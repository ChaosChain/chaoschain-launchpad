{"input": "Explain the Ethereum concept: What Is Ethereum?", "output": "(((\"Ethereum (generally)\",\"about\", id=\"ix_01what-is-asciidoc0\", range=\"startofrange\")))Ethereum (((\"world computer, Ethereum as\")))is often described as \"the world computer.&#x201d; But what does that mean? Let's start with a computer science\u2013focused description, and then try to decipher that with a more practical analysis of Ethereum's capabilities and characteristics, while comparing it to Bitcoin and other decentralized information exchange platforms (or \"blockchains\" for short).\n\nFrom a computer science perspective, Ethereum is a deterministic but practically unbounded state machine, consisting of a globally accessible singleton state and a virtual machine that applies changes to that state.\n\nFrom a more practical perspective, Ethereum is an open source, globally decentralized computing infrastructure that executes programs called _smart contracts_. It uses a blockchain to synchronize and store the system\u2019s state changes, along with a cryptocurrency called _ether_ to meter and constrain execution resource costs.\n\nThe Ethereum platform enables developers to build powerful decentralized applications with built-in economic functions. While providing high availability, auditability, transparency, and neutrality, it also reduces or eliminates censorship and reduces certain counterparty risks.\n\n[[bitcoin_comparison]]", "metadata": {"source": "ethereumbook", "chapter": "01what-is.asciidoc", "section": "What Is Ethereum?"}}
{"input": "Explain the Ethereum concept: Compared to Bitcoin", "output": "(((\"Bitcoin\",\"Ethereum compared to\")))(((\"Ethereum (generally)\",\"Bitcoin compared to\")))Many people will come to Ethereum with some prior experience of cryptocurrencies, specifically Bitcoin. Ethereum shares many common elements with other open blockchains: a peer-to-peer network connecting participants, a Byzantine fault&#x2013;tolerant consensus algorithm for synchronization of state updates (a proof-of-work blockchain), the use of cryptographic primitives such as digital signatures and hashes, and a digital currency (ether).\n\nYet in many ways, both the purpose and construction of Ethereum are strikingly different from those of the open blockchains that preceded it, including Bitcoin.\n\n(((\"Ethereum (generally)\",\"purpose of\")))Ethereum's purpose is not primarily to be a digital currency payment network. (((\"utility currency, ether as\")))While the digital currency ether is both integral to and necessary for the operation of Ethereum, ether is intended as a _utility currency_ to pay for use of the Ethereum platform as the world computer.\n\nUnlike Bitcoin, which has a very limited scripting language, Ethereum is designed to be a general-purpose programmable blockchain that runs a _virtual machine_ capable of executing code of arbitrary and unbounded complexity. Where Bitcoin's Script language is, intentionally, constrained to simple true/false evaluation of spending conditions, Ethereum's language is _Turing complete_, meaning that Ethereum can straightforwardly function as a general-purpose computer.\n\n[[blockchain_components]]", "metadata": {"source": "ethereumbook", "chapter": "01what-is.asciidoc", "section": "Compared to Bitcoin"}}
{"input": "Explain the Ethereum concept: Components of a Blockchain", "output": "(((\"blockchain\",\"components of\")))(((\"Ethereum (generally)\",\"blockchain components\")))The components of an open, public blockchain are (usually):\n\n* A peer-to-peer (P2P) network connecting participants and propagating transactions and blocks of verified transactions, based on a standardized \"gossip\" pass:[<span class=\"keep-together\">protocol</span>]\n* Messages, in the form of transactions, representing state transitions\n* A set of consensus rules, governing what constitutes a transaction and what makes for a valid state transition\n* A state machine that processes transactions according to the consensus rules\n* A chain of cryptographically secured blocks that acts as a journal of all the verified and accepted state transitions\n* A consensus algorithm that decentralizes control over the blockchain, by forcing participants to cooperate in the enforcement of the consensus rules\n* A game-theoretically sound incentivization scheme (e.g., proof-of-work costs plus block rewards) to economically secure the state machine in an open pass:[<span class=\"keep-together\">environment</span>]\n* One or more open source software implementations of the above (\"clients\")\n\nAll or most of these components are usually combined in a single software client. For example, in (((\"Bitcoin Core\")))(((\"bitcoind client\")))Bitcoin, the reference implementation is developed by the _Bitcoin Core_ open source project and implemented as the _bitcoind_ client. In Ethereum, rather than a reference implementation there is a (((\"reference specification\")))_reference specification_, a mathematical description of the system in the Yellow Paper (see <<references>>). There are a number of clients, which are built according to the reference specification.\n\nIn the past, we used the term \"blockchain\" to represent all of the components just listed, as a shorthand reference to the combination of technologies that encompass all of the characteristics described. Today, however, there are a huge variety of blockchains with different properties. We need qualifiers to help us understand the characteristics of the blockchain in question, such as _open, public, global, decentralized, neutral,_ and _censorship-resistant_, to identify the important emergent characteristics of a \"blockchain\" system that these components allow.\n\nNot all blockchains are created equal. When someone tells you that something is a blockchain, you have not received an answer; rather, you need to start asking a lot of questions to clarify what they mean when they use the word \"blockchain.\" Start by asking for a description of the components in the preceding list, then ask whether this \"blockchain\" exhibits the characteristics of being _open, public_, etc.\n\n[[ethereum_birth]]", "metadata": {"source": "ethereumbook", "chapter": "01what-is.asciidoc", "section": "Components of a Blockchain"}}
{"input": "Explain the Ethereum concept: The Birth of Ethereum", "output": "(((\"Ethereum (generally)\",\"birth of\")))All great innovations solve real problems, and Ethereum is no exception. Ethereum was conceived at a time when people recognized the power of the Bitcoin model, and were trying to move beyond cryptocurrency applications. But developers faced a conundrum: they either needed to build on top of Bitcoin or start a new blockchain. (((\"Bitcoin\",\"limitations of\")))Building upon Bitcoin meant living within the intentional constraints of the network and trying to find workarounds. The limited set of transaction types, data types, and sizes of data storage seemed to limit the sorts of applications that could run directly on Bitcoin; anything else needed additional off-chain layers, and that immediately negated many of the advantages of using a public blockchain. For projects that needed more freedom and flexibility while staying on-chain, a new blockchain was the only option. But that meant a lot of work: bootstrapping all the infrastructure elements, exhaustive testing, etc.\n\n(((\"Buterin, Vitalik\",\"and birth of Ethereum\")))Toward the end of 2013, Vitalik Buterin, a young programmer and Bitcoin enthusiast, started thinking about further extending the capabilities of Bitcoin and Mastercoin (an overlay protocol that extended Bitcoin to offer rudimentary smart contracts). In October of that year, Vitalik proposed a more generalized approach to the Mastercoin team, one that allowed flexible and scriptable (but not Turing-complete) contracts to replace the specialized contract language of Mastercoin. While the Mastercoin team were impressed, this proposal was too radical a change to fit into their development roadmap.\n\nIn December 2013, Vitalik started sharing a whitepaper that outlined the idea behind Ethereum: a Turing-complete, general-purpose blockchain. A few dozen people saw this early draft and offered feedback, helping Vitalik evolve the proposal.\n\nBoth of the authors of this book received an early draft of the whitepaper and commented on it. Andreas M. Antonopoulos was intrigued by the idea and asked Vitalik many questions about the use of a separate blockchain to enforce consensus rules on smart contract execution and the implications of a Turing-complete language. Andreas continued to follow Ethereum's progress with great interest but was in the early stages of writing his book _Mastering Bitcoin_, and did not participate directly in Ethereum until much later. (((\"Wood, Dr. Gavin\",\"and birth of Ethereum\")))Dr. Gavin Wood, however, was one of the first people to reach out to Vitalik and offer to help with his C++ programming skills. Gavin became Ethereum's cofounder, codesigner, and CTO.\n\nAs Vitalik recounts in his http://bit.ly/2T2t6zs[\"Ethereum Prehistory\" post]: \n\n____\nThis was the time when the Ethereum protocol was entirely my own creation. From here on, however, new participants started to join the fold. By far the most prominent on the protocol side was Gavin Wood...\n\nGavin can also be largely credited for the subtle change in vision from viewing Ethereum as a platform for building programmable money, with blockchain-based contracts that can hold digital assets and transfer them according to pre-set rules, to a general-purpose computing platform. This started with subtle changes in emphasis and terminology, and later this influence became stronger with the increasing emphasis on the \u201cWeb 3\u201d ensemble, which saw Ethereum as being one piece of a suite of decentralized technologies, the other two being Whisper and Swarm.\n____\n\nStarting in December 2013, Vitalik and Gavin refined and evolved the idea, together building the protocol layer that became Ethereum.\n\nEthereum's founders were thinking about a blockchain without a specific purpose, that could support a broad variety of applications by being _programmed_. The idea was that by using a general-purpose blockchain like Ethereum, a developer could program their particular application without having to implement the underlying mechanisms of peer-to-peer networks, blockchains, consensus algorithms, etc. The Ethereum platform was designed to abstract these details and provide a deterministic and secure programming environment for decentralized blockchain applications.\n\nMuch like Satoshi, Vitalik and Gavin didn't just invent a new technology; they combined new inventions with existing technologies in a novel way and delivered the prototype code to prove their ideas to the world.\n\nThe founders worked for years, building and refining the vision. And on July 30, 2015, the first Ethereum block was mined. The world's computer started serving the world.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "01what-is.asciidoc", "section": "The Birth of Ethereum"}}
{"input": "Explain the Ethereum concept: Ethereum's Four Stages of Development", "output": "(((\"Ethereum (generally)\",\"four stages of development\")))Ethereum's development was planned over four distinct stages, with major changes occurring at each stage. (((\"hard forks\", seealso=\"DAO; other specific hard forks, e.g.: Spurious Dragon\")))A stage may include subreleases, known as \"hard forks,\" that change functionality in a way that is not backward compatible.\n\nThe four main development stages are codenamed _Frontier_, _Homestead_, _Metropolis_, and _Serenity_. The intermediate hard forks that have occurred to date are codenamed _Ice Age_, _DAO_, _Tangerine Whistle_, _Spurious Dragon_, _Byzantium_, _Constantinople/St. Petersburg_, _Istanbul_ and _Muir Glacier_. Both the development stages and the intermediate hard forks are shown on the following timeline, which is \"dated\" by  block number:\n\n\nBlock #0:: (((\"Frontier\")))__Frontier__&#x2014;The initial stage of Ethereum, lasting from July 30, 2015, to March 2016.\n\nBlock #200,000:: (((\"Ice Age\")))__Ice Age__&#x2014;A hard fork to introduce an exponential difficulty increase, to motivate a transition to PoS when ready.\n\nBlock #1,150,000:: (((\"Homestead\")))__Homestead__&#x2014;The second stage of Ethereum, launched in March 2016.\n\nBlock #1,192,000:: (((\"DAO (Decentralized Autonomous Organization)\")))__DAO__&#x2014;A hard fork that reimbursed victims of the hacked DAO contract and caused Ethereum and Ethereum Classic to split into two competing systems.\n\nBlock #2,463,000:: (((\"Tangerine Whistle\")))__Tangerine Whistle__&#x2014;A hard fork to change the gas calculation for certain I/O-heavy operations and to clear the accumulated state from a denial-of-service (DoS) attack that exploited the low gas cost of those operations.\n\nBlock #2,675,000:: (((\"Spurious Dragon\")))__Spurious Dragon__&#x2014;A hard fork to address more DoS attack vectors, and another state clearing. Also, a replay attack protection mechanism.\n\nBlock #4,370,000:: (((\"Metropolis\")))(((\"Byzantium fork\")))__Metropolis Byzantium__&#x2014;Metropolis is the third stage of Ethereum. Launched in October 2017, Byzantium is the first part of Metropolis, adding low-level functionalities and adjusting the block reward and difficulty.\n\nBlock #7,280,000:: (((\"Constantinople fork\")))(((\"St. Petersburg fork\")))__Constantinople / St. Petersburg__&#x2014;Constantinople was planned to be the second part of Metropolis with similar improvements. A few hours before its activation, a https://bit.ly/2Ast7rz[critical bug] was discovered. The hard fork was therefore postponed and renamed St. Petersburg.\n\nBlock #9,069,000:: (((\"Istanbul fork\")))__Istanbul__&#x2014;An additional hard fork with the same approach, and naming convention, as for the prior two.\n\nBlock #9,200,000:: (((\"Muir Glacier\u200afork\")))__Muir Glacier__&#x2014;A hard fork whose sole purpose was to adjust the difficulty again due to the exponential increase introduced by Ice Age.\n\n(((\"Serenity\")))(((\"Ethereum 2.0\")))Two hard forks, Berlin and London, have also been announced, and we are now in the final stage of Ethereum development, codenamed Serenity. Serenity involves a profound reorganization of the infrastructure that will make Ethereum more scalable, more secure, and more sustainable. It is presented as the second version of Ethereum, \"Ethereum 2.0\".\n\n\n[[general_purpose_blockchain]]", "metadata": {"source": "ethereumbook", "chapter": "01what-is.asciidoc", "section": "Ethereum's Four Stages of Development"}}
{"input": "Explain the Ethereum concept: Ethereum: A General-Purpose Blockchain", "output": "(((\"Bitcoin\",\"Ethereum blockchain compared to Bitcoin blockchain\")))(((\"Ethereum (generally)\",\"as general-purpose blockchain\")))The original blockchain, namely Bitcoin's blockchain, tracks the state of units of bitcoin and their ownership. (((\"distributed state machine, Ethereum as\")))You can think of Bitcoin as a distributed consensus _state machine_, where transactions cause a global _state transition_, altering the ownership of coins. The state transitions are constrained by the rules of consensus, allowing all participants to (eventually) converge on a common (consensus) state of the system, after several blocks are mined.\n\nEthereum is also a distributed state machine. But instead of tracking only the state of currency ownership, (((\"key-value tuple\")))Ethereum tracks the state transitions of a general-purpose data store, i.e., a store that can hold any data expressible as a _key\u2013value tuple_. A key\u2013value data store holds arbitrary values, each referenced by some key; for example, the value \"Mastering Ethereum\" referenced by the key \"Book Title\". In some ways, this serves the same purpose as the data storage model of _Random Access Memory_ (RAM) used by most general-purpose computers. Ethereum has memory that stores both code and data, and it uses the Ethereum blockchain to track how this memory changes over time. Like a general-purpose stored-program computer, Ethereum can load code into its state machine and _run_ that code, storing the resulting state changes in its blockchain. Two of the critical differences from most general-purpose computers are that Ethereum state changes are governed by the rules of consensus and the state is distributed globally. Ethereum answers the question: \"What if we could track any arbitrary state and program the state machine to create a world-wide computer operating under consensus?\"\n\n[[ethereum_components]]", "metadata": {"source": "ethereumbook", "chapter": "01what-is.asciidoc", "section": "Ethereum: A General-Purpose Blockchain"}}
{"input": "Explain the Ethereum concept: Ethereum's Components", "output": "(((\"blockchain\",\"components of\")))(((\"Ethereum (generally)\",\"blockchain components\")))In Ethereum, the components of a blockchain system described in <<blockchain_components>> are, more specifically:\n\n\nP2P network:: Ethereum runs on the _Ethereum main network_, which is addressable on TCP port 30303, and runs a protocol called _\u00d0\u039eVp2p_.\n\nConsensus rules:: Ethereum's consensus rules are defined in the reference specification, the Yellow Paper (see <<references>>).\n\nTransactions:: Ethereum transactions are network messages that include (among other things) a sender, recipient, value, and data payload.\n\n[role=\"pagebreak-before\"]\nState machine:: Ethereum state transitions are processed by the _Ethereum Virtual Machine_ (EVM), a stack-based virtual machine that executes _bytecode_ (machine-language instructions). EVM programs, called \"smart contracts,\" are written in high-level languages (e.g., Solidity) and compiled to bytecode for execution on the EVM.\n\nData structures:: Ethereum's state is stored locally on each node as a _database_ (usually Google's LevelDB), which contains the transactions and system state in a serialized hashed data structure called a _Merkle Patricia Tree_.\n\nConsensus algorithm:: Ethereum uses Bitcoin's consensus model, Nakamoto Consensus, which uses sequential single-signature blocks, weighted in importance by PoW to determine the longest chain and therefore the current state. However, there are plans to move to a PoS weighted voting system, codenamed _Casper_, in the near future.\n\nEconomic security:: Ethereum currently uses a PoW algorithm called _Ethash_, but this will eventually be dropped with the move to PoS at some point in the future.\n\nClients:: Ethereum has several interoperable implementations of the client software, the most prominent of which are _Go-Ethereum_ (_Geth_) and _Parity_.\n\n[[references]]", "metadata": {"source": "ethereumbook", "chapter": "01what-is.asciidoc", "section": "Ethereum's Components"}}
{"input": "Explain the Ethereum concept: Further Reading", "output": "The following references provide additional information on the technologies mentioned here:\n\n* The Ethereum Yellow Paper:\nhttps://ethereum.github.io/yellowpaper/paper.pdf\n\n* The Beige Paper, a rewrite of the Yellow Paper for a broader audience in less formal language:\nhttps://github.com/chronaeon/beigepaper\n\n* \u00d0\u039eVp2p network protocol:\nhttps://github.com/ethereum/devp2p/blob/master/rlpx.md\n\n* Ethereum Virtual Machine list of resources:\nhttps://eth.wiki/en/concepts/evm/ethereum-virtual-machine-(evm)-awesome-list\n\n* LevelDB database (used most often to store the local copy of the blockchain):\nhttps://github.com/google/leveldb\n\n* Merkle Patricia trees:\nhttps://eth.wiki/en/fundamentals/patricia-tree\n\n* Ethash PoW algorithm:\nhttps://eth.wiki/en/concepts/ethash/ethash\n\n* Casper PoS v1 Implementation Guide:\nhttp://bit.ly/2DyPr3l\n\n* Go-Ethereum (Geth) client:\nhttps://geth.ethereum.org/\n\n* Parity Ethereum client:\nhttps://parity.io/\n\n[[turing_completeness]]", "metadata": {"source": "ethereumbook", "chapter": "01what-is.asciidoc", "section": "Further Reading"}}
{"input": "Explain the Ethereum concept: Ethereum and Turing Completeness", "output": "(((\"Ethereum (generally)\",\"Turing completeness and\")))(((\"Turing completeness\",\"Ethereum and\")))As soon as you start reading about Ethereum, you will immediately encounter the term \"Turing complete.\" Ethereum, they say, unlike Bitcoin, is Turing complete. What exactly does that mean?\n\n(((\"Turing, Alan\")))The term refers to English mathematician Alan Turing, who is considered the father of computer science. In 1936 he created a mathematical model of a computer consisting of a state machine that manipulates symbols by reading and writing them on sequential memory (resembling an infinite-length paper tape). With this construct, Turing went on to provide a mathematical foundation to answer (in the negative) questions about _universal computability_, meaning whether all problems are solvable. He proved that there are classes of problems that are uncomputable. (((\"halting problem\")))Specifically, he proved that the _halting problem_ (whether it is possible, given an arbitrary program and its input, to determine whether the program will eventually stop running) is not solvable.\n\n(((\"Universal Turing machine (UTM)\")))(((\"UTM (Universal Turing machine)\")))Alan Turing further defined a system to be _Turing complete_ if it can be used to simulate any Turing machine. Such a system is called a _Universal Turing machine_ (UTM).\n\nEthereum's ability to execute a stored program, in a state machine called the Ethereum Virtual Machine, while reading and writing data to memory makes it a Turing-complete system and therefore a UTM. Ethereum can compute any algorithm that can be computed by any Turing machine, given the limitations of finite memory.\n\nEthereum's groundbreaking innovation is to combine the general-purpose computing architecture of a stored-program computer with a decentralized blockchain, thereby creating a distributed single-state (singleton) world computer. Ethereum programs run \"everywhere,\" yet produce a common state that is secured by the rules of pass:[<span class=\"keep-together\">consensus</span>].\n\n[[turing_completeness_feature]]", "metadata": {"source": "ethereumbook", "chapter": "01what-is.asciidoc", "section": "Ethereum and Turing Completeness"}}
{"input": "Explain the Ethereum concept: Turing Completeness as a \"Feature\"", "output": "(((\"Turing completeness\",\"as feature\")))Hearing that Ethereum is Turing complete, you might arrive at the conclusion that this is a _feature_ that is somehow lacking in a system that is Turing incomplete. Rather, it is the opposite. Turing completeness is very easy to achieve; in fact, http://bit.ly/2ABft33[the simplest Turing-complete state machine known]  has 4 states and uses 6 symbols, with a state definition that is only 22 instructions long. Indeed, sometimes systems are found to be \"accidentally Turing complete.\" A fun reference of such systems can be found at http://bit.ly/2Og1VgX[].\n\nHowever, Turing completeness is very dangerous, particularly in open access systems like public blockchains, because of the halting problem we touched on earlier. For example, modern printers are Turing complete and can be given files to print that send them into a frozen state. The fact that Ethereum is Turing complete means that any program of any complexity can be computed by Ethereum. But that flexibility brings some thorny security and resource management problems. An unresponsive printer can be turned off and turned back on again. That is not possible with a public blockchain.\n\n[[turing_completeness_implications]]", "metadata": {"source": "ethereumbook", "chapter": "01what-is.asciidoc", "section": "Turing Completeness as a \"Feature\""}}
{"input": "Explain the Ethereum concept: Implications of Turing Completeness", "output": "(((\"Turing completeness\",\"implications of\")))Turing proved that you cannot predict whether a program will terminate by simulating it on a computer. In simple terms, we cannot predict the path of a program without running it. (((\"infinite loops\")))Turing-complete systems can run in \"infinite loops,\" a term used (in oversimplification) to describe a program that does not terminate. It is trivial to create a program that runs a loop that never ends. But unintended never-ending loops can arise without warning, due to complex interactions between the starting conditions and the code. In Ethereum, this poses a challenge: every participating node (client) must validate every transaction, running any smart contracts it calls. But as Turing proved, Ethereum can't predict if a smart contract will terminate, or how long it will run, without actually running it (possibly running forever). Whether by accident or on purpose, a smart contract can be created such that it runs forever when a node attempts to validate it. This is effectively a DoS attack. And of course, between a program that takes a millisecond to validate and one that runs forever are an infinite range of nasty, resource-hogging, memory-bloating, CPU-overheating programs that simply waste resources. In a world computer, a program that abuses resources gets to abuse the world's resources. How does Ethereum constrain the resources used by a smart contract if it cannot predict resource use in advance?\n\n(((\"EVM (Ethereum Virtual Machine)\",\"gas and\")))(((\"gas\",\"as counter to Turing completeness\")))To answer this challenge, Ethereum introduces a metering mechanism called _gas_. As the EVM executes a smart contract, it carefully accounts for every instruction (computation, data access, etc.). Each instruction has a predetermined cost in units of gas. When a transaction triggers the execution of a smart contract, it must include an amount of gas that sets the upper limit of what can be consumed running the smart contract. The EVM will terminate execution if the amount of gas consumed by computation exceeds the gas available in the transaction. Gas is the mechanism Ethereum uses to allow Turing-complete computation while limiting the resources that any program can consume.\n\nThe next question is, 'how does one get gas to pay for computation on the Ethereum world computer?' You won't find gas on any exchanges. (((\"ether (generally)\",\"gas and\")))It can only be purchased as part of a transaction, and can only be bought with ether. Ether needs to be sent along with a transaction and it needs to be explicitly earmarked for the purchase of gas, along with an acceptable gas price. Just like at the pump, the price of gas is not fixed. Gas is purchased for the transaction, the computation is executed, and any unused gas is refunded back to the sender of the transaction.\n\n[[DApp]]", "metadata": {"source": "ethereumbook", "chapter": "01what-is.asciidoc", "section": "Implications of Turing Completeness"}}
{"input": "Explain the Ethereum concept: From General-Purpose Blockchains to Decentralized Applications (DApps)", "output": "(((\"DApps (decentralized applications)\",\"Ethereum as platform for\")))(((\"Ethereum (generally)\",\"DApps and\")))Ethereum started as a way to make a general-purpose blockchain that could be programmed for a variety of uses. But very quickly, Ethereum's vision expanded to become a platform for programming DApps. DApps represent a broader perspective than smart contracts. A DApp is, at the very least, a smart contract and a web user interface. More broadly, a DApp is a web application that is built on top of open, decentralized, peer-to-peer infrastructure services.\n\nA DApp is composed of at least:\n\n- Smart contracts on a blockchain\n- A web frontend user interface\n\nIn addition, many DApps include other decentralized components, such as:\n\n- A decentralized (P2P) storage protocol and platform\n- A decentralized (P2P) messaging protocol and platform\n\n[TIP]", "metadata": {"source": "ethereumbook", "chapter": "01what-is.asciidoc", "section": "From General-Purpose Blockchains to Decentralized Applications (DApps)"}}
{"input": "Explain the Ethereum concept: The Third Age of the Internet", "output": "(((\"DApps (decentralized applications)\",\"web3 and\")))(((\"Ethereum (generally)\",\"web3 and\")))(((\"web3\")))In 2004 the term \"Web 2.0\" came to prominence, describing an evolution of the web toward user-generated content, responsive interfaces, and interactivity. Web 2.0 is not a technical specification, but rather a term describing the new focus of web pass:[<span class=\"keep-together\">applications</span>].\n\nThe concept of DApps is meant to take the World Wide Web to its next natural evolutionary stage, introducing decentralization with peer-to-peer protocols into every aspect of a web application. The term used to describe this evolution is _web3_, meaning the third \"version\" of the web. (((\"Wood, Dr. Gavin\",\"and web3\")))First proposed by Dr. Gavin Wood, web3 represents a new vision and focus for web applications: from centrally owned and managed applications, to applications built on decentralized protocols.\n\nIn later chapters we'll explore the Ethereum web3.js JavaScript library, which bridges JavaScript applications that run in your browser with the Ethereum blockchain. The web3.js library also includes an interface to a P2P storage network called _Swarm_ and a P2P messaging service called _Whisper_. With these three components included in a JavaScript library running in your web browser, developers have a full application development suite that allows them to build web3 DApps.\n\n[[development_culture]]", "metadata": {"source": "ethereumbook", "chapter": "01what-is.asciidoc", "section": "The Third Age of the Internet"}}
{"input": "Explain the Ethereum concept: Ethereum's Development Culture", "output": "(((\"development culture, Ethereum\")))(((\"Ethereum (generally)\",\"development culture\")))So far we've talked about how Ethereum's goals and technology differ from those of other blockchains that preceded it, like Bitcoin. Ethereum also has a very different development culture.\n\n(((\"Bitcoin\",\"development culture\")))In Bitcoin, development is guided by conservative principles: all changes are carefully studied to ensure that none of the existing systems are disrupted. For the most part, changes are only implemented if they are backward compatible. Existing clients are allowed to opt-in, but will continue to operate if they decide not to upgrade.\n\n(((\"backward compatibility, Ethereum vs. Bitcoin\")))In Ethereum, by comparison, the community's development culture is focused on the future rather than the past. The (not entirely serious) mantra is \"move fast and break things.\" If a change is needed, it is implemented, even if that means invalidating prior assumptions, breaking compatibility, or forcing clients to update. Ethereum's development culture is characterized by rapid innovation, rapid evolution, and a willingness to deploy forward-looking improvements, even if this is at the expense of some backward compatibility.\n\nWhat this means to you as a developer is that you must remain flexible and be prepared to rebuild your infrastructure as some of the underlying assumptions change. One of the big challenges facing developers in Ethereum is the inherent contradiction between deploying code to an immutable system and a development platform that is still evolving. You can't simply \"upgrade\" your smart contracts. You must be prepared to deploy new ones, migrate users, apps, and funds, and start over.\n\nIronically, this also means that the goal of building systems with more autonomy and less centralized control is still not fully realized. Autonomy and decentralization require a bit more stability in the platform than you're likely to get in Ethereum in the next few years. In order to \"evolve\" the platform, you have to be ready to scrap and restart your smart contracts, which means you have to retain a certain degree of control over them.\n\nBut, on the positive side, Ethereum is moving forward very fast. There's little opportunity for \"bike-shedding,\" an expression that means holding up development by arguing over minor details such as how to build the bicycle shed at the back of a nuclear power station. If you start bike-shedding, you might suddenly discover that while you were distracted the rest of the development team changed the plan and ditched bicycles in favor of autonomous hovercraft.\n\nEventually, the development of the Ethereum platform will slow down and its interfaces will become fixed. But in the meantime, innovation is the driving principle. You'd better keep up, because no one will slow down for you.\n\n[[why_learn]]", "metadata": {"source": "ethereumbook", "chapter": "01what-is.asciidoc", "section": "Ethereum's Development Culture"}}
{"input": "Explain the Ethereum concept: Why Learn Ethereum?", "output": "(((\"blockchain\",\"Ethereum as developer&#39;s blockchain\")))(((\"Ethereum (generally)\",\"reasons to learn\")))Blockchains have a very steep learning curve, as they combine multiple disciplines into one domain: programming, information security, cryptography, economics, distributed systems, peer-to-peer networks, etc. Ethereum makes this learning curve a lot less steep, so you can get started quickly. But just below the surface of a deceptively simple environment lies a lot more. As you learn and start looking deeper, there's always another layer of complexity and wonder.\n\nEthereum is a great platform for learning about blockchains and it's building a massive community of developers, faster than any other blockchain platform. More than any other, Ethereum is a _developer's blockchain_, built by developers for developers. A developer familiar with JavaScript applications can drop into Ethereum and start producing working code very quickly. For the first few years of Ethereum's life, it was common to see T-shirts announcing that you can create a token in just five lines of code. Of course, this is a double-edged sword. It's easy to write code, but it's very hard to write _good_ and _secure_ code.\n\n[[teaching_objectives]]", "metadata": {"source": "ethereumbook", "chapter": "01what-is.asciidoc", "section": "Why Learn Ethereum?"}}
{"input": "Explain the Ethereum concept: What This Book Will Teach You", "output": "This book dives into Ethereum and examines every component. You will start with a simple transaction, dissect how it works, build a simple contract, make it better, and follow its journey through the Ethereum system.\n\nYou will learn not only how to use Ethereum&#x2014;how it works&#x2014;but also why it is designed the way it is. You will be able to understand how each of the pieces works, and how they fit together and why.(((range=\"endofrange\", startref=\"ix_01what-is-asciidoc0\")))(((\"account\",\"contract\", see=\"smart contracts\")))(((\"assymetric cryptography\", see=\"public key cryptography\")))(((\"BIPs\", see=\"Bitcoin improvement proposals\")))(((\"burn\", see=\"ether burn\")))(((\"cryptography\",\"asymmetric\", see=\"public key cryptography\")))(((\"decentralized applications\", see=\"DApps\")))(((\"Decentralized Autonomous Organization\", see=\"DAO\")))(((\"default function\", see=\"fallback function\")))(((\"deterministic (seeded) wallets\",\"hierarchical\", see=\"hierarchical deterministic wallets\")))(((\"DoS attacks\", see=\"denial of service attacks\")))(((\"ECDSA\", see=\"Elliptic Curve Digital Signature Algorithm\")))(((\"ETC\", see=\"Ethereum Classic\")))(((\"Ethereum (generally)\",\"clients\", see=\"clients, Ethereum\")))(((\"Ethereum Improvement Proposals\", see=\"EIP entries\")))(((\"Ethereum Name Service\", see=\"ENS\")))(((\"Ethereum Virtual Machine\", see=\"EVM\")))(((\"Externally Owned Account\", see=\"EOA\")))(((\"fees\", see=\"gas\")))(((\"ICOs\", see=\"Initial Coin Offerings\")))(((\"Mastering Ethereum Token\", see=\"METoken\")))(((\"MEW\", see=\"MyEtherWallet\")))(((\"names/naming\", see=\"ENS (Ethereum Name Service)\")))(((\"NFTs\", see=\"nonfungible tokens\")))(((\"PoS\", see=\"proof of stake\")))(((\"PoW\", see=\"proof of work\")))(((\"PoWHC\", see=\"Proof of Weak Hands Coin\")))(((\"Remote Procedure Call (RPC) commands\", see=\"JSON-RPC API\")))(((\"RPC (Remote Procedure Call) commands\", see=\"JSON-RPC API\")))(((\"Secure Hash Algorithm\", see=\"SHA entries\")))(((\"seeded wallets\", see=\"deterministic wallets\")))(((\"smart contracts\",\"Vyper and\", see=\"Vyper\")))(((\"smartphones\", see=\"mobile (smartphone) wallets\")))(((\"storage\", see=\"data storage\")))(((\"SUICIDE\", see=\"SELFDESTRUCT opcode\")))(((\"synchronization\", see=\"fast synchronization\")))(((\"synchronization\", see=\"first synchronization\")))(((\"transaction fees\", see=\"gas\")))(((\"wallets\",\"HD\", see=\"hierarchical deterministic wallets\")))(((\"wallets\",\"MetaMask\", see=\"MetaMask\")))", "metadata": {"source": "ethereumbook", "chapter": "01what-is.asciidoc", "section": "What This Book Will Teach You"}}
{"input": "Explain the Ethereum concept: Ethereum Basics", "output": "(((\"Ethereum (generally)\",\"basics\", id=\"ix_02intro-asciidoc0\", range=\"startofrange\")))In this chapter we will start exploring Ethereum, learning how to use wallets, how to create transactions, and also how to run a basic smart contract.\n\n[[ether_units]]", "metadata": {"source": "ethereumbook", "chapter": "02intro.asciidoc", "section": "Ethereum Basics"}}
{"input": "Explain the Ethereum concept: Ether Currency Units", "output": "(((\"currency units\")))(((\"Ethereum (generally)\",\"currency units\")))Ethereum's currency unit is called _ether_, identified also as \"ETH\" or with the symbols &#926; (from the Greek letter \"Xi\" that looks like a stylized capital E) or, less often, &#9830;: for example, 1 ether, or 1 ETH, or &#926;1, or &#9830;1.\n\n[TIP]", "metadata": {"source": "ethereumbook", "chapter": "02intro.asciidoc", "section": "Ether Currency Units"}}
{"input": "Explain the Ethereum concept: Choosing an Ethereum Wallet", "output": "(((\"Ethereum (generally)\",\"wallet choices\")))(((\"wallets\",\"choosing\")))(((\"wallets\",\"defined\")))The term \"wallet\" has come to mean many things, although they are all related and on a day-to-day basis boil down to pretty much the same thing. We will use the term \"wallet\" to mean a software application that helps you manage your Ethereum account. In short, an Ethereum wallet is your gateway to the Ethereum system. It holds your keys and can create and broadcast transactions on your behalf. Choosing an Ethereum wallet can be difficult because there are many different options with different features and designs. Some are more suitable for beginners and some are more suitable for experts. The Ethereum platform itself is still being improved, and the \"best\" wallets are often the ones that adapt to the changes that come with the platform upgrades.\n\nBut don't worry! If you choose a wallet and don't like how it works&#x2014;or if you like it at first but later want to try something else&#x2014;you can change wallets quite easily. All you have to do is make a transaction that sends your funds from the old wallet to the new wallet, or export your private keys and import them into the new one.\n\nWe've selected a few different types of wallets to use as examples throughout the book. Some are for mobile, desktop, and others are web-based. We've chosen different wallets because they represent a broad range of complexity and features. However, the selection of these wallets is not an endorsement of their quality or security. They are simply a good starting place for demonstrations and testing.\n\n(((\"private keys\",\"wallets and\")))Remember that for a wallet application to work, it must have access to your private keys, so it is vital that you only download and use wallet applications from sources you trust. Fortunately, in general, the more popular a wallet application is, the more trustworthy it is likely to be. Nevertheless, it is good practice to avoid \"putting all your eggs in one basket\" and have your Ethereum accounts spread across a couple of wallets.\n\nThe following are some good starter wallets:\n\nMetaMask:: (((\"MetaMask\")))MetaMask is a browser extension wallet that runs in your browser (Chrome, Firefox, Opera, or Brave Browser). It is easy to use and convenient for testing, as it is able to connect to a variety of Ethereum nodes and test blockchains. MetaMask is a web-based wallet that also includes mobile apps for both iOS and Android.\n\nJaxx:: (((\"Jaxx\")))(((\"wallets\",\"Jaxx\")))Jaxx is a multiplatform and multicurrency wallet that runs on a variety of operating systems, including Android, iOS, Windows, macOS, and Linux. It is often a good choice for new users as it is designed for simplicity and ease of use. Jaxx is either a mobile or a desktop wallet, depending on where you install it.\n\nMyEtherWallet (MEW):: (((\"MyEtherWallet (MEW)\")))(((\"wallets\",\"MyEtherWallet\")))MyEtherWallet is primarily a web-based wallet that runs in any browser. It is also available on Android and iOS. It has multiple sophisticated features we will explore in many of our examples.\n\nEmerald Wallet:: (((\"Ethereum Classic (ETC)\",\"Emerald Wallet and\")))(((\"wallets\",\"Emerald Wallet\")))(((\"Emerald Wallet\")))Emerald Wallet is designed to work with the Ethereum Classic blockchain, but is compatible with other Ethereum-based blockchains. It's an open source desktop application and works under Windows, macOS, and Linux. Emerald Wallet can run a full node or connect to a public remote node, working in a \"light\" mode. It also has a companion tool to do all operations from the command line.\n\nWe'll start by installing MetaMask on a desktop&#x2014;but first, we'll briefly discuss controlling and managing keys.\n\n[[control_responsibility]]", "metadata": {"source": "ethereumbook", "chapter": "02intro.asciidoc", "section": "Choosing an Ethereum Wallet"}}
{"input": "Explain the Ethereum concept: Control and Responsibility", "output": "(((\"Ethereum (generally)\",\"control and responsibility\", id=\"ix_02intro-asciidoc1\", range=\"startofrange\")))Open blockchains like Ethereum are important because they operate as a _decentralized_ system. That means lots of things, but one crucial aspect is that each user of Ethereum can&#x2014;and should&#x2014;control their own private keys, which are the things that control access to funds and smart contracts. We sometimes call the combination of access to funds and smart contracts an \"account\" or \"wallet.\" These terms can get quite complex in their functionality, so we will go into this in more detail later. As a fundamental principle, however, it is as easy as one private key equals one \"account.\" Some users choose to give up control over their private keys by using a third-party custodian, such as an online exchange. In this book, we will teach you how to take control and manage your own private keys.\n\nWith control comes a big responsibility. If you lose your private keys, you lose access to your funds and contracts. No one can help you regain access&#x2014;your funds will be locked forever. Here are a few tips to help you manage this responsibility:\n\n* Do not improvise security. Use tried-and-tested standard approaches.\n\n* The more important the account (e.g., the higher the value of the funds controlled, or the more significant the smart contracts accessible), the higher security measures should be taken.\n\n* The highest security is gained from an air-gapped device, but this level is not required for every account.\n\n* Never store your private key in plain form, especially digitally. Fortunately, most user interfaces today won't even let you see the raw private key.\n\n* (((\"private keys\",\"wallets and\")))Private keys can be stored in an encrypted form, as a digital \"keystore\" file. Being encrypted, they need a password to unlock. When you are prompted to choose a password, make it strong (i.e., long and random), back it up, and don't share it. If you don't have a password manager, write it down and store it in a safe and secret place. To access your account, you need both the keystore file and the password.\n\n* Do not store any passwords in digital documents, digital photos, screenshots, online drives, encrypted PDFs, etc. Again, do not improvise security. Use a password manager or pen and paper.\n\n* When you are prompted to back up a key as a mnemonic word sequence, use pen and paper to make a physical backup. Do not leave that task \"for later\"; you will forget. These backups can be used to rebuild your private key in case you lose all the data saved on your system, or if you forget or lose your password. However, they can also be used by attackers to get your private keys, so never store them digitally, and keep the physical copy stored securely in a locked drawer or safe.\n\n* Before transferring any large amounts (especially to new addresses), first do a small test transaction (e.g., less than $1 value) and wait for confirmation of receipt.\n\n* When you create a new account, start by sending only a small test transaction to the new address. Once you receive the test transaction, try sending back again from that account. There are lots of reasons account creation can go wrong, and if it has gone wrong, it is better to find out with a small loss. If the tests work, all is well.\n\n* Public block explorers are an easy way to independently see whether a transaction has been accepted by the network. However, this convenience has a negative impact on your privacy, because you reveal your addresses to block explorers, which can track you.\n\n* Do not send money to any of the addresses shown in this book. The private keys are listed in the book and someone will immediately take that money.\n\nNow that we've covered some basic best practices for key management and security, let's get to work using MetaMask!(((range=\"endofrange\", startref=\"ix_02intro-asciidoc1\")))\n\n[[installing_MetaMask]]", "metadata": {"source": "ethereumbook", "chapter": "02intro.asciidoc", "section": "Control and Responsibility"}}
{"input": "Explain the Ethereum concept: Getting Started with MetaMask", "output": "(((\"Ethereum (generally)\",\"MetaMask basics\", id=\"ix_02intro-asciidoc2\", range=\"startofrange\")))(((\"MetaMask\",\"basics\", id=\"ix_02intro-asciidoc3\", range=\"startofrange\")))Open the Google Chrome browser and navigate to https://chrome.google.com/webstore/category/extensions[].\n\nSearch for \"MetaMask\" and click on the logo of a fox. You should see something like the result shown in <<metamask_download>>.\n\n[[metamask_download]]\n.The detail page of the MetaMask Chrome extension\nimage::images/metamask_download.png[\"MetaMask Detail Page\"]\n\nIt's important to verify that you are downloading the real MetaMask extension, as sometimes people are able to sneak malicious extensions past Google's filters. The real one:\n\n* Shows the ID +nkbihfbeogaeaoehlefnkodbefgpgknn+ in the address bar\n* Is offered by https://metamask.io\n* Has more than 1,500 reviews\n* Has more than 1,000,000 users\n\nOnce you confirm you are looking at the correct extension, click \"Add to Chrome\" to install it.\n\n[[using_MetaMask]]", "metadata": {"source": "ethereumbook", "chapter": "02intro.asciidoc", "section": "Getting Started with MetaMask"}}
{"input": "Explain the Ethereum concept: Creating a Wallet", "output": "(((\"MetaMask\",\"wallet setup with\", id=\"ix_02intro-asciidoc4\", range=\"startofrange\")))Once MetaMask is installed you should see a new icon (the head of a fox) in your browser's toolbar. Click on it to get started. You will be asked to accept the terms and conditions and then to create your new Ethereum wallet by entering a password (see <<metamask_password>>).\n\n[[metamask_password]]\n.The password page of the MetaMask Chrome extension\nimage::images/metamask_password.png[\"MetaMask Password Page\"]\n\n[TIP]", "metadata": {"source": "ethereumbook", "chapter": "02intro.asciidoc", "section": "Creating a Wallet"}}
{"input": "Explain the Ethereum concept: Switching Networks", "output": "(((\"MetaMask\",\"network choices\")))As you can see on the MetaMask account page, you can choose between multiple Ethereum networks. By default, MetaMask will try to connect to the main network. The other choices are public testnets, any Ethereum node of your choice, or nodes running private blockchains on your own computer (localhost):\n\nMain Ethereum Network:: The main public Ethereum blockchain. Real ETH, real value, and real consequences.\n\nRopsten Test Network:: Ethereum public test blockchain and network. ETH on this network has no value.\n\nKovan Test Network:: Ethereum public test blockchain and network using the Aura consensus protocol with proof of authority (federated signing). ETH on this network has no value. The Kovan test network is supported by Parity only. Other Ethereum clients use the Clique consensus protocol, which was proposed later, for proof of authority&#x2013;based verification.\n\nRinkeby Test Network:: Ethereum public test blockchain and network, using the Clique consensus protocol with proof of authority (federated signing). ETH on this network has no value.\n\nLocalhost 8545:: Connects to a node running on the same computer as the browser. The node can be part of any public blockchain (main or testnet), or a private testnet.\n\nCustom RPC:: Allows you to connect MetaMask to any node with a Geth-compatible Remote Procedure Call (RPC) interface. The node can be part of any public or private blockchain.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "02intro.asciidoc", "section": "Switching Networks"}}
{"input": "Explain the Ethereum concept: Getting Some Test Ether", "output": "(((\"ether (generally)\",\"testnet\")))(((\"MetaMask\",\"and testnet ether\")))(((\"test ether\",\"obtaining\")))(((\"testnet\",\"ether for\")))(((\"wallets\",\"testnet ether and\")))Your first task is to get your wallet funded. You won't be doing that on the main network because real ether costs money and handling it requires a bit more experience. For now, you'll load your wallet with some testnet ether.\n\n(((\"Ropsten Test Network\")))Switch MetaMask to the _Ropsten Test Network_. Click Deposit, then click Ropsten Test Faucet. MetaMask will open a new web page, as shown in <<metamask_ropsten_faucet>>.\n\n[[metamask_ropsten_faucet]]\n.MetaMask Ropsten Test Faucet\nimage::images/metamask_ropsten_faucet.png[\"MetaMask Ropsten Test Faucet\"]\n\nYou may notice that the web page already contains your MetaMask wallet's Ethereum address. MetaMask integrates Ethereum-enabled web pages with your MetaMask wallet and can \"see\" Ethereum addresses on the web page, allowing you, for example, to send a payment to an online shop displaying an Ethereum address. MetaMask can also populate the web page with your own wallet's address as a recipient address if the web page requests it. In this page, the faucet application is asking MetaMask for a wallet address to send test ether to.\n\nClick the green \"request 1 ether from faucet\" button. You will see a transaction ID appear in the lower part of the page. The faucet app has created a transaction&#x2014;a payment to you. The transaction ID looks like this:\n\n[[faucet_tx_id]]\n----\n0x7c7ad5aaea6474adccf6f5c5d6abed11b70a350fbc6f9590109e099568090c57\n----\n\nIn a few seconds, the new transaction will be mined by the Ropsten miners and your MetaMask wallet will show a balance of 1 ETH. Click on the transaction ID and your browser will take you to a _block explorer_, which is a website that allows you to visualize and explore blocks, addresses, and transactions. MetaMask uses the https://etherscan.io/[Etherscan block explorer], one of the more popular Ethereum block explorers. The transaction containing the payment from the Ropsten Test Faucet is shown in <<ropsten_block_explorer>>.\n\n[[ropsten_block_explorer]]\n.Etherscan Ropsten block explorer\nimage::images/ropsten_block_explorer.png[\"Etherscan Ropsten Block Explorer\"]\n\nThe transaction has been recorded on the Ropsten blockchain and can be viewed at any time by anyone, simply by searching for the transaction ID, or http://bit.ly/2Q860Wk[visiting the link].\n\nTry visiting that link, or entering the transaction hash into the _ropsten.etherscan.io_ website, to see it for yourself.\n\n[[sending_eth_MetaMask]]", "metadata": {"source": "ethereumbook", "chapter": "02intro.asciidoc", "section": "Getting Some Test Ether"}}
{"input": "Explain the Ethereum concept: Sending Ether from MetaMask", "output": "(((\"MetaMask\",\"sending ether from\", id=\"ix_02intro-asciidoc6\", range=\"startofrange\")))(((\"test ether\",\"sending\", id=\"ix_02intro-asciidoc7\", range=\"startofrange\")))Once you've received your first test ether from the Ropsten Test Faucet, you can experiment with sending ether by trying to send some back to the faucet. As you can see on the Ropsten Test Faucet page, there is an option to \"donate\" 1 ETH to the faucet. This option is available so that once you're done testing, you can return the remainder of your test ether, so that someone else can use it next. Even though test ether has no value, some people hoard it, making it difficult for everyone else to use the test networks. Hoarding test ether is frowned upon!\n\nFortunately, we are not test ether hoarders. Click the orange \"1 ether\" button to tell MetaMask to create a transaction paying the faucet 1 ether. MetaMask will prepare a transaction and pop up a window with the confirmation, as shown in <<send_to_faucet>>.\n\n\n[[send_to_faucet]]\n.Sending 1 ether to the faucet\nimage::images/send_to_faucet.png[\"Sending 1 ether to the faucet\"]\n\nOops! You probably noticed you can't complete the transaction&#x2014;MetaMask says you have an insufficient balance. At first glance this may seem confusing: you have 1 ETH, you want to send 1 ETH, so why is MetaMask saying you have insufficient funds?\n\n(((\"gas\",\"basics\")))The answer is because of the cost of _gas_. Every Ethereum transaction requires payment of a fee, which is collected by the miners to validate the transaction. The fees in Ethereum are charged in a virtual currency called gas. You pay for the gas with ether, as part of the transaction.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "02intro.asciidoc", "section": "Sending Ether from MetaMask"}}
{"input": "Explain the Ethereum concept: Exploring the Transaction History of an Address", "output": "(((\"addresses\",\"exploring transaction history of\", id=\"ix_02intro-asciidoc8\", range=\"startofrange\")))(((\"MetaMask\",\"exploring transaction history of an address with\", id=\"ix_02intro-asciidoc9\", range=\"startofrange\")))By now you have become an expert in using MetaMask to send and receive test ether. Your wallet has received at least two payments and sent at least one. You can view all these transactions using the _ropsten.etherscan.io_ block explorer. You can either copy your wallet address and paste it into the block explorer's search box, or have MetaMask open the page for you. Next to your account icon in MetaMask, you will see a button showing three dots. Click on it to show a menu of account-related options (see <<metamask_account_context_menu>>).\n\n[[metamask_account_context_menu]]\n.MetaMask account context menu\nimage::images/metamask_account_context_menu.png[\"MetaMask Account Context Menu\"]\n\nSelect \"View account on Etherscan\" to open a web page in the block explorer showing your account's transaction history, as shown in <<block_explorer_account_history>>.\n\n[[block_explorer_account_history]]\n.Address transaction history on Etherscan\nimage::images/block_explorer_account_history.png[\"Address Transaction History on Etherscan\"]\n\nHere you can see the entire transaction history of your Ethereum address. It shows all the transactions recorded on the Ropsten blockchain where your address is the sender or recipient. Click on a few of these transactions to see more details.\n\nYou can explore the transaction history of any address. Take a look at the transaction history of the Ropsten Test Faucet address (hint: it is the \"sender\" address listed in the oldest payment to your address). You can see all the test ether sent from the faucet to you and to other addresses. Every transaction you see can lead you to more addresses and more transactions. Before long you will be lost in the maze of interconnected data. Public blockchains contain an enormous wealth of information, all of which can be explored programmatically, as we will see in future examples(((range=\"endofrange\", startref=\"ix_02intro-asciidoc9\")))(((range=\"endofrange\", startref=\"ix_02intro-asciidoc8\"))).(((range=\"endofrange\", startref=\"ix_02intro-asciidoc3\")))(((range=\"endofrange\", startref=\"ix_02intro-asciidoc2\")))\n\n[[intro_world_computer]]", "metadata": {"source": "ethereumbook", "chapter": "02intro.asciidoc", "section": "Exploring the Transaction History of an Address"}}
{"input": "Explain the Ethereum concept: Introducing the World Computer", "output": "(((\"Ethereum (generally)\",\"and EVM\")))(((\"EVM (Ethereum Virtual Machine)\",\"as world computer\")))(((\"world computer, Ethereum as\")))You've now created a wallet and sent and received ether. So far, we've treated Ethereum as a cryptocurrency. But Ethereum is much, much more. In fact, the cryptocurrency function is subservient to Ethereum's function as a decentralized world computer. (((\"smart contracts\",\"ether and\")))Ether is meant to be used to pay for running _smart contracts_, which are computer programs that run on an emulated computer called the _Ethereum Virtual Machine_ (EVM).\n\nThe EVM is a global singleton, meaning that it operates as if it were a global, single-instance computer, running everywhere. Each node on the Ethereum network runs a local copy of the EVM to validate contract execution, while the Ethereum blockchain records the changing _state_ of this world computer as it processes transactions and smart contracts. We'll discuss this in much greater detail in <<evm_chapter>>.\n\n[[EOA_contracts]]", "metadata": {"source": "ethereumbook", "chapter": "02intro.asciidoc", "section": "Introducing the World Computer"}}
{"input": "Explain the Ethereum concept: Externally Owned Accounts (EOAs) and Contracts", "output": "(((\"contract accounts\", seealso=\"smart contracts\")))(((\"EOA (Externally Owned Account)\",\"basics\")))(((\"Ethereum (generally)\",\"EOAs and contracts\")))(((\"smart contracts\",\"basics\")))The type of account you created in the MetaMask wallet is called an _externally owned account_ (EOA). Externally owned accounts are those that have a private key; having the private key means control over access to funds or contracts. Now, you're probably guessing there is another type of account. That other type of account is a _contract account_. A contract account has smart contract code, which a simple EOA can't have. Furthermore, a contract account does not have a private key. Instead, it is owned (and controlled) by the logic of its smart contract code: the software program recorded on the Ethereum blockchain at the contract account's creation and executed by the EVM.\n\nContracts have addresses, just like EOAs. Contracts can also send and receive ether, just like EOAs. However, when a transaction destination is a contract address, it causes that contract to _run_ in the EVM, using the transaction, and the transaction's data, as its input. In addition to ether, transactions can contain _data_ indicating which specific function in the contract to run and what parameters to pass to that function. In this way, transactions can _call_ functions within contracts.\n\nNote that because a contract account does not have a private key, it cannot _initiate_ a transaction. Only EOAs can initiate transactions, but contracts can _react_ to transactions by calling other contracts, building complex execution paths. One typical use of this is an EOA sending a request transaction to a multisignature smart contract wallet to send some ETH on to another address. A typical DApp programming pattern is to have Contract A calling Contract B in order to maintain a shared state across users of Contract A.\n\nIn the next few sections, we will write our first contract. You will then learn how to create, fund, and use that contract with your MetaMask wallet and test ether on the Ropsten test network.\n\n[[simple_contract_example]]", "metadata": {"source": "ethereumbook", "chapter": "02intro.asciidoc", "section": "Externally Owned Accounts (EOAs) and Contracts"}}
{"input": "Explain the Ethereum concept: A Simple Contract: A Test Ether Faucet", "output": "(((\"contract accounts\",\"creating\", seealso=\"Faucet.sol contract\", id=\"ix_02intro-asciidoc10\", range=\"startofrange\")))(((\"Faucet.sol contract (test example)\",\"creating\", id=\"ix_02intro-asciidoc11\", range=\"startofrange\")))Ethereum has many different high-level languages, all of which can be used to write a contract and produce EVM bytecode. You can read about many of the most prominent and interesting ones in <<high_level_languages>>. One high-level language is by far the dominant choice for smart contract programming: Solidity. (((\"Wood, Dr. Gavin\",\"and Solidity\")))Solidity was created by Dr. Gavin Wood, the coauthor of this book, and has become the most widely used language in Ethereum (and beyond). We'll use Solidity to write our first contract.\n\n(((\"Solidity\",\"faucet.sol and\")))For our first example (<<solidity_faucet_example>>), we will write a contract that controls a _faucet_. You've already used a faucet to get test ether on the Ropsten test network. A faucet is a relatively simple thing: it gives out ether to any address that asks, and can be refilled periodically. You can implement a faucet as a wallet controlled by a human or a web server.\n\n[[solidity_faucet_example]]\n.Faucet.sol: A Solidity contract implementing a faucet", "metadata": {"source": "ethereumbook", "chapter": "02intro.asciidoc", "section": "A Simple Contract: A Test Ether Faucet"}}
{"input": "Explain the Ethereum concept: Compiling the Faucet Contract", "output": "(((\"compiling\",\"Faucet.sol contract\", id=\"ix_02intro-asciidoc12\", range=\"startofrange\")))(((\"Faucet.sol contract (test example)\",\"compiling\", id=\"ix_02intro-asciidoc13\", range=\"startofrange\")))Now that we have our first example contract, we need to use a Solidity compiler to convert the Solidity code into EVM bytecode so it can be executed by the EVM on the blockchain itself.\n\nThe Solidity compiler comes as a standalone executable, as part of various frameworks, and bundled in Integrated Development Environments (IDEs). To keep things simple, we will use one of the more popular IDEs, called _Remix_.\n\n(((\"Remix IDE\")))Use your Chrome browser (with the MetaMask wallet you installed earlier) to navigate to the Remix IDE at https://remix.ethereum.org[].\n\nWhen you first load Remix, it will start with a sample contract called _ballot.sol_. We don't need that, so close it by clicking the +x+ on the corner of the tab, as seen in <<remix_close_tab>>.\n\n[[remix_close_tab]]\n.Close the default example tab\nimage::images/remix_close_tab.png[\"Close the default example tab\"]\n\nNow, add a new tab by clicking on the circular plus sign in the top-left toolbar, as seen in <<remix_toolbar>>. Name the new file _Faucet.sol_.\n\n[[remix_toolbar]]\n.Click the plus sign to open a new tab\nimage::images/remix_toolbar.png[\"Click the plus sign to open a new tab\"]\n\nOnce you have the new tab open, copy and paste the code from our example _Faucet.sol_, as seen in <<remix_faucet_load>>.\n\n[[remix_faucet_load]]\n.Copy the Faucet example code into the new tab\nimage::images/remix_faucet_load.png[\"Copy the Faucet example code into the new tab\"]\n\nOnce you have loaded the _Faucet.sol_ contract into the Remix IDE, the IDE will automatically compile the code. If all goes well, you will see a green box with \"Faucet\" in it appear on the right, under the Compile tab, confirming the successful compilation (see <<remix_compile>>).\n\n[[remix_compile]]\n.Remix successfully compiles the Faucet.sol contract\nimage::images/remix_compile.png[\"\"]\n\nIf something goes wrong, the most likely problem is that the Remix IDE is using a version of the Solidity compiler that is different from 0.6. In that case, our pragma directive will prevent _Faucet.sol_ from compiling. To change the compiler version, go to the Settings tab, set the version to 0.6.0, and try again.\n\nThe Solidity compiler has now compiled our _Faucet.sol_ into EVM bytecode. If you are curious, the bytecode looks like this:\n\n[[faucet_bytecode]]\n----\nPUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0xF4 DUP1 PUSH2 0x1F PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE PUSH1 0x4 CALLDATASIZE LT PUSH1 0x1F JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0x2E1A7D4D EQ PUSH1 0x2A JUMPI PUSH1 0x25 JUMP JUMPDEST CALLDATASIZE PUSH1 0x25 JUMPI STOP JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST CALLVALUE DUP1 ISZERO PUSH1 0x35 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x5F PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x20 DUP2 LT ISZERO PUSH1 0x4A JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 ADD SWAP1 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP PUSH1 0x61 JUMP JUMPDEST STOP JUMPDEST PUSH8 0x16345785D8A0000 DUP2 GT ISZERO PUSH1 0x75 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST CALLER PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH2 0x8FC DUP3 SWAP1 DUP2 ISZERO MUL SWAP1 PUSH1 0x40 MLOAD PUSH1 0x0 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 DUP6 DUP9 DUP9 CALL SWAP4 POP POP POP POP ISZERO DUP1 ISZERO PUSH1 0xBA JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 STOP CODECOPY 0xDC DUP16 0xD SGT PUSH6 0xD2245039EDD7 RETURN CALLDATALOAD 0xC2 0xE4 SWAP9 0xF6 0x2C 0xF8 0xB3 OR JUMPDEST 0xAC 0xD8 CREATE2 SSTORE 0x4E SIGNEXTEND PUSH4 0x3164736F PUSH13 0x634300060C0033000000000000\n----\n\nAren't you glad you are using a high-level language like Solidity instead of programming directly in EVM bytecode? Me too!(((range=\"endofrange\", startref=\"ix_02intro-asciidoc13\")))(((range=\"endofrange\", startref=\"ix_02intro-asciidoc12\")))\n\n[[create_contract]]", "metadata": {"source": "ethereumbook", "chapter": "02intro.asciidoc", "section": "Compiling the Faucet Contract"}}
{"input": "Explain the Ethereum concept: Creating the Contract on the Blockchain", "output": "(((\"blockchain\",\"creating contract on\", id=\"ix_02intro-asciidoc14\", range=\"startofrange\")))(((\"Faucet.sol contract (test example)\",\"on the blockchain\", id=\"ix_02intro-asciidoc15\", range=\"startofrange\")))So, we have a contract. We've compiled it into bytecode. Now, we need to \"register\" the contract on the Ethereum blockchain. We will be using the Ropsten testnet to test our contract, so that's the blockchain we want to submit it to.\n\n(((\"zero address\",\"contract registration\")))Registering a contract on the blockchain involves creating a special transaction whose destination is the address +0x0000000000000000000000000000000000000000+, also known as the _zero address_. The zero address is a special address that tells the Ethereum blockchain that you want to register a contract. Fortunately, the Remix IDE will handle all of that for you and send the transaction to MetaMask.\n\n(((\"Remix IDE\", id=\"ix_02intro-asciidoc16\", range=\"startofrange\")))First, switch to the Run tab and select Injected Web3 in the Environment drop-down selection box. This connects the Remix IDE to the MetaMask wallet, and through MetaMask to the Ropsten test network. Once you do that, you can see Ropsten under Environment. Also, in the Account selection box it shows the address of your wallet (see <<remix_run>>).\n\n[[remix_run]]\n.Remix IDE Run tab, with Injected Web3 environment selected\nimage::images/remix_run.png[\"Remix IDE Run tab, with Injected Web3 environment selected\"]\n\nRight below the Run settings you just confirmed is the +Faucet+ contract, ready to be created. Click on the Deploy button shown in <<remix_run>>.\n\nRemix will construct the special \"creation\" transaction and MetaMask will ask you to approve it, as shown in <<remix_metamask_create>>. You'll notice the contract creation transaction has no ether in it, but it has 275 bytes of data (the compiled contract) and will consume 3 gwei in gas. Press Confirm to approve it.\n\n[[remix_metamask_create]]\n.MetaMask showing the contract creation transaction\nimage::images/remix_metamask_create.png[\"MetaMask showing the contract creation transaction\"]\n\nNow you have to wait. It will take about 15 to 30 seconds for the contract to be mined on Ropsten. Remix won't appear to be doing much, but be patient.\n\nOnce the contract is created, it appears at the bottom of the Run tab (see <<remix_contract_interact>>).\n\n[[remix_contract_interact]]\n.The Faucet contract is ALIVE!\nimage::images/remix_contract_interact.png[\"The Faucet contract is ALIVE!\"]\n\nNotice that the +Faucet+ contract now has an address of its own: Remix shows it as &#x201c;Faucet at 0x72e...c7829&#x201d; (although your address, the random letters and numbers, will be different). The small clipboard symbol to the right allows you to copy the contract address to your clipboard. We will use that in the next section.(((range=\"endofrange\", startref=\"ix_02intro-asciidoc16\")))(((range=\"endofrange\", startref=\"ix_02intro-asciidoc15\")))\n\n[[interact_contract]]", "metadata": {"source": "ethereumbook", "chapter": "02intro.asciidoc", "section": "Creating the Contract on the Blockchain"}}
{"input": "Explain the Ethereum concept: Interacting with the Contract", "output": "(((\"Faucet.sol contract (test example)\",\"interacting with\", id=\"ix_02intro-asciidoc17\", range=\"startofrange\")))Let's recap what we've learned so far: Ethereum contracts are programs that control money, which run inside a virtual machine called the EVM. They are created by a special transaction that submits their bytecode to be recorded on the blockchain. Once they are created on the blockchain, they have an Ethereum address, just like wallets. Anytime someone sends a transaction to a contract address it causes the contract to run in the EVM, with the transaction as its input. Transactions sent to pass:[<span class=\"keep-together\">contract</span>] addresses may have ether or data or both. If they contain ether, it is \"deposited\" to the contract balance. If they contain data, the data can specify a named function in the contract and call it, passing arguments to the function.\n\n[[view_contract_address]]", "metadata": {"source": "ethereumbook", "chapter": "02intro.asciidoc", "section": "Interacting with the Contract"}}
{"input": "Explain the Ethereum concept: Viewing the Contract Address in a Block Explorer", "output": "(((\"Faucet.sol contract (test example)\",\"viewing contract address in a block explorer\")))We now have a contract recorded on the blockchain, and we can see it has an Ethereum address. Let's check it out in the _ropsten.etherscan.io_ block explorer and see what a contract looks like. In the Remix IDE, copy the address of the contract by clicking the clipboard icon next to its name (see <<remix_contract_address>>).\n\n[[remix_contract_address]]\n.Copy the contract address from Remix\nimage::images/remix_contract_address.png[\"Copy the contract address from Remix\"]\n\nKeep Remix open; we'll come back to it again later. Now, navigate your browser to _ropsten.etherscan.io_ and paste the address into the search box. You should see the contract's Ethereum address history, as shown in <<etherscan_contract_address>>.(((range=\"endofrange\", startref=\"ix_02intro-asciidoc17\")))\n\n[[etherscan_contract_address]]\n.View the Faucet contract address in the Etherscan block explorer\nimage::images/etherscan_contract_address.png[\"View the Faucet contract address in the etherscan block explorer\"]\n\n[[fund_contract]]", "metadata": {"source": "ethereumbook", "chapter": "02intro.asciidoc", "section": "Viewing the Contract Address in a Block Explorer"}}
{"input": "Explain the Ethereum concept: Funding the Contract", "output": "(((\"Faucet.sol contract (test example)\",\"sending ether to\", id=\"ix_02intro-asciidoc18\", range=\"startofrange\")))For now, the contract only has one transaction in its history: the contract creation transaction. As you can see, the contract also has no ether (zero balance). That's because we didn't send any ether to the contract in the creation transaction, even though we could have.\n\nOur faucet needs funds! Our first project will be to use MetaMask to send ether to the contract. You should still have the address of the contract in your clipboard (if not, copy it again from Remix). Open MetaMask, and send 1 ether to it, exactly as you would to any other Ethereum address (see <<metamask_send_to_contract>>).\n\n[[metamask_send_to_contract]]\n.Send 1 ether to the contract address\nimage::images/metamask_send_to_contract.png[\"\"]\n\nIn a minute, if you reload the Etherscan block explorer, it will show another transaction to the contract address and an updated balance of 1 ether.\n\nRemember the unnamed default external payable function in our _Faucet.sol_ code? It looked like this:\n\n[[receive_function_review]]\n[source,solidity]\n----\nreceive () external payable {}\n----\n\nWhen you sent a transaction to the contract address, with no data specifying which function to call, it called this default function. Because we declared it as +payable+, it accepted and deposited the 1 ether into the contract's account balance. Your transaction caused the contract to run in the EVM, updating its balance. You have funded your faucet!(((range=\"endofrange\", startref=\"ix_02intro-asciidoc18\")))\n\n[[withdraw_from_contract]]", "metadata": {"source": "ethereumbook", "chapter": "02intro.asciidoc", "section": "Funding the Contract"}}
{"input": "Explain the Ethereum concept: Withdrawing from Our Contract", "output": "(((\"Faucet.sol contract (test example)\",\"withdrawing funds from\", id=\"ix_02intro-asciidoc19\", range=\"startofrange\")))(((\"withdrawal of funds from contract\", id=\"ix_02intro-asciidoc20\", range=\"startofrange\")))Next, let's withdraw some funds from the faucet. To withdraw, we have to construct a transaction that calls the +withdraw+ function and passes a +withdraw_amount+ argument to it. To keep things simple for now, Remix will construct that transaction for us and MetaMask will present it for our approval.\n\nReturn to the Remix tab and look at the contract on the Run tab. You should see a orange box labeled +withdraw+ with a field entry labeled +uint256 withdraw_amount+ (see <<remix_contract_withdraw>>).\n\n[[remix_contract_withdraw]]\n.The withdraw function of Faucet.sol, in Remix\nimage::images/remix_contract_interact.png[\"The withdraw function of Faucet.sol, in Remix\"]\n\nThis is the Remix interface to the contract. It allows us to construct transactions that call the functions defined in the contract. We will enter a +withdraw_amount+ and click the withdraw button to generate the transaction.\n\nFirst, let's figure out the +withdraw_amount+. We want to try and withdraw 0.1 ether, which is the maximum amount allowed by our contract. Remember that all currency values in Ethereum are denominated in wei internally, and our +withdraw+ function expects the +withdraw_amount+ to be denominated in wei too. The amount we want is 0.1 ether, which is 100,000,000,000,000,000 wei (a 1 followed by 17 zeros).\n\n\n\n[TIP]", "metadata": {"source": "ethereumbook", "chapter": "02intro.asciidoc", "section": "Withdrawing from Our Contract"}}
{"input": "Explain the Ethereum concept: Conclusions", "output": "In this chapter, you set up a wallet using MetaMask and funded it using a faucet on the Ropsten test network. You received ether into your wallet's Ethereum address, then you sent ether to the faucet's Ethereum address.\n\nNext, you wrote a faucet contract in Solidity. You used the Remix IDE to compile the contract into EVM bytecode, then used Remix to form a transaction and created the +Faucet+ contract on the Ropsten blockchain. Once created, the +Faucet+ contract had an Ethereum address, and you sent it some ether. Finally, you constructed a transaction to call the +withdraw+ function and successfully asked for 0.1 ether. The contract checked the request and sent you 0.1 ether with an internal transaction.\n\nIt may not seem like much, but you've just successfully interacted with software that controls money on a decentralized world computer.\n\nWe will do a lot more smart contract programming in <<smart_contracts_chapter>> and learn about best practices and security considerations in <<smart_contract_security>>.(((range=\"endofrange\", startref=\"ix_02intro-asciidoc0\")))", "metadata": {"source": "ethereumbook", "chapter": "02intro.asciidoc", "section": "Conclusions"}}
{"input": "Explain the Ethereum concept: Ethereum Clients", "output": "(((\"clients, Ethereum\", id=\"ix_03clients-asciidoc0\", range=\"startofrange\")))An Ethereum client is a software application that implements the Ethereum specification and communicates over the peer-to-peer network with other Ethereum clients. Different Ethereum clients _interoperate_ if they comply with the reference specification and the standardized communications protocols. While these different clients are implemented by different teams and in different programming languages, they all \"speak\" the same protocol and follow the same rules. As such, they can all be used to operate and interact with the same Ethereum network.\n\nEthereum is an open source project, and the source code for all the major clients is available under open source licenses (e.g., LGPL v3.0), free to download and use for any purpose. _Open source_ means more than simply free to use, though. It also means that Ethereum is developed by an open community of volunteers and can be modified by anyone. More eyes means more trustworthy code.\n\n(((\"Yellow Paper specification\")))Ethereum is defined by a formal specification called the \"Yellow Paper\" (see <<references>>).\n\n(((\"Bitcoin\",\"Ethereum definition compared to\")))This is in contrast to, for example, Bitcoin, which is not defined in any formal way. Where Bitcoin's \"specification\" is the reference implementation Bitcoin Core, Ethereum's specification is documented in a paper that combines an English and a mathematical (formal) specification. This formal specification, in addition to various Ethereum Improvement Proposals, defines the standard behavior of an Ethereum pass:[<span class=\"keep-together\">client</span>]. The Yellow Paper is periodically updated as major changes are made to pass:[<span class=\"keep-together\">Ethereum</span>].\n\nAs a result of Ethereum's clear formal specification, there are a number of independently developed, yet interoperable, software implementations of an Ethereum client. Ethereum has a greater diversity of implementations running on the network than any other blockchain, which is generally regarded as a good thing. Indeed, it has, for example, proven itself to be an excellent way of defending against attacks on the network, because exploitation of a particular client's implementation strategy simply hassles the developers while they patch the exploit, while other clients keep the network running almost unaffected.", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Ethereum Clients"}}
{"input": "Explain the Ethereum concept: Ethereum Networks", "output": "(((\"clients, Ethereum\",\"Ethereum-based networks and\", id=\"ix_03clients-asciidoc1\", range=\"startofrange\")))(((\"networks (Ethereum)\",\"clients and\", id=\"ix_03clients-asciidoc2\", range=\"startofrange\")))There exist a variety of Ethereum-based networks that largely conform to the formal specification defined in the Ethereum Yellow Paper, but which may or may not interoperate with each other.\n\nAmong these Ethereum-based networks are Ethereum, Ethereum Classic, Ella, Expanse, Ubiq, Musicoin, and many others. While mostly compatible at the protocol level, these networks often have features or attributes that require maintainers of Ethereum client software to make small changes in order to support each network. Because of this, not every version of Ethereum client software runs every Ethereum-based blockchain.\n\nCurrently, there are six main implementations of the Ethereum protocol, written in six different languages:\n\n* Parity, written in Rust\n* Geth, written in Go\n* +cpp-ethereum+, written in Cpass:[++]\n* +pyethereum+, written in Python\n* Mantis, written in Scala\n* Harmony, written in Java\n\nIn this section, we will look at the two most common clients, Parity and Geth. We'll show how to set up a node using each client, and explore some of their command-line options and application programming interfaces (APIs).\n\n[[full_node_importance]]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Ethereum Networks"}}
{"input": "Explain the Ethereum concept: Should I Run a Full Node?", "output": "(((\"full node\",\"Ethereum-based networks and\", id=\"ix_03clients-asciidoc3\", range=\"startofrange\")))(((\"networks (Ethereum)\",\"full nodes and\", id=\"ix_03clients-asciidoc4\", range=\"startofrange\")))The health, resilience, and censorship resistance of blockchains depend on them having many independently operated and geographically dispersed full nodes. Each full node can help other new nodes obtain the block data to bootstrap their operation, as well as offering the operator an authoritative and independent verification of all transactions and contracts.\n\nHowever, running a full node will incur a cost in hardware resources and bandwidth. A full node may download up to 300 GB of data (as of March 2021, depending on the client configuration) and store it on a local hard drive. This data burden increases quite rapidly every day as new transactions and blocks are added. We discuss this topic in greater detail in <<requirements>>.\n\nA full node running on a live _mainnet_ network is not necessary for Ethereum development. You can do almost everything you need to do with a _testnet_ node (which connects you to one of the smaller public test blockchains), with a local private blockchain like Ganache, or with a cloud-based Ethereum client offered by a service provider like Infura.\n\nYou also have the option of running a remote client, which does not store a local copy of the blockchain or validate blocks and transactions. These clients offer the functionality of a wallet and can create and broadcast transactions. Remote clients can be used to connect to existing networks, such as your own full node, a public blockchain, a public or permissioned (proof-of-authority) testnet, or a private local blockchain. In practice, you will likely use a remote client such as MetaMask, Emerald Wallet, pass:[<span class=\"keep-together\">MyEtherWallet</span>], or MyCrypto as a convenient way to switch between all of the different node options.\n\n(((\"remote clients\",\"wallet compared to\")))(((\"wallets\",\"remote clients compared to\")))The terms \"remote client\" and \"wallet\" are used interchangeably, though there are some differences. Usually, a remote client offers an API (such as the web3.js API) in addition to the transaction functionality of a wallet.\n\n(((\"light/lightweight client\")))Do not confuse the concept of a remote wallet in Ethereum with that of a _light client_ (which is analogous to a Simplified Payment Verification client in Bitcoin). Light clients validate block headers and use Merkle proofs to validate the inclusion of transactions in the blockchain and determine their effects, giving them a similar level of security to a full node. Conversely, Ethereum remote clients do not validate block headers or transactions. They entirely trust a full client to give them access to the blockchain, and hence lose significant security and anonymity guarantees. You can mitigate these problems by using a full client you run yourself.\n\n[[full_node_adv_disadv]]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Should I Run a Full Node?"}}
{"input": "Explain the Ethereum concept: Full Node Advantages and Disadvantages", "output": "(((\"full node\",\"advantages/disadvantages\")))Choosing to run a full node helps with the operation of the networks you connect it to, but also incurs some mild to moderate costs for you. Let's look at some of the advantages and disadvantages.\n\n*Advantages:*\n\n* Supports the resilience and censorship resistance of Ethereum-based networks\n* Authoritatively validates all transactions\n* Can interact with any contract on the public blockchain without an intermediary\n* Can directly deploy contracts into the public blockchain without an intermediary\n* Can query (read-only) the blockchain status (accounts, contracts, etc.) offline\n* Can query the blockchain without letting a third party know the information you're reading\n\n*Disadvantages:*\n\n* Requires significant and growing hardware and bandwidth resources\n* May require several days to fully sync when first started\n* Must be maintained, upgraded, and kept online to remain synced(((range=\"endofrange\", startref=\"ix_03clients-asciidoc4\")))(((range=\"endofrange\", startref=\"ix_03clients-asciidoc3\")))\n\n[[pub_test_adv_disadv]]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Full Node Advantages and Disadvantages"}}
{"input": "Explain the Ethereum concept: Public Testnet Advantages and Disadvantages", "output": "(((\"networks (Ethereum)\",\"public testnet advantages/disadvantages\")))(((\"public testnets\")))(((\"testnet\",\"public\")))Whether or not you choose to run a full node, you will probably want to run a public testnet node. Let's look at some of the advantages and disadvantages of using a public testnet.\n\n*Advantages:*\n\n* A testnet node needs to sync and store significantly less data compared to mainnet&#x2014;about 75 GB depending on the network.\n* A testnet node can sync fully in much less time.\n* Deploying contracts or making transactions requires test ether, which has no value and can be acquired for free from several \"faucets.\"\n* Testnets are public blockchains with many other users and contracts, running \"live.\"\n\n*Disadvantages:*\n\n* You can't use \"real\" money on a testnet; it runs on test ether. Consequently, you can't test security against real adversaries, as there is nothing at stake.\n* There are some aspects of a public blockchain that you cannot test realistically on a testnet. For example, transaction fees, although necessary to send transactions, are not a consideration on a testnet, since gas is free. Further, the testnets do not experience network congestion like the public mainnet sometimes does.\n\n[[localtest_adv_dis]]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Public Testnet Advantages and Disadvantages"}}
{"input": "Explain the Ethereum concept: Local Blockchain Simulation Advantages and Disadvantages", "output": "(((\"Ganache\",\"advantages/disadvantages\")))(((\"local blockchain simulation\")))(((\"networks (Ethereum)\",\"local blockchain simulation advantages/disadvantages\")))(((\"private blockchain\")))(((\"single-instance private blockchain\")))For many testing purposes, the best option is to launch a single-instance private blockchain. Ganache (formerly named +testrpc+) is one of the most popular local blockchain simulations that you can interact with, without any other participants. It shares many of the advantages and disadvantages of the public testnet, but also has some differences.\n\n*Advantages:*\n\n* No syncing and almost no data on disk; you mine the first block yourself\n* No need to obtain test ether; Ganache is initialized with accounts that already hold ether for testing\n* No other users, just you\n* No other contracts, just the ones you deploy after you launch it unless you use the option of forking off an existing Ethereum node\n\n*Disadvantages:*\n\n* Having no other users means that it doesn't behave the same as a public blockchain. There's no competition for transaction space or sequencing of pass:[<span class=\"keep-together\">transactions</span>].\n* No miners other than you means that mining is more predictable; therefore, you can't test some scenarios that occur on a public blockchain.\n* If you are forking off an existing Ethereum node, it will need to be an archival node for you to interact with state from blocks that may have been pruned otherwise\n\n(((range=\"endofrange\", startref=\"ix_03clients-asciidoc2\")))(((range=\"endofrange\", startref=\"ix_03clients-asciidoc1\")))\n\n\n[[running_client]]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Local Blockchain Simulation Advantages and Disadvantages"}}
{"input": "Explain the Ethereum concept: Running an Ethereum Client", "output": "(((\"clients, Ethereum\",\"running\", id=\"ix_03clients-asciidoc5\", range=\"startofrange\")))If you have the time and resources, you should attempt to run a full node, even if only to learn more about the process. In this section we cover how to download, compile, and run the Ethereum clients Parity and Geth. This requires some familiarity with using the command-line interface on your operating system. It's worth installing these clients, whether you choose to run them as full nodes, as testnet nodes, or as clients to a local private blockchain.\n\n[[requirements]]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Running an Ethereum Client"}}
{"input": "Explain the Ethereum concept: Hardware Requirements for a Full Node", "output": "(((\"clients, Ethereum\",\"full node hardware requirements\")))(((\"full node\",\"hardware requirements\")))Before we get started, you should ensure you have a computer with sufficient resources to run an Ethereum full node. You will need at least 300 GB of disk space to store a full copy of the Ethereum blockchain. If you also want to run a full node on the Ethereum testnet, you will need at least an additional 75 GB. Downloading 375 GB of blockchain data can take a long time, so it's recommended that you work on a fast internet connection.\n\nSyncing the Ethereum blockchain is very input/output (I/O) intensive. It is best to have a solid-state drive (SSD). If you have a mechanical hard disk drive (HDD), you will need at least 8 GB of RAM to use as cache. Otherwise, you may discover that your system is too slow to keep up and sync fully.\n\n*Minimum requirements:*\n\n* CPU with 2+ cores\n* At least 300 GB free storage space\n* 4 GB RAM minimum with an SSD, 8 GB+ if you have an HDD\n* 8 MBit/sec download internet service\n\nThese are the minimum requirements to sync a full (but pruned) copy of an Ethereum-based blockchain.\n\nAt the time of writing the Parity codebase is lighter on resources, so if you're running with limited hardware you'll likely see better results using Parity.\n\nIf you want to sync in a reasonable amount of time and store all the development tools, libraries, clients, and blockchains we discuss in this book, you will want a more capable computer.\n\n*Recommended specifications:*\n\n* Fast CPU with 4+ cores\n* 16 GB+ RAM\n* Fast SSD with at least 500 GB free space\n* 25+ MBit/sec download internet service\n\nIt\u2019s difficult to predict how fast a blockchain's size will increase and when more disk space will be required, so it\u2019s recommended to check the blockchain's latest size before you start syncing.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Hardware Requirements for a Full Node"}}
{"input": "Explain the Ethereum concept: Software Requirements for Building and Running a Client (Node)", "output": "(((\"clients, Ethereum\",\"software requirements for building/running\", id=\"ix_03clients-asciidoc6\", range=\"startofrange\")))This section covers Parity and Geth client software. It also assumes you are using a Unix-like command-line environment. The examples show the commands and output as they appear on an Ubuntu GNU/Linux operating system running the bash shell (command-line execution environment).\n\nTypically every blockchain will have its own version of Geth, while Parity provides support for multiple Ethereum-based blockchains (Ethereum, Ethereum Classic, pass:[<span class=\"keep-together\">Ellaism</span>], Expanse, Musicoin) with the same client download.\n\n[TIP]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Software Requirements for Building and Running a Client (Node)"}}
{"input": "Explain the Ethereum concept: Parity", "output": "(((\"clients, Ethereum\",\"Parity and\")))(((\"Parity\",\"basics\")))Parity is an implementation of a full-node Ethereum client and DApp browser. It was written &#x201c;from the ground up&#x201d; in Rust, a systems programming language, with the aim of building a modular, secure, and scalable Ethereum client. Parity is developed by Parity Tech, a UK company, and is released under the GPLv3 free software license.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Parity"}}
{"input": "Explain the Ethereum concept: Installing Parity", "output": "(((\"Parity\",\"installing\")))The https://wiki.parity.io/Setup[Parity Wiki] offers instructions for building Parity in different environments and containers. We'll show you how to build Parity from source. This assumes you have already installed Rust using +rustup+ (see <<sw_reqs>>).\n\nFirst, get the source code from GitHub:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>git clone https://github.com/paritytech/parity</strong>\n</pre>\n++++\n\nThen change to the _parity_ directory and use +cargo+ to build the executable:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>cd parity</strong>\n$ <strong>cargo install --path .</strong>\n</pre>\n++++\n\nIf all goes well, you should see something like:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>cargo install --path .</strong>\nInstalling parity-ethereum v2.7.0 (/root/parity)\nUpdating crates.io index\nUpdating git repository `https://github.com/paritytech/rust-ctrlc.git`\nUpdating git repository `https://github.com/paritytech/app-dirs-rs`   Updating git repository\n\n [...]\n\nCompiling parity-ethereum v2.7.0 (/root/parity)\nFinished release [optimized] target(s) in 10m 16s\nInstalling /root/.cargo/bin/parity\nInstalled package `parity-ethereum v2.7.0 (/root/parity)` (executable `parity`)\n$\n</pre>\n++++\n\nTry and run +parity+ to see if it is installed, by invoking the +--version+ option:\n\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>parity --version</strong>\nParity Ethereum Client.\n  version Parity-Ethereum/v2.7.0-unstable-b69a33b3a-20200124/x86_64-unknown-linux-gnu/rustc1.40.0\nCopyright 2015-2020 Parity Technologies (UK) Ltd.\nLicense GPLv3+: GNU GPL version 3 or later <ulink url=\"http://gnu.org/licenses/gpl.html\">http://gnu.org/licenses/gpl.html</ulink>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\nBy Wood/Paronyan/Kotewicz/Drwi\u0119ga/Volf/Greeff\n   Habermeier/Czaban/Gotchac/Redman/Nikolsky\n   Schoedon/Tang/Adolfsson/Silva/Palm/Hirsz et al.\n$\n</pre>\n++++\n\nGreat! Now that Parity is installed, you can sync the blockchain and get started with some basic command-line options.\n\n[[go_ethereum_geth]]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Installing Parity"}}
{"input": "Explain the Ethereum concept: Go-Ethereum (Geth)", "output": "(((\"clients, Ethereum\",\"Geth and\", id=\"ix_03clients-asciidoc7\", range=\"startofrange\")))(((\"Geth (Go-Ethereum)\",\"basics\", id=\"ix_03clients-asciidoc8\", range=\"startofrange\")))Geth is the Go language implementation that is actively developed by the Ethereum Foundation, so is considered the \"official\" implementation of the Ethereum client. Typically, every Ethereum-based blockchain will have its own Geth implementation. If you're running Geth, then you'll want to make sure you grab the correct version for your blockchain using one of the following repository links:\n\n\n* https://github.com/ethereum/go-ethereum[Ethereum] (or https://geth.ethereum.org/)\n\n* https://github.com/etclabscore/go-ethereum[Ethereum Classic]\n\n* https://github.com/ellaism/go-ellaism[Ellaism]\n\n* https://github.com/expanse-org/go-expanse[Expanse]\n\n* https://github.com/Musicoin/go-musicoin[Musicoin]\n\n* https://github.com/ubiq/go-ubiq[Ubiq]\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Go-Ethereum (Geth)"}}
{"input": "Explain the Ethereum concept: Cloning the repository", "output": "(((\"Geth (Go-Ethereum)\",\"cloning Git repo for\")))The first step is to clone the Git repository, to get a copy of the source code.\n\nTo make a local clone of your chosen repository, use the +git+ command as follows, in your home directory or under any directory you use for development:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>git clone &lt;Repository Link&gt;</strong>\n</pre>\n++++\n\nYou should see a progress report as the repository is copied to your local system:\n\n[[cloning_status]]\n----\nCloning into 'go-ethereum'...\nremote: Enumerating objects: 86915, done.\nremote: Total 86915 (delta 0), reused 0 (delta 0), pack-reused 86915\nReceiving objects: 100% (86915/86915), 134.73 MiB | 29.30 MiB/s, done.\nResolving deltas: 100% (57590/57590), done.\n----\n\nGreat! Now that you have a local copy of Geth, you can compile an executable for your platform.\n\n[[build_geth_src]]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Cloning the repository"}}
{"input": "Explain the Ethereum concept: Building Geth from source code", "output": "(((\"Geth (Go-Ethereum)\",\"building from source code\")))To build Geth, change to the directory where the source code was downloaded and use the +make+ command:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>cd go-ethereum</strong>\n$ <strong>make geth</strong>\n</pre>\n++++\n\nIf all goes well, you will see the Go compiler building each component until it produces the +geth+ executable:\n\n[[making_geth_status]]\n----\nbuild/env.sh go run build/ci.go install ./cmd/geth\n>>> /usr/local/go/bin/go install -ldflags -X main.gitCommit=58a1e13e6dd7f52a1d...\ngithub.com/ethereum/go-ethereum/common/hexutil\ngithub.com/ethereum/go-ethereum/common/math\ngithub.com/ethereum/go-ethereum/crypto/sha3\ngithub.com/ethereum/go-ethereum/rlp\ngithub.com/ethereum/go-ethereum/crypto/secp256k1\ngithub.com/ethereum/go-ethereum/common\n[...]\ngithub.com/ethereum/go-ethereum/cmd/utils\ngithub.com/ethereum/go-ethereum/cmd/geth\nDone building.\nRun \"build/bin/geth\" to launch geth.\n$\n----\n\nLet's make sure +geth+ works without actually starting it running:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>./build/bin/geth version</strong>\n\nGeth\nVersion: 1.9.11-unstable\nGit Commit: 0b284f6c6cfc6df452ca23f9454ee16a6330cb8e\nGit Commit Date: 20200123\nArchitecture: amd64\nProtocol Versions: [64 63]\nGo Version: go1.13.4\nOperating System: linux\n[...]\n</pre>\n++++\n\nYour +geth version+ command may show slightly different information, but you should see a version report much like the one seen here.\n\nThe next sections explains the challenge with the initial synchronization of Ethereum's blockchain(((range=\"endofrange\", startref=\"ix_03clients-asciidoc6\"))).(((range=\"endofrange\", startref=\"ix_03clients-asciidoc5\")))\n\n\n[[first_sync]]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Building Geth from source code"}}
{"input": "Explain the Ethereum concept: The First Synchronization of Ethereum-Based Blockchains", "output": "(((\"blockchain\",\"first synchronization of\", id=\"ix_03clients-asciidoc9\", range=\"startofrange\")))(((\"clients, Ethereum\",\"first synchronization of Ethereum-based blockchains\", id=\"ix_03clients-asciidoc10\", range=\"startofrange\")))(((\"first synchronization\",\"of Ethereum-based blockchains\", id=\"ix_03clients-asciidoc11\", range=\"startofrange\")))Traditionally, when syncing an Ethereum blockchain, your client would download and validate every block and every transaction since the very start&#x2014;i.e., from the genesis block.\n\nWhile it is possible to fully sync the blockchain this way, this type of sync will take a very long time and has high resource requirements (it will need much more RAM, and will take a very long time indeed if you don't have fast storage).\n\nMany Ethereum-based blockchains were the victim of denial-of-service attacks at the end of 2016. Affected blockchains will tend to sync slowly when doing a full sync.\n\nFor example, on Ethereum, a new client will make rapid progress until it reaches block 2,283,397. This block was mined on September 18, 2016, and marks the beginning of the DoS attacks. From this block to block 2,700,031 (November 26, 2016), the validation of transactions becomes extremely slow, memory intensive, and I/O intensive. This results in validation times exceeding 1 minute per block. Ethereum implemented a series of upgrades, using hard forks, to address the underlying vulnerabilities that were exploited in the DoS attacks. These upgrades also cleaned up the blockchain by removing some 20 million empty accounts created by spam transactions.\n\nIf you are syncing with full validation, your client will slow down and may take several days, or perhaps even longer, to validate the blocks affected by the DoS attacks.\n\n(((\"fast synchronization\")))Fortunately, most Ethereum clients by default now perform a \"fast\" synchronization that skips the full validation of transactions until it has synced to the tip of the blockchain, then resumes full validation.\n\nGeth performs fast synchronization by default for Ethereum. You may need to refer to the specific instructions for other chosen Ethereum chain.\n\nParity also does fast synchronization by default.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "The First Synchronization of Ethereum-Based Blockchains"}}
{"input": "Explain the Ethereum concept: Running Geth or Parity", "output": "(((\"first synchronization\",\"Geth or Parity for\")))(((\"Geth (Go-Ethereum)\",\"for first synchronization\")))(((\"Parity\",\"for first synchronization\")))Now that you understand the challenges of the \"first sync,\" you're ready to start an Ethereum client and sync the blockchain. For both Geth and Parity, you can use the +--help+ option to see all the configuration parameters. The default settings are usually sensible and appropriate for most uses. Choose how to configure any optional parameters to suit your needs, then start Geth or Parity to sync the chain. Then wait...\n\n[TIP]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Running Geth or Parity"}}
{"input": "Explain the Ethereum concept: The JSON-RPC Interface", "output": "(((\"clients, Ethereum\",\"and JSON-RPC API\", id=\"ix_03clients-asciidoc12\", range=\"startofrange\")))(((\"first synchronization\",\"and JSON-RPC API\", id=\"ix_03clients-asciidoc13\", range=\"startofrange\")))(((\"JSON-RPC API\", id=\"ix_03clients-asciidoc14\", range=\"startofrange\")))Ethereum clients offer an application programming interface and a set of Remote Procedure Call (RPC) commands, which are encoded as JavaScript Object Notation (JSON). You will see this referred to as the _JSON-RPC API_. Essentially, the JSON-RPC API is an interface that allows us to write programs that use an Ethereum client as a _gateway_ to an Ethereum network and blockchain.\n\nUsually, the RPC interface is offered as an HTTP service on port 8545. For security reasons it is restricted, by default, to only accept connections from localhost (the IP address of your own computer, which is 127.0.0.1).\n\nTo access the JSON-RPC API, you can use a specialized library (written in the programming language of your choice) that provides \"stub\" function calls corresponding to each available RPC command, or you can manually construct HTTP requests and send/receive JSON-encoded requests. You can even use a generic command-line HTTP client, like +curl+, to call the RPC interface. Let's try that. First, ensure that you have Geth up and running, configured with --rpc to allow HTTP access to the RPC interface, then switch to a new terminal window (e.g., with Ctrl-Shift-N or Ctrl-Shift-T in an existing terminal window) as shown here:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>curl -X POST -H \"Content-Type: application/json\" --data \\\n  '{\"jsonrpc\":\"2.0\",\"method\":\"web3_clientVersion\",\"params\":[],\"id\":1}' \\\n  http://localhost:8545</strong>\n\n{\"jsonrpc\":\"2.0\",\"id\":1,\n\"result\":\"Geth/v1.9.11-unstable-0b284f6c-20200123/linux-amd64/go1.13.4\"}\n</pre>\n++++\n\nIn this example, we use +curl+ to make an HTTP connection to the address _http://localhost:8545_. We are already running +geth+, which offers the JSON-RPC API as an HTTP service on port 8545. We instruct +curl+ to use the HTTP +POST+ command and to identify the content as type +application/json+. Finally, we pass a JSON-encoded request as the +data+ component of our HTTP request. Most of our command line is just setting up +curl+ to make the HTTP connection correctly. The interesting part is the actual JSON-RPC command we issue:\n\n[[JSON_RPC_command]]\n----\n{\"jsonrpc\":\"2.0\",\"method\":\"web3_clientVersion\",\"params\":[],\"id\":1}\n----\n\nThe JSON-RPC request is formatted according to the https://www.jsonrpc.org/specification[JSON-RPC 2.0 specification]. Each request contains four elements:\n\n++jsonrpc++:: Version of the JSON-RPC protocol. This MUST be exactly ++\"2.0\"++.\n\n++method++:: The name of the method to be invoked.\n\n++params++:: A structured value that holds the parameter values to be used during the invocation of the method. This member MAY be omitted.\n\n++id++:: An identifier established by the client that MUST contain a +String+, +Number+, or +NULL+ value if included. The server MUST reply with the same value in the response object if included. This member is used to correlate the context between the two objects.\n\n[TIP]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "The JSON-RPC Interface"}}
{"input": "Explain the Ethereum concept: Parity's Geth compatibility mode", "output": "Parity has a special \"Geth compatibility mode,&#x201d; where it offers a JSON-RPC API that is identical to that offered by Geth. To run Parity in this mode, use the +--geth+ switch(((range=\"endofrange\", startref=\"ix_03clients-asciidoc14\")))(((range=\"endofrange\", startref=\"ix_03clients-asciidoc13\")))(((range=\"endofrange\", startref=\"ix_03clients-asciidoc12\"))):(((range=\"endofrange\", startref=\"ix_03clients-asciidoc11\")))(((range=\"endofrange\", startref=\"ix_03clients-asciidoc10\")))(((range=\"endofrange\", startref=\"ix_03clients-asciidoc9\")))\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>parity --geth</strong>\n</pre>\n++++\n\n[[lw_eth_clients]]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Parity's Geth compatibility mode"}}
{"input": "Explain the Ethereum concept: Remote Ethereum Clients", "output": "(((\"clients, Ethereum\",\"remote\", id=\"ix_03clients-asciidoc15\", range=\"startofrange\")))(((\"remote clients\", id=\"ix_03clients-asciidoc16\", range=\"startofrange\")))Remote clients offer a subset of the functionality of a full client. They do not store the full Ethereum blockchain, so they are faster to set up and require far less data storage.\n\n[role=\"pagebreak-before\"]\nThese clients typically provide the ability to do one or more of the following:\n\n* Manage private keys and Ethereum addresses in a wallet.\n* Create, sign, and broadcast transactions.\n* Interact with smart contracts, using the data payload.\n* Browse and interact with DApps.\n* Offer links to external services such as block explorers.\n* Convert ether units and retrieve exchange rates from external sources.\n* Inject a web3 instance into the web browser as a JavaScript object.\n* Use a web3 instance provided/injected into the browser by another client.\n* Access RPC services on a local or remote Ethereum node.\n\nSome remote clients, for example mobile (smartphone) wallets, offer only basic wallet functionality. Other remote clients are full-blown DApp browsers. Remote clients commonly offer some of the functions of a full-node Ethereum client without synchronizing a local copy of the Ethereum blockchain by connecting to a full node being run elsewhere, e.g., by you locally on your machine or on a web server, or by a third party on their servers.\n\nLet's look at some of the most popular remote clients and the functions they offer.\n\n[[mobile_wallets]]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Remote Ethereum Clients"}}
{"input": "Explain the Ethereum concept: Mobile (Smartphone) Wallets", "output": "(((\"mobile (smartphone) wallets\")))(((\"remote clients\",\"mobile wallets\")))(((\"wallets\",\"mobile\")))All mobile wallets are remote clients, because smartphones do not have adequate resources to run a full Ethereum client. Light clients are in development and not in general use for Ethereum. In the case of Parity, the light client is marked \"experimental\" and can be used by running +parity+ with the +--light+ option.\n\nPopular mobile wallets include the following (we list these merely as examples; this is not an endorsement or an indication of the security or functionality of these wallets):\n\nhttps://jaxx.io[Jaxx]:: (((\"Jaxx\",\"mobile version\")))(((\"wallets\",\"Jaxx\")))A multicurrency mobile wallet based on BIP-39 mnemonic seeds, with support for Bitcoin, Litecoin, Ethereum, Ethereum Classic, ZCash, a variety of ERC20 tokens, and many other currencies. Jaxx is available on Android and iOS, as a browser plug-in wallet, and as a desktop wallet for a variety of operating systems.\n\nhttps://status.im[Status]:: (((\"Status (mobile wallet)\")))A mobile wallet and DApp browser, with support for a variety of tokens and popular DApps. Available for iOS and Android.\n\nhttps://trustwalletapp.com/[Trust Wallet]:: (((\"Trust Wallet\")))(((\"wallets\",\"Trust\")))A mobile multi-currency wallet that supports Ethereum and Ethereum Classic as well as ERC20 and ERC223 tokens. Trust Wallet is available for iOS and Android.\n\nhttps://www.cipherbrowser.com[Cipher Browser]::  (((\"Cipher Browser\")))A full-featured Ethereum-enabled mobile DApp browser and wallet that allows integration with Ethereum apps and tokens. Available for iOS and Android.\n\n[[browser_wallets]]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Mobile (Smartphone) Wallets"}}
{"input": "Explain the Ethereum concept: Browser Wallets", "output": "(((\"browser wallets\")))(((\"remote clients\",\"browser wallets\")))(((\"wallets\",\"browser wallets\")))A variety of wallets and DApp browsers are available as plug-ins or extensions of web browsers such as Chrome and Firefox. These are remote clients that run inside your browser.\n\nSome of the more popular ones are MetaMask, Jaxx, MyEtherWallet, and MyCrypto.\n\n[[MetaMask]]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Browser Wallets"}}
{"input": "Explain the Ethereum concept: MetaMask", "output": "https://metamask.io/[MetaMask], (((\"MetaMask\",\"as browser wallet\")))introduced in <<intro_chapter>>, is a versatile browser-based wallet, RPC client, and basic contract explorer. It is available on Chrome, Firefox, Opera, and Brave Browser.\n\nUnlike other browser wallets, MetaMask injects a web3 instance into the browser JavaScript context, acting as an RPC client that connects to a variety of Ethereum blockchains (mainnet, Ropsten testnet, Kovan testnet, local RPC node, etc.). The ability to inject a web3 instance and act as a gateway to external RPC services makes MetaMask a very powerful tool for developers and users alike. It can be combined, for example, with MyEtherWallet or MyCrypto, acting as a web3 provider and RPC gateway for those tools.\n\n[[Jaxx]]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "MetaMask"}}
{"input": "Explain the Ethereum concept: Jaxx", "output": "https://jaxx.io[Jaxx], (((\"Jaxx\",\"desktop version\")))(((\"wallets\",\"Jaxx\")))which was introduced as a mobile wallet in the previous section, is also available as a Chrome and Firefox extension and as a desktop wallet.\n\n[[MEW]]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Jaxx"}}
{"input": "Explain the Ethereum concept: MyEtherWallet (MEW)", "output": "https://www.myetherwallet.com/[MyEtherWallet] (((\"MyEtherWallet (MEW)\")))(((\"wallets\",\"MyEtherWallet\")))is a browser-based JavaScript remote client that offers:\n\n* A bridge to popular hardware wallets such as the Trezor and Ledger\n* A web3 interface that can connect to a web3 instance injected by another client (e.g., MetaMask)\n* An RPC client that can connect to an Ethereum full client\n* A basic interface that can interact with smart contracts, given a contract's address and application binary interface (ABI)\n* A mobile app, MEWConnect, that enables one to use a compatible Android or iOS device to store funds, similarly to a hardware wallet.\n* A software wallet running in JavaScript\n\n[WARNING]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "MyEtherWallet (MEW)"}}
{"input": "Explain the Ethereum concept: MyCrypto", "output": "(((\"MyCrypto (wallet)\")))(((\"wallets\",\"MyCrypto\")))In early 2018, the (((\"MyEtherWallet (MEW)\")))(((\"wallets\",\"MyEtherWallet\")))MyEtherWallet project split into two competing implementations, guided by two independent development teams: a \"fork,\" as it is called in open source development. The two projects are called MyEtherWallet (the original branding) and https://mycrypto.com/[MyCrypto]. MyCrypto offers almost identical functionality to MyEtherWallet, but instead of using MEWConnect, it offers a connection to the Parity Signer mobile app. Like MEWConnect, Parity Signer stores keys on the phone and interfaces with MyCrypto in a similar manner as a hardware wallet.\n\n[[Mist]]", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "MyCrypto"}}
{"input": "Explain the Ethereum concept: Mist (Deprecated)", "output": "https://github.com/ethereum/mist[Mist] (((\"Mist (browser-based wallet)\")))(((\"wallets\",\"Mist\")))was the first Ethereum-enabled browser, built by the Ethereum Foundation. It contained a browser-based wallet that was the first implementation of the ERC20 token standard (Fabian Vogelsteller, author of ERC20, was also the main developer of Mist). Mist was also the first wallet to introduce the camelCase checksum (EIP-55). As of March, 2019, Mist was deprecated and should no longer be used.", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Mist (Deprecated)"}}
{"input": "Explain the Ethereum concept: Conclusions", "output": "In this chapter we explored Ethereum clients. You downloaded, installed, and synchronized a client, becoming a participant in the Ethereum network, and contributing to the health and stability of the system by replicating the blockchain on your own computer.(((range=\"endofrange\", startref=\"ix_03clients-asciidoc0\")))", "metadata": {"source": "ethereumbook", "chapter": "03clients.asciidoc", "section": "Conclusions"}}
{"input": "Explain the Ethereum concept: Cryptography", "output": "(((\"cryptography\", id=\"ix_04keys-addresses-asciidoc0\", range=\"startofrange\")))One of Ethereum's foundational technologies is (((\"cryptography\",\"defined\")))_cryptography_, which is a branch of mathematics used extensively in computer security. Cryptography means \"secret writing\" in Greek, but the study of cryptography encompasses more than just secret writing, which is referred to as _encryption_. Cryptography can, for example, also be used to prove knowledge of a secret without revealing that secret (e.g., with a digital signature), or to prove the authenticity of data (e.g., with digital fingerprints, also known as \"hashes\"). These types of cryptographic proofs are mathematical tools critical to the operation of the Ethereum platform (and, indeed, all blockchain systems), and are also extensively used in Ethereum applications. (((\"encryption\", seealso=\"keys and addresses\")))\n\nNote that, at the time of publication, no part of the Ethereum protocol involves encryption; that is to say all communications with the Ethereum platform and between nodes (including transaction data) are unencrypted and can (necessarily) be read by anyone. This is so everyone can verify the correctness of state updates and consensus can be reached. In the future, advanced cryptographic tools, such as zero knowledge proofs and homomorphic encryption, will be available that will allow for some encrypted calculations to be recorded on the blockchain while still enabling consensus; however, while provision has been made for them, they have yet to be deployed. \n\nIn this chapter we will introduce some of the cryptography used in Ethereum: namely public key cryptography (PKC), which is used to control ownership of funds, in the form of private keys and addresses.\n\n[[keys_addresses_intro]]", "metadata": {"source": "ethereumbook", "chapter": "04keys-addresses.asciidoc", "section": "Cryptography"}}
{"input": "Explain the Ethereum concept: Keys and Addresses", "output": "(((\"cryptography\",\"keys and addresses\")))(((\"EOA (Externally Owned Account)\",\"keys and addresses\")))(((\"keys and addresses\")))As we saw earlier in the book, Ethereum has two different types of accounts: _externally owned accounts_ (EOAs) and _contracts_. Ownership of ether by EOAs is established through digital _private keys_, _Ethereum addresses_, and _digital signatures_. (((\"private keys\", seealso=\"keys and addresses\")))The private keys are at the heart of all user interaction with Ethereum. In fact, account addresses are derived directly from private keys: a private key uniquely determines a single Ethereum address, also known as an _account_.\n\nPrivate keys are not used directly in the Ethereum system in any way; they are never transmitted or stored on Ethereum. That is to say that private keys should remain private and never appear in messages passed to the network, nor should they be stored on-chain; only account addresses and digital signatures are ever transmitted and stored on the Ethereum system. For more information on how to keep private keys safe and secure, see <<control_responsibility>> and <<wallets_chapter>>.\n\n(((\"digital signatures\")))Access and control of funds is achieved with digital signatures, which are also created using the private key. Ethereum transactions require a valid digital signature to be included in the blockchain. Anyone with a copy of a private key has control of the corresponding account and any ether it holds. Assuming a user keeps their private key safe, the digital signatures in Ethereum transactions prove the true owner of the funds, because they prove ownership of the private key.\n\n(((\"key pairs\")))In public key cryptography&#x2013;based systems, such as that used by Ethereum, keys come in pairs consisting of a private (secret) key and a public key. Think of the public key as similar to a bank account number, and the private key as similar to the secret PIN; it is the latter that provides control over the account, and the former that identifies it to others. The private keys themselves are very rarely seen by Ethereum users; for the most part, they are stored (in encrypted form) in special files and managed by Ethereum wallet software.\n\nIn the payment portion of an Ethereum transaction, the intended recipient is represented by an Ethereum address, which is used in the same way as the beneficiary account details of a bank transfer. As we will see in more detail shortly, an Ethereum address for an EOA is generated from the public key portion of a key pair. However, not all Ethereum addresses represent public\u2013private key pairs; they can also represent contracts, which, as we will see in <<smart_contracts_chapter>>, are not backed by private keys.\n\nIn the rest of this chapter, we will first explore basic cryptography in a bit more detail and explain the mathematics used in Ethereum. Then we will look at how keys are generated, stored, and managed.  Finally, we will review the various encoding formats used to represent private keys, public keys, and addresses.\n\n[[pkc]]", "metadata": {"source": "ethereumbook", "chapter": "04keys-addresses.asciidoc", "section": "Keys and Addresses"}}
{"input": "Explain the Ethereum concept: Public Key Cryptography and Cryptocurrency", "output": "(((\"cryptography\",\"public key cryptography and cryptocurrency\", id=\"ix_04keys-addresses-asciidoc1\", range=\"startofrange\")))(((\"public key cryptography\", id=\"ix_04keys-addresses-asciidoc2\", range=\"startofrange\")))Public key cryptography (also called \"asymmetric cryptography\") is a core part of modern-day information security. (((\"Diffie, Whitfield\")))(((\"Hellman, Martin\")))(((\"key exchange protocol\")))(((\"Merkle, Ralph\")))The key exchange protocol, first published in the 1970s by Martin Hellman, Whitfield Diffie, and Ralph Merkle, was a monumental breakthrough that incited the first big wave of public interest in the field of cryptography. Before the 1970s, strong cryptographic knowledge was kept secret by pass:[<span class=\"keep-together\">governments</span>].\n\nPublic key cryptography uses unique keys to secure information. These keys are based on mathematical functions that have a special property: it is easy to calculate them, but hard to calculate their inverse. Based on these functions, cryptography enables the creation of digital secrets and unforgeable digital signatures, which are secured by the laws of mathematics.\n\nFor example, multiplying two large prime numbers together is trivial. (((\"prime factorization\")))But given the product of two large primes, it is very difficult to find the prime factors (a problem called _prime factorization_). Let's say we present the number 8,018,009 and tell you it is the product of two primes. Finding those two primes is much harder for you than it was for me to multiply them to produce 8,018,009.\n\n(((\"trapdoor functions\")))Some of these mathematical functions can be inverted easily if you know some secret information. In the preceding example, if I tell you that one of the prime factors is 2,003, you can trivially find the other one with a simple division: 8,018,009 \u00f7 2,003 = 4,003. Such functions are often called _trapdoor functions_ because they are very difficult to invert unless you are given a piece of secret information that can be used as a shortcut to reverse the function.\n\n(((\"elliptic curve cryptography\")))A more advanced category of mathematical functions that is useful in cryptography is based on arithmetic operations on an elliptic curve. In elliptic curve arithmetic, multiplication modulo a prime is simple but division (the inverse) is practically impossible. (((\"discrete logarithm problem\")))This is called the _discrete logarithm problem_ and there are currently no known trapdoors. _Elliptic curve cryptography_ is used extensively in modern computer systems and is the basis of Ethereum's (and other cryptocurrencies') use of private keys and digital signatures.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "04keys-addresses.asciidoc", "section": "Public Key Cryptography and Cryptocurrency"}}
{"input": "Explain the Ethereum concept: Private Keys", "output": "(((\"private keys\", id=\"ix_04keys-addresses-asciidoc3\", range=\"startofrange\")))A private key is simply a number, picked at random. Ownership and control of the private key is the root of user control over all funds associated with the corresponding Ethereum address, as well as access to contracts that authorize that address. The private key is used to create signatures required to spend ether by proving ownership of funds used in a transaction. (((\"warnings and cautions\",\"private key protection\")))The private key must remain secret at all times, because revealing it to third parties is equivalent to giving them control over the ether and contracts secured by that private key. The private key must also be backed up and protected from accidental loss. If it's lost, it cannot be recovered and the funds secured by it are lost forever too.\n\n[TIP]", "metadata": {"source": "ethereumbook", "chapter": "04keys-addresses.asciidoc", "section": "Private Keys"}}
{"input": "Explain the Ethereum concept: Generating a Private Key from a Random Number", "output": "(((\"entropy\",\"private key generation and\")))(((\"private keys\",\"generating from random number\")))(((\"random numbers, private key generation from\")))The first and most important step in generating keys is to find a secure source of entropy, or randomness. Creating an Ethereum private key essentially involves picking a number between 1 and 2^256^. The exact method you use to pick that number does not matter as long as it is not predictable or deterministic. Ethereum software uses the underlying operating system's random number generator to produce 256 random bits. Usually, the OS random number generator is initialized by a human source of randomness, which is why you may be asked to wiggle your mouse around for a few seconds, or press random keys on your keyboard. An alternative could be cosmic radiation noise on the computer's microphone channel.\n\nMore precisely, a private key can be any nonzero number up to a very large number slightly less than 2^256^&#x2014;a huge 78-digit number, roughly 1.158 * 10^77^. The exact number shares the first 38 digits with 2^256^ and is defined as the order of the elliptic curve used in Ethereum (see <<elliptic_curve>>). To create a private key, we randomly pick a 256-bit number and check that it is within the valid range. In programming terms, this is usually achieved by feeding an even larger string of random bits (collected from a cryptographically secure source of randomness) into a 256-bit hash algorithm such as Keccak-256 or SHA-256, both of which will conveniently produce a 256-bit number. If the result is within the valid range, we have a suitable private key. Otherwise, we simply try again with another random number.\n\n[TIP]", "metadata": {"source": "ethereumbook", "chapter": "04keys-addresses.asciidoc", "section": "Generating a Private Key from a Random Number"}}
{"input": "Explain the Ethereum concept: Public Keys", "output": "(((\"cryptography\",\"public keys\", id=\"ix_04keys-addresses-asciidoc4\", range=\"startofrange\")))(((\"elliptic curve cryptography\",\"public key generation\", id=\"ix_04keys-addresses-asciidoc5\", range=\"startofrange\")))(((\"public keys\", seealso=\"keys and addresses\", id=\"ix_04keys-addresses-asciidoc6\", range=\"startofrange\")))An Ethereum public key is a _point_ on an elliptic curve, meaning it is a set of _x_ and _y_ coordinates that satisfy the elliptic curve equation.\n\nIn simpler terms, an Ethereum public key is two numbers, joined together. These numbers are produced from the private key by a calculation that can _only go one way_. That means that it is trivial to calculate a public key if you have the private key, but you cannot calculate the private key from the public key.\n\n[WARNING]", "metadata": {"source": "ethereumbook", "chapter": "04keys-addresses.asciidoc", "section": "Public Keys"}}
{"input": "Explain the Ethereum concept: Elliptic Curve Cryptography Explained", "output": "(((\"elliptic curve cryptography\",\"basics\", id=\"ix_04keys-addresses-asciidoc7\", range=\"startofrange\")))Elliptic (((\"elliptic curve cryptography\", id=\"ix_04keys-addresses-asciidoc8\", range=\"startofrange\")))(((\"public keys\",\"elliptic curve cryptography and\", id=\"ix_04keys-addresses-asciidoc9\", range=\"startofrange\")))curve cryptography is a type of asymmetric or public key cryptography based on the discrete logarithm problem as expressed by addition and multiplication on the points of an elliptic curve.\n\n<<ecc-curve>> is an example of an elliptic curve, similar to that used by Ethereum.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "04keys-addresses.asciidoc", "section": "Elliptic Curve Cryptography Explained"}}
{"input": "Explain the Ethereum concept: Elliptic Curve Arithmetic Operations", "output": "(((\"elliptic curve cryptography\",\"arithmetic operations\")))A lot of elliptic curve math looks and works very much like the integer arithmetic we learned at school. Specifically, we can define an addition operator, which instead of jumping along the number line is jumping to other points on the curve. Once we have the addition operator, we can also define multiplication of a point and a whole number, which is equivalent to repeated addition.\n\nElliptic curve addition is defined such that given two points _P_~1~ and _P_~2~ on the elliptic curve, there is a third point _P_~3~ = _P_~1~ + _P_~2~, also on the elliptic curve.\n\nGeometrically, this third point _P_~3~ is calculated by drawing a line between _P_~1~ and _P_~2~. This line will intersect the elliptic curve in exactly one additional place (amazingly). Call this point _P_~3~' = (_x_, _y_). Then reflect in the x-axis to get _P_~3~ = (_x_, _\u2013y_).\n\nIf _P_~1~ and _P_~2~ are the same point, the line \"between\" _P_~1~ and _P_~2~ should extend to be the tangent to the curve at this point _P_~1~. This tangent will intersect the curve at exactly one new point. You can use techniques from calculus to determine the slope of the tangent line. Curiously, these techniques work, even though we are restricting our interest to points on the curve with two integer coordinates!\n\nIn elliptic curve math, there is also a point called the \"point at infinity,\" which roughly corresponds to the role of the number zero in addition. On computers, it's sometimes represented by _x_ = _y_ = 0 (which doesn't satisfy the elliptic curve equation, but it's an easy separate case that can be checked). There are a couple of special cases that explain the need for the point at infinity.\n\nIn some cases (e.g., if _P_~1~ and _P_~2~ have the same _x_ values but different _y_ values), the line will be exactly vertical, in which case _P_~3~ = the point at infinity.\n\nIf _P_~1~ is the point at infinity, then _P_~1~ + _P_~2~ = _P_~2~. Similarly, if _P_~2~ is the point at infinity, then _P_~1~ + _P_~2~ = _P_~1~. This shows how the point at infinity plays the role that zero plays in \"normal\" arithmetic.\n\nIt turns out that pass:[+] is associative, which means that (_A_ pass:[+] _B_) pass:[+] _C_ = _A_ pass:[+] (_B_ pass:[+] _C_). That means we can write _A_ pass:[+] _B_ pass:[+] _C_ (without parentheses) without ambiguity.\n\nNow that we have defined addition, we can define multiplication in the standard way that extends addition. For a point _P_ on the elliptic curve, if _k_ is a whole number, then _k_ pass:[*] _P_ = _P_ pass:[+] _P_ pass:[+] _P_ pass:[+] ... pass:[+] _P_ (_k_ times). Note that _k_ is sometimes (perhaps confusingly) called an \"exponent\" in this case.(((range=\"endofrange\", startref=\"ix_04keys-addresses-asciidoc8\")))(((range=\"endofrange\", startref=\"ix_04keys-addresses-asciidoc7\")))\n\n[[public_key_derivation]]", "metadata": {"source": "ethereumbook", "chapter": "04keys-addresses.asciidoc", "section": "Elliptic Curve Arithmetic Operations"}}
{"input": "Explain the Ethereum concept: Generating a Public Key", "output": "(((\"elliptic curve cryptography\",\"public key generation with\")))(((\"generator point\")))(((\"public keys\",\"generating\")))Starting with a private key in the form of a randomly generated number _k_, we multiply it by a predetermined point on the curve called the _generator point_ _G_ to produce another point somewhere else on the curve, which is the corresponding public key _K_: \n\n++++\n<div data-type=\"equation\">\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mrow>\n    <mi>K</mi>\n    <mo>=</mo>\n    <mi>k</mi>\n    <mo>*</mo>\n    <mi>G</mi>\n  </mrow>\n</math>\n</div>\n++++\n\n(((\"secp256k1 elliptic curve\")))The generator point is specified as part of the +secp256k1+ standard; it is the same for all implementations of +secp256k1+, and all keys derived from that curve use the same point _G_. Because the generator point is always the same for all Ethereum users, a private key _k_ multiplied with _G_ will always result in the same public key _K_. The relationship between _k_ and _K_ is fixed, but can only be calculated in one direction, from _k_ to _K_. That's why an Ethereum address (derived from _K_) can be shared with anyone and does not reveal the user's private key (_k_).\n\nAs we described in the previous section, the multiplication of _k_ * _G_ is equivalent to repeated addition, so _G_ pass:[+] _G_ pass:[+] _G_ pass:[+] ... pass:[+] _G_, repeated _k_ times. In summary, to produce a public key _K_ from a private key _k_, we add the generator point _G_ to itself, _k_ times.\n\n[TIP]", "metadata": {"source": "ethereumbook", "chapter": "04keys-addresses.asciidoc", "section": "Generating a Public Key"}}
{"input": "Explain the Ethereum concept: Elliptic Curve Libraries", "output": "(((\"elliptic curve cryptography\",\"libraries\")))(((\"secp256k1 elliptic curve\")))There are a couple of implementations of the +secp256k1+ elliptic curve that are used in cryptocurrency-related projects:\n\n(((\"OpenSSL cryptographic library\")))https://www.openssl.org/[OpenSSL]:: The OpenSSL library offers a comprehensive set of cryptographic primitives, including a full implementation of +secp256k1+. For example, to derive the public key, the function +EC_POINT_mul+ can be used.\n\n(((\"libsecp256k1 cryptographic library\")))https://github.com/bitcoin-core/secp256k1[libsecp256k1]:: Bitcoin Core's +libsecp256k1+ is a C-language implementation of the +secp256k1+ elliptic curve and other cryptographic primitives. It was written from scratch to replace OpenSSL in Bitcoin Core software, and is considered superior in both performance and security.(((range=\"endofrange\", startref=\"ix_04keys-addresses-asciidoc6\")))(((range=\"endofrange\", startref=\"ix_04keys-addresses-asciidoc5\")))(((range=\"endofrange\", startref=\"ix_04keys-addresses-asciidoc4\")))\n\n[[hash_functions]]", "metadata": {"source": "ethereumbook", "chapter": "04keys-addresses.asciidoc", "section": "Elliptic Curve Libraries"}}
{"input": "Explain the Ethereum concept: Cryptographic Hash Functions", "output": "(((\"cryptographic hash functions\", id=\"ix_04keys-addresses-asciidoc11\", range=\"startofrange\")))(((\"cryptography\",\"hash functions\", id=\"ix_04keys-addresses-asciidoc12\", range=\"startofrange\")))(((\"hash functions\", id=\"ix_04keys-addresses-asciidoc13\", range=\"startofrange\")))Cryptographic hash functions are used throughout Ethereum. In fact, hash functions are used extensively in almost all cryptographic systems&#x2014;a fact captured by (((\"Schneier, Bruce\")))pass:[<span class=\"keep-together\">cryptographer</span>] http://bit.ly/2Q79qZp[Bruce Schneier], who said, \"Much more than encryption algorithms, one-way hash functions are the workhorses of modern cryptography.\"\n\nIn this section we will discuss hash functions, explore their basic properties, and see how those properties make them so useful in so many areas of modern cryptography. We address hash functions here because they are part of the transformation of Ethereum public keys into addresses. (((\"digital fingerprint\")))They can also be used to create _digital fingerprints_, which aid in the verification of data.\n\n(((\"one-way functions\")))In simple terms, a http://bit.ly/2CR26gD[_hash function_] is &#x201c;any function that can be used to map data of arbitrary size to data of fixed size.&#x201d; (((\"pre-image\")))The input to a hash function is called a _pre-image_, the _message_, or simply the _input data_. The output is called the _hash_. http://bit.ly/2Jrn3jM[_Cryptographic hash functions_] are a special subcategory that have specific properties that are useful to secure platforms, such as Ethereum.\n\nA cryptographic hash function is a _one-way_ hash function that maps data of arbitrary size to a fixed-size string of bits. The \"one-way\" nature means that it is computationally infeasible to recreate the input data if one only knows the output hash. The only way to determine a possible input is to conduct a brute-force search, checking each candidate for a matching output; given that the search space is virtually infinite, it is easy to understand the practical impossibility of the task. Even if you find some input data that creates a matching hash, it may not be the original input data: hash functions are \"many-to-one\" functions. (((\"hash collision\")))Finding two sets of input data that hash to the same output is called finding a _hash collision_. Roughly speaking, the better the hash function, the rarer hash collisions are. For Ethereum, they are effectively impossible.\n\n(((\"hash functions\",\"main properties\")))Let's take a closer look at the main properties of cryptographic hash functions. These include:\n\nDeterminism:: A given input message always produces the same hash output.\n\nVerifiability:: Computing the hash of a message is efficient (linear complexity).\n\nNoncorrelation:: A small change to the message (e.g., a 1-bit change) should change the hash output so extensively that it cannot be correlated to the hash of the original message.\n\nIrreversibility:: Computing the message from its hash is infeasible, equivalent to a brute-force search through all possible messages.\n\nCollision protection:: It should be infeasible to calculate two different messages that produce the same hash output.\n\nResistance to hash collisions is particularly important for avoiding digital signature forgery in Ethereum.\n\nThe combination of these properties make cryptographic hash functions useful for a broad range of security applications, including:\n\n* Data fingerprinting\n* Message integrity (error detection)\n* Proof of work\n* Authentication (password hashing and key stretching)\n* Pseudorandom number generators\n* Message commitment (commit\u2013reveal mechanisms)\n* Unique identifiers\n\nWe will find many of these in Ethereum as we progress through the various layers of the system.\n\n[[keccak256]]", "metadata": {"source": "ethereumbook", "chapter": "04keys-addresses.asciidoc", "section": "Cryptographic Hash Functions"}}
{"input": "Explain the Ethereum concept: Ethereum's Cryptographic Hash Function: Keccak-256", "output": "(((\"hash functions\",\"Keccak-256\")))(((\"Keccak-256 hash function\")))(((\"SHA-3 Hash Function\")))Ethereum uses the _Keccak-256_ cryptographic hash function in many places. Keccak-256 was designed as a candidate for the SHA-3 Cryptographic Hash Function Competition held in 2007 by the (((\"National Institute of Standards and Technology (NIST)\")))(((\"NIST (National Institute of Standards and Technology)\")))National Institute of Standards and Technology. Keccak was the winning algorithm, which became standardized as (((\"Federal Information Processing Standard (FIPS)\")))(((\"FIPS (Federal Information Processing Standard)\")))(((\"FIPS-202\")))Federal Information Processing Standard (FIPS) 202 in 2015.\n\nHowever, during the period when Ethereum was developed, the NIST standardization was not yet finalized. NIST adjusted some of the parameters of Keccak after the completion of the standards process, allegedly to improve its efficiency. This was occurring at the same time as heroic whistleblower (((\"Snowden, Edward\")))Edward Snowden revealed documents that imply that NIST may have been improperly influenced by the National Security Agency to intentionally weaken the (((\"Dual_EC_DRBG\")))Dual_EC_DRBG random-number generator standard, effectively placing a backdoor in the standard random number generator. The result of this controversy was a backlash against the proposed changes and a significant delay in the standardization of SHA-3. At the time, the Ethereum Foundation decided to implement the original Keccak algorithm, as proposed by its inventors, rather than the SHA-3 standard as modified by NIST.\n\n[WARNING]", "metadata": {"source": "ethereumbook", "chapter": "04keys-addresses.asciidoc", "section": "Ethereum's Cryptographic Hash Function: Keccak-256"}}
{"input": "Explain the Ethereum concept: Which Hash Function Am I Using?", "output": "(((\"hash functions\",\"test vector for determining\")))(((\"test vector, determining hash functions with\")))How can you tell if the software library you are using implements FIPS-202 SHA-3 or Keccak-256, if both might be called \"SHA-3\"?\n\nAn easy way to tell is to use a _test vector_, an expected output for a given input. (((\"empty input test\")))The test most commonly used for a hash function is the _empty input_. If you run the hash function with an empty string as input you should see the following results:\n\n----\nKeccak256(\"\") =\n  c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\n\nSHA3(\"\") =\n  a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a\n----\n\n\nRegardless of what the function is called, you can test it to see whether it is the original Keccak-256 or the final NIST standard FIPS-202 SHA-3 by running this simple test. Remember, Ethereum uses Keccak-256, even though it is often called SHA-3 in the code.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "04keys-addresses.asciidoc", "section": "Which Hash Function Am I Using?"}}
{"input": "Explain the Ethereum concept: Ethereum Addresses", "output": "(((\"addresses\", id=\"ix_04keys-addresses-asciidoc14\", range=\"startofrange\")))(((\"cryptography\",\"Ethereum addresses and\", id=\"ix_04keys-addresses-asciidoc15\", range=\"startofrange\")))Ethereum addresses are _unique identifiers_ that are derived from public keys or contracts using the Keccak-256 one-way hash function.\n\nIn our previous examples, we started with a private key and used elliptic curve multiplication to derive a public key:\n\n[role=\"pagebreak-before\"]\nPrivate key _k_:\n\n----\nk = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315\n----\n\n[[concat_pubkey]]\nPublic key _K_ (_x_ and _y_ coordinates concatenated and shown as hex):\n\n----\nK = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e...\n----\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "04keys-addresses.asciidoc", "section": "Ethereum Addresses"}}
{"input": "Explain the Ethereum concept: Ethereum Address Formats", "output": "(((\"addresses\",\"formats\")))Ethereum addresses are hexadecimal numbers, identifiers derived from the last 20 bytes of the Keccak-256 hash of the public key.\n\n(((\"checksum\",\"in Ethereum address formats\")))Unlike Bitcoin addresses, which are encoded in the user interface of all clients to include a built-in checksum to protect against mistyped addresses, Ethereum addresses are presented as raw hexadecimal without any checksum.\n\nThe rationale behind that decision was that Ethereum addresses would eventually be hidden behind abstractions (such as name services) at higher layers of the system and that checksums should be added at higher layers if necessary.\n\nIn reality, these higher layers were developed too slowly and this design choice led to a number of problems in the early days of the ecosystem, including the loss of funds due to mistyped addresses and input validation errors. Furthermore, because Ethereum name services were developed slower than initially expected, alternative encodings were adopted very slowly by wallet developers. We'll look at a few of the encoding options next.\n\n[[ICAP]]", "metadata": {"source": "ethereumbook", "chapter": "04keys-addresses.asciidoc", "section": "Ethereum Address Formats"}}
{"input": "Explain the Ethereum concept: Inter Exchange Client Address Protocol", "output": "(((\"addresses\",\"ICAP encoding\", id=\"ix_04keys-addresses-asciidoc16\", range=\"startofrange\")))(((\"ICAP (Inter-exchange Client Address Protocol)\", id=\"ix_04keys-addresses-asciidoc17\", range=\"startofrange\")))(((\"Inter-exchange Client Address Protocol (ICAP)\", id=\"ix_04keys-addresses-asciidoc18\", range=\"startofrange\")))The _Inter exchange Client Address Protocol_ (ICAP) is an Ethereum address encoding that is partly compatible with the (((\"IBAN (International Bank Account Number)\")))(((\"International Bank Account Number (IBAN)\")))International Bank Account Number (IBAN) encoding, offering a versatile, checksummed, and interoperable encoding for Ethereum addresses. ICAP addresses can encode Ethereum addresses or common names registered with an Ethereum name registry. You can read more about ICAP on the https://eth.wiki/en/ideas/inter-exchange-client-address-protocol-icap[Ethereum Wiki].\n\nIBAN is an international standard for identifying bank account numbers, mostly used for wire transfers. It is broadly adopted in the European Single Euro Payments Area (SEPA) and beyond. IBAN is a centralized and heavily regulated service. ICAP is a decentralized but compatible implementation for Ethereum addresses.\n\nAn IBAN consists of a string of up to 34 alphanumeric characters (case-insensitive) comprising a country code, checksum, and bank account identifier (which is country-specific).\n\nICAP uses the same structure by introducing a nonstandard country code, &#x201c;XE,&#x201d; that stands for \"Ethereum,&#x201d; followed by a two-character checksum and three possible variations of an account identifier:\n\nDirect:: A big-endian base-36 integer comprised of up to 30 alphanumeric characters, representing the 155 least significant bits of an Ethereum address. Because this encoding fits less than the full 160 bits of a general Ethereum address, it only works for Ethereum addresses that start with one or more zero bytes. The advantage is that it is compatible with IBAN, in terms of the field length and checksum. Example: +XE60HAMICDXSV5QXVJA7TJW47Q9CHWKJD+ (33 characters long).\n\nBasic:: Same as the Direct encoding, except that it is 31 characters long. This allows it to encode any Ethereum address, but makes it incompatible with IBAN field validation. Example: +XE18CHDJBPLTBCJ03FE9O2NS0BPOJVQCU2P+ (35 characters long).\n\nIndirect:: Encodes an identifier that resolves to an Ethereum address through a name registry provider. It uses 16 alphanumeric characters, comprising an _asset identifier_ (e.g., ETH), a name service (e.g., XREG), and a 9-character human-readable name (e.g., KITTYCATS). Example: +XEpass:[##]ETHXREGKITTYCATS+ (20 characters long), where the +##+ should be replaced by the two computed checksum characters.\n\n(((\"EthereumJS helpeth\")))(((\"helpeth command-line tool\")))We can use the +helpeth+ command-line tool to create ICAP addresses. You can get helpeth by installing it with:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>npm install -g helpeth</strong>\n</pre>\n++++\n\nIf you don't have npm, you may have to install nodeJS first, which you can do by following the instructions at https://nodeJS.org. \n\nNow that we have helpeth, let's try creating an ICAP address with our example private key (prefixed with +0x+ and passed as a parameter to +helpeth+). \n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>helpeth keyDetails \\\n  -p 0xf8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315</strong>\n\nAddress: 0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9\nICAP: XE60 HAMI CDXS V5QX VJA7 TJW4 7Q9C HWKJ D\nPublic key: 0x6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b...\n</pre>\n++++\n\nThe +helpeth+ command constructs a hexadecimal Ethereum address as well as an ICAP address for us. The ICAP address for our example key is:\n\n[[ICAP_example]]\n----\nXE60HAMICDXSV5QXVJA7TJW47Q9CHWKJD\n----\n\nBecause our example Ethereum address happens to start with a zero byte, it can be encoded using the Direct ICAP encoding method that is valid in IBAN format. You can tell because it is 33 characters long.\n\nIf our address did not start with a zero, it would be encoded with the Basic encoding, which would be 35 characters long and invalid as an IBAN.\n\n[TIP]", "metadata": {"source": "ethereumbook", "chapter": "04keys-addresses.asciidoc", "section": "Inter Exchange Client Address Protocol"}}
{"input": "Explain the Ethereum concept: Hex Encoding with Checksum in Capitalization (EIP-55)", "output": "(((\"addresses\",\"hex encoding with checksum in capitalization (EIP-55)\", id=\"ix_04keys-addresses-asciidoc19\", range=\"startofrange\")))(((\"checksum\",\"EIP-55 and\", id=\"ix_04keys-addresses-asciidoc20\", range=\"startofrange\")))(((\"EIP-55 (Ethereum Improvement Proposal 55)\",\"checksum for addresses\", id=\"ix_04keys-addresses-asciidoc21\", range=\"startofrange\")))Due to the slow deployment of ICAP and name services, a standard was proposed by https://github.com/Ethereum/EIPs/blob/master/EIPS/eip-55.md[Ethereum Improvement Proposal 55 (EIP-55)]. EIP-55 offers a backward-compatible checksum for Ethereum addresses by modifying the capitalization of the hexadecimal address. The idea is that Ethereum addresses are case-insensitive and all wallets are supposed to accept Ethereum addresses expressed in capital or lowercase characters, without any difference in interpretation.\n\nBy modifying the capitalization of the alphabetic characters in the address, we can convey a checksum that can be used to protect the integrity of the address against typing or reading mistakes. Wallets that do not support EIP-55 checksums simply ignore the fact that the address contains mixed capitalization, but those that do support it can validate it and detect errors with a 99.986% accuracy.\n\nThe mixed-capitals encoding is subtle and you may not notice it at first. Our example address is:\n\n----\n0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9\n----\n\nWith an EIP-55 mixed-capitalization checksum it becomes:\n\n[[mixed_capitalization]]\n----\n0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9\n----\n\nCan you tell the difference? Some of the alphabetic (A&#x2013;F) characters from the hexadecimal encoding alphabet are now capital, while others are lowercase.\n\nEIP-55 is quite simple to implement. We take the Keccak-256 hash of the lowercase hexadecimal address. This hash acts as a digital fingerprint of the address, giving us a convenient checksum. Any small change in the input (the address) should cause a big change in the resulting hash (the checksum), allowing us to detect errors effectively. The hash of our address is then encoded in the capitalization of the address itself. Let's break it down, step by step:\n\n1. Hash the lowercase address, without the +0x+ prefix:\n\n[[hash_lower_case_address]]\n----\nKeccak256(\"001d3f1ef827552ae1114027bd3ecf1f086ba0f9\") =\n23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9695d9a19d8f673ca991deae1\n----\n\n[start=2]\n1. Capitalize each alphabetic address character if the corresponding hex digit of the hash is greater than or equal to +0x8+. This is easier to show if we line up the address and the hash:\n\n[[capitalize_input]]\n----\nAddress: 001d3f1ef827552ae1114027bd3ecf1f086ba0f9\nHash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...\n----\n\nOur address contains an alphabetic character +d+ in the fourth position. The fourth character of the hash is +6+, which is less than +8+. So, we leave the +d+ lowercase. The next alphabetic character in our address is +f+, in the sixth position. The sixth character of the hexadecimal hash is +c+, which is greater than +8+. Therefore, we capitalize the +F+ in the address, and so on. As you can see, we only use the first 20 bytes (40 hex characters) of the hash as a checksum, since we only have 20 bytes (40 hex characters) in the address to capitalize appropriately.\n\nCheck the resulting mixed-capitals address yourself and see if you can tell which characters were capitalized and which characters they correspond to in the address hash:\n\n[[capitalize_output]]\n----\nAddress: 001d3F1ef827552Ae1114027BD3ECF1f086bA0F9\nHash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...\n----\n\n[[EIP55_error]]", "metadata": {"source": "ethereumbook", "chapter": "04keys-addresses.asciidoc", "section": "Hex Encoding with Checksum in Capitalization (EIP-55)"}}
{"input": "Explain the Ethereum concept: Detecting an error in an EIP-55 encoded address", "output": "(((\"EIP-55 (Ethereum Improvement Proposal 55)\",\"detecting an error in an encoded address\")))Now, let's look at how EIP-55 addresses will help us find an error. Let's assume we have printed out an Ethereum address, which is EIP-55 encoded:\n\n[[correct_address]]\n----\n0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9\n----\n\nNow let's make a basic mistake in reading that address. The character before the last one is a capital +F+. For this example let's assume we misread that as a capital +E+, and we type the following (incorrect) address into our wallet:\n\n[[incorrect_address]]\n----\n0x001d3F1ef827552Ae1114027BD3ECF1f086bA0E9\n----\n\nFortunately, our wallet is EIP-55 compliant! It notices the mixed capitalization and attempts to validate the address. It converts it to lowercase, and calculates the checksum hash:\n\n[[hash_demo]]\n----\nKeccak256(\"001d3f1ef827552ae1114027bd3ecf1f086ba0e9\") =\n5429b5d9460122fb4b11af9cb88b7bb76d8928862e0a57d46dd18dd8e08a6927\n----\n\nAs you can see, even though the address has only changed by one character (in fact, only one bit, as +e+ and +f+ are one bit apart), the hash of the address has changed radically. That's the property of hash functions that makes them so useful for checksums!\n\nNow, let's line up the two and check the capitalization:\n\n[[incorrect_capitalization]]\n----\n001d3F1ef827552Ae1114027BD3ECF1f086bA0E9\n5429b5d9460122fb4b11af9cb88b7bb76d892886...\n----\n\nIt's all wrong! Several of the alphabetic characters are incorrectly capitalized. Remember that the capitalization is the encoding of the _correct_ checksum.\n\nThe capitalization of the address we input doesn't match the checksum just calculated, meaning something has changed in the address, and an error has been pass:[<span class=\"keep-together\">introduced</span>](((range=\"endofrange\", startref=\"ix_04keys-addresses-asciidoc21\")))(((range=\"endofrange\", startref=\"ix_04keys-addresses-asciidoc20\")))(((range=\"endofrange\", startref=\"ix_04keys-addresses-asciidoc19\"))).(((range=\"endofrange\", startref=\"ix_04keys-addresses-asciidoc15\")))(((range=\"endofrange\", startref=\"ix_04keys-addresses-asciidoc14\")))\n\n\n[[keys-addresses-conclusions]]", "metadata": {"source": "ethereumbook", "chapter": "04keys-addresses.asciidoc", "section": "Detecting an error in an EIP-55 encoded address"}}
{"input": "Explain the Ethereum concept: Conclusions", "output": "In this chapter we provided a brief survey of public key cryptography and focused on the use of public and private keys in Ethereum and the use of cryptographic tools, such as hash functions, in the creation and verification of Ethereum addresses. We also looked at digital signatures and how they can demonstrate ownership of a private key without revealing that private key. In <<wallets_chapter>>, we will put these ideas together and look at how wallets can be used to manage collections of keys.(((range=\"endofrange\", startref=\"ix_04keys-addresses-asciidoc0\")))", "metadata": {"source": "ethereumbook", "chapter": "04keys-addresses.asciidoc", "section": "Conclusions"}}
{"input": "Explain the Ethereum concept: Wallets", "output": "(((\"wallets\", id=\"ix_05wallets-asciidoc0\", range=\"startofrange\")))The word \"wallet\" is used to describe a few different things in Ethereum.\n\nAt a high level, a wallet is a software application that serves as the primary user interface to Ethereum. The wallet controls access to a user's money, managing keys and addresses, tracking the balance, and creating and signing transactions. In addition, some Ethereum wallets can also interact with contracts, such as ERC20 tokens.\n\n(((\"wallets\",\"defined\")))More narrowly, from a programmer's perspective, the word _wallet_ refers to the system used to store and manage a user's keys. Every wallet has a key-management component. For some wallets, that's all there is. Other wallets are part of a much broader category, that of _browsers_, which are interfaces to Ethereum-based decentralized applications, or _DApps_, which we will examine in more detail in <<decentralized_applications_chap>>. There are no clear lines of distinction between the various categories that are conflated under the term wallet.\n\nIn this chapter we will look at wallets as containers for private keys, and as systems for managing these keys.\n\n[[wallet_tech_overview]]", "metadata": {"source": "ethereumbook", "chapter": "05wallets.asciidoc", "section": "Wallets"}}
{"input": "Explain the Ethereum concept: Wallet Technology Overview", "output": "(((\"wallets\",\"technology overview\", id=\"ix_05wallets-asciidoc1\", range=\"startofrange\")))In this section we summarize the various technologies used to construct user-friendly, secure, and flexible Ethereum wallets.\n\nOne key consideration in designing wallets is balancing convenience and privacy. The most convenient Ethereum wallet is one with a single private key and address that you reuse for everything. Unfortunately, such a solution is a privacy nightmare, as anyone can easily track and correlate all your transactions. Using a new key for every transaction is best for privacy, but becomes very difficult to manage. The correct balance is difficult to achieve, but that's why good wallet design is paramount.\n\nA common misconception about Ethereum is that Ethereum wallets contain ether or tokens. In fact, very strictly speaking, the wallet holds only keys. The ether or other tokens are recorded on the Ethereum blockchain. Users control the tokens on the network by signing transactions with the keys in their wallets. (((\"keychains\")))In a sense, an Ethereum wallet is a _keychain_. Having said that, given that the keys held by the wallet are the only things that are needed to transfer ether or tokens to others, in practice this distinction is fairly irrelevant. Where the difference does matter is in changing one's mindset from dealing with the centralized system of conventional banking (where only you, and the bank, can see the money in your account, and you only need convince the bank that you want to move funds to make a transaction) to the decentralized system of blockchain platforms (where everyone can see the ether balance of an account, although they probably don't know the account's owner, and everyone needs to be convinced the owner wants to move funds for a transaction to be enacted). In practice this means that there is an independent way to check an account's balance, without needing its wallet. Moreover, you can move your account handling from your current wallet to a different wallet, if you grow to dislike the wallet app you started out using.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "05wallets.asciidoc", "section": "Wallet Technology Overview"}}
{"input": "Explain the Ethereum concept: Nondeterministic (Random) Wallets", "output": "In the first Ethereum wallet (produced for the Ethereum pre-sale), each wallet file stored a single randomly generated private key. Such wallets are being replaced with deterministic wallets because these \"old-style\" wallets are in many ways inferior. For example, it is considered good practice to avoid Ethereum address reuse as part of maximizing your privacy while using Ethereum&#x2014;i.e., to use a new address (which needs a new private key) every time you receive funds. You can go further and use a new address for each transaction, although this can get expensive if you deal a lot with tokens. To follow this practice, a nondeterministic wallet will need to regularly increase its list of keys, which means you will need to make regular backups. If you ever lose your data (disk failure, drink accident, phone stolen) before you've managed to back up your wallet, you will lose access to your funds and smart contracts. The \"type 0\" nondeterministic wallets are the hardest to deal with, because they create a new wallet file for every new address in a \"just in time\" manner.\n\n(((\"keystore file\")))Nevertheless, many Ethereum clients (including +geth+) use a _keystore_ file, which is a JSON-encoded file that contains a single (randomly generated) private key, encrypted by a passphrase for extra security. The JSON file's contents look like this:\n\n[[keystore_example]]\n[source,json]\n----\n{\n    \"address\": \"001d3f1ef827552ae1114027bd3ecf1f086ba0f9\",\n    \"crypto\": {\n        \"cipher\": \"aes-128-ctr\",\n        \"ciphertext\":\n            \"233a9f4d236ed0c13394b504b6da5df02587c8bf1ad8946f6f2b58f055507ece\",\n        \"cipherparams\": {\n            \"iv\": \"d10c6ec5bae81b6cb9144de81037fa15\"\n        },\n        \"kdf\": \"scrypt\",\n        \"kdfparams\": {\n            \"dklen\": 32,\n            \"n\": 262144,\n            \"p\": 1,\n            \"r\": 8,\n            \"salt\":\n                \"99d37a47c7c9429c66976f643f386a61b78b97f3246adca89abe4245d2788407\"\n        },\n        \"mac\": \"594c8df1c8ee0ded8255a50caf07e8c12061fd859f4b7c76ab704b17c957e842\"\n    },\n    \"id\": \"4fcb2ba4-ccdb-424f-89d5-26cce304bf9c\",\n    \"version\": 3\n}\n----\n\n(((\"key derivation function (KDF)\")))(((\"password stretching algorithm\")))The keystore format uses a _key derivation function_ (KDF), also known as a password stretching algorithm, which protects against brute-force, dictionary, and rainbow table attacks. In simple terms, the private key is not encrypted by the passphrase directly. Instead, the passphrase is _stretched_, by repeatedly hashing it. The hashing function is repeated for 262,144 rounds, which can be seen in the keystore JSON as the parameter +crypto.kdfparams.n+. An attacker trying to brute-force the passphrase would have to apply 262,144 rounds of hashing for every attempted passphrase, which slows down the attack sufficiently to make it infeasible for passphrases of sufficient complexity and length.\n\nThere are a number of software libraries that can read and write the keystore format, such as the JavaScript library https://github.com/ethereumjs/keythereum[+keythereum+].\n\n[TIP]", "metadata": {"source": "ethereumbook", "chapter": "05wallets.asciidoc", "section": "Nondeterministic (Random) Wallets"}}
{"input": "Explain the Ethereum concept: Deterministic (Seeded) Wallets", "output": "(((\"deterministic (seeded) wallets\",\"about\")))(((\"wallets\",\"deterministic\")))Deterministic or \"seeded\" wallets are wallets that contain private keys that are all derived from a single master key, or seed. The seed is a randomly generated number that is combined with other data, such as an index number or \"chain code\" (see <<extended_keys>>), to derive any number of private keys. In a deterministic wallet, the seed is sufficient to recover all the derived keys, and therefore a single backup, at creation time, is sufficient to secure all the funds and smart contracts in the wallet. The seed is also sufficient for a wallet export or import, allowing for easy migration of all the keys between different wallet implementations.\n\nThis design makes the security of the seed of utmost importance, as only the seed is needed to gain access to the entire wallet. On the other hand, being able to focus security efforts on a single piece of data can be seen as an advantage.\n\n[[hd_wallets]]", "metadata": {"source": "ethereumbook", "chapter": "05wallets.asciidoc", "section": "Deterministic (Seeded) Wallets"}}
{"input": "Explain the Ethereum concept: Hierarchical Deterministic Wallets (BIP-32/BIP-44)", "output": "(((\"Bitcoin improvement proposals (BIPs)\",\"Hierarchical Deterministic Wallets (BIP-32/BIP-44)\")))(((\"hierarchical deterministic wallets (BIP-32/BIP-44)\")))Deterministic wallets were developed to make it easy to derive many keys from a single seed. Currently, the most advanced form of deterministic wallet is the _hierarchical deterministic_ (HD) wallet defined by Bitcoin's http://bit.ly/2B2vQWs[_BIP-32 standard_]. HD wallets contain keys derived in a tree structure, such that a parent key can derive a sequence of child keys, each of which can derive a sequence of grandchild keys, and so on. This tree structure is illustrated in <<hd_wallets_figure>>.\n\n[[hd_wallets_figure]]\n.HD wallet: a tree of keys generated from a single seed\nimage::images/hd_wallet.png[\"HD wallet\"]\n\nHD wallets offer a few key advantages over simpler deterministic wallets. First, the tree structure can be used to express additional organizational meaning, such as when a specific branch of subkeys is used to receive incoming payments and a different branch is used to receive change from outgoing payments. Branches of keys can also be used in corporate settings, allocating different branches to departments, subsidiaries, specific functions, or accounting categories.\n\nThe second advantage of HD wallets is that users can create a sequence of public keys without having access to the corresponding private keys. This allows HD wallets to be used on an insecure server or in a watch-only or receive-only capacity, where the wallet doesn't have the private keys that can spend the funds.\n\n[[mnemonic_codes]]", "metadata": {"source": "ethereumbook", "chapter": "05wallets.asciidoc", "section": "Hierarchical Deterministic Wallets (BIP-32/BIP-44)"}}
{"input": "Explain the Ethereum concept: Seeds and Mnemonic Codes (BIP-39)", "output": "(((\"BIP-39 standard\")))(((\"Bitcoin improvement proposals (BIPs)\",\"Mnemonic Code Words (BIP-39)\")))(((\"mnemonic code words\",\"BIP-39\")))(((\"seeds\",\"mnemonic code words for\", seealso=\"mnemonic code words\")))(((\"wallets\",\"mnemonic codes (BIP-39)\")))There are many ways to encode a private key for secure backup and retrieval. The currently preferred method is using a sequence of words that, when taken together in the correct order, can uniquely recreate the private key. This is sometimes known as a _mnemonic_, and the approach has been standardized by http://bit.ly/2OEMjUz[BIP-39]. Today, many Ethereum wallets (as well as wallets for other cryptocurrencies) use this standard, and can import and export seeds for backup and recovery using interoperable mnemonics.\n\nTo see why this approach has become popular, let's have a look at an example:\n\n[[hex_seed_example]]\n.A seed for a deterministic wallet, in hex\n----\nFCCF1AB3329FD5DA3DA9577511F8F137\n----\n\n[[mnemonic_seed_example]]\n.A seed for a deterministic wallet, from a 12-word mnemonic\n----\nwolf juice proud gown wool unfair\nwall cliff insect more detail hub\n----\n\nIn practical terms, the chance of an error when writing down the hex sequence is unacceptably high. In contrast, the list of known words is quite easy to deal with, mainly because there is a high level of redundancy in the writing of words (especially English words). If \"inzect\" had been recorded by accident, it could quickly be determined, upon the need for wallet recovery, that \"inzect\" is not a valid English word and that \"insect\" should be used instead. We are talking about writing down a representation of the seed because that is good practice when managing HD wallets: the seed is needed to recover a wallet in the case of data loss (whether through accident or theft), so keeping a backup is very prudent. However, the seed must be kept extremely private, so digital backups should be carefully avoided; hence the earlier advice to back up with pen and paper.\n\nIn summary, the use of a recovery word list to encode the seed for an HD wallet makes for the easiest way to safely export, transcribe, record on paper, read without error, and import a private key set into another wallet.(((range=\"endofrange\", startref=\"ix_05wallets-asciidoc1\")))\n\n\n[[wallet_best_practices]]", "metadata": {"source": "ethereumbook", "chapter": "05wallets.asciidoc", "section": "Seeds and Mnemonic Codes (BIP-39)"}}
{"input": "Explain the Ethereum concept: Wallet Best Practices", "output": "(((\"wallets\",\"best practices for\", id=\"ix_05wallets-asciidoc5\", range=\"startofrange\")))As cryptocurrency wallet technology has matured, certain common industry standards have emerged that make wallets broadly interoperable, easy to use, secure, and flexible. These standards also allow wallets to derive keys for multiple different cryptocurrencies, all from a single mnemonic. These common standards are:\n\n* Mnemonic code words, based on BIP-39\n* HD wallets, based on BIP-32\n* Multipurpose HD wallet structure, based on BIP-43\n* Multicurrency and multiaccount wallets, based on BIP-44\n\nThese standards may change or be obsoleted by future developments, but for now they form a set of interlocking technologies that have become the _de facto_ wallet standard for most blockchain platforms and their cryptocurrencies.\n\nThe standards have been adopted by a broad range of software and hardware wallets, making all these wallets interoperable. A user can export a mnemonic generated in one of these wallets and import it to another wallet, recovering all keys and addresses.\n\nSome examples of software wallets supporting these standards include (listed alphabetically) Jaxx, MetaMask, MyCrypto, and MyEtherWallet (MEW). (((\"hardware wallets\")))Examples of hardware wallets supporting these standards include Keepkey, Ledger, and Trezor.\n\nThe following sections examine each of these technologies in detail.\n\n[TIP]", "metadata": {"source": "ethereumbook", "chapter": "05wallets.asciidoc", "section": "Wallet Best Practices"}}
{"input": "Explain the Ethereum concept: Mnemonic Code Words (BIP-39)", "output": "(((\"BIP-39 standard\", id=\"ix_05wallets-asciidoc6\", range=\"startofrange\")))(((\"Bitcoin improvement proposals (BIPs)\",\"Mnemonic Code Words (BIP-39)\", id=\"ix_05wallets-asciidoc7\", range=\"startofrange\")))(((\"mnemonic code words\",\"BIP-39\", id=\"ix_05wallets-asciidoc8\", range=\"startofrange\")))(((\"wallets\",\"mnemonic codes (BIP-39)\", id=\"ix_05wallets-asciidoc9\", range=\"startofrange\")))Mnemonic code words are word sequences that encode a random number used as a seed to derive a deterministic wallet. The sequence of words is sufficient to recreate the seed, and from there recreate the wallet and all the derived keys. A wallet application that implements deterministic wallets with mnemonic words will show the user a sequence of 12 to 24 words when first creating a wallet. That sequence of words is the wallet backup, and can be used to recover and recreate all the keys in the same or any compatible wallet application. As we explained earlier, mnemonic word lists make it easier for users to back up wallets, because they are easy to read and correctly pass:[<span class=\"keep-together\">transcribe</span>].\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "05wallets.asciidoc", "section": "Mnemonic Code Words (BIP-39)"}}
{"input": "Explain the Ethereum concept: Generating mnemonic words", "output": "(((\"BIP-39 standard\",\"generating code words with\")))(((\"checksum\",\"in mnemonic code word generation\")))(((\"mnemonic code words\",\"generating\")))Mnemonic words are generated automatically by the wallet using the standardized process defined in BIP-39. The wallet starts from a source of entropy, adds a checksum, and then maps the entropy to a word list:\n\n1. Create a cryptographically random sequence +S+ of 128 to 256 bits.\n2. Create a checksum of +S+ by taking the first length-of-++S++ \u00f7 32 bits of the SHA-256 hash of +S+.\n3. Add the checksum to the end of the random sequence +S+.\n4. Divide the sequence-and-checksum concatenation into sections of 11 bits.\n5. Map each 11-bit value to a word from the predefined dictionary of 2,048 words.\n6. Create the mnemonic code from the sequence of words, maintaining the order.\n\n<<generating_entropy_and_encoding>> shows how entropy is used to generate mnemonic words.\n\n<<table_bip39_entropy>> shows the relationship between the size of the entropy data and the length of mnemonic codes in words.\n\n[[table_bip39_entropy]]\n.Mnemonic codes: entropy and word length\n[options=\"header\"]\n|=======\n|Entropy (bits) | Checksum (bits) | Entropy *+* checksum (bits) | Mnemonic length (words)\n| 128 | 4 | 132 | 12\n| 160 | 5 | 165 | 15\n| 192 | 6 | 198 | 18\n| 224 | 7 | 231 | 21\n| 256 | 8 | 264 | 24\n|=======\n\n[[generating_entropy_and_encoding]]\n[role=\"smallerseventy\"]\n.Generating entropy and encoding as mnemonic words\nimage::images/bip39-part1.png[\"Generating entropy and encoding as mnemonic words\"]\n\n[[mnemonic_to_seed]]", "metadata": {"source": "ethereumbook", "chapter": "05wallets.asciidoc", "section": "Generating mnemonic words"}}
{"input": "Explain the Ethereum concept: From mnemonic to seed", "output": "(((\"BIP-39 standard\",\"deriving seed from mnemonic words\")))(((\"seeds\",\"deriving from mnemonic code words\")))The mnemonic words represent entropy with a length of 128 to 256 bits. The entropy is then used to derive a longer (512-bit) seed through the use of the key-stretching function (((\"PBKDF2 function\")))PBKDF2. The seed produced is used to build a deterministic wallet and derive its keys.\n\n(((\"key-stretching function\")))(((\"salts\")))The key-stretching function takes two parameters: the mnemonic and a _salt_. The purpose of a salt in a key-stretching function is to make it difficult to build a lookup table enabling a brute-force attack. In the BIP-39 standard, the salt has another purpose: it allows the introduction of a passphrase that serves as an additional security factor protecting the seed, as we will describe in more detail in <<mnemonic_passphrase>>.\n\nThe process described in steps 7 through 9 continues from the process described in the previous section:\n\n[start=7]\n7. The first parameter to the PBKDF2 key-stretching function is the _mnemonic_ produced in step 6.\n8. The second parameter to the PBKDF2 key-stretching function is a _salt_. The salt is composed of the string constant +\"mnemonic\"+ concatenated with an optional user-supplied passphrase.\n9. PBKDF2 stretches the mnemonic and salt parameters using 2,048 rounds of hashing with the HMAC-SHA512 algorithm, producing a 512-bit value as its final output. That 512-bit value is the seed.\n\n<<mnemonic_to_seed_figure>> shows how a mnemonic is used to generate a seed.\n\n[[mnemonic_to_seed_figure]]\n.From mnemonic to seed\nimage::images/bip39-part2.png[\"From mnemonic to seed\"]\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "05wallets.asciidoc", "section": "From mnemonic to seed"}}
{"input": "Explain the Ethereum concept: Optional passphrase in BIP-39", "output": "(((\"BIP-39 standard\",\"optional passphrase with\")))(((\"mnemonic code words\",\"optional passphrase in BIP-39\")))(((\"passphrases\")))(((\"seeds\",\"optional passphrase with\")))The BIP-39 standard allows the use of an optional passphrase in the derivation of the seed. If no passphrase is used, the mnemonic is stretched with a salt consisting of the constant string +\"mnemonic\"+, producing a specific 512-bit seed from any given mnemonic. If a passphrase is used, the stretching function produces a _different_ seed from that same mnemonic. In fact, given a single mnemonic, every possible passphrase leads to a different seed. Essentially, there is no \"wrong\" passphrase. All passphrases are valid and they all lead to different seeds, forming a vast set of possible uninitialized wallets. The set of possible wallets is so large (2^512^) that there is no practical possibility of brute-forcing or accidentally guessing one that is in use, as long as the passphrase has sufficient complexity and length.\n\n[TIP]", "metadata": {"source": "ethereumbook", "chapter": "05wallets.asciidoc", "section": "Optional passphrase in BIP-39"}}
{"input": "Explain the Ethereum concept: Working with mnemonic codes", "output": "(((\"BIP-39 standard\",\"libraries\")))(((\"BIP-39 standard\",\"working with mnemonic codes\")))BIP-39 is implemented as a library in many different programming languages. For example:\n\nhttps://github.com/trezor/python-mnemonic[python-mnemonic]:: The reference implementation of the standard by the SatoshiLabs team that proposed BIP-39, in Python\n\nhttps://github.com/ConsenSys/eth-lightwallet[ConsenSys/eth-lightwallet]:: Lightweight JS Ethereum wallet for nodes and browser (with BIP-39)\n\nhttps://www.npmjs.com/package/bip39[npm/bip39]:: JavaScript implementation of Bitcoin BIP-39: Mnemonic code for generating deterministic keys\n\nThere is also a BIP-39 generator implemented in a standalone web page (<<a_bip39_generator_as_a_standalone_web_page>>), which is extremely useful for testing and experimentation. The https://iancoleman.io/bip39/[Mnemonic Code Converter] generates mnemonics, seeds, and extended private keys. It can be used offline in a browser, or accessed online.(((range=\"endofrange\", startref=\"ix_05wallets-asciidoc9\")))(((range=\"endofrange\", startref=\"ix_05wallets-asciidoc8\")))(((range=\"endofrange\", startref=\"ix_05wallets-asciidoc7\")))(((range=\"endofrange\", startref=\"ix_05wallets-asciidoc6\")))\n\n[[a_bip39_generator_as_a_standalone_web_page]]\n.A BIP-39 generator as a standalone web page\nimage::images/bip39_web.png[\"BIP-39 generator web-page\"]\n\n[[create_hd_wallet]]", "metadata": {"source": "ethereumbook", "chapter": "05wallets.asciidoc", "section": "Working with mnemonic codes"}}
{"input": "Explain the Ethereum concept: Creating an HD Wallet from the Seed", "output": "(((\"hierarchical deterministic wallets (BIP-32/BIP-44)\",\"creating from root seed\")))(((\"root seeds, creating HD wallets from\")))(((\"wallets\",\"creating HD wallets from root seed\")))HD wallets are created from a single _root seed_, which is a 128-, 256-, or 512-bit random number. Most commonly, this seed is generated from a mnemonic as detailed in the previous section.\n\nEvery key in the HD wallet is deterministically derived from this root seed, which makes it possible to recreate the entire HD wallet from that seed in any compatible HD wallet. This makes it easy to export, back up, restore, and import HD wallets containing thousands or even millions of keys by transferring just the mnemonic from which the root seed is derived.\n\n[[bip32_bip43_44]]", "metadata": {"source": "ethereumbook", "chapter": "05wallets.asciidoc", "section": "Creating an HD Wallet from the Seed"}}
{"input": "Explain the Ethereum concept: HD Wallets (BIP-32) and Paths (BIP-43/44)", "output": "(((\"Bitcoin improvement proposals (BIPs)\",\"Multipurpose HD Wallet Structure (BIP-43)\", id=\"ix_05wallets-asciidoc10\", range=\"startofrange\")))(((\"hierarchical deterministic wallets (BIP-32/BIP-44)\",\"HD wallets (BIP-32) and paths (BIP-43/44)\", id=\"ix_05wallets-asciidoc11\", range=\"startofrange\")))Most HD wallets follow the (((\"BIP-32 standard\",\"HD wallets and\", id=\"ix_05wallets-asciidoc12\", range=\"startofrange\")))BIP-32 standard, which has become a _de facto_ industry standard for deterministic key generation.\n\nWe won't be discussing all the details of BIP-32 here, only the components necessary to understand how it is used in wallets. The main important aspect is the tree-like hierarchical relationships that it is possible for the derived keys to have, as you can see in <<hd_wallets_figure>>. It's also important to understand the ideas of _extended keys_ and _hardened keys_, which are explained in the following sections.\n\nThere are dozens of interoperable implementations of BIP-32 offered in many software libraries. These are mostly designed for Bitcoin wallets, which implement addresses in a different way, but share the same key-derivation implementation as Ethereum's BIP-32-compatible wallets. Use one https://github.com/ConsenSys/eth-lightwallet[designed for Ethereum], or adapt one from Bitcoin by adding an Ethereum address encoding library.\n\nThere is also a BIP-32 generator implemented as a http://bip32.org/[standalone web page] that is very useful for testing and experimentation with BIP-32.\n\n[WARNING]", "metadata": {"source": "ethereumbook", "chapter": "05wallets.asciidoc", "section": "HD Wallets (BIP-32) and Paths (BIP-43/44)"}}
{"input": "Explain the Ethereum concept: Extended public and private keys", "output": "(((\"BIP-32 standard\",\"extended public and private keys\")))(((\"extended keys\")))(((\"hierarchical deterministic wallets (BIP-32/BIP-44)\",\"extended public and private keys\")))(((\"keys\",\"extended\")))In BIP-32 terminology, keys can be \"extended.&#x201d; With the right mathematical operations, these extended \"parent\" keys can be used to derive \"child\" keys, thus producing the hierarchy of keys and addresses described earlier. A parent key doesn't have to be at the top of the tree. It can be picked out from anywhere in the tree hierarchy. (((\"chain code\")))Extending a key involves taking the key itself and appending a special _chain code_ to it. A chain code is a 256-bit binary string that is mixed with each key to produce child keys.\n\n(((\"private keys\",\"extended\")))If the key is a private key, it becomes an _extended private key_ distinguished by the pass:[<span class=\"keep-together\">prefix</span>] +xprv+:\n\n[[xprv_example]]\n----\nxprv9s21ZrQH143K2JF8RafpqtKiTbsbaxEeUaMnNHsm5o6wCW3z8ySyH4UxFVSfZ8n7ESu7fgir8i...\n----\n\n(((\"public keys\",\"extended\")))An _extended public key_ is distinguished by the prefix +xpub+:\n\n[[xpub_example]]\n----\nxpub661MyMwAqRbcEnKbXcCqD2GT1di5zQxVqoHPAgHNe8dv5JP8gWmDproS6kFHJnLZd23tWevhdn...\n----\n\nA very useful characteristic of HD wallets is the ability to derive child public keys from parent public keys, _without_ having the private keys. This gives us two ways to derive a child public key: either directly from the child private key, or from the parent public key.\n\nAn extended public key can be used, therefore, to derive all of the public keys (and only the public keys) in that branch of the HD wallet structure.\n\nThis shortcut can be used to create very secure public key&#x2013;only deployments, where a server or application has a copy of an extended public key, but no private keys whatsoever. That kind of deployment can produce an infinite number of public keys and Ethereum addresses, but cannot spend any of the money sent to those addresses. Meanwhile, on another, more secure server, the extended private key can derive all the corresponding private keys to sign transactions and spend the money.\n\nOne common application of this method is to install an extended public key on a web server that serves an ecommerce application. The web server can use the public key derivation function to create a new Ethereum address for every transaction (e.g., for a customer shopping cart), and will not have any private keys that would be vulnerable to theft. Without HD wallets, the only way to do this is to generate thousands of Ethereum addresses on a separate secure server and then preload them on the ecommerce server. That approach is cumbersome and requires constant maintenance to ensure that the server doesn't run out of keys, hence the preference to use extended public keys from HD wallets.\n\n(((\"hardware wallets\")))Another common application of this solution is for (((\"cold-storage wallets\")))(((\"wallets\",\"cold-storage wallets\")))cold-storage or hardware wallets. In that scenario, the extended private key can be stored in a hardware wallet, while the extended public key can be kept online. The user can create \"receive\" addresses at will, while the private keys are safely stored offline. To spend the funds, the user can use the extended private key in an offline signing Ethereum client, or sign transactions on the hardware wallet device.\n\n[[hardened_child_key]]", "metadata": {"source": "ethereumbook", "chapter": "05wallets.asciidoc", "section": "Extended public and private keys"}}
{"input": "Explain the Ethereum concept: Hardened child key derivation", "output": "(((\"child private keys\")))(((\"hardened derivation\",\"for child private keys\")))(((\"hierarchical deterministic wallets (BIP-32/BIP-44)\",\"hardened child key derivation\")))(((\"hierarchical deterministic wallets (BIP-32/BIP-44)\",\"index numbers for normal/hardened derivation\")))(((\"index numbers, for normal/hardened derivation\")))(((\"private keys\",\"hardened child key derivation\")))The ability to derive a branch of public keys from an extended public key, or _xpub_, is very useful, but it comes with a potential risk. Access to an xpub does not give access to child private keys. However, because the xpub contains the chain code (used to derive child public keys from the parent public key), if a child private key is known, or somehow leaked, it can be used with the chain code to derive all the other child private keys. A single leaked child private key, together with a parent chain code, reveals all the private keys of all the children. Worse, the child private key together with a parent chain code can be used to deduce the parent private key.\n\nTo counter this risk, HD wallets use an alternative derivation function called _hardened derivation_, which \"breaks\" the relationship between parent public key and child chain code. The hardened derivation function uses the parent private key to derive the child chain code, instead of the parent public key. This creates a \"firewall\" in the parent/child sequence, with a chain code that cannot be used to compromise a parent or sibling private key.\n\nIn simple terms, if you want to use the convenience of an xpub to derive branches of public keys without exposing yourself to the risk of a leaked chain code, you should derive it from a hardened parent, rather than a normal parent. Best practice is to have the level-1 children of the master keys always derived by hardened derivation, to prevent compromise of the master keys.\n\n[[index_number]]", "metadata": {"source": "ethereumbook", "chapter": "05wallets.asciidoc", "section": "Hardened child key derivation"}}
{"input": "Explain the Ethereum concept: Index numbers for normal and hardened derivation", "output": "(((\"hardened derivation\",\"index numbers for\")))It is clearly desirable to be able to derive more than one child key from a given parent key. To manage this, an index number is used. Each index number, when combined with a parent key using the special child derivation function, gives a different child key. The index number used in the BIP-32 parent-to-child derivation function is a 32-bit integer. To easily distinguish between keys derived through the normal (unhardened) derivation function versus keys derived through hardened derivation, this index number is split into two ranges. Index numbers between 0 and 2^31^&#x2013;1 (+0x0+ to +0x7FFFFFFF+) are used _only_ for normal derivation. Index numbers between 2^31^ and 2^32^&#x2013;1 (+0x80000000+ to +0xFFFFFFFF+) are used _only_ for hardened derivation. Therefore, if the index number is less than 2^31^, the child is normal, whereas if the index number is equal to or above 2^31^, the child is hardened.\n\nTo make the index numbers easier to read and display, the index numbers for hardened children are displayed starting from zero, but with a prime symbol. The first normal child key is therefore displayed as +0+, whereas the first hardened child (index +0x80000000+) is displayed as ++0&#x27;++. In sequence, then, the second hardened key would have index of +0x80000001+ and would be displayed as ++1&#x27;++, and so on. When you see an HD wallet index ++i&#x27;++, that means 2^31^ pass:[+] ++i++.(((range=\"endofrange\", startref=\"ix_05wallets-asciidoc12\")))\n\n[[hd_wallet_path]]", "metadata": {"source": "ethereumbook", "chapter": "05wallets.asciidoc", "section": "Index numbers for normal and hardened derivation"}}
{"input": "Explain the Ethereum concept: HD wallet key identifier (path)", "output": "(((\"hierarchical deterministic wallets (BIP-32/BIP-44)\",\"key identifier\")))(((\"keys\",\"path naming convention\")))Keys in an HD wallet are identified using a \"path\" naming convention, with each level of the tree separated by a slash (/) character (see <<hd_path_table>>). Private keys derived from the master private key start with +m+. Public keys derived from the master public key start with +M+. Therefore, the first child private key of the master private key is +m/0+. The first child public key is +M/0+. The second grandchild of the first child is +m/0/1+, and so on.\n\nThe \"ancestry\" of a key is read from right to left, until you reach the master key from which it was derived. For example, identifier +m/x/y/z+ describes the key that is the ++z++-th child of key +m/x/y+, which is the ++y++-th child of key +m/x+, which is the ++x++-th child of +m+.\n\n[[hd_path_table]]\n.HD wallet path examples\n[options=\"header\"]\n|=======\n|HD path | Key described\n| +m/0+ | The first (+0+) child private key of the master private key (+m+)\n| +m/0/0+ | The first grandchild private key of the first child (+m/0+)\n| +m/0'/0+ | The first normal grandchild of the first _hardened_ child (+m/0'+)\n| +m/1/0+ | The first grandchild private key of the second child (+m/1+)\n| +M/23/17/0/0+ | The first great-great-grandchild public key of the first great-grandchild of the 18th grandchild of the pass:[<span class=\"keep-together\">24th child</span>]\n|=======\n\n[[navigating_hd_wallet_tree]]", "metadata": {"source": "ethereumbook", "chapter": "05wallets.asciidoc", "section": "HD wallet key identifier (path)"}}
{"input": "Explain the Ethereum concept: Navigating the HD wallet tree structure", "output": "(((\"hierarchical deterministic wallets (BIP-32/BIP-44)\",\"tree structure\")))(((\"tree structure, navigating\")))The HD wallet tree structure is tremendously flexible. The flip side of this is that it also allows for unbounded complexity: each parent extended key can have 4 billion children: 2 billion normal children and 2 billion hardened children. Each of those children can have another 4 billion children, and so on. The tree can be as deep as you want, with a potentially infinite number of generations. With all that potential, it can become quite difficult to navigate these very large trees.\n\nTwo BIPs offer a way to manage this potential complexity by creating standards for the structure of HD wallet trees. (((\"BIP-43 standard\")))BIP-43 proposes the use of the first hardened child index as a special identifier that signifies the \"purpose\" of the tree structure. Based on BIP-43, an HD wallet should use only one level-1 branch of the tree, with the index number defining the purpose of the wallet by identifying the structure and namespace of the rest of the tree. More specifically, an HD wallet using only branch ++m/i&#x27;/...++ is intended to signify a specific purpose and that purpose is identified by index number +i+.\n\n(((\"BIP-44 standard\")))Extending that specification, BIP-44 proposes a multicurrency multiaccount structure signified by setting the \"purpose\" number to +44'+. All HD wallets following the BIP-44 structure are identified by the fact that they only use one branch of the tree: +m/44'/*+.\n\nBIP-44 specifies the structure as consisting of five predefined tree levels:\n\n[[bip44_tree]]\n-----\nm / purpose' / coin_type' / account' / change / address_index\n-----\n\nThe first level, +purpose&#x27;+, is always set to +44&#x27;+. The second level, +coin_type&#x27;+, specifies the type of cryptocurrency coin, allowing for multicurrency HD wallets where each currency has its own subtree under the second level. There are several currencies defined in a standards document called https://github.com/satoshilabs/slips/blob/master/slip-0044.md[SLIP0044]; for example, Ethereum is ++m/44&#x27;/60&#x27;++, Ethereum Classic is ++m/44&#x27;/61&#x27;++, Bitcoin is ++m/44&#x27;/0&#x27;++, and Testnet for all currencies is ++m/44&#x27;/1&#x27;++.\n\nThe third level of the tree is +account&#x27;+, which allows users to subdivide their wallets into separate logical subaccounts for accounting or organizational purposes. For example, an HD wallet might contain two Ethereum \"accounts\": ++m/44&#x27;/60&#x27;/0&#x27;++ and ++m/44&#x27;/60&#x27;/1&#x27;++. Each account is the root of its own subtree.\n\nBecause BIP-44 was created originally for Bitcoin, it contains a \"quirk\" that isn't relevant in the Ethereum world. On the fourth level of the path, +change+, an HD wallet has two subtrees: one for creating receiving addresses and one for creating change addresses. Only the \"receive\" path is used in Ethereum, as there is no necessity for a change address like there is in Bitcoin. Note that whereas the previous levels used hardened derivation, this level uses normal derivation. This is to allow the account level of the tree to export extended public keys for use in a nonsecured environment. Usable addresses are derived by the HD wallet as children of the fourth level, making the fifth level of the tree the +address_index+. For example, the third receiving address for Ethereum payments in the primary account would be ++M/44&#x27;/60&#x27;/0&#x27;/0/2++. <<bip44_path_examples>> shows a few more examples(((range=\"endofrange\", startref=\"ix_05wallets-asciidoc11\")))(((range=\"endofrange\", startref=\"ix_05wallets-asciidoc10\"))).(((range=\"endofrange\", startref=\"ix_05wallets-asciidoc5\")))\n\n[[bip44_path_examples]]\n.BIP-44 HD wallet structure examples\n[options=\"header\"]\n|=======\n|HD path | Key described\n| ++M/44&#x27;/60&#x27;/0&#x27;/0/2++ | The third receiving public key for the primary Ethereum account\n| ++M/44&#x27;/0&#x27;/3&#x27;/1/14++ | The 15^th^ change-address public key for the 4^th^ Bitcoin account\n| ++m/44&#x27;/2&#x27;/0&#x27;/0/1++ | The second private key in the Litecoin main account, for signing transactions\n|=======", "metadata": {"source": "ethereumbook", "chapter": "05wallets.asciidoc", "section": "Navigating the HD wallet tree structure"}}
{"input": "Explain the Ethereum concept: Conclusions", "output": "Wallets are the foundation of any user-facing blockchain application. They allow users to manage collections of keys and addresses. Wallets also allow users to demonstrate their ownership of ether, and authorize transactions, by applying digital signatures, as we will see in <<tx_chapter>>.(((range=\"endofrange\", startref=\"ix_05wallets-asciidoc0\")))", "metadata": {"source": "ethereumbook", "chapter": "05wallets.asciidoc", "section": "Conclusions"}}
{"input": "Explain the Ethereum concept: Transactions", "output": "(((\"transactions\", id=\"ix_06transactions-asciidoc0\", range=\"startofrange\")))Transactions are signed messages originated by an externally owned account (EOA), transmitted by the Ethereum network, and recorded on the Ethereum blockchain. This basic definition conceals a lot of surprising and fascinating details. Another way to look at transactions is that they are the only things that can trigger a change of state, or cause a contract to execute in the EVM. Ethereum is a global singleton state machine, and transactions are what make that state machine \"tick,\" changing its state. Contracts don't run on their own. Ethereum doesn't run  autonomously. Everything starts with a transaction.\n\nIn this chapter, we will dissect transactions, show how they work, and examine the details. Note that much of this chapter is addressed to those who are interested in managing their own transactions at a low level, perhaps because they are writing a wallet app; you don't have to worry about this if you are happy using existing wallet applications, although you may find the details interesting!\n\n[[tx_struct]]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Transactions"}}
{"input": "Explain the Ethereum concept: The Structure of a Transaction", "output": "(((\"transactions\",\"basic structure\")))First let's take a look at the basic structure of a transaction, as it is serialized and transmitted on the Ethereum network. Each client and application that receives a serialized transaction will store it in-memory using its own internal data structure, perhaps embellished with metadata that doesn't exist in the network serialized transaction itself. The network-serialization is the only standard form of a transaction.\n\nA transaction is a serialized binary message that contains the following data:\n\nNonce:: A sequence number, issued by the originating EOA, used to prevent message replay\n\nGas price:: The amount of ether (in wei) that the originator is willing to pay for each unit of gas\n\nGas limit:: The maximum amount of gas the originator is willing to buy for this transaction\n\nRecipient:: The destination Ethereum address\n\nValue:: The amount of ether (in wei) to send to the destination\n\nData:: The variable-length binary data payload\n\nv,r,s:: The three components of an ECDSA digital signature of the originating EOA\n\n(((\"Recursive Length Prefix (RLP)\")))(((\"RLP (Recursive Length Prefix)\")))The transaction message's structure is serialized using the Recursive Length Prefix (RLP) encoding scheme, which was created specifically for simple, byte-perfect data serialization in Ethereum. All numbers in Ethereum are encoded as big-endian integers, of lengths that are multiples of 8 bits.\n\nNote that the field labels (+to+, +gas limit+, etc.) are shown here for clarity, but are not part of the transaction serialized data, which contains the field values RLP-encoded. In general, RLP does not contain any field delimiters or labels. RLP's length prefix is used to identify the length of each field. Anything beyond the defined length belongs to the next field in the structure.\n\nWhile this is the actual transaction structure transmitted, most internal representations and user interface visualizations embellish this with additional information, derived from the transaction or from the blockchain.\n\nFor example, you may notice there is no &#x201c;from&#x201d; data in the address identifying the originator EOA. That is because the EOA's public key can be derived from the +v,r,s+ components of the ECDSA signature. The address can, in turn, be derived from the public key. When you see a transaction showing a \"from\" field, that was added by the software used to visualize the transaction. Other metadata frequently added to the transaction by client software includes the block number (once it is mined and included in the blockchain) and a transaction ID (calculated hash). Again, this data is derived from the transaction, and does not form part of the transaction message itself.\n\n[[tx_nonce]]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "The Structure of a Transaction"}}
{"input": "Explain the Ethereum concept: The Transaction Nonce", "output": "(((\"nonces\", id=\"ix_06transactions-asciidoc1\", range=\"startofrange\")))(((\"transactions\",\"nonces\", id=\"ix_06transactions-asciidoc2\", range=\"startofrange\")))The nonce is one of the most important and least understood components of a transaction. The definition in the Yellow Paper (see <<references>>) reads:\n\n____\n+nonce+: A scalar value equal to the number of transactions sent from this address or, in the case of accounts with associated code, the number of contract-creations made by this account.\n____\n\nStrictly speaking, the nonce is an attribute of the originating address; that is, it only has meaning in the context of the sending address. However, the nonce is not stored explicitly as part of an account's state on the blockchain. Instead, it is calculated dynamically, by counting the number of confirmed transactions that have originated from an address.\n\nThere are two scenarios where the existence of a transaction-counting nonce is important: the usability feature of transactions being included in the order of creation, and the vital feature of transaction duplication protection. Let's look at an example scenario for each of these:\n\n1. Imagine you wish to make two transactions. You have an important payment to make of 6 ether, and also another payment of 8 ether. You sign and broadcast the 6-ether transaction first, because it is the more important one, and then you sign and broadcast the second, 8-ether transaction. Sadly, you have overlooked the fact that your account contains only 10 ether, so the network can't accept both transactions: one of them will fail. Because you sent the more important 6-ether one first, you understandably expect that one to go through and the 8-ether one to be rejected. However, in a decentralized system like Ethereum, nodes may receive the transactions in either order; there is no guarantee that a particular node will have one transaction propagated to it before the other. As such, it will almost certainly be the case that some nodes receive the 6-ether transaction first and others receive the 8-ether transaction first. Without the nonce, it would be random as to which one gets accepted and which rejected. However, with the nonce included, the first transaction you sent will have a nonce of, let's say, 3, while the 8-ether transaction has the next nonce value (i.e., 4). So, that transaction will be ignored until the transactions with nonces from 0 to 3 have been processed, even if it is received first. Phew!\n\n\n2. Now imagine you have an account with 100 ether. Fantastic! You find someone online who will accept payment in ether for a mcguffin-widget that you really want to buy. You send them 2 ether and they send you the mcguffin-widget. Lovely. To make that 2-ether payment, you signed a transaction sending 2 ether from your account to their account, and then broadcast it to the Ethereum network to be verified and included on the blockchain. Now, without a nonce value in the transaction, a second transaction sending 2 ether to the same address a second time will look exactly the same as the first transaction. This means that anyone who sees your transaction on the Ethereum network (which means everyone, including the recipient or your enemies) can \"replay\" the transaction again and again and again until all your ether is gone simply by copying and pasting your original transaction and resending it to the network. However, with the nonce value included in the transaction data, _every single transaction is unique_, even when sending the same amount of ether to the same recipient address multiple times. Thus, by having the incrementing nonce as part of the transaction, it is simply not possible for anyone to \"duplicate\" a payment you have made.\n\nIn summary, it is important to note that the use of the nonce is actually vital for an _account-based_ protocol, in contrast to the &#x201c;Unspent Transaction Output&#x201d; (UTXO) mechanism of the Bitcoin protocol.\n\n[[tracking_nonce]]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "The Transaction Nonce"}}
{"input": "Explain the Ethereum concept: Keeping Track of Nonces", "output": "(((\"nonces\",\"keeping track of\")))In practical terms, the nonce is an up-to-date count of the number of _confirmed_ (i.e., on-chain) transactions that have originated from an account. To find out what the nonce is, you can interrogate the blockchain, for example via the web3 interface. Open a JavaScript console in Geth (or your preferred web3 interface) on Ropsten testnet, then type:\n\n++++\n<pre data-type=\"programlisting\">\n&gt; <strong>web3.eth.getTransactionCount(\"0x9e713963a92c02317a681b9bb3065a8249de124f\")</strong>\n40\n</pre>\n++++\n\n[TIP]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Keeping Track of Nonces"}}
{"input": "Explain the Ethereum concept: Gaps in Nonces, Duplicate Nonces, and Confirmation", "output": "(((\"nonces\",\"gaps in sequence of\")))It is important to keep track of nonces if you are creating transactions programmatically, especially if you are doing so from multiple independent processes pass:[<span class=\"keep-together\">simultaneously</span>].\n\nThe Ethereum network processes transactions sequentially, based on the nonce. That means that if you transmit a transaction with nonce 0 and then transmit a transaction with nonce 2, the second transaction will not be included in any blocks. It will be stored in the mempool, while the Ethereum network waits for the missing nonce to appear. All nodes will assume that the missing nonce has simply been delayed and that the transaction with nonce 2 was received out of sequence.\n\nIf you then transmit a transaction with the missing nonce 1, both transactions (nonces 1 and 2) will be processed and included (if valid, of course). Once you fill the gap, the network can mine the out-of-sequence transaction that it held in the mempool.\n\nWhat this means is that if you create several transactions in sequence and one of them does not get officially included in any blocks, all the subsequent transactions will be \"stuck,\" waiting for the missing nonce. A transaction can create an inadvertent \"gap\" in the nonce sequence because it is invalid or has insufficient gas. To get things moving again, you have to transmit a valid transaction with the missing nonce. You should be equally mindful that once a transaction with the \"missing\" nonce is validated by the network, all the broadcast transactions with subsequent nonces will incrementally become valid; it is not possible to \"recall\" a transaction!\n\n(((\"nonces\",\"confirmation\")))(((\"nonces\",\"duplicated\")))If, on the other hand, you accidentally duplicate a nonce, for example by transmitting two transactions with the same nonce but different recipients or values, then one of them will be confirmed and one will be rejected. Which one is confirmed will be determined by the sequence in which they arrive at the first validating node that receives them&#x2014;i.e., it will be fairly random.\n\nAs you can see, keeping track of nonces is necessary, and if your application doesn't manage that process correctly you will run into problems. Unfortunately, things get even more difficult if you are trying to do this concurrently, as we will see in the next section.\n\n[[concurrency]]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Gaps in Nonces, Duplicate Nonces, and Confirmation"}}
{"input": "Explain the Ethereum concept: Concurrency, Transaction Origination, and Nonces", "output": "(((\"concurrency, nonces and\")))(((\"nonces\",\"concurrency\")))(((\"nonces\",\"transaction origination\")))Concurrency is a complex aspect of computer science, and it crops up unexpectedly sometimes, especially in decentralized and distributed real-time systems like pass:[<span class=\"keep-together\">Ethereum</span>].\n\nIn simple terms, concurrency is when you have simultaneous computation by multiple independent systems. These can be in the same program (e.g., multithreading), on the same CPU (e.g., multiprocessing), or on different computers (i.e., distributed pass:[<span class=\"keep-together\">systems</span>]). Ethereum, by definition, is a system that allows concurrency of operations (nodes, clients, DApps) but enforces a singleton state through consensus.\n\nNow, imagine that you have multiple independent wallet applications that are generating transactions from the same address or addresses. One example of such a situation would be an exchange processing withdrawals from the exchange's hot wallet (a wallet whose keys are stored online, in contrast to a cold wallet where the keys are never online). Ideally, you'd want to have more than one computer processing withdrawals, so that it doesn't become a bottleneck or single point of failure. However, this quickly becomes problematic, as having more than one computer producing withdrawals will result in some thorny concurrency problems, not least of which is the selection of nonces. How do multiple computers generating, signing, and broadcasting transactions from the same hot wallet account coordinate?\n\nYou could use a single computer to assign nonces, on a first-come first-served basis, to computers signing transactions. However, this computer is now a single point of failure. Worse, if several nonces are assigned and one of them never gets used (because of a failure in the computer processing the transaction with that nonce), all subsequent transactions get stuck.\n\nAnother approach would be to generate the transactions, but not assign a nonce to them (and therefore leave them unsigned&#x2014;remember that the nonce is an integral part of the transaction data and therefore needs to be included in the digital signature that authenticates the transaction). You could then queue them to a single node that signs them and also keeps track of nonces. Again, though, this would be a choke point in the process: the signing and tracking of nonces is the part of your operation that is likely to become congested under load, whereas the generation of the unsigned transaction is the part you don't really need to parallelize. You would have some concurrency, but it would be lacking in a critical part of the process.\n\nIn the end, these concurrency problems, on top of the difficulty of tracking account balances and transaction confirmations in independent processes, force most implementations toward avoiding concurrency and creating bottlenecks such as a single process handling all withdrawal transactions in an exchange, or setting up multiple hot wallets that can work completely independently for withdrawals and only need to be intermittently rebalanced.(((range=\"endofrange\", startref=\"ix_06transactions-asciidoc2\")))(((range=\"endofrange\", startref=\"ix_06transactions-asciidoc1\")))\n\n[[tx_gas]]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Concurrency, Transaction Origination, and Nonces"}}
{"input": "Explain the Ethereum concept: Transaction Gas", "output": "(((\"gas\",\"transactions and\", id=\"ix_06transactions-asciidoc3\", range=\"startofrange\")))(((\"transactions\",\"gas\", id=\"ix_06transactions-asciidoc4\", range=\"startofrange\")))We talked about gas a little in earlier chapters, and we discuss it in more detail in <<gas>>. However, let's cover some basics about the role of the +gasPrice+ and +gasLimit+ components of a transaction.\n\nGas is the fuel of Ethereum. Gas is not ether&#x2014;it's a separate virtual currency with its own exchange rate against ether. Ethereum uses gas to control the amount of resources that a transaction can use, since it will be processed on thousands of computers around the world. The open-ended (Turing-complete) computation model requires some form of metering in order to avoid denial-of-service attacks or inadvertently resource-devouring transactions.\n\nGas is separate from ether in order to protect the system from the volatility that might arise along with rapid changes in the value of ether, and also as a way to manage the important and sensitive ratios between the costs of the various resources that gas pays for (namely, computation, memory, and storage).\n\n(((\"gasPrice field\")))The +gasPrice+ field in a transaction allows the transaction originator to set the price they are willing to pay in exchange for gas. The price is measured in wei per gas unit. For example, in the sample transaction in <<intro_chapter>> your wallet set the +gasPrice+ to 3 gwei (3 gigawei or 3 billion wei).\n\n[TIP]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Transaction Gas"}}
{"input": "Explain the Ethereum concept: Transaction Recipient", "output": "(((\"transactions\",\"recipient of\")))The recipient of a transaction is specified in the +to+ field. This contains a 20-byte Ethereum address. The address can be an EOA or a contract address.\n\nEthereum does no further validation of this field. Any 20-byte value is considered valid. If the 20-byte value corresponds to an address without a corresponding private key, or without a corresponding contract, the transaction is still valid. Ethereum has no way of knowing whether an address was correctly derived from a public key (and therefore from a private key) in existence.\n\n[WARNING]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Transaction Recipient"}}
{"input": "Explain the Ethereum concept: Transaction Value and Data", "output": "(((\"transactions\",\"value and data fields\", id=\"ix_06transactions-asciidoc5\", range=\"startofrange\")))The main \"payload\" of a transaction is contained in (((\"data field\", id=\"ix_06transactions-asciidoc6\", range=\"startofrange\")))(((\"value field\", id=\"ix_06transactions-asciidoc7\", range=\"startofrange\")))two fields: +value+ and +data+. Transactions can have both value and data, only value, only data, or neither value nor data. All four combinations are valid.\n\n(((\"invocation\")))(((\"payment\")))A transaction with only value is a _payment_. A transaction with only data is an _invocation_. A transaction with both value and data is both a payment and an invocation. A transaction with neither value nor data&#x2014;well that's probably just a waste of gas! But it is still possible.\n\nLet's try all of these combinations. First we'll set the source and destination addresses from our wallet, just to make the demo easier to read:\n\n[source,javascript]\n----\nsrc = web3.eth.accounts[0];\ndst = web3.eth.accounts[1];\n----\n\nOur first transaction contains only a value (payment), and no data payload:\n\n[[tx_value_nodata_src]]\n[source,javascript]\n----\nweb3.eth.sendTransaction({from: src, to: dst, \\\n  value: web3.utils.toWei(0.01, \"ether\"), data: \"\"});\n----\n\nOur wallet shows a confirmation screen indicating the value to send, as shown in <<parity_txdemo_value_nodata>>.\n\n[[parity_txdemo_value_nodata]]\n.Parity wallet showing a transaction with value, but no data\nimage::images/parity_txdemo_value_nodata.png[\"Parity wallet showing a transaction with value, but no data\"]\n\n\nThe next example specifies both a value and a data payload:\n\n[[tx_value_data_src]]\n[source,javascript]\n----\nweb3.eth.sendTransaction({from: src, to: dst, \\\n  value: web3.utils.toWei(0.01, \"ether\"), data: \"0x1234\"});\n----\n\nOur wallet shows a confirmation screen indicating the value to send as well as the data payload, as shown in <<parity_txdemo_value_data>>.\n\n[[parity_txdemo_value_data]]\n.Parity wallet showing a transaction with value and data\nimage::images/parity_txdemo_value_data.png[\"Parity wallet showing a transaction with value and data\"]\n\nThe next transaction includes a data payload but specifies a value of zero:\n\n[[tx_novalue_data_src]]\n[source,javascript]\n----\nweb3.eth.sendTransaction({from: src, to: dst, value: 0, data: \"0x1234\"});\n----\n\nOur wallet shows a confirmation screen indicating the zero value and the data payload, as shown in <<parity_txdemo_novalue_data>>.\n\n[[parity_txdemo_novalue_data]]\n.Parity wallet showing a transaction with no value, only data\nimage::images/parity_txdemo_novalue_data.png[\"Parity wallet showing a transaction with no value, only data\"]\n\n[role=\"pagebreak-before\"]\nFinally, the last transaction includes neither a value to send nor a data payload:\n\n[[tx_novalue_nodata_src]]\n[source,javascript]\n----\nweb3.eth.sendTransaction({from: src, to: dst, value: 0, data: \"\"}));\n----\n\nOur wallet shows a confirmation screen indicating zero value, as shown in <<parity_txdemo_novalue_nodata>>.\n\n[[parity_txdemo_novalue_nodata]]\n.Parity wallet showing a transaction with no value, and no data\nimage::images/parity_txdemo_novalue_nodata.png[\"Parity wallet showing a transaction with no value, and no data\"]\n\n[[value_EOA_contracts]]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Transaction Value and Data"}}
{"input": "Explain the Ethereum concept: Transmitting Value to EOAs and Contracts", "output": "(((\"EOA (Externally Owned Account)\",\"transmitting value to\")))(((\"smart contracts\",\"transmitting value to\")))(((\"transactions\",\"transmitting value to EOAs and contract\")))When you construct an Ethereum transaction that contains a value, it is the equivalent of a _payment_. Such transactions behave differently depending on whether the destination address is a contract or not.\n\nFor EOA addresses, or rather for any address that isn't flagged as a contract on the blockchain, Ethereum will record a state change, adding the value you sent to the balance of the address. If the address has not been seen before, it will be added to the client's internal representation of the state and its balance initialized to the value of your payment.\n\nIf the destination address (+to+) is a contract, then the EVM will execute the contract and will attempt to call the function named in the data payload of your transaction. If there is no data in your transaction, the EVM will call a _fallback_ function and, if that function is payable, will execute it to determine what to do next. If there is no code in fallback function, then the effect of the transaction will be to increase the balance of the contract, exactly like a payment to a wallet. If there is no fallback function or non-payable fallback function, then transaction will be reverted. \n\nA contract can reject incoming payments by throwing an exception immediately when a function is called, or as determined by conditions coded in a function. If the function terminates successfully (without an exception), then the contract's state is updated to reflect an increase in the contract's ether balance.(((range=\"endofrange\", startref=\"ix_06transactions-asciidoc7\")))(((range=\"endofrange\", startref=\"ix_06transactions-asciidoc6\")))\n\n[[data_EOA]]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Transmitting Value to EOAs and Contracts"}}
{"input": "Explain the Ethereum concept: Transmitting a Data Payload to an EOA or Contract", "output": "(((\"data payload, transmitting to EOAs and contracts\", id=\"ix_06transactions-asciidoc8\", range=\"startofrange\")))(((\"EOA (Externally Owned Account)\",\"transmitting data payload to\", id=\"ix_06transactions-asciidoc9\", range=\"startofrange\")))(((\"smart contracts\",\"transmitting data payload to\", id=\"ix_06transactions-asciidoc10\", range=\"startofrange\")))(((\"transactions\",\"transmitting data payload to EOAs and contracts\", id=\"ix_06transactions-asciidoc11\", range=\"startofrange\")))When your transaction contains data, it is most likely addressed to a contract address. That doesn't mean you cannot send a data payload to an EOA&#x2014;that is completely valid in the Ethereum protocol. However, in that case, the interpretation of the data is up to the wallet you use to access the EOA. It is ignored by the Ethereum protocol. Most wallets also ignore any data received in a transaction to an EOA they control. In the future, it is possible that standards may emerge that allow wallets to interpret data the way contracts do, thereby allowing transactions to invoke functions running inside user wallets. The critical difference is that any interpretation of the data payload by an EOA is not subject to Ethereum's consensus rules, unlike a contract pass:[<span class=\"keep-together\">execution</span>].\n\nFor now, let's assume your transaction is delivering data to a contract address. (((\"contract invocation\")))(((\"invocation\")))In that case, the data will be interpreted by the EVM as a _contract invocation_. (((\"function invocation\")))Most contracts use this data more specifically as a _function invocation_, calling the named function and passing any encoded arguments to the function.\n\nThe data payload sent to an ABI-compatible contract (which you can assume all contracts are) is a hex-serialized encoding of:\n\nA function selector:: The first 4 bytes of the Keccak-256 hash of the function's prototype. This allows the contract to unambiguously identify which function you wish to invoke.\n\nThe function arguments:: The function's arguments, encoded according to the rules for the various elementary types defined in the ABI specification.\n\nIn <<solidity_faucet_example>>, we defined a function for withdrawals:\n\n[[withdraw_function_src]]\n[source,solidity]\n----\nfunction withdraw(uint withdraw_amount) public {\n----\n\n(((\"prototype of a function\")))The _prototype_ of a function is defined as the string containing the name of the function, followed by the data types of each of its arguments, enclosed in parentheses and separated by commas. The function name here is +withdraw+ and it takes a single argument that is a +uint+ (which is an alias for +uint256+), so the prototype of +withdraw+ would be:\n\n[source,solidity]\n----\nwithdraw(uint256)\n----\n\nLet's calculate the Keccak-256 hash of this string:\n\n++++\n<pre data-type=\"programlisting\">\n> <strong>web3.utils.sha3(\"withdraw(uint256)\");</strong>\n'0x2e1a7d4d13322e7b96f9a57413e1525c250fb7a9021cf91d1540d5b69f16a49f'\n</pre>\n++++\n\nThe first 4 bytes of the hash are +0x2e1a7d4d+. That's our \"function selector\" value, which will tell the contract which function we want to call.\n\nNext, let's calculate a value to pass as the argument +withdraw_amount+. We want to withdraw 0.01 ether. Let's encode that to a hex-serialized big-endian unsigned 256-bit integer, denominated in wei:\n\n++++\n<pre data-type=\"programlisting\">\n> <strong>withdraw_amount = web3.utils.toWei(0.01, \"ether\");</strong>\n'10000000000000000'\n> <strong>withdraw_amount_hex = web3.utils.toHex(withdraw_amount);</strong>\n'0x2386f26fc10000'\n</pre>\n++++\n\nNow, we add the function selector to the amount (padded to 32 bytes):\n\n----\n2e1a7d4d000000000000000000000000000000000000000000000000002386f26fc10000\n----\n\nThat's the data payload for our transaction, invoking the +withdraw+ function and requesting 0.01 ether as the +withdraw_amount+(((range=\"endofrange\", startref=\"ix_06transactions-asciidoc11\")))(((range=\"endofrange\", startref=\"ix_06transactions-asciidoc10\")))(((range=\"endofrange\", startref=\"ix_06transactions-asciidoc9\")))(((range=\"endofrange\", startref=\"ix_06transactions-asciidoc8\"))).(((range=\"endofrange\", startref=\"ix_06transactions-asciidoc5\")))\n\n[[contract_reg]]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Transmitting a Data Payload to an EOA or Contract"}}
{"input": "Explain the Ethereum concept: Special Transaction: Contract Creation", "output": "(((\"contract creation transaction\", id=\"ix_06transactions-asciidoc12\", range=\"startofrange\")))(((\"transactions\",\"contract creation\", id=\"ix_06transactions-asciidoc13\", range=\"startofrange\")))One special case that we should mention is a transaction that _creates a new contract_ on the blockchain, deploying it for future use. (((\"zero address\",\"contract creation\")))Contract creation transactions are sent to a special destination address called the _zero address_; the +to+ field in a contract registration transaction contains the address +0x0+. This address represents neither an EOA (there is no corresponding private\u2013public key pair) nor a contract. It can never spend ether or initiate a transaction. It is only used as a destination, with the special meaning \"create this contract.\"\n\nWhile the zero address is intended only for contract creation, it sometimes receives payments from various addresses. (((\"ether burn\")))There are two explanations for this: either it is by accident, resulting in the loss of ether, or it is an intentional _ether burn_ (deliberately destroying ether by sending it to an address from which it can never be spent). However, if you want to do an intentional ether burn, you should make your intention clear to the network and use the specially designated burn address instead:\n\n[[burn_address]]\n----\n0x000000000000000000000000000000000000dEaD\n----\n\n[WARNING]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Special Transaction: Contract Creation"}}
{"input": "Explain the Ethereum concept: Digital Signatures", "output": "(((\"digital signatures\", id=\"ix_06transactions-asciidoc14\", range=\"startofrange\")))(((\"transactions\",\"digital signatures and\", id=\"ix_06transactions-asciidoc15\", range=\"startofrange\")))So far, we have not delved into any detail about digital signatures. In this section, we look at how digital signatures work and how they can be used to present proof of ownership of a private key without revealing that private key.\n\n[[ecdsa]]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Digital Signatures"}}
{"input": "Explain the Ethereum concept: The Elliptic Curve Digital Signature Algorithm", "output": "(((\"digital signatures\",\"ECDSA and\")))(((\"Elliptic Curve Digital Signature Algorithm (ECDSA)\",\"about\")))The digital signature algorithm used in Ethereum is the _Elliptic Curve Digital Signature Algorithm_ (ECDSA). It's based on elliptic curve private\u2013public key pairs, as described in <<elliptic_curve>>.\n\nA digital signature serves three purposes in Ethereum (see the following sidebar). First, the signature proves that the owner of the private key, who is by implication the owner of an Ethereum account, has _authorized_ the spending of ether, or execution of a contract. (((\"non-repudiation\")))Secondly, it guarantees _non-repudiation_: the proof of authorization is undeniable. Thirdly, the signature proves that the transaction data has not been and _cannot be modified_ by anyone after the transaction has been signed.\n\n[[digital_signature_definition]]\n.Wikipedia's Definition of a Digital Signature\n****\n(((\"digital signatures\",\"Wikipedia definition\")))A _digital signature_ is a mathematical scheme for presenting the authenticity of digital messages or documents. A valid digital signature gives a recipient reason to believe that the message was created by a known sender (authentication), that the sender cannot deny having sent the message (non-repudiation), and that the message was not altered in transit (integrity).\n\n_Source: https://en.wikipedia.org/wiki/Digital_signature_\n****\n\n[[digital_sign_work]]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "The Elliptic Curve Digital Signature Algorithm"}}
{"input": "Explain the Ethereum concept: How Digital Signatures Work", "output": "(((\"digital signatures\",\"mechanism of operation\")))A digital signature is a mathematical scheme that consists of two parts. The first part is an algorithm for creating a signature, using a private key (the signing key), from a message (which in our case is the transaction). The second part is an algorithm that allows anyone to verify the signature by only using the message and a public key.\n\n[[digital_sign_create]]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "How Digital Signatures Work"}}
{"input": "Explain the Ethereum concept: Creating a digital signature", "output": "(((\"digital signatures\",\"creating\")))(((\"Elliptic Curve Digital Signature Algorithm (ECDSA)\",\"signature creation\")))In Ethereum's implementation of ECDSA, the \"message\" being signed is the transaction, or more accurately, the Keccak-256 hash of the RLP-encoded data from the transaction. The signing key is the EOA's private key. The result is the signature:\n\n++++\n<div data-type=\"equation\">\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mrow>\n    <mrow>\n      <mi>S</mi>\n      <mi>i</mi>\n      <mi>g</mi>\n    </mrow>\n    <mo>=</mo>\n    <msub><mi>F</mi> <mrow><mi>s</mi><mi>i</mi><mi>g</mi></mrow> </msub>\n    <mrow>\n      <mo>(</mo>\n      <msub><mi>F</mi> <mrow><mi>k</mi><mi>e</mi><mi>c</mi><mi>c</mi><mi>a</mi><mi>k</mi><mn>256</mn></mrow> </msub>\n      <mrow>\n        <mo>(</mo>\n        <mi>m</mi>\n        <mo>)</mo>\n      </mrow>\n      <mo>,</mo>\n      <mi>k</mi>\n      <mo>)</mo>\n    </mrow>\n  </mrow>\n</math>\n</div>\n++++\n\nwhere:\n\n* _k_ is the signing private key.\n* _m_ is the RLP-encoded transaction.\n* _F_~_keccak256_~ is the Keccak-256 hash function.\n* _F_~_sig_~ is the signing algorithm.\n* _Sig_ is the resulting signature.\n\n[[sign_function]]\nThe function _F_~_sig_~ produces a signature __Sig__ that is composed of two values, commonly referred to as _r_ and _s_:\n\n++++\n<div data-type=\"equation\">\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\">\n  <mrow>\n    <mrow>\n      <mi>S</mi>\n      <mi>i</mi>\n      <mi>g</mi>\n    </mrow>\n    <mo>=</mo>\n    <mo>(</mo>\n    <mi>r</mi>\n    <mo>,</mo>\n    <mi>s</mi>\n    <mo>)</mo>\n  </mrow>\n</math>\n</div>\n++++\n\n[[verify_sign]]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Creating a digital signature"}}
{"input": "Explain the Ethereum concept: Verifying the Signature", "output": "(((\"digital signatures\",\"verifying\")))To verify the signature, one must have the signature (_r_ and _s_), the serialized transaction, and the public key that corresponds to the private key used to create the signature. Essentially, verification of a signature means \"only the owner of the private key that generated this public key could have produced this signature on this transaction.\"\n\nThe signature verification algorithm takes the message (i.e., a hash of the transaction for our usage), the signer's public key, and the signature (_r_ and _s_ values), and returns +true+ if the signature is valid for this message and public key.\n\n[[ecdsa_math]]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Verifying the Signature"}}
{"input": "Explain the Ethereum concept: ECDSA Math", "output": "(((\"digital signatures\",\"ECDSA math\", id=\"ix_06transactions-asciidoc16\", range=\"startofrange\")))(((\"Elliptic Curve Digital Signature Algorithm (ECDSA)\",\"mathematics of\", id=\"ix_06transactions-asciidoc17\", range=\"startofrange\")))As mentioned previously, signatures are created by a mathematical function _F_~_sig_~ that produces a signature composed of two values, _r_ and _s_. In this section we look at the function _F_~_sig_~ in more detail.\n\n(((\"ephemeral private key\")))The signature algorithm first generates an _ephemeral_ (temporary) private key in a cryptographically secure way. This temporary key is used in the calculation of the _r_ and _s_ values to ensure that the sender's actual private key can't be calculated by attackers watching signed transactions on the Ethereum network.\n\nAs we know from <<pubkey>>, the ephemeral private key is used to derive the corresponding (ephemeral) public key, so we have:\n\n* A cryptographically secure random number _q_, which is used as the ephemeral private key\n* The corresponding ephemeral public key _Q_, generated from _q_ and the elliptic curve generator point _G_\n\nThe _r_ value of the digital signature is then the _x_ coordinate of the ephemeral public key _Q_.\n\nFrom there, the algorithm calculates the _s_ value of the signature, such that:\n\n++++\n<ul class=\"simplelist\">\n<li><em>s</em> &#8801; <em>q</em><sup>-1</sup> (<em>Keccak256</em>(<em>m</em>) + <em>r</em> * <em>k</em>)  &nbsp;  &nbsp; (<em>mod p</em>)</li>\n</ul>\n++++\n\nwhere:\n\n* _q_ is the ephemeral private key.\n* _r_ is the _x_ coordinate of the ephemeral public key.\n* _k_ is the signing (EOA owner's) private key.\n* _m_ is the transaction data.\n* _p_ is the prime order of the elliptic curve.\n\nVerification is the inverse of the signature generation function, using the _r_ and _s_ values and the sender's public key to calculate a value _Q_, which is a point on the elliptic curve (the ephemeral public key used in signature creation). The steps are as follows:\n\n1. Check all inputs are correctly formed\n2. Calculate _w_ = __s__^-1^ _mod p_\n3. Calculate _u~1~_ = __Keccak256__(__m__) * _w_ _mod p_\n4. Calculate _u~2~_ = _r_ * _w_ _mod p_\n5. Finally, calculate the point on the elliptic curve _Q_ &#8801; _u~1~_ * _G_ + _u~2~_ * _K_  {nbsp} {nbsp} (_mod p_)\n\nwhere:\n\n* _r_ and _s_ are the signature values.\n* _K_ is the signer's (EOA owner's) public key.\n* _m_ is the transaction data that was signed.\n* _G_ is the elliptic curve generator point.\n* _p_ is the prime order of the elliptic curve.\n\nIf the _x_ coordinate of the calculated point _Q_ is equal to _r_, then the verifier can conclude that the signature is valid.\n\nNote that in verifying the signature, the private key is neither known nor revealed.\n\n[TIP]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "ECDSA Math"}}
{"input": "Explain the Ethereum concept: Transaction Signing in Practice", "output": "(((\"digital signatures\",\"signing in practice\")))(((\"Elliptic Curve Digital Signature Algorithm (ECDSA)\",\"transaction signing in practice\")))(((\"transactions\",\"signing in practice\")))To produce a valid transaction, the originator must digitally sign the message, using the Elliptic Curve Digital Signature Algorithm. When we say \"sign the transaction\" we actually mean \"sign the Keccak-256 hash of the RLP-serialized transaction data.\" The signature is applied to the hash of the transaction data, not the transaction itself.\n\nTo sign a transaction in Ethereum, the originator must:\n\n1. Create a transaction data structure, containing nine fields: +nonce+, +gasPrice+, +gasLimit+, +to+, +value+, +data+, +chainID+, +0+, +0+.\n2. Produce an RLP-encoded serialized message of the transaction data structure.\n3. Compute the Keccak-256 hash of this serialized message.\n4. Compute the ECDSA signature, signing the hash with the originating EOA's private key.\n5. Append the ECDSA signature's computed +v+, +r+, and +s+ values to the transaction.\n\nThe special signature variable +v+ indicates two things: the chain ID and the recovery identifier to help the +ECDSArecover+ function check the signature. It is calculated as either one of 27 or 28, or as the chain ID doubled plus 35 or 36. For more information on the chain ID, see <<raw_tx_eip155>>. The recovery identifier (27 or 28 in the \"old-style\" signatures, or 35 or 36 in the full Spurious Dragon&#x2013;style transactions) is used to indicate the parity of the +y+ component of the public key (see <<sign_prefix>> for more details).\n\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Transaction Signing in Practice"}}
{"input": "Explain the Ethereum concept: Raw Transaction Creation and Signing", "output": "(((\"EthereumJS\")))(((\"transactions\",\"raw transaction creation/signing\")))In this section we'll create a raw transaction and sign it, using the +ethereumjs-tx+ library, which can be installed with npm. This demonstrates the functions that would normally be used inside a wallet, or an application that signs transactions on behalf of a user. The source code for this example is in the file __raw_tx_demo.js__ in the book's http://bit.ly/2yI2GL3[GitHub repository]:\n\n[[raw_tx_demo_source]]\n[source,javascript]\n----\ninclude::code/web3js/raw_tx/raw_tx_demo.js[]\n----\n\n[[raw_tx_demo_run]]\nRunning the example code produces the following results:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>node raw_tx_demo.js</strong>\nRLP-Encoded Tx: 0xe6808609184e72a0008303000094b0920c523d582040f2bcb1bd7fb1c7c1...\nTx Hash: 0xaa7f03f9f4e52fcf69f836a6d2bbc7706580adce0a068ff6525ba337218e6992\nSigned Raw Transaction: 0xf866808609184e72a0008303000094b0920c523d582040f2bcb1...\n</pre>\n++++\n\n[[raw_tx_eip155]]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Raw Transaction Creation and Signing"}}
{"input": "Explain the Ethereum concept: Raw Transaction Creation with EIP-155", "output": "(((\"chain identifier\")))(((\"EIP-155 Simple Replay Attack Protection standard\")))(((\"transactions\",\"raw transaction creation with EIP-155\")))The EIP-155 \"Simple Replay Attack Protection\" standard specifies a replay-attack-protected transaction encoding, which includes a _chain identifier_ inside the transaction data, prior to signing. This ensures that transactions created for one blockchain (e.g., the Ethereum main network) are invalid on another blockchain (e.g., Ethereum Classic or the Ropsten test network). Therefore, transactions broadcast on one network cannot be _replayed_ on another, hence the name of the standard.\n\nEIP-155 adds three fields to the main six fields of the transaction data structure, namely the chain identifier, +0+, and +0+. These three fields are added to the transaction data _before it is encoded and hashed_. They therefore change the transaction's hash, to which the signature is later applied. By including the chain identifier in the data being signed, the transaction signature prevents any changes, as the signature is invalidated if the chain identifier is modified. Therefore, EIP-155 makes it impossible for a transaction to be replayed on another chain, because the signature's validity depends on the chain identifier.\n\n\nThe chain identifier field takes a value according to the network the transaction is meant for, as outlined in <<chain_id_table>>.\n\n[[chain_id_table]]\n.Chain identifiers\n[options=\"header\"]\n|======\n| Chain | Chain ID\n| Ethereum mainnet | 1\n| Morden (obsolete), Expanse | 2\n| Ropsten | 3\n| Rinkeby | 4\n| Rootstock mainnet | 30\n| Rootstock testnet | 31\n| Kovan | 42\n| Ethereum Classic mainnet | 61\n| Ethereum Classic testnet | 62\n| Geth private testnets | 1337\n|======\n\nThe resulting transaction structure is RLP-encoded, hashed, and signed. The signature algorithm is modified slightly to encode the chain identifier in the +v+ prefix too.\n\nFor more details, see http://bit.ly/2CQUgne[the EIP-155 specification].(((range=\"endofrange\", startref=\"ix_06transactions-asciidoc15\")))(((range=\"endofrange\", startref=\"ix_06transactions-asciidoc14\")))\n\n[[sign_prefix]]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Raw Transaction Creation with EIP-155"}}
{"input": "Explain the Ethereum concept: The Signature Prefix Value (v) and Public Key Recovery", "output": "(((\"digital signatures\",\"signature prefix value (v) and public key recovery\")))(((\"public key recovery\")))(((\"transactions\",\"signature prefix value (v) and public key recovery\")))As mentioned in <<tx_struct>>, the transaction message doesn't include a \"from\" field. That's because the originator's public key can be computed directly from the ECDSA signature. Once you have the public key, you can compute the address easily. The process of recovering the signer's public key is called _public key recovery_.\n\nGiven the values +r+ and +s+ that were computed in <<ecdsa_math>>, we can compute two possible public keys.\n\nFirst, we compute two elliptic curve points, _R_ and __R__^__'__^, from the _x_ coordinate +r+ value that is in the signature. There are two points because the elliptic curve is symmetric across the x-axis, so that for any value +x+ there are two possible values that fit the curve, one on each side of the x-axis.\n\nFrom +r+ we also calculate __r__^-1^, which is the multiplicative inverse of +r+.\n\nFinally, we calculate _z_, which is the _n_ lowest bits of the message hash, where _n_ is the order of the elliptic curve.\n\nThe two possible public keys are then:\n\n++++\n<ul class=\"simplelist\">\n<li><em>K</em><sub>1</sub> = <em>r</em><sup>&#x2013;1</sup> (<em>sR</em> &#x2013; <em>zG</em>)</li>\n</ul>\n++++\n\nand:\n\n++++\n<ul class=\"simplelist\">\n<li><em>K</em><sub>2</sub> = <em>r</em><sup>&#x2013;1</sup> (<em>sR</em><sup>'</sup> &#x2013; <em>zG</em>)</li>\n</ul>\n++++\n\nwhere:\n\n* __K__~1~ and __K__~2~ are the two possibilities for the signer's public key.\n* __r__^-1^ is the multiplicative inverse of the signature's +r+ value.\n* _s_ is the signature's +s+ value.\n* __R__ and __R__^'^ are the two possibilities for the ephemeral public key _Q_.\n* _z_ is the __n__-lowest bits of the message hash.\n* _G_ is the elliptic curve generator point.\n\nTo make things more efficient, the transaction signature includes a prefix value +v+, which tells us which of the two possible _R_ values is the ephemeral public key. If +v+ is even, then _R_ is the correct value. If +v+ is odd, then it is __R__^'^. That way, we need to calculate only one value for _R_ and only one value for _K_.\n\n[[offline_sign]]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "The Signature Prefix Value (v) and Public Key Recovery"}}
{"input": "Explain the Ethereum concept: Separating Signing and Transmission (Offline Signing)", "output": "(((\"digital signatures\",\"separating signing and transmission\", id=\"ix_06transactions-asciidoc18\", range=\"startofrange\")))(((\"offline signing\", id=\"ix_06transactions-asciidoc19\", range=\"startofrange\")))(((\"transactions\",\"separating signing and transmission\", id=\"ix_06transactions-asciidoc20\", range=\"startofrange\")))Once a transaction is signed, it is ready to transmit to the Ethereum network. The three steps of creating, signing, and broadcasting a transaction normally happen as a single operation, for example using +web3.eth.sendTransaction+. However, as you saw in <<raw_tx>>, you can create and sign the transaction in two separate steps. Once you have a signed transaction, you can then transmit it using +web3.eth.sendSignedTransaction+, which takes a hex-encoded and signed transaction and transmits it on the Ethereum network.\n\nWhy would you want to separate the signing and transmission of transactions? The most common reason is security. The computer that signs a transaction must have unlocked private keys loaded in memory. The computer that does the transmitting must be connected to the internet (and be running an Ethereum client). If these two functions are on one computer, then you have private keys on an online system, which is quite dangerous. Separating the functions of signing and transmitting and performing them on different machines (on an offline and an online device, respectively) is called _offline signing_ and is a common security practice.\n\n<<offline_signing>> shows the process:\n\n1. Create an unsigned transaction on the online computer where the current state of the account, notably the current nonce and funds available, can be retrieved.\n2. Transfer the unsigned transaction to an \"air-gapped\" offline device for transaction signing, e.g., via a QR code or USB flash drive.\n3. Transmit the signed transaction (back) to an online device for broadcast on the Ethereum blockchain, e.g., via QR code or USB flash drive.\n\n[[offline_signing]]\n.Offline signing of Ethereum transactions\nimage::images/offline_signing.png[\"Offline signing of Ethereum transactions\"]\n\nDepending on the level of security you need, your \"offline signing\" computer can have varying degrees of separation from the online computer, ranging from an isolated and firewalled subnet (online but segregated) to a completely offline system known as an _air-gapped_ system. (((\"air-gapped system\")))In an air-gapped system there is no network connectivity at all&#x2014;the computer is separated from the online environment by a gap of \"air.\" To sign transactions you transfer them to and from the air-gapped computer using data storage media or (better) a webcam and QR code. Of course, this means you must manually transfer every transaction you want signed, and this doesn't scale.\n\nWhile not many environments can utilize a fully air-gapped system, even a small degree of isolation has significant security benefits. For example, an isolated subnet with a firewall that only allows a message-queue protocol through can offer a much-reduced attack surface and much higher security than signing on the online system. (((\"ZeroMQ (0MQ)\")))Many companies use a protocol such as ZeroMQ (0MQ) for this purpose. With a setup like that, transactions are serialized and queued for signing. The queuing protocol transmits the serialized message, in a way similar to a TCP socket, to the signing computer. The signing computer reads the serialized transactions from the queue (carefully), applies a signature with the appropriate key, and places them on an outgoing queue. The outgoing queue transmits the signed transactions to a computer with an Ethereum client that dequeues them and transmits them.(((range=\"endofrange\", startref=\"ix_06transactions-asciidoc20\")))(((range=\"endofrange\", startref=\"ix_06transactions-asciidoc19\")))(((range=\"endofrange\", startref=\"ix_06transactions-asciidoc18\")))\n\n[[tx_propagation]]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Separating Signing and Transmission (Offline Signing)"}}
{"input": "Explain the Ethereum concept: Transaction Propagation", "output": "(((\"flood routing\")))(((\"node\",\"transaction propagation\")))(((\"propagation of transactions\")))(((\"transactions\",\"propagation of\")))The Ethereum network uses a \"flood routing\" protocol. Each Ethereum client acts as a _node_ in a _peer-to-peer (P2P)_ network, which (ideally) forms a _mesh_ network. No network node is special: they all act as equal peers. We will use the term \"node\" to refer to an Ethereum client that is connected to and participates in the P2P network.\n\nTransaction propagation starts with the originating Ethereum node creating (or receiving from offline) a signed transaction. The transaction is validated and then transmitted to all the other Ethereum nodes that are _directly_ connected to the originating node. (((\"neighbor nodes\")))On average, each Ethereum node maintains connections to at least 13 other nodes, called its _neighbors_. Each neighbor node validates the transaction as soon as they receive it. If they agree that it is valid, they store a copy and propagate it to all their neighbors (except the one it came from). As a result, the transaction ripples outwards from the originating node, _flooding_ across the network, until all nodes in the network have a copy of the transaction. Nodes can filter the messages they propagate, but the default is to propagate all valid transaction messages they receive.\n\nWithin just a few seconds, an Ethereum transaction propagates to all the Ethereum nodes around the globe. From the perspective of each node, it is not possible to discern the origin of the transaction. The neighbor that sent it to the node may be the originator of the transaction or may have received it from one of its neighbors. To be able to track the origins of transactions, or interfere with propagation, an attacker would have to control a significant percentage of all nodes. This is part of the security and privacy design of P2P networks, especially as applied to blockchain networks.\n\n[[chain_record]]", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Transaction Propagation"}}
{"input": "Explain the Ethereum concept: Recording on the Blockchain", "output": "(((\"blockchain\",\"recording transactions on\")))(((\"miners\")))(((\"mining farms\")))(((\"transactions\",\"recording on the blockchain\")))While all the nodes in Ethereum are equal peers, some of them are operated by _miners_ and are feeding transactions and blocks to _mining farms_, which are computers with high-performance graphics processing units (GPUs). The mining computers add transactions to a candidate block and attempt to find a _proof of work_ that makes the candidate block valid. We will discuss this in more detail in <<consensus>>.\n\nWithout going into too much detail, valid transactions will eventually be included in a block of transactions and, thus, recorded in the Ethereum blockchain. Once mined into a block, transactions also modify the state of the Ethereum singleton, either by modifying the balance of an account (in the case of a simple payment) or by invoking contracts that change their internal state. These changes are recorded alongside the transaction, in the form of a transaction _receipt_, which may also include _events_. We will examine all this in much more detail in <<evm_chapter>>.\n\nA transaction that has completed its journey from creation through signing by an EOA, propagation, and finally mining has changed the state of the singleton and left an indelible mark on the blockchain.", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Recording on the Blockchain"}}
{"input": "Explain the Ethereum concept: Multiple-Signature (Multisig) Transactions", "output": "(((\"multiple-signature (multisig) transactions\")))(((\"transactions\",\"multiple-signature\")))If you are familiar with Bitcoin's scripting capabilities, you know that it is possible to create a Bitcoin multisig account which can only spend funds when multiple parties sign the transaction (e.g., 2 of 2 or 3 of 4 signatures). Ethereum's basic EOA value transactions have no provisions for multiple signatures; however, arbitrary signing restrictions can be enforced by smart contracts with any conditions you can think of, to handle the transfer of ether and tokens alike.\n\nTo take advantage of this capability, ether has to be transferred to a \"wallet contract\" that is programmed with the spending rules desired, such as multisignature requirements or spending limits (or combinations of the two). The wallet contract then sends the funds when prompted by an authorized EOA once the spending conditions have been satisfied. For example, to protect your ether under a multisig condition, transfer the ether to a multisig contract. Whenever you want to send funds to another account, all the required users will need to send transactions to the contract using a regular wallet app, effectively authorizing the contract to perform the final pass:[<span class=\"keep-together\">transaction</span>].\n\nThese contracts can also be designed to require multiple signatures before executing local code or to trigger other contracts. The security of the scheme is ultimately determined by the multisig contract code.\n\nThe ability to implement multisignature transactions as a smart contract demonstrates the flexiblity of Ethereum. However, it is a double-edged sword, as the extra flexibility can lead to bugs that undermine the security of multisignature schemes. There are, in fact, a number of proposals to create a multisignature command in the EVM that removes the need for smart contracts, at least for the simple M-of-N multisignature schemes. This would be equivalent to Bitcoin's multisignature system, which is part of the core consensus rules and has proven to be robust and secure.", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Multiple-Signature (Multisig) Transactions"}}
{"input": "Explain the Ethereum concept: Conclusions", "output": "Transactions are the starting point of every activity in the Ethereum system. Transactions are the \"inputs\" that cause the Ethereum Virtual Machine to evaluate contracts, update balances, and more generally modify the state of the Ethereum blockchain. Next, we will work with smart contracts in a lot more detail and learn how to program in the Solidity contract-oriented language.(((range=\"endofrange\", startref=\"ix_06transactions-asciidoc0\")))", "metadata": {"source": "ethereumbook", "chapter": "06transactions.asciidoc", "section": "Conclusions"}}
{"input": "Explain the Ethereum concept: Smart Contracts and Solidity", "output": "(((\"smart contracts\", id=\"ix_07smart-contracts-solidity-asciidoc0\", range=\"startofrange\")))As we discussed in <<intro_chapter>>, there are two different types of accounts in Ethereum: (((\"EOA (Externally Owned Account)\",\"contract accounts compared to\")))externally owned accounts (EOAs) and contract accounts. EOAs are controlled by users, often via software such as a wallet application that is external to the Ethereum platform. (((\"contract accounts\",\"EOAs compared to\")))(((\"smart contracts\",\"EOAs compared to\")))In contrast, contract accounts are controlled by program code (also commonly referred to as &#x201c;smart contracts&#x201d;) that is executed by the Ethereum Virtual Machine. In short, EOAs are simple accounts without any associated code or data storage, whereas contract accounts have both associated code and data storage. EOAs are controlled by transactions created and cryptographically signed with a private key in the \"real world\" external to and independent of the protocol, whereas contract accounts do not have private keys and so \"control themselves\" in the predetermined way prescribed by their smart contract code. Both types of accounts are identified by an Ethereum address. In this chapter, we will discuss contract accounts and the program code that controls them.\n\n[[smart_contracts_definition]]", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Smart Contracts and Solidity"}}
{"input": "Explain the Ethereum concept: What Is a Smart Contract?", "output": "(((\"smart contracts\",\"defined\")))The term _smart contract_ has been used over the years to describe a wide variety of different things. (((\"contract creation transaction\")))(((\"Szabo, Nick\")))In the 1990s, cryptographer Nick Szabo coined the term and defined it as \u201ca set of promises, specified in digital form, including protocols within which the parties perform on the other promises.\u201d Since then, the concept of smart contracts has evolved, especially after the introduction of decentralized blockchain platforms with the invention of Bitcoin in 2009. In the context of Ethereum, the term is actually a bit of a misnomer, given that Ethereum smart contracts are neither smart nor legal contracts, but the term has stuck. In this book, we use the term \u201csmart contracts\u201d to refer to immutable computer programs that run deterministically in the context of an Ethereum Virtual Machine as part of the Ethereum network protocol&#x2014;i.e., on the decentralized Ethereum world computer.\n\nLet\u2019s unpack that definition:\n\nComputer programs::\nSmart contracts are simply computer programs. The word &#x201c;contract&#x201d; has no legal meaning in this context.\n\nImmutable::\nOnce deployed, the code of a smart contract cannot change. Unlike with traditional software, the only way to modify a smart contract is to deploy a new instance.\n\nDeterministic::\nThe outcome of the execution of a smart contract is the same for everyone who runs it, given the context of the transaction that initiated its execution and the state of the Ethereum blockchain at the moment of execution.\n\nEVM context::\nSmart contracts operate with a very limited execution context. They can access their own state, the context of the transaction that called them, and some information about the most recent blocks.\n\nDecentralized world computer::\nThe EVM runs as a local instance on every Ethereum node, but because all instances of the EVM operate on the same initial state and produce the same final state, the system as a whole operates as a single \"world computer.\"\n\n[[smart_contract_lifecycle]]", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "What Is a Smart Contract?"}}
{"input": "Explain the Ethereum concept: Life Cycle of a Smart Contract", "output": "(((\"smart contracts\",\"life cycle of\")))Smart contracts are typically written in a high-level language, such as Solidity. But in order to run, they must be compiled to the low-level bytecode that runs in the EVM. Once compiled, they are deployed on the Ethereum platform using a special _contract creation_ transaction, which is identified as such by being sent to the special contract creation address, namely +0x0+ (see <<contract_reg>>). Each contract is identified by an Ethereum address, which is derived from the contract creation transaction as a function of the originating account and nonce. The Ethereum address of a contract can be used in a transaction as the recipient, sending funds to the contract or calling one of the contract\u2019s functions. Note that, unlike with EOAs, there are no keys associated with an account created for a new smart contract. As the contract creator, you don't get any special privileges at the protocol level (although you can explicitly code them into the smart contract). You certainly don't receive the private key for the contract account, which in fact does not exist&#x2014;we can say that smart contract accounts own themselves.\n\n(((\"transactions\",\"smart contracts and\")))Importantly, contracts _only run if they are called by a transaction_. All smart contracts in Ethereum are executed, ultimately, because of a transaction initiated from an EOA. A contract can call another contract that can call another contract, and so on, but the first contract in such a chain of execution will always have been called by a transaction from an EOA. Contracts never run \u201con their own\u201d or \u201cin the background.\u201d Contracts effectively lie dormant until a transaction triggers execution, either directly or indirectly as part of a chain of contract calls. It is also worth noting that smart contracts are not executed \"in parallel\" in any sense&#x2014;the Ethereum world computer can be considered to be a single-threaded machine.\n\n(((\"transactions\",\"as atomic\")))Transactions are _atomic_, they are either successfully terminated or reverted. A successful termination of a transaction means different things under different scenarios: (1) if a transaction is sent from an EOA to another EOA then any changes to the global state (e.g. account balances) made by the transaction are recorded; (2) if a transaction is sent from an EOA to a contract that does not invoke any other contracts, then any changes to the global state are recorded (e.g. account balances, state variables of the contracts) (3) if a transaction is sent from an EOA to a contract that only invokes other contracts in a manner that propagates errors, then any changes to the global state are recorded (e.g. account balances, state variables of the contracts); and (4) if a transaction is sent from an EOA to a contract that invokes other contracts in a manner that does not propagates errors, then there may only be some changes to the global state recorded (e.g. account balances, state variables of the non erroring contracts), whereas other changes to the global state are not recorded (e.g. state variables of the erroring contracts). Otherwise, if a transaction is reverted, all of its effects (changes in state) are \u201crolled back\u201d as if the transaction never ran.  A failed transaction is still recorded as having been attempted, and the ether spent on gas for the execution is deducted from the originating account, but it otherwise has no other effects on contract or account state. \n\n(((\"smart contracts\",\"deleting\")))As mentioned previously, it is important to remember that a contract\u2019s code cannot be changed. However, a contract can be \u201cdeleted,\u201d removing the code and its internal state (storage) from its address, leaving a blank account. Any transactions sent to that account address after the contract has been deleted do not result in any code execution, because there is no longer any code there to execute. (((\"SELFDESTRUCT opcode\")))To delete a contract, you execute an EVM opcode called +SELFDESTRUCT+ (previously called +SUICIDE+). (((\"negative gas\")))That operation costs \u201cnegative gas,\u201d a gas refund, thereby incentivizing the release of network client resources from the deletion of stored state. Deleting a contract in this way does not remove the transaction history (past) of the contract, since the blockchain itself is immutable. It is also important to note that the +SELFDESTRUCT+ capability will only be available if the contract author programmed the smart contract to have that functionality. If the contract's code does not have a +SELFDESTRUCT+ opcode, or it is inaccessible, the smart contract cannot be deleted.\n\n[[high_level_languages]]", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Life Cycle of a Smart Contract"}}
{"input": "Explain the Ethereum concept: Introduction to Ethereum High-Level Languages", "output": "(((\"EVM (Ethereum Virtual Machine)\",\"and Ethereum high-level languages\", id=\"ix_07smart-contracts-solidity-asciidoc1\", range=\"startofrange\")))(((\"smart contracts\",\"and Ethereum high-level languages\", id=\"ix_07smart-contracts-solidity-asciidoc2\", range=\"startofrange\")))The EVM is a virtual machine that runs a (((\"EVM bytecode\")))special form of code called _EVM bytecode_, analogous to your computer's CPU, which runs machine code such as x86_64. We will examine the operation and language of the EVM in much more detail in <<evm_chapter>>. In this section we will look at how smart contracts are written to run on the EVM.\n\nWhile it is possible to program smart contracts directly in bytecode, EVM bytecode is rather unwieldy and very difficult for programmers to read and understand. Instead, most Ethereum developers use a high-level language to write programs, and a compiler to convert them into bytecode.\n\nWhile any high-level language could be adapted to write smart contracts, adapting an arbitrary language to be compilable to EVM bytecode is quite a cumbersome exercise and would in general lead to some amount of confusion. Smart contracts operate in a highly constrained and minimalistic execution environment (the EVM). In addition, a special set of EVM-specific system variables and functions needs to be available. As such, it is easier to build a smart contract language from scratch than it is to make a general-purpose language suitable for writing smart contracts. As a result, a number of special-purpose languages have emerged for programming smart contracts. Ethereum has several such languages, together with the compilers needed to produce EVM-executable bytecode.\n\n(((\"declarative programming\")))In general, programming languages can be classified into two broad programming paradigms: _declarative_ and _imperative_, also known as _functional_ and _procedural_, respectively. In declarative programming, we write functions that express the _logic_ of a program, but not its _flow_. (((\"side effects\")))Declarative programming is used to create programs where there are no _side effects_, meaning that there are no changes to state outside of a function. Declarative programming languages include Haskell and SQL. (((\"hybrid programming languages\")))(((\"imperative programming\")))Imperative programming, by contrast, is where a programmer writes a set of procedures that combine the logic and flow of a program. Imperative programming languages include C++ and Java. Some languages are \u201chybrid,\u201d meaning that they encourage declarative programming but can also be used to express an imperative programming paradigm. Such hybrids include Lisp, JavaScript, and Python. In general, any imperative language can be used to write in a declarative paradigm, but it often results in inelegant code. By comparison, pure declarative languages cannot be used to write in an imperative paradigm. In purely declarative languages, _there are no \u201cvariables.\u201d_\n\nWhile imperative programming is more commonly used by programmers, it can be very difficult to write programs that execute _exactly as expected_. The ability of any part of the program to change the state of any other makes it difficult to reason about a program\u2019s execution and introduces many opportunities for bugs. Declarative programming, by comparison, makes it easier to understand how a program will behave: since it has no side effects, any part of a program can be understood in isolation.\n\nIn smart contracts, bugs literally cost money. As a result, it is critically important to write smart contracts without unintended effects. To do that, you must be able to clearly reason about the expected behavior of the program. So, declarative languages play a much bigger role in smart contracts than they do in general-purpose software. Nevertheless, as you will see, the most widely used language for smart contracts (Solidity) is imperative. Programmers, like most humans, resist change!\n\nCurrently supported high-level programming languages for smart contracts include (ordered by approximate age):\n\nLLL:: (((\"LLL\")))A functional (declarative) programming language, with Lisp-like syntax. It was the first high-level language for Ethereum smart contracts but is rarely used today.\n\nSerpent:: (((\"Serpent\")))A procedural (imperative) programming language with a syntax similar to Python. Can also be used to write functional (declarative) code, though it is not entirely free of side effects.\n\nSolidity:: (((\"Solidity\")))A procedural (imperative) programming language with a syntax similar to JavaScript, pass:[C++], or Java. The most popular and frequently used language for Ethereum smart contracts.\n\nVyper:: (((\"Vyper\")))A more recently developed language, similar to Serpent and again with Python-like syntax. Intended to get closer to a pure-functional Python-like language than Serpent, but not to replace Serpent.\n\nBamboo:: (((\"Bamboo\")))A newly developed language, influenced by Erlang, with explicit state transitions and without iterative flows (loops). Intended to reduce side effects and increase auditability. Very new and yet to be widely adopted.\n\nAs you can see, there are many languages to choose from. However, of all of these Solidity is by far the most popular, to the point of being the _de facto_ high-level language of Ethereum and even other EVM-like blockchains. We will spend most of our time using Solidity, but will also explore some of the examples in other high-level languages to gain an understanding of their different philosophies.(((range=\"endofrange\", startref=\"ix_07smart-contracts-solidity-asciidoc2\")))(((range=\"endofrange\", startref=\"ix_07smart-contracts-solidity-asciidoc1\")))\n\n[[building_a_smart_contract_sec]]", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Introduction to Ethereum High-Level Languages"}}
{"input": "Explain the Ethereum concept: Building a Smart Contract with Solidity", "output": "(((\"smart contracts\",\"building with Solidity\", id=\"ix_07smart-contracts-solidity-asciidoc3\", range=\"startofrange\")))(((\"Solidity\",\"building a smart contract with\", id=\"ix_07smart-contracts-solidity-asciidoc4\", range=\"startofrange\")))Solidity (((\"smart contracts\",\"Solidity and\", id=\"ix_07smart-contracts-solidity-asciidoc5\", range=\"startofrange\")))(((\"Solidity\",\"smart contracts and\", id=\"ix_07smart-contracts-solidity-asciidoc6\", range=\"startofrange\")))was created by (((\"Wood, Dr. Gavin\",\"and Solidity\")))Dr. Gavin Wood (coauthor of this book) as a language explicitly for writing smart contracts with features to directly support execution in the decentralized environment of the Ethereum world computer. The resulting attributes are quite general, and so it has ended up being used for coding smart contracts on several other blockchain platforms. It was developed by Christian Reitiwessner and then also by Alex Beregszaszi, Liana Husikyan, Yoichi Hirai, and several former Ethereum core contributors. Solidity is now developed and maintained as an independent project https://github.com/ethereum/solidity[on GitHub].\n\nThe main \"product\" of the Solidity project is the Solidity compiler, +solc+, which converts programs written in the Solidity language to EVM bytecode. The project also manages the important application binary interface (ABI) standard for Ethereum smart contracts, which we will explore in detail in this chapter. Each version of the Solidity compiler corresponds to and compiles a specific version of the Solidity pass:[<span class=\"keep-together\">language</span>].\n\nTo get started, we will download a binary executable of the Solidity compiler. Then we will develop and compile a simple contract, following on from the example we started with in <<intro_chapter>>.", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Building a Smart Contract with Solidity"}}
{"input": "Explain the Ethereum concept: Selecting a Version of Solidity", "output": "(((\"semantic versioning\")))(((\"Solidity\",\"selecting version of\")))Solidity follows a versioning model called https://semver.org/[_semantic versioning_], which specifies version numbers structured as three numbers separated by dots: __++MAJOR.MINOR.PATCH++__. The \"major\" number is incremented for major and _backward-incompatible_ changes, the \"minor\" number is incremented as backward-compatible features are added in between major releases, and the \"patch\" number is incremented for backward-compatible bug fixes.\n\nAt the time of writing, Solidity is at version 0.6.4.  The rules for major version 0, which is for initial development of a project, are different: anything may change at any time. In practice, Solidity treats the \"minor\" number as if it were the major version and the \"patch\" number as if it were the minor version. Therefore, in 0.6.4, 6 is considered to be the major version and 4 the minor version.\n\nThe 0.5 major version release of Solidity is anticipated imminently.\n\nAs you saw in <<intro_chapter>>, your Solidity programs can contain a pragma directive that specifies the minimum and maximum versions of Solidity that it is compatible with, and can be used to compile your contract.\n\nSince Solidity is rapidly evolving, it is often better to install the latest release.", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Selecting a Version of Solidity"}}
{"input": "Explain the Ethereum concept: Download and Install", "output": "(((\"Solidity\",\"downloading/installing\")))There are a number of methods you can use to download and install Solidity, either as a binary release or by compiling from source code. You can find detailed instructions in http://bit.ly/2RrZmup[the Solidity documentation].\n\nHere's how to install the latest binary release of Solidity on an Ubuntu/Debian operating system, using the +apt+ package manager:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>sudo add-apt-repository ppa:ethereum/ethereum</strong>\n$ <strong>sudo apt update</strong>\n$ <strong>sudo apt install solc</strong>\n</pre>\n++++\n\nOnce you have +solc+ installed, check the version by running:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>solc --version</strong>\nsolc, the solidity compiler commandline interface\nVersion: 0.6.4+commit.1dca32f3.Linux.g++\n</pre>\n++++\n\nThere are a number of other ways to install Solidity, depending on your operating system and requirements, including compiling from the source code directly. For more information see https://github.com/ethereum/solidity[].", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Download and Install"}}
{"input": "Explain the Ethereum concept: Development Environment", "output": "(((\"Solidity\",\"development environment\")))To develop in Solidity, you can use any text editor and +solc+ on the command line. However, you might find that some text editors designed for development, such as Emacs, Vim, and Atom, offer additional features such as syntax highlighting and macros that make Solidity development easier.\n\nThere are also web-based development environments, such as https://remix.ethereum.org/[Remix IDE] and https://ethfiddle.com/[EthFiddle].\n\nUse the tools that make you productive. In the end, Solidity programs are just plain text files. While fancy editors and development environments can make things easier, you don't need anything more than a simple text editor, such as nano (Linux/Unix), TextEdit (macOS), or even NotePad (Windows). Simply save your program source code with a _.sol_ extension and it will be recognized by the Solidity compiler as a Solidity program.", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Development Environment"}}
{"input": "Explain the Ethereum concept: Writing a Simple Solidity Program", "output": "(((\"Solidity\",\"writing a simple program in\")))In <<intro_chapter>>, we wrote our first Solidity program.  When we first built the +Faucet+ contract, we used the Remix IDE to compile and deploy the contract. In this section, we will revisit, improve, and embellish +Faucet+.\n\nOur first attempt looked like <<original_sol_faucet>>.\n\n[[original_sol_faucet]]\n.Faucet.sol: A Solidity contract implementing a faucet", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Writing a Simple Solidity Program"}}
{"input": "Explain the Ethereum concept: Compiling with the Solidity Compiler (solc)", "output": "(((\"Faucet.sol contract (test example)\",\"compiling\")))(((\"solc (Solidity compiler)\")))(((\"Solidity compiler (solc)\")))Now, we will use the Solidity compiler on the command line to compile our contract directly. The Solidity compiler +solc+ offers a variety of options, which you can see by passing the +--help+ argument.\n\nWe use the +--bin+ and +--optimize+ arguments of +solc+ to produce an optimized binary of our example contract:\n\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>solc --optimize --bin Faucet.sol</strong>", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Compiling with the Solidity Compiler (solc)"}}
{"input": "Explain the Ethereum concept: Faucet.sol:Faucet", "output": "Binary:\n608060405234801561001057600080fd5b5060cc8061001f6000396000f3fe6080604052600436106\n01f5760003560e01c80632e1a7d4d14602a576025565b36602557005b600080fd5b34801560355760\n0080fd5b50605060048036036020811015604a57600080fd5b50356052565b005b67016345785d8a0\n000811115606657600080fd5b604051339082156108fc029083906000818181858888f19350505050\n1580156092573d6000803e3d6000fd5b505056fea26469706673582212205cf23994b22f7ba19eee5\n6c77b5fb127bceec1276b6f76ca71b5f95330ce598564736f6c63430006040033\n</pre>\n++++\n\n\nThe result that +solc+ produces is a hex-serialized binary that can be submitted to the Ethereum blockchain.(((range=\"endofrange\", startref=\"ix_07smart-contracts-solidity-asciidoc6\")))(((range=\"endofrange\", startref=\"ix_07smart-contracts-solidity-asciidoc5\")))\n\n[[eth_contract_abi_sec]]", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Faucet.sol:Faucet"}}
{"input": "Explain the Ethereum concept: The Ethereum Contract ABI", "output": "(((\"ABI (application binary interface)\", id=\"ix_07smart-contracts-solidity-asciidoc7\", range=\"startofrange\")))(((\"application binary interface (ABI)\", id=\"ix_07smart-contracts-solidity-asciidoc8\", range=\"startofrange\")))(((\"smart contracts\",\"ABI\", id=\"ix_07smart-contracts-solidity-asciidoc9\", range=\"startofrange\")))In computer software, an _application binary interface_ is an interface between two program modules; often, between the operating system and user programs. An ABI defines how data structures and functions are accessed in _machine code_; this is not to be confused with an API, which defines this access in high-level, often human-readable formats as _source code_. The ABI is thus the primary way of encoding and decoding data into and out of machine code.\n\nIn Ethereum, the ABI is used to encode contract calls for the EVM and to read data out of transactions. The purpose of an ABI is to define the functions in the contract that can be invoked and describe how each function will accept arguments and return its result.\n\nA contract's ABI is specified as a JSON array of function descriptions (see <<solidity_functions>>) and events (see <<solidity_events>>). A function description is a JSON object with fields `type`, `name`, `inputs`, `outputs`, `constant`, and `payable`. An event description object has fields `type`, `name`, `inputs`, and `anonymous`.\n\nWe use the +solc+ command-line Solidity compiler to produce the ABI for our pass:[<span class=\"keep-together\"><em>Faucet.sol</em></span>] example contract:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>solc --abi Faucet.sol</strong>", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "The Ethereum Contract ABI"}}
{"input": "Explain the Ethereum concept: Faucet.sol:Faucet", "output": "Contract JSON ABI\n[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"withdraw_amount\",\"type\":\"uint256\"}], \\\n\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}, \\\n{\"stateMutability\":\"payable\",\"type\":\"receive\"}]\n</pre>\n++++\n\nAs you can see, the compiler produces a JSON array describing the two functions that are defined by _Faucet.sol_. This JSON can be used by any application that wants to access the +Faucet+ contract once it is deployed. Using the ABI, an application such as a wallet or DApp browser can construct transactions that call the functions in +Faucet+ with the correct arguments and argument types. For example, a wallet would know that to call the function +withdraw+ it would have to provide a +uint256+ argument named +withdraw_amount+. The wallet could prompt the user to provide that value, then create a transaction that encodes it and executes the +withdraw+ function.\n\nAll that is needed for an application to interact with a contract is an ABI and the address where the contract has been deployed.\n\n[[solidity_pragma]]", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Faucet.sol:Faucet"}}
{"input": "Explain the Ethereum concept: Selecting a Solidity Compiler and Language Version", "output": "(((\"Solidity\",\"selecting compiler and language version\")))As we saw in the previous code, our +Faucet+ contract compiles successfully with Solidity version 0.6.4. But what if we had used a different version of the Solidity compiler? The language is still in constant flux and things may change in unexpected ways. Our contract is fairly simple, but what if our program used a feature that was only added in Solidity version 0.6.1 and we tried to compile it with 0.6.0?\n\n(((\"compiler directive\")))(((\"version pragma\")))To resolve such issues, Solidity offers a _compiler directive_ known as a _version pragma_ that instructs the compiler that the program expects a specific compiler (and language) version. Let\u2019s look at an example:\n\n[[compiler_version]]\n----\npragma solidity ^0.6.0;\n----\n\nThe Solidity compiler reads the version pragma and will produce an error if the compiler version is incompatible with the version pragma. In this case, our version pragma says that this program can be compiled by a Solidity compiler with a minimum version of 0.6.0. The symbol +^+ states, however, that we allow compilation with any _minor revision_ above 0.6.0; e.g., 0.6.1, but not 0.7.0 (which is a major revision, not a minor revision). Pragma directives are not compiled into EVM bytecode. They are only used by the compiler to check compatibility.\n\nLet\u2019s add a pragma directive to our +Faucet+ contract. We will name the new file pass:[<span class=\"keep-together\"><em>Faucet2.sol</em></span>], to keep track of our changes as we proceed through these examples starting in <<add_pragma_to_faucet>>.\n\n[[add_pragma_to_faucet]]\n.Faucet2.sol: Adding the version pragma to Faucet", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Selecting a Solidity Compiler and Language Version"}}
{"input": "Explain the Ethereum concept: Programming with Solidity", "output": "(((\"Solidity\",\"programming with\", id=\"ix_07smart-contracts-solidity-asciidoc10\", range=\"startofrange\")))In this section, we will look at some of the capabilities of the Solidity language. As we mentioned in <<intro_chapter>>, our first contract example was very simple and also flawed in various ways. We'll gradually improve it here, while exploring how to use Solidity. This won't be a comprehensive Solidity tutorial, however, as Solidity is quite complex and rapidly evolving. We'll cover the basics and give you enough of a foundation to be able to explore the rest on your own. The documentation for Solidity can be found\nhttps://solidity.readthedocs.io/en/latest/[on the project website].", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Programming with Solidity"}}
{"input": "Explain the Ethereum concept: Data Types", "output": "(((\"Solidity\",\"data types\", id=\"ix_07smart-contracts-solidity-asciidoc11\", range=\"startofrange\")))First, let's look at some of the basic data types offered in Solidity:\n\nBoolean (+bool+):: Boolean value, +true+ or +false+, with logical operators +!+ (not), +&&+ (and), +||+ (or), +==+ (equal), and +!=+ (not equal).\n\nInteger (+int+, +uint+):: Signed (+int+) and unsigned (+uint+) integers, declared in increments of 8 bits from +int8+ to +uint256+. Without a size suffix, 256-bit quantities are used, to match the word size of the EVM.\n\nFixed point (+fixed+, +ufixed+):: Fixed-point numbers, declared with pass:[(<code>u</code>)<code>fixed<em>M</em>x<em>N</em></code>] where __++M++__ is the size in bits (increments of 8 up to 256) and __++N++__ is the number of decimals after the point (up to 18); e.g., +ufixed32x2+.\n\nAddress:: A 20-byte Ethereum address. The +address+ object has many helpful member functions, the main ones being +balance+ (returns the account balance) and pass:[<span class=\"keep-together\"><code>transfer</code></span>] (transfers ether to the account).\n\nByte array (fixed):: Fixed-size arrays of bytes, declared with +bytes1+ up to +bytes32+.\n\nByte array (dynamic):: Variable-sized arrays of bytes, declared with +bytes+ or +string+.\n\nEnum:: User-defined type for enumerating discrete values: +enum NAME {LABEL1, LABEL 2, pass:[...]}+.\n\nArrays:: An array of any type, either fixed or dynamic: +uint32[][5]+ is a fixed-size array of five dynamic arrays of unsigned integers.\n\nStruct:: User-defined data containers for grouping variables: pass:[<code>struct NAME {TYPE1 <span class=\"keep-together\">VARIABLE1</span>; TYPE2 VARIABLE2; ...}</code>].\n\nMapping:: Hash lookup tables for __++key++__ +=>+ _++value++_ pairs: +mapping(KEY_TYPE => VALUE_TYPE) NAME+.\n\nIn addition to these data types, Solidity also offers a variety of value literals that can be used to calculate different units:\n\nTime units:: The units +seconds+, +minutes+, +hours+, and +days+ can be used as suffixes, converting to multiples of the base unit +seconds+.\n\nEther units:: The units +wei+, +finney+, +szabo+, and +ether+ can be used as suffixes, converting to multiples of the base unit +wei+.\n\nIn our +Faucet+ contract example, we used a +uint+ (which is an alias for +uint256+) for the +withdraw_amount+ variable. We also indirectly used an +address+ variable, which we set with +msg.sender+. We will use more of these data types in our examples in the rest of this chapter.\n\nLet's use one of the unit multipliers to improve the readability of our example contract. In the +withdraw+ function we limit the maximum withdrawal, expressing the limit in wei, the base unit of ether:\n\n----\nrequire(withdraw_amount <= 100000000000000000);\n----\n\nThat's not very easy to read. We can improve our code by using the unit multiplier +ether+, to express the value in ether instead of wei:(((range=\"endofrange\", startref=\"ix_07smart-contracts-solidity-asciidoc11\")))\n\n----\nrequire(withdraw_amount <= 0.1 ether);\n----", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Data Types"}}
{"input": "Explain the Ethereum concept: Predefined Global Variables and Functions", "output": "(((\"Solidity\",\"predefined global variables/functions\", id=\"ix_07smart-contracts-solidity-asciidoc12\", range=\"startofrange\")))When a contract is executed in the EVM, it has access to a small set of global objects. These include the +block+, +msg+, and +tx+ objects. In addition, Solidity exposes a number of EVM opcodes as predefined functions. In this section we will examine the variables and functions you can access from within a smart contract in Solidity.", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Predefined Global Variables and Functions"}}
{"input": "Explain the Ethereum concept: Transaction/message call context", "output": "(((\"message call\")))(((\"msg object\")))(((\"transaction call\")))The +msg+ object is the transaction call (EOA originated) or message call (contract originated) that launched this contract execution. It contains a number of useful attributes:\n\n+msg.sender+:: We've already used this one. It represents the address that initiated this contract call, not necessarily the originating EOA that sent the transaction. If our contract was called directly by an EOA transaction, then this is the address that signed the transaction, but otherwise it will be a contract address.\n\n+msg.value+:: The value of ether sent with this call (in wei).\n\n+msg.gas+:: The amount of gas left in the gas supply of this execution environment. This was deprecated in Solidity v0.4.21 and replaced by the +gasleft+ function.\n\n+msg.data+:: The data payload of this call into our contract.\n\n+msg.sig+:: The first four bytes of the data payload, which is the function selector.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Transaction/message call context"}}
{"input": "Explain the Ethereum concept: Transaction context", "output": "(((\"tx object\")))The +tx+ object provides a means of accessing transaction-related information:\n\n++tx.gasprice++:: The gas price in the calling transaction.\n\n++tx.origin++:: The address of the originating EOA for this transaction. WARNING: unsafe!", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Transaction context"}}
{"input": "Explain the Ethereum concept: Block context", "output": "(((\"block object\")))The +block+ object contains information about the current block:\n\n++block.blockhash(__blockNumber__)++:: The block hash of the specified block number, up to 256 blocks in the past. Deprecated and replaced with the +blockhash+ function in Solidity v0.4.22.\n\n++block.coinbase++:: The address of the recipient of the current block's fees and block reward.\n\n++block.difficulty++:: The difficulty (proof of work) of the current block.\n\n++block.gaslimit++:: The maximum amount of gas that can be spent across all transactions included in the current block.\n\n++block.number++:: The current block number (blockchain height).\n\n++block.timestamp++:: The timestamp placed in the current block by the miner (number of seconds since the Unix epoch).\n\n[[solidity_address_object]]", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Block context"}}
{"input": "Explain the Ethereum concept: address object", "output": "(((\"address object\")))Any address, either passed as an input or cast from a contract object, has a number of attributes and methods:\n\n+address.balance+:: The balance of the address, in wei. For example, the current contract balance is +address(this).balance+.\n\n++address.transfer(__amount__)++:: Transfers the amount (in wei) to this address, throwing an exception on any error. We used this function in our +Faucet+ example as a method on the +msg.sender+ address, as +msg.sender.transfer+.\n\n++address.send(__amount__)++:: Similar to +transfer+, only instead of throwing an exception, it returns +false+ on error. WARNING: always check the return value of +send+.\n\n++address.call(__payload__)++:: Low-level +CALL+ function&#x2014;can construct an arbitrary message call with a data payload. Returns +false+ on error. WARNING: unsafe&#x2014;recipient can (accidentally or maliciously) use up all your gas, causing your contract to halt with an +OOG+ exception; always check the return value of +call+.\n\n+address.delegatecall(__payload__)+:: Low-level +DELEGATECALL+ function, like +callcode(pass:[...])+ but with the full +msg+ context seen by the current contract. Returns +false+ on error. WARNING: advanced use only!", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "address object"}}
{"input": "Explain the Ethereum concept: Built-in functions", "output": "Other functions worth noting are:\n\n+addmod+, +mulmod+:: For modulo addition and multiplication. For example, +addmod(x,y,k)+ calculates +pass:[(x + y) % k]+.\n\n+keccak256+, +sha256+, +sha3+, +ripemd160+:: Functions to calculate hashes with various standard hash algorithms.\n\n+ecrecover+:: Recovers the address used to sign a message from the signature.\n\n++selfdestruct(__recipient_address__)++:: Deletes the current contract, sending any remaining ether in the account to the recipient address.\n\n+this+:: The address of the currently executing contract account.(((range=\"endofrange\", startref=\"ix_07smart-contracts-solidity-asciidoc12\")))", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Built-in functions"}}
{"input": "Explain the Ethereum concept: Contract Definition", "output": "(((\"contract data type\")))(((\"contract definition, Solidity\")))(((\"Solidity\",\"contract definition\")))Solidity's principal data type is +contract+; our +Faucet+ example simply defines a pass:[<span class=\"keep-together\"><code>contract</code></span>] object. Similar to any object in an object-oriented language, the contract is a container that includes data and methods.\n\nSolidity offers two other object types that are similar to a contract:\n\n+interface+:: (((\"interface object type\")))(((\"stub\")))An interface definition is structured exactly like a contract, except none of the functions are defined, they are only declared. This type of declaration is often called a _stub_; it tells you the functions' arguments and return types without any implementation. An interface specifies the \"shape\" of a contract; when inherited, each of the functions declared by the interface must be defined by the child.\n\n+library+:: (((\"library contract\")))A library contract is one that is meant to be deployed only once and used by other contracts, using the +delegatecall+ method (see <<solidity_address_object>>).\n\n[[solidity_functions]]", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Contract Definition"}}
{"input": "Explain the Ethereum concept: Functions", "output": "(((\"Solidity\",\"functions\", id=\"ix_07smart-contracts-solidity-asciidoc13\", range=\"startofrange\")))Within a contract, we define functions that can be called by an EOA transaction or another contract. In our +Faucet+ example, we have two functions: +withdraw+ and the (unnamed) _fallback_ function.\n\n(((\"Solidity\",\"function syntax\")))The syntax we use to declare a function in Solidity is as follows:\n\n++++\n<pre data-type=\"programlisting\">\nfunction FunctionName([<em>parameters</em>]) {public|private|internal|external}\n[pure|view|payable] [<em>modifiers</em>] [returns (<em>return types</em>)]\n</pre>\n++++\n\n\nLet's look at each of these components:\n\n++FunctionName++:: The name of the function, which is used to call the function in a transaction (from an EOA), from another contract, or even from within the same contract. (((\"fallback function\")))One function in each contract may be defined as a fallback function using the \"fallback\" keyword or a receive ether function defined using the \"receive\" keyword. If present, the receive ether function is called whenever the call data is empty (whether or not ether is received). Otherwise, the fallback function is called when no other function is named. The fallback function cannot have any arguments or return anything.\n\n__++parameters++__:: Following the name, we specify the arguments that must be passed to the function, with their names and types. In our +Faucet+ example we defined +uint withdraw_amount+ as the only argument to the pass:[<code><span class=\"keep-together\">withdraw</span></code>] function.\n\nThe next set of keywords (+public+, +private+, +internal+, +external+) specify the function's _visibility_:\n\n+public+:: (((\"public function\")))Public is the default; such functions can be called by other contracts or EOA transactions, or from within the contract. In our +Faucet+ example, both functions are defined as public.\n\n+external+:: (((\"external function\")))External functions are like public functions, except they cannot be called from within the contract unless explicitly prefixed with the keyword +this+.\n\n+internal+:: (((\"internal function\")))Internal functions are only accessible from within the contract&#x2014;they cannot be called by another contract or EOA transaction. They can be called by derived contracts (those that inherit this one).\n\n+private+:: (((\"private function\")))Private functions are like internal functions but cannot be called by derived pass:[<span class=\"keep-together\">contracts</span>].\n\nKeep in mind that the terms _internal_ and _private_ are somewhat misleading. Any function or data inside a contract is always _visible_ on the public blockchain, meaning that anyone can see the code or data. The keywords described here only affect how and when a function can be _called_.\n\nThe second set of keywords (+pure+, +constant+, +view+, +payable+) affect the behavior of the function:\n\n+constant+ or +view+:: (((\"view (function keyword)\")))A function marked as a _view_ promises not to modify any state. (((\"constant (function keyword)\")))The term _constant_ is an alias for view that will be deprecated in a future release. At this time, the compiler does not enforce the +view+ modifier, only producing a warning, but this is expected to become an enforced keyword in v0.5 of Solidity.\n\n+pure+:: (((\"pure function\")))A pure function is one that neither reads nor writes any variables in storage. It can only operate on arguments and return data, without reference to any stored data. Pure functions are intended to encourage declarative-style programming without side effects or state.\n\n+payable+:: (((\"payable function\")))A payable function is one that can accept incoming payments. Functions not declared as +payable+ will reject incoming payments. There are two exceptions, due to design decisions in the EVM: coinbase payments and +SELFDESTRUCT+ inheritance will be paid even if the fallback function is not declared as +payable+, but this makes sense because code execution is not part of those payments pass:[<span class=\"keep-together\">anyway</span>].\n\nAs you can see in our +Faucet+ example, we have one payable function (the fallback function), which is the only function that can receive incoming payments.(((range=\"endofrange\", startref=\"ix_07smart-contracts-solidity-asciidoc13\")))", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Functions"}}
{"input": "Explain the Ethereum concept: Contract Constructor and selfdestruct", "output": "(((\"constructor function\")))(((\"smart contracts\",\"constructor function\")))(((\"Solidity\",\"contract constructor function\")))There is a special function that is only used once. When a contract is created, it also runs the _constructor function_ if one exists, to initialize the state of the contract. The constructor is run in the same transaction as the contract creation. The constructor function is optional; you'll notice our +Faucet+ example doesn't have one.\n\nConstructors can be specified in two ways. Up to and including in Solidity v0.4.21, the constructor is a function whose name matches the name of the contract, as you can see here:\n\n[source,solidity]\n----\ncontract MEContract {\n    function MEContract() {\n        // This is the constructor\n    }\n}\n----\n\n\nThe difficulty with this format is that if the contract name is changed and the constructor function name is not changed, it is no longer a constructor. Likewise, if there is an accidental typo in the naming of the contract and/or constructor, the function is again no longer a constructor. This can cause some pretty nasty, unexpected, and difficult-to-find bugs. Imagine for example if the constructor is setting the owner of the contract for purposes of control. If the function is not actually the constructor because of a naming error, not only will the owner be left unset at the time of contract creation, but the function may also be deployed as a permanent and \"callable\" part of the contract, like a normal function, allowing any third party to hijack the contract and become the \"owner\" after contract creation.\n\nTo address the potential problems with constructor functions being based on having an identical name as the contract, Solidity v0.4.22 introduces a +constructor+ keyword that operates like a constructor function but does not have a name. Renaming the contract does not affect the constructor at all. Also, it is easier to identify which function is the constructor. It looks like this:\n\n[source,solidity]\n----\npragma ^0.4.22\ncontract MEContract {\n    constructor () {\n        // This is the constructor\n    }\n}\n----\n\nTo summarize, a contract's life cycle starts with a creation transaction from an EOA or contract account. If there is a constructor, it is executed as part of contract creation, to initialize the state of the contract as it is being created, and is then discarded.\n\n(((\"contract destruction\")))(((\"selfdestruct function\")))(((\"Solidity\",\"contract destruction\")))(((\"Solidity\",\"selfdestruct function\")))The other end of the contract's life cycle is _contract destruction_. (((\"SELFDESTRUCT opcode\")))Contracts are destroyed by a special EVM opcode called +SELFDESTRUCT+. It used to be called pass:[<span class=\"keep-together\"><code>SUICIDE</code></span>], but that name was deprecated due to the negative associations of the word. In Solidity, this opcode is exposed as a high-level built-in function called +selfdestruct+, which takes one argument: the address to receive any ether balance remaining in the contract account. It looks like this:\n\n[source,solidity]\n----\nselfdestruct(address recipient);\n----\n\nNote that you must explicitly add this command to your contract if you want it to be deletable&#x2014;this is the only way a contract can be deleted, and it is not present by default. In this way, users of a contract who might rely on a contract being there forever can be certain that a contract can't be deleted if it doesn't contain a pass:[<span class=\"keep-together\"><code>SELFDESTRUCT</code></span>] opcode.", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Contract Constructor and selfdestruct"}}
{"input": "Explain the Ethereum concept: Adding a Constructor and selfdestruct to Our Faucet Example", "output": "(((\"constructor function\",\"adding to faucet example\")))(((\"Faucet.sol contract (test example)\",\"adding constructor and selfdestruct to\")))(((\"Solidity\",\"adding constructor/selfdestruct to faucet example\")))The +Faucet+ example contract we introduced in <<intro_chapter>> does not have any constructor or +selfdestruct+ functions. It is an eternal contract that cannot be deleted. Let's change that, by adding a constructor and +selfdestruct+ function. We probably want +selfdestruct+ to be callable _only_ by the EOA that originally created the contract. By convention, this is usually stored in an address variable called +owner+. Our constructor sets the +owner+ variable, and the +selfdestruct+ function will first check that the owner called it directly.\n\nFirst, our constructor:\n\n[source,solidity]\n----\n// Version of Solidity compiler this program was written for\npragma solidity ^0.6.0;\n\n// Our first contract is a faucet!\ncontract Faucet {\n\n    address owner;\n\n    // Initialize Faucet contract: set owner\n    constructor() {\n        owner = msg.sender;\n    }\n\n    [...]\n}\n----\n\nOur contract now has an +address+ type variable named +owner+. The name \"owner\" is not special in any way. We could call this address variable \"potato\" and still use it the same way. The name +owner+ simply makes its purpose clear.\n\nNext, our constructor, which runs as part of the contract creation transaction, assigns the address from +msg.sender+ to the +owner+ variable. We used +msg.sender+ in the pass:[<span class=\"keep-together\"><code>withdraw</code></span>] function to identify the initiator of the withdrawal request. In the constructor, however, the +msg.sender+ is the EOA or contract address that initiated contract creation. We know this is the case _because_ this is a constructor function: it only runs once, during contract creation.\n\nNow we can add a function to destroy the contract. We need to make sure that only the owner can run this function, so we will use a +require+ statement to control access. Here's how it will look:\n\n[source,solidity]\n----\n// Contract destructor\nfunction destroy() public {\n    require(msg.sender == owner);\n    selfdestruct(owner);\n}\n----\n\nIf anyone calls this +destroy+ function from an address other than +owner+, it will fail. But if the same address stored in +owner+ by the constructor calls it, the contract will self-destruct and send any remaining balance to the +owner+ address. Note that we did not use the unsafe +tx.origin+ to determine whether the owner wished to destroy the contract&#x2014;using +tx.origin+ would allow malign contracts to destroy your contract without your permission.", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Adding a Constructor and selfdestruct to Our Faucet Example"}}
{"input": "Explain the Ethereum concept: Function Modifiers", "output": "(((\"function modifiers\")))(((\"Solidity\",\"function modifiers\")))Solidity offers a special type of function called a _function modifier_. You apply modifiers to functions by adding the modifier name in the function declaration. Modifiers are most often used to create conditions that apply to many functions within a contract. We have an access control statement already, in our +destroy+ function. Let's create a function modifier that expresses that condition:\n\n[source,solidity]\n----\nmodifier onlyOwner {\n    require(msg.sender == owner);\n    _;\n}\n----\n\n\nThis function modifier, named +onlyOwner+, sets a condition on any function that it modifies, requiring that the address stored as the +owner+ of the contract is the same as the address of the transaction's +msg.sender+. This is the basic design pattern for access control, allowing only the owner of a contract to execute any function that has the +onlyOwner+ modifier.\n\nYou may have noticed that our function modifier has a peculiar syntactic \"placeholder\" in it, an underscore followed by a semicolon (+&#95;;+). This placeholder is replaced by the code of the function that is being modified. Essentially, the modifier is \"wrapped around\" the modified function, placing its code in the location identified by the underscore character.\n\nTo apply a modifier, you add its name to the function declaration. More than one modifier can be applied to a function; they are applied in the sequence they are declared, as a space-separated list.\n\nLet's rewrite our +destroy+ function to use the +onlyOwner+ modifier:\n\n[source,solidity]\n----\nfunction destroy() public onlyOwner {\n    selfdestruct(owner);\n}\n----\n\nThe function modifier's name (+onlyOwner+) is after the keyword +public+ and tells us that the +destroy+ function is modified by the +onlyOwner+ modifier. Essentially, you can read this as \"Only the owner can destroy this contract.\" In practice, the resulting code is equivalent to \"wrapping\" the code from +onlyOwner+ around +destroy+.\n\nFunction modifiers are an extremely useful tool because they allow us to write preconditions for functions and apply them consistently, making the code easier to read and, as a result, easier to audit for security. They are most often used for access control, but they are quite versatile and can be used for a variety of other purposes.\n\nInside a modifier, you can access all the values (variables and arguments) visible to the modified function. In this case, we can access the +owner+ variable, which is declared within the contract. However, the inverse is not true: you cannot access any of the modifier's variables inside the modified function.", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Function Modifiers"}}
{"input": "Explain the Ethereum concept: Contract Inheritance", "output": "(((\"contract object\", id=\"ix_07smart-contracts-solidity-asciidoc14\", range=\"startofrange\")))(((\"inheritance\", id=\"ix_07smart-contracts-solidity-asciidoc15\", range=\"startofrange\")))(((\"smart contracts\",\"inheritance\", id=\"ix_07smart-contracts-solidity-asciidoc16\", range=\"startofrange\")))(((\"Solidity\",\"contract inheritance\", id=\"ix_07smart-contracts-solidity-asciidoc17\", range=\"startofrange\")))Solidity's +contract+ object supports _inheritance_, which is a mechanism for extending a base contract with additional functionality. To use inheritance, specify a parent contract with the keyword +is+:\n\n[source,solidity]\n----\ncontract Child is Parent {\n    ...\n}\n----\n\nWith this construct, the +Child+ contract inherits all the methods, functionality, and variables of +Parent+. Solidity also supports multiple inheritance, which can be specified by comma-separated contract names after the keyword +is+:\n\n[source,solidity]\n----\ncontract Child is Parent1, Parent2 {\n    ...\n}\n----\n\nContract inheritance allows us to write our contracts in such a way as to achieve modularity, extensibility, and reuse. We start with contracts that are simple and implement the most generic capabilities, then extend them by inheriting those capabilities in more specialized contracts.\n\nIn our +Faucet+ contract, we introduced the constructor and destructor, together with access control for an owner, assigned on construction. Those capabilities are quite generic: many contracts will have them. We can define them as generic contracts, then use inheritance to extend them to the +Faucet+ contract.\n\nWe start by defining a base contract +Owned+, which has an +owner+ variable, setting it in the contract's constructor:\n\n[source,solidity]\n----\ncontract Owned {\n\taddress owner;\n\n\t// Contract constructor: set owner\n\tconstructor() {\n\t\towner = msg.sender;\n\t}\n\n\t// Access control modifier\n\tmodifier onlyOwner {\n\t    require(msg.sender == owner);\n\t    _;\n\t}\n}\n----\n\nNext, we define a base contract +Mortal+, which inherits +Owned+:\n\n[source,solidity]\n----\ncontract Mortal is Owned {\n\t// Contract destructor\n\tfunction destroy() public onlyOwner {\n\t\tselfdestruct(owner);\n\t}\n}\n----\n\nAs you can see, the +Mortal+ contract can use the +onlyOwner+ function modifier, defined in +Owned+. It indirectly also uses the +owner+ address variable and the constructor defined in +Owned+. Inheritance makes each contract simpler and focused on its specific functionality, allowing us to manage the details in a modular way.\n\nNow we can further extend the +Owned+ contract, inheriting its capabilities in +Faucet+:\n\n[source,solidity]\n----\ncontract Faucet is Mortal {\n    // Give out ether to anyone who asks\n    function withdraw(uint withdraw_amount) public {\n        // Limit withdrawal amount\n        require(withdraw_amount <= 0.1 ether);\n        // Send the amount to the address that requested it\n        msg.sender.transfer(withdraw_amount);\n    }\n    // Accept any incoming amount\n    receive () external payable {}\n}\n----\n\nBy inheriting +Mortal+, which in turn inherits +Owned+, the +Faucet+ contract now has the constructor and +destroy+ functions, and a defined owner. The functionality is the same as when those functions were within +Faucet+, but now we can reuse those functions in other contracts without writing them again. Code reuse and modularity make our code cleaner, easier to read, and easier to audit.(((range=\"endofrange\", startref=\"ix_07smart-contracts-solidity-asciidoc17\")))(((range=\"endofrange\", startref=\"ix_07smart-contracts-solidity-asciidoc16\")))(((range=\"endofrange\", startref=\"ix_07smart-contracts-solidity-asciidoc15\")))(((range=\"endofrange\", startref=\"ix_07smart-contracts-solidity-asciidoc14\")))", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Contract Inheritance"}}
{"input": "Explain the Ethereum concept: Error Handling (assert, require, revert)", "output": "(((\"error handling, Solidity\")))(((\"Solidity\",\"error handling\")))A contract call can terminate and return an error. Error handling in Solidity is handled by four functions: +assert+, +require+, +revert+, and +throw+ (now deprecated).\n\nWhen a contract terminates with an error, all the state changes (changes to variables, balances, etc.) are reverted, all the way up the chain of contract calls if more than one contract was called. This ensures that transactions are _atomic_, meaning they either complete successfully or have no effect on state and are reverted entirely.\n\n(((\"assert function\",\"Solidity and\")))(((\"require function\")))The +assert+ and +require+ functions operate in the same way, evaluating a condition and stopping execution with an error if the condition is false. By convention, +assert+ is used when the outcome is expected to be true, meaning that we use +assert+ to test internal conditions. By comparison, +require+ is used when testing inputs (such as function arguments or transaction fields), setting our expectations for those pass:[<span class=\"keep-together\">conditions</span>].\n\nWe've used +require+ in our function modifier +onlyOwner+, to test that the message sender is the owner of the contract:\n\n[source,solidity]\n----\nrequire(msg.sender == owner);\n----\n\nThe +require+ function acts as a _gate condition_, preventing execution of the rest of the function and producing an error if it is not satisfied.\n\nAs of Solidity v0.6.0, +require+ can also include a helpful text message that can be used to show the reason for the error. The error message is recorded in the transaction log. So, we can improve our code by adding an error message in our +require+ function:\n\n[source,solidity]\n----\nrequire(msg.sender == owner, \"Only the contract owner can call this function\");\n----\n\n(((\"revert function\")))(((\"throw function\")))The +revert+ and +throw+ functions halt the execution of the contract and revert any state changes. The +throw+ function is obsolete and will be removed in future versions of Solidity; you should use +revert+ instead. The +revert+ function can also take an error message as the only argument, which is recorded in the transaction log.\n\nCertain conditions in a contract will generate errors regardless of whether we explicitly check for them. For example, in our +Faucet+ contract, we don't check whether there is enough ether to satisfy a withdrawal request. That's because the +transfer+ function will fail with an error and revert the transaction if there is insufficient balance to make the transfer:\n\n[source,solidity]\n----\nmsg.sender.transfer(withdraw_amount);\n----\n\nHowever, it might be better to check explicitly and provide a clear error message on failure. We can do that by adding a +require+ statement before the transfer:\n\n[source,solidity]\n----\nrequire(this.balance >= withdraw_amount,\n        \"Insufficient balance in faucet for withdrawal request\");\nmsg.sender.transfer(withdraw_amount);\n----\n\nAdditional error-checking code like this will increase gas consumption slightly, but it offers better error reporting than if omitted. You will need to find the right balance between gas consumption and verbose error checking based on the expected use of your contract. In the case of a +Faucet+ contract intended for a testnet, we'd probably err on the side of extra reporting even if it costs more gas. Perhaps for a mainnet contract we'd choose to be frugal with our gas usage instead.\n\n[[solidity_events]]", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Error Handling (assert, require, revert)"}}
{"input": "Explain the Ethereum concept: Events", "output": "(((\"events\",\"Solidity\", id=\"ix_07smart-contracts-solidity-asciidoc18\", range=\"startofrange\")))(((\"Solidity\",\"event objects\", id=\"ix_07smart-contracts-solidity-asciidoc19\", range=\"startofrange\")))When (((\"transaction receipt\")))a transaction completes (successfully or not), it produces a _transaction receipt_, as we will see in <<evm_chapter>>. The transaction receipt contains _log_ entries that provide information about the actions that occurred during the execution of the transaction. _Events_ are the Solidity high-level objects that are used to construct these logs.\n\nEvents are especially useful for light clients and DApp services, which can \"watch\" for specific events and report them to the user interface, or make a change in the state of the application to reflect an event in an underlying contract.\n\nEvent objects take arguments that are serialized and recorded in the transaction logs, in the blockchain. You can supply the keyword +indexed+ before an argument, to make the value part of an indexed table (hash table) that can be searched or filtered by an application.\n\n(((\"Faucet.sol contract (test example)\",\"adding events to\", id=\"ix_07smart-contracts-solidity-asciidoc20\", range=\"startofrange\")))We have not added any events in our +Faucet+ example so far, so let's do that. We will add two events, one to log any withdrawals and one to log any deposits. We will call these events +Withdrawal+ and +Deposit+, respectively. First, we define the events in the +Faucet+ contract:\n\n[source,solidity]\n----\ncontract Faucet is Mortal {\n\tevent Withdrawal(address indexed to, uint amount);\n\tevent Deposit(address indexed from, uint amount);\n\n    [...]\n}\n----\n\nWe've chosen to make the addresses +indexed+, to allow searching and filtering in any user interface built to access our +Faucet+.\n\nNext, we use the +emit+ keyword to incorporate the event data in the transaction logs:\n\n[source,solidity]\n----\n// Give out ether to anyone who asks\nfunction withdraw(uint withdraw_amount) public {\n    [...]\n    msg.sender.transfer(withdraw_amount);\n    emit Withdrawal(msg.sender, withdraw_amount);\n}\n// Accept any incoming amount\nreceive () external payable {\n    emit Deposit(msg.sender, msg.value);\n}\n----\n\nThe resulting _Faucet.sol_ contract looks like <<Faucet8_sol>>.\n\n[[Faucet8_sol]]\n.Faucet8.sol: Revised Faucet contract, with events", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Events"}}
{"input": "Explain the Ethereum concept: Catching events", "output": "(((\"events\",\"catching\")))(((\"Faucet.sol contract (test example)\",\"catching events\")))OK, so we've set up our contract to emit events. How do we see the results of a transaction and \"catch\" the events? The web3.js library provides a data structure that contains a transaction's logs. Within those we can see the events generated by the transaction.\n\n(((\"Truffle\",\"running test transaction with\")))Let's use +truffle+ to run a test transaction on the revised +Faucet+ contract. Follow the instructions in <<truffle>> to set up a project directory and compile the pass:[<span class=\"keep-together\"><code>Faucet</code></span>] code. The source code can be found in https://github.com/ethereumbook/ethereumbook[the book's GitHub repository] under _code/truffle/FaucetEvents_.\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>truffle develop</strong>\ntruffle(develop)> <strong>compile</strong>\ntruffle(develop)> <strong>migrate</strong>\nUsing network 'develop'.\n\nRunning migration: 1_initial_migration.js\n  Deploying Migrations...\n  ... 0xb77ceae7c3f5afb7fbe3a6c5974d352aa844f53f955ee7d707ef6f3f8e6b4e61\n  Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0\nSaving successful migration to network...\n  ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956\nSaving artifacts...\nRunning migration: 2_deploy_contracts.js\n  Deploying Faucet...\n  ... 0xfa850d754314c3fb83f43ca1fa6ee20bc9652d891c00a2f63fd43ab5bfb0d781\n  Faucet: 0x345ca3e014aaf5dca488057592ee47305d9b3e10\nSaving successful migration to network...\n  ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0\nSaving artifacts...\n\ntruffle(develop)> <strong>Faucet.deployed().then(i => {FaucetDeployed = i})</strong>\ntruffle(develop)> <strong>FaucetDeployed.send(web3.utils.toWei(1, \"ether\")).then(res => \\\n                  { console.log(res.logs[0].event, res.logs[0].args) })</strong>\nDeposit { from: '0x627306090abab3a6e1400e9345bc60c78a8bef57',\n  amount: BigNumber { s: 1, e: 18, c: [ 10000 ] } }\ntruffle(develop)> <strong>FaucetDeployed.withdraw(web3.utils.toWei(0.1, \"ether\")).then(res => \\\n                  { console.log(res.logs[0].event, res.logs[0].args) })</strong>\nWithdrawal { to: '0x627306090abab3a6e1400e9345bc60c78a8bef57',\n  amount: BigNumber { s: 1, e: 17, c: [ 1000 ] } }\n</pre>\n++++\n\nAfter deploying the contract using the +deployed+ function, we execute two transactions. The first transaction is a deposit (using +send+), which emits a +Deposit+ event in the transaction logs:\n\n----\nDeposit { from: '0x627306090abab3a6e1400e9345bc60c78a8bef57',\n  amount: BigNumber { s: 1, e: 18, c: [ 10000 ] } }\n----\n\nNext, we use the +withdraw+ function to make a withdrawal. This emits a +Withdrawal+ event:\n\n----\nWithdrawal { to: '0x627306090abab3a6e1400e9345bc60c78a8bef57',\n  amount: BigNumber { s: 1, e: 17, c: [ 1000 ] } }\n----\n\nTo get these events, we looked at the +logs+ array returned as a result (+res+) of the transactions. The first log entry (+logs[0]+) contains an event name in +logs[0].event+ and the event arguments in +logs[0].args+. By showing these on the console, we can see the emitted event name and the event arguments.\n\nEvents are a very useful mechanism, not only for intra-contract communication, but also for debugging during development(((range=\"endofrange\", startref=\"ix_07smart-contracts-solidity-asciidoc20\"))).(((range=\"endofrange\", startref=\"ix_07smart-contracts-solidity-asciidoc19\")))(((range=\"endofrange\", startref=\"ix_07smart-contracts-solidity-asciidoc18\")))", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Catching events"}}
{"input": "Explain the Ethereum concept: Calling Other Contracts (send, call, callcode, delegatecall)", "output": "(((\"smart contracts\",\"calling other contracts from within a contract\", id=\"ix_07smart-contracts-solidity-asciidoc21\", range=\"startofrange\")))(((\"Solidity\",\"calling other contracts from within a contract\", id=\"ix_07smart-contracts-solidity-asciidoc22\", range=\"startofrange\")))Calling other contracts from within your contract is a very useful but potentially dangerous operation. We'll examine the various ways you can achieve this and evaluate the risks of each method. In short, the risks arise from the fact that you may not know much about a contract you are calling into or that is calling into your contract. When writing smart contracts, you must keep in mind that while you may mostly expect to be dealing with EOAs, there is nothing to stop arbitrarily complex and perhaps malign contracts from calling into and being called by your code.", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Calling Other Contracts (send, call, callcode, delegatecall)"}}
{"input": "Explain the Ethereum concept: Creating a new instance", "output": "(((\"smart contracts\",\"creating new instance\")))The safest way to call another contract is if you create that other contract yourself. That way, you are certain of its interfaces and behavior. To do this, you can simply instantiate it, using the keyword +new+, as in other object-oriented languages. In Solidity, the keyword +new+ will create the contract on the blockchain and return an object that you can use to reference it. Let's say you want to create and call a +Faucet+ contract from within another contract called +Token+:\n\n[role=\"pagebreak-before\"]\n[source,solidity]\n----\ncontract Token is Mortal {\n\tFaucet _faucet;\n\n    constructor() {\n        _faucet = new Faucet();\n    }\n}\n----\n\nThis mechanism for contract construction ensures that you know the exact type of the contract and its interface. The contract +Faucet+ must be defined within the scope of +Token+, which you can do with an +import+ statement if the definition is in another file:\n\n[source,solidity]\n----\nimport \"Faucet.sol\";\n\ncontract Token is Mortal {\n\tFaucet _faucet;\n\n    constructor() {\n        _faucet = new Faucet();\n    }\n}\n----\n\nYou can optionally specify the +value+ of ether transfer on creation, and pass arguments to the new contract's constructor:\n\n[source,solidity]\n----\nimport \"Faucet.sol\";\n\ncontract Token is Mortal {\n\tFaucet _faucet;\n\n    constructor() {\n        _faucet = (new Faucet).value(0.5 ether)();\n    }\n}\n----\n\nYou can also then call the +Faucet+ functions. In this example, we call the +destroy+ function of +Faucet+ from within the +destroy+ function of +Token+:\n\n[source,solidity]\n----\nimport \"Faucet.sol\";\n\ncontract Token is Mortal {\n\tFaucet _faucet;\n\n    constructor() {\n        _faucet = (new Faucet).value(0.5 ether)();\n    }\n\n    function destroy() ownerOnly {\n        _faucet.destroy();\n    }\n}\n----\n\nNote that while you are the owner of the +Token+ contract, the +Token+ contract itself owns the new +Faucet+ contract, so only the +Token+ contract can destroy it.", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Creating a new instance"}}
{"input": "Explain the Ethereum concept: Addressing an existing instance", "output": "(((\"smart contracts\",\"addressing an existing instance\")))Another way you can call a contract is by casting the address of an existing instance of the contract. With this method, you apply a known interface to an existing instance. It is therefore critically important that you know, for sure, that the instance you are addressing is in fact of the type you assume. Let's look at an example:\n\n[source,solidity]\n----\nimport \"Faucet.sol\";\n\ncontract Token is Mortal {\n\n    Faucet _faucet;\n\n    constructor(address _f) {\n        _faucet = Faucet(_f);\n        _faucet.withdraw(0.1 ether);\n    }\n}\n----\n\nHere, we take an address provided as an argument to the constructor, +_f+, and we cast it to a +Faucet+ object. This is much riskier than the previous mechanism, because we don't know for sure whether that address actually is a +Faucet+ object. When we call +withdraw+, we are assuming that it accepts the same arguments and executes the same code as our +Faucet+ declaration, but we can't be sure. For all we know, the +withdraw+ function at this address could execute something completely different from what we expect, even if it is named the same. Using addresses passed as input and casting them into specific objects is therefore much more dangerous than creating the contract yourself.", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Addressing an existing instance"}}
{"input": "Explain the Ethereum concept: Raw call, delegatecall", "output": "Solidity offers some even more \"low-level\" functions for calling other contracts. These correspond directly to EVM opcodes of the same name and allow us to construct a contract-to-contract call manually. As such, they represent the most flexible _and_ the most dangerous mechanisms for calling other contracts.\n\n(((\"smart contracts\",\"call method\", id=\"ix_07smart-contracts-solidity-asciidoc23\", range=\"startofrange\")))Here's the same example, using a +call+ method:\n\n[source,solidity]\n----\ncontract Token is Mortal {\n\tconstructor(address _faucet) {\n\t\t_faucet.call(\"withdraw\", 0.1 ether);\n\t}\n}\n----\n\n(((\"blind calls\")))As you can see, this type of +call+ is a _blind_ call into a function, very much like constructing a raw transaction, only from within a contract's context. (((\"reentrancy attacks\",\"blind calls and\")))It can expose your contract to a number of security risks, most importantly _reentrancy_, which we will discuss in more detail in <<reentrancy_security>>. The +call+ function will return +false+ if there is a problem, so you can evaluate the return value for error handling:\n\n[source,solidity]\n----\ncontract Token is Mortal {\n\tconstructor(address _faucet) {\n\t\tif !(_faucet.call(\"withdraw\", 0.1 ether)) {\n\t\t\trevert(\"Withdrawal from faucet failed\");\n\t\t}\n\t}\n}\n----\n\n(((\"delegatecall method\")))(((\"smart contracts\",\"delegatecall method\")))Another variant of +call+ is +delegatecall+, which replaced the more dangerous +callcode+. The pass:[<code><span class=\"keep-together\">callcode</span></code>] method will be deprecated soon, so it should not be used.\n\nAs mentioned in <<solidity_address_object>>, a +delegatecall+ is different from a +call+ in that the +msg+ context does not change. For example, whereas a +call+ changes the value of +msg.sender+ to be the calling contract, a +delegatecall+ keeps the same +msg.sender+ as in the calling contract. Essentially, +delegatecall+ runs the code of another contract inside the context of the execution of the current contract. It is most often used to invoke code from a library. It also allows you to draw on the pattern of using library functions stored elsewhere, but have that code work with the storage data of your contract.\n\nThe +delegate+ call should be used with great caution. It can have some unexpected effects, especially if the contract you call was not designed as a library.\n\nLet's use an example contract to demonstrate the various call semantics used by +call+ and +delegatecall+ for calling libraries and contracts. In <<call_examples_code>>, we use an event to log the details of each call and see how the calling context changes depending on the call type.\n\n[[call_examples_code]]\n.CallExamples.sol: An example of different call semantics", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Raw call, delegatecall"}}
{"input": "Explain the Ethereum concept: Gas Considerations", "output": "(((\"gas\",\"conserving\", id=\"ix_07smart-contracts-solidity-asciidoc24\", range=\"startofrange\")))(((\"smart contracts\",\"gas considerations\", id=\"ix_07smart-contracts-solidity-asciidoc25\", range=\"startofrange\")))(((\"Solidity\",\"gas considerations\", id=\"ix_07smart-contracts-solidity-asciidoc26\", range=\"startofrange\")))Gas, described in more detail in <<gas>>, is an incredibly important consideration in smart contract programming. Gas is a resource constraining the maximum amount of computation that Ethereum will allow a transaction to consume. If the gas limit is exceeded during computation, the following series of events occurs:\n\n* An \"out of gas\" exception is thrown.\n* The state of the contract prior to execution is restored (reverted).\n* All ether used to pay for the gas is taken as a transaction fee; it is _not_ refunded.\n\nBecause gas is paid by the user who initiates the transaction, users are discouraged from calling functions that have a high gas cost. It is thus in the programmer's best interest to minimize the gas cost of a contract's functions. To this end, there are certain practices that are recommended when constructing smart contracts, so as to minimize the gas cost of a function call.", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Gas Considerations"}}
{"input": "Explain the Ethereum concept: Avoid Dynamically Sized Arrays", "output": "(((\"dynamically sized arrays\")))(((\"gas\",\"dynamically sized arrays and\")))Any loop through a dynamically sized array where a function performs operations on each element or searches for a particular element introduces the risk of using too much gas. Indeed, the contract may run out of gas before finding the desired result, or before acting on every element, thus wasting time and ether without giving any result at all.", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Avoid Dynamically Sized Arrays"}}
{"input": "Explain the Ethereum concept: Avoid Calls to Other Contracts", "output": "(((\"gas\",\"avoiding calls to other contracts\")))Calling other contracts, especially when the gas cost of their functions is not known, introduces the risk of running out of gas. Avoid using libraries that are not well tested and broadly used. The less scrutiny a library has received from other programmers, the greater the risk of using it.", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Avoid Calls to Other Contracts"}}
{"input": "Explain the Ethereum concept: Estimating Gas Cost", "output": "(((\"gas\",\"estimating cost of\", id=\"ix_07smart-contracts-solidity-asciidoc27\", range=\"startofrange\")))If you need to estimate the gas necessary to execute a certain method of a contract considering its arguments, you could use the following procedure:\n\n[source, javascript]\nvar contract = web3.eth.contract(abi).at(address);\nvar gasEstimate = contract.myAweSomeMethod.estimateGas(arg1, arg2,\n    {from: account});\n\n+gasEstimate+ will tell you the number of gas units needed for its execution. It is an estimate because of the Turing completeness of the EVM&#x2014;it is relatively trivial to create a function that will take vastly different amounts of gas to execute different calls. Even production code can change execution paths in subtle ways, resulting in hugely different gas costs from one call to the next. However, most functions are sensible and +estimateGas+ will give a good estimate most of the time.\n\nTo obtain the gas price from the network you can use:\n\n[source, javascript]\nvar gasPrice = web3.eth.getGasPrice();\n\nAnd from there you can estimate the gas cost:\n\n[source, javascript]\nvar gasCostInEther = web3.utils.fromWei((gasEstimate * gasPrice), 'ether');\n\nLet's apply our gas estimation functions to estimating the gas cost of our +Faucet+ example, using the code http://bit.ly/2zf0SIO[from the book's repository].\n\nStart Truffle in development mode and execute the JavaScript file in <<estimateGas_function>>, _gas_estimates.js_.\n\n[source, javascript]\n[[estimateGas_function]]\n.gas_estimates.js: Using the estimateGas function", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Estimating Gas Cost"}}
{"input": "Explain the Ethereum concept: Conclusions", "output": "In this chapter we started working with smart contracts in detail and explored the Solidity contract programming language.(((range=\"endofrange\", startref=\"ix_07smart-contracts-solidity-asciidoc4\")))(((range=\"endofrange\", startref=\"ix_07smart-contracts-solidity-asciidoc3\"))) We took a simple example contract, _Faucet.sol_, and gradually improved it and made it more complex, using it to explore various aspects of the Solidity language. In <<vyper_chap>> we will work with Vyper, another contract-oriented programming language. We will compare Vyper to Solidity, showing some of the differences in the design of these two languages and deepening our understanding of smart contract programming.(((range=\"endofrange\", startref=\"ix_07smart-contracts-solidity-asciidoc0\")))", "metadata": {"source": "ethereumbook", "chapter": "07smart-contracts-solidity.asciidoc", "section": "Conclusions"}}
{"input": "Explain the Ethereum concept: Smart Contracts and Vyper", "output": "(((\"Vyper\", id=\"ix_08smart-contracts-vyper-asciidoc0\", range=\"startofrange\")))Vyper is an experimental, contract-oriented programming language for the Ethereum Virtual Machine that strives to provide superior auditability, by making it easier for developers to produce intelligible code. In fact, one of the principles of Vyper is to make it virtually impossible for developers to write misleading code.\n\nIn this chapter we will look at common problems with smart contracts, introduce the Vyper contract programming language, and compare it to Solidity, demonstrating the differences.", "metadata": {"source": "ethereumbook", "chapter": "08smart-contracts-vyper.asciidoc", "section": "Smart Contracts and Vyper"}}
{"input": "Explain the Ethereum concept: Vulnerabilities and Vyper", "output": "https://arxiv.org/pdf/1802.06038.pdf[A recent study] (((\"vulnerabilities\", seealso=\"security; specific attacks/vulnerabilities\")))(((\"Vyper\",\"contract vulnerabilities and\")))analyzed nearly one million deployed Ethereum smart contracts and found that many of these contracts contained serious vulnerabilities. During their analysis, the researchers outlined three basic categories of trace vulnerabilities:\n\nSuicidal contracts:: Smart contracts that can be killed by arbitrary addresses\n\nGreedy contracts:: Smart contracts that can reach a state in which they cannot release ether\n\nProdigal contracts:: Smart contracts that can be made to release ether to arbitrary addresses\n\nVulnerabilities are introduced into smart contracts via code. It may be strongly argued that these and other vulnerabilities are not intentionally introduced, but regardless, undesirable smart contract code evidently results in the unexpected loss of funds for Ethereum users, and this is not ideal. Vyper is designed to make it easier to write secure code, or equally to make it more difficult to accidentally write misleading or vulnerable code.\n\n[[comparison_to_solidity_sec]]", "metadata": {"source": "ethereumbook", "chapter": "08smart-contracts-vyper.asciidoc", "section": "Vulnerabilities and Vyper"}}
{"input": "Explain the Ethereum concept: Comparison to Solidity", "output": "(((\"Solidity\",\"Vyper compared to\", id=\"ix_08smart-contracts-vyper-asciidoc1\", range=\"startofrange\")))(((\"Vyper\",\"Solidity compared to\", id=\"ix_08smart-contracts-vyper-asciidoc2\", range=\"startofrange\")))One of the ways in which Vyper tries to make unsafe code harder to write is by deliberately _omitting_ some of Solidity's features. It is important for those considering developing smart contracts in Vyper to understand what features Vyper does _not_ have, and why. Therefore, in this section, we will explore those features and provide justification for why they have been omitted.", "metadata": {"source": "ethereumbook", "chapter": "08smart-contracts-vyper.asciidoc", "section": "Comparison to Solidity"}}
{"input": "Explain the Ethereum concept: Modifiers", "output": "(((\"modifiers\")))(((\"Solidity\",\"modifiers\")))(((\"Vyper\",\"modifiers\")))As we saw in the previous chapter, in Solidity you can write a function using modifiers. For example, the following function, `changeOwner`, will run the code in a modifier called `onlyBy` as part of its execution:\n\n[source,javascript]\n----\nfunction changeOwner(address _newOwner)\n    public\n    onlyBy(owner)\n{\n    owner = _newOwner;\n}\n----\n\nThis modifier enforces a rule in relation to ownership. As you can see, this particular modifier acts as a mechanism to perform a pre-check on behalf of the `changeOwner` function:\n\n[source,javascript]\n----\nmodifier onlyBy(address _account)\n{\n    require(msg.sender == _account);\n    _;\n}\n----\n\nBut modifiers are not just there to perform checks, as shown here. In fact, as modifiers, they can significantly change a smart contract's environment, in the context of the calling function. Put simply, modifiers are _pervasive_.\n\nLet's look at another Solidity-style example:\n\n[source, javascript]\n----\nenum Stages {\n    SafeStage,\n    DangerStage,\n    FinalStage\n}\n\nuint public creationTime = now;\nStages public stage = Stages.SafeStage;\n\nfunction nextStage() internal {\n    stage = Stages(uint(stage) + 1);\n}\n\nmodifier stageTimeConfirmation() {\n    if (stage == Stages.SafeStage &&\n                now >= creationTime + 10 days)\n        nextStage();\n    _;\n}\n\nfunction a()\n    public\n    stageTimeConfirmation\n    // More code goes here\n{\n}\n----\n\nOn the one hand, developers should always check any other code that their own code is calling. However, it is possible that in certain situations (like when time constraints or exhaustion result in lack of concentration) a developer may overlook a single line of code. This is even more likely if the developer has to jump around inside a large file while mentally keeping track of the function call hierarchy and committing the state of smart contract variables to memory.\n\nLet's look at the preceding example in a bit more depth. Imagine that a developer is writing a public function called `a`. The developer is new to this contract and is utilizing a modifier written by someone else. At a glance, it appears that the `stageTimeConfirmation` modifier is simply performing some checks regarding the age of the contract in relation to the calling function. What the developer may _not_ realize is that the modifier is also calling another function, `nextStage`. In this simplistic demonstration scenario, simply calling the public function `a` results in the smart contract's `stage` variable moving from `SafeStage` to `DangerStage`.\n\nVyper has done away with modifiers altogether. The recommendations from Vyper are as follows: if only performing assertions with modifiers, then simply use inline checks and asserts as part of the function; if modifying smart contract state and so forth, again make these changes explicitly part of the function. Doing this improves auditability and readability, as the reader doesn't have to mentally (or manually) \"wrap\" the modifier code around the function to see what it does.", "metadata": {"source": "ethereumbook", "chapter": "08smart-contracts-vyper.asciidoc", "section": "Modifiers"}}
{"input": "Explain the Ethereum concept: Class Inheritance", "output": "(((\"class inheritance\")))(((\"inheritance\")))(((\"Solidity\",\"class inheritance\")))(((\"Vyper\",\"class inheritance\")))Inheritance allows programmers to harness the power of prewritten code by acquiring preexisting functionality, properties, and behaviors from existing software libraries. Inheritance is powerful and promotes the reuse of code. Solidity supports multiple inheritance as well as polymorphism, but while these are key features of object-oriented programming, Vyper does not support them. Vyper maintains that the implementation of inheritance requires coders and auditors to jump between multiple files in order to understand what the program is doing. Vyper also takes the view that multiple inheritance can make code too complicated to understand&#x2014;a view tacitly admitted by the Solidity http://bit.ly/2Q6Azvo[documentation], which gives an example of how multiple inheritance can be problematic.", "metadata": {"source": "ethereumbook", "chapter": "08smart-contracts-vyper.asciidoc", "section": "Class Inheritance"}}
{"input": "Explain the Ethereum concept: Inline Assembly", "output": "(((\"inline assembly\")))(((\"inline assembly\",\"Solidity compared to Vyper\")))(((\"Solidity inline assembly\")))Inline assembly gives developers low-level access to the Ethereum Virtual Machine, allowing Solidity programs to perform operations by directly accessing EVM instructions. For example, the following inline assembly code adds 3 to memory location +0x80+:\n\n----\n3 0x80 mload add 0x80 mstore\n----\n\nVyper considers the loss of readability to be too high a price to pay for the extra power, and thus does not support inline assembly.", "metadata": {"source": "ethereumbook", "chapter": "08smart-contracts-vyper.asciidoc", "section": "Inline Assembly"}}
{"input": "Explain the Ethereum concept: Function Overloading", "output": "(((\"function overloading\")))(((\"Solidity\",\"function overloading\")))(((\"Vyper\",\"function overloading\")))Function overloading allows developers to write multiple functions of the same name. Which function is used on a given occasion depends on the types of the arguments supplied. Take the following two functions, for example:\n\n[source,javascript]\n----\nfunction f(uint _in) public pure returns (uint out) {\n    out = 1;\n}\n\nfunction f(uint _in, bytes32 _key) public pure returns (uint out) {\n    out = 2;\n}\n----\n\nThe first function (named +f+) accepts an input argument of type +uint+; the second function (also named +f+) accepts two arguments, one of type +uint+ and one of type +bytes32+. Having multiple function definitions with the same name taking different arguments can be confusing, so Vyper does not support function overloading.", "metadata": {"source": "ethereumbook", "chapter": "08smart-contracts-vyper.asciidoc", "section": "Function Overloading"}}
{"input": "Explain the Ethereum concept: Variable Typecasting", "output": "(((\"Solidity\",\"variable typecasting\")))(((\"typecasting\")))(((\"Vyper\",\"variable typecasting\")))There are two sorts of typecasting: _implicit_ and _explicit_\n\n(((\"implicit typecasting\")))Implicit typecasting is often performed at compile time. For example, if a type conversion is semantically sound and no information is likely to be lost, the compiler can perform an implicit conversion, such as converting a variable of type +uint8+ to +uint16+. The earliest versions of Vyper allowed implicit typecasting of variables, but recent versions do not.\n\n(((\"explicit typecasting\")))Explicit typecasts can be inserted in Solidity. Unfortunately, they can lead to unexpected behavior. For example, casting a +uint32+ to the smaller type +uint16+ simply removes the higher-order bits, as demonstrated here:\n\n[source,javascript]\n----\nuint32 a = 0x12345678;\nuint16 b = uint16(a);\n// Variable b is 0x5678 now\n----\n\n(((\"convert function (Vyper)\")))Vyper instead has a +convert+ function to perform explicit casts. The convert function (found on line 82 of https://bit.ly/2Nnjy3I[_convert.py_]):\n\n[source,python]\n----\ndef convert(expr, context):\n    output_type = expr.args[1].s\n    if output_type in conversion_table:\n        return conversion_table[output_type](expr, context)\n    else:\n        raise Exception(\"Conversion to {} is invalid.\".format(output_type))\n----\n\nNote the use of +conversion_table+ (found on line 90 of the same file), which looks like this:\n\n[source,python]\n----\nconversion_table = {\n    'int128': to_int128,\n    'uint256': to_unint256,\n    'decimal': to_decimal,\n    'bytes32': to_bytes32,\n}\n----\n\nWhen a developer calls +convert+, it references +conversion_table+, which ensures that the appropriate conversion is performed. For example, if a developer passes an +int128+ to the +convert+ function, the +to_int128+ function on line 26 of the same (_convert.py_) file will be executed. The +to_int128+ function is as follows:\n\n[source,python]\n----\n@signature(('int128', 'uint256', 'bytes32', 'bytes'), 'str_literal')\ndef to_int128(expr, args, kwargs, context):\n    in_node = args[0]\n    typ, len = get_type(in_node)\n    if typ in ('int128', 'uint256', 'bytes32'):\n        if in_node.typ.is_literal \n            and not SizeLimits.MINNUM <= in_node.value <= SizeLimits.MAXNUM:\n            raise InvalidLiteralException(\n                \"Number out of range: {}\".format(in_node.value), expr\n            )\n        return LLLnode.from_list(\n            ['clamp', ['mload', MemoryPositions.MINNUM], in_node,\n            ['mload', MemoryPositions.MAXNUM]], typ=BaseType('int128'),\n            pos=getpos(expr)\n        )\n    else:\n        return byte_array_to_num(in_node, expr, 'int128')\n----\n\nAs you can see, the conversion process ensures that no information can be lost; if it could be, an exception is raised. The conversion code prevents truncation as well as other anomalies that would ordinarily be allowed by implicit typecasting.\n\nChoosing explicit over implicit typecasting means that the developer is responsible for performing all casts. While this approach does produce more verbose code, it also improves the safety and auditability of smart contracts.", "metadata": {"source": "ethereumbook", "chapter": "08smart-contracts-vyper.asciidoc", "section": "Variable Typecasting"}}
{"input": "Explain the Ethereum concept: Infinite Loop", "output": "(((\"infinite loop\")))(((\"Solidity\",\"infinite loop\")))(((\"Vyper\",\"infinite loop\")))Although there is no merit because of gaslimit, developers can write an endless loop processing in Solidity. Infinite loop makes it impossible to set an upper bound on gas limits, opening the door for gas limit attacks. Therefore, Vyper doesn't permit you to write the processing and has the following three features:\n\nThe `while` statement::\nyou can use `while` statement in Solidity, but Vyper doesn't have the statement.\n\nDeterministic number of iterations of `for` statement::\nVyper has a `for` statement, but the upper limit of the number of iterations must be determinate, and `range ()` can only accept integer literals.\n\nRecursive calling::\nRecursive calling can be written in Solidity, but not in Vyper.", "metadata": {"source": "ethereumbook", "chapter": "08smart-contracts-vyper.asciidoc", "section": "Infinite Loop"}}
{"input": "Explain the Ethereum concept: Preconditions and Postconditions", "output": "(((\"Vyper\",\"preconditions/postconditions\")))Vyper handles preconditions, postconditions, and state changes explicitly. While this produces redundant code, it also allows for maximal readability and safety. When writing a smart contract in Vyper, a developer should observe the following three points:\n\nCondition::\nWhat is the current state/condition of the Ethereum state variables?\nEffects::\nWhat effects will this smart contract code have on the condition of the state variables upon execution? That is, what _will_ be affected, and what _will not_ be affected? Are these effects congruent with the smart contract's intentions?\nInteraction::\nAfter the first two considerations have been exhaustively dealt with, it is time to run the code. Before deployment, logically step through the code and consider all of the possible permanent outcomes, consequences, and scenarios of executing the code, including interactions with other contracts.\n\nIdeally, each of these points should be carefully considered and then thoroughly documented in the code. Doing so will improve the design of the code, ultimately making it more readable and auditable.(((range=\"endofrange\", startref=\"ix_08smart-contracts-vyper-asciidoc2\")))(((range=\"endofrange\", startref=\"ix_08smart-contracts-vyper-asciidoc1\")))\n\n[[decorators_sec]]", "metadata": {"source": "ethereumbook", "chapter": "08smart-contracts-vyper.asciidoc", "section": "Preconditions and Postconditions"}}
{"input": "Explain the Ethereum concept: Decorators", "output": "(((\"decorators, Vyper\")))(((\"Vyper\",\"decorators\")))The following decorators may be used at the start of each function:\n\n+@private+:: The `@private` decorator makes the function inaccessible from outside the contract.\n\n+@public+:: The `@public` decorator makes the function both visible and executable publicly. For example, even the Ethereum wallet will display such functions when viewing the contract.\n\n+@constant+:: Functions with the `@constant` decorator are not allowed to change state variables. In fact, the compiler will reject the entire program (with an appropriate error) if the function tries to change a state variable.\n\n+@payable+:: Only functions with the `@payable` decorator are allowed to transfer value.\n\nVyper implements http://bit.ly/2P14RDq[the logic of decorators] explicitly. For example, the Vyper compilation process will fail if a function has both a `@payable` decorator and a `@constant` decorator. This makes sense because a function that transfers value has by definition updated the state, so cannot be `@constant`. Each Vyper function must be decorated with either `@public` or `@private` (but not both!).\n\n[[order_of_functions_sec]]", "metadata": {"source": "ethereumbook", "chapter": "08smart-contracts-vyper.asciidoc", "section": "Decorators"}}
{"input": "Explain the Ethereum concept: Function and Variable Ordering", "output": "(((\"function declarations, ordering of\")))(((\"Solidity\",\"function ordering\")))(((\"Solidity\",\"variable ordering\")))(((\"variable declarations, ordering of\")))(((\"Vyper\",\"function ordering\")))(((\"Vyper\",\"variable ordering\")))Each individual Vyper smart contract consists of a single Vyper file only. In other words, all of a given Vyper smart contract's code, including all functions, variables, and so forth, exists in one place. Vyper requires that each smart contract's function and variable declarations are physically written in a particular order. Solidity does not have this requirement at all. Let's take a quick look at a Solidity example:\n\n[source,javascript]\n----\npragma solidity ^0.4.0;\n\ncontract ordering {\n\n    function topFunction()\n    external\n    returns (bool) {\n        initiatizedBelowTopFunction = this.lowerFunction();\n        return initiatizedBelowTopFunction;\n    }\n\n    bool initiatizedBelowTopFunction;\n    bool lowerFunctionVar;\n\n    function lowerFunction()\n    external\n    returns (bool) {\n        lowerFunctionVar = true;\n        return lowerFunctionVar;\n    }\n\n}\n----\n\nIn this example, the function called +topFunction+ is calling another function, +lowerFunction+. +topFunction+ is also assigning a value to a variable called +initiatizedBelowTopFunction+. As you can see, Solidity does not require these functions and variables to be physically declared before being called upon by the excecuting code. This is valid Solidity code that will compile successfully.\n\nVyper's ordering requirements are not a new thing; in fact, these ordering requirements have always been present in Python programming. The ordering required by Vyper is straightforward and logical, as illustrated in this next example:\n\n[source,python]\n----\n# Declare a variable called theBool\ntheBool: public(bool)\n\n# Declare a function called topFunction\n@public\ndef topFunction() -> bool:\n    # Assign a value to the already declared variable called theBool\n    self.theBool = True\n    return self.theBool\n\n# Declare a function called lowerFunction\n@public\ndef lowerFunction():\n    # Call the already declared function called topFunction\n    assert self.topFunction()\n----\n\nThis shows the correct ordering of functions and variables in a Vyper smart contract. Note how the variable +theBool+ and the function +topFunction+ are declared before they are assigned a value and called, respectively. If +theBool+ was declared below +topFunction+ or if +topFunction+ was declared below +lowerFunction+ this contract would not compile.\n\n[[online_code_editor_and_compiler_sec]]", "metadata": {"source": "ethereumbook", "chapter": "08smart-contracts-vyper.asciidoc", "section": "Function and Variable Ordering"}}
{"input": "Explain the Ethereum concept: Compilation", "output": "(((\"compiling\",\"Vyper\")))(((\"Vyper\",\"compilation\")))Vyper has its own https://vyper.online[online code editor and compiler], which allows you to write and then compile your smart contracts into bytecode, ABI, and LLL using only your web browser. The Vyper online compiler has a variety of prewritten smart contracts for your convenience, including contracts for a simple open auction, safe remote purchases, ERC20 tokens, and more. This tool, offers only one version of the compilation software. It is updated regularly but does not always guarantee the latest version. Etherscan has an https://etherscan.io/vyper[online Vyper compiler] which allows you to select the compiler version. Also https://remix.ethereum.org[Remix], originally designed for Solidity smart contracts, now has a Vyper plugin available in the settings tab.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "08smart-contracts-vyper.asciidoc", "section": "Compilation"}}
{"input": "Explain the Ethereum concept: Protecting Against Overflow Errors at the Compiler Level", "output": "(((\"compiling\",\"protecting against overflow errors at the compiler level\")))(((\"overflow\",\"protecting against\")))(((\"Vyper\",\"overflow protection\")))Overflow errors in software can be catastrophic when dealing with real value. For example, one http://bit.ly/2yHfvoF[transaction from mid-April 2018] shows the  pass:[<span class=\"keep-together\">malicious transfer of over 57,896,044,618,658,100,000,000,000,000,000,000,000,000,&thinsp;</span>]000,000,000,000,000,000 BEC tokens. This transaction was the result of an integer overflow issue in BeautyChain's ERC20 token contract (_BecToken.sol_). Solidity developers do have access to libraries like http://bit.ly/2ABhb4l[+SafeMath+] as well as Ethereum smart contract security analysis tools like http://bit.ly/2CQRoGU[Mythril OSS]. However, developers are not forced to use the safety tools. Put simply, if safety is not enforced by the language, developers can write unsafe code that will successfully compile and later on \"successfully\" execute.\n\nVyper has built-in overflow protection, implemented in a two-pronged approach. Firstly, Vyper provides http://bit.ly/2PuDfpB[a +SafeMath+ equivalent] that includes the necessary exception cases for integer arithmetic. Secondly, Vyper uses clamps whenever a literal constant is loaded, a value is passed to a function, or a variable is assigned. Clamps are implemented via custom functions in the Low-level Lisp-like Language (LLL) compiler, and cannot be disabled. (The Vyper compiler outputs LLL rather than EVM bytecode; this simplifies the development of Vyper itself.)\n\n\n[[reading_and_writing_data_sec]]", "metadata": {"source": "ethereumbook", "chapter": "08smart-contracts-vyper.asciidoc", "section": "Protecting Against Overflow Errors at the Compiler Level"}}
{"input": "Explain the Ethereum concept: Reading and Writing Data", "output": "(((\"Vyper\",\"reading/writing data\")))While it is costly to store, read, and modify data, these storage operations are a necessary component of most smart contracts. Smart contracts can write data to two places:\n\nGlobal state:: (((\"global state trie\")))The state variables in a given smart contract are stored in Ethereum's global state trie; a smart contract can only store, read, and modify data in relation to that particular contract's address (i.e., smart contracts cannot read or write to other smart contracts).\n\nLogs:: (((\"logs, Vyper\")))A smart contract can also write to Ethereum's chain data through log events. While Vyper initially employed the pass:[<code>__log__</code>] syntax for declaring these events, an update has been made that brings its event declaration more in line with Solidity's original syntax. For example, Vyper's declaration of an event called `MyLog` was originally `MyLog: pass:[__]logpass:[__]({arg1: indexed(bytes[3])})`. The syntax has now become `MyLog: event({arg1: indexed(bytes[3])})`. It is important to note that the execution of the log event in Vyper was, and still is, as follows: `log.MyLog(\"123\")`.\n\nWhile smart contracts can write to Ethereum's chain data (through log events), they are unable to read the on-chain log events they've created. Notwithstanding, one of the advantages of writing to Ethereum's chain data via log events is that logs can be discovered and read, on the public chain, by light clients. For example, the +logsBloom+ value in a mined block can indicate whether or not a log event is present. Once the existence of log events has been established, the log data can be obtained from a given transaction receipt.", "metadata": {"source": "ethereumbook", "chapter": "08smart-contracts-vyper.asciidoc", "section": "Reading and Writing Data"}}
{"input": "Explain the Ethereum concept: Conclusions", "output": "Vyper is a powerful and interesting new contract-oriented programming language. Its design is biased toward \"correctness,\" at the expense of some flexibility. This may allow programmers to write better smart contracts and avoid certain pitfalls that cause serious vulnerabilities to arise. Next, we will look at smart contract security in more detail. Some of the nuances of Vyper design may become more apparent once you read about all the possible security problems that can arise in smart contracts.(((range=\"endofrange\", startref=\"ix_08smart-contracts-vyper-asciidoc0\")))", "metadata": {"source": "ethereumbook", "chapter": "08smart-contracts-vyper.asciidoc", "section": "Conclusions"}}
{"input": "Explain the Ethereum concept: Smart Contract Security", "output": "(((\"security (smart contracts)\", id=\"ix_09smart-contracts-security-asciidoc0\", range=\"startofrange\")))(((\"smart contracts\",\"security\", id=\"ix_09smart-contracts-security-asciidoc1\", range=\"startofrange\")))Security is one of the most important considerations when writing smart contracts. In the field of smart contract programming, mistakes are costly and easily exploited. In this chapter we will look at security best practices and design patterns, as well as \"security antipatterns,\" which are practices and patterns that can introduce vulnerabilities in our smart contracts.\n\nAs with other programs, a smart contract will execute exactly what is written, which is not always what the programmer intended. Furthermore, all smart contracts are public, and any user can interact with them simply by creating a transaction. Any vulnerability can be exploited, and losses are almost always impossible to recover. It is therefore critical to follow best practices and use well-tested design patterns.", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Smart Contract Security"}}
{"input": "Explain the Ethereum concept: Security Best Practices", "output": "(((\"defensive programming\")))(((\"security (smart contracts)\",\"best practices\")))_Defensive programming_ is a style of programming that is particularly well suited to smart contracts. It emphasizes the following, all of which are best practices:\n\nMinimalism/simplicity:: Complexity is the enemy of security. The simpler the code, and the less it does, the lower the chances are of a bug or unforeseen effect occurring. When first engaging in smart contract programming, developers are often tempted to try to write a lot of code. Instead, you should look through your smart contract code and try to find ways to do less, with fewer lines of code, less complexity, and fewer \"features.\" If someone tells you that their project has produced \"thousands of lines of code\" for their smart contracts, you should question the security of that project. Simpler is more secure.\n\nCode reuse:: Try not to reinvent the wheel. If a library or contract already exists that does most of what you need, reuse it. Within your own code, follow the DRY principle: Don't Repeat Yourself. If you see any snippet of code repeated more than once, ask yourself whether it could be written as a function or library and reused. Code that has been extensively used and tested is likely more secure than any new code you write. Beware of &#x201c;Not Invented Here&#x201d; syndrome, where you are tempted to \"improve\" a feature or component by building it from scratch. The security risk is often greater than the improvement value.\n\nCode quality:: Smart contract code is unforgiving. Every bug can lead to monetary loss. You should not treat smart contract programming the same way as general-purpose programming. Writing DApps in Solidity is not like creating a web widget in JavaScript. Rather, you should apply rigorous engineering and software development methodologies, as you would in aerospace engineering or any similarly unforgiving discipline. Once you \"launch\" your code, there's little you can do to fix any problems.\n\nReadability/auditability:: Your code should be clear and easy to comprehend. The easier it is to read, the easier it is to audit. Smart contracts are public, as everyone can read the bytecode and anyone can reverse-engineer it. Therefore, it is beneficial to develop your work in public, using collaborative and open source methodologies, to draw upon the collective wisdom of the developer community and benefit from the highest common denominator of open source development. You should write code that is well documented and easy to read, following the style and naming conventions that are part of the Ethereum community.\n\nTest coverage:: Test everything that you can. Smart contracts run in a public execution environment, where anyone can execute them with whatever input they want. You should never assume that input, such as function arguments, is well formed, properly bounded, or has a benign purpose. Test all arguments to make sure they are within expected ranges and properly formatted before allowing execution of your code to continue.", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Security Best Practices"}}
{"input": "Explain the Ethereum concept: Security Risks and Antipatterns", "output": "(((\"security (smart contracts)\",\"risks and antipatterns\", id=\"ix_09smart-contracts-security-asciidoc2\", range=\"startofrange\")))As a smart contract programmer, you should be familiar with the most common security risks, so as to be able to detect and avoid the programming patterns that leave your contracts exposed to these risks. In the next several sections we will look at different security risks, examples of how vulnerabilities can arise, and countermeasures or preventative solutions that can be used to address them.\n\n[[reentrancy_security]]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Security Risks and Antipatterns"}}
{"input": "Explain the Ethereum concept: Reentrancy", "output": "(((\"reentrancy attacks\", id=\"ix_09smart-contracts-security-asciidoc3\", range=\"startofrange\")))(((\"security (smart contracts)\",\"reentrancy attacks\", id=\"ix_09smart-contracts-security-asciidoc4\", range=\"startofrange\")))One of the features of Ethereum smart contracts is their ability to call\nand utilize code from other external contracts. Contracts also typically\nhandle ether, and as such often send ether to various external user\naddresses. These operations require the contracts to submit external calls. These\nexternal calls can be hijacked by attackers, who can force the\ncontracts to execute further code (through a fallback function),\nincluding calls back into themselves. Attacks of this kind were used in the\ninfamous http://bit.ly/2DamSZT[DAO hack].\n\nFor further reading on reentrancy attacks, see Gus Guimareas's http://bit.ly/2zaqSEY[blog post] on the subject and the http://bit.ly/2ERDMxV[Ethereum Smart Contract Best Practices].\n\n[role=\"notoc\"]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Reentrancy"}}
{"input": "Explain the Ethereum concept: The Vulnerability", "output": "////\nNOTE to editor\nThe section headings \"The Vulnerability\" & \"Preventive Techniques\" throughout this chapter have been changed from headings to bold formatting intentionally so as not to clutter the table of contents with repetitive wording.\n////\n\n(((\"reentrancy attacks\",\"vulnerability\", id=\"ix_09smart-contracts-security-asciidoc5\", range=\"startofrange\")))This type of attack can occur when a contract sends ether to an unknown address.\nAn attacker can carefully construct a contract at an external address\nthat contains malicious code in the fallback function. Thus, when a contract sends ether to this address, it will\ninvoke the malicious code. Typically the malicious code executes a\nfunction on the vulnerable contract, performing operations not expected\nby the developer. The term \"reentrancy\" comes from the fact that the\nexternal malicious contract calls a function on the vulnerable\ncontract and the path of code execution &#x201c;__reenters__&#x201d; it.\n\nTo clarify this, consider the simple vulnerable contract in <<etherstore_vulnerable>>, which acts as\nan Ethereum vault that allows depositors to withdraw only 1 ether per\nweek.\n\n[[etherstore_vulnerable]]\n.EtherStore.sol", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "The Vulnerability"}}
{"input": "Explain the Ethereum concept: Preventative Techniques", "output": "(((\"reentrancy attacks\",\"preventative techniques\")))There are a number of common techniques that help avoid potential\nreentrancy vulnerabilities in smart contracts. (((\"transfer function\",\"to reduce reentrancy vulnerabilities\")))The first is to (whenever possible) use the built-in\nhttp://bit.ly/2Ogvnng[+transfer+]\nfunction when sending ether to external contracts. The +transfer+ function\nonly sends 2300 gas with the external call, which is not enough for the destination\naddress/contract to call another contract (i.e., reenter the sending\ncontract).\n\n(((\"checks-effects-interactions pattern\")))The second technique is to ensure that all logic that changes state\nvariables happens before ether is sent out of the contract (or any\nexternal call). In the `EtherStore` example, lines 18 and 19 of\n_EtherStore.sol_ should be put before line 17. It is good practice for any code that performs external calls to unknown addresses to be the\nlast operation in a localized function or piece of code execution. This\nis known as the\nhttp://bit.ly/2EVo70v[checks-effects-interactions\npattern].\n\n(((\"mutex\")))A third technique is to introduce a mutex&#x2014;that is, to add a state\nvariable that locks the contract during code execution, preventing\nreentrant calls.\n\nApplying all of these techniques (using all three is unnecessary, but we do it\nfor demonstrative purposes) to _EtherStore.sol_, gives the\nreentrancy-free contract:\n\n[source,solidity,linenums]\n----\ncontract EtherStore {\n\n    // initialize the mutex\n    bool reEntrancyMutex = false;\n    uint256 public withdrawalLimit = 1 ether;\n    mapping(address => uint256) public lastWithdrawTime;\n    mapping(address => uint256) public balances;\n\n    function depositFunds() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdrawFunds (uint256 _weiToWithdraw) public {\n        require(!reEntrancyMutex);\n        require(balances[msg.sender] >= _weiToWithdraw);\n        // limit the withdrawal\n        require(_weiToWithdraw <= withdrawalLimit);\n        // limit the time allowed to withdraw\n        require(now >= lastWithdrawTime[msg.sender] + 1 weeks);\n        balances[msg.sender] -= _weiToWithdraw;\n        lastWithdrawTime[msg.sender] = now;\n        // set the reEntrancy mutex before the external call\n        reEntrancyMutex = true;\n        msg.sender.transfer(_weiToWithdraw);\n        // release the mutex after the external call\n        reEntrancyMutex = false;\n    }\n }\n----\n\n[[real_world_example_the_dao]]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Preventative Techniques"}}
{"input": "Explain the Ethereum concept: Real-World Example: The DAO", "output": "(((\"DAO (Decentralized Autonomous Organization)\",\"reentrancy attack\")))(((\"reentrancy attacks\",\"real-world example: DAO attack\")))The DAO (Decentralized Autonomous Organization) attack was one of the major hacks that\noccurred in the early development of Ethereum. At the time, the contract\nheld over $150 million. Reentrancy played a major role in the\nattack, which ultimately led to the hard fork that created Ethereum\nClassic (ETC). For a good analysis of the DAO exploit, see\nhttp://bit.ly/2EQaLCI. More information on Ethereum's fork history, the DAO hack timeline, and the birth of ETC in a hard fork can be found in <<ethereum_standards>>.(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc4\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc3\")))", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Real-World Example: The DAO"}}
{"input": "Explain the Ethereum concept: Arithmetic Over/Underflows", "output": "(((\"arithmetic over/underflows\", id=\"ix_09smart-contracts-security-asciidoc6\", range=\"startofrange\")))(((\"overflow\", id=\"ix_09smart-contracts-security-asciidoc7\", range=\"startofrange\")))(((\"security (smart contracts)\",\"arithmetic over/underflow threat\", id=\"ix_09smart-contracts-security-asciidoc8\", range=\"startofrange\")))(((\"underflow\", id=\"ix_09smart-contracts-security-asciidoc9\", range=\"startofrange\")))The Ethereum Virtual Machine specifies fixed-size data types for\nintegers. This means that an integer variable can represent only a certain range\nof numbers. A `uint8`, for example, can only store\nnumbers in the range [0,255]. Trying to store `256` into a `uint8` will\nresult in `0`. If care is not taken, variables in Solidity can be\nexploited if user input is unchecked and calculations are performed\nthat result in numbers that lie outside the range of the data type that\nstores them.\n\nFor further reading on arithmetic over/underflows, see https://bit.ly/2nNLuOr[&#x201c;How to Secure Your Smart Contracts&#x201d;],\nhttps://bit.ly/2MOfBPv[Ethereum Smart Contract Best Practices], and\nhttps://bit.ly/2xvbx1M[&#x201c;Ethereum, Solidity and integer overflows: programming blockchains like 1970&#x201d;].\n\n[role=\"notoc\"]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Arithmetic Over/Underflows"}}
{"input": "Explain the Ethereum concept: The Vulnerability", "output": "(((\"arithmetic over/underflows\",\"vulnerability\", id=\"ix_09smart-contracts-security-asciidoc10\", range=\"startofrange\")))An over/underflow occurs when an operation is performed that requires a\nfixed-size variable to store a number (or piece of data) that is outside\nthe range of the variable\u2019s data type.\n\n(((\"underflow\")))For example, subtracting `1` from a `uint8` (unsigned integer of 8 bits; i.e., nonnegative) variable whose value is `0` will result\nin the number `255`. This is an _underflow_. We have assigned a number\nbelow the range of the `uint8`, so the result _wraps around_ and gives the\nlargest number a `uint8` can store. Similarly, adding `2^8=256` to a\n`uint8` will leave the variable unchanged, as we have wrapped around the\nentire length of the `uint`. Two simple analogies of this behavior are\nodometers in cars, which measure distance traveled (they reset to 000000, after\nthe largest number, i.e., 999999, is surpassed) and periodic mathematical functions\n(adding +2\u03c0+ to the argument of +sin+ leaves the value unchanged).\n\n(((\"overflow\",\"defined\")))Adding numbers larger than the data type\u2019s range is called an _overflow_. For\nclarity, adding `257` to a `uint8` that currently has a value of `0` will result\nin the number `1`.  It is sometimes instructive to think of fixed-size variables\nas being cyclic, where we start again from zero if we add numbers above the\nlargest possible stored number, and start counting down from the largest number if we subtract from zero. In the case of signed `int` types, which _can_ represent negative numbers, we start again once we reach the largest negative value; for example, if we try to subtract `1` from a `int8` whose value is `-128`, we will get `127`.\n\nThese kinds of numerical gotchas allow attackers to misuse code and create\nunexpected logic flows. For example, consider the +TimeLock+ contract in\n<<timelock_sol_security>>.\n\n[[timelock_sol_security]]\n.TimeLock.sol", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "The Vulnerability"}}
{"input": "Explain the Ethereum concept: Preventative Techniques", "output": "(((\"arithmetic over/underflows\",\"preventative techniques\", id=\"ix_09smart-contracts-security-asciidoc11\", range=\"startofrange\")))The current conventional technique to guard against under/overflow\nvulnerabilities is to use or build mathematical libraries that replace\nthe standard math operators addition, subtraction, and multiplication\n(division is excluded as it does not cause over/underflows and the EVM\nreverts on division by 0).\n\n(((\"OpenZeppelin\")))(((\"SafeMath library\")))https://github.com/OpenZeppelin/openzeppelin-solidity[OpenZeppelin] has\ndone a great job of building and auditing secure libraries for the Ethereum community. In particular, its http://bit.ly/2ABhb4l[+SafeMath+ library] can be used to avoid under/overflow vulnerabilities.\n\nTo demonstrate how these libraries are used in Solidity, let's correct the `TimeLock` contract using the `SafeMath` library. The overflow-free version of the contract is:\n\n[source,solidity,linenums]\n----\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // This holds in all cases\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract TimeLock {\n    using SafeMath for uint; // use the library for uint type\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public lockTime;\n\n    function deposit() external payable {\n        balances[msg.sender] = balances[msg.sender].add(msg.value);\n        lockTime[msg.sender] = now.add(1 weeks);\n    }\n\n    function increaseLockTime(uint256 _secondsToIncrease) public {\n        lockTime[msg.sender] = lockTime[msg.sender].add(_secondsToIncrease);\n    }\n\n    function withdraw() public {\n        require(balances[msg.sender] > 0);\n        require(now > lockTime[msg.sender]);\n        uint256 transferValue = balances[msg.sender];\n        balances[msg.sender] = 0;\n        msg.sender.transfer(transferValue);\n    }\n}\n----\n\nNotice that all standard math operations have been replaced by those\ndefined in the `SafeMath` library. The `TimeLock` contract no longer\nperforms any operation that is capable of under/overflow.(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc11\")))", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Preventative Techniques"}}
{"input": "Explain the Ethereum concept: Real-World Examples: PoWHC and Batch Transfer Overflow (CVE-2018\u201310299)", "output": "(((\"arithmetic over/underflows\",\"real-world examples: PoWHC and batch transfer overflow\")))(((\"batchTransfer function\")))(((\"Proof of Weak Hands Coin (PoWHC)\")))Proof of Weak Hands Coin (PoWHC), originally devised as a joke of sorts, was a\nPonzi scheme written by an internet collective. Unfortunately it seems that the author(s) of the contract\nhad not seen over/underflows before, and consequently 866 ether were\nliberated from its contract. Eric Banisadr gives a good overview of how the underflow occurred\n(which is not too dissimilar to the Ethernaut challenge described earlier) in his https://bit.ly/2wrxIFJ[blog post] on the event.\n\nhttp://bit.ly/2CUf7WG[Another example] comes from the implementation of a `batchTransfer()` function into a group of ERC20 token contracts. The implementation contained an overflow vulnerability; you can read about the details in https://bit.ly/2HDlIs8[PeckShield's account].(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc9\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc8\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc7\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc6\")))", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Real-World Examples: PoWHC and Batch Transfer Overflow (CVE-2018\u201310299)"}}
{"input": "Explain the Ethereum concept: Unexpected Ether", "output": "(((\"ether (generally)\",\"unexpected ether security threat\", id=\"ix_09smart-contracts-security-asciidoc12\", range=\"startofrange\")))(((\"security (smart contracts)\",\"unexpected ether threat\", id=\"ix_09smart-contracts-security-asciidoc13\", range=\"startofrange\")))(((\"unexpected ether\",\"security threat from\", id=\"ix_09smart-contracts-security-asciidoc14\", range=\"startofrange\")))Typically, when ether is sent to a contract it must execute either the\nfallback function or another function defined in the contract. There\nare two exceptions to this, where ether can exist in a contract without\nhaving executed any code. Contracts that rely on code execution for\nall ether sent to them can be vulnerable to attacks where\nether is forcibly sent.\n\nFor further reading on this, see https://bit.ly/2MR8Gp0[&#x201c;How to Secure Your Smart Contracts&#x201d;] and http://bit.ly/2RjXmUWl[&#x201c;Solidity Security Patterns - Forcing Ether to a Contract&#x201d;].\n\n[role=\"notoc\"]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Unexpected Ether"}}
{"input": "Explain the Ethereum concept: The Vulnerability", "output": "(((\"unexpected ether\",\"vulnerability\", id=\"ix_09smart-contracts-security-asciidoc15\", range=\"startofrange\")))A (((\"invariant checking\")))common defensive programming technique that is useful in enforcing\ncorrect state transitions or validating operations is\n_invariant checking_. This technique involves defining a set of\ninvariants (metrics or parameters that should not change) and checking\nthat they remain unchanged after a single (or many) operation(s).\nThis is typically good design, provided the invariants being checked are\nin fact invariants. One example of an invariant is the `totalSupply` of\na fixed-issuance\nhttp://bit.ly/2CUf7WG[ERC20 token]. As no function should modify this invariant, one could add a\ncheck to the `transfer` function that ensures the `totalSupply`\nremains unmodified, to guarantee the function is working as expected.\n\nIn particular, there is one apparent invariant that it may be tempting to use\nbut that can in fact be manipulated by external users (regardless of the rules put\nin place in the smart contract). This is the current ether stored in the\ncontract. Often when developers first learn Solidity they have the\nmisconception that a contract can only accept or obtain ether via payable\nfunctions. This misconception can lead to contracts that have false assumptions\nabout the ether balance within them, which can lead to a range of\nvulnerabilities. The smoking gun for this vulnerability is the (incorrect) use\nof `this.balance`.\n\nThere are two ways in which ether can (forcibly) be sent to a contract\nwithout using a payable function or executing any code on the\ncontract:\n\nSelf-destruct/suicide::\n\n(((\"selfdestruct function\")))Any contract is able to implement the\nhttp://bit.ly/2RovrDf[`selfdestruct`\nfunction], which removes all bytecode from the contract address and sends\nall ether stored there to the parameter-specified address. If this\nspecified address is also a contract, no functions (including the\nfallback) get called. Therefore, the `selfdestruct` function can be\nused to forcibly send ether to any contract regardless of any code that\nmay exist in the contract, even contracts with no\npayable functions. This means any attacker can create a contract with a\n`selfdestruct` function, send ether to it, call `selfdestruct(target)`\nand force ether to be sent to a `target` contract. Martin Swende has an\nexcellent http://bit.ly/2OfLukM[blog post] describing some quirks of the self-destruct opcode (Quirk #2) along with\nan account of how client nodes were checking incorrect invariants,\nwhich could have led to a rather catastrophic crash of the Ethereum network.\n\nPre-sent ether::\n\nAnother way to get ether into a contract is to preload the contract address\nwith ether. Contract addresses are deterministic&#x2014;in fact, the address is\ncalculated from the Keccak-256 (commonly synonymous with SHA-3) hash of the\naddress creating the contract and the transaction nonce that creates the\ncontract. Specifically, it is of the form `address = sha3(rlp.encode([account_address,transaction_nonce]))`\n(see Adrian Manning's discussion of http://bit.ly/2EPj5Tq[&#x201c;Keyless Ether&#x201d;] for some fun use cases of this). This\nmeans anyone can calculate what a contract's address will be before it is\ncreated and send ether to that address. When the contract is\ncreated it will have a nonzero ether balance.\n\nLet\u2019s explore some pitfalls that can arise given this knowledge. Consider the overly simple contract in <<etherGame_security>>.\n\n[[etherGame_security]]\n.EtherGame.sol", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "The Vulnerability"}}
{"input": "Explain the Ethereum concept: Preventative Techniques", "output": "(((\"unexpected ether\",\"preventative techniques\")))This sort of vulnerability typically arises from the misuse of `this.balance`.\nContract logic, when possible, should avoid being dependent on exact\nvalues of the balance of the contract, because it can be artificially\nmanipulated. If applying logic based on `this.balance`, you have to\ncope with unexpected balances.\n\nIf exact values of deposited ether are required, a self-defined variable\nshould be used that is incremented in payable functions, to safely\ntrack the deposited ether. This variable will not be influenced by the\nforced ether sent via a `selfdestruct` call.\n\nWith this in mind, a corrected version of the `EtherGame` contract could\nlook like:\n\n[source,solidity,linenums]\n----\ncontract EtherGame {\n\n    uint public payoutMileStone1 = 3 ether;\n    uint public mileStone1Reward = 2 ether;\n    uint public payoutMileStone2 = 5 ether;\n    uint public mileStone2Reward = 3 ether;\n    uint public finalMileStone = 10 ether;\n    uint public finalReward = 5 ether;\n    uint public depositedWei;\n\n    mapping (address => uint) redeemableEther;\n\n    function play() external payable {\n        require(msg.value == 0.5 ether);\n        uint currentBalance = depositedWei + msg.value;\n        // ensure no players after the game has finished\n        require(currentBalance <= finalMileStone);\n        if (currentBalance == payoutMileStone1) {\n            redeemableEther[msg.sender] += mileStone1Reward;\n        }\n        else if (currentBalance == payoutMileStone2) {\n            redeemableEther[msg.sender] += mileStone2Reward;\n        }\n        else if (currentBalance == finalMileStone ) {\n            redeemableEther[msg.sender] += finalReward;\n        }\n        depositedWei += msg.value;\n        return;\n    }\n\n    function claimReward() public {\n        // ensure the game is complete\n        require(depositedWei == finalMileStone);\n        // ensure there is a reward to give\n        require(redeemableEther[msg.sender] > 0);\n        uint transferValue = redeemableEther[msg.sender];\n        redeemableEther[msg.sender] = 0;\n        msg.sender.transfer(transferValue);\n    }\n }\n----\n\nHere, we have created a new variable, `depositedWei`, which keeps\ntrack of the known ether deposited, and it is this variable that we\nuse for our tests. Note that we no longer have any\nreference to `this.balance`.", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Preventative Techniques"}}
{"input": "Explain the Ethereum concept: Further Examples", "output": "A few examples of exploitable contracts were given in the\nhttps://github.com/Arachnid/uscc/tree/master/submissions-2017/[Underhanded\nSolidity Coding Contest], which also provides extended examples of a number of the\npitfalls raised in this section.(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc14\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc13\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc12\")))", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Further Examples"}}
{"input": "Explain the Ethereum concept: DELEGATECALL", "output": "(((\"DELEGATECALL opcode security threat\", id=\"ix_09smart-contracts-security-asciidoc16\", range=\"startofrange\")))(((\"security (smart contracts)\",\"DELEGATECALL opcode threat\", id=\"ix_09smart-contracts-security-asciidoc17\", range=\"startofrange\")))The `CALL` and `DELEGATECALL` opcodes are useful in allowing Ethereum\ndevelopers to modularize their code. (((\"CALL opcode\")))Standard external message calls to\ncontracts are handled by the `CALL` opcode, whereby code is run in the\ncontext of the external contract/function. The `DELEGATECALL` opcode is\nalmost identical, except that the code executed at the targeted address is\nrun in the context of the calling contract, and `msg.sender` and `msg.value` remain unchanged. This\nfeature enables the implementation of _libraries_, allowing developers to\ndeploy reusable code once and call it from future contracts.\n\nAlthough the differences between these two opcodes are simple and\nintuitive, the use of `DELEGATECALL` can lead to unexpected code\nexecution.\n\nFor further reading, see Loi.Luu's\nhttp://bit.ly/2AAElb8[Ethereum\nStack Exchange question on this topic] and the\nhttp://bit.ly/2Oi7UlH[Solidity docs].\n\n[role=\"notoc\"]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "DELEGATECALL"}}
{"input": "Explain the Ethereum concept: The Vulnerability", "output": "(((\"DELEGATECALL opcode security threat\",\"vulnerability\", id=\"ix_09smart-contracts-security-asciidoc18\", range=\"startofrange\")))As a result of the context-preserving nature of `DELEGATECALL`, building\nvulnerability-free custom libraries is not as easy as one might think.\nThe code in libraries themselves can be secure and vulnerability-free;\nhowever, when run in the context of another application new\nvulnerabilities can arise. (((\"Fibonacci sequences\", id=\"ix_09smart-contracts-security-asciidoc19\", range=\"startofrange\")))Let\u2019s see a fairly complex example of this,\nusing Fibonacci numbers.\n\nConsider the library in <<fibonacci_security>>, which can generate the Fibonacci sequence\nand sequences of similar form. (Note: this code was\nmodified from https://bit.ly/2MReuii[].)\n\n[[fibonacci_security]]\n.FibonacciLib.sol", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "The Vulnerability"}}
{"input": "Explain the Ethereum concept: Preventative Techniques", "output": "(((\"DELEGATECALL opcode security threat\",\"preventative techniques\")))Solidity provides the `library` keyword for implementing library\ncontracts (see the http://bit.ly/2zjD8TI[docs] for further details). This ensures the library contract is\nstateless and non-self-destructable. Forcing libraries to be stateless\nmitigates the complexities of storage context demonstrated in this\nsection. Stateless libraries also prevent attacks wherein attackers\nmodify the state of the library directly in order to affect the\ncontracts that depend on the library\u2019s code. As a general rule of thumb,\nwhen using `DELEGATECALL` pay careful attention to the possible calling\ncontext of both the library contract and the calling contract, and\nwhenever possible build stateless pass:[<span class=\"keep-together\">libraries</span>].\n\n[[multisig_secondhack]]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Preventative Techniques"}}
{"input": "Explain the Ethereum concept: Real-World Example: Parity Multisig Wallet (Second Hack)", "output": "(((\"DELEGATECALL opcode security threat\",\"real-world example: Parity Multisig Wallet hack\", id=\"ix_09smart-contracts-security-asciidoc20\", range=\"startofrange\")))(((\"Parity Multisig Wallet\",\"second hack\", id=\"ix_09smart-contracts-security-asciidoc21\", range=\"startofrange\")))(((\"wallets\",\"Parity Multisig Wallet hacks\", id=\"ix_09smart-contracts-security-asciidoc22\", range=\"startofrange\")))The Second Parity Multisig Wallet hack is an example of how well-written library code can be exploited if run outside its intended\ncontext. There are a number of good explanations of this hack, such as\nhttp://bit.ly/2Dg7GtW[&#x201c;Parity Multisig Hacked. Again&#x201d;] and http://bit.ly/2Of06B9[&#x201c;An In-Depth Look at the Parity Multisig Bug&#x201d;].\n\nTo add to these references, let\u2019s explore the contracts that were\nexploited. The library and wallet contracts can be found http://bit.ly/2OgnXQC[on GitHub].\n\nThe library contract is as follows:\n\n[source,solidity,linenums]\n----\ncontract WalletLibrary is WalletEvents {\n\n  ...\n\n  // throw unless the contract is not yet initialized.\n  modifier only_uninitialized { if (m_numOwners > 0) throw; _; }\n\n  // constructor - just pass on the owner array to multiowned and\n  // the limit to daylimit\n  function initWallet(address[] _owners, uint _required, uint _daylimit)\n      only_uninitialized {\n    initDaylimit(_daylimit);\n    initMultiowned(_owners, _required);\n  }\n\n  // kills the contract sending everything to `_to`.\n  function kill(address _to) onlymanyowners(sha3(msg.data)) external {\n    suicide(_to);\n  }\n\n  ...\n\n}\n----\n\nAnd here's the wallet contract:\n\n[source,solidity,linenums]\n----\ncontract Wallet is WalletEvents {\n\n  ...\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n    else if (msg.data.length > 0)\n      _walletLibrary.delegatecall(msg.data);\n  }\n\n  ...\n\n  // FIELDS\n  address constant _walletLibrary =\n    0xcafecafecafecafecafecafecafecafecafecafe;\n}\n----\n\nNotice that the `Wallet` contract essentially passes all calls to the\n`WalletLibrary` contract via a delegate call. The constant\n`_walletLibrary` address in this code snippet acts as a placeholder for\nthe actually deployed `WalletLibrary` contract (which was at\n`0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4`).\n\nThe intended operation of these contracts was to have a simple low-cost\ndeployable `Wallet` contract whose codebase and main functionality were\nin the `WalletLibrary` contract. Unfortunately, the `WalletLibrary`\ncontract is itself a contract and maintains its own state. Can you see\nwhy this might be an issue?\n\nIt is possible to send calls to the pass:[<code><span class=\"keep-together\">WalletLibrary</span></code>] contract itself.\nSpecifically, the pass:[<code><span class=\"keep-together\">WalletLibrary</span></code>] contract could be initialized and\nbecome owned. In fact, a user did this, calling the `initWallet` function on the\n`WalletLibrary` contract and becoming an owner of the library contract. The\nsame user subsequently called the `kill` function. Because the user\nwas an owner of the library contract, the modifier passed and the\nlibrary contract self-destructed. As all `Wallet` contracts in existence refer\nto this library contract and contain no method to change this reference,\nall of their functionality, including the ability to withdraw ether, was\nlost along with the `WalletLibrary` contract. As a result, all ether\nin all Parity multisig wallets of this type instantly became lost or\npermanently unrecoverable(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc22\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc21\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc20\"))).(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc17\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc16\")))", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Real-World Example: Parity Multisig Wallet (Second Hack)"}}
{"input": "Explain the Ethereum concept: Default Visibilities", "output": "(((\"default visibility specifier security problem\", id=\"ix_09smart-contracts-security-asciidoc23\", range=\"startofrange\")))(((\"security (smart contracts)\",\"default visibility specifier threat\", id=\"ix_09smart-contracts-security-asciidoc24\", range=\"startofrange\")))(((\"Solidity\",\"default visibility specifier problem\", id=\"ix_09smart-contracts-security-asciidoc25\", range=\"startofrange\")))(((\"visibility specifiers\", id=\"ix_09smart-contracts-security-asciidoc26\", range=\"startofrange\")))Functions in Solidity have visibility specifiers that dictate how\nthey can be called. The visibility determines whether a\nfunction can be called externally by users, by other derived contracts,\nonly internally, or only externally. There are four visibility\nspecifiers, which are described in detail in the http://bit.ly/2ABiv7j[Solidity docs]. Functions default to `public`, allowing users to call them\nexternally. We shall now see how incorrect use of visibility specifiers can lead to some devastating vulnerabilities in smart contracts.\n\n[role=\"notoc\"]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Default Visibilities"}}
{"input": "Explain the Ethereum concept: The Vulnerability", "output": "(((\"default visibility specifier security problem\",\"vulnerability\")))The default visibility for functions is `public`, so functions\nthat do not specify their visibility will be callable by external users.\nThe issue arises when developers mistakenly omit visibility specifiers\non functions that should be private (or only callable within the\ncontract itself).\n\nLet's quickly explore a trivial example:\n\n[source,solidity,linenums]\n----\ncontract HashForEther {\n\n    function withdrawWinnings() {\n        // Winner if the last 8 hex characters of the address are 0\n        require(uint32(msg.sender) == 0);\n        _sendWinnings();\n     }\n\n     function _sendWinnings() {\n         msg.sender.transfer(this.balance);\n     }\n}\n----\n\nThis simple contract is designed to act as an address-guessing bounty\ngame. To win the balance of the contract, a user must generate an\nEthereum address whose last 8 hex characters are +0+. Once achieved, they\ncan call the `withdrawWinnings` function to obtain their bounty.\n\nUnfortunately, the visibility of the functions has not been specified.\nIn particular, the `_sendWinnings` function is `public` (the default), and thus any\naddress can call this function to steal the bounty.\n\n[role=\"notoc\"]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "The Vulnerability"}}
{"input": "Explain the Ethereum concept: Preventative Techniques", "output": "(((\"default visibility specifier security problem\",\"preventative techniques\")))It is good practice to always specify the visibility of all functions in\na contract, even if they are intentionally `public`. Recent versions of\n+solc+ show a warning for functions that\nhave no explicit visibility set, to encourage this practice.", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Preventative Techniques"}}
{"input": "Explain the Ethereum concept: Real-World Example: Parity Multisig Wallet (First Hack)", "output": "(((\"default visibility specifier security problem\",\"real world example: Parity Multisig Wallet hack\")))(((\"Parity Multisig Wallet\",\"first hack\")))(((\"wallets\",\"Parity Multisig Wallet hacks\")))In the first Parity multisig hack, about $31M worth of Ether was stolen,\nmostly from three wallets. A good recap of exactly how this was done\nis given by https://bit.ly/2vHiuJQ[Haseeb Qureshi].\n\nEssentially, the multisig wallet\nis constructed from a base `Wallet` contract, which calls a library\ncontract containing the core functionality (as described in\n<<multisig_secondhack>>).\nThe library contract contains the code to initialize the wallet, as can\nbe seen from the following snippet:\n\n[source,solidity,linenums]\n----\ncontract WalletLibrary is WalletEvents {\n\n  ...\n\n  // METHODS\n\n  ...\n\n  // constructor is given number of sigs required to do protected\n  // \"onlymanyowners\" transactions as well as the selection of addresses\n  // capable of confirming them\n  function initMultiowned(address[] _owners, uint _required) {\n    m_numOwners = _owners.length + 1;\n    m_owners[1] = uint(msg.sender);\n    m_ownerIndex[uint(msg.sender)] = 1;\n    for (uint i = 0; i < _owners.length; ++i)\n    {\n      m_owners[2 + i] = uint(_owners[i]);\n      m_ownerIndex[uint(_owners[i])] = 2 + i;\n    }\n    m_required = _required;\n  }\n\n  ...\n\n  // constructor - just pass on the owner array to multiowned and\n  // the limit to daylimit\n  function initWallet(address[] _owners, uint _required, uint _daylimit) {\n    initDaylimit(_daylimit);\n    initMultiowned(_owners, _required);\n  }\n}\n----\n\nNote that neither of the functions specifies their\nvisibility, so both default to `public`. The `initWallet`\nfunction is called in the wallet's constructor, and sets the owners for\nthe multisig wallet as can be seen in the `initMultiowned` function.\nBecause these functions were accidentally left `public`, an attacker was\nable to call these functions on deployed contracts, resetting the\nownership to the attacker's address. Being the owner, the attacker then\ndrained the wallets of all their ether.(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc26\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc25\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc24\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc23\")))\n\n[[entropyillusion_security]]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Real-World Example: Parity Multisig Wallet (First Hack)"}}
{"input": "Explain the Ethereum concept: Entropy Illusion", "output": "(((\"entropy illusion security threat\")))(((\"security (smart contracts)\",\"entropy illusion threat\")))All transactions on the Ethereum blockchain are deterministic state\ntransition operations. This means that every transaction modifies the\nglobal state of the Ethereum ecosystem in a calculable\nway, with no uncertainty. This has the fundamental implication that\nthere is no source of entropy or randomness in Ethereum.\nAchieving decentralized entropy\n(randomness) is a well-known problem for which many solutions have been proposed, including https://github.com/randao/randao[RANDAO], or using a chain of hashes, as\ndescribed by Vitalik Buterin in the blog post\nhttps://vitalik.ca/files/randomness.html[&#x201c;Validator Ordering and Randomness in PoS&#x201d;].\n\n[role=\"notoc\"]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Entropy Illusion"}}
{"input": "Explain the Ethereum concept: The Vulnerability", "output": "(((\"entropy illusion security threat\",\"vulnerability\")))Some of the first contracts built on the Ethereum platform were based\naround gambling. Fundamentally, gambling requires uncertainty (something\nto bet on), which makes building a gambling system on the blockchain (a\ndeterministic system) rather difficult. It is clear that the uncertainty\nmust come from a source external to the blockchain. This is possible for\nbets between players (see for example the http://bit.ly/2CUh2KS[commit&#x2013;reveal technique]); however, it is significantly more difficult if you want to\nimplement a contract to act as &#x201c;the house&#x201d; (like in blackjack or\nroulette). A common pitfall is to use future block variables&#x2014;that is,\nvariables containing information about the transaction block whose values are not yet known, such as\nhashes, timestamps, block numbers, or gas limits. The issue with these are\nthat they are controlled by the miner who mines the block, and as such\nare not truly random. Consider, for example, a roulette smart contract\nwith logic that returns a black number if the next block hash ends in an\neven number. A miner (or miner pool) could bet $1M on black. If they\nsolve the next block and find the hash ends in an odd number, they could\nhappily not publish their block and mine another, until they find a\nsolution with the block hash being an even number (assuming the block\nreward and fees are less than $1M). Using past or present variables can\nbe even more devastating, as Martin Swende demonstrates in his excellent http://martin.swende.se/blog/Breaking_the_house.html[blog post].\nFurthermore, using solely block variables means that the pseudorandom\nnumber will be the same for all transactions in a block, so an attacker\ncan multiply their wins by doing many transactions within a block\n(should there be a maximum bet).\n\n[role=\"notoc\"]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "The Vulnerability"}}
{"input": "Explain the Ethereum concept: Preventative Techniques", "output": "(((\"entropy illusion security threat\",\"preventative techniques\")))The source of entropy (randomness) must be external to the blockchain.\nThis can be done among peers with systems such as\nhttp://bit.ly/2CUh2KS[commit\u2013reveal],\nor via changing the trust model to a group of participants (as in\nhttps://github.com/randao/randao[RandDAO]). This can also be done via a\ncentralized entity that acts as a randomness oracle. Block variables\n(in general, there are some exceptions) should not be used to source\nentropy, as they can be manipulated by miners.", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Preventative Techniques"}}
{"input": "Explain the Ethereum concept: Real-World Example: PRNG Contracts", "output": "(((\"entropy illusion security threat\",\"real world example: PRNG contracts\")))(((\"PRNG (pseudorandom number generator) contracts\")))(((\"pseudorandom number generator (PRNG) contracts\")))In February 2018 Arseny Reutov\nhttp://bit.ly/2Q589lx[blogged] about his analysis of 3,649 live smart contracts that were using some\nsort of pseudorandom number generator (PRNG); he found 43 contracts\nthat could be exploited.\n\n[[external_contract_referencing]]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Real-World Example: PRNG Contracts"}}
{"input": "Explain the Ethereum concept: External Contract Referencing", "output": "(((\"external contract referencing security threat\", id=\"ix_09smart-contracts-security-asciidoc27\", range=\"startofrange\")))(((\"security (smart contracts)\",\"external contract referencing threat\", id=\"ix_09smart-contracts-security-asciidoc28\", range=\"startofrange\")))One of the benefits of the Ethereum &#x201c;world computer&#x201d; is the ability to\nreuse code and interact with contracts already deployed on the network.\nAs a result, a large number of contracts reference external contracts,\nusually via external message calls.\nThese external message calls can mask malicious actors'\nintentions in some nonobvious ways, which we'll now examine.\n\n[role=\"notoc\"]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "External Contract Referencing"}}
{"input": "Explain the Ethereum concept: The Vulnerability", "output": "(((\"external contract referencing security threat\",\"vulnerability\", id=\"ix_09smart-contracts-security-asciidoc29\", range=\"startofrange\")))In Solidity, any address can be cast to a contract, regardless of whether\nthe code at the address represents the contract type being cast. This\ncan cause problems, especially when the author of the contract is trying\nto hide malicious code. Let's illustrate this with an example.\n\nConsider a piece of code like <<rot13_security>>, which rudimentarily implements the\nhttps://en.wikipedia.org/wiki/ROT13[ROT13 cipher].\n\n[[rot13_security]]\n.Rot13Encryption.sol", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "The Vulnerability"}}
{"input": "Explain the Ethereum concept: Preventative Techniques", "output": "(((\"external contract referencing security threat\",\"preventative techniques\")))As demonstrated previously, safe contracts can (in some cases)\nbe deployed in such a way that they behave maliciously. An auditor could\npublicly verify a contract and have its owner deploy it in a malicious\nway, resulting in a publicly audited contract that has vulnerabilities\nor malicious intent.\n\nThere are a number of techniques that prevent these scenarios.\n\nOne technique is to use the `new` keyword to create contracts. In the\npreceding example, the constructor could be written as:\n\n[source,solidity]\n----\nconstructor() {\n    encryptionLibrary = new Rot13Encryption();\n}\n----\n\nThis way an instance of the referenced contract is created at deployment\ntime, and the deployer cannot replace the `Rot13Encryption` contract\nwithout changing it.\n\nAnother solution is to hardcode external contract addresses.\n\nIn general, code that calls external contracts should always be\naudited carefully. As a developer, when defining external contracts, it can\nbe a good idea to make the contract addresses public (which is not the\ncase in the honey-pot example in the following section) to allow users to easily examine\ncode referenced by the contract. Conversely, if a contract has\na private variable contract address it can be a sign of someone behaving\nmaliciously (as shown in the real-world example). If a user can change\na contract address that is used to\ncall external functions, it can be important (in a decentralized system\ncontext) to implement a time-lock and/or voting mechanism to allow users to\nsee what code is being changed, or to give participants a chance to opt\nin/out with the new contract address.", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Preventative Techniques"}}
{"input": "Explain the Ethereum concept: Real-World Example: Reentrancy Honey Pot", "output": "(((\"external contract referencing security threat\",\"real-world example: reentrancy honey pot\", id=\"ix_09smart-contracts-security-asciidoc30\", range=\"startofrange\")))(((\"honey pots\", id=\"ix_09smart-contracts-security-asciidoc31\", range=\"startofrange\")))(((\"reentrancy honey pot security threat\", id=\"ix_09smart-contracts-security-asciidoc32\", range=\"startofrange\")))A number of recent honey pots have been released on the mainnet. These\ncontracts try to outsmart Ethereum hackers who try to exploit the\ncontracts, but who in turn end up losing ether to the contract\nthey expect to exploit. One example employs this attack by\nreplacing an expected contract with a malicious one in the constructor.\nThe code can be found\nhttp://bit.ly/2JtdqRi[here]:\n\n[source,solidity,linenums]\n----\npragma solidity ^0.4.19;\n\ncontract Private_Bank\n{\n    mapping (address => uint) public balances;\n    uint public MinDeposit = 1 ether;\n    Log TransferLog;\n\n    function Private_Bank(address _log)\n    {\n        TransferLog = Log(_log);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _am)\n    {\n        if(_am<=balances[msg.sender])\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n\n    function() external payable{}\n\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}\n----\n\nThis\nhttp://bit.ly/2Q58VyX[post]\nby one reddit user explains how they lost 1 ether to this contract\nby trying to exploit the reentrancy bug they expected to be present in the\ncontract(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc32\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc31\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc30\"))).(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc28\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc27\")))", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Real-World Example: Reentrancy Honey Pot"}}
{"input": "Explain the Ethereum concept: Short Address/Parameter Attack", "output": "(((\"security (smart contracts)\",\"short address/parameter attack\")))(((\"short address/parameter attack\")))This attack is not performed on Solidity contracts\nthemselves, but on third-party applications that may interact with them. This\nsection is added for completeness and to give the reader an awareness of how parameters can be\nmanipulated in contracts.\n\nFor further reading, see\nhttp://bit.ly/2yKme14[&#x201c;The ERC20\nShort Address Attack Explained&#x201d;],\nhttp://bit.ly/2yFOGRQ[&#x201c;ICO\nSmart Contract Vulnerability: Short Address Attack&#x201d;], or this\nhttp://bit.ly/2CQjBhc[Reddit\npost].\n\n[role=\"notoc\"]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Short Address/Parameter Attack"}}
{"input": "Explain the Ethereum concept: The Vulnerability", "output": "(((\"short address/parameter attack\",\"vulnerability\")))When passing parameters to a smart contract, the parameters are encoded\naccording to the\nhttp://bit.ly/2Q5VIG9[ABI\nspecification]. It is possible to send encoded parameters that are\nshorter than the expected parameter length (for example, sending an\naddress that is only 38 hex chars (19 bytes) instead of the standard 40\nhex chars (20 bytes)). In such a scenario, the EVM will add zeros to the\nend of the encoded parameters to make up the expected length.\n\nThis becomes an issue when third-party applications do not validate\ninputs. The clearest example is an exchange that doesn\u2019t verify the\naddress of an\nERC20 token\nwhen a user requests a withdrawal. This example is covered in more\ndetail in Peter Vessenes\u2019s post,\nhttp://bit.ly/2Q1ybpQ[&#x201c;The ERC20\nShort Address Attack Explained&#x201d;].\n\nConsider the standard\nhttp://bit.ly/2CUf7WG[ERC20]\n+transfer+ function interface, noting the order of the parameters:\n\n[source,solidity]\n----\nfunction transfer(address to, uint tokens) public returns (bool success);\n----\n\nNow consider an exchange holding a large amount of a token (let\u2019s say\n`REP`) and a user who wishes to withdraw their share of 100 tokens. The user\nwould submit their address, `0xdeaddeaddeaddeaddeaddeaddeaddeaddeaddead`,\nand the number of tokens, `100`. The exchange would encode these\nparameters in the order specified by the pass:[<code><span class=\"keep-together\">transfer</span></code>] function; that is,\n`address` then `tokens`. The encoded result would be:\n\n----\na9059cbb000000000000000000000000deaddeaddea \\\nddeaddeaddeaddeaddeaddeaddead0000000000000\n000000000000000000000000000000000056bc75e2d63100000\n----\n\nThe first 4\nbytes (`a9059cbb`) are the `transfer`\nhttp://bit.ly/2RmueMP[function\nsignature/selector], the next 32 bytes are the address, and\nthe final 32 bytes represent the `uint256` number of tokens.\nNotice that the hex `56bc75e2d63100000` at the end corresponds to 100\ntokens (with 18 decimal places, as specified by the `REP` token\npass:[<span class=\"keep-together\">contract</span>]).\n\nLet us now look at what would happen if one were to send an address that\nwas missing 1 byte (2 hex digits). Specifically, let\u2019s say an attacker\nsends `0xdeaddeaddeaddeaddeaddeaddeaddeaddeadde` as an address (missing\nthe last two digits) and the same `100` tokens to withdraw. If the\nexchange does not validate this input, it will get encoded as:\n\n----\na9059cbb000000000000000000000000deaddeaddea \\\nddeaddeaddeaddeaddeaddeadde00000000000000\n00000000000000000000000000000000056bc75e2d6310000000\n----\n\nThe difference\nis subtle. Note that `00` has been added to the end of the encoding, to\nmake up for the short address that was sent. When this gets sent to the\nsmart contract, the `address` parameters will be read as\n`0xdeaddeaddeaddeaddeaddeaddeaddeaddeadde00` and the value will be read\nas `56bc75e2d6310000000` (notice the two extra ++0++s). This value is\nnow `25600` tokens (the value has been multiplied by `256`). In this\nexample, if the exchange held this many tokens, the user would withdraw\n`25600` tokens (while the exchange thinks the user is only withdrawing\n`100`) to the modified address. Obviously the attacker won't possess the\nmodified address in this example, but if the attacker were to generate\nany address that ended in ++0++s (which can be easily brute-forced) and\nused this generated address, they could steal tokens from the\nunsuspecting exchange.\n\n[role=\"notoc\"]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "The Vulnerability"}}
{"input": "Explain the Ethereum concept: Preventative Techniques", "output": "(((\"short address/parameter attack\",\"preventative techniques\")))All input parameters in external applications should be validated before\nsending them to the blockchain. It should\nalso be noted that parameter ordering plays an important role here. As padding\nonly occurs at the end, careful ordering of parameters in the smart contract\ncan mitigate some forms of this attack.", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Preventative Techniques"}}
{"input": "Explain the Ethereum concept: Unchecked CALL Return Values", "output": "(((\"calls, external\", id=\"ix_09smart-contracts-security-asciidoc33\", range=\"startofrange\")))(((\"external calls\", id=\"ix_09smart-contracts-security-asciidoc34\", range=\"startofrange\")))(((\"security (smart contracts)\",\"unchecked CALL return value threat\", id=\"ix_09smart-contracts-security-asciidoc35\", range=\"startofrange\")))(((\"unchecked CALL return value security threat\", id=\"ix_09smart-contracts-security-asciidoc36\", range=\"startofrange\")))There are a number of ways of performing external calls in Solidity. Sending\nether to external accounts is commonly performed via the `transfer` method.\nHowever, the `send` function can also be used, and for more versatile\nexternal calls the `CALL` opcode can be directly employed in Solidity.\nThe `call` and `send` functions return a Boolean indicating whether the\ncall succeeded or failed. Thus, these functions have a simple caveat, in\nthat the transaction that executes these functions will not revert if\nthe external call (intialized by `call` or `send`) fails; rather, the\nfunctions will simply return `false`. A common error is\nthat the developer expects a revert to occur if the external call fails, and does not check the return value.\n\nFor further reading, see #4 on the http://www.dasp.co/#item-4[DASP Top 10 of 2018] and\nhttp://bit.ly/2RnS1vA[&#x201c;Scanning\nLive Ethereum Contracts for the &lsquo;Unchecked-Send&rsquo; Bug&#x201d;].\n\n[role=\"notoc\"]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Unchecked CALL Return Values"}}
{"input": "Explain the Ethereum concept: The Vulnerability", "output": "(((\"unchecked CALL return value security threat\",\"vulnerability\")))Consider the following example:\n\n[source,solidity,linenums]\n----\ncontract Lotto {\n\n    bool public payedOut = false;\n    address public winner;\n    uint public winAmount;\n\n    // ... extra functionality here\n\n    function sendToWinner() public {\n        require(!payedOut);\n        winner.send(winAmount);\n        payedOut = true;\n    }\n\n    function withdrawLeftOver() public {\n        require(payedOut);\n        msg.sender.send(this.balance);\n    }\n}\n----\n\nThis represents a Lotto-like contract, where a `winner`\nreceives `winAmount` of ether, which typically leaves a little left over\nfor anyone to withdraw.\n\nThe vulnerability exists on line 11, where a `send` is used without checking\nthe response. In this trivial example, a `winner` whose transaction\nfails (either by running out of gas or by being a contract that intentionally\nthrows in the fallback function) allows `payedOut` to be set to `true` regardless\nof whether ether was sent or not. In this case, anyone can withdraw\nthe `winner`\u2019s winnings via the `withdrawLeftOver` function.\n\n[role=\"notoc\"]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "The Vulnerability"}}
{"input": "Explain the Ethereum concept: Preventative Techniques", "output": "(((\"unchecked CALL return value security threat\",\"preventative techniques\")))Whenever possible, use the `transfer` function rather than `send`, as\n`transfer` will revert if the external transaction reverts. If\n`send` is required, always check the return value.\n\nA more robust\nhttp://bit.ly/2CSdF7y[recommendation]\nis to adopt a _withdrawal pattern_. In this solution, each user must\ncall an isolated +withdraw+ function\nthat handles the sending of ether out of the contract and\ndeals with the consequences of failed send transactions.\nThe idea is to logically isolate the external send functionality from\nthe rest of the codebase, and place the burden of a potentially failed\ntransaction on the end user calling the +withdraw+ function.", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Preventative Techniques"}}
{"input": "Explain the Ethereum concept: Real-World Example: Etherpot and King of the Ether", "output": "http://bit.ly/2OfHalK[Etherpot] was (((\"Etherpot smart contract lottery\")))(((\"King of the Ether\")))(((\"unchecked CALL return value security threat\",\"real-world example: Etherpot and King of the Ether\")))a smart contract lottery, not\ntoo dissimilar to the example contract mentioned earlier.\nThe downfall of this contract was primarily due to incorrect use of\nblock hashes (only the last 256 block hashes are usable; see Aakil\nFernandes\u2019s\nhttp://bit.ly/2Jpzf4x[post]\nabout how Etherpot failed to take account of this correctly). However, this\ncontract also suffered from an unchecked call value. Consider the\nfunction `cash` in <<lotto_security>>.\n\n[[lotto_security]]\n.lotto.sol: Code snippet", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Real-World Example: Etherpot and King of the Ether"}}
{"input": "Explain the Ethereum concept: Race Conditions/Front Running", "output": "(((\"front-running attacks\", id=\"ix_09smart-contracts-security-asciidoc37\", range=\"startofrange\")))(((\"security (smart contracts)\",\"race conditions/front running threat\", id=\"ix_09smart-contracts-security-asciidoc38\", range=\"startofrange\")))The (((\"race conditions\", seealso=\"front-running security threat; reentrancy attack\")))combination of external calls to other contracts and the multiuser\nnature of the underlying blockchain gives rise to a variety of potential\nSolidity pitfalls whereby users _race_ code execution to obtain\nunexpected states. Reentrancy (discussed earlier in this chapter) is one example of such\na race condition. In this section we will discuss\nother kinds of race conditions that can occur on the Ethereum\nblockchain. There are a variety of good posts on this subject, including\n&#x201c;Race Conditions&#x201d; on the http://bit.ly/2yFesFF[Ethereum\nWiki], http://www.dasp.co/#item-7[#7 on the DASP Top10 of 2018], and the\nhttp://bit.ly/2Q6E4lP[Ethereum Smart Contract Best Practices].\n\n[role=\"notoc\"]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Race Conditions/Front Running"}}
{"input": "Explain the Ethereum concept: The Vulnerability", "output": "(((\"front-running attacks\",\"vulnerability\")))As with most blockchains, Ethereum nodes pool transactions and form them\ninto blocks. The transactions are only considered valid once a miner has\nsolved a consensus mechanism (currently\nhttp://bit.ly/2yI5Dv7[Ethash] PoW for Ethereum).\nThe miner who solves the block also chooses which transactions from the\npool will be included in the block, typically ordered by the\n`gasPrice` of each transaction. Here is a potential attack vector. An\nattacker can watch the transaction pool for transactions that may\ncontain solutions to problems, and modify or revoke the solver's\npermissions or change state in a contract detrimentally to the\nsolver. The attacker can then get the data from this transaction and\ncreate a transaction of their own with a higher `gasPrice` so their\ntransaction is included in a block before the original.\n\nLet\u2019s see how this could work with a simple example. Consider the\ncontract shown in <<findthishash_security>>.\n\n[[findthishash_security]]\n.FindThisHash.sol", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "The Vulnerability"}}
{"input": "Explain the Ethereum concept: Preventative Techniques", "output": "(((\"front-running attacks\",\"preventative techniques\")))There are two classes of actor who can perform these kinds of\nfront-running attacks: users (who modify the `gasPrice` of their\ntransactions) and miners themselves (who can reorder the transactions\nin a block how they see fit). A contract that is vulnerable to the first\nclass (users) is significantly worse off than one vulnerable to the\nsecond (miners), as miners can only perform the attack when they solve a\nblock, which is unlikely for any individual miner targeting a specific\nblock. Here we\u2019ll list a few mitigation measures relative to both\nclasses of attackers.\n\nOne method is to place an upper bound on the `gasPrice`.\nThis prevents users from\nincreasing the `gasPrice` and getting preferential transaction ordering\nbeyond the upper bound. This measure only guards against the\nfirst class of attackers (arbitrary users). Miners in this scenario can\nstill attack the contract, as they can order the transactions in their\nblock however they like, regardless of gas price.\n\nA more robust method is to use a\nhttp://bit.ly/2CUh2KS[commit\u2013reveal]\nscheme. Such a scheme dictates that users send\ntransactions with hidden information (typically a hash). After the\ntransaction has been included in a block, the user sends a transaction\nrevealing the data that was sent (the reveal phase). This method\nprevents both miners and users from front-running transactions, as they\ncannot determine the contents of the transaction. This method, however,\ncannot conceal the transaction value (which in some cases is the\nvaluable information that needs to be hidden). The\nhttps://ens.domains/[ENS] smart contract allowed users to send\ntransactions whose committed data included the amount of ether they\nwere willing to spend. Users could then send transactions of arbitrary\nvalue. During the reveal phase, users were refunded the difference\nbetween the amount sent in the transaction and the amount they were\nwilling to spend.\n\nA further suggestion by (((\"submarine sends\")))Lorenz Breidenbach, Phil Daian, Ari Juels, and Florian Tram\u00e8r is to use\nhttp://bit.ly/2SygqQx[&#x201c;submarine\nsends&#x201d;]. An efficient implementation of this idea requires the `CREATE2`\nopcode, which currently hasn\u2019t been adopted but seems likely to be in\nupcoming hard forks.", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Preventative Techniques"}}
{"input": "Explain the Ethereum concept: Real-World Examples: ERC20 and Bancor", "output": "(((\"ERC20 token standard\",\"front-running vulnerability\")))(((\"front-running attacks\",\"real-world examples: ERC 20 and Bancor\")))The http://bit.ly/2CUf7WG[ERC20\nstandard] is quite well-known for building tokens on Ethereum. This\nstandard has a potential front-running vulnerability that comes about\ndue to the `approve` function. http://bit.ly/2DbvQpJ[Mikhail Vladimirov and Dmitry Khovratovich] have written a good explanation of this\nvulnerability (and ways to mitigate the attack).\n\nThe standard specifies the `approve` function as:\n\n[source,solidity]\n----\nfunction approve(address _spender, uint256 _value) returns (bool success)\n----\n\nThis function allows a user to permit other users to transfer tokens on\ntheir behalf. The front-running vulnerability occurs in the scenario where\na user Alice _approves_ her friend Bob to spend 100 tokens. Alice\nlater decides that she wants to revoke Bob\u2019s approval to spend, say,\n100 tokens, so she creates a transaction that sets Bob\u2019s allocation\nto 50 tokens. Bob, who has been carefully watching the chain, sees\nthis transaction and builds a transaction of his own spending the\n100 tokens. He puts a higher `gasPrice` on his transaction than\nAlice's, so gets his transaction prioritized over hers. Some\nimplementations of `approve` would allow Bob to transfer his\n100 tokens and then, when Alice\u2019s transaction is committed, reset\nBob\u2019s approval to 50 tokens, in effect giving Bob access to\n150 tokens.\n\n(((\"Bancor\")))Another prominent real-world example is\nhttps://www.bancor.network/[Bancor]. Ivan Bogatyy and his team\ndocumented a profitable attack on the initial Bancor implementation. His\nhttp://bit.ly/2EUlLzb[blog\npost] and http://bit.ly/2yHgkhs[DevCon3 talk]\ndiscuss in detail how this was done. Essentially, prices of tokens are\ndetermined based on transaction value; users can watch the transaction\npool for Bancor transactions and front-run them to profit from the price\ndifferences. This attack has been addressed by the Bancor team.(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc38\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc37\")))", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Real-World Examples: ERC20 and Bancor"}}
{"input": "Explain the Ethereum concept: Denial of Service (DoS)", "output": "(((\"denial of service (DoS) attacks\", id=\"ix_09smart-contracts-security-asciidoc39\", range=\"startofrange\")))(((\"security (smart contracts)\",\"denial of service attacks\", id=\"ix_09smart-contracts-security-asciidoc40\", range=\"startofrange\")))This category is very broad, but fundamentally consists of attacks where\nusers can render a contract inoperable for a period of time, or\nin some cases permanently. This can trap ether in these contracts\nforever, as was the case in <<multisig_secondhack>>.\n\n[role=\"notoc\"]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Denial of Service (DoS)"}}
{"input": "Explain the Ethereum concept: The Vulnerability", "output": "(((\"denial of service (DoS) attacks\",\"vulnerability\")))There are various ways a contract can become inoperable. Here we\nhighlight just a few less-obvious Solidity\ncoding patterns that can lead to DoS vulnerabilities:\n\nLooping through externally manipulated mappings or arrays::\nThis pattern typically appears when an owner wishes to distribute tokens\nto investors with a `distribute`-like function,\nas in this example contract:\n+\n[source,solidity,linenums]\n----\ncontract DistributeTokens {\n    address public owner; // gets set somewhere\n    address[] investors; // array of investors\n    uint[] investorTokens; // the amount of tokens each investor gets\n\n    // ... extra functionality, including transfertoken()\n\n    function invest() external payable {\n        investors.push(msg.sender);\n        investorTokens.push(msg.value * 5); // 5 times the wei sent\n        }\n\n    function distribute() public {\n        require(msg.sender == owner); // only owner\n        for(uint i = 0; i < investors.length; i++) {\n            // here transferToken(to,amount) transfers \"amount\" of \n            // tokens to the address \"to\"\n            transferToken(investors[i],investorTokens[i]);\n        }\n    }\n}\n----\n+\nNotice that the loop in this contract runs over an array that can be\nartificially inflated. An attacker can create many user accounts, making\nthe `investor` array large. In principle this can be done such that the\ngas required to execute the +for+ loop exceeds the block gas limit,\nessentially making the `distribute` function inoperable.\n\nOwner operations::\n(((\"Initial Coin Offerings (ICOs)\",\"DoS attacks and\")))Another common pattern is where owners have\nspecific privileges in contracts and must perform some task in order for\nthe contract to proceed to the next state. One example would be an Initial Coin Offering (ICO)\ncontract that requires the owner to `finalize` the contract, which then\nallows tokens to be transferable. For example:\n+\n[source,solidity,linenums]\n----\nbool public isFinalized = false;\naddress public owner; // gets set somewhere\n\nfunction finalize() public {\n    require(msg.sender == owner);\n    isFinalized = true;\n}\n\n// ... extra ICO functionality\n\n// overloaded transfer function\nfunction transfer(address _to, uint _value) returns (bool) {\n    require(isFinalized);\n    super.transfer(_to,_value)\n}\n\n...\n----\n+\nIn such cases, if the privileged user loses their private keys or becomes\ninactive, the entire token contract becomes inoperable. In this case, if\nthe owner cannot call pass:[<span class=\"keep-together\"><code>finalize</code></span>] no tokens can be transferred;\nthe entire operation of the token ecosystem hinges on a single\naddress.\n\nProgressing state based on external calls:: Contracts are sometimes written\nsuch that progressing to a new state requires sending ether to an\naddress, or waiting for some input from an external source.  These patterns can\nlead to DoS attacks when the external call fails or is prevented for external\nreasons. In the example of sending ether, a user can create a contract that\ndoes not accept ether. If a contract requires ether to be withdrawn in order to progress to a new state (consider a\ntime-locking contract that requires all ether to be withdrawn before being\nusable again), the contract will never\nachieve the new state, as ether can never be sent to the user's contract that\ndoes not accept ether.\n\n[role=\"notoc\"]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "The Vulnerability"}}
{"input": "Explain the Ethereum concept: Preventative Techniques", "output": "(((\"denial of service (DoS) attacks\",\"preventative techniques\")))In the first example, contracts should not loop through data structures\nthat can be artificially manipulated by external users. A withdrawal\npattern is recommended, whereby each of the investors call a +withdraw+\nfunction to claim tokens independently.\n\nIn the second example, a privileged user was required to change the state\nof the contract. In such examples a failsafe can be\nused in the event that the owner becomes incapacitated. One solution\nis to make the owner a multisig contract. Another solution\nis to use a time-lock: in the example given the +require+ on line 5 could include a\ntime-based mechanism, such as\n`require(msg.sender == owner || now > unlockTime)`, that allows any user\nto finalize after a period of time specified by `unlockTime`. This kind\nof mitigation technique can be used in the third example also. If\nexternal calls are required to progress to a new state, account for\ntheir possible failure and potentially add a time-based state\nprogression in the event that the desired call never comes.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Preventative Techniques"}}
{"input": "Explain the Ethereum concept: Real-World Examples: GovernMental", "output": "http://governmental.github.io/GovernMental/[GovernMental] (((\"denial of service (DoS) attacks\",\"real-world example: GovernMental\")))(((\"GovernMental Ponzi scheme\",\"DoS vulnerability\")))was an old\nPonzi scheme that accumulated quite a large amount of ether (1,100 ether, at one point). Unfortunately, it was\nsusceptible to the DoS vulnerabilities mentioned in this section. A http://bit.ly/2DcgvFc[Reddit post] by etherik describes how the contract required the deletion of a large\nmapping in order to withdraw the ether. The deletion of this mapping had\na gas cost that exceeded the block gas limit at the time, and thus it was\nnot possible to withdraw the 1,100 ether. The contract address is\nhttp://bit.ly/2Oh8j7R[+0xF45717552f12Ef7cb65e95476F217Ea008167Ae3+],\nand you can see from transaction http://bit.ly/2Ogzrnn[+0x0d80d67202bd9cb6773df8dd2020e719&thinsp;0a1b0793e8ec4fc105257e8128f0506b+] that the 1,100 ether were finally obtained with a transaction that used\n2.5M gas (when the block gas limit had risen enough to allow such a transaction).(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc40\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc39\")))", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Real-World Examples: GovernMental"}}
{"input": "Explain the Ethereum concept: Block Timestamp Manipulation", "output": "(((\"block timestamp manipulation security threat\", id=\"ix_09smart-contracts-security-asciidoc41\", range=\"startofrange\")))(((\"security (smart contracts)\",\"block timestamp manipulation threat\", id=\"ix_09smart-contracts-security-asciidoc42\", range=\"startofrange\")))Block timestamps have historically been used for a variety of\napplications, such as entropy for random numbers (see the\n<<entropyillusion_security>> for further details), locking\nfunds for periods of time, and various state-changing conditional\nstatements that are time-dependent. Miners have the ability to adjust\ntimestamps slightly, which can prove to be dangerous if block\ntimestamps are used incorrectly in smart contracts.\n\nUseful references for this include\nhttp://bit.ly/2OdUC9C[the\nSolidity docs] and http://bit.ly/2CQ8gh4[Joris Bontje's Ethereum Stack\nExchange question] on the topic.\n\n[role=\"notoc\"]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Block Timestamp Manipulation"}}
{"input": "Explain the Ethereum concept: The Vulnerability", "output": "(((\"block timestamp manipulation security threat\",\"vulnerability\")))`block.timestamp` and its alias `now` can be manipulated by miners if\nthey have some incentive to do so. Let's construct a simple game, shown in <<roulette_security>>, that\nwould be vulnerable to miner exploitation.\n\n[[roulette_security]]\n.roulette.sol", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "The Vulnerability"}}
{"input": "Explain the Ethereum concept: Preventative Techniques", "output": "(((\"block timestamp manipulation security threat\",\"preventative techniques\")))Block timestamps should not be used for entropy or generating random\nnumbers&#x2014;i.e., they should not be the deciding factor (either directly\nor through some derivation) for winning a game or changing an important\nstate.\n\nTime-sensitive logic is sometimes required; e.g., for unlocking contracts\n(time-locking), completing an ICO after a few weeks, or enforcing expiry\ndates. It is sometimes recommended to use http://bit.ly/2OdUC9C[`block.number`] and an average block time to estimate times; with\na `10 second` block time, `1 week` equates to approximately, `60480 blocks`.\nThus, specifying a block number at which to change a contract state can\nbe more secure, as miners are unable to easily manipulate the block number. The\nhttp://bit.ly/2AAebFr[BAT\nICO] contract employed this strategy.\n\nThis can be unnecessary if contracts aren\u2019t particularly concerned with\nminer manipulations of the block timestamp, but it is something to be\naware of when developing contracts.", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Preventative Techniques"}}
{"input": "Explain the Ethereum concept: Real-World Example: GovernMental", "output": "http://governmental.github.io/GovernMental/[GovernMental], (((\"block timestamp manipulation security threat\",\"real-world example: GovernMental\")))(((\"GovernMental Ponzi scheme\",\"block timestamp-based attack\")))the old Ponzi scheme mentioned above, was also\nvulnerable to a timestamp-based attack. The contract paid out to the\nplayer who was the last player to join (for at least one minute) in a\nround. Thus, a miner who was a player could adjust the timestamp (to a\nfuture time, to make it look like a minute had elapsed) to make it\nappear that they were the last player to join for over a minute (even\nthough this was not true in reality). More detail on this can be found in\nthe\nhttp://bit.ly/2Q1AMA6[&#x201c;History\nof Ethereum Security Vulnerabilities, Hacks and Their Fixes&#x201d; post] by Tanya pass:[<span class=\"keep-together\">Bahrynovska</span>].(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc42\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc41\")))", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Real-World Example: GovernMental"}}
{"input": "Explain the Ethereum concept: Constructors with Care", "output": "(((\"constructor function\",\"contract name modification security threat\")))(((\"security (smart contracts)\",\"constructors and contract name-change threat\")))Constructors are special functions that often perform critical,\nprivileged tasks when initializing contracts. Before Solidity v0.4.22,\nconstructors were defined as functions that had the same name as the\ncontract that contained them. In such cases, when the contract name is changed in\ndevelopment, if the constructor name isn\u2019t changed too it becomes a normal,\ncallable function. As you can imagine, this can lead (and has) to some\ninteresting contract hacks.\n\nFor further insight, the reader may be interested in attempting the\nhttps://github.com/OpenZeppelin/ethernaut[Ethernaut challenges] (in\nparticular the Fallout level).\n\n[role=\"notoc\"]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Constructors with Care"}}
{"input": "Explain the Ethereum concept: The Vulnerability", "output": "(((\"constructor/contract name modification security threat\",\"vulnerability\")))(((\"contract name modification/constructor security threat\",\"vulnerability\")))If the contract name is modified, or there is a typo in the\nconstructor's name such that it does not match the name of the\ncontract, the constructor will behave like a normal function. This can\nlead to dire consequences, especially if the constructor performs\nprivileged operations. Consider the following contract:\n\n[source,solidity,linenums]\n----\ncontract OwnerWallet {\n    address public owner;\n\n    // constructor\n    function ownerWallet(address _owner) public {\n        owner = _owner;\n    }\n\n    // Fallback. Collect ether.\n    function () payable {}\n\n    function withdraw() public {\n        require(msg.sender == owner);\n        msg.sender.transfer(this.balance);\n    }\n}\n----\n\nThis contract collects ether and allows only the owner to withdraw it,\nby calling the `withdraw` function. The issue arises because the constructor is not named exactly the same as the contract:\nthe first letter is different! Thus, any\nuser can call the `ownerWallet` function, set themselves as the owner,\nand then take all the ether in the contract by calling `withdraw`.\n\n[role=\"notoc\"]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "The Vulnerability"}}
{"input": "Explain the Ethereum concept: Preventative Techniques", "output": "(((\"constructor/contract name modification security threat\",\"preventative techniques\")))(((\"contract name modification/constructor security threat\",\"preventative techniques\")))This issue has been addressed in version 0.4.22 of the Solidity compiler. This version introduced a `constructor` keyword that\nspecifies the constructor, rather than requiring the name of the\nfunction to match the contract name. Using this keyword to specify\nconstructors is recommended to prevent naming issues.", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Preventative Techniques"}}
{"input": "Explain the Ethereum concept: Real-World Example: Rubixi", "output": "http://bit.ly/2ESWG7t[Rubixi] (((\"constructor/contract name modification security threat\",\"real-world example: Rubixi\")))(((\"contract name modification/constructor security threat\",\"real-world example: Rubixi\")))(((\"Rubixi pyramid scheme\")))was another pyramid scheme that exhibited this kind of\nvulnerability. It was originally called `DynamicPyramid`, but the\ncontract name was changed before deployment to `Rubixi`. The\nconstructor\u2019s name wasn\u2019t changed, allowing any user to become the\ncreator. Some interesting discussion related to this bug can be found\non http://bit.ly/2P0TRWw[Bitcointalk]. Ultimately, it allowed users to fight for creator status to\nclaim the fees from the pyramid scheme. More detail on this particular\nbug can be found in http://bit.ly/2Q1AMA6[&#x201c;History of Ethereum Security Vulnerabilities, Hacks and Their Fixes&#x201d;].", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Real-World Example: Rubixi"}}
{"input": "Explain the Ethereum concept: Uninitialized Storage Pointers", "output": "(((\"security (smart contracts)\",\"uninitialized storage pointer threat\", id=\"ix_09smart-contracts-security-asciidoc43\", range=\"startofrange\")))(((\"storage pointers, uninitialized\", id=\"ix_09smart-contracts-security-asciidoc44\", range=\"startofrange\")))(((\"uninitialized storage pointers security threat\", id=\"ix_09smart-contracts-security-asciidoc45\", range=\"startofrange\")))The EVM stores data either as storage or as memory. Understanding\nexactly how this is done and the default types for local variables of\nfunctions is highly recommended when developing contracts. This is\nbecause it is possible to produce vulnerable contracts by\ninappropriately initializing variables.\n\nTo read more about storage and memory in the EVM, see the Solidity documentation on http://bit.ly/2OdUU0l[data location], http://bit.ly/2JslDWf[layout of state variables in storage], and http://bit.ly/2Dch2Hc[layout in memory].\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Uninitialized Storage Pointers"}}
{"input": "Explain the Ethereum concept: The Vulnerability", "output": "(((\"uninitialized storage pointers security threat\",\"vulnerability\", id=\"ix_09smart-contracts-security-asciidoc46\", range=\"startofrange\")))Local variables within functions default to storage or memory\ndepending on their type. Uninitialized local storage variables may\ncontain the value of other storage variables in the contract; this fact\ncan cause unintentional vulnerabilities, or be exploited deliberately.\n\nLet\u2019s consider the relatively simple name registrar contract in <<nameregistrar_security>>.\n\n[[nameregistrar_security]]\n.NameRegistrar.sol", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "The Vulnerability"}}
{"input": "Explain the Ethereum concept: Preventative Techniques", "output": "(((\"uninitialized storage pointers security threat\",\"preventative techniques\")))The Solidity compiler shows a warning for unintialized storage variables;\ndevelopers should pay careful attention to these warnings when\nbuilding smart contracts. The current version of Mist (0.10) doesn\u2019t\nallow these contracts to be compiled. It is often good practice to\nexplicitly use the `memory` or `storage` specifiers when dealing with complex types,\nto ensure they behave as expected.", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Preventative Techniques"}}
{"input": "Explain the Ethereum concept: Real-World Examples: OpenAddressLottery and CryptoRoulette Honey Pots", "output": "(((\"OpenAddressLottery honey pot\")))(((\"uninitialized storage pointers security threat\",\"real-world examples: OpenAddressLottery and CryptoRoulette honey pots\")))A honey pot named http://bit.ly/2AAVnWD[+OpenAddressLottery+] was deployed that used this uninitialized storage variable quirk\nto collect ether from some would-be hackers. The contract is rather\ninvolved, so we will leave the analysis to the http://bit.ly/2OgxPtG[Reddit\nthread] where the attack is quite clearly explained.\n\n(((\"CryptoRoulette honey pot\")))Another honey pot, http://bit.ly/2OfNGJ2[+CryptoRoulette+], also utilized this trick pass:[<span class=\"keep-together\">to try</span>] and collect some ether. If you\ncan\u2019t figure out how the attack works, see\nhttp://bit.ly/2OVkSL4[&#x201c;An\nAnalysis of a Couple Ethereum Honeypot Contracts&#x201d;] for an overview of\nthis contract and others.(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc45\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc44\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc43\")))", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Real-World Examples: OpenAddressLottery and CryptoRoulette Honey Pots"}}
{"input": "Explain the Ethereum concept: Floating Point and Precision", "output": "(((\"floating-point representation security risk\", id=\"ix_09smart-contracts-security-asciidoc47\", range=\"startofrange\")))(((\"security (smart contracts)\",\"floating-point problem\", id=\"ix_09smart-contracts-security-asciidoc48\", range=\"startofrange\")))As of this writing (v0.4.24), Solidity does not support fixed-point and floating-point\nnumbers. This means that floating-point\nrepresentations must be constructed with integer types in Solidity. This\ncan lead to errors and vulnerabilities if not implemented correctly.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Floating Point and Precision"}}
{"input": "Explain the Ethereum concept: The Vulnerability", "output": "(((\"floating-point representation security risk\",\"vulnerability\")))As there is no fixed-point type in Solidity, developers are required to\nimplement their own using the standard integer data types. There are a\nnumber of pitfalls developers can run into during this process. We will\ntry to highlight some of these in this section.\n\nLet's begin with a code example (we'll ignore over/underflow issues, discussed earlier in this chapter, for simplicity):\n\n[source,solidity,linenums]\n----\ncontract FunWithNumbers {\n    uint constant public tokensPerEth = 10;\n    uint constant public weiPerEth = 1e18;\n    mapping(address => uint) public balances;\n\n    function buyTokens() external payable {\n        // convert wei to eth, then multiply by token rate\n        uint tokens = msg.value/weiPerEth*tokensPerEth;\n        balances[msg.sender] += tokens;\n    }\n\n    function sellTokens(uint tokens) public {\n        require(balances[msg.sender] >= tokens);\n        uint eth = tokens/tokensPerEth;\n        balances[msg.sender] -= tokens;\n        msg.sender.transfer(eth*weiPerEth);\n    }\n}\n----\n\nThis simple token buying/selling contract has some obvious problems. Although the mathematical calculations\nfor buying and selling tokens are correct, the lack of floating-point\nnumbers will give erroneous results. For example, when buying tokens on\nline 8, if the value is less than `1 ether` the initial division will\nresult in `0`, leaving the result of the final multiplication as `0` (e.g., `200 wei`\ndivided by `1e18` `weiPerEth` equals `0`). Similarly, when selling\ntokens, any number of tokens less than `10` will also result in `0 ether`. In\nfact, rounding here is always down, so selling `29 tokens` will result\nin `2 ether`.\n\nThe issue with this contract is that the precision is only to the\nnearest ether (i.e., 1e18 wei). This can get tricky when\ndealing with decimals in\nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md[ERC20]\ntokens when you need higher precision.\n\n[role=\"notoc\"]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "The Vulnerability"}}
{"input": "Explain the Ethereum concept: Preventative Techniques", "output": "(((\"floating-point representation security risk\",\"preventative techniques\")))Keeping the right precision in your smart contracts is very important,\nespecially when dealing with ratios and rates that reflect economic\ndecisions.\n\nYou should ensure that any ratios or rates you are using allow for large\nnumerators in fractions. For example, we used the rate `tokensPerEth` in\nour example. It would have been better to use `weiPerTokens`, which would\nbe a large number. To calculate the corresponding number of tokens we could do\n`msg.value/weiPerTokens`. This would give a more precise result.\n\nAnother tactic to keep in mind is to be mindful of order of operations.\nIn our example, the calculation to purchase tokens was\n`msg.value/weiPerEth*tokenPerEth`. Notice that the division occurs\nbefore the multiplication. (Solidity, unlike some languages, guarantees to perform operations in the order in which they are written.) This example would have achieved a greater\nprecision if the calculation performed the multiplication first and then\nthe division; i.e., `msg.value*tokenPerEth/weiPerEth`.\n\nFinally, when defining arbitrary precision for numbers it can be a good\nidea to convert values to higher precision, perform all\nmathematical operations, then finally convert back down to\nthe precision required for output. Typically ++uint256++s are used (as they are\noptimal for gas usage); these give approximately 60 orders of magnitude\nin their range, some of which can be dedicated to the precision of\nmathematical operations. It may be the case that it is better to keep\nall variables in high precision in Solidity and convert back to lower\nprecisions in external apps (this is essentially how the `decimals`\nvariable works in ERC20 token\ncontracts). To see an example of how this can be done, we recommend looking at https://github.com/dapphub/ds-math[DS-Math]. It uses some\nfunky naming (&#x201c;wads&#x201d; and &#x201c;rays&#x201d;), but the concept is useful.", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Preventative Techniques"}}
{"input": "Explain the Ethereum concept: Real-World Example: Ethstick", "output": "(((\"Ethstick contract\")))(((\"floating-point representation security risk\",\"real-world example: Ethstick\")))The http://bit.ly/2Qb7PSB[+Ethstick+ contract] does not use extended precision; however, it deals with wei. So,\nthis contract will have issues of rounding, but only at the wei level\nof precision. It has some more serious flaws, but these relate\nback to the difficulty in getting entropy on the blockchain (see\n<<entropyillusion_security>>). For a further discussion of\nthe +Ethstick+ contract, we\u2019ll refer you to another post by Peter Vessenes,\nhttp://bit.ly/2SwDnE0[&#x201c;Ethereum\nContracts Are Going to Be Candy for Hackers&#x201d;].(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc48\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc47\")))", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Real-World Example: Ethstick"}}
{"input": "Explain the Ethereum concept: Tx.Origin Authentication", "output": "(((\"security (smart contracts)\",\"tx.origin authentication threat\", id=\"ix_09smart-contracts-security-asciidoc49\", range=\"startofrange\")))Solidity has a global variable, `tx.origin`, which traverses the entire\ncall stack and contains the address of the account that originally sent\nthe call (or transaction). Using this variable for authentication in a smart contract leaves the contract vulnerable to a phishing-like\nattack.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Tx.Origin Authentication"}}
{"input": "Explain the Ethereum concept: The Vulnerability", "output": "(((\"tx.origin authentication security threat\",\"vulnerability\")))Contracts that authorize users using the `tx.origin` variable are\ntypically vulnerable to phishing attacks that can trick users into\nperforming authenticated actions on the vulnerable contract.\n\nConsider the simple contract in <<phishable_security>>.\n\n[[phishable_security]]\n.Phishable.sol", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "The Vulnerability"}}
{"input": "Explain the Ethereum concept: Preventative Techniques", "output": "(((\"tx.origin authentication security threat\",\"preventative techniques\")))`tx.origin` should not be used for authorization in smart contracts.\nThis isn\u2019t to say that the `tx.origin` variable should never be used. It\ndoes have some legitimate use cases in smart contracts. For example, if\none wanted to deny external contracts from calling the current contract,\none could implement a `require` of the form\n`require(tx.origin == msg.sender)`. This prevents intermediate contracts\nbeing used to call the current contract, limiting the contract to\nregular codeless addresses(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc49\"))).(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc2\")))\n\n[[contract_libraries_sec]]", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Preventative Techniques"}}
{"input": "Explain the Ethereum concept: Contract Libraries", "output": "(((\"security (smart contracts)\",\"contract libraries for\")))(((\"smart contracts\",\"on-platform libraries\")))There is a lot of existing code available for reuse, both deployed on-chain as callable libraries and off-chain as code template libraries. On-platform libraries, having been deployed, exist as bytecode smart contracts, so great care should be taken before using them in production. However, using well-established existing on-platform libraries comes with many advantages, such as being able to benefit from the latest upgrades, and saves you money and benefits the Ethereum ecosystem by reducing the total number of live contracts in Ethereum.\n\n(((\"frameworks\",\"OpenZeppelin suite\")))(((\"OpenZeppelin\")))In Ethereum, the most widely used resource is the https://openzeppelin.org/[OpenZeppelin suite], an ample library of contracts ranging from implementations of ERC20 and ERC721 tokens, to many flavors of crowdsale models, to simple behaviors commonly found in contracts, such as `Ownable`, `Pausable`, or `LimitBalance`. The contracts in this repository have been extensively tested and in some cases even function as _de facto_ standard implementations. They are free to use, and are built and maintained by https://zeppelin.solutions[Zeppelin] together with an ever-growing list of external contributors.\n\n(((\"frameworks\",\"ZeppelinOS\")))(((\"ZeppelinOS\")))Also from Zeppelin is https://zeppelinos.org/[ZeppelinOS], an open source platform of services and tools to develop and manage smart contract applications securely. ZeppelinOS provides a layer on top of the EVM that makes it easy for developers to launch upgradeable DApps linked to an on-chain library of well-tested contracts that are themselves upgradeable. Different versions of these libraries can coexist on the Ethereum platform, and a vouching system allows users to propose or push improvements in different directions. A set of off-chain tools to debug, test, deploy, and monitor decentralized applications is also provided by the platform.\n\n(((\"ethpm project\")))The project +ethpm+ aims to organize the various resources that are developing in the ecosystem by providing a package management system. As such, their registry provides more examples for you to browse:\n\n* Website: https://www.ethpm.com/\n* Repository link: https://www.ethpm.com/registry\n* GitHub link: https://github.com/ethpm\n* Documentation: https://www.ethpm.com/docs/integration-guide", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Contract Libraries"}}
{"input": "Explain the Ethereum concept: Conclusions", "output": "There is a lot for any developer working in the smart contract domain to know and understand. By following best practices in your smart contract design and code writing, you will avoid many severe pitfalls and traps.\n\nPerhaps the most fundamental software security principle is to maximize reuse of trusted code. In cryptography, this is so important it has been condensed into an adage: \"Don't roll your own crypto.\" In the case of smart contracts, this amounts to gaining as much as possible from freely available libraries that have been thoroughly vetted by the community.(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc1\")))(((range=\"endofrange\", startref=\"ix_09smart-contracts-security-asciidoc0\")))", "metadata": {"source": "ethereumbook", "chapter": "09smart-contracts-security.asciidoc", "section": "Conclusions"}}
{"input": "Explain the Ethereum concept: Tokens", "output": "(((\"tokens\", id=\"ix_10tokens-asciidoc0\", range=\"startofrange\")))The word \"token\" derives from the Old English \"t\u0101cen,\" meaning a sign or symbol. It is commonly used to refer to privately issued special-purpose coin-like items of insignificant intrinsic value, such as transportation tokens, laundry tokens, and arcade game tokens.\n\nNowadays, \"tokens\" administered on blockchains are redefining the word to mean blockchain-based abstractions that can be owned and that represent assets, currency, or access rights.\n\nThe association between the word \"token\" and insignificant value has a lot to do with the limited use of the physical versions of tokens. Often restricted to specific businesses, organizations, or locations, physical tokens are not easily exchangeable and typically have only one function. With blockchain tokens, these restrictions are lifted&#x2014;or, more accurately, completely redefinable. Many blockchain tokens serve multiple purposes globally and can be traded for each other or for other currencies on global liquid markets. With the restrictions on use and ownership gone, the \"insignificant value\" expectation is also a thing of the past.\n\nIn this chapter, we look at various uses for tokens and how they are created. We also discuss attributes of tokens such as fungibility and intrinsicality. Finally, we examine the standards and technologies that they are based on, and experiment by building our own tokens.\n\n[[tokens_use]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "Tokens"}}
{"input": "Explain the Ethereum concept: How Tokens Are Used", "output": "(((\"tokens\",\"uses of\", id=\"ix_10tokens-asciidoc1\", range=\"startofrange\")))The most obvious use of tokens is as digital private currencies. However, this is only one possible use. Tokens can be programmed to serve many different functions, often overlapping. For example, a token can simultaneously convey a voting right, an access right, and ownership of a resource. As the following list shows, currency is just the first \"app\":\n\nCurrency:: A token can serve as a form of currency, with a value determined through private trade.\n\nResource:: A token can represent a resource earned or produced in a sharing economy or resource-sharing environment; for example, a storage or CPU token representing resources that can be shared over a network.\n\nAsset:: A token can represent ownership of an intrinsic or extrinsic, tangible or intangible asset; for example, gold, real estate, a car, oil, energy, MMOG items, etc.\n\nAccess:: A token can represent access rights and grant access to a digital or physical property, such as a discussion forum, an exclusive website, a hotel room, or a rental car.\n\nEquity:: A token can represent shareholder equity in a digital organization (e.g., a DAO) or legal entity (e.g., a corporation).\n\nVoting:: A token can represent voting rights in a digital or legal system.\n\nCollectible:: A token can represent a digital collectible (e.g., CryptoPunks) or physical collectible (e.g., a painting).\n\nIdentity:: A token can represent a digital identity (e.g., avatar) or legal identity (e.g., national ID).\n\nAttestation:: A token can represent a certification or attestation of fact by some authority or by a decentralized reputation system (e.g., marriage record, birth certificate, college degree).\n\nUtility:: A token can be used to access or pay for a service.\n\nOften, a single token encompasses several of these functions. Sometimes it is hard to discern between them, as the physical equivalents have always been inextricably linked. For example, in the physical world, a driver's license (attestation) is also an identity document (identity) and the two cannot be separated. In the digital realm, previously commingled functions can be separated and developed independently (e.g., an anonymous attestation).(((range=\"endofrange\", startref=\"ix_10tokens-asciidoc1\")))\n\n[[tokens_fungibility]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "How Tokens Are Used"}}
{"input": "Explain the Ethereum concept: Tokens and Fungibility", "output": "(((\"fungible tokens\", seealso=\"ERC20 token standard\")))(((\"tokens\",\"fungibility\")))https://en.wikipedia.org/wiki/Fungibility[Wikipedia] says: \"In economics, fungibility is the property of a good or a commodity whose individual units are essentially interchangeable.\"\n\nTokens are fungible when we can substitute any single unit of the token for another without any difference in its value or function.\n\nStrictly speaking, if a token's historical provenance can be tracked, then it is not entirely fungible. The ability to track provenance can lead to blacklisting and whitelisting, reducing or eliminating fungibility.\n\n(((\"non-fungible tokens (NFTs)\")))Non-fungible tokens are tokens that each represent a unique tangible or intangible item and therefore are not interchangeable. For example, a token that represents ownership of a _specific_ Van Gogh painting is not equivalent to another token that represents a Picasso, even though they might be part of the same \"art ownership token\" system. Similarly, a token representing a _specific_ digital collectible such as a specific CryptoKitty is not interchangeable with any other CryptoKitty. Each non-fungible token is associated with a unique identifier, such as a serial number.\n\nWe will see examples of both fungible and non-fungible tokens later in this chapter.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "Tokens and Fungibility"}}
{"input": "Explain the Ethereum concept: Counterparty Risk", "output": "(((\"counterparty risk\")))(((\"tokens\",\"counterparty risk\")))Counterparty risk is the risk that the _other_ party in a transaction will fail to meet their obligations. Some types of transactions suffer additional counterparty risk because there are more than two parties involved. For example, if you hold a certificate of deposit for a precious metal and you sell that to someone, there are at least three parties in that transaction: the seller, the buyer, and the custodian of the precious metal. Someone holds the physical asset; by necessity they become party to the fulfillment of the transaction and add counterparty risk to any transaction involving that asset. In general, when an asset is traded indirectly through the exchange of a token of ownership, there is additional counterparty risk from the custodian of the asset. Do they have the asset? Will they recognize (or allow) the transfer of ownership based on the transfer of a token (such as a certificate, deed, title, or digital token)? In the world of digital tokens representing assets, as in the nondigital world, it is important to understand who holds the asset that is represented by the token and what rules apply to that underlying asset.\n\n[[tokens_intrinsicality]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "Counterparty Risk"}}
{"input": "Explain the Ethereum concept: Tokens and Intrinsicality", "output": "(((\"tokens\",\"intrinsicality\")))The word \"intrinsic\" derives from the Latin \"intra,\" meaning \"from within.\"\n\nSome tokens represent digital items that are intrinsic to the blockchain. Those digital assets are governed by consensus rules, just like the tokens themselves. This has an important implication: tokens that represent intrinsic assets do not carry additional counterparty risk. If you hold the keys for a CryptoKitty, there is no other party holding that CryptoKitty for you&#x2014;you own it directly. The blockchain consensus rules apply and your ownership (i.e., control) of the private keys is equivalent to ownership of the asset, without any intermediary.\n\nConversely, many tokens are used to represent _extrinsic_ things, such as real estate, corporate voting shares, trademarks, and gold bars. The ownership of these items, which are not \"within\" the blockchain, is governed by law, custom, and policy, separate from the consensus rules that govern the token. In other words, token issuers and owners may still depend on real-world non-smart contracts. As a result, these extrinsic assets carry additional counterparty risk because they are held by custodians, recorded in external registries, or controlled by laws and policies outside the blockchain environment.\n\nOne of the most important ramifications of blockchain-based tokens is the ability to convert extrinsic assets into intrinsic assets and thereby remove counterparty risk. A good example is moving from equity in a corporation (extrinsic) to an equity or voting token in a _DAO_ or similar (intrinsic) organization.\n\n[[using_tokens]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "Tokens and Intrinsicality"}}
{"input": "Explain the Ethereum concept: Using Tokens: Utility or Equity", "output": "(((\"tokens\",\"utility/equity types\", id=\"ix_10tokens-asciidoc2\", range=\"startofrange\")))Almost all projects in Ethereum today launch with some kind of token. But do all these projects really need tokens? Are there any disadvantages to using a token, or will we see the slogan \"tokenize all the things\" come to fruition? In principle, the use of tokens can be seen as the ultimate management or organization tool. In practice, the integration of blockchain platforms, including Ethereum, into the existing structures of society means that, so far, there are many limitations to their applicability.\n\nLet's start by clarifying the role of a token in a new project. The majority of projects are using tokens in one of two ways: either as \"utility tokens\" or as \"equity tokens.\" Very often, those two roles are conflated.\n\n(((\"utility tokens\",\"defined\")))Utility tokens are those where the use of the token is required to gain access to a service, application, or resource. Examples of utility tokens include tokens that represent resources such as shared storage, or access to services such as social media networks.\n\n(((\"equity tokens\",\"defined\")))Equity tokens are those that represent shares in the control or ownership of something, such as a startup. Equity tokens can be as limited as nonvoting shares for distribution of dividends and profits, or as expansive as voting shares in a decentralized autonomous organization, where management of the platform is through some complex governance system based on votes by the token holders.\n\n[[its_not_duck]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "Using Tokens: Utility or Equity"}}
{"input": "Explain the Ethereum concept: It's a Duck!", "output": "(((\"equity tokens\",\"utility tokens as\")))(((\"utility tokens\",\"equity tokens disguised as\")))Many startups face a difficult problem: tokens are a great fundraising mechanism, but offering securities (equity) to the public is a regulated activity in most jurisdictions. By disguising equity tokens as utility tokens, many startups hope to get around these regulatory restrictions and raise money from a public offering while presenting it as a pre-sale of \"service access vouchers\" or, as we call them, utility tokens. Whether these thinly disguised equity offerings will be able to skirt the regulators remains to be seen.\n\nAs the popular saying goes: \"If it walks like a duck and quacks like a duck, it's a duck.\" Regulators are not likely to be distracted by these semantic contortions; quite the opposite, they are more likely to see such legal sophistry as an attempt to deceive the public.\n\n[[who_needs_utility_tokens]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "It's a Duck!"}}
{"input": "Explain the Ethereum concept: Utility Tokens: Who Needs Them?", "output": "(((\"utility tokens\",\"issues to consider when using\", id=\"ix_10tokens-asciidoc3\", range=\"startofrange\")))The real problem is that utility tokens introduce significant risks and adoption barriers for startups. Perhaps in a distant future \"tokenize all the things\" will become reality, but at present the set of people who have an understanding of and desire to use a token is a subset of the already small cryptocurrency market.\n\nFor a startup, each innovation represents a risk and a market filter. Innovation is taking the road least traveled, walking away from the path of tradition. It is already a lonely walk. If a startup is trying to innovate in a new area of technology, such as storage sharing over P2P networks, that is a lonely enough path. Adding a utility token to that innovation and requiring users to adopt tokens in order to use the service compounds the risk and increases the barriers to adoption. It's walking off the already lonely trail of P2P storage innovation and into the wilderness.\n\nThink of each innovation as a filter. It limits adoption to the subset of the market that can become early adopters of this innovation. Adding a second filter compounds that effect, further limiting the addressable market. You are asking your early adopters to adopt not one but two completely new technologies: the novel application/platform/service you built, and the token economy.\n\nFor a startup, each innovation introduces risks that increase the chance of failure of the startup. If you take your already risky startup idea and add a utility token, you are adding all the risks of the underlying platform (Ethereum), broader economy (exchanges, liquidity), regulatory environment (equity/commodity regulators), and technology (smart contracts, token standards). That's a lot of risk for a startup.\n\nAdvocates of \"tokenize all the things\" will likely counter that by adopting tokens they are also inheriting the market enthusiasm, early adopters, technology, innovation, and liquidity of the entire token economy. That is true too. The question is whether the benefits and enthusiasm outweigh the risks and uncertainties.\n\nNevertheless, some of the most innovative business ideas are indeed taking place in the crypto realm. If regulators are not quick enough to adopt laws and support new business models, entrepreneurs and associated talent will seek to operate in other jurisdictions that are more crypto-friendly. This is already happening.\n\nFinally, at the beginning of this chapter, when introducing tokens, we discussed the colloquial meaning of \"token\" as \"something of insignificant value.\" The underlying reason for the insignificant value of most tokens is because they can only be used in a very narrow context: one bus company, one laundromat, one arcade, one hotel, or one company store. Limited liquidity, limited applicability, and high conversion costs reduce the value of tokens until they are only of \"token\" value. So when you add a utility token to your platform, but the token can only be used on your single platform with a small market, you are recreating the conditions that made physical tokens worthless. This may indeed be the correct way to incorporate tokenization into your project. However, if in order to use your platform a user has to convert something into your utility token, use it, and then convert the remainder back into something more generally useful, you've created a company scrip. The switching costs of a digital token are orders of magnitude lower than for a physical token without a market, but they are not zero. Utility tokens that work across an entire industry sector will be very interesting and probably quite valuable. But if you set up your startup to have to bootstrap an entire industry standard in order to succeed, you may have already failed.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "Utility Tokens: Who Needs Them?"}}
{"input": "Explain the Ethereum concept: Tokens on Ethereum", "output": "(((\"tokens\",\"on Ethereum\", id=\"ix_10tokens-asciidoc4\", range=\"startofrange\")))Blockchain tokens existed before Ethereum. (((\"Bitcoin\",\"as token\")))In some ways, the first blockchain currency, Bitcoin, is a token itself. Many token platforms were also developed on Bitcoin and other cryptocurrencies before Ethereum. However, the introduction of the first token standard on Ethereum led to an explosion of tokens.\n\n(((\"Buterin, Vitalik\",\"on tokens\")))Vitalik Buterin suggested tokens as one of the most obvious and useful applications of a generalized programmable blockchain such as Ethereum. In fact, in the first year of Ethereum, it was common to see Vitalik and others wearing T-shirts emblazoned with the Ethereum logo and a smart contract sample on the back. There were several variations of this T-shirt, but the most common showed an implementation of a token.\n\nBefore we delve into the details of creating tokens on Ethereum, it is important to have an overview of how tokens work on Ethereum. Tokens are different from ether because the Ethereum protocol does not know anything about them. Sending ether is an intrinsic action of the Ethereum platform, but sending or even owning tokens is not. The ether balance of Ethereum accounts is handled at the protocol level, whereas the token balance of Ethereum accounts is handled at the smart contract level. In order to create a new token on Ethereum, you must create a new smart contract. Once deployed, the smart contract handles everything, including ownership, transfers, and access rights. You can write your smart contract to perform all the necessary actions any way you want, but it is probably wisest to follow an existing standard. We will look at such standards next. We discuss the pros and cons of the following standards at the end of the chapter.\n\n\n[[ERC20_std]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "Tokens on Ethereum"}}
{"input": "Explain the Ethereum concept: The ERC20 Token Standard", "output": "(((\"ERC20 token standard\", id=\"ix_10tokens-asciidoc5\", range=\"startofrange\")))(((\"tokens\",\"ERC20 standard\", id=\"ix_10tokens-asciidoc6\", range=\"startofrange\")))The first standard was introduced in November 2015 by Fabian Vogelsteller as an Ethereum Request for Comments (ERC). It was automatically assigned GitHub issue number 20, giving rise to the name \"ERC20 token.\" The vast majority of tokens are currently based on the ERC20 standard. The ERC20 request for comments eventually became Ethereum Improvement Proposal 20 (EIP-20), but it is mostly still referred to by the original name, ERC20.\n\nERC20 is a standard for _fungible tokens_, meaning that different units of an ERC20 token are interchangeable and have no unique properties.\n\nhttp://bit.ly/2CUf7WG[The ERC20 standard] defines a common interface for contracts implementing a token, such that any compatible token can be accessed and used in the same way. The interface consists of a number of functions that must be present in every implementation of the standard, as well as some optional functions and attributes that may be added by developers.\n\n[[ERC20_reqd_func]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "The ERC20 Token Standard"}}
{"input": "Explain the Ethereum concept: ERC20 required functions and events", "output": "(((\"ERC20 token standard\",\"required functions and events\")))An ERC20-compliant token contract must provide at least the following functions and events:\n\n+totalSupply+:: Returns the total units of this token that currently exist. ERC20 tokens can have a fixed or a variable supply.\n\n+balanceOf+:: Given an address, returns the token balance of that address.\n\n+transfer+:: Given an address and amount, transfers that amount of tokens to that address, from the balance of the address that executed the transfer.\n\n+transferFrom+:: Given a sender, recipient, and amount, transfers tokens from one account to another. Used in combination with +approve+.\n\n+approve+:: Given a recipient address and amount, authorizes that address to execute several transfers up to that amount, from the account that issued the approval.\n\n+allowance+:: Given an owner address and a spender address, returns the remaining amount that the spender is approved to withdraw from the owner.\n\n+Transfer+:: Event triggered upon a successful transfer (call to +transfer+ or +transferFrom+) (even for zero-value transfers).\n\n+Approval+:: Event logged upon a successful call to +approve+.\n\n[[ERC20_optional_func]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "ERC20 required functions and events"}}
{"input": "Explain the Ethereum concept: ERC20 optional functions", "output": "(((\"ERC20 token standard\",\"optional functions\")))In addition to the required functions listed in the previous section, the following optional functions are also defined by the standard:\n\n+name+:: Returns the human-readable name (e.g., \"US Dollars\") of the token.\n\n+symbol+:: Returns a human-readable symbol (e.g., \"USD\") for the token.\n\n+decimals+:: Returns the number of decimals used to divide token amounts. For example, if +decimals+ is +2+, then the token amount is divided by 100 to get its user pass:[<span class=\"keep-together\">representation</span>].\n\n[[ERC20_interface]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "ERC20 optional functions"}}
{"input": "Explain the Ethereum concept: The ERC20 interface defined in Solidity", "output": "(((\"ERC20 token standard\",\"interface defined in Solidity\")))Here's what an ERC20 interface specification looks like in Solidity:\n\n[[ERC20_interface_example]]\n[source,solidity]\n----\ncontract ERC20 {\n   function totalSupply() constant returns (uint theTotalSupply);\n   function balanceOf(address _owner) constant returns (uint balance);\n   function transfer(address _to, uint _value) returns (bool success);\n   function transferFrom(address _from, address _to, uint _value) returns\n      (bool success);\n   function approve(address _spender, uint _value) returns (bool success);\n   function allowance(address _owner, address _spender) constant returns\n      (uint remaining);\n   event Transfer(address indexed _from, address indexed _to, uint _value);\n   event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n----\n\n[[ERC20_data_struct]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "The ERC20 interface defined in Solidity"}}
{"input": "Explain the Ethereum concept: ERC20 data structures", "output": "(((\"data mapping\")))(((\"ERC20 token standard\",\"data structures\")))If you examine any ERC20 implementation you will see that it contains two data structures, one to track balances and one to track allowances. In Solidity, they are implemented with a _data mapping_.\n\nThe first data mapping implements an internal table of token balances, by owner. This allows the token contract to keep track of who owns the tokens. Each transfer is a deduction from one balance and an addition to another balance:\n\n[[balance_mapping]]\n[source,solidity]\n----\nmapping(address => uint256) balances;\n----\n\nThe second data structure is a data mapping of allowances. As we will see in the next section, with ERC20 tokens an owner of a token can delegate authority to a spender, allowing them to spend a specific amount (allowance) from the owner's balance. The ERC20 contract keeps track of the allowances with a two-dimensional mapping, with the primary key being the address of the token owner, mapping to a spender address and an allowance amount:\n\n[[allowance_mapping]]\n[source,solidity]\n----\nmapping (address => mapping (address => uint256)) public allowed;\n----\n\n\n[[transfer_workflows]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "ERC20 data structures"}}
{"input": "Explain the Ethereum concept: ERC20 workflows: \"transfer\" and \"approve & transferFrom\"", "output": "(((\"ERC20 token standard\",\"transfer functions\", id=\"ix_10tokens-asciidoc7\", range=\"startofrange\")))(((\"transfer function\",\"ERC20 token standard\", id=\"ix_10tokens-asciidoc8\", range=\"startofrange\")))The ERC20 token standard has two transfer functions. You might be wondering why.\n\nERC20 allows for two different workflows. The first is a single-transaction, straightforward workflow using the +transfer+ function. This workflow is the one used by wallets to send tokens to other wallets. The vast majority of token transactions happen with the +transfer+ workflow.\n\nExecuting the transfer contract is very simple. If Alice wants to send 10 tokens to Bob, her wallet sends a transaction to the token contract's address, calling the pass:[<span class=\"keep-together\"><code>transfer</code></span>] function with Bob's address and +10+ as the arguments. The token contract adjusts Alice's balance (&#x2013;10) and Bob's balance (pass:[+10]) and issues a +Transfer+ event.\n\n(((\"approve & transferFrom workflow\")))The second workflow is a two-transaction workflow that uses +approve+ followed by +transferFrom+. This workflow allows a token owner to delegate their control to another address. It is most often used to delegate control to a contract for distribution of tokens, but it can also be used by exchanges.\n\n(((\"Initial Coin Offerings (ICOs)\",\"tokens and\")))For example, if a company is selling tokens for an ICO, they can +approve+ a crowdsale contract address to distribute a certain amount of tokens. The crowdsale contract can then +transferFrom+ the token contract owner's balance to each buyer of the token, as illustrated in <<approve_transferFrom_workflow>>.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "ERC20 workflows: \"transfer\" and \"approve & transferFrom\""}}
{"input": "Explain the Ethereum concept: ERC20 implementations", "output": "While it is possible to implement an ERC20-compatible token in about 30 lines of Solidity code, most implementations are more complex. This is to account for potential security vulnerabilities. There are two implementations mentioned in the EIP-20 standard:\n\nhttp://bit.ly/2EUYCMR[Consensys EIP20]:: A simple and easy-to-read implementation of an ERC20-compatible token.\n\nhttps://bit.ly/2xPYck6[OpenZeppelin StandardToken]:: This implementation is ERC20-compatible, with additional security precautions. It forms the basis of OpenZeppelin libraries implementing more complex ERC20-compatible tokens with fundraising caps, auctions, vesting schedules, and other features.(((range=\"endofrange\", startref=\"ix_10tokens-asciidoc6\")))(((range=\"endofrange\", startref=\"ix_10tokens-asciidoc5\")))\n\n[[METoken_example]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "ERC20 implementations"}}
{"input": "Explain the Ethereum concept: Launching Our Own ERC20 Token", "output": "(((\"ERC20 token standard\",\"METoken creation/launch example\", id=\"ix_10tokens-asciidoc9\", range=\"startofrange\")))(((\"METoken (Mastering Ethereum Token)\",\"creation/launch example\", id=\"ix_10tokens-asciidoc10\", range=\"startofrange\")))Let's create and launch our own token. For this example, we will use the Truffle framework. The example assumes you have already installed +truffle+ and configured it, and are familiar with its basic operation (for details, see <<truffle>>).\n\nWe will call our token \"Mastering Ethereum Token,&#x201d; with the symbol \"MET.\"\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "Launching Our Own ERC20 Token"}}
{"input": "Explain the Ethereum concept: Interacting with METoken using the Truffle console", "output": "(((\"METoken (Mastering Ethereum Token)\",\"interacting with via Truffle console\", id=\"ix_10tokens-asciidoc11\", range=\"startofrange\")))(((\"Truffle\",\"interacting with METoken via Truffle console\", id=\"ix_10tokens-asciidoc12\", range=\"startofrange\")))We can interact with our contract on the +ganache+ blockchain using the Truffle console. This is an interactive JavaScript environment that provides access to the Truffle environment and, via web3, to the blockchain. In this case, we will connect the Truffle console to the +ganache+ blockchain:\n\n++++\n<pre data-type=\"programlist\">\n$ <strong>truffle console --network ganache</strong>\ntruffle(ganache)&gt;\n</pre>\n++++\n\nThe +truffle(ganache)>+ prompt shows that we are connected to the +ganache+ blockchain and are ready to type our commands. The Truffle console supports all the +truffle+ commands, so we could +compile+ and +migrate+ from the console. We've already run those commands, so let's go directly to the contract itself. The +METoken+ contract exists as a JavaScript object within the Truffle environment. Type ++**METoken**++ at the prompt and it will dump the entire contract definition:\n\n++++\n<pre data-type=\"programlist\">\ntruffle(ganache)&gt; <strong>METoken</strong>\n{ [Function: TruffleContract]\n  _static_methods:\n\n[...]\n\ncurrentProvider:\n HttpProvider {\n   host: 'http://localhost:7545',\n   timeout: 0,\n   user: undefined,\n   password: undefined,\n   headers: undefined,\n   send: [Function],\n   sendAsync: [Function],\n   _alreadyWrapped: true },\nnetwork_id: '5777' }\n</pre>\n++++\n\nThe +METoken+ object also exposes several attributes, such as the address of the contract (as deployed by the +migrate+ command):\n\n++++\n<pre data-type=\"programlist\">\ntruffle(ganache)&gt; <strong>METoken.address</strong>\n'0x345ca3e014aaf5dca488057592ee47305d9b3e10'\n</pre>\n++++\n\nIf we want to interact with the deployed contract, we have to use an asynchronous call, in the form of a JavaScript \"promise.\" We use the +deployed+ function to get the contract instance and then call the +totalSupply+ function:\n\n++++\n<pre data-type=\"programlist\">\ntruffle(ganache)&gt; <strong>METoken.deployed().then(instance => instance.totalSupply())</strong>\nBigNumber { s: 1, e: 9, c: [ 2100000000 ] }\n</pre>\n++++\n\nNext, let's use the accounts created by +ganache+ to check our METoken balance and send some METoken to another address. First, let's get the account addresses:\n\n++++\n<pre data-type=\"programlist\">\ntruffle(ganache)&gt; <strong>let accounts</strong>\nundefined\ntruffle(ganache)&gt; <strong>web3.eth.getAccounts((err,res) => { accounts = res })</strong>\nundefined\ntruffle(ganache)&gt; <strong>accounts[0]</strong>\n'0x627306090abab3a6e1400e9345bc60c78a8bef57'\n</pre>\n++++\n\nThe +accounts+ list now contains all the accounts created by +ganache+, and +accounts[0]+ is the account that deployed the +METoken+ contract. It should have a balance of pass:[<span class=\"keep-together\">METoken</span>], because our METoken constructor gives the entire token supply to the address that created it. Let's check:\n\n++++\n<pre data-type=\"programlist\">\ntruffle(ganache)&gt; <strong>METoken.deployed().then(instance =></strong>\n                  <strong>{ instance.balanceOf(accounts[0]).then(console.log) })</strong>\nundefined\ntruffle(ganache)&gt; <strong>BigNumber { s: 1, e: 9, c: [ 2100000000 ] }</strong>\n</pre>\n++++\n\nFinally, let's transfer 1000.00 METoken from +accounts[0]+ to +accounts[1]+, by calling the contract's +transfer+ function:\n\n++++\n<pre data-type=\"programlist\">\ntruffle(ganache)&gt; <strong>METoken.deployed().then(instance =>\n                  { instance.transfer(accounts[1], 100000) })</strong>\nundefined\ntruffle(ganache)&gt; <strong>METoken.deployed().then(instance =>\n                  { instance.balanceOf(accounts[0]).then(console.log) })</strong>\nundefined\ntruffle(ganache)&gt; <strong>BigNumber { s: 1, e: 9, c: [ 2099900000 ] }</strong>\nundefined\ntruffle(ganache)&gt; <strong>METoken.deployed().then(instance =>\n                  { instance.balanceOf(accounts[1]).then(console.log) })</strong>\nundefined\ntruffle(ganache)&gt; <strong>BigNumber { s: 1, e: 5, c: [ 100000 ] }</strong>\n</pre>\n++++\n\n[TIP]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "Interacting with METoken using the Truffle console"}}
{"input": "Explain the Ethereum concept: Sending ERC20 tokens to contract addresses", "output": "(((\"Faucet.sol contract (test example)\",\"METoken project\", id=\"ix_10tokens-asciidoc13\", range=\"startofrange\")))(((\"METoken (Mastering Ethereum Token)\",\"sending to contract addresses\", id=\"ix_10tokens-asciidoc14\", range=\"startofrange\")))So far, we've set up an ERC20 token and transferred some tokens from one account to another. All the accounts we used for these demonstrations are externally owned accounts, meaning they are controlled by a private key, not a contract. What happens if we send MET to a contract address? Let's find out!\n\nFirst, let's deploy another contract into our test environment. For this example, we will use our first contract, _Faucet.sol_. Let's add it to the METoken project by copying it to the _contracts_ directory. Our directory should look like this:\n\n[[METoken_directory]]\n----\nMEToken/\n+---- contracts\n|   +---- Faucet.sol\n|   +---- METoken.sol\n|   `---- Migrations.sol\n----\n\nWe'll also add a migration, to deploy +Faucet+ separately from +METoken+:\n\n[[faucet_migration]]\n[source,solidity]\n----\nvar Faucet = artifacts.require(\"Faucet\");\n\nmodule.exports = function(deployer) {\n  // Deploy the Faucet contract as our only task\n  deployer.deploy(Faucet);\n};\n----\n\nLet's compile and migrate the contracts from the Truffle console:\n\n++++\n<pre data-type=\"programlist\">\n$ <strong>truffle console --network ganache</strong>\ntruffle(ganache)&gt; <strong>compile</strong>\nCompiling ./contracts/Faucet.sol...\nWriting artifacts to ./build/contracts\n\ntruffle(ganache)&gt; <strong>migrate</strong>\nUsing network 'ganache'.\n\nRunning migration: 1_initial_migration.js\n  Deploying Migrations...\n  ... 0x89f6a7bd2a596829c60a483ec99665c7af71e68c77a417fab503c394fcd7a0c9\n  Migrations: 0xa1ccce36fb823810e729dce293b75f40fb6ea9c9\nSaving artifacts...\nRunning migration: 2_deploy_contracts.js\n  Replacing METoken...\n  ... 0x28d0da26f48765f67e133e99dd275fac6a25fdfec6594060fd1a0e09a99b44ba\n  METoken: 0x7d6bf9d5914d37bcba9d46df7107e71c59f3791f\nSaving artifacts...\nRunning migration: 3_deploy_faucet.js\n  Deploying Faucet...\n  ... 0x6fbf283bcc97d7c52d92fd91f6ac02d565f5fded483a6a0f824f66edc6fa90c3\n  Faucet: 0xb18a42e9468f7f1342fa3c329ec339f254bc7524\nSaving artifacts...\n</pre>\n++++\n\nGreat. Now let's send some MET to the +Faucet+ contract:\n\n++++\n<pre data-type=\"programlist\">\ntruffle(ganache)&gt; <strong>METoken.deployed().then(instance =>\n                  { instance.transfer(Faucet.address, 100000) })</strong>\ntruffle(ganache)&gt; <strong>METoken.deployed().then(instance =>\n                  { instance.balanceOf(Faucet.address).then(console.log)})</strong>\ntruffle(ganache)&gt; <strong>BigNumber { s: 1, e: 5, c: [ 100000 ] }</strong>\n</pre>\n++++\n\nAlright, we have transferred 1,000 MET to the +Faucet+ contract. Now, how do we withdraw those tokens?\n\nRemember, _Faucet.sol_ is a pretty simple contract. It only has one function, pass:[<span class=\"keep-together\"><code>withdraw</code></span>], which is for withdrawing _ether_. It doesn't have a function for withdrawing MET, or any other ERC20 token. If we use +withdraw+ it will try to send ether, but since +Faucet+ doesn't have a balance of ether yet, it will fail.\n\nThe +METoken+ contract knows that +Faucet+ has a balance, but the only way that it can transfer that balance is if it receives a +transfer+ call from the address of the contract. Somehow we need to make the +Faucet+ contract call the +transfer+ function in pass:[<span class=\"keep-together\"><code>METoken</code></span>].\n\nIf you're wondering what to do next, don't. There is no solution to this problem. The MET sent to +Faucet+ is stuck, forever. Only the +Faucet+ contract can transfer it, and the +Faucet+ contract doesn't have code to call the +transfer+ function of an ERC20 token contract.\n\nPerhaps you anticipated this problem. Most likely, you didn't. In fact, neither did hundreds of Ethereum users who accidentally transferred various tokens to contracts that didn't have any ERC20 capability. According to some estimates, tokens worth more than roughly $2.5 million USD (at the time of writing) have gotten \"stuck\" like this and are lost forever.\n\nOne of the ways that users of ERC20 tokens can inadvertently lose their tokens in a transfer, is when they attempt to transfer to an exchange or another service. They copy an Ethereum address from the website of an exchange, thinking they can simply send tokens to it. However, many exchanges publish receiving addresses that are actually contracts! These contracts are only meant to receive ether, not ERC20 tokens, most often sweeping all funds sent to them to \"cold storage\" or another centralized wallet. Despite the many warnings saying \"do not send tokens to this address,\" lots of tokens are lost this way.(((range=\"endofrange\", startref=\"ix_10tokens-asciidoc14\")))(((range=\"endofrange\", startref=\"ix_10tokens-asciidoc13\")))\n\n[[transfer_workflow_demo]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "Sending ERC20 tokens to contract addresses"}}
{"input": "Explain the Ethereum concept: Demonstrating the &#x201c;approve & transferFrom&#x201d; workflow", "output": "(((\"approve & transferFrom workflow\", id=\"ix_10tokens-asciidoc15\", range=\"startofrange\")))(((\"Faucet.sol contract (test example)\",\"METoken approve & transferFrom workflow demonstration\", id=\"ix_10tokens-asciidoc16\", range=\"startofrange\")))(((\"METoken (Mastering Ethereum Token)\",\"approve & transferFrom workflow demonstration\", id=\"ix_10tokens-asciidoc17\", range=\"startofrange\")))Our +Faucet+ contract couldn't handle ERC20 tokens. Sending tokens to it using the +transfer+ function resulted in the loss of those tokens. Let's rewrite the contract now and make it handle ERC20 tokens. Specifically, we will turn it into a faucet that gives out MET to anyone who asks.\n\nFor this example, we'll make a copy of the _truffle_ project directory (we'll call it __METoken_METFaucet__), initialize +truffle+ and +npm+, install the OpenZeppelin dependencies, and copy the _METoken.sol_ contract. See our first example, in <<METoken_example>>, for the detailed instructions.\n\nOur new faucet contract, _METFaucet.sol_, will look like <<METFaucet>>.\n\n[[METFaucet]]\n.METFaucet.sol: A faucet for METoken", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "Demonstrating the &#x201c;approve & transferFrom&#x201d; workflow"}}
{"input": "Explain the Ethereum concept: Issues with ERC20 Tokens", "output": "(((\"ERC20 token standard\",\"issues with ERC20 tokens\")))The adoption of the ERC20 token standard has been truly explosive. Thousands of tokens have been launched, both to experiment with new capabilities and to raise funds in various \"crowdfund\" auctions and ICOs. However, there are some potential pitfalls, as we saw with the issue of transferring tokens to contract addresses.\n\nOne of the less obvious issues with ERC20 tokens is that they expose subtle differences between tokens and ether itself. Where ether is transferred by a transaction that has a recipient address as its destination, token transfers occur within the _specific token contract state_ and have the token contract as their destination, not the recipient's address. The token contract tracks balances and issues events. In a token transfer, no transaction is actually sent to the recipient of the token. Instead, the recipient's address is added to a map within the token contract itself. A transaction sending ether to an address changes the state of an address. A transaction transferring a token to an address only changes the state of the token contract, not the state of the recipient address. Even a wallet that has support for ERC20 tokens does not become aware of a token balance unless the user explicitly adds a specific token contract to \"watch.\" Some wallets watch the most popular token contracts to detect balances held by addresses they control, but that's limited to a small fraction of existing ERC20 pass:[<span class=\"keep-together\">contracts</span>].\n\nIn fact, it's unlikely that a user would _want_ to track all balances in all possible ERC20 token contracts. Many ERC20 tokens are more like email spam than usable tokens. They automatically create balances for accounts that have ether activity, in order to attract users. If you have an Ethereum address with a long history of activity, especially if it was created in the presale, you will find it full of \"junk\" tokens that appeared out of nowhere. Of course, the address isn't really full of tokens; it's the token contracts that have your address in them. You only see these balances if these token contracts are being watched by the block explorer or wallet you use to view your address.\n\nTokens don't behave the same way as ether. Ether is sent with the +send+ function and accepted by any payable function in a contract or any externally owned address. Tokens are sent using +transfer+ or +approve+ & +transferFrom+ functions that exist only in the ERC20 contract, and do not (at least in ERC20) trigger any payable functions in a recipient contract. Tokens are meant to function just like a cryptocurrency such as ether, but they come with certain differences that break that illusion.\n\n(((\"gas\",\"tokens and\")))(((\"tokens\",\"gas and\")))Consider another issue. To send ether or use any Ethereum contract you need ether to pay for gas. To send tokens, you _also need ether_. You cannot pay for a transaction's gas with a token and the token contract can't pay for the gas for you. This may change at some point in the distant future, but in the meantime this can cause some rather strange user experiences. For example, let's say you use an exchange or ShapeShift to convert some bitcoin to a token. You \"receive\" the token in a wallet that tracks that token's contract and shows your balance. It looks the same as any of the other cryptocurrencies you have in your wallet. Try sending the token, though, and your wallet will inform you that you need ether to do that. You might be confused&#x2014;after all, you didn't need ether to receive the token. Perhaps you have no ether. Perhaps you didn't even know the token was an ERC20 token on Ethereum; maybe you thought it was a cryptocurrency with its own blockchain. The illusion just broke.\n\nSome of these issues are specific to ERC20 tokens. Others are more general issues that relate to abstraction and interface boundaries within Ethereum. Some can be solved by changing the token interface, while others may need changes to fundamental structures within Ethereum (such as the distinction between EOAs and contracts, and between transactions and messages). Some may not be \"solvable\" exactly and may require user interface design to hide the nuances and make the user experience consistent regardless of the underlying distinctions.\n\nIn the next sections we will look at various proposals that attempt to address some of these issues.\n\n[[ERC223_std]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "Issues with ERC20 Tokens"}}
{"input": "Explain the Ethereum concept: ERC223: A Proposed Token Contract Interface Standard", "output": "(((\"ERC223 token standard proposal\")))(((\"tokens\",\"ERC223 standard proposal\")))The ERC223 proposal attempts to solve the problem of inadvertent transfer of tokens to a contract (that may or may not support tokens) by detecting whether the destination address is a contract or not. ERC223 requires that contracts designed to accept tokens implement a function named +tokenFallback+. If the destination of a transfer is a contract and the contract does not have support for tokens (i.e., does not implement +tokenFallback+), the transfer fails.\n\n[[is_contract]]\nTo detect whether the destination address is a contract, the ERC223 reference implementation uses a small segment of inline bytecode in a rather creative way:\n\n[source,solidity]\n----\nfunction isContract(address _addr) private view returns (bool is_contract) {\n  uint length;\n    assembly {\n       // retrieve the size of the code on target address; this needs assembly\n       length := extcodesize(_addr)\n    }\n    return (length>0);\n}\n----\n\n[[ERC223_interface]]\nThe ERC223 contract interface specification is:\n\n[source,solidity]\n----\ninterface ERC223Token {\n  uint public totalSupply;\n  function balanceOf(address who) public view returns (uint);\n\n  function name() public view returns (string _name);\n  function symbol() public view returns (string _symbol);\n  function decimals() public view returns (uint8 _decimals);\n  function totalSupply() public view returns (uint256 _supply);\n\n  function transfer(address to, uint value) public returns (bool ok);\n  function transfer(address to, uint value, bytes data) public returns (bool ok);\n  function transfer(address to, uint value, bytes data, string custom_fallback)\n      public returns (bool ok);\n\n  event Transfer(address indexed from, address indexed to, uint value,\n                 bytes indexed data);\n}\n----\n\nERC223 is not widely implemented, and there is some debate in https://github.com/ethereum/EIPs/issues/223[the ERC discussion] thread about backward compatibility and trade-offs between implementing changes at the contract interface level versus the user interface. The debate continues.", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "ERC223: A Proposed Token Contract Interface Standard"}}
{"input": "Explain the Ethereum concept: ERC777: A Proposed Token Contract Interface Standard", "output": "(((\"ERC777 token standard proposal\", id=\"ix_10tokens-asciidoc18\", range=\"startofrange\")))(((\"tokens\",\"ERC777 standard proposal\", id=\"ix_10tokens-asciidoc19\", range=\"startofrange\")))Another proposal for an improved token contract standard is https://eips.ethereum.org/EIPS/eip-777[ERC777]. This proposal has several goals, including:\n\n* To offer an ERC20-compatible interface\n* To transfer tokens using a +send+ function, similar to ether transfers\n* To be compatible with ERC820 for token contract registration\n* To allow contracts and addresses to control which tokens they send through a `tokensToSend` function that is called prior to sending\n* To enable contracts and addresses to be notified of the tokens' receipt by calling a `tokensReceived` function in the recipient, and to reduce the probability of tokens being locked into contracts by requiring contracts to provide a pass:[<span class=\"keep-together\"><code>tokensReceived</code></span>] function\n* To allow existing contracts to use proxy contracts for the +tokensToSend+ and +tokensReceived+ functions\n* To operate in the same way whether sending to a contract or an EOA\n* To provide specific events for the minting and burning of tokens\n* To enable operators (trusted third parties, intended to be verified contracts) to move tokens on behalf of a token holder\n* To provide metadata on token transfer transactions in +userData+ and +operatorData+ fields\n\nThe ongoing discussion on ERC777 can be found https://github.com/ethereum/EIPs/issues/777[on GitHub].\n\n[[ERC777_interface]]\nThe ERC777 contract interface specification is:\n\n[source,solidity]\n----\ninterface ERC777Token {\n    function name() public constant returns (string);\n    function symbol() public constant returns (string);\n    function totalSupply() public constant returns (uint256);\n    function granularity() public constant returns (uint256);\n    function balanceOf(address owner) public constant returns (uint256);\n\n    function send(address to, uint256 amount, bytes userData) public;\n\n    function authorizeOperator(address operator) public;\n    function revokeOperator(address operator) public;\n    function isOperatorFor(address operator, address tokenHolder)\n        public constant returns (bool);\n    function operatorSend(address from, address to, uint256 amount,\n                          bytes userData,bytes operatorData) public;\n\n    event Sent(address indexed operator, address indexed from,\n               address indexed to, uint256 amount, bytes userData,\n               bytes operatorData);\n    event Minted(address indexed operator, address indexed to,\n                 uint256 amount, bytes operatorData);\n    event Burned(address indexed operator, address indexed from,\n                 uint256 amount, bytes userData, bytes operatorData);\n    event AuthorizedOperator(address indexed operator,\n                             address indexed tokenHolder);\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n}\n----\n\n[[ERC777_hooks]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "ERC777: A Proposed Token Contract Interface Standard"}}
{"input": "Explain the Ethereum concept: ERC777 hooks", "output": "[[ERC777TokensSender_interface]]\nThe ERC777 tokens sender hook specification is:\n\n[source,solidity]\n----\ninterface ERC777TokensSender {\n    function tokensToSend(address operator, address from, address to,\n                          uint value, bytes userData, bytes operatorData) public;\n}\n----\n\nThe implementation of this interface is required for any address wishing to be notified of, to handle, or to prevent the debit of tokens. The address for which the contract implements this interface must be registered via ERC820, whether the contract implements the interface for itself or for another address.\n\n[[ERC777TokensRecipient_interface]]\nThe ERC777 tokens recipient hook specification is:\n\n[source,solidity]\n----\ninterface ERC777TokensRecipient {\n  function tokensReceived(\n     address operator, address from, address to,\n    uint amount, bytes userData, bytes operatorData\n  ) public;\n}\n----\n\nThe implementation of this interface is required for any address wishing to be notified of, to handle, or to reject the reception of tokens. The same logic and requirements apply to the tokens recipient as to the tokens sender interface, with the added constraint that recipient contracts must implement this interface to prevent locking tokens. If the recipient contract does not register an address implementing this interface, the transfer of tokens will fail.\n\nAn important aspect is that only one token sender and one token recipient can be registered per address. Hence, for every ERC777 token transfer the same hook functions are called upon debit and reception of every ERC777 token transfer. A specific token can be identified in these functions using the message's sender, which is the specific token contract address, to handle a particular use case.\n\nOn the other hand, the same token sender and token recipient hooks can be registered for multiple addresses and the hooks can distinguish who are the sender and the intended recipient using the `from` and `to` parameters.\n\nA http://bit.ly/2qkAKba[reference implementation] of ERC777 is linked in the proposal. ERC777 depends on a parallel proposal for a registry contract, specified in ERC820. Some of the debate on ERC777 is about the complexity of adopting two big changes at once: a new token standard and a registry standard. The discussion continues.(((range=\"endofrange\", startref=\"ix_10tokens-asciidoc19\")))(((range=\"endofrange\", startref=\"ix_10tokens-asciidoc18\")))\n\n[[erc721]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "ERC777 hooks"}}
{"input": "Explain the Ethereum concept: ERC721: Non-fungible Token (Deed) Standard", "output": "(((\"deed\",\"and ERC721 non-fungible token standard\", id=\"ix_10tokens-asciidoc20\", range=\"startofrange\")))(((\"ERC721 non-fungible token standard\", id=\"ix_10tokens-asciidoc21\", range=\"startofrange\")))(((\"non-fungible tokens (NFTs)\",\"ERC721 non-fungible token standard\", id=\"ix_10tokens-asciidoc22\", range=\"startofrange\")))(((\"tokens\",\"ERC721 non-fungible token standard\", id=\"ix_10tokens-asciidoc23\", range=\"startofrange\")))All the token standards we have looked at so far are for _fungible_ tokens, meaning that units of a token are interchangeable. The ERC20 token standard only tracks the final balance of each account and does not (explicitly) track the provenance of any token.\n\n(((\"deed\",\"defined\")))The http://bit.ly/2Ogs7Im[ERC721 proposal] is for a standard for _non-fungible_ tokens, also known as _deeds_.\n\nFrom the Oxford Dictionary:\n\n____\n_deed_: A legal document that is signed and delivered, especially one regarding the ownership of property or legal rights.\n____\n\nThe use of the word \"deed\" is intended to reflect the \"ownership of property\" part, even though these are not recognized as \"legal documents\" in any jurisdiction&#x2014;yet. It is likely that at some point in the future, legal ownership based on digital signatures on a blockchain platform will be legally recognized.\n\nNon-fungible tokens track ownership of a unique thing. The thing owned can be a digital item, such as an in-game item or digital collectible; or the thing can be a physical item whose ownership is tracked by a token, such as a house, a car, or an artwork. Deeds can also represent things with negative value, such as loans (debt), liens, easements, etc. The ERC721 standard places no limitation or expectation on the nature of the thing whose ownership is tracked by a deed and requires only that it can be uniquely identified, which in the case of this standard is achieved by a 256-bit pass:[<span class=\"keep-together\">identifier</span>].\n\nThe details of the standard and discussion are tracked in two different GitHub pass:[<span class=\"keep-together\">locations</span>]:\n\n* https://github.com/ethereum/EIPs/issues/721[Initial proposal]\n\n* https://github.com/ethereum/EIPs/pull/841[Continued discussion]\n\n[[map_deed_owner]]\nTo grasp the basic difference between ERC20 and ERC721, it is sufficient to look at the internal data structure used in ERC721:\n\n[source,solidity]\n----\n// Mapping from deed ID to owner\nmapping (uint256 => address) private deedOwner;\n----\n\nWhereas ERC20 tracks the balances that belong to each owner, with the owner being the primary key of the mapping, ERC721 tracks each deed ID and who owns it, with the deed ID being the primary key of the mapping. From this basic difference flow all the properties of a non-fungible token.\n\n[[ERC721_interface]]\nThe ERC721 contract interface specification is:\n\n[source,solidity]\n----\ninterface ERC721 /* is ERC165 */ {\n    event Transfer(address indexed _from, address indexed _to, uint256 _deedId);\n    event Approval(address indexed _owner, address indexed _approved,\n                   uint256 _deedId);\n    event ApprovalForAll(address indexed _owner, address indexed _operator,\n                         bool _approved);\n\n    function balanceOf(address _owner) external view returns (uint256 _balance);\n    function ownerOf(uint256 _deedId) external view returns (address _owner);\n    function transfer(address _to, uint256 _deedId) external payable;\n    function transferFrom(address _from, address _to, uint256 _deedId)\n        external payable;\n    function approve(address _approved, uint256 _deedId) external payable;\n    function setApprovalForAll(address _operator, boolean _approved) payable;\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n----\n\nERC721 also supports two _optional_ interfaces, one for metadata and one for enumeration of deeds and owners.\n\n[[ERC721_metadata]]\nThe ERC721 optional interface for metadata is:\n\n[source,solidity]\n----\ninterface ERC721Metadata /* is ERC721 */ {\n    function name() external pure returns (string _name);\n    function symbol() external pure returns (string _symbol);\n    function deedUri(uint256 _deedId) external view returns (string _deedUri);\n}\n----\n\n[[ERC721_enum]]\nThe ERC721 optional interface for enumeration is(((range=\"endofrange\", startref=\"ix_10tokens-asciidoc23\")))(((range=\"endofrange\", startref=\"ix_10tokens-asciidoc22\")))(((range=\"endofrange\", startref=\"ix_10tokens-asciidoc21\")))(((range=\"endofrange\", startref=\"ix_10tokens-asciidoc20\"))):(((range=\"endofrange\", startref=\"ix_10tokens-asciidoc4\")))\n\n[source,solidity]\n----\ninterface ERC721Enumerable /* is ERC721 */ {\n    function totalSupply() external view returns (uint256 _count);\n    function deedByIndex(uint256 _index) external view returns (uint256 _deedId);\n    function countOfOwners() external view returns (uint256 _count);\n    function ownerByIndex(uint256 _index) external view returns (address _owner);\n    function deedOfOwnerByIndex(address _owner, uint256 _index) external view\n        returns (uint256 _deedId);\n}\n----\n\n[[token_std_review]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "ERC721: Non-fungible Token (Deed) Standard"}}
{"input": "Explain the Ethereum concept: Using Token Standards", "output": "(((\"token standards (generally)\", seealso=\"specific standards, e.g.: ERC20 token standard\", id=\"ix_10tokens-asciidoc24\", range=\"startofrange\")))(((\"tokens\",\"using token standards\", id=\"ix_10tokens-asciidoc25\", range=\"startofrange\")))In the previous section we reviewed several proposed standards and a couple of widely deployed standards for token contracts. What exactly do these standards do? Should you use these standards? How should you use them? Should you add functionality beyond these standards? Which standards should you use? We will examine some of those questions next.\n\n[[token_std_purpose]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "Using Token Standards"}}
{"input": "Explain the Ethereum concept: What Are Token Standards? What Is Their Purpose?", "output": "(((\"token standards (generally)\",\"defined\")))Token standards are the _minimum_ specifications for an implementation. What that means is that in order to be compliant with, say, ERC20, you need to at minimum implement the functions and behavior specified by the ERC20 standard. You are also free to _add_ to the functionality by implementing functions that are not part of the standard.\n\n(((\"token standards (generally)\",\"purpose of\")))The primary purpose of these standards is to encourage _interoperability_ between contracts. Thus, all wallets, exchanges, user interfaces, and other infrastructure components can _interface_ in a predictable manner with any contract that follows the specification. In other words, if you deploy a contract that follows the ERC20 standard, all existing wallet users can seamlessly start trading your token without any wallet upgrade or effort on your part.\n\nThe standards are meant to be _descriptive_, rather than _prescriptive_. How you choose to implement those functions is up to you&#x2014;the internal functioning of the contract is not relevant to the standard. They have some functional requirements, which govern the behavior under specific circumstances, but they do not prescribe an implementation. An example of this is the behavior of a +transfer+ function if the value is set to zero.\n\n[[should_use_std]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "What Are Token Standards? What Is Their Purpose?"}}
{"input": "Explain the Ethereum concept: Should You Use These Standards?", "output": "(((\"token standards (generally)\",\"reasons to use\")))Given all these standards, each developer faces a dilemma: use the existing standards or innovate beyond the restrictions they impose?\n\nThis dilemma is not easy to resolve. Standards necessarily restrict your ability to innovate, by creating a narrow \"rut\" that you have to follow. On the other hand, the basic standards have emerged from experience with hundreds of applications and often fit well with the vast majority of use cases.\n\nAs part of this consideration is an even bigger issue: the value of interoperability and broad adoption. If you choose to use an existing standard, you gain the value of all the systems designed to work with that standard. If you choose to depart from the standard, you have to consider the cost of building all of the support infrastructure on your own, or persuading others to support your implementation as a new standard. The tendency to forge your own path and ignore existing standards is known as \"Not Invented Here\" syndrome and is antithetical to open source culture. On the other hand, progress and innovation depend on departing from tradition sometimes. It's a tricky choice, so consider it carefully!\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "Should You Use These Standards?"}}
{"input": "Explain the Ethereum concept: Security by Maturity", "output": "(((\"security (smart contracts)\",\"token standard implementation choices\")))(((\"token standards (generally)\",\"implementation choices\")))Beyond the choice of standard, there is the parallel choice of _implementation_. When you decide to use a standard such as ERC20, you have to then decide how to implement a compatible design. There are a number of existing \"reference\" implementations that are widely used in the Ethereum ecosystem, or you could write your own from scratch. Again, this choice represents a dilemma that can have serious security implications.\n\nExisting implementations are &#x201c;battle-tested.&#x201d; While it is impossible to prove that they are secure, many of them underpin millions of dollars' worth of tokens. They have been attacked, repeatedly and vigorously. So far, no significant vulnerabilities have been discovered. Writing your own is not easy&#x2014;there are many subtle ways that a contract can be compromised. It is much safer to use a well-tested, widely used implementation. In our examples, we used the OpenZeppelin implementation of the ERC20 standard, as this implementation is security-focused from the ground up.\n\nIf you use an existing implementation you can also extend it. Again, however, be careful with this impulse. Complexity is the enemy of security. (((\"attack surface\")))Every single line of code you add expands the _attack surface_ of your contract and could represent a vulnerability lying in wait. You may not notice a problem until you put a lot of value on top of the contract and someone breaks it.\n\n[TIP]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "Security by Maturity"}}
{"input": "Explain the Ethereum concept: Extensions to Token Interface Standards", "output": "(((\"token standards (generally)\",\"extensions to\")))The token standards discussed in this chapter provide a very minimal interface, with limited functionality. Many projects have created extended implementations to support features that they need for their applications. Some of these features include:\n\nOwner control:: The ability to give specific addresses, or sets of addresses (i.e., multisignature schemes), special capabilities, such as blacklisting, whitelisting, minting, recovery, etc.\n\nBurning:: The ability to deliberately destroy (&#x201c;burn&#x201d;) tokens by transferring them to an unspendable address or by erasing a balance and reducing the supply.\n\nMinting:: The ability to add to the total supply of tokens, at a predictable rate or by \"fiat\" of the creator of the token.\n\nCrowdfunding:: The ability to offer tokens for sale, for example through an auction, market sale, reverse auction, etc.\n\nCaps:: The ability to set predefined and immutable limits on the total supply (the opposite of the \"minting\" feature).\n\nRecovery backdoors:: Functions to recover funds, reverse transfers, or dismantle the token that can be activated by a designated address or set of addresses.\n\nWhitelisting:: The ability to restrict actions (such as token transfers) to specific addresses. Most commonly used to offer tokens to \"accredited investors\" after vetting by the rules of different jurisdictions. There is usually a mechanism for updating the whitelist.\n\nBlacklisting:: The ability to restrict token transfers by disallowing specific addresses. There is usually a function for updating the blacklist.\n\nThere are reference implementations for many of these functions, for example in the OpenZeppelin library. Some of these are use case\u2013specific and only implemented in a few tokens. There are, as of now, no widely accepted standards for the interfaces to these functions.\n\nAs previously discussed, the decision to extend a token standard with additional functionality represents a trade-off between innovation/risk and interoperability/security.\n\n[[tokens_ico]]", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "Extensions to Token Interface Standards"}}
{"input": "Explain the Ethereum concept: Tokens and ICOs", "output": "(((\"Initial Coin Offerings (ICOs)\",\"tokens and\")))(((\"tokens\",\"ICOs and\")))Tokens have been an explosive development in the Ethereum ecosystem. It is likely that they will become a very important component of all smart contract platforms like Ethereum.\n\nNevertheless, the importance and future impact of these standards should not be confused with an endorsement of current token offerings. As in any early-stage technology, the first wave of products and companies will almost all fail, and some will fail spectacularly. Many of the tokens on offer in Ethereum today are barely disguised scams, pyramid schemes, and money grabs.\n\nThe trick is to separate the long-term vision and impact of this technology, which is likely to be huge, from the short-term bubble of token ICOs, which are rife with fraud. Token standards and the platform will survive the current token mania, and then they will likely change the world.", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "Tokens and ICOs"}}
{"input": "Explain the Ethereum concept: Conclusions", "output": "Tokens are a very powerful concept in Ethereum and can form the basis of many important decentralized applications. In this chapter we looked at the different types of tokens and token standards, and you built your first token and related application. We will revisit tokens again in <<decentralized_applications_chap>>, where you will use a non-fungible token as the basis for an auction DApp.(((range=\"endofrange\", startref=\"ix_10tokens-asciidoc0\")))", "metadata": {"source": "ethereumbook", "chapter": "10tokens.asciidoc", "section": "Conclusions"}}
{"input": "Explain the Ethereum concept: Oracles", "output": "(((\"oracles\", id=\"ix_11oracles-asciidoc0\", range=\"startofrange\")))In this chapter we discuss _oracles_, which are systems that can provide external data sources to Ethereum smart contracts. The term \"oracle\" comes from Greek mythology, where it referred to a person in communication with the gods who could see visions of the future. In the context of blockchains, an oracle is a system that can answer questions that are external to Ethereum. (((\"trustless systems\", seealso=\"oracles\")))Ideally oracles are systems that are _trustless_, meaning that they do not need to be trusted because they operate on decentralized principles.\n\n[[why_oracles]]", "metadata": {"source": "ethereumbook", "chapter": "11oracles.asciidoc", "section": "Oracles"}}
{"input": "Explain the Ethereum concept: Why Oracles Are Needed", "output": "(((\"oracles\",\"reasons for using\")))A key component of the Ethereum platform is the Ethereum Virtual Machine, with its ability to execute programs and update the state of Ethereum, constrained by consensus rules, on any node in the decentralized network. In order to maintain consensus, EVM execution must be totally deterministic and based only on the shared context of the Ethereum state and signed transactions. This has two particularly important consequences: the first is that there can be no intrinsic source of randomness for the EVM and smart contracts to work with; the second is that extrinsic data can only be introduced as the data payload of a transaction.\n\nLet's unpack those two consequences further. To understand the prohibition of a true random function in the EVM to provide randomness for smart contracts, consider the effect on attempts to achieve consensus after the execution of such a function: node A would execute the command and store +3+ on behalf of the smart contract in its storage, while node B, executing the same smart contract, would store +7+ instead. Thus, nodes A and B would come to different conclusions about what the resulting state should be, despite having run exactly the same code in the same context. Indeed, it could be that a different resulting state would be achieved every time that the smart contract is evaluated. As such, there would be no way for the network, with its multitude of nodes running independently around the world, to ever come to a decentralized consensus on what the resulting state should be. In practice, it would get much worse than this example very quickly, because knock-on effects, including ether transfers, would build up exponentially.\n\nNote that pseudorandom functions, such as cryptographically secure hash functions (which are deterministic and therefore can be, and indeed are, part of the EVM), are not enough for many applications. Take a gambling game that simulates coin flips to resolve bet payouts, which needs to randomize heads or tails&#x2014;a miner can gain an advantage by playing the game and only including their transactions in blocks for which they will win. How do we get around this problem? Since all nodes can agree on the contents of signed transactions, extrinsic information, including sources of randomness, price information, weather forecasts, etc., can be introduced as the data part of transactions sent to the network. However, such data simply cannot be trusted, because it comes from unverifiable sources. As such, we have just deferred the problem. We use oracles to attempt to solve these problems, which we will discuss in detail, in the rest of this chapter.\n\n[[oracle_use_cases]]", "metadata": {"source": "ethereumbook", "chapter": "11oracles.asciidoc", "section": "Why Oracles Are Needed"}}
{"input": "Explain the Ethereum concept: Oracle Use Cases and Examples", "output": "(((\"oracles\",\"use cases/examples\")))Oracles, ideally, provide a trustless (or at least near-trustless) way of getting extrinsic (i.e., \"real-world\" or off-chain) information, such as the results of football games, the price of gold, or truly random numbers, onto the Ethereum platform for smart contracts to use. They can also be used to relay data securely to DApp frontends directly. Oracles can therefore be thought of as a mechanism for bridging the gap between the off-chain world and smart contracts. Allowing smart contracts to enforce contractual relationships based on real-world events and data broadens their scope dramatically. However, this can also introduce external risks to Ethereum's security model. Consider a \"smart will\" contract that distributes assets when a person dies. This is something frequently discussed in the smart contract space, and highlights the risks of a trusted oracle. If the inheritance amount controlled by such a contract is high enough, the incentive to hack the oracle and trigger distribution of assets _before_ the owner dies is very high.\n\nNote that some oracles provide data that is particular to a specific private data source, such as academic certificates or government IDs. The source of such data, such as a university or government department, is fully trusted, and the truth of the data is subjective (truth is only determined by appeal to the authority of the source). Such data cannot therefore be provided trustlessly\u2014i.e., without  trusting a source\u2014as there is no independently verifiable objective truth. As such, we include these data sources in our definition of what counts as \"oracles\" because they also provide a data bridge for smart contracts. The data they provide generally takes the form of attestations, such as passports or records of achievement. Attestations will become a big part of the success of blockchain platforms in the future, particularly in relation to the related issues of verifying identity or reputation, so it is important to explore how they can be served by blockchain platforms.\n\nSome more examples of data that might be provided by oracles include:\n\n* Random numbers/entropy from physical sources such as quantum/thermal processes: e.g., to fairly select a winner in a lottery smart contract\n* Parametric triggers indexed to natural hazards: e.g., triggering of catastrophe bond smart contracts, such as Richter scale measurements for an earthquake bond\n* Exchange rate data: e.g., for accurate pegging of cryptocurrencies to fiat currency\n* Capital markets data: e.g., pricing baskets of tokenized assets/securities\n* Benchmark reference data: e.g., incorporating interest rates into smart financial derivatives\n* Static/pseudostatic data: security identifiers, country codes, currency codes, etc.\n* Time and interval data: for event triggers grounded in precise time measurements\n* Weather data: e.g., insurance premium calculations based on weather forecasts\n* Political events: for prediction market resolution\n* Sporting events: for prediction market resolution and fantasy sports contracts\n* Geolocation data: e.g., as used in supply chain tracking\n* Damage verification: for insurance contracts\n* Events occurring on other blockchains: interoperability functions\n* Ether market price: e.g., for fiat gas price oracles\n* Flight statistics: e.g., as used by groups and clubs for flight ticket pooling\n\n\nIn the following sections, we will examine some of the ways oracles can be implemented, including basic oracle patterns, computation oracles, decentralized oracles, and oracle client implementations in Solidity.\n\n[[oracle_design_patterns]]", "metadata": {"source": "ethereumbook", "chapter": "11oracles.asciidoc", "section": "Oracle Use Cases and Examples"}}
{"input": "Explain the Ethereum concept: Oracle Design Patterns", "output": "(((\"oracles\",\"design patterns\", id=\"ix_11oracles-asciidoc1\", range=\"startofrange\")))All oracles provide a few key functions, by definition. These include the ability to:\n\n* Collect data from an off-chain source.\n* Transfer the data on-chain with a signed message.\n* Make the data available by putting it in a smart contract's storage.\n\nOnce the data is available in a smart contract's storage, it can be accessed by other smart contracts via message calls that invoke a \"retrieve\" function of the oracle's smart contract; it can also be accessed by Ethereum nodes or network-enabled clients directly by \"looking into&#x201d; the oracle's storage.\n\nThe three main ways to set up an oracle can be categorized as _request\u2013response_, pass:[<span class=\"keep-together\"><em>publish-subscribe</em></span>], and _immediate-read_.\n\n(((\"immediate-read oracles\")))(((\"oracles\",\"immediate-read\")))Starting with the simplest, _immediate-read_ oracles are those that provide data that is only needed for an immediate decision, like \"What is the address for __ethereumbook.info__?\" or \"Is this person over 18?\" Those wishing to query this kind of data tend to do so on a \"just-in-time\" basis; the lookup is done when the information is needed and possibly never again. Examples of such oracles include those that hold data about or issued by organizations, such as academic certificates, dial codes, institutional memberships, airport identifiers, self-sovereign IDs, etc. This type of oracle stores data once in its contract storage, whence any other smart contract can look it up using a request call to the oracle contract. It may be updated. The data in the oracle's storage is also available for direct lookup by blockchain-enabled (i.e., Ethereum pass:[<span class=\"keep-together\">client\u2013connected</span>]) applications without having to go through the palaver and incurring the gas costs of issuing a transaction. A shop wanting to check the age of a customer wishing to purchase alcohol could use an oracle in this way. This type of oracle is attractive to an organization or company that might otherwise have to run and maintain servers to answer such data requests. Note that the data stored by the oracle is likely not to be the raw data that the oracle is serving, e.g., for efficiency or privacy reasons. A university might set up an oracle for the certificates of academic achievement of past students. However, storing the full details of the certificates (which could run to pages of courses taken and grades achieved) would be excessive. Instead, a hash of the certificate is sufficient. Likewise, a government might wish to put citizen IDs onto the Ethereum platform, where clearly the details included need to be kept private. Again, hashing the data (more carefully, in Merkle trees with salts) and only storing the root hash in the smart contract's storage would be an efficient way to organize such a service.\n\n(((\"oracles\",\"publish-subscribe\")))(((\"publish-subscribe oracles\")))The next setup is _publish\u2013subscribe_, where an oracle that effectively provides a broadcast service for data that is expected to change (perhaps both regularly and frequently) is either polled by a smart contract on-chain, or watched by an off-chain daemon for updates. This category has a pattern similar to RSS feeds, WebSub, and the like, where the oracle is updated with new information and a flag signals that new data is available to those who consider themselves \"subscribed.\" Interested parties must either poll the oracle to check whether the latest information has changed, or listen for updates to oracle contracts and act when they occur. Examples include price feeds, weather information, economic or social statistics, traffic data, etc. Polling is very inefficient in the world of web servers, but not so in the peer-to-peer context of blockchain platforms: Ethereum clients have to keep up with all state changes, including changes to contract storage, so polling for data changes is a local call to a synced client. Ethereum event logs make it particularly easy for applications to look out for oracle updates, and so this pattern can in some ways even be considered a \"push\" service. However, if the polling is done from a smart contract, which might be necessary for some decentralized applications (e.g., where activation incentives are not possible), then significant gas expenditure may be incurred.\n\n(((\"oracles\",\"request-response\")))(((\"request-response oracles\")))The _request\u2013response_ category is the most complicated: this is where the data space is too huge to be stored in a smart contract and users are expected to only need a small part of the overall dataset at a time. It is also an applicable model for data provider businesses. In practical terms, such an oracle might be implemented as a system of on-chain smart contracts and off-chain infrastructure used to monitor requests and retrieve and return data. A request for data from a decentralized application would typically be an asynchronous process involving a number of steps. In this pattern, firstly, an EOA transacts with a decentralized application, resulting in an interaction with a function defined in the oracle smart contract. This function initiates the request to the oracle, with the associated arguments detailing the data requested in addition to supplementary information that might include callback functions and scheduling parameters. Once this transaction has been validated, the oracle request can be observed as an EVM event emitted by the oracle contract, or as a state change; the arguments can be retrieved and used to perform the actual query of the off-chain data source. The oracle may also require payment for processing the request, gas payment for the callback, and permissions to access the requested data. Finally, the resulting data is signed by the oracle owner, attesting to the validity of the data at a given time, and delivered in a transaction to the decentralized application that made the request\u2014either directly or via the oracle contract. Depending on the scheduling parameters, the oracle may broadcast further transactions updating the data at regular intervals (e.g., end-of-day pricing information).\n\nThe steps for a request\u2013response oracle may be summarized as follows:\n\n1. Receive a query from a DApp.\n2. Parse the query.\n3. Check that payment and data access permissions are provided.\n4. Retrieve relevant data from an off-chain source (and encrypt it if necessary).\n5. Sign the transaction(s) with the data included.\n6. Broadcast the transaction(s) to the network.\n7. Schedule any further necessary transactions, such as notifications, etc.\n\nA range of other schemes are also possible; for example, data can be requested from and returned directly by an EOA, removing the need for an oracle smart contract. Similarly, the request and response could be made to and from an Internet of Things\u2013enabled hardware sensor. Therefore, oracles can be human, software, or hardware.\n\nThe request\u2013response pattern described here is commonly seen in client\u2013server architectures. While this is a useful messaging pattern that allows applications to have a two-way conversation, it is perhaps inappropriate under certain conditions. For example, a smart bond requiring an interest rate from an oracle might have to request the data on a daily basis under a request\u2013response pattern in order to ensure the rate is always correct. Given that interest rates change infrequently, a publish\u2013subscribe pattern may be more appropriate here\u2014especially when taking into consideration Ethereum's limited bandwidth.\n\nPublish\u2013subscribe is a pattern where publishers (in this context, oracles) do not send messages directly to receivers, but instead categorize published messages into distinct classes. Subscribers are able to express an interest in one or more classes and retrieve only those messages that are of interest. Under such a pattern, an oracle might write the interest rate to its own internal storage each time it changes. Multiple subscribed DApps can simply read it from the oracle contract, thereby reducing the impact on network bandwidth while minimizing storage costs.\n\n(((\"broadcast (multicast) oracle\")))(((\"multicast (broadcast) oracle\")))(((\"oracles\",\"broadcast/multicast\")))In a broadcast or multicast pattern, an oracle would post all messages to a channel and subscribing contracts would listen to the channel under a variety of subscription modes. For example, an oracle might publish messages to a cryptocurrency exchange rate channel. A subscribing smart contract could request the full content of the channel if it required the time series for, e.g., a moving average calculation; another might require only the latest rate for a spot price calculation. A broadcast pattern is appropriate where the oracle does not need to know the identity of the subscribing pass:[<span class=\"keep-together\">contract</span>].(((range=\"endofrange\", startref=\"ix_11oracles-asciidoc1\")))\n\n[[data_authentication_sec]]", "metadata": {"source": "ethereumbook", "chapter": "11oracles.asciidoc", "section": "Oracle Design Patterns"}}
{"input": "Explain the Ethereum concept: Data Authentication", "output": "(((\"data authentication, oracles and\")))(((\"oracles\",\"and data authentication\")))(((\"oracles\",\"data authentication with\")))If we assume that the source of data being queried by a DApp is both authoritative and trustworthy (a not insignificant assumption), an outstanding question remains: given that the oracle and the request\u2013response mechanism may be operated by distinct entities, how are we able trust this mechanism? There is a distinct possibility that data may be tampered with in transit, so it is critical that off-chain methods are able to attest to the returned data's integrity. Two common approaches to data authentication are _authenticity proofs_ and _trusted execution environments_ (TEEs).\n\n(((\"authenticity proofs\")))Authenticity proofs are cryptographic guarantees that data has not been tampered with. Based on a variety of attestation techniques (e.g., digitally signed proofs), they effectively shift the trust from the data carrier to the attestor (i.e., the provider of the attestation). By verifying the authenticity proof on-chain, smart contracts are able to verify the integrity of the data before operating upon it. (((\"Oraclize\")))http://www.oraclize.it/[Oraclize] is an example of an oracle service leveraging a variety of authenticity proofs. (((\"TLSNotary proofs\")))One such proof that is currently available for data queries from the Ethereum main network is the TLSNotary proof. TLSNotary proofs allow a client to provide evidence to a third party that HTTPS web traffic occurred between the client and a server. While HTTPS is itself secure, it doesn\u2019t support data signing. As a result, TLSNotary proofs rely on TLSNotary (via PageSigner) signatures. TLSNotary proofs leverage the Transport Layer Security (TLS) protocol, enabling the TLS master key, which signs the data after it has been accessed, to be split between three parties: the server (the oracle), an auditee (Oraclize), and an auditor. Oraclize uses an Amazon Web Services (AWS) virtual machine instance as the auditor, which can be verified as having been unmodified since instantiation. This AWS instance stores the TLSNotary secret, allowing it to provide honesty proofs. Although it offers higher assurances against data tampering than a pure request\u2013response mechanism, this approach does require the assumption that Amazon itself will not tamper with the VM instance.\n\n(((\"TEEs (trusted execution environments)\")))(((\"Town Crier\")))(((\"trusted execution environments (TEEs)\")))http://www.town-crier.org/[Town Crier] is an authenticated data feed oracle system based on the TEE approach; such methods utilize hardware-based secure enclaves to ensure data integrity. Town Crier uses Intel's  (((\"SGX (Software Guard eXtensions)\")))(((\"Software Guard eXtensions (SGX)\")))Software Guard eXtensions (SGX) to ensure that responses from HTTPS queries can be verified as authentic. SGX provides guarantees of integrity, ensuring that applications running within an enclave are protected by the CPU against tampering by any other process. It also provides confidentiality, ensuring that an application's state is opaque to other processes when running within the enclave. And finally, SGX allows attestation, by generating a digitally signed proof that an application\u2014securely identified by a hash of its build\u2014is actually running within an enclave. By verifying this digital signature, it is possible for a decentralized application to prove that a Town Crier instance is running securely within an SGX enclave. This, in turn, proves that the instance has not been tampered with and that the data emitted by Town Crier is therefore authentic. The confidentiality property additionally enables Town Crier to handle private data by allowing data queries to be encrypted using the Town Crier instance's public key. Operating an oracle's query/response mechanism within an enclave such as SGX effectively allows us to think of it as running securely on trusted third-party hardware, ensuring that the requested data is returned untampered with (assuming that we trust Intel/SGX).\n\n[[computation_oracles_sec]]", "metadata": {"source": "ethereumbook", "chapter": "11oracles.asciidoc", "section": "Data Authentication"}}
{"input": "Explain the Ethereum concept: Computation Oracles", "output": "(((\"oracles\",\"computation oracles\", id=\"ix_11oracles-asciidoc2\", range=\"startofrange\")))So far, we have only discussed oracles in the context of requesting and delivering data. However, oracles can also be used to perform arbitrary computation, a function that can be especially useful given Ethereum\u2019s inherent block gas limit and comparatively expensive computation costs. Rather than just relaying the results of a query, computation oracles can be used to perform computation on a set of inputs and return a calculated result that may have been infeasible to calculate on-chain. For example, one might use a computation oracle to perform a computationally intensive regression calculation in order to estimate the yield of a bond contract.\n\n(((\"Oraclize\")))If you are willing to trust a centralized but auditable service, you can go again to Oraclize. They provide a service that allows decentralized applications to request the output of a computation performed in a sandboxed AWS virtual machine. The AWS instance creates an executable container from a user-configured Dockerfile packed in an archive that is uploaded to the Inter-Planetary File System (IPFS; see <<data_storage_sec>>). On request, Oraclize retrieves this archive using its hash and then initializes and executes the Docker container on AWS, passing any arguments that are provided to the application as environment variables. The containerized application performs the calculation, subject to a time constraint, and writes the result to standard output, where it can be retrieved by Oraclize and returned to the decentralized application. Oraclize currently offers this service on an auditable t2.micro AWS instance, so if the computation is of some nontrivial value, it is possible to check that the correct Docker container was executed. Nonetheless, this is not a truly decentralized solution.\n\n(((\"cryplet\")))The concept of a 'cryptlet' as a standard for verifiable oracle truths has been formalized as part of Microsoft's wider ESC Framework.  Cryptlets execute within an encrypted capsule that abstracts away the infrastructure, such as I/O, and has the CryptoDelegate attached so incoming and outgoing messages are signed, validated, and proven automatically.  Cryptlets support distributed transactions so that contract logic can take on complex multistep, multiblockchain, and external system transactions in an ACID manner.  This allows developers to create portable, isolated, and private resolutions of the truth for use in smart contracts. Cryptlets follow the format shown here:\n\n[source,solidity]\n----\npublic class SampleContractCryptlet : Cryptlet\n  {\n        public SampleContractCryptlet(Guid id, Guid bindingId, string name,\n            string address, IContainerServices hostContainer, bool contract)\n            : base(id, bindingId, name, address, hostContainer, contract)\n        {\n            MessageApi = new CryptletMessageApi(GetType().FullName,\n                new SampleContractConstructor())\n----\n\n(((\"TrueBit\")))For a more decentralized solution, we can turn to https://truebit.io/[TrueBit], which offers a solution for scalable and verifiable off-chain computation. They use a system of solvers and verifiers who are incentivized to perform computations and verification of those computations, respectively. Should a solution be challenged, an iterative verification process on subsets of the computation is performed on-chain\u2014a kind of 'verification game'. The game proceeds through a series of rounds, each recursively checking a smaller and smaller subset of the computation. The game eventually reaches a final round, where the challenge is sufficiently trivial such that the judges\u2014Ethereum miners\u2014can make a final ruling on whether the challenge was met, on-chain. In effect, TrueBit is an implementation of a computation market, allowing decentralized applications to pay for verifiable computation to be performed outside of the network, but relying on Ethereum to enforce the rules of the verification game. In theory, this enables trustless smart contracts to securely perform any computation task.\n\nA broad range of applications exist for systems like TrueBit, ranging from machine learning to verification of proof of work. An example of the latter is the Doge\u2013Ethereum bridge, which uses TrueBit to verify Dogecoin\u2019s proof of work (Scrypt), which is a memory-hard and computationally intensive function that cannot be computed within the Ethereum block gas limit. By performing this verification on TrueBit, it has been possible to securely verify Dogecoin transactions within a smart contract on Ethereum's Rinkeby testnet.(((range=\"endofrange\", startref=\"ix_11oracles-asciidoc2\")))\n\n[[decentralized_orackes_sec]]", "metadata": {"source": "ethereumbook", "chapter": "11oracles.asciidoc", "section": "Computation Oracles"}}
{"input": "Explain the Ethereum concept: Decentralized Oracles", "output": "(((\"oracles\",\"decentralized\")))While centralized data or computation oracles suffice for many applications, they represent single points of failure in the Ethereum network. A number of schemes have been proposed around the idea of decentralized oracles as a means of ensuring data availability and the creation of a network of individual data providers with an on-chain data aggregation system.\n\n(((\"ChainLink\")))https://www.smartcontract.com/link[ChainLink] has proposed a decentralized oracle network consisting of three key smart contracts&#x2014;a reputation contract, an order-matching contract, and an aggregation contract&#x2014;and an off-chain registry of data providers. The reputation contract is used to keep track of data providers' performance. Scores in the reputation contract are used to populate the off-chain registry. The order-matching contract selects bids from oracles using the reputation contract. It then finalizes a service-level agreement, which includes query parameters and the number of oracles required. This means that the purchaser needn\u2019t transact with the individual oracles directly. The aggregation contract collects responses (submitted using a commit\u2013reveal scheme) from multiple oracles, calculates the final collective result of the query, and finally feeds the results back into the reputation contract.\n\nOne of the main challenges with such a decentralized approach is the formulation of the aggregation function. ChainLink proposes calculating a weighted response, allowing a validity score to be reported for each oracle response. Detecting an 'invalid' score here is nontrivial, since it relies on the premise that outlying data points, measured by deviations from responses provided by peers, are incorrect. Calculating a validity score based on the location of an oracle response among a distribution of responses risks penalizing correct answers over average ones. Therefore, ChainLink offers a standard set of aggregation contracts, but also allows customized aggregation contracts to be specified.\n\n(((\"SchellingCoin protocol\")))A related idea is the SchellingCoin protocol. Here, multiple participants report values and the median is taken as the &#x201c;correct&#x201d; answer. Reporters are required to provide a deposit that is redistributed in favor of values that are closer to the median, therefore incentivizing the reporting of values that are similar to others. A common value, also known as the Schelling point, which respondents might consider as the natural and obvious target around which to coordinate is expected to be close to the actual value.\n\nJason Teutsch of TrueBit recently proposed a new design for a decentralized off-chain data availability oracle. This design leverages a dedicated proof-of-work blockchain that is able to correctly report on whether or not registered data is available during a given epoch. Miners attempt to download, store, and propagate all currently registered data, thereby guaranteeing data is available locally. While such a system is expensive in the sense that every mining node stores and propagates all registered data, the system allows storage to be reused by releasing data after the registration period ends.\n\n[[oracle_client_interfaces_in_solidity_sec]]", "metadata": {"source": "ethereumbook", "chapter": "11oracles.asciidoc", "section": "Decentralized Oracles"}}
{"input": "Explain the Ethereum concept: Oracle Client Interfaces in Solidity", "output": "(((\"oracles\",\"client interfaces in Solidity\", id=\"ix_11oracles-asciidoc3\", range=\"startofrange\")))(((\"Oraclize\", id=\"ix_11oracles-asciidoc4\", range=\"startofrange\")))(((\"Solidity\",\"oracle client interfaces in\", id=\"ix_11oracles-asciidoc5\", range=\"startofrange\")))<<using_oraclize_to_update_the_eth_usd>> is a Solidity example demonstrating how Oraclize can be used to continuously poll for the ETH/USD price from an API and store the result in a usable manner.\n\n[[using_oraclize_to_update_the_eth_usd]]\n.Using Oraclize to update the ETH/USD exchange rate from an external source", "metadata": {"source": "ethereumbook", "chapter": "11oracles.asciidoc", "section": "Oracle Client Interfaces in Solidity"}}
{"input": "Explain the Ethereum concept: Conclusions", "output": "As you can see, oracles provide a crucial service to smart contracts: they bring external facts to contract execution. With that, of course, oracles also introduce a significant risk&#x2014;if they are trusted sources and can be compromised, they can result in compromised execution of the smart contracts they feed.\n\nGenerally, when considering the use of an oracle be very careful about the _trust model_. If you assume the oracle can be trusted, you may be undermining the security of your smart contract by exposing it to potentially false inputs. That said, oracles can be very useful if the security assumptions are carefully considered.\n\nDecentralized oracles can resolve some of these concerns and offer Ethereum smart contracts trustless external data. Choose carefully and you can start exploring the bridge between Ethereum and the \"real world\" that oracles offer.(((range=\"endofrange\", startref=\"ix_11oracles-asciidoc0\")))", "metadata": {"source": "ethereumbook", "chapter": "11oracles.asciidoc", "section": "Conclusions"}}
{"input": "Explain the Ethereum concept: Decentralized Applications (DApps)", "output": "(((\"DApps (decentralized applications)\", id=\"ix_12dapps-asciidoc0\", range=\"startofrange\")))In this chapter we will explore the world of _decentralized applications_, or _DApps_. From the early days of Ethereum, the founders' vision was much broader than \"smart contracts\": (((\"web3\")))no less than reinventing the web and creating a new world of DApps, aptly called _web3_. Smart contracts are a way to decentralize the controlling logic and payment functions of applications. Web3 DApps are about decentralizing all other aspects of an application: storage, messaging, naming, etc. (see <<image_web3_suite>>).\n\n[[image_web3_suite]]\n.Web3: A decentralized web using smart contracts and P2P technologies\nimage::images/web3suite.png[\"Web3: A decentralized web using smart contracts and P2P Technologies\"]\n\n[WARNING]", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Decentralized Applications (DApps)"}}
{"input": "Explain the Ethereum concept: What Is a DApp?", "output": "(((\"DApps (decentralized applications)\",\"elements of\", id=\"ix_12dapps-asciidoc1\", range=\"startofrange\")))A DApp is an application that is mostly or entirely decentralized.\n\nConsider all the possible aspects of an application that may be decentralized:\n\n* Backend software (application logic)\n* Frontend software\n* Data storage\n* Message communications\n* Name resolution\n\nEach of these can be somewhat centralized or somewhat decentralized. For example, a frontend can be developed as a web app that runs on a centralized server, or as a mobile app that runs on your device. The backend and storage can be on private servers and proprietary databases, or you can use a smart contract and P2P storage.\n\nThere are many advantages to creating a DApp that a typical centralized architecture cannot provide:\n\nResiliency::\nBecause the business logic is controlled by a smart contract, a DApp backend will be fully distributed and managed on a blockchain platform. Unlike an application deployed on a centralized server, a DApp will have no downtime and will continue to be available as long as the platform is still operating.\n\nTransparency::\nThe on-chain nature of a DApp allows everyone to inspect the code and be more sure about its function. Any interaction with the DApp will be stored forever in the blockchain.\n\nCensorship resistance::\nAs long as a user has access to an Ethereum node (running one if necessary), the user will always be able to interact with a DApp without interference from any centralized control. No service provider, or even the owner of the smart contract, can alter the code once it is deployed on the network.\n\nIn the Ethereum ecosystem as it stands today, there are very few truly decentralized apps&#x2014;most still rely on centralized services and servers for some part of their operation. In the future, we expect that it will be possible for every part of any DApp to be operated in a fully decentralized way.\n\n[[blockchain_smart_contracts_sec]]", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "What Is a DApp?"}}
{"input": "Explain the Ethereum concept: Backend (Smart Contract)", "output": "(((\"DApps (decentralized applications)\",\"backend (smart contract)\")))(((\"smart contracts\",\"as DApp backend\")))In a DApp, smart contracts are used to store the business logic (program code) and the related state of your application. You can think of a smart contract replacing a server-side (aka \"backend\") component in a regular application. This is an oversimplification, of course. One of the main differences is that any computation executed in a smart contract is very expensive and so should be kept as minimal as possible. It is therefore important to identify which aspects of the application need a trusted and decentralized execution platform.\n\nEthereum smart contracts allow you to build architectures in which a network of smart contracts call and pass data between each other, reading and writing their own state variables as they go, with their complexity restricted only by the block gas limit. After you deploy your smart contract, your business logic could well be used by many other developers in the future.\n\nOne major consideration of smart contract architecture design is the inability to change the code of a smart contract once it is deployed. It can be deleted if it is programmed with an accessible +SELFDESTRUCT+ opcode, but other than complete removal, the code cannot be changed in any way.\n\nThe second major consideration of smart contract architecture design is DApp size. A really large monolithic smart contract may cost a lot of gas to deploy and use. Therefore, some applications may choose to have off-chain computation and an external data source. Keep in mind, however, that having the core business logic of the DApp be dependent on external data (e.g., from a centralized server) means your users will have to trust these external resources.\n\n[[front_end_web_ui_cec]]", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Backend (Smart Contract)"}}
{"input": "Explain the Ethereum concept: Frontend (Web User Interface)", "output": "(((\"DApps (decentralized applications)\",\"frontend (web user interface)\")))(((\"user interface, as DApp frontend\")))(((\"web user interface, as DApp frontend\")))Unlike the business logic of the DApp, which requires a developer to understand the EVM and new languages such as Solidity, the client-side interface of a DApp can use standard web technologies (HTML, CSS, JavaScript, etc.). This allows a traditional web developer to use familiar tools, libraries, and frameworks. Interactions with Ethereum, such as signing messages, sending transactions, and managing keys, are often conducted through the web browser, via an extension such as MetaMask (see <<intro_chapter>>).\n\nAlthough it is possible to create a mobile DApp as well, currently there are few resources to help create mobile DApp frontends, mainly due to the lack of mobile clients that can serve as a light client with key-management functionality.\n\nThe frontend is usually linked to Ethereum via the _web3.js_ JavaScript library, which is bundled with the frontend resources and served to a browser by a web server.\n\n[[data_storage_sec]]", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Frontend (Web User Interface)"}}
{"input": "Explain the Ethereum concept: Data Storage", "output": "(((\"DApps (decentralized applications)\",\"data storage\")))(((\"data storage\",\"DApps and\")))Due to high gas costs and the currently low block gas limit, smart contracts are not well suited to storing or processing large amounts of data. Hence, most DApps utilize off-chain data storage services, meaning they store the bulky data off the Ethereum chain, on a data storage platform. That data storage platform can be centralized (for example, a typical cloud database), or the data can be decentralized, stored on a P2P platform such as the IPFS, or Ethereum's own Swarm platform.\n\nDecentralized P2P storage is ideal for storing and distributing large static assets such as images, videos, and the resources of the application's frontend web interface (HTML, CSS, JavaScript, etc.). We'll look at a few of the options next.\n\n[[ipfs_sec]]", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Data Storage"}}
{"input": "Explain the Ethereum concept: IPFS", "output": "(((\"DApps (decentralized applications)\",\"IPFS and\")))(((\"data storage\",\"IPFS\")))(((\"IPFS (InterPlanetary File System)\")))The _Inter-Planetary File System_ (IPFS) is a decentralized content-addressable storage system that distributes stored objects among peers in a P2P network. \"Content addressable\" means that each piece of content (file) is hashed and the hash is used to identify that file. You can then retrieve any file from any IPFS node by requesting it by its hash.\n\nIPFS aims to replace HTTP as the protocol of choice for delivery of web applications. Instead of storing a web application on a single server, the files are stored on IPFS and can be retrieved from any IPFS node.\n\nMore information about IPFS can be found at https://ipfs.io[].\n\n\n[[swarm_sec]]", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "IPFS"}}
{"input": "Explain the Ethereum concept: Swarm", "output": "(((\"DApps (decentralized applications)\",\"Swarm and\")))(((\"data storage\",\"Swarm\")))(((\"Swarm\")))Swarm is another content-addressable P2P storage system, similar to IPFS. Swarm was created by the Ethereum Foundation, as part of the Go-Ethereum suite of tools. Like IPFS, it allows you to store files that get disseminated and replicated by Swarm nodes. You can access any Swarm file by referring to it by a hash. Swarm allows you to access a website from a decentralized P2P system, instead of a central web server.\n\nThe home page for Swarm is itself stored on Swarm and accessible on your Swarm node or a gateway:\nhttps://swarm-gateways.net/bzz:/theswarm.eth/[].\n\n\n[[interdapp_coammunications_protocol_sec]]", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Swarm"}}
{"input": "Explain the Ethereum concept: Decentralized Message Communications Protocols", "output": "(((\"DApps (decentralized applications)\",\"decentralized message communication protocols\")))(((\"message communication protocols\")))Another major component of any application is inter-process communication. That means being able to exchange messages between applications, between different instances of the application, or between users of the application. Traditionally, this is achieved by reliance on a centralized server. However, there are a variety of decentralized alternatives to server-based protocols, offering messaging over a P2P network. (((\"Whisper\")))The most notable P2P messaging protocol for DApps is http://bit.ly/2CSls5h[_Whisper_], which is part of the Ethereum Foundation's Go-Ethereum suite of tools.\n\nThe final aspect of an application that can be decentralized is name resolution. We'll take a close look at Ethereum's name service later in this chapter; now, though, let's dig into an example.(((range=\"endofrange\", startref=\"ix_12dapps-asciidoc1\")))\n\n[[auction_dapp_intro]]", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Decentralized Message Communications Protocols"}}
{"input": "Explain the Ethereum concept: A Basic DApp Example: Auction DApp", "output": "(((\"Auction DApp\", id=\"ix_12dapps-asciidoc2\", range=\"startofrange\")))(((\"DApps (decentralized applications)\",\"Auction DApp example\", seealso=\"Auction DApp\", id=\"ix_12dapps-asciidoc3\", range=\"startofrange\")))In this section we will start building an example DApp, to explore the various decentralization tools. Our DApp will implement a decentralized auction.\n\n(((\"deed\",\"Auction DApp and\")))(((\"nonfungible tokens (NFTs)\",\"Auction DApp and\")))The Auction DApp allows a user to register a \"deed\" token, which represents some unique asset, such as a house, a car, a trademark, etc. Once a token has been registered, the ownership of the token is transferred to the Auction DApp, allowing it to be listed for sale. The Auction DApp lists each of the registered tokens, allowing other users to place bids. During each auction, users can join a chat room created specifically for that auction. Once an auction is finalized, the deed token ownership is transferred to the winner of the auction.\n\nThe overall auction process can be seen in <<auction_dapp_overview>>.\n\nThe main components of our Auction DApp are:\n\n* A smart contract implementing ERC721 non-fungible \"deed\" tokens (pass:[<code><span class=\"keep-together\">DeedRepository</span></code>])\n* A smart contract implementing an auction (+AuctionRepository+) to sell the deeds\n* A web frontend using the Vue/Vuetify JavaScript framework\n* The _web3.js_ library to connect to Ethereum chains (via MetaMask or other clients)\n* A Swarm client, to store resources such as images\n* A Whisper client, to create per-auction chat rooms for all participants\n\n[[auction_dapp_overview]]\n.Auction DApp: A simple example auction DApp\nimage::images/auction_diagram.png[\"Auction DApp: A simple example auction DApp\"]\n\nYou can find the source code for the auction DApp http://bit.ly/2DcmjyA[in the book's repository].", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "A Basic DApp Example: Auction DApp"}}
{"input": "Explain the Ethereum concept: Auction DApp: Backend Smart Contracts", "output": "(((\"Auction DApp\",\"backend smart contracts\", id=\"ix_12dapps-asciidoc4\", range=\"startofrange\")))(((\"smart contracts\",\"as DApp backend\", id=\"ix_12dapps-asciidoc5\", range=\"startofrange\")))Our Auction DApp example is supported by two smart contracts that we need to deploy on an Ethereum blockchain in order to support the application: pass:[<code><span class=\"keep-together\">AuctionRepository</span></code>] and +DeedRepository+.\n\nLet's start by looking at +DeedRepository+, shown in <<deed_repository_code>>. This contract is an ERC721-compatible non-fungible token (see <<erc721>>).\n\n[[deed_repository_code]]\n.DeedRepository.sol: An ERC721 deed token for use in an auction", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Auction DApp: Backend Smart Contracts"}}
{"input": "Explain the Ethereum concept: DApp governance", "output": "If you read through the two smart contracts of the Auction DApp you will notice something important: there is no special account or role that has special privileges over the DApp. Each auction has an owner with some special capabilities, but the Auction DApp itself has no privileged user.\n\nThis is a deliberate choice to decentralize the governance of the DApp and relinquish any control once it has been deployed. Some DApps, by comparison, have one or more privileged accounts with special capabilities, such as the ability to terminate the DApp contract, to override or change its configuration, or to \"veto\" certain operations. Usually, these governance functions are introduced in the DApp in order to avoid unknown problems that might arise due to a bug.\n\nThe issue of governance is a particularly difficult one to solve, as it represents a double-edged sword. On the one side, privileged accounts are dangerous; if compromised, they can subvert the security of the DApp. On the other side, without any privileged account, there are no recovery options if a bug is found. We have seen both of these risks manifest in Ethereum DApps. (((\"DAO (Decentralized Autonomous Organization)\",\"reentrancy attack\")))In the case of The DAO (<<real_world_example_the_dao>> and <<ethereum_fork_history>>), there were some privileged accounts called the \"curators,\" but they were very limited in their capabilities. Those accounts were not able to override the DAO attacker's withdrawal of the funds. In a more recent case, the decentralized exchange Bancor experienced a massive theft because a privileged management account was compromised. Turns out, Bancor was not as decentralized as initially assumed.\n\nWhen building a DApp, you have to decide if you want to make the smart contracts truly independent, launching them and then having no control, or create privileged accounts and run the risk of those being compromised. Either choice carries risk, but in the long run, true DApps cannot have specialized access for privileged accounts&#x2014;that's not decentralized.(((range=\"endofrange\", startref=\"ix_12dapps-asciidoc5\")))(((range=\"endofrange\", startref=\"ix_12dapps-asciidoc4\")))", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "DApp governance"}}
{"input": "Explain the Ethereum concept: Auction DApp: Frontend User Interface", "output": "(((\"Auction DApp\",\"frontend user interface\")))Once the Auction DApp's contracts are deployed, you can interact with them using your favorite JavaScript console and web3.js, or another web3 library. However, most users will need an easy-to-use interface. Our Auction DApp user interface is built using the Vue2/Vuetify JavaScript framework from Google.\n\nYou can find the user interface code in the _code/auction_dapp/frontend_ folder in https://github.com/ethereumbook/ethereumbook[the book's repository]. The directory has the following structure and contents:\n\n----\nfrontend/\n|-- build\n|   |-- build.js\n|   |-- check-versions.js\n|   |-- logo.png\n|   |-- utils.js\n|   |-- vue-loader.conf.js\n|   |-- webpack.base.conf.js\n|   |-- webpack.dev.conf.js\n|   `-- webpack.prod.conf.js\n|-- config\n|   |-- dev.env.js\n|   |-- index.js\n|   `-- prod.env.js\n|-- index.html\n|-- package.json\n|-- package-lock.json\n|-- README.md\n|-- src\n|   |-- App.vue\n|   |-- components\n|   |   |-- Auction.vue\n|   |   `-- Home.vue\n|   |-- config.js\n|   |-- contracts\n|   |   |-- AuctionRepository.json\n|   |   `-- DeedRepository.json\n|   |-- main.js\n|   |-- models\n|   |   |-- AuctionRepository.js\n|   |   |-- ChatRoom.js\n|   |   `-- DeedRepository.js\n|   `-- router\n|       `-- index.js\n----\n\nOnce you have deployed the contracts, edit the frontend configuration in _frontend/src/config.js_ and enter the addresses of the +DeedRepository+ and +AuctionRepository+ contracts, as deployed. The frontend application also needs access to an Ethereum node offering a JSON-RPC and WebSockets interface. Once you've configured the frontend, launch it with a web server on your local machine:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>npm install</strong>\n$ <strong>npm run dev</strong>\n</pre>\n++++\n\nThe Auction DApp frontend will launch and will be accessible via any web browser at http://localhost:8080.\n\nIf all goes well you should see the screen shown in <<auction_dapp_screen>>, which illustrates the Auction DApp running in a web browser.\n\n[[auction_dapp_screen]]\n.Auction DApp user interface\nimage::images/auction_dapp_home_screen.png[\"Auction DApp User interface\"]", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Auction DApp: Frontend User Interface"}}
{"input": "Explain the Ethereum concept: Further Decentralizing the Auction DApp", "output": "(((\"Auction DApp\",\"further decentralizing of\")))Our DApp is already quite decentralized, but we can improve things.\n\nThe +AuctionRepository+ contract operates independently of any oversight, open to anyone. Once deployed it cannot be stopped, nor can any auction be controlled. Each auction has a separate chat room that allows anyone to communicate about the auction without censorship or identification. The various auction assets, such as the description and associated image, are stored on Swarm, making them hard to censor or block.\n\nAnyone can interact with the DApp by constructing transactions manually or by running the Vue frontend on their local machine. The DApp code itself is open source and developed collaboratively on a public repository.\n\nThere are two things we can do to make this DApp decentralized and resilient:\n\n* Store all the application code on Swarm or IPFS.\n* Access the DApp by reference to a name, using the Ethereum Name Service.\n\nWe'll explore the first option in the next section, and we'll dig into the second in <<ethereum_naming_system_ens>>.", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Further Decentralizing the Auction DApp"}}
{"input": "Explain the Ethereum concept: Storing the Auction DApp on Swarm", "output": "(((\"Auction DApp\",\"storing on Swarm\", id=\"ix_12dapps-asciidoc6\", range=\"startofrange\")))(((\"Swarm\",\"storing Auction DApp on\", id=\"ix_12dapps-asciidoc7\", range=\"startofrange\")))We introduced Swarm in <<swarm_sec>>, earlier in this chapter. Our Auction DApp already uses Swarm to store the icon image for each auction. This is a much more efficient solution than attempting to store data on Ethereum, which is expensive. It is also a lot more resilient than if these images were stored in a centralized service like a web server or file server.\n\nBut we can take things one step further. We can store the entire frontend of the DApp itself in Swarm and run it from a Swarm node directly, instead of running a web server.", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Storing the Auction DApp on Swarm"}}
{"input": "Explain the Ethereum concept: Preparing Swarm", "output": "(((\"Swarm\",\"installing and initializing\")))To get started, you need to install Swarm and initialize your Swarm node. Swarm is part of the Ethereum Foundation's Go-Ethereum suite of tools. Refer to the instructions for installing Go-Ethereum in <<go_ethereum_geth>>, or to install a Swarm binary release, follow the instructions in the http://bit.ly/2Q75KXw[Swarm documentation].\n\nOnce you have installed Swarm, you can check that it is working correctly by running it with the +version+ command:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>swarm version</strong>\nVersion: 0.3\nGit Commit: 37685930d953bcbe023f9bc65b135a8d8b8f1488\nGo Version: go1.10.1\nOS: linux\n</pre>\n++++\n\nTo start running Swarm, you must tell it how to connect to an instance of Geth, to access the JSON-RPC API. Get it started by following the instructions in the https://swarm-guide.readthedocs.io/en/latest/gettingstarted.html[Getting Started guide].\n\nWhen you start Swarm, you should see something like this:\n\n----\nMaximum peer count                       ETH=25 LES=0 total=25\nStarting peer-to-peer node               instance=swarm/v0.3.1-225171a4/linux...\nconnecting to ENS API                    url=http://127.0.0.1:8545\nswarm[5955]: [189B blob data]\nStarting P2P networking\nUDP listener up                          self=enode://f50c8e19ff841bcd5ce7d2d...\nUpdated bzz local addr                   oaddr=9c40be8b83e648d50f40ad3... uaddr=e\nStarting Swarm service\n9c40be8b hive starting\ndetected an existing store. trying to load peers\nhive 9c40be8b: peers loaded\nSwarm network started on bzz address: 9c40be8b83e648d50f40ad3d35f...\nPss started\nStreamer started\nIPC endpoint opened                      url=/home/ubuntu/.ethereum/bzzd.ipc\nRLPx listener up                         self=enode://f50c8e19ff841bcd5ce7d2d...\n----\n\nYou can confirm that your Swarm node is running correctly by connecting to the local Swarm gateway web interface:\nhttp://localhost:8500.\n\nYou should see a screen like the one in <<image_swarm_gateway>> and be able to query any Swarm hash or ENS name.\n\n[[image_swarm_gateway]]\n.Swarm gateway on localhost\nimage::images/swarm-gateway.png[\"Swarm gateway on localhost\"]", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Preparing Swarm"}}
{"input": "Explain the Ethereum concept: Uploading Files to Swarm", "output": "(((\"Swarm\",\"uploading files to\", id=\"ix_12dapps-asciidoc8\", range=\"startofrange\")))Once you have your local Swarm node and gateway running, you can upload to Swarm and the files will be accessible on any Swarm node, simply by reference to the file hash.\n\nLet's test this by uploading a file:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>swarm up code/auction_dapp/README.md</strong>\nec13042c83ffc2fb5cb0aa8c53f770d36c9b3b35d0468a0c0a77c97016bb8d7c\n</pre>\n++++\n\nSwarm has uploaded the _README.md_ file and returned a hash that you can use to access the file from any Swarm node. For example, you could use the https://bit.ly/2znWUP9[public Swarm gateway].\n\nWhile uploading one file is relatively straightforward, it is a bit more complex to upload an entire DApp frontend. That's because the various DApp resources (HTML, CSS, JavaScript, libraries, etc.) have embedded references to each other. Normally, a web server translates URLs to local files and serves the correct resources. We can achieve the same for Swarm by packaging our DApp.\n\nIn the Auction DApp, there's a script for packaging all the resources:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>cd code/auction_dapp/frontend</strong>\n$ <strong>npm run build</strong>\n\n> <strong>frontend@1.0.0 build /home/aantonop/Dev/ethereumbook/code/auction_dapp/frontend</strong>\n> <strong>node build/build.js</strong>\n\nHash: 9ee134d8db3c44dd574d\nVersion: webpack 3.10.0\nTime: 25665ms\nAsset     Size\nstatic/js/vendor.77913f316aaf102cec11.js  1.25 MB\nstatic/js/app.5396ead17892922422d4.js   502 kB\nstatic/js/manifest.87447dd4f5e60a5f9652.js  1.54 kB\nstatic/css/app.0e50d6a1d2b1ed4daa03d306ced779cc.css  1.13 kB\nstatic/css/app.0e50d6a1d2b1ed4daa03d306ced779cc.css.map  2.54 kB\nstatic/js/vendor.77913f316aaf102cec11.js.map  4.74 MB\nstatic/js/app.5396ead17892922422d4.js.map   893 kB\nstatic/js/manifest.87447dd4f5e60a5f9652.js.map  7.86 kB\nindex.html  1.15 kB\n\nBuild complete.\n</pre>\n++++\n\nThe result of this command will be a new directory, _code/auction_dapp/frontend/dist_, that contains the entire Auction DApp frontend, packed together:\n\n----\ndist/\n|-- index.html\n`-- static\n    |-- css\n    |   |-- app.0e50d6a1d2b1ed4daa03d306ced779cc.css\n    |   `-- app.0e50d6a1d2b1ed4daa03d306ced779cc.css.map\n    `-- js\n        |-- app.5396ead17892922422d4.js\n        |-- app.5396ead17892922422d4.js.map\n        |-- manifest.87447dd4f5e60a5f9652.js\n        |-- manifest.87447dd4f5e60a5f9652.js.map\n        |-- vendor.77913f316aaf102cec11.js\n        `-- vendor.77913f316aaf102cec11.js.map\n\n----\n\nNow you can upload the entire DApp to Swarm, by using the +up+ command and the +--recursive+ option. Here, we also tell Swarm that +index.html+ is the +defaultpath+ for loading this DApp:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>swarm --bzzapi http://localhost:8500 --recursive \\\n  --defaultpath dist/index.html up dist/</strong>\n\nab164cf37dc10647e43a233486cdeffa8334b026e32a480dd9cbd020c12d4581\n</pre>\n++++\n\nNow, our entire Auction DApp is hosted on Swarm and accessible by the Swarm URL:(((range=\"endofrange\", startref=\"ix_12dapps-asciidoc8\")))\n\n++++\n<ul class=\"simplelist\">\n<li><em>bzz://ab164cf37dc10647e43a233486cdeffa8334b026e32a480dd9cbd020c12d4581</em></li>\n</ul>\n++++\n\nWe've made some progress in decentralizing our DApp, but we've made it harder to use. A URL like that is much less user-friendly than a nice name like __auction_dapp.com__. Are we forced to sacrifice usability in order to gain decentralization? Not necessarily. In the next section we will examine Ethereum's name service, which allows us to use easy-to-read names but still preserves the decentralized nature of our application.(((range=\"endofrange\", startref=\"ix_12dapps-asciidoc7\")))(((range=\"endofrange\", startref=\"ix_12dapps-asciidoc6\")))\n\n[[ethereum_naming_system_ens]]", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Uploading Files to Swarm"}}
{"input": "Explain the Ethereum concept: The Ethereum Name Service (ENS)", "output": "(((\"Auction DApp\",\"ENS and\", id=\"ix_12dapps-asciidoc9\", range=\"startofrange\")))(((\"ENS (Ethereum Name Service)\", id=\"ix_12dapps-asciidoc10\", range=\"startofrange\")))(((\"ENS (Ethereum Name Service)\",\"DApps and\", id=\"ix_12dapps-asciidoc11\", range=\"startofrange\")))You can design the best smart contract in the world, but if you don't provide a good interface for users, they won't be able to access it.\n\nOn the traditional internet, the Domain Name System (DNS) allows us to use human-readable names in the browser while resolving those names to IP addresses or other identifiers behind the scenes. On the Ethereum blockchain, the _Ethereum Naming System_ (ENS) solves the same problem, but in a decentralized manner.\n\nFor example, the Ethereum Foundation donation address is +0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359+; in a wallet that supports ENS, it's simply +ethereum.eth+.\n\nENS is more than a smart contract; it's a fundamental DApp itself, offering a decentralized name service. Furthermore, ENS is supported by a number of DApps for registration, management, and auctions of registered names. ENS demonstrates how DApps can work together: it's DApp built to serve other DApps, supported by an ecosystem of DApps, embedded in other DApps, and so on.\n\nIn this section we will look at how ENS works. We'll demonstrate how you can set up your own name and link it to a wallet or Ethereum address, how you can embed ENS in another DApp, and how you can use ENS to name your DApp resources to make them easier to use.", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "The Ethereum Name Service (ENS)"}}
{"input": "Explain the Ethereum concept: History of Ethereum Name Services", "output": "(((\"ENS (Ethereum Name Service)\",\"history of\")))Name registration was the first noncurrency application of blockchains, pioneered by Namecoin. The Ethereum http://bit.ly/2Of1gfZ[White Paper] gave a two-line Namecoin-like registration system as one of its example applications.\n\nEarly releases of Geth and the C++ Ethereum client had a built-in +namereg+ contract (not used any more), and many proposals and ERCs for name services were made, but it was only when Nick Johnson started working for the Ethereum Foundation in 2016 and took the project under his wing that serious work on a registrar started.\n\nENS was launched on Star Wars Day, May 4, 2017 (after a failed attempt to launch it on Pi Day, March 15).", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "History of Ethereum Name Services"}}
{"input": "Explain the Ethereum concept: The ENS Specification", "output": "(((\"ENS (Ethereum Name Service)\",\"design of\", id=\"ix_12dapps-asciidoc12\", range=\"startofrange\")))ENS is (((\"ENS (Ethereum Name Service)\",\"specification\")))specified mainly in three Ethereum Improvement Proposals: EIP-137, which specifies the basic functions of ENS; EIP-162, which describes the auction system for the +.eth+ root; and EIP-181, which specifies reverse resolution of addresses.\n\nENS follows a \"sandwich\" design philosophy: a very simple layer on the bottom, followed by layers of more complex but replaceable code, with a very simple top layer that keeps all the funds in separate accounts.", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "The ENS Specification"}}
{"input": "Explain the Ethereum concept: Bottom Layer: Name Owners and Resolvers", "output": "(((\"ENS (Ethereum Name Service)\",\"bottom layer: name owners and resolvers\", id=\"ix_12dapps-asciidoc13\", range=\"startofrange\")))The ENS operates on \"nodes\" instead of human-readable names: a human-readable name is converted to a node using the \"Namehash\" algorithm.\n\nThe base layer of ENS is a cleverly simple contract (less than 50 lines of code) defined by ERC137 that allows only nodes' owners to set information about their names and to create subnodes (the ENS equivalent of DNS subdomains).\n\nThe only functions on the base layer are those that enable a node owner to set information about their own node (specifically the resolver, time to live, or transferring the ownership) and to create owners of new subnodes.", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Bottom Layer: Name Owners and Resolvers"}}
{"input": "Explain the Ethereum concept: The Namehash algorithm", "output": "(((\"ENS (Ethereum Name Service)\",\"Namehash algorithm\")))(((\"Namehash algorithm\")))Namehash is a recursive algorithm that can convert any name into a hash that identifies the name.\n\n\"Recursive\" means that we solve the problem by solving a subproblem that is a smaller problem of the same type, and then use the solution to the subproblem to solve the original problem.\n\nNamehash recursively hashes components of the name, producing a unique, fixed-length string (or &#x201c;node&#x201d;) for any valid input domain. For example, the Namehash node of +subdomain.example.eth+ is `keccak('<example.eth>' node) + keccak('<subdomain>')`. The subproblem we must solve is to compute the node for +example.eth+, which is `keccak('<.eth>' node) + keccak('<example>')`.  To begin, we must compute the node for +eth+, which is `keccak(<root node>) + keccak('<eth>')`.\n\nThe root node is what we call the \"base case\" of our recursion, and we obviously can't define it recursively, or the algorithm will never terminate! The root node is defined as `0x0000000000000000000000000000000000000000000000000000000000000000` (32 zero bytes).\n\nPutting this all together, the node of +subdomain.example.eth+ is therefore pass:[<code><span class=\"keep-together\">keccak</span>(keccak(keccak(0x0...0 + keccak('eth')) + keccak('example')) + keccak('subdomain'))</code>].\n\nGeneralizing, we can define the Namehash function as follows (the base case for the root node, or empty name, followed by the recursive step):\n\n....\nnamehash([]) = 0x0000000000000000000000000000000000000000000000000000000000000000\nnamehash([label, ...]) = keccak256(namehash(...) + keccak256(label))\n....\n\nIn Python this becomes:\n\n....\ndef namehash(name):\n  if name == '':\n    return '\\0' * 32\n  else:\n    label, _, remainder = name.partition('.')\n    return sha3(namehash(remainder) + sha3(label))\n....\n\nThus, +mastering-ethereum.eth+ will be processed as follows:\n\n....\nnamehash('mastering-ethereum.eth')\n\u21d2 sha3(namehash('eth') + sha3('mastering-ethereum'))\n\u21d2 sha3(sha3(namehash('') + sha3('eth')) + sha3('mastering-ethereum'))\n\u21d2 sha3(sha3(('\\0' * 32) + sha3('eth')) + sha3('mastering-ethereum'))\n....\n\nOf course, subdomains can themselves have subdomains: there could be a +sub.subdomain.example.eth+ after +subdomain.example.eth+, then a +sub.sub.subdomain.example.eth+, and so on. To avoid expensive recomputation, since Namehash depends only on the name itself, the node for a given name can be precomputed and inserted into a contract, removing the need for string manipulation and permitting immediate lookup of ENS records regardless of the number of components in the raw name.", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "The Namehash algorithm"}}
{"input": "Explain the Ethereum concept: How to choose a valid name", "output": "(((\"ENS (Ethereum Name Service)\",\"choosing a valid name\")))Names consist of a series of dot-separated labels. Although upper- and lowercase letters are allowed, all labels should follow a UTS &#x23;46 normalization process that case-folds labels before hashing them, so names with different case but identical spelling will end up with the same Namehash.\n\nYou could use labels and domains of any length, but for the sake of compatibility with legacy DNS, the following rules are recommended:\n\n* Labels should be no more than 64 characters each.\n* Complete ENS names should be no more than 255 characters.\n* Labels should not start or end with hyphens, or start with digits.", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "How to choose a valid name"}}
{"input": "Explain the Ethereum concept: Root node ownership", "output": "(((\"ENS (Ethereum Name Service)\",\"root node ownership\")))One of the results of this hierarchical system is that it relies on the owners of the root node, who are able to create top-level domains (TLDs).\n\nWhile the eventual goal is to adopt a decentralized decision-making process for new TLDs, at the time of writing the root node is controlled by a 4-of-7 multisig, held by people in different countries (built as a reflection of the 7 keyholders of the DNS system).\nAs a result, a majority of at least 4 of the 7 keyholders is required to effect any change.\n\nCurrently the purpose and goal of these keyholders is to work in consensus with the community to:\n\n* Migrate and upgrade the temporary ownership of the +.eth+ TLD to a more permanent contract once the system is evaluated.\n* Allow adding new TLDs, if the community agrees they are needed.\n* Migrate the ownership of the root multisig to a more decentralized contract, when such a system is agreed upon, tested, and implemented.\n* Serve as a last-resort way to deal with any bugs or vulnerabilities in the top-level registries.", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Root node ownership"}}
{"input": "Explain the Ethereum concept: Resolvers", "output": "(((\"ENS (Ethereum Name Service)\",\"resolvers\")))(((\"resolver contracts\")))The basic ENS contract can't add metadata to names; that is the job of so-called \"resolver contracts.\" These are user-created contracts that can answer questions about the name, such as what Swarm address is associated with the app, what address receives payments to the app (in ether or tokens), or what the hash of the app is (to verify its integrity).(((range=\"endofrange\", startref=\"ix_12dapps-asciidoc13\")))", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Resolvers"}}
{"input": "Explain the Ethereum concept: Middle Layer: The .eth Nodes", "output": "(((\".eth nodes\")))(((\"ENS (Ethereum Name Service)\",\"middle layer: .eth nodes\")))(((\"eth nodes\")))At the time of writing, the only top-level domain that is uniquely registrable in a smart contract is +.eth+.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Middle Layer: The .eth Nodes"}}
{"input": "Explain the Ethereum concept: Vickrey auctions", "output": "(((\"ENS (Ethereum Name Service)\",\"Vickrey auctions\")))(((\"Vickrey auctions\")))Names are distributed via a modified Vickrey auction. In a traditional Vickrey auction, every bidder submits a sealed bid, and all of them are revealed simultaneously, at which point the highest bidder wins the auction but only pays the second-highest bid. Therefore bidders are incentivized not to bid less than the true value of the name to them, since bidding their true value increases the chance they will win but does not affect the price they will eventually pay.\n\nOn a blockchain, some changes are required:\n\n* To ensure bidders don't submit bids they have no intention of paying, they must lock up a value equal to or higher than their bid beforehand, to guarantee the bid is valid.\n* Because you can't hide secrets on a blockchain, bidders must execute at least two transactions (a commit\u2013reveal process), in order to hide the original value and name they bid on.\n* Since you can't reveal all bids simultaneously in a decentralized system, bidders must reveal their own bids themselves; if they don't, they forfeit their locked-up funds. Without this forfeit, one could make many bids and choose to reveal only one or two, turning a sealed-bid auction into a traditional increasing price pass:[<span class=\"keep-together\">auction</span>].\n\nTherefore, the auction is a four-step process:\n\n1. Start the auction. This is required to broadcast the intent to register a name.\nThis creates all auction deadlines. The names are hashed, so that only those who have the name in their dictionary will know which auction was opened. This allows some privacy, which is useful if you are creating a new project and don't want to share details about it.\nYou can open multiple dummy auctions at the same time, so if someone is following you they cannot simply bid on all auctions you open.\n\n2. Make a sealed bid. You must do this before the bidding deadline, by tying a given amount of ether to the hash of a secret message (containing, among other things, the hash of the name, the actual amount of the bid, and a salt).\nYou can lock up more ether than you are actually bidding in order to mask your true valuation.\n\n3. Reveal the bid. During the reveal period, you must make a transaction that reveals the bid, which will then calculate the highest bid and the second-highest bid and send ether back to unsuccessful bidders.\nEvery time the bid is revealed the current winner is recalculated; therefore, the last one to be set before the revealing deadline expires becomes the overall winner.\n\n4. Clean up after. If you are the winner, you can finalize the auction in order to get back the difference between your bid and the second-highest bid.\nIf you forgot to reveal you can make a late reveal and recover a little of your bid.", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Vickrey auctions"}}
{"input": "Explain the Ethereum concept: Top Layer: The Deeds", "output": "(((\"deed\",\"as ENS top layer\")))(((\"ENS (Ethereum Name Service)\",\"top layer: deeds\")))The top layer of ENS is yet another super-simple contract with a single purpose: to hold the funds.\n\nWhen you win a name, the funds are not actually sent anywhere, but are just locked up for the period you want to hold the name (at least a year).\nThis works like a guaranteed buyback: if the owner does not want the name any more they can sell it back to the system and recover their ether (so the cost of holding the name is the opportunity cost of doing something with a return greater than zero).\n\nOf course, having a single contract hold millions of dollars in ether has proven to be very risky, so instead ENS creates a deed contract for each new name.\nThe deed contract is very simple (about 50 lines of code), and it only allows the funds to be transferred back to a single account (the deed owner) and to be called by a single entity (the registrar contract).\nThis approach drastically reduces the attack surface where bugs can put the funds at risk.(((range=\"endofrange\", startref=\"ix_12dapps-asciidoc12\")))", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Top Layer: The Deeds"}}
{"input": "Explain the Ethereum concept: Registering a Name", "output": "(((\"ENS (Ethereum Name Service)\",\"registering a name\", id=\"ix_12dapps-asciidoc14\", range=\"startofrange\")))(((\"registering a name\", id=\"ix_12dapps-asciidoc15\", range=\"startofrange\")))Registering a name in ENS is a four-step process, as we saw in  <<vickrey_auction>>. First we place a bid for any available name, then we reveal our bid after 48 hours to secure the name. <<ens_registration_timeline>> is a diagram showing the timeline of registration.\n\nLet's register our first name!\n\nWe will use one of several available user-friendly interfaces to search for available names, place a bid on the name +ethereumbook.eth+, reveal the bid, and secure the name.\n\nThere are a number of web-based interfaces to ENS that allow us to interact with the ENS DApp. For this example, we will use the https://mycrypto.com/[MyCrypto interface], in conjunction with MetaMask as our wallet.\n\n[[ens_registration_timeline]]\n.ENS timeline for registration\nimage::images/ens-flow.png[]\n\n\n\nFirst, we need to make sure the name we want is available. While writing this book, we really wanted to register the name +mastering.eth+, but alas, <<ens-name-search>> revealed it was already taken! Because ENS registrations only last one year, it might become possible to secure that name in the future. In the meantime, let's search for +ethereumbook.eth+ (<<ens-name-search>>).\n\n[[ens-name-search]]\n.Searching for ENS names on MyCrypto.com\nimage::images/ens-checkname.png[\"Searching for ENS names on MyCrypto.com\"]\n\nGreat! The name is available. In order to register it, we need to move forward with <<ens-auction>>. Let's unlock MetaMask and start an auction for +ethereumbook.eth+.\n\n\n[[ens-auction]]\n.Starting an auction for an ENS name\nimage::images/ens-auction.png[\"Starting an auction for an ENS name\"]\n\n\nLet's make our bid. In order to do that we need to follow the steps in <<ens-bid>>.\n\n\n[[ens-bid]]\n.Placing a bid for an ENS name\nimage::images/ens-bid.png[\"Placing a bid for an ENS name\"]\n\n[WARNING]", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Registering a Name"}}
{"input": "Explain the Ethereum concept: Managing Your ENS Name", "output": "(((\"ENS (Ethereum Name Service)\",\"managing your ENS name\")))Once you have registered an ENS name, you can manage it using another user-friendly interface: https://manager.ens.domains/[ENS Manager].\n\n\nOnce there, enter the name you want to manage in the search box (see <<ens-manager>>). You need to have your Ethereum wallet  (e.g., MetaMask) unlocked, so that the ENS Manager DApp can manage the name on your behalf.\n\n[[ens-manager]]\n.The ENS Manager web interface\nimage::images/ens-manager.png[\"The ENS Manager web interface\"]\n\nFrom this interface, we can create subdomains, set a resolver contract (more on that later), and connect each name to the appropriate resource, such as the Swarm address of a DApp frontend.", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Managing Your ENS Name"}}
{"input": "Explain the Ethereum concept: Creating an ENS subdomain", "output": "First, let's create a subdomain for our example Auction DApp (see <<ens-manager-add-subdomain>>). We will name the subdomain +auction+, so the fully qualified name will be +auction.ethereumbook.eth+.\n\n[[ens-manager-add-subdomain]]\n.Adding the subdomain auction.ethereumbook.eth\nimage::images/ens_manager_add_subdomain.png[\"Adding the subdomain auction.ethereumbook.eth\"]\n\nOnce we've created the subdomain, we can enter +auction.ethereumbook.eth+ in the search box and manage it, just as we managed the domain +ethereumbook.eth+ pass:[<span class=\"keep-together\">previously</span>].\n\n[role=\"pagebreak-before\"]", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Creating an ENS subdomain"}}
{"input": "Explain the Ethereum concept: ENS Resolvers", "output": "(((\"ENS (Ethereum Name Service)\",\"resolving a name\", id=\"ix_12dapps-asciidoc16\", range=\"startofrange\")))In ENS, resolving a name is a two-step process:\n\n1. The ENS registry is called with the name to resolve after hashing it.\nIf the record exists, the registry returns the address of its resolver.\n\n2. The resolver is called, using the method appropriate to the resource being requested. The resolver returns the desired result.\n\nThis two-step process has several benefits. Separating the functionality of resolvers from the naming system itself gives us a lot more flexibility. The owners of names can use custom resolvers to resolve any type or resource, extending the functionality of ENS. For example, if in the future you wanted to link a geolocation resource (longitude/lattitude) to an ENS name, you could create a new resolver that answers a pass:[<span class=\"keep-together\"><code>geolocation</code></span>] query. Who knows what applications might be useful in the future? With custom resolvers, the only limitation is your imagination.\n\nFor convenience, there is a default public resolver that can resolve a variety of resources, including the address (for wallets or contracts) and content (a Swarm hash for DApps or contract source code).\n\nSince we want to link our Auction DApp to a Swarm hash, we can use the public resolver, which supports content resolution, as shown in <<ens-manager-set-default-resolver>>; we don't need to code or deploy a custom resolver.\n\n[[ens-manager-set-default-resolver]]\n.Setting the default public resolver for auction.ethereumbook.eth\nimage::images/ens-manager-set-default-resolver.png[\"Set the default public resolver for auction.ethereumbook.eth\"]", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "ENS Resolvers"}}
{"input": "Explain the Ethereum concept: Resolving a Name to a Swarm Hash (Content)", "output": "(((\"ENS (Ethereum Name Service)\",\"resolving a name to a Swarm hash\")))(((\"Swarm\",\"resolving a name to a Swarm hash\")))(((\"Swarm hash, resolving a name to\")))Once the resolver for +auction.ethereumbook.eth+ is set to be the public resolver, we can set it to return the Swarm hash as the content of our name (see <<ens-set-content>>).\n\n[[ens-set-content]]\n.Setting the 'content' to return for auction.ethereumbook.eth\nimage::images/ens-manager-set-content.png[\"Set the 'content' return for auction.ethereumbook.eth\"]\n\nAfter waiting a short time for our transaction to be confirmed, we should be able to resolve the name correctly. Before setting a name, our Auction DApp could be found on a Swarm gateway by its hash:\n\n++++\n<ul class=\"simplelist\">\n<li><em>https://swarm-gateways.net/bzz:/ab164cf37dc10647e43a233486cdeffa8334b026e32a480dd9cbd020c12d4581</em></li>\n</ul>\n++++\n\nor by searching in a DApp browser or Swarm gateway for the Swarm URL:\n\n++++\n<ul class=\"simplelist\">\n<li><em>bzz://ab164cf37dc10647e43a233486cdeffa8334b026e32a480dd9cbd020c12d4581</em></li>\n</ul>\n++++\n\n[role=\"pagebreak-before\"]\nNow that we have attached it to a name, it is much easier:\n\n++++\n<ul class=\"simplelist\">\n<li><em>http://swarm-gateways.net/bzz:/auction.ethereumbook.eth/</em></li>\n</ul>\n++++\n\nWe can also find it by searching for \"auction.ethereumbook.eth\" in any ENS-compatible wallet or DApp browser (e.g., Mist)(((range=\"endofrange\", startref=\"ix_12dapps-asciidoc16\"))).(((range=\"endofrange\", startref=\"ix_12dapps-asciidoc11\")))(((range=\"endofrange\", startref=\"ix_12dapps-asciidoc10\")))(((range=\"endofrange\", startref=\"ix_12dapps-asciidoc9\")))", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Resolving a Name to a Swarm Hash (Content)"}}
{"input": "Explain the Ethereum concept: From App to DApp", "output": "Over the past several sections, we have gradually built a decentralized application. We started with a pair of smart contracts to run an auction for ERC721 deeds. These contracts were designed to have no governing or privileged accounts, so that their operation is truly decentralized. We  added a frontend, implemented in JavaScript, that offers a convenient and user-friendly interface to our DApp. The auction DApp uses the decentralized storage system Swarm to store application resources such as images. The DApp also uses the decentralized communications protocol Whisper to offer an encrypted chat room for each auction, without any central servers.\n\nWe uploaded the entire frontend to Swarm, so that our DApp doesn't rely on any web servers to serve the files. Finally, we allocated a name for our DApp using ENS, connecting it to the Swarm hash of the frontend, so that users can access it with a simple and easy-to-remember human-readable name.\n\nWith each of these steps, we increased the decentralization of our application. The final result is a DApp that has no central point of authority, no central point of failure, and expresses the \"web3\" vision.\n\n<<auction_dapp_final_architecture>> shows the complete architecture of the Auction DApp.(((range=\"endofrange\", startref=\"ix_12dapps-asciidoc3\")))(((range=\"endofrange\", startref=\"ix_12dapps-asciidoc2\")))\n\n[[auction_dapp_final_architecture]]\n.Auction DApp architecture\nimage::images/auction_dapp_final_architecture.png[\"Auction DApp architecture\"]", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "From App to DApp"}}
{"input": "Explain the Ethereum concept: Conclusions", "output": "Decentralized applications are the culmination of the Ethereum vision, as expressed by the founders from the very earliest designs. While a lot of applications call themselves \"DApps\" today, most are not fully decentralized. However, it is already possible to construct applications that are almost completely decentralized. Over time, as the technology matures further, more and more of our applications can be decentralized, resulting in a more resilient, censorship-resistant, and free web.(((range=\"endofrange\", startref=\"ix_12dapps-asciidoc0\")))", "metadata": {"source": "ethereumbook", "chapter": "12dapps.asciidoc", "section": "Conclusions"}}
{"input": "Explain the Ethereum concept: The Ethereum Virtual Machine", "output": "(((\"EVM (Ethereum Virtual Machine)\", id=\"ix_13evm-asciidoc0\", range=\"startofrange\")))At the heart of the Ethereum protocol and operation is the Ethereum Virtual Machine, or EVM for short. As you might guess from the name, it is a computation engine, not hugely dissimilar to the virtual machines of Microsoft's .NET Framework, or interpreters of other bytecode-compiled programming languages such as Java. In this chapter we take a detailed look at the EVM, including its instruction set, structure, and operation, within the context of Ethereum state updates.\n\n[[evm_description]]", "metadata": {"source": "ethereumbook", "chapter": "13evm.asciidoc", "section": "The Ethereum Virtual Machine"}}
{"input": "Explain the Ethereum concept: What Is the EVM?", "output": "(((\"EVM (Ethereum Virtual Machine)\",\"about\")))The EVM is the part of Ethereum that handles smart contract deployment and execution. Simple value transfer transactions from one EOA to another don't need to involve it, practically speaking, but everything else will involve a state update computed by the EVM. At a high level, the EVM running on the Ethereum blockchain can be thought of as a global decentralized computer containing millions of executable objects, each with its own permanent data store.\n\n(((\"Turing completeness\",\"EVM and\")))The EVM is a quasi\u2013Turing-complete state machine; \"quasi\" because all execution processes are limited to a finite number of computational steps by the amount of gas available for any given smart contract execution. As such, the halting problem is \"solved\" (all program executions will halt) and the situation where execution might (accidentally or maliciously) run forever, thus bringing the Ethereum platform to halt in its entirety, is avoided.\n\nThe EVM has a stack-based architecture, storing all in-memory values on a stack. It works with a word size of 256 bits (mainly to facilitate native hashing and elliptic curve operations) and has several addressable data components:\n\n[role=\"pagebreak-before\"]\n* An immutable _program code ROM_, loaded with the bytecode of the smart contract to be executed\n* A volatile _memory_, with every location explicitly initialized to zero\n* A permanent _storage_ that is part of the Ethereum state, also zero-initialized\n\nThere is also a set of environment variables and data that is available during execution. We will go through these in more detail later in this chapter.\n\n<<evm_architecture>> shows the EVM architecture and execution context.\n\n[[evm_architecture]]\n.The Ethereum Virtual Machine (EVM) Architecture and Execution Context\nimage::images/evm-architecture.png[\"The Ethereum Virtual Machine (EVM) Architecture and Execution Context\"]\n\n[[evm_comparison]]", "metadata": {"source": "ethereumbook", "chapter": "13evm.asciidoc", "section": "What Is the EVM?"}}
{"input": "Explain the Ethereum concept: Comparison with Existing Technology", "output": "(((\"EVM (Ethereum Virtual Machine)\",\"comparison with existing technology\")))The term \"virtual machine\" is often applied to the virtualization of a real computer, typically by a \"hypervisor\" such as VirtualBox or QEMU, or of an entire operating system instance, such as Linux's KVM. These must provide a software abstraction, respectively, of actual hardware, and of system calls and other kernel functionality.\n\nThe EVM operates in a much more limited domain: it is just a computation engine, and as such provides an abstraction of just computation and storage, similar to the Java Virtual Machine (JVM) specification, for example. From a high-level viewpoint, the JVM is designed to provide a runtime environment that is agnostic of the underlying host OS or hardware, enabling compatibility across a wide variety of systems. High-level programming languages such as Java or Scala (which use the JVM) or C# (which uses .NET) are compiled into the bytecode instruction set of their respective virtual machine. In the same way, the EVM executes its own bytecode instruction set (described in the next section), which higher-level smart contract programming languages such as LLL, Serpent, Mutan, or Solidity are compiled into.\n\nThe EVM, therefore, has no scheduling capability, because execution ordering is organized externally to it&#x2014;Ethereum clients run through verified block transactions to determine which smart contracts need executing and in which order. In this sense, the Ethereum world computer is single-threaded, like JavaScript. Neither does the EVM have any \"system interface\" handling or &#x201c;hardware support&#x201d;&#x2014;there is no physical machine to interface with. The Ethereum world computer is completely virtual.\n\n[[evm_bytecode_overview]]", "metadata": {"source": "ethereumbook", "chapter": "13evm.asciidoc", "section": "Comparison with Existing Technology"}}
{"input": "Explain the Ethereum concept: The EVM Instruction Set (Bytecode Operations)", "output": "(((\"bytecode operations\", id=\"ix_13evm-asciidoc1\", range=\"startofrange\")))(((\"EVM (Ethereum Virtual Machine)\",\"instruction set (bytecode operations)\", id=\"ix_13evm-asciidoc2\", range=\"startofrange\")))(((\"EVM bytecode\",\"instruction set\", id=\"ix_13evm-asciidoc3\", range=\"startofrange\")))The EVM instruction set offers most of the operations you might expect, including:\n\n* Arithmetic and bitwise logic operations\n* Execution context inquiries\n* Stack, memory, and storage access\n* Control flow operations\n* Logging, calling, and other operators\n\nIn addition to the typical bytecode operations, the EVM also has access to account information (e.g., address and balance) and block information (e.g., block number and current gas price).\n\nLet's start our exploration of the EVM in more detail by looking at the available opcodes and what they do. As you might expect, all operands are taken from the stack, and the result (where applicable) is often\nput back on the top of the stack.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "13evm.asciidoc", "section": "The EVM Instruction Set (Bytecode Operations)"}}
{"input": "Explain the Ethereum concept: Ethereum State", "output": "(((\"EVM (Ethereum Virtual Machine)\",\"Ethereum state updating\")))The job of the EVM is to update the Ethereum state by computing valid state transitions as a result of smart contract code execution, as defined by the Ethereum protocol. This aspect leads to the description of Ethereum as a _transaction-based state machine_, which reflects the fact that external actors (i.e., account holders and miners) initiate state transitions by creating, accepting, and ordering transactions. It is useful at this point to consider what constitutes the Ethereum state.\n\n(((\"world state\")))At the top level, we have the Ethereum _world state_. The world state is a mapping of Ethereum addresses (160-bit values) to (((\"account\",\"world state and\")))_accounts_. (((\"balance, world state and\")))(((\"nonces\",\"world state and\")))At the lower level, each Ethereum address represents an account comprising an ether _balance_ (stored as the number of wei owned by the account), a _nonce_ (representing the number of transactions successfully sent from this account if it is an EOA, or the number of contracts created by it if it is a contract account), the account's _storage_ (which is a permanent data store, only used by smart contracts), and the account's _program code_ (again, only if the account is a smart contract account). An EOA will always have no code and an empty storage.\n\n////\nTODO: basic diagram showing the structure of the world state mapping and account structure\n////\n\nWhen a transaction results in smart contract code execution, an EVM is instantiated with all the information required in relation to the current block being created and the specific transaction being processed. In particular, the EVM's program code ROM is loaded with the code of the contract account being called, the program counter is set to zero, the storage is loaded from the contract account's storage, the memory is set to all zeros, and all the block and environment variables are set. A key variable is the gas supply for this execution, which is set to the amount of gas paid for by the sender at the start of the transaction (see <<gas>> for more details). As code execution progresses, the gas supply is reduced according to the gas cost of the operations executed. If at any point the gas supply is reduced to zero we get an \"Out of Gas\" (OOG) exception; execution immediately halts and the transaction is abandoned. No changes to the Ethereum state are applied, except for the sender's nonce being incremented and their ether balance going down to pay the block's beneficiary for the resources used to execute the code to the halting point. At this point, you can think of the EVM running on a sandboxed copy of the Ethereum world state, with this sandboxed version being discarded completely if execution cannot complete for whatever reason. However, if execution does complete successfully, then the real-world state is updated to match the sandboxed version, including any changes to the called contract's storage data, any new contracts created, and any ether balance transfers that were initiated.\n\nNote that because a smart contract can itself effectively initiate transactions, code execution is a recursive process. A contract can call other contracts, with each call resulting in another EVM being instantiated around the new target of the call. Each instantiation has its sandbox world state initialized from the sandbox of the EVM at the level above. Each instantiation is also given a specified amount of gas for its gas supply (not exceeding the amount of gas remaining in the level above, of course), and so may itself halt with an exception due to being given too little gas to complete its execution. Again, in such cases, the sandbox state is discarded, and execution returns to the EVM at the level above.\n\n[[compiling_solidity_to_evm]]", "metadata": {"source": "ethereumbook", "chapter": "13evm.asciidoc", "section": "Ethereum State"}}
{"input": "Explain the Ethereum concept: Compiling Solidity to EVM Bytecode", "output": "[[solc_help]]\n(((\"EVM (Ethereum Virtual Machine)\",\"compiling Solidity to EVM bytecode\", id=\"ix_13evm-asciidoc4\", range=\"startofrange\")))(((\"EVM bytecode\",\"compiling source file to\", id=\"ix_13evm-asciidoc5\", range=\"startofrange\")))(((\"Solidity\",\"compiling source file to EVM bytecode\", id=\"ix_13evm-asciidoc6\", range=\"startofrange\")))Compiling a Solidity source file to EVM bytecode can be accomplished via several methods. In <<intro_chapter>> we used the online Remix compiler. In this chapter, we will use the +solc+ executable at the command line. For a list of options, run the following pass:[<span class=\"keep-together\">command</span>]:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>solc --help</strong>\n</pre>\n++++\n\n[[solc_opcodes_option]]\nGenerating the raw opcode stream of a Solidity source file is easily achieved with the +--opcodes+ command-line option. This opcode stream leaves out some information (the +--asm+ option produces the full information), but it is sufficient for this discussion. For example, compiling an example Solidity file, _Example.sol_, and sending the opcode output into a directory named _BytecodeDir_ is accomplished with the following command:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>solc -o BytecodeDir --opcodes Example.sol</strong>\n</pre>\n++++\n\nor:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>solc -o BytecodeDir --asm Example.sol</strong>\n</pre>\n++++\n\n[[solc_bin_option]]\nThe following command will produce the bytecode binary for our example program:\n\n++++\n<pre data-type=\"programlisting\">\n$ <strong>solc -o BytecodeDir --bin Example.sol</strong>\n</pre>\n++++\n\nThe output opcode files generated will depend on the specific contracts contained within the Solidity source file. Our simple Solidity file _Example.sol_ has only one contract, named +example+:\n\n[[simple_solidity_example]]\n[source,solidity]\n----\npragma solidity ^0.4.19;\n\ncontract example {\n\n  address contractOwner;\n\n  function example() {\n    contractOwner = msg.sender;\n  }\n}\n----\n\nAs you can see, all this contract does is hold one persistent state variable, which is set as the address of the last account to run this contract.\n\nIf you look in the _BytecodeDir_ directory you will see the opcode file _example.opcode_, which contains the EVM opcode instructions of the +example+ contract. Opening the _example.opcode_ file in a text editor will show the following:\n\n[[opcode_output]]\n----\nPUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE ISZERO PUSH1 0xE JUMPI PUSH1 0x0 DUP1\nREVERT JUMPDEST CALLER PUSH1 0x0 DUP1 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH20\n0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH20\n0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP PUSH1\n0x35 DUP1 PUSH1 0x5B PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN STOP PUSH1 0x60 PUSH1\n0x40 MSTORE PUSH1 0x0 DUP1 REVERT STOP LOG1 PUSH6 0x627A7A723058 KECCAK256 JUMP\n0xb9 SWAP14 0xcb 0x1e 0xdd RETURNDATACOPY 0xec 0xe0 0x1f 0x27 0xc9 PUSH5\n0x9C5ABCC14A NUMBER 0x5e INVALID EXTCODESIZE 0xdb 0xcf EXTCODESIZE 0x27\nEXTCODESIZE 0xe2 0xb8 SWAP10 0xed 0x\n----\n\nCompiling the example with the +--asm+ option produces a file named _example.evm_ in our _BytecodeDir_ directory. This contains a slightly higher-level description of the EVM bytecode instructions, together with some helpful annotations:\n\n[[asm_output]]\n[source,solidity]\n----\n/* \"Example.sol\":26:132  contract example {... */\n  mstore(0x40, 0x60)\n    /* \"Example.sol\":74:130  function example() {... */\n  jumpi(tag_1, iszero(callvalue))\n  0x0\n  dup1\n  revert\ntag_1:\n    /* \"Example.sol\":115:125  msg.sender */\n  caller\n    /* \"Example.sol\":99:112  contractOwner */\n  0x0\n  dup1\n    /* \"Example.sol\":99:125  contractOwner = msg.sender */\n  0x100\n  exp\n  dup2\n  sload\n  dup2\n  0xffffffffffffffffffffffffffffffffffffffff\n  mul\n  not\n  and\n  swap1\n  dup4\n  0xffffffffffffffffffffffffffffffffffffffff\n  and\n  mul\n  or\n  swap1\n  sstore\n  pop\n    /* \"Example.sol\":26:132  contract example {... */\n  dataSize(sub_0)\n  dup1\n  dataOffset(sub_0)\n  0x0\n  codecopy\n  0x0\n  return\nstop\n\nsub_0: assembly {\n        /* \"Example.sol\":26:132  contract example {... */\n      mstore(0x40, 0x60)\n      0x0\n      dup1\n      revert\n\n    auxdata: 0xa165627a7a7230582056b99dcb1edd3eece01f27c9649c5abcc14a435efe3b...\n}\n----\n\nThe +--bin-runtime+ option produces the machine-readable hexadecimal bytecode:\n\n[[bin_output]]\n----\n60606040523415600e57600080fd5b336000806101000a81548173\nffffffffffffffffffffffffffffffffffffffff\n021916908373\nffffffffffffffffffffffffffffffffffffffff\n160217905550603580605b6000396000f3006060604052600080fd00a165627a7a7230582056b...\n----\n\nYou can investigate what's going on here in detail using the opcode list given in <<evm_bytecode_overview>>. However, that's quite a task, so let's just start by examining the first four instructions:\n\n[[opcode_analysis_1]]\n----\nPUSH1 0x60 PUSH1 0x40 MSTORE CALLVALUE\n----\n\nHere we have +PUSH1+ followed by a raw byte of value +0x60+. This EVM instruction takes the single byte following the opcode in the program code (as a literal value) and pushes it onto the stack. It is possible to push values of size up to 32 bytes onto the stack, as in:\n\n----\nPUSH32 0x436f6e67726174756c6174696f6e732120536f6f6e20746f206d617374657221\n----\n\nThe second +PUSH1+ opcode from _example.opcode_ stores +0x40+ onto the top of the stack (pushing the +0x60+ already present there down one slot).\n\nNext is +MSTORE+, which is a memory store operation that saves a value to the EVM's memory. It takes two arguments and, like most EVM operations, obtains them from the stack. For each argument the stack is pass:[&#x201c;popped&#x201d;;] i.e., the top value on the stack is taken off and all the other values on the stack are shifted up one position. The first argument for +MSTORE+ is the address of the word in memory where the value to be saved will be put. For this program we have +0x40+ at the top of the stack, so that is removed from the stack and used as the memory address. The second argument is the value to be saved, which is +0x60+ here. After the +MSTORE+ operation is executed our stack is empty again, but we have the value +0x60+ (+96+ in decimal) at the memory location +0x40+.\n\nThe next opcode is +CALLVALUE+, which is an environmental opcode that pushes onto the top of the stack the amount of ether (measured in wei) sent with the message call that initiated this execution.\n\nWe could continue to step through this program in this way until we had a full understanding of the low-level state changes that this code effects, but it wouldn't help us at this stage. We'll come back to it later in the chapter.(((range=\"endofrange\", startref=\"ix_13evm-asciidoc6\")))(((range=\"endofrange\", startref=\"ix_13evm-asciidoc5\")))(((range=\"endofrange\", startref=\"ix_13evm-asciidoc4\")))\n\n[[contract_deployment_code]]", "metadata": {"source": "ethereumbook", "chapter": "13evm.asciidoc", "section": "Compiling Solidity to EVM Bytecode"}}
{"input": "Explain the Ethereum concept: Contract Deployment Code", "output": "(((\"EVM (Ethereum Virtual Machine)\",\"contract deployment code\", id=\"ix_13evm-asciidoc7\", range=\"startofrange\")))(((\"EVM bytecode\",\"contract deployment code\", id=\"ix_13evm-asciidoc8\", range=\"startofrange\")))There is an important but subtle difference between the code used when creating and deploying a new contract on the Ethereum platform and the code of the contract itself. In order to create a new contract, a special transaction is needed that has its +to+ field set to the special +0x0+ address and its +data+ field set to the contract's _initiation code_. When such a contract creation transaction is processed, the code for the new contract account is _not_ the code in the +data+ field of the transaction. Instead, an EVM is instantiated with the code in the +data+ field of the transaction loaded into its program code ROM, and then the output of the execution of that deployment code is taken as the code for the new contract account. This is so that new contracts can be programmatically initialized using the Ethereum world state at the time of deployment, setting values in the contract's storage and even sending ether or creating further new contracts.\n\nWhen compiling a contract offline, e.g., using +solc+ on the command line, you can either get the _deployment bytecode_ or the _runtime bytecode_.\n\n(((\"deployment bytecode\")))The deployment bytecode is used for every aspect of the initialization of a new contract account, including the bytecode that will actually end up being executed when transactions call this new contract (i.e., the runtime bytecode) and the code to initialize everything based on the contract's constructor.\n\n(((\"runtime bytecode\")))The runtime bytecode, on the other hand, is exactly the bytecode that ends up being executed when the new contract is called, and nothing more; it does not include the bytecode needed to initialize the contract during deployment.\n\nLet's take the simple _Faucet.sol_ contract we created earlier as an example:\n\n[[faucet_example]]\n[source,solidity]\n----\n// Version of Solidity compiler this program was written for\npragma solidity ^0.4.19;\n\n// Our first contract is a faucet!\ncontract Faucet {\n\n  // Give out ether to anyone who asks\n  function withdraw(uint withdraw_amount) public {\n\n      // Limit withdrawal amount\n      require(withdraw_amount <= 100000000000000000);\n\n      // Send the amount to the address that requested it\n      msg.sender.transfer(withdraw_amount);\n    }\n\n  // Accept any incoming amount\n  function () external payable {}\n\n}\n----\n\nTo get the deployment bytecode, we would run `solc --bin Faucet.sol`. If we instead wanted just the runtime bytecode, we would run pass:[<code>solc --bin-runtime <span class=\"keep-together\">Faucet.sol</span></code>].\n\nIf you compare the output of these commands, you will see that the runtime bytecode is a subset of the deployment bytecode. In other words, the runtime bytecode is entirely contained within the deployment bytecode.(((range=\"endofrange\", startref=\"ix_13evm-asciidoc8\")))(((range=\"endofrange\", startref=\"ix_13evm-asciidoc7\")))\n\n[[disassembling_the_bytecode]]", "metadata": {"source": "ethereumbook", "chapter": "13evm.asciidoc", "section": "Contract Deployment Code"}}
{"input": "Explain the Ethereum concept: Disassembling the Bytecode", "output": "(((\"EVM (Ethereum Virtual Machine)\",\"disassembling bytecode\", id=\"ix_13evm-asciidoc9\", range=\"startofrange\")))(((\"EVM bytecode\",\"disassembling\", id=\"ix_13evm-asciidoc10\", range=\"startofrange\")))Disassembling EVM bytecode is a great way to understand how high-level Solidity acts in the EVM. There are a few disassemblers you can use to do this:\n\n- https://github.com/comaeio/porosity[_Porosity_] is a popular open source decompiler.\n- https://github.com/trailofbits/ethersplay[_Ethersplay_] is an EVM plug-in for Binary Ninja, a disassembler.\n- https://github.com/trailofbits/ida-evm[_IDA-Evm_] is an EVM plugin for IDA, another disassembler.\n\nIn this section, we will be using the Ethersplay plug-in for Binary Ninja and to start <<Faucet_disassembled>>. After getting the runtime bytecode of _Faucet.sol_, we can feed it into Binary Ninja (after loading the Ethersplay plug-in) to see what the EVM instructions look like.\n\n[[Faucet_disassembled]]\n.Disassembling the Faucet runtime bytecode\nimage::images/Faucet_disassembled.png[\"Faucet.sol runtime bytecode disassembled\"]\n\nWhen you send a transaction to an ABI-compatible smart contract (which you can assume all contracts are), the transaction first interacts with that smart contract's _dispatcher_. The dispatcher reads in the +data+ field of the transaction and sends the relevant part to the appropriate function. We can see an example of a dispatcher at the beginning of our disassembled _Faucet.sol_ runtime bytecode. After the familiar +MSTORE+ instruction, we see the following instructions:\n\n[[faucet_instructions]]\n----\nPUSH1 0x4\nCALLDATASIZE\nLT\nPUSH1 0x3f\nJUMPI\n----\n\nAs we have seen, +PUSH1 0x4+ places +0x4+ onto the top of the stack, which is otherwise empty. +CALLDATASIZE+ gets the size in bytes of the data sent with the transaction (known as the _calldata_) and pushes that number onto the stack. After these operations have been executed, the stack looks like this:\n\n[width=\"40%\",frame=\"topbot\",options=\"header,footer\"]\n|======================\n|Stack\n|<length of calldata from tx>\n|+0x4+\n|\n|======================\n\nThis next instruction is +LT+, short for \u201cless than.\u201d The +LT+ instruction checks whether the top item on the stack is less than the next item on the stack. In our case, it checks to see if the result of +CALLDATASIZE+ is less than 4 bytes.\n\nWhy does the EVM check to see that the calldata of the transaction is at least 4 bytes? Because of how function identifiers work. Each function is identified by the first 4 bytes of its Keccak-256 hash. By placing the function's name and what arguments it takes into a +keccak256+ hash function, we can deduce its function identifier. In our case, we have:\n\n[[faucet_function_identifier]]\n```\nkeccak256(\"withdraw(uint256)\") = 0x2e1a7d4d...\n```\n\nThus, the function identifier for the +withdraw(uint256)+ function is +0x2e1a7d4d+, since these are the first 4 bytes of the resulting hash. A function identifier is always 4 bytes long, so if the entire +data+ field of the transaction sent to the contract is less than 4 bytes, then there\u2019s no function with which the transaction could possibly be communicating, unless a _fallback function_ is defined. Because we implemented such a fallback function in _Faucet.sol_, the EVM jumps to this function when the calldata's length is less than 4 bytes.\n\n+LT+ pops the top two values off the stack and, if the transaction's +data+ field is less than 4 bytes, pushes +1+ onto it. Otherwise, it pushes +0+. In our example, let's assume the +data+ field of the transaction sent to our contract _was_ less than 4 bytes.\n\nThe +PUSH1 0x3f+ instruction pushes the byte +0x3f+ onto the stack. After this instruction, the stack looks like this:\n\n[width=\"40%\",frame=\"topbot\",options=\"header,footer\"]\n|======================\n|Stack\n|+0x3f+\n|+1+\n|\n|======================\n\nThe next instruction is +JUMPI+, which stands for \"jump if.\" It works like so:\n\n[[faucet_jump_instruction_text]]\n----\njumpi(label, cond) // Jump to \"label\" if \"cond\" is true\n----\n\nIn our case, +label+ is +0x3f+, which is where our fallback function lives in our smart contract. The +cond+ argument is +1+, which was the result of the +LT+ instruction earlier. To put this entire sequence into words, the contract jumps to the fallback function if the transaction data is less than 4 bytes.\n\nAt +0x3f+, only a +STOP+ instruction follows, because although we declared a fallback function, we kept it empty. As you can see in <<Faucet_jumpi_instruction>>, had we not implemented a fallback function, the contract would throw an exception instead.\n\n[[Faucet_jumpi_instruction]]\n.JUMPI instruction leading to fallback function\nimage::images/Faucet_jumpi_instruction.png[\"JUMPI instruction leading to fallback function\"]\n\nLet's examine the central block of the dispatcher. Assuming we received calldata that was _greater_ than 4 bytes in length, the +JUMPI+ instruction would not jump to the fallback function. Instead, code execution would proceed to the following instructions:\n\n[[faucet_instructions2]]\n----\nPUSH1 0x0\nCALLDATALOAD\nPUSH29 0x1000000...\nSWAP1\nDIV\nPUSH4 0xffffffff\nAND\nDUP1\nPUSH4 0x2e1a7d4d\nEQ\nPUSH1 0x41\nJUMPI\n----\n\n+PUSH1 0x0+ pushes +0+ onto the stack, which is now otherwise empty again. +CALLDATALOAD+ accepts as an argument an index within the calldata sent to the smart contract and reads 32 bytes from that index, like so:\n\n[[faucet_calldataload_instruction_text]]\n----\ncalldataload(p) //load 32 bytes of calldata starting from byte position p\n----\n\nSince +0+ was the index passed to it from the +PUSH1 0x0+ command, +CALLDATALOAD+ reads 32 bytes of calldata starting at byte 0, and then pushes it to the top of the stack (after popping the original +0x0+). After the ++PUSH29 0x1000000++... instruction, the stack is then:\n\n[width=\"40%\",frame=\"topbot\",options=\"header,footer\"]\n|======================\n|Stack\n|++0x1000000++... (29 bytes in length)\n|<32 bytes of calldata starting at byte 0>\n|\n|======================\n\n+SWAP1+ switches the top element on the stack with the __i__-th element after it. In this case, it swaps ++0x1000000++... with the calldata. The new stack is:\n\n[width=\"40%\",frame=\"topbot\",options=\"header,footer\"]\n|======================\n|Stack\n|<32 bytes of calldata starting at byte 0>\n|++0x1000000++... (29 bytes in length)\n|\n|======================\n\nThe next instruction is +DIV+, which works as follows:\n\n[[faucet_div_instruction_text]]\n----\ndiv(x, y) // integer division x / y\n----\n\nIn this case, +x+ = 32 bytes of calldata starting at byte 0, and +y+ = ++0x100000000++... (29 bytes total). Can you think of why the dispatcher is doing the division? Here's a hint: we read 32 bytes from calldata earlier, starting at index 0. The first 4 bytes of that calldata is the function identifier.\n\n\nThe ++0x100000000++... we pushed earlier is 29 bytes long, consisting of a +1+ at the beginning, followed by all ++0++s. Dividing our 32 bytes of calldata by this value will leave us only the _topmost 4 bytes_ of our calldata load, starting at index 0. These 4 bytes\u2014the first 4 bytes in the calldata starting at index 0\u2014are the function identifier, and this is how the EVM extracts that field.\n\nIf this part isn\u2019t clear to you, think of it like this: in base 10, 1234000 / 1000 = 1234. In base 16, this is no different. Instead of every place being a multiple of 10, it is a multiple of 16. Just as dividing by 10^3^ (1000) in our smaller example kept only the topmost digits, dividing our 32-byte base 16 value by 16^29^ does the same.\n\nThe result of the +DIV+ (the function identifier) gets pushed onto the stack, and our stack is now:\n\n[width=\"40%\",frame=\"topbot\",options=\"header,footer\"]\n|======================\n|Stack\n|<function identifier sent in +data+>\n|\n|======================\n\nSince the +PUSH4 0xffffffff+ and +AND+ instructions are redundant, we can ignore them entirely, as the stack will remain the same after they are done. The +DUP1+ instruction duplicates the first item on the stack, which is the function identifier. The next instruction, +PUSH4 0x2e1a7d4d+, pushes the precalculated function identifier of the pass:[<code><span class=\"keep-together\">withdraw</span>(uint256)</code>] function onto the stack. The stack is now:\n\n[width=\"40%\",frame=\"topbot\",options=\"header,footer\"]\n|======================\n|Stack\n|+0x2e1a7d4d+\n|<function identifier sent in +data+>\n|<function identifier sent in +data+>\n|\n|======================\n\nThe next instruction, +EQ+, pops off the top two items of the stack and compares them. This is where the dispatcher does its main job: it compares whether the function identifier sent in the +msg.data+ field of the transaction matches that of pass:[<code><span class=\"keep-together\">withdraw</span>(uint256)</code>]. If they are equal, +EQ+ pushes +1+ onto the stack, which will ultimately be used to jump to the withdraw function. Otherwise, +EQ+ pushes +0+ onto the stack.\n\nAssuming the transaction sent to our contract indeed began with the function identifier for +withdraw(uint256)+, our stack has become:\n\n[width=\"40%\",frame=\"topbot\",options=\"header,footer\"]\n|======================\n|Stack\n|+1+\n|<function identifier sent in +data+> (now known to be +0x2e1a7d4d+)\n|\n|======================\n\nNext, we have +PUSH1 0x41+, which is the address at which the +withdraw(uint256)+ function lives in the contract. After this instruction, the stack looks like this:\n\n[width=\"40%\",frame=\"topbot\",options=\"header,footer\"]\n|======================\n|Stack\n|+0x41+\n|+1+\n|function identifier sent in +msg.data+\n|\n|======================\n\nThe +JUMPI+ instruction is next, and it once again accepts the top two elements on the stack as arguments. In this case, we have +jumpi(0x41, 1)+, which tells the EVM to execute the jump to the location of the +withdraw(uint256)+ function, and the execution of that function's code can proceed.(((range=\"endofrange\", startref=\"ix_13evm-asciidoc10\")))(((range=\"endofrange\", startref=\"ix_13evm-asciidoc9\")))\n\n[[turing_completeness_and_gas]]", "metadata": {"source": "ethereumbook", "chapter": "13evm.asciidoc", "section": "Disassembling the Bytecode"}}
{"input": "Explain the Ethereum concept: Turing Completeness and Gas", "output": "(((\"EVM (Ethereum Virtual Machine)\",\"Turing completeness and Gas\")))(((\"Turing completeness\",\"EVM and\")))As we have already touched on, in simple terms, a system or programming language is _Turing complete_ if it can run any program. This capability, however, comes with a very important caveat: some programs take forever to run. An important aspect of this is that we can't tell, just by looking at a program, whether it will take forever or not to execute. We have to actually go through with the execution of the program and wait for it to finish to find out. (((\"halting problem\")))Of course, if it is going to take forever to execute, we will have to wait forever to find out. This is called the _halting problem_ and would be a huge problem for Ethereum if it were not addressed.\n\nBecause of the halting problem, the Ethereum world computer is at risk of being asked to execute a program that never stops. This could be by accident or malice. We have discussed that Ethereum acts like a single-threaded machine, without any scheduler, and so if it became stuck in an infinite loop this would mean it would become unusable.\n\nHowever, with gas, there is a solution: if after a prespecified maximum amount of computation has been performed, the execution hasn't ended, the execution of the program is halted by the EVM. This makes the EVM a __quasi__&#x2013;Turing-complete machine: it can run any program you feed into it, but only if the program terminates within a particular amount of computation. That limit isn't fixed in Ethereum&#x2014;you can pay to increase it up to a maximum (called the \"block gas limit\"), and everyone can agree to increase that maximum over time. Nevertheless, at any one time, there is a limit in place, and transactions that consume too much gas while executing are pass:[<span class=\"keep-together\">halted</span>].\n\nIn the following sections, we will look at gas and examine how it works in detail.\n\n[[gas]]", "metadata": {"source": "ethereumbook", "chapter": "13evm.asciidoc", "section": "Turing Completeness and Gas"}}
{"input": "Explain the Ethereum concept: Gas", "output": "(((\"EVM (Ethereum Virtual Machine)\",\"gas and\", id=\"ix_13evm-asciidoc11\", range=\"startofrange\")))(((\"gas\",\"EVM and\", id=\"ix_13evm-asciidoc12\", range=\"startofrange\")))_Gas_ is Ethereum's unit for measuring the computational and storage resources required to perform actions on the Ethereum blockchain. In contrast to Bitcoin, whose transaction fees only take into account the size of a transaction in kilobytes, Ethereum must account for every computational step performed by transactions and smart contract code execution.\n\nEach operation performed by a transaction or contract costs a fixed amount of gas. Some examples, from the Ethereum Yellow Paper:\n\n* Adding two numbers costs 3 gas\n* Calculating a Keccak-256 hash costs 30 gas + 6 gas for each 256 bits of data being hashed\n* Sending a transaction costs 21,000 gas\n\nGas is a crucial component of Ethereum, and serves a dual role: as a buffer between the (volatile) price of Ethereum and the reward to miners for the work they do, and as a defense against denial-of-service attacks. To prevent accidental or malicious infinite loops or other computational wastage in the network, the initiator of each transaction is required to set a limit to the amount of computation they are willing to pay for. The gas system thereby disincentivizes attackers from sending \"spam\" transactions, as they must pay proportionately for the computational, bandwidth, and storage resources that they consume.\n\n[[gas_accounting_execution]]", "metadata": {"source": "ethereumbook", "chapter": "13evm.asciidoc", "section": "Gas"}}
{"input": "Explain the Ethereum concept: Gas Accounting During Execution", "output": "(((\"EVM (Ethereum Virtual Machine)\",\"gas accounting during execution\")))(((\"gas\",\"accounting during execution\")))When an EVM is needed to complete a transaction, in the first instance it is given a gas supply equal to the amount specified by the gas limit in the transaction. Every opcode that is executed has a cost in gas, and so the EVM's gas supply is reduced as the EVM steps through the program. Before each operation, the EVM checks that there is enough gas to pay for the operation's execution. If there isn't enough gas, execution is halted and the transaction is reverted.\n\nIf the EVM reaches the end of execution successfully, without running out of gas, the  gas cost used is paid to the miner as a transaction fee, converted to ether based on the gas price specified in the transaction:\n\n----\nminer fee = gas cost * gas price\n----\n\n\nThe gas remaining in the gas supply is refunded to the sender, again converted to ether based on the gas price specified in the transaction:\n\n----\nremaining gas = gas limit - gas cost\nrefunded ether = remaining gas * gas price\n----\n\nIf the transaction &#x201c;runs out of gas&#x201d; during execution, the operation is immediately terminated, raising an &#x201c;out of gas&#x201d; exception. The transaction is reverted and all changes to the state are rolled back.\n\nAlthough the transaction was unsuccessful, the sender will be charged a transaction fee, as miners have already performed the computational work up to that point and must be compensated for doing so.", "metadata": {"source": "ethereumbook", "chapter": "13evm.asciidoc", "section": "Gas Accounting During Execution"}}
{"input": "Explain the Ethereum concept: Gas Accounting Considerations", "output": "(((\"EVM (Ethereum Virtual Machine)\",\"gas accounting considerations\")))(((\"gas\",\"accounting considerations\")))The relative gas costs of the various operations that can be performed by the EVM have been carefully chosen to best protect the Ethereum blockchain from attack. You can see a detailed table of gas costs for different EVM opcodes in <<evm_opcodes_table>>.\n\nMore computationally intensive operations cost more gas. For example, executing the +SHA3+ function is 10 times more expensive (30 gas) than the +ADD+ operation (3 gas). More importantly, some operations, such as +EXP+, require an additional payment based on the size of the operand. There is also a gas cost to using EVM memory and for storing data in a contract's on-chain storage.\n\nThe importance of matching gas cost to the real-world cost of resources was demonstrated in 2016 when an attacker found and exploited a mismatch in costs. The attack generated transactions that were very computationally expensive, and made the Ethereum mainnet almost grind to a halt. This mismatch was resolved by a hard fork (codenamed \"Tangerine Whistle\") that tweaked the relative gas costs.", "metadata": {"source": "ethereumbook", "chapter": "13evm.asciidoc", "section": "Gas Accounting Considerations"}}
{"input": "Explain the Ethereum concept: Gas Cost Versus Gas Price", "output": "(((\"EVM (Ethereum Virtual Machine)\",\"gas cost vs. gas price\")))(((\"gas\",\"cost vs. price\")))(((\"gas cost, gas price vs.\")))While the gas _cost_ is a measure of computation and storage used in the EVM, the gas itself also has a _price_ measured in ether. When performing a transaction, the sender specifies the gas price they are willing to pay (in ether) for each unit of gas, allowing the market to decide the relationship between the price of ether and the cost of computing operations (as measured in gas):\n\n----\ntransaction fee = total gas used * gas price paid  (in ether)\n----\n\nWhen constructing a new block, miners on the Ethereum network can choose among pending transactions by selecting those that offer to pay a higher gas price. Offering a higher gas price will therefore incentivize miners to include your transaction and get it confirmed faster.\n\nIn practice, the sender of a transaction will set a gas limit that is higher than or equal to the amount of gas expected to be used. If the gas limit is set higher than the amount of gas consumed, the sender will receive a refund of the excess amount, as miners are only compensated for the work they actually perform.\n\nIt is important to be clear about the distinction between the _gas cost_ and the _gas price_. To recap:\n\n* Gas cost is the number of units of gas required to perform a particular operation.\n\n* Gas price is the amount of ether you are willing to pay per unit of gas when you send your transaction to the Ethereum network.\n\n[TIP]", "metadata": {"source": "ethereumbook", "chapter": "13evm.asciidoc", "section": "Gas Cost Versus Gas Price"}}
{"input": "Explain the Ethereum concept: Negative gas costs", "output": "(((\"gas\",\"negative costs\")))Ethereum encourages the deletion of used storage variables and accounts by refunding some of the gas used during contract execution.\n\nThere are two operations in the EVM with negative gas costs:\n\n* Deleting a contract (+SELFDESTRUCT+) is worth a refund of 24,000 gas.\n* Changing a storage address from a nonzero value to zero (+SSTORE[x] = 0+) is worth a refund of 15,000 gas.\n\nTo avoid exploitation of the refund mechanism, the maximum refund for a transaction is set to half the total amount of gas used (rounded down).", "metadata": {"source": "ethereumbook", "chapter": "13evm.asciidoc", "section": "Negative gas costs"}}
{"input": "Explain the Ethereum concept: Block Gas Limit", "output": "(((\"block gas limit\")))(((\"EVM (Ethereum Virtual Machine)\",\"block gas limit\")))(((\"gas\",\"block gas limit\")))The block gas limit is the maximum amount of gas that may be consumed by all the transactions in a block, and constrains how many transactions can fit into a block.\n\nFor example, let\u2019s say we have 5 transactions whose gas limits have been set to 30,000, 30,000, 40,000, 50,000, and 50,000. If the block gas limit is 180,000, then any four of those transactions can fit in a block, while the fifth will have to wait for a future block. As previously discussed, miners decide which transactions to include in a block. Different miners are likely to select different combinations, mainly because they receive transactions from the network in a different order.\n\nIf a miner tries to include a transaction that requires more gas than the current block gas limit, the block will be rejected by the network. Most Ethereum clients will stop you from issuing such a transaction by giving a warning along the lines of \u201ctransaction exceeds block gas limit.\u201d The block gas limit on the Ethereum mainnet is 8 million gas at the time of writing according to https://etherscan.io, meaning that around 380 basic transactions (each consuming 21,000 gas) could fit into a block.", "metadata": {"source": "ethereumbook", "chapter": "13evm.asciidoc", "section": "Block Gas Limit"}}
{"input": "Explain the Ethereum concept: Who decides what the block gas limit is?", "output": "The miners on the network collectively decide the block gas limit. Individuals who want to mine on the Ethereum network use a mining program, such as Ethminer, which connects to a Geth or Parity Ethereum client. The Ethereum protocol has a built-in mechanism where miners can vote on the gas limit so capacity can be increased or decreased in subsequent blocks. The miner of a block can vote to adjust the block gas limit by a factor of 1/1,024 (0.0976%) in either direction. The result of this is an adjustable block size based on the needs of the network at the time. This mechanism is coupled with a default mining strategy where miners vote on a gas limit that is at least 4.7 million gas, but which targets a value of 150% of the average of recent total gas usage per block (using a 1,024-block exponential moving average).(((range=\"endofrange\", startref=\"ix_13evm-asciidoc12\")))(((range=\"endofrange\", startref=\"ix_13evm-asciidoc11\")))", "metadata": {"source": "ethereumbook", "chapter": "13evm.asciidoc", "section": "Who decides what the block gas limit is?"}}
{"input": "Explain the Ethereum concept: Conclusions", "output": "In this chapter we have explored the Ethereum Virtual Machine, tracing the execution of various smart contracts and looking at how the EVM executes bytecode. We also looked at gas, the EVM's accounting mechanism, and saw how it solves the halting problem and protects Ethereum from denial-of-service attacks. Next, in <<consensus>>, we will look at the mechanism used by Ethereum to achieve decentralized consensus.(((range=\"endofrange\", startref=\"ix_13evm-asciidoc0\")))", "metadata": {"source": "ethereumbook", "chapter": "13evm.asciidoc", "section": "Conclusions"}}
{"input": "Explain the Ethereum concept: Consensus", "output": "(((\"consensus\", id=\"ix_14consensus-asciidoc0\", range=\"startofrange\")))Throughout this book we have talked about \"consensus rules&#x201d;&#x2014;the rules that everyone must agree to for the system to operate in a decentralized, yet deterministic, manner. In computer science, the term _consensus_ predates blockchains and is related to the broader problem of synchronizing state in distributed systems, such that different participants in a distributed system all (eventually) agree on a single system-wide state. This is called \"reaching consensus.\"\n\nWhen it comes to the core function of decentralized record keeping and verification, it can become problematic to rely on trust alone to ensure that information derived from state updates is correct. This rather general challenge is particularly pronounced in decentralized networks because there is no central entity to decide what is true. The lack of a central decision-making entity is one of the main attractions of blockchain platforms, because of the resulting capacity to resist censorship and the lack of dependence on authority for permission to access information. However, these benefits come at a cost: without a trusted arbitrator, any disagreements, deceptions, or differences need to be reconciled using other means. Consensus algorithms are the  mechanism used to reconcile security and decentralization.\n\nIn blockchains, consensus is a critical property of the system. Simply put, there is money at stake! So, in the context of blockchains, _consensus_ is about being able to arrive at a common state, while maintaining decentralization. In other words, consensus is intended to produce a system of _strict rules without rulers_. There is no one person, organization, or group pass:[\"in charge&#x201d;;] rather, power and control are diffused across a broad network of participants, whose self-interest is served by following the rules and behaving honestly.\n\nThe ability to come to consensus across a distributed network, under adversarial conditions, without centralizing control is the core principle of all open public blockchains. To address this challenge and maintain the valued property of decentralization, the community continues to experiment with different models of consensus. This chapter explores these consensus models and their expected impact on smart contract blockchains such as Ethereum.\n\n[NOTE]", "metadata": {"source": "ethereumbook", "chapter": "14consensus.asciidoc", "section": "Consensus"}}
{"input": "Explain the Ethereum concept: Consensus via Proof of Work", "output": "(((\"consensus\",\"via proof of work\")))(((\"proof of work (PoW)\",\"consensus via\")))The creator of the original blockchain, Bitcoin, invented a _consensus algorithm_ called _proof of work_ (PoW). Arguably, PoW is the most important invention underpinning Bitcoin. The colloquial term for PoW is \"mining,\" which creates a misunderstanding about the primary purpose of consensus. Often people assume that the purpose of mining is the creation of new currency, since the purpose of real-world mining is the extraction of precious metals or other resources. Rather, the real purpose of mining (and all other consensus models) is to _secure the blockchain_, while keeping control over the system decentralized and diffused across as many participants as possible. The reward of newly minted currency is an incentive to those who contribute to the security of the system: a means to an end. In that sense, the reward is the means and decentralized security is the end. In PoW consensus there is also a corresponding \"punishment,\" which is the cost of energy required to participate in mining. If participants do not follow the rules and earn the reward, they risk the funds they have already spent on electricity to mine. Thus, PoW consensus is a careful balance of risk and reward that drives participants to behave honestly out of self-interest.\n\nEthereum is currently a PoW blockchain, in that it uses a PoW algorithm with the same basic incentive system for the same basic goal: securing the blockchain while decentralizing control. Ethereum's PoW algorithm is slightly different than Bitcoin's and is called _Ethash_. We will examine the function and design characteristics of the algorithm in <<ethash>>.\n\nEthereum also considers switching to _ProgPOW_, a more ASIC-resistant PoW algorithm, which is still under development at the time of writing.", "metadata": {"source": "ethereumbook", "chapter": "14consensus.asciidoc", "section": "Consensus via Proof of Work"}}
{"input": "Explain the Ethereum concept: Consensus via Proof of Stake (PoS)", "output": "(((\"consensus\",\"via proof of stake\")))(((\"proof of stake (PoS)\",\"consensus via\")))Historically, proof of work was not the first consensus algorithm proposed. Preceding the introduction of proof of work, many researchers had proposed variations of consensus algorithms based on financial stake, now called _proof of stake_ (PoS). In some respects, proof of work was invented as an alternative to proof of stake. Following the success of Bitcoin, many blockchains have emulated proof of work. Yet the explosion of research into consensus algorithms has also resurrected proof of stake, significantly advancing the state of the technology. From the beginning, Ethereum's founders were hoping to eventually migrate its consensus algorithm to proof of stake. In fact, there is a deliberate handicap on Ethereum's proof of work called the _difficulty bomb_, intended to gradually make proof-of-work mining of Ethereum more and more difficult, thereby forcing the transition to proof of stake.\n\nAt the time of publication of this book, Ethereum is still using proof of work, but the ongoing research toward a proof-of-stake alternative is nearing completion. Ethereum's planned PoS algorithm is called _Casper_. The introduction of Casper as a replacement for Ethash has been postponed several times over the past two years, necessitating interventions to defuse the difficulty bomb and postpone its forced obsolescence of proof of work.\n\nIn general, a PoS algorithm works as follows. The blockchain keeps track of a set of validators, and anyone who holds the blockchain's base cryptocurrency (in Ethereum's case, ether) can become a validator by sending a special type of transaction that locks up their ether into a deposit. The validators take turns proposing and voting on the next valid block, and the weight of each validator's vote depends on the size of its deposit (i.e., stake). Importantly, a validator risks losing their deposit, i.e., \"being slashed\", if the block they staked it on is rejected by the majority of validators. Conversely, validators earn a small reward, proportional to their deposited stake, for every block that is accepted by the majority. Thus, PoS forces validators to act honestly and follow the consensus rules, by a system of reward and punishment. The major difference between PoS and PoW is that the punishment in PoS is intrinsic to the blockchain (e.g., loss of staked ether), whereas in PoW the punishment is extrinsic (e.g., loss of funds spent on pass:[<span class=\"keep-together\">electricity</span>]).\n\n[[ethash]]", "metadata": {"source": "ethereumbook", "chapter": "14consensus.asciidoc", "section": "Consensus via Proof of Stake (PoS)"}}
{"input": "Explain the Ethereum concept: Ethash: Ethereum's Proof-of-Work Algorithm", "output": "(((\"Buterin, Vitalik\",\"and Dagger algorithm\")))(((\"consensus\",\"Ethash as Ethereum PoW algorithm\")))(((\"Dagger-Hashimoto algorithm\")))(((\"Ethash\")))(((\"proof of work (PoW)\",\"Ethash as Ethereum PoW algorithm\")))Ethash is the Ethereum PoW algorithm. It uses an evolution of the Dagger\u2013Hashimoto algorithm, which is a combination of Vitalik Buterin's Dagger algorithm and Thaddeus Dryja's Hashimoto algorithm. (((\"DAG (directed acyclic graph)\")))(((\"directed acyclic graph (DAG)\")))Ethash is dependent on the generation and analysis of a large dataset, known as a _directed acyclic graph_ (or, more simply, &#x201c;the DAG&#x201d;). The DAG had an initial size of about 1 GB and will continue to slowly and linearly grow in size, being updated once every epoch (30,000 blocks, or roughly 125 hours).\n\nThe purpose of the DAG is to make the Ethash PoW algorithm dependent on maintaining a large, frequently accessed data structure. (((\"application-specific integrated circuits (ASIC)\")))(((\"ASIC (application-specific integrated circuits)\")))(((\"graphics processing unit (GPU), mining and\")))This in turn is intended to make Ethash \"ASIC resistant,\" which means that it is more difficult to make _application-specific integrated circuits_ (ASIC) mining equipment that is orders of magnitude faster than a fast _graphics processing unit_ (GPU). Ethereum's founders wanted to avoid centralization in PoW mining, where those with access to specialized silicon fabrication factories and big budgets could dominate the mining infrastructure and undermine the security of the consensus algorithm.\n\nUse of consumer-level GPUs for carrying out the PoW on the Ethereum network means that more people around the world can participate in the mining process. The more independent miners there are the more decentralized the mining power is, which means we can avoid a situation like in Bitcoin, where much of the mining power is concentrated in the hands of a few large industrial mining operations. The downside of the use of GPUs for mining is that it precipitated a worldwide shortage GPUs in 2017, causing their price to skyrocket and an outcry from gamers. This led to purchase restrictions at retailers, limiting buyers to one or two GPUs per customer.\n\nUntil recently, the threat of ASIC miners on the Ethereum network was largely nonexistent. Using ASICs for Ethereum requires the design, manufacture, and distribution of highly customized hardware. Producing them requires considerable investment of time and money. The Ethereum developers' long-expressed plans to move to a PoS consensus algorithm likely kept ASIC suppliers away from targeting the Ethereum network for a long time. As soon as Ethereum moves to PoS, ASICs designed for the PoW algorithm will be rendered useless\u2014that is, unless miners can use them to mine other cryptocurrencies instead. The latter possibility is now a reality with a range of other Ethash-based consensus coins available, such as PIRL and Ubiq, and Ethereum Classic has pledged to remain a PoW blockchain for the foreseeable future. This means that we will likely see ASIC mining begin to become a force on the Ethereum network while is it still operating on PoW consensus.", "metadata": {"source": "ethereumbook", "chapter": "14consensus.asciidoc", "section": "Ethash: Ethereum's Proof-of-Work Algorithm"}}
{"input": "Explain the Ethereum concept: Casper: Ethereum's Proof-of-Stake Algorithm", "output": "(((\"Casper\")))(((\"consensus\",\"Casper as Ethereum PoS algorithm\")))(((\"proof of stake (PoS)\",\"Casper as Ethereum PoS algorithm\")))Casper is the proposed name for Ethereum's PoS consensus algorithm. It is still under active research and development and is not implemented on the Ethereum blockchain at the time of publication of this book. (((\"Casper CBC\")))(((\"Casper FFG\")))Casper is being developed in two competing \"flavors\":\n\n* Casper FFG: \"The Friendly Finality Gadget\"\n* Casper CBC: \"The Friendly GHOST/Correct-by-Construction\"\n\nInitially, Casper FFG was proposed as a hybrid PoW/PoS algorithm to be implemented as a transition to a more permanent \"pure PoS\" algorithm. (((\"Buterin, Vitalik\",\"and Casper\")))But in June 2018, Vitalik Buterin, who was leading the research work on Casper FFG, decided to \"scrap\" the hybrid model in favor of a pure PoS algorithm. Now, Casper FFG and Casper CBC are both being developed in parallel. As Vitalik explains:\n\n____\nThe main tradeoff between FFG and CBC is that CBC seems to have nicer theoretical properties, but FFG seems to be easier to implement.\n____\n\nMore information about Casper's history, ongoing research and future plans can be found at the following links:\n\n* http://bit.ly/2RO5HAl[Ethereum Casper (Proof of Stake)]\n* http://bit.ly/2FlBojb[History of Casper, Part 1]\n* http://bit.ly/2QyHiic[History of Casper, Part 2]\n* http://bit.ly/2JWWFyt[History of Casper, Part 3]\n* http://bit.ly/2FsaExI[History of Casper, Part 4]\n* http://bit.ly/2PPhhOv[History of Casper, Part 5]", "metadata": {"source": "ethereumbook", "chapter": "14consensus.asciidoc", "section": "Casper: Ethereum's Proof-of-Stake Algorithm"}}
{"input": "Explain the Ethereum concept: Principles of Consensus", "output": "(((\"consensus\",\"principles of\")))The principles and assumptions of consensus algorithms can be more clearly understood by asking a few key questions:\n\n* Who can change the past, and how? (This is also known as _immutability_.)\n* Who can change the future, and how? (This is also known as _finality_.)\n* What is the cost to make such changes?\n* How decentralized is the power to make such changes?\n* Who will know if something has changed, and how will they know?\n\nConsensus algorithms are evolving rapidly, attempting to answer these questions in increasingly innovative ways.", "metadata": {"source": "ethereumbook", "chapter": "14consensus.asciidoc", "section": "Principles of Consensus"}}
{"input": "Explain the Ethereum concept: Controversy and Competition", "output": "(((\"consensus\",\"controversy and competition\")))At this point you might be wondering: Why do we need so many different consensus algorithms? Which one works better? The answer to the latter question is at the center of the most exciting area of research in distributed systems of the past decade. It all boils down to what you consider \"better&#x201d;&#x2014;which in the context of computer science is about assumptions, goals, and the unavoidable trade-offs.\n\nIt is likely that no  algorithm can optimize across all dimensions of the problem of decentralized consensus. When someone suggests that one consensus algorithm is \"better\" than the others, you should start asking questions that clarify: Better at what? Immutability, finality, decentralization, cost? There is no clear answer to these questions, at least not yet. Furthermore, the design of consensus algorithms is at the center of a multi-billion-dollar industry and generates enormous controversy and heated arguments. In the end, there might not be a \"correct\" answer, just as there might be different answers for different applications.\n\nThe entire blockchain industry is one giant experiment where these questions will be tested under adversarial conditions, with enormous monetary value at stake. In the end, history will answer the controversy.", "metadata": {"source": "ethereumbook", "chapter": "14consensus.asciidoc", "section": "Controversy and Competition"}}
{"input": "Explain the Ethereum concept: Conclusions", "output": "Ethereum's consensus algorithm is still in flux at the time of completion of this book. In a future edition, we will likely add more detail about Casper and other related technologies as these mature and are deployed on Ethereum. This chapter represents the end of our journey, completing _Mastering Ethereum_. Additional reference material follows in the appendixes. Thank you for reading this book, and congratulations on reaching the end!(((range=\"endofrange\", startref=\"ix_14consensus-asciidoc0\")))", "metadata": {"source": "ethereumbook", "chapter": "14consensus.asciidoc", "section": "Conclusions"}}
{"input": "Explain the Ethereum concept: Quick Glossary", "output": "This quick glossary contains many of the terms used in relation to Ethereum. These terms are used throughout the book, so bookmark this for quick reference.\n\nAccount::\n(((\"account\",\"defined\")))An object containing an address, balance, nonce, and optional storage and code. An account can be a contract account or an externally owned account (EOA).\n\nAddress::\n(((\"addresses\",\"defined\")))Most generally, this represents an EOA or contract that can receive (destination address) or send (source address) transactions on the blockchain. More specifically, it is the rightmost 160 bits of a Keccak hash of an ECDSA public key.\n\nAssert::\n(((\"assert function\",\"defined\")))In Solidity, +assert(false)+ compiles to +0xfe+, an invalid opcode, which uses up all remaining gas and reverts all changes. When an +assert()+ statement fails, something very wrong and unexpected is happening, and you will need to fix your code. You should use +assert()+ to avoid conditions that should never, ever occur.\n\nBig-endian::\n(((\"big-endian, defined\")))A positional number representation where the most significant digit is first. The opposite of little-endian, where the least significant digit is first.\n\nBIPs::\n(((\"Bitcoin improvement proposals (BIPs)\")))Bitcoin Improvement Proposals.  A set of proposals that members of the Bitcoin community have submitted to improve Bitcoin. For example, BIP-21 is a proposal to improve the Bitcoin uniform resource identifier (URI) scheme.\n\nBlock::\n(((\"block, defined\")))A collection of required information (a block header) about the comprised transactions, and a set of other block headers known as ommers. Blocks are added to the Ethereum network by miners.\n\nBlockchain::\n(((\"blockchain\",\"defined\")))In Ethereum, a sequence of blocks validated by the proof-of-work system, each linking to its predecessor all the way to the genesis block. This varies from the Bitcoin protocol in that it does not have a block size limit; it instead uses varying gas limits.\n\nBytecode::\n(((\"bytecode\", seealso=\"EVM bytecode\")))An abstract instruction set designed for efficient execution by a software interpreter or a virtual machine. Unlike human-readable source code, bytecode is expressed in numeric format.\n\nByzantium fork::\n(((\"Byzantium fork\")))The first of two hard forks for the Metropolis development stage. It included EIP-649: Metropolis Difficulty Bomb Delay and Block Reward Reduction, where the Ice Age (see below) was delayed by 1 year and the block reward was reduced from 5 to 3 ether.\n\nCompiling::\n(((\"compiling\",\"defined\")))Converting code written in a high-level programming language (e.g., Solidity) into a lower-level language (e.g., EVM bytecode).\n\nConsensus::\n(((\"consensus\",\"defined\")))When numerous nodes&#x2014;usually most nodes on the network&#x2014;all have the same blocks in their locally validated best blockchain. Not to be confused with consensus rules.\n\nConsensus rules::\n(((\"consensus rules\")))The block validation rules that full nodes follow to stay in consensus with other nodes. Not to be confused with consensus.\n\nConstantinople fork::\n(((\"Constantinople fork\")))The second part of the Metropolis stage, originally planned for mid-2018. Expected to include a switch to a hybrid proof-of-work/proof-of-stake consensus algorithm, among other changes.\n\nContract account::\n(((\"contract accounts\",\"defined\")))(((\"smart contracts\",\"defined\")))An account containing code that executes whenever it receives a transaction from another account (EOA or contract).\n\nContract creation transaction::\n(((\"contract creation transaction\")))A special transaction, with the \"zero address\" as the recipient, that is used to register a contract and record it on the Ethereum blockchain (see \"zero address\").\n\nDAO::\n(((\"DAO (Decentralized Autonomous Organization)\",\"defined\")))Decentralized Autonomous Organization. A company or other organization that operates without hierarchical management. Also may refer to a contract named \"The DAO\" launched on April 30, 2016, which was then hacked in June 2016; this ultimately motivated a hard fork (codenamed DAO) at block #1,192,000, which reversed the hacked DAO contract and caused Ethereum and Ethereum Classic to split into two competing systems.\n\nDApp::\n(((\"DApps (decentralized applications)\",\"defined\")))Decentralized application. At a minimum, it is a smart contract and a web user interface. More broadly, a DApp is a web application that is built on top of open, decentralized, peer-to-peer infrastructure services. In addition, many DApps include decentralized storage and/or a message protocol and platform.\n\nDeed::\n(((\"deed\",\"defined\")))Non-fungible token (NFT) standard introduced by the ERC721 proposal. Unlike ERC20 tokens, deeds prove ownership and are not interchangeable, though they are not recognized as legal documents in any jurisdiction\u2014at least not currently (see also \"NFT\").\n\nDifficulty::\n(((\"difficulty setting\")))A network-wide setting that controls how much computation is required to produce a proof of work.\n\nDigital signature::\n(((\"digital signatures\",\"defined\")))A short string of data a user produces for a document using a private key such that anyone with the corresponding public key, the signature, and the document can verify that (1) the document was \"signed\" by the owner of that particular private key, and (2) the document was not changed after it was signed.\n\nECDSA::\n(((\"Elliptic Curve Digital Signature Algorithm (ECDSA)\",\"defined\")))Elliptic Curve Digital Signature Algorithm. A cryptographic algorithm used by Ethereum to ensure that funds can only be spent by their owners.\n\nEIP::\n(((\"EIPs (Ethereum Improvement Proposals)\",\"defined\")))Ethereum Improvement Proposal. A design document providing information to the Ethereum community, describing a proposed new feature or its processes or environment. For more information, see https://github.com/ethereum/EIPs (see also \"ERC\").\n\nENS::\n(((\"ENS (Ethereum Name Service)\")))Ethereum Name Service. For more information, see https://github.com/ethereum/ens/.\n\nEntropy::\n(((\"entropy\",\"defined\")))In the context of cryptography, lack of predictability or level of randomness. When generating secret information, such as private keys, algorithms usually rely on a source of high entropy to ensure the output is unpredictable.\n\nEOA::\n(((\"EOA (Externally Owned Account)\",\"defined\")))Externally Owned Account. An account created by or for human users of the Ethereum network.\n\nERC::\n(((\"ERC (Ethereum Request for Comments)\", seealso=\"EIPs (Ethereum Improvement Proposals)\")))Ethereum Request for Comments. A label given to some EIPs that attempt to define a specific standard of Ethereum usage.\n\nEthash::\n(((\"Ethash\")))A proof-of-work algorithm for Ethereum 1.0. For more information, see https://github.com/ethereum/wiki/wiki/Ethash.\n\nEther::\n(((\"Ether (cryptocurrency)\")))The native cryptocurrency used by the Ethereum ecosystem, which covers gas costs when executing smart contracts. Its symbol is \u039e, the Greek uppercase Xi character.\n\nEvent::\n(((\"events\",\"defined\")))Allows the use of EVM logging facilities. DApps can listen for events and use them to trigger JavaScript callbacks in the user interface. For more information, see http://solidity.readthedocs.io/en/develop/contracts.html#events.\n\nEVM::\n(((\"EVM (Ethereum Virtual Machine)\",\"defined\")))Ethereum Virtual Machine. A stack-based virtual machine that executes bytecode. In Ethereum, the execution model specifies how the system state is altered given a series of bytecode instructions and a small tuple of environmental data. This is specified through a formal model of a virtual state machine.\n\nEVM assembly language::\n(((\"EVM assembly language\")))A human-readable form of EVM bytecode.\n\nFallback function::\n(((\"fallback function\")))A default function called in the absence of data or a declared function name.\n\nFaucet::\n(((\"faucet, defined\")))A service that dispenses funds in the form of free test ether that can be used on a testnet.\n\nFinney::\n(((\"finney\")))A denomination of ether. 1 finney = 10^15^ wei, 10^3^ finney = 1 ether.\n\nFork::\n(((\"forks\")))A change in protocol causing the creation of an alternative chain, or a temporal divergence in two potential block paths during mining.\n\n\nFrontier::\n(((\"Frontier\")))The initial test development stage of Ethereum, which lasted from July 2015 to March 2016.\n\nGanache::\n(((\"Ganache\",\"defined\")))A personal Ethereum blockchain that you can use to run tests, execute commands, and inspect state while controlling how the chain operates.\n\nGas::\n(((\"gas\",\"defined\")))A virtual fuel used in Ethereum to execute smart contracts. The EVM uses an accounting mechanism to measure the consumption of gas and limit the consumption of computing resources (see \"Turing complete\").\n\nGas limit::\n(((\"gas limit\")))The maximum amount of gas a transaction or block may consume.\n\nGavin Wood::\n(((\"Wood, Dr. Gavin\")))A British programmer who is the cofounder and former CTO of Ethereum. In August 2014 he proposed Solidity, a contract-oriented programming language for writing smart contracts.\n\nGenesis block::\n(((\"genesis block\")))The first block in a blockchain, used to initialize a particular network and its cryptocurrency.\n\nGeth::\n(((\"Geth (Go-Ethereum)\",\"defined\")))Go Ethereum. One of the most prominent implementations of the Ethereum protocol, written in Go.\n\nHard fork::\n(((\"hard forks\")))A permanent divergence in the blockchain; also known as a hard-forking change. One commonly occurs when nonupgraded nodes can't validate blocks created by upgraded nodes that follow newer consensus rules. Not to be confused with a fork, soft fork, software fork, or Git fork.\n\nHash::\n(((\"hash, defined\")))A fixed-length fingerprint of variable-size input, produced by a hash function.\n\nHD wallet::\n(((\"hierarchical deterministic wallets (BIP-32/BIP-44)\",\"defined\")))A wallet using the hierarchical deterministic (HD) key creation and transfer protocol (BIP-32).\n\nHD wallet seed::\n(((\"HD wallet seed\")))(((\"seeds\", seealso=\"root seeds\")))A value used to generate the master private key and master chain code for an HD wallet. The wallet seed can be represented by mnemonic words, making it easier for humans to copy, back up, and restore private keys.\n\nHomestead::\n(((\"Homestead\")))The second development stage of Ethereum, launched in March 2016 at block #1,150,000.\n\nICAP::\n(((\"ICAP (Inter-exchange Client Address Protocol)\")))(((\"Inter-exchange Client Address Protocol (ICAP)\")))Inter-exchange Client Address Protocol. An Ethereum address encoding that is partly compatible with the International Bank Account Number (IBAN) encoding, offering a versatile, checksummed, and interoperable encoding for Ethereum addresses. ICAP addresses use a new IBAN pseudo-country code: XE, standing for \"eXtended Ethereum,\" as used in nonjurisdictional currencies (e.g., XBT, XRP, XCP).\n\nIce Age::\n(((\"Ice Age\")))A hard fork of Ethereum at block #200,000 to introduce an exponential difficulty increase (aka Difficulty Bomb), motivating a transition to proof of stake.\n\nIDE::\n(((\"IDE (Integrated Development Environment)\")))(((\"Integrated Development Environment (IDE)\")))Integrated Development Environment. A user interface that typically combines a code editor, compiler, runtime, and debugger.\n\nImmutable deployed code problem::\n(((\"immutable deployed code problem\")))Once a contract's (or library's) code is deployed, it becomes immutable. Standard software development practices rely on being able to fix possible bugs and add new features, so this represents a challenge for smart contract development.\n\nInternal transaction (also \"message\")::\n(((\"internal transaction (message)\")))A transaction sent from a contract account to another contract account or an EOA.\n\nIPFS::\n(((\"IPFS (InterPlanetary File System)\")))InterPlanetary File System. A protocol, network, and open source project designed to create a content-addressable, peer-to-peer method of storing and sharing hypermedia in a distributed filesystem.\n\nKDF::\n(((\"key derivation function (KDF)\")))Key Derivation Function. Also known as a \"password stretching algorithm,\" it is used by keystore formats to protect against brute-force, dictionary, and rainbow table attacks on passphrase encryption, by repeatedly hashing the passphrase.\n\nKeccak-256::\n(((\"Keccak-256 hash function\")))Cryptographic hash function used in Ethereum. Keccak-256 was standardized as SHA-3.\n\nKeystore file::\n(((\"keystore file\")))A JSON-encoded file that contains a single (randomly generated) private key, encrypted by a passphrase for extra security.\n\nLevelDB::\n(((\"LevelDB\")))An open source on-disk key&#x2013;value store, implemented as a lightweight, single-purpose library, with bindings to many platforms.\n\nLibrary::\n(((\"library contract\")))A special type of contract that has no payable functions, no fallback function, and no data storage. Therefore, it cannot receive or hold ether, or store data. A library serves as previously deployed code that other contracts can call for read-only computation.\n\nLightweight client::\n(((\"light/lightweight client\")))An Ethereum client that does not store a local copy of the blockchain, or validate blocks and transactions. It offers the functions of a wallet and can create and broadcast transactions.\n\nMerkle Patricia Tree::\n(((\"Merkle Patricia Tree\")))A data structure used in Ethereum to efficiently store key&#x2013;value pairs.\n\nMessage::\n(((\"message, defined\")))An internal transaction that is never serialized and only sent within the EVM.\n\nMessage call::\n(((\"message call\")))The act of passing a message from one account to another. If the destination account is associated with EVM code, then the VM will be started with the state of that object and the message acted\nupon.\n\nMEToken::\n(((\"METoken (Mastering Ethereum Token)\",\"defined\")))Mastering Ethereum Token. An ERC20 token used for demonstration in this book.\n\nMetropolis::\n(((\"Metropolis\")))The third development stage of Ethereum, launched in October 2017.\n\n\nMiner::\n(((\"miners\")))A network node that finds valid proof of work for new blocks, by repeated pass:[<span class=\"keep-together\">hashing</span>].\n\nMist::\n(((\"Mist (browser-based wallet)\")))(((\"wallets\",\"Mist\")))The first Ethereum-enabled browser, built by the Ethereum Foundation. It contains a browser-based wallet that was the first implementation of the ERC20 token standard (Fabian Vogelsteller, author of ERC20, was also the main developer of Mist). Mist was also the first wallet to introduce the camelCase checksum (EIP-55; see <<EIP55>>). Mist runs a full node and offers a full DApp browser with support for Swarm-based storage and ENS addresses.\n\nNetwork::\n(((\"networks (Ethereum)\",\"defined\")))(((\"networks (Ethereum)\",\"MetaMask and\")))Referring to the Ethereum network, a peer-to-peer network that propagates transactions and blocks to every Ethereum node (network participant).\n\nNFT::\n(((\"nonfungible tokens (NFTs)\",\"defined\")))A non-fungible token (also known as a \"deed\"). This is a token standard introduced by the ERC721 proposal. NFTs can be tracked and traded, but each token is unique and distinct; they are not interchangeable like ERC20 tokens. NFTs can represent ownership of digital or physical assets.\n\nNode::\n(((\"node\",\"defined\")))A software client that participates in the network.\n\nNonce::\n(((\"nonces\",\"defined\")))In cryptography, a value that can only be used once. There are two types of nonce used in Ethereum: an account nonce is a transaction counter in each account, which is used to prevent replay attacks; a proof-of-work nonce is the random value in a block that was used to satisfy the proof of work.\n\nOmmer::\n(((\"ommer, defined\")))A child block of an ancestor that is not itself an ancestor. When a miner finds a valid block, another miner may have published a competing block which is added to the tip of the blockchain. Unlike with Bitcoin, orphaned blocks in Ethereum can be included by newer blocks as ommers and receive a partial block reward. The term \"ommer\" is the preferred gender-neutral term for the sibling of a parent block, but this is also sometimes referred to as an \"uncle.\"\n\nParity::\n(((\"Parity\",\"defined\")))One of the most prominent interoperable implementations of the Ethereum client software.\n\nPrivate key::\nSee &#x201c;secret key.&#x201d;\n\nProof of stake (PoS)::\n(((\"proof of stake (PoS)\",\"defined\")))A method by which a cryptocurrency blockchain protocol aims to achieve distributed consensus. PoS asks users to prove ownership of a certain amount of cryptocurrency (their \"stake\" in the network) in order to be able to participate in the validation of transactions.\n\nProof of work (PoW)::\n(((\"proof of work (PoW)\",\"defined\")))A piece of data (the proof) that requires significant computation to find. In Ethereum, miners must find a numeric solution to the Ethash algorithm that meets a network-wide difficulty target.\n\nPublic key::\n(((\"public keys\",\"defined\")))A number, derived via a one-way function from a private key, which can be shared publicly and used by anyone to verify a digital signature made with the corresponding private key.\n\nReceipt::\n(((\"receipt, defined\")))Data returned by an Ethereum client to represent the result of a particular transaction, including a hash of the transaction, its block number, the amount of gas used, and, in case of deployment of a smart contract, the address of the contract.\n\nRe-entrancy attack::\n(((\"reentrancy attacks\",\"defined\")))An attack that consists of an attacker contract calling a victim contract function in such a way that during execution the victim calls the attacker contract again, recursively. This can result, for example, in the theft of funds by skipping parts of the victim contract that update balances or count withdrawal amounts.\n\nReward::\n(((\"reward, defined\")))An amount of ether included in each new block as a reward by the network to the miner who found the proof-of-work solution.\n\nRLP::\n(((\"Recursive Length Prefix (RLP)\")))(((\"RLP (Recursive Length Prefix)\")))Recursive Length Prefix. An encoding standard designed by the Ethereum developers to encode and serialize objects (data structures) of arbitrary complexity and length.\n\nSatoshi Nakamoto::\n(((\"Satoshi Nakamoto\")))The name used by the person or people who designed Bitcoin, created its original reference implementation, and were the first to solve the double-spend problem for digital currency. Their real identity remains unknown.\n\nSecret key (aka private key)::\n(((\"private keys\",\"defined\")))(((\"secret keys\", seealso=\"private keys\")))The secret number that allows Ethereum users to prove ownership of an account or contracts, by producing a digital signature (see &#x201c;public key,&#x201d; &#x201c;address,&#x201d; &#x201c;ECDSA&#x201d;).\n\nSerenity::\n(((\"Serenity\")))The fourth and final development stage of Ethereum. Serenity does not yet have a planned release date.\n\nSerpent::\n(((\"Serpent\")))A procedural (imperative) smart contract programming language with syntax similar to Python.\n\nSHA::\n(((\"SHA (Secure Hash Algorithm)\")))Secure Hash Algorithm. A family of cryptographic hash functions published by the National Institute of Standards and Technology (NIST).\n\nSingleton::\n(((\"singleton\")))A computer programming term that describes an object of which only a single instance can exist.\n\nSmart contract::\n(((\"smart contracts\",\"defined\")))A program that executes on the Ethereum computing infrastructure.\n\nSolidity::\n(((\"Solidity\",\"defined\")))A procedural (imperative) programming language with syntax that is similar to JavaScript, C++, or Java. The most popular and most frequently used language for Ethereum smart contracts. Created by Dr. Gavin Wood (coauthor of this book).\n\nSolidity inline assembly::\n(((\"inline assembly\",\"defined\")))(((\"Solidity inline assembly\")))EVM assembly language in a Solidity program. Solidity's support for inline assembly makes it easier to write certain operations.\n\nSpurious Dragon::\n(((\"Spurious Dragon\")))A hard fork of the Ethereum blockchain, which occurred at block #2,675,000 to address more denial-of-service attack vectors and clear state (see also \"Tangerine Whistle\"). Also, a replay attack protection mechanism.\n\nSwarm::\n(((\"Swarm\",\"defined\")))A decentralized (P2P) storage network, used along with Web3 and Whisper to build DApps.\n\nSzabo::\n(((\"szabo, defined\")))A denomination of ether. 1 szabo = 10^12^ wei, 10^6^ szabo = 1 ether.\n\nTangerine Whistle::\n(((\"Tangerine Whistle\")))A hard fork of the Ethereum blockchain, which occurred at block #2,463,000 to change the gas calculation for certain I/O-intensive operations and to clear the accumulated state from a denial-of-service attack, which exploited the low gas cost of those operations.\n\nTestnet::\n(((\"testnet\",\"defined\")))Short for \"test network,\" a network used to simulate the behavior of the main Ethereum network.\n\nTransaction::\n(((\"transactions\",\"defined\")))Data committed to the Ethereum Blockchain signed by an originating account, targeting a specific address. The transaction contains metadata such as the gas limit for that transaction.\n\nTruffle::\n(((\"Truffle\",\"defined\")))One of the most commonly used Ethereum development frameworks.\n\nTuring complete::\n(((\"Turing completeness\",\"defined\")))A concept named after English mathematician and computer scientist Alan Turing: a system of data-manipulation rules (such as a computer's instruction set, a programming language, or a cellular automaton) is said to be \"Turing complete\" or \"computationally universal\" if it can be used to simulate any Turing machine.\n\nVitalik Buterin::\n(((\"Buterin, Vitalik\")))A Russian\u2013Canadian programmer and writer primarily known as the cofounder of Ethereum and of _Bitcoin Magazine_.\n\nVyper::\n(((\"Vyper\",\"defined\")))A high-level programming language, similar to Serpent, with Python-like syntax. Intended to get closer to a pure functional language. Created by Vitalik Buterin.\n\nWallet::\n(((\"wallets\",\"defined\")))Software that holds secret keys. Used to access and control Ethereum accounts and interact with smart contracts. Keys need not be stored in a wallet, and can instead be retrieved from offline storage (e.g., a memory card or paper) for improved security. Despite the name, wallets never store the actual coins or tokens.\n\nWeb3::\n(((\"web3\", seealso=\"DApps\")))The third version of the web. First proposed by Dr. Gavin Wood, Web3 represents a new vision and focus for web applications: from centrally owned and managed applications, to applications built on decentralized protocols.\n\nWei::\n(((\"wei, defined\")))The smallest denomination of ether. 10^18^ wei = 1 ether.\n\nWhisper::\n(((\"Whisper\")))A decentralized (P2P) messaging service. It is used along with Web3 and Swarm to build DApps.\n\nZero address::\n(((\"zero address\",\"defined\")))A special Ethereum address, composed entirely of zeros, that is specified as the destination address of a contract creation transaction.", "metadata": {"source": "ethereumbook", "chapter": "glossary.asciidoc", "section": "Quick Glossary"}}
{"input": "Explain the Ethereum concept: Ethereum Standards", "output": "[[eips]]", "metadata": {"source": "ethereumbook", "chapter": "appdx-standards-eip-erc.asciidoc", "section": "Ethereum Standards"}}
{"input": "Explain the Ethereum concept: Ethereum Improvement Proposals (EIPs)", "output": "(((\"EIPs (Ethereum Improvement Proposals)\")))(((\"Ethereum (generally)\",\"EIPs\")))(((\"Ethereum (generally)\",\"standards\")))The Ethereum Improvement Proposal repository is located at https://github.com/ethereum/EIPs/[]. (((\"EIPs (Ethereum Improvement Proposals)\",\"workflow\")))The workflow is illustrated in <<eip_workflow>>.\n\nFrom https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1.md[EIP-1]:\n\n____\nEIP stands for Ethereum Improvement Proposal. An EIP is a design document providing information to the Ethereum community, or describing a new feature for Ethereum or its processes or environment. The EIP should provide a concise technical specification of the feature and a rationale for the feature. The EIP author is responsible for building consensus within the community and documenting dissenting opinions.\n____\n\n[[eip_workflow]]\n.Ethereum Improvement Proposal workflow\nimage::images/eip_workflow.png[\"Ethereum Improvement Proposal Workflow\"]\n\n[[eip_table]]", "metadata": {"source": "ethereumbook", "chapter": "appdx-standards-eip-erc.asciidoc", "section": "Ethereum Improvement Proposals (EIPs)"}}
{"input": "Explain the Ethereum concept: Table of Most Important EIPs and ERCs", "output": ".Important EIPs and ERCs\n[options=\"header\"]\n|===\n| EIP/ERC # | Title/Description | Author | Layer | Status | Created\n| http://bit.ly/2OVq6qa[EIP-1]                                 | EIP Purpose and Guidelines                                                                  | Martin Becze, Hudson Jameson               | Meta       | Final    |\n| http://bit.ly/2yJtTNa[EIP-2]                                 | Homestead Hard-fork Changes                                                                  | Vitalik Buterin                            | Core       | Final    |\n\n| http://bit.ly/2Jrx93V[EIP-5]                                 | Gas Usage for `RETURN` and `CALL*`                                                                  | Christian Reitwiessner           | Core       | Draft    |\n| http://bit.ly/2OYbc2t[EIP-6]                                 | Renaming +SUICIDE+ Opcode                                                                      | Hudson Jameson                             | Interface  | Final    |\n| http://bit.ly/2JxdBeN[EIP-7]                                 | `DELEGATECALL`                                                                                 | Vitalik Buterin                            | Core       | Final    |\n| http://bit.ly/2Q6Oly6[EIP-8]                                 | devp2p Forward Compatibility Requirements for Homestead                                      | Felix Lange                                | Networking | Final    |\n| http://bit.ly/2CUf7WG[EIP-20]                | ERC-20 Token Standard. Describes standard functions a token contract may implement to allow DApps and wallets to handle tokens across multiple interfaces/DApps. Methods include: `totalSupply`, +balanceOf(address)+, `transfer`, `transferFrom`, `approve`, `allowance`. Events include: `Transfer` (triggered when tokens are transferred), pass:[<span class=\"keep-together\"><code>Approval</code></span>] (triggered when `approve` is called).                                                                       | Fabian Vogelsteller, Vitalik Buterin       | ERC        | Final    | Frontier\n| http://bit.ly/2Q6R4YB[EIP-55]                               | Mixed-case checksum address encoding                                                  | Vitalik Buterin                            | ERC        | Final    |\n| http://bit.ly/2OgE5la[EIP-86]                | Abstraction of transaction origin and signature. Sets the stage for \"abstracting out\" account security and allowing users to create \"account contracts,\" moving toward a model where in the long term all accounts are contracts that can pay for gas, and users are free to define their own security models that perform any desired signature verification and nonce checks (instead of using the in-protocol mechanism where ECDSA and the default nonce scheme are the only \"standard\" way to secure an account, which is currently hardcoded into transaction processing).                                                                      | Vitalik Buterin       | Core        | Deferred (to be replaced)    | Constantinople\n| http://bit.ly/2QedSFC[EIP-96]                | Blockhash and state root changes. Stores blockhashes in the state to reduce protocol complexity and need for complex client implementations to process the `BLOCKHASH` opcode. Extends range of how far back blockhash checking may go, with the side effect of creating direct links between blocks with very distant block numbers to facilitate much more efficient initial light client syncing.                                                                       | Vitalik Buterin       | Core        |  Deferred   | Constantinople\n| http://bit.ly/2AC05DM[EIP-100] | Change difficulty adjustment to target mean block time and including uncles. | Vitalik Buterin                            | Core       | Final    | Metropolis Byzantinium\n| http://bit.ly/2Jr1zDv[EIP-101] | Serenity Currency and Crypto Abstraction. Abstracts ether up a level with the benefit of allowing ether and subtokens to be treated similarly by contracts, reduces the level of indirection required for custom-policy accounts such as multisigs, and purifies the underlying Ethereum protocol by reducing the minimal consensus implementation complexity. | Vitalik Buterin                            | Active       | Serenity feature    | Serenity Casper\n| http://bit.ly/2Q5sdEv[EIP-105] | Binary sharding plus contract calling semantics. \"Sharding scaffolding\" EIP to allow Ethereum transactions to be parallelized using a binary tree sharding mechanism, and to set the stage for a later sharding scheme. Research in progress; see https://github.com/ethereum/sharding[]. | Vitalik Buterin                            | Active       | Serenity feature    | Serenity Casper\n| http://bit.ly/2yG2Dzi[EIP-137] | Ethereum Domain Name Service - Specification                                                 | Nick Johnson                               | ERC        | Final    |\n| http://bit.ly/2yJtWZm[EIP-140]   | New Opcode: +REVERT+. Adds `REVERT` opcode instruction, which stops execution and rolls back the EVM execution state changes without consuming all provided gas (instead the contract only has to pay for memory) or losing logs, and returns to the caller a pointer to the memory location with the error code or message.                                                                           | Alex Beregszaszi, Nikolai Mushegian        | Core       | Final    | Metropolis Byzantinium\n| http://bit.ly/2CQMXfe[EIP-141]                             | Designated invalid EVM instruction                                                           | Alex Beregszaszi                           | Core       | Final    |\n| http://bit.ly/2qhKz9Y[EIP-145]                             | Bitwise shifting instructions in EVM                                                     | Alex Beregszaszi, Pawe\u0142 Bylica                            | Core       | Deferred    |\n| http://bit.ly/2qhxflQ[EIP-150]                             | Gas cost changes for IO-heavy operations                                                     | Vitalik Buterin                            | Core       | Final    |\n| http://bit.ly/2CQUgne[EIP-155]                             | Simple replay attack protection. Replay Attack allows any transaction using a pre-EIP-155 Ethereum node or client to become signed so it is valid and executed on both the Ethereum and Ethereum Classic chains.                                                               | Vitalik Buterin                            | Core       | Final    | Homestead\n| http://bit.ly/2JryBmT[EIP-158]                             | State clearing                                                               | Vitalik Buterin                            | Core       | Superseded    |\n| http://bit.ly/2CR6VGY[EIP-160]                             | EXP cost increase                                                                            | Vitalik Buterin                            | Core       | Final    |\n| http://bit.ly/2OfU96M[EIP-161]                           | State trie clearing (invariant-preserving alternative)                                      | Gavin Wood                                 | Core       | Final    |\n| http://bit.ly/2JxdKil[EIP-162]                             | Initial ENS Hash Registrar                             | Maurelian, Nick Johnson, Alex Van de Sande                    | ERC        | Final    |\n\n| http://bit.ly/2OgsOkO[EIP-165]                             | ERC-165 Standard Interface Detection                             | Christian Reitwiessner et al.                    | Interface        | Draft    |\n| http://bit.ly/2OgCWu1[EIP-170]                             | Contract code size limit                                                                     | Vitalik Buterin                            | Core       | Final    |\n| http://bit.ly/2ERNv7g[EIP-181]                             | ENS support for reverse resolution of Ethereum addresses                             | Nick Johnson                               | ERC        | Final    |\n| http://bit.ly/2P0wPz5[EIP-190]                             | Ethereum Smart Contract Packaging Standard                                           | Piper Merriam et al. | ERC        | Final    |\n| http://bit.ly/2SwNQiz[EIP-196]   | Precompiled contracts for addition and scalar multiplication on the elliptic curve +alt_bn128+. Required in order to perform zkSNARK verification within the block gas limit.\n| Christian Reitwiessner                     | Core       | Final    | Metropolis Byzantinium\n| http://bit.ly/2ETDC9a[EIP-197]   | Precompiled contracts for optimal ate pairing check on the elliptic curve +alt_bn128+. Combined with EIP-196.\n| Vitalik Buterin, Christian Reitwiessner    | Core       | Final    | Metropolis Byzantinium\n| http://bit.ly/2DdTCRN[EIP-198]   | Big integer modular exponentiation. Precompile enabling RSA signature verification and other cryptographic applications.\n| Vitalik Buterin                            | Core       | Final    | Metropolis Byzantinium\n| http://bit.ly/2qjYJr3[EIP-211]   | New opcodes: `RETURNDATASIZE` and `RETURNDATACOPY`. Adds support for returning variable-length values inside the EVM with simple gas charging and minimal change to calling opcodes using new opcodes `RETURNDATASIZE` and `RETURNDATACOPY`. Handles similar to existing `calldata`, whereby after a call, return data is kept inside a virtual buffer from which the caller can copy it (or parts thereof) into memory, and upon the next call, the buffer is overwritten.\n| Christian Reitwiessner                     | Core       | Final    | Metropolis Byzantinium\n| http://bit.ly/2OgV0Eb[EIP-214]   | New opcode: `STATICCALL`. Permits non-state-changing calls to itself or other contracts while disallowing any modifications to state during the call (and its subcalls, if present) to increase smart contract security and assure developers that re-entrancy bugs cannot arise from the call. Calls the child with `STATIC` flag set to `true` for execution of child, causing exception to be thrown upon any attempts to make state-changing operations inside an execution instance where `STATIC` is `true`, and resets flag once call returns.                                                                        | Vitalik Buterin, Christian Reitwiessner    | Core       | Final    | Metropolis Byzantinium\n| http://bit.ly/2JssHlJ[EIP-225]  | Rinkeby testnet using proof of authority where blocks are only mined by trusted signers.    | P\u00e9ter Szil\u00e1gyi    |        |     | Homestead\n| http://bit.ly/2yPBavd[EIP-234]  | Add `blockHash` to JSON-RPC filter options    |  Micah Zoltu  | Interface       | Draft    |\n\n| http://bit.ly/2yKrBNM[EIP-615]   | Subroutines and Static Jumps for the EVM | Greg Colvin, Pawe\u0142 Bylica, Christian Reitwiessner             | Core       | Draft    |\n\n| http://bit.ly/2AzGX99[EIP-616]   | SIMD Operations for the EVM | Greg Colvin             | Core       | Draft    |\n\n| http://bit.ly/2qjYX1n[EIP-681]   | URL Format for Transaction Requests | Daniel A. Nagy             | Interface       | Draft    |\n\n| http://bit.ly/2OYgE5n[EIP-649]   | Metropolis Difficulty Bomb Delay and Block Reward Reduction. Delayed the Ice Age (aka Difficulty Bomb) by 1 year, and reduced the block reward from 5 to 3 ether. | Afri Schoedon, Vitalik Buterin             | Core       | Final    | Metropolis Byzantinium\n| http://bit.ly/2RoGCvH[EIP-658]   | Embedding transaction status code in receipts. Fetches and embeds a status field indicative of success or failure state to transaction receipts for callers, as it's no longer possible to assume the transaction failed if and only if it consumed all gas after the introduction of the `REVERT` opcode in EIP-140.\n| Nick Johnson                               | Core       | Final    | Metropolis Byzantinium\n| http://bit.ly/2Ogwpzs[EIP-706]                             | DEVp2p snappy compression                                                                    | P\u00e9ter Szil\u00e1gyi                             | Networking | Final    |\n| http://bit.ly/2AAkCIP[EIP-721]                             | ERC-721 Non-Fungible Token Standard. A standard API that allows smart contracts to operate as unique tradable non-fungible tokens (NFTs) that may be tracked in standardized wallets and traded on exchanges as assets of value, similar to ERC20. CryptoKitties was the first popularly adopted implementation of a digital NFT in the Ethereum ecosystem.                                     | William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs                            | Standard | Draft    |\n| http://bit.ly/2qmuDmJ[EIP-758]   | Subscriptions and filters for completed transactions                        | Jack Peterson                    | Interface | Draft    |\n| http://bit.ly/2RnqlHy[EIP-801]   | ERC-801 Canary Standard                        | ligi                   | Interface | Draft    |\n| http://bit.ly/2DdTKkf[EIP-827]                             | ERC827 Token Standard. An extension of the standard interface ERC20 for tokens with methods that allow the execution of calls inside +transfer+ and approvals. This standard provides basic functionality to transfer tokens, as well as allowing tokens to be approved so they can be spent by another on-chain third party. Also, it allows the developer to execute calls on transfers and approvals.                                     | Augusto Lemble                            | ERC | Draft    |\n| http://bit.ly/2Jq2hAM[EIP-930]                             | ERC930 Eternal Storage. The ES (Eternal Storage) contract is owned by an address that has write permissions. The storage is public, which means everyone has read permissions. It stores the data in mappings, using one mapping per type of variable. The use of this contract allows the developer to migrate the storage easily to another contract if needed.                                     | Augusto Lemble                            | ERC | Draft    |\n|===", "metadata": {"source": "ethereumbook", "chapter": "appdx-standards-eip-erc.asciidoc", "section": "Table of Most Important EIPs and ERCs"}}
{"input": "Explain the Ethereum concept: Ethereum Fork History", "output": "(((\"Ethereum (generally)\",\"fork history\", id=\"ix_appdx-forks-history-asciidoc0\", range=\"startofrange\")))(((\"forks\", seealso=\"hard forks\", id=\"ix_appdx-forks-history-asciidoc1\", range=\"startofrange\")))(((\"hard forks\", id=\"ix_appdx-forks-history-asciidoc2\", range=\"startofrange\")))Most hard forks are planned as part of an upgrade roadmap and consist of updates that the community generally agrees to (i.e., there is social consensus). However, some hard forks lack consensus, which leads to multiple distinct blockchains. The events that led to the Ethereum/Ethereum Classic split are one such case, and are discussed in this appendix.\n\n[[etc_origin]]", "metadata": {"source": "ethereumbook", "chapter": "appdx-forks-history.asciidoc", "section": "Ethereum Fork History"}}
{"input": "Explain the Ethereum concept: Ethereum Classic (ETC)", "output": "(((\"DAO (Decentralized Autonomous Organization)\",\"and Ethereum Classic origins\")))(((\"Ethereum Classic (ETC)\",\"origins\")))(((\"forks\",\"ETC\")))Ethereum Classic came to be after members of the Ethereum community implemented a time-sensitive hard fork (codenamed &#x201c;DAO&#x201d;). On July 20, 2016, at a block height of 1.92 million, Ethereum introduced an irregular state change via a hard fork in an effort to return approximately 3.6 million ether that had been taken from a smart contract known as The DAO. Almost everyone agreed that the ether taken had been stolen and that leaving it all in the hands of the thief would be of significant detriment to the development of the Ethereum ecosystem as well as the platform itself.\n\nReturning the ether to its respective owners as though The DAO had never even existed was technically easy, if rather politically controversial. A number of people in the ecosystem disagreed with this change, believing immutability should be a fundamental principle of the Ethereum blockchain without exception; they elected to continue the original chain under the moniker of Ethereum Classic. While the split itself was initially ideological, the two chains have since evolved into separate entities.\n\n[[dao_origin]]", "metadata": {"source": "ethereumbook", "chapter": "appdx-forks-history.asciidoc", "section": "Ethereum Classic (ETC)"}}
{"input": "Explain the Ethereum concept: The Decentralized Autonomous Organization (The DAO)", "output": "(((\"DAO (Decentralized Autonomous Organization)\",\"about\")))(((\"forks\",\"DAO\")))The (((\"DAO (Decentralized Autonomous Organization)\", id=\"ix_appdx-forks-history-asciidoc3\", range=\"startofrange\")))DAO was created by Slock.it, with the aim of providing community-based funding and governance for projects. The core idea was that proposals would be submitted, curators would manage proposals, funds would be raised from investors within the Ethereum community, and, if the projects proved successful, investors would receive a share of the profits.\n\nThe DAO was also one of the first experiments in an Ethereum token. Rather than funding projects directly with ether, participants would trade their ether for DAO tokens, use them to vote on project funding, and later be able to trade them back for ether. \n\nDAO tokens were available to purchase in a crowdsale that ran from April 5 through April 30, 2016, amassing https://econ.st/2qfJO1g[nearly 14%] of the total ether in existence, which was worth ~$150 million at the time.\n\n[[dao_reentrancy_bug]]", "metadata": {"source": "ethereumbook", "chapter": "appdx-forks-history.asciidoc", "section": "The Decentralized Autonomous Organization (The DAO)"}}
{"input": "Explain the Ethereum concept: The Reentrancy Bug", "output": "(((\"forks\",\"reentrancy bug\")))(((\"reentrancy bug\")))On June 9, 2016, developers Peter Vessenes and Chriseth reported that most Ethereum-based contracts that managed funds were potentially http://bit.ly/2AAaDmA[vulnerable to an exploit] that could empty contract funds. A few days later, on June 12, Stephen Tual (cofounder of Slock.it) reported that http://bit.ly/2qmo3g1[The DAO's code was not vulnerable] to the bug described by Peter and Chriseth. Worried DAO contributors breathed a sigh of relief&#x2014;until five days later, when an unknown attacker started http://bit.ly/2Q7zR1h[draining The DAO] using an exploit similar to the one for which the warning had been issued. Ultimately, the DAO attacker siphoned ~3.6 million ether out of The DAO.\n\nSimultaneously, an assemblage of volunteers calling themselves the Robin Hood Group (RHG) started using the same exploit to withdraw the remaining funds in order to save them from being stolen by the DAO attacker. On June 21, http://bit.ly/2PtX4xl[the RHG announced] that they had secured about 70% of The DAO's funds (roughly 7.2 million ether), with plans to return it to the community (which they successfully did on the ETC network, and didn't need to do on the Ethereum network after the fork). Many thanks and commendations were given to the RHG for their quick thinking and fast actions that helped secure the bulk of the community's ether.\n\n[[dao_reentrancy_bug_technicals]]", "metadata": {"source": "ethereumbook", "chapter": "appdx-forks-history.asciidoc", "section": "The Reentrancy Bug"}}
{"input": "Explain the Ethereum concept: Technical Details", "output": "(((\"reentrancy bug\",\"technical details\")))While a more detailed and thorough explanation of the bug is given by http://bit.ly/2EQaLCI[Phil Daian], the short explanation is that a crucial function in the DAO had two lines of code in the wrong order, meaning that the attacker could have requests to withdraw ether acted upon repeatedly, before the check of whether the attacker was entitled to the withdrawal was completed. This type of vulnerability is described in <<reentrancy_security>>.\n\n[[dao_reentrancy_bug_attack_flow]]", "metadata": {"source": "ethereumbook", "chapter": "appdx-forks-history.asciidoc", "section": "Technical Details"}}
{"input": "Explain the Ethereum concept: Attack Flow", "output": "(((\"reentrancy bug\",\"attack flow\")))Imagine you had $100 in your bank account and you could bring your bank teller any number of withdrawal slips. The teller would give you money for each slip in order, and only after processing all the slips would they record your withdrawal. What if you brought them three slips, each requesting withdraw $100? What if you brought them three thousand?\n\nThe DAO attack worked like this:\n\n1. The DAO attacker asks the DAO contract to withdraw DAO tokens (DAO).\n2. The attacker asks the contract to withdraw DAO _again_, before the contract updates its records to show that DAO was withdrawn.\n3. The attacker repeats step 2 as many times as possible.\n4. The contract finally logs a single DAO withdrawal, losing track of the withdrawals that happened in the interim.\n\n[[dao_hard_fork]]", "metadata": {"source": "ethereumbook", "chapter": "appdx-forks-history.asciidoc", "section": "Attack Flow"}}
{"input": "Explain the Ethereum concept: The DAO Hard Fork", "output": "(((\"DAO (Decentralized Autonomous Organization)\",\"hard fork\", id=\"ix_appdx-forks-history-asciidoc4\", range=\"startofrange\")))(((\"forks\",\"DAO\", id=\"ix_appdx-forks-history-asciidoc5\", range=\"startofrange\")))(((\"hard forks\", id=\"ix_appdx-forks-history-asciidoc6\", range=\"startofrange\")))Fortunately, there were several safeguards built into The DAO: notably, all withdrawal requests were subject to a 28-day delay. This gave the community a little while to discuss what to do about the exploit, because from roughly June 17&#x2013;July 20 the DAO attacker would be unable to convert their DAO tokens into ether.\n\nSeveral developers focused on finding a viable solution, and multiple avenues were explored in this short space of time. Among them were a http://bit.ly/2qhruEK[_DAO soft fork_], announced on June 24, to delay DAO withdrawals until consensus was reached, and a http://bit.ly/2AAGjIu[_DAO hard fork_], announced on July 15, to reverse the effects of the DAO attack with an exceptional state change.\n\nOn June 28, developers discovered http://bit.ly/2zgOxUn[a DoS exploit in the DAO soft fork]  and concluded that the DAO hard fork would be the only viable option to fully resolve the situation. The DAO hard fork would transfer all ether that had been invested in The DAO into a new refund smart contract, allowing the original owners of the ether to claim full refunds. This provided a solution for returning the hacked funds, but also meant interfering with the balances of specific addresses on the network, however isolated they were. There would also be some leftover ether in portions of The DAO known as _childDAOs_. A group of trustees would manually authorize the leftover ether, worth http://bit.ly/2RuUrJh[~$6\u20137 million] at the time.\n\nWith time running out, multiple Ethereum development teams created clients that allowed a user to decide whether they wanted to enable this fork. However, the client creators wanted to decide whether to make this choice opt-in (don't fork by default) or opt-out (fork by default). On July 15, a vote was opened on http://bit.ly/2ABkTuV[_carbonvote.com_]. The next day, at block height http://bit.ly/2yHb7Gl[1,894,000], it was closed. Of the http://bit.ly/2RuUrJh[5.5% of the total ether supply] that voted, &#x7e;80% of the votes (&#x7e;4.5% of the total ether supply) voted for opt-out. One-quarter of the opt-out vote came from a single address.\n\nUltimately the decision became opt-out, so those who opposed the DAO hard fork would need to explicitly state their opposition by changing a configuration option in the software they were running.\n\nOn July 20, at block height http://bit.ly/2zfaIKB[1,920,000], Ethereum http://bit.ly/2yJxZ83[implemented the DAO hard fork] and thus two Ethereum networks were created: one including the state change, and the other ignoring it.\n\n(((\"Ethereum Classic (ETC)\",\"origins\")))When the DAO hard-forked Ethereum (present-day Ethereum) gained a majority of the mining power, many assumed that consensus was achieved and the minority chain would fade away, as in previous forks. Despite this, a sizable portion of the Ethereum community (roughly 10% by value and mining power) started supporting the non-forked chain, which came to be known as Ethereum Classic.\n\nWithin days of the fork, several exchanges began to list both Ethereum (\"ETH\") and Ethereum Classic (\"ETC\"). Due to the nature of hard forks, all Ethereum users holding ether at the time of the split then held funds on both of the chains, and a market value for ETC was soon established with http://bit.ly/2qhuNvP[Poloniex] listing ETC on July 24.\n\n[[dao_hard_fork_timeline]]", "metadata": {"source": "ethereumbook", "chapter": "appdx-forks-history.asciidoc", "section": "The DAO Hard Fork"}}
{"input": "Explain the Ethereum concept: Timeline of the DAO Hard Fork", "output": "- April 5, 2016: Slock.it http://bit.ly/2Db4boE[releases a security review] of the generic DAO framework smart contracts by Deja Vu Security.\n- April 30, 2016: The DAO crowdsale http://bit.ly/2qhwhpI[launches].\n- May 27, 2016: The DAO crowdsale ends.\n- June 9, 2016: A generic http://bit.ly/2AAaDmA[recursive call bug] is discovered and believed to affect many Solidity contracts that track users' balances.\n- June 12, 2016: Stephen Tual http://bit.ly/2qmo3g1[declares] that The DAO's funds are not at risk.\n- June 17, 2016: http://bit.ly/2EQaLCI[The DAO is exploited] and a variant of the discovered bug (termed the \"reentrancy bug\") is used to start draining the funds, eventually nabbing ~30% of the ether.\n- June 21, 2016: The RHG http://bit.ly/2zgl3Gk[announces] it has secured the other ~70% of the ether stored within The DAO.\n- June 24, 2016: A http://bit.ly/2qhruEK[soft fork vote] is announced via opt-in signaling through Geth and Parity clients, designed to temporarily withhold funds until the community can better decide what to do.\n- June 28, 2016: A http://bit.ly/2zgOxUn[vulnerability] is discovered in the soft fork and it's abandoned.\n- June 28, 2016 to July 15: Users debate whether or not to hard fork; most of the vocal public debate occurs on the _/r/ethereum_ subreddit.\n- July 15, 2016: The http://bit.ly/2qmo3g1[DAO hard fork] is proposed, to return the funds taken in the DAO attack.\n- July 15, 2016: A http://bit.ly/2ABkTuV[vote is held] on CarbonVote to decide if the DAO hard fork will be opt-in (don't fork by default) or opt-out (fork by default).\n- July 16, 2016: http://bit.ly/2RuUrJh[5.5% of the total ether supply votes]; pass:[~80% of the votes (~4.5%] of the total supply) are pro the opt-out hard fork, with one-quarter of the pro-vote coming from a single address.\n- July 20, 2016: The http://bit.ly/2yJxZ83[hard fork] occurs at block 1,920,000.\n- July 20, 2016: Those against the DAO hard fork continue running the old client software; this leads to issues with http://bit.ly/2qjJm27[transactions being replayed on both chains].\n- July 24, 2016: http://bit.ly/2qhuNvP[Poloniex lists] the original Ethereum chain under the ticker symbol ETC; it's the first exchange to do so.\n- August 10, 2016: The RHG http://bit.ly/2JrLpK2[transfers 2.9] million of the recovered ETC to Poloniex in order to convert it to ETH on the advice of Bity SA; 14% of the total RHG holdings are converted from ETC to ETH and other cryptocurrencies, and http://bit.ly/2ETDdUc[Poloniex freezes] the other 86% of deposited ETH.\n- August 30, 2016: The frozen funds are sent by Poloniex back to the RHG, which then sets up a refund contract on the ETC chain.\n- December 11, 2016: IOHK's ETC development team forms, led by Ethereum founding member Charles Hoskinson.\n- January 13, 2017: The ETC network is updated to resolve transaction replay issues; the chains are now functionally separate.\n- February 20, 2017: The ETCDEVTeam forms, led by early ETC developer Igor Artamonov(((range=\"endofrange\", startref=\"ix_appdx-forks-history-asciidoc6\"))) (splix).(((range=\"endofrange\", startref=\"ix_appdx-forks-history-asciidoc5\")))(((range=\"endofrange\", startref=\"ix_appdx-forks-history-asciidoc4\")))(((range=\"endofrange\", startref=\"ix_appdx-forks-history-asciidoc3\")))\n\n[[eth_etc_differences]]", "metadata": {"source": "ethereumbook", "chapter": "appdx-forks-history.asciidoc", "section": "Timeline of the DAO Hard Fork"}}
{"input": "Explain the Ethereum concept: Ethereum and Ethereum Classic", "output": "(((\"Ethereum (generally)\",\"Ethereum Classic compared to\")))(((\"Ethereum Classic (ETC)\",\"Ethereum compared to\")))(((\"forks\",\"ETC\")))(((\"forks\",\"Ethereum and Ethereum Classic split\")))While the initial split was centered around The DAO, the two networks, Ethereum and Ethereum Classic, are now separate projects, although most development is still done by the Ethereum community and simply ported to Ethereum Classic codebases. Nevertheless, the full set of differences is constantly evolving and too extensive to cover in this appendix. However, it is worth noting that the chains do differ significantly in their core development and community structure. A few of the technical differences are discussed next.\n\n\n[[eth_etc_differences_evm]]", "metadata": {"source": "ethereumbook", "chapter": "appdx-forks-history.asciidoc", "section": "Ethereum and Ethereum Classic"}}
{"input": "Explain the Ethereum concept: The EVM", "output": "(((\"EVM OPCODES\")))For the most part (at the time of writing), the two networks remain highly compatible: contract code produced for one chain runs as expected on the other; but there are some small differences in EVM OPCODES (see EIPs link:http://bit.ly/2yIajkF[140], link:http://bit.ly/2qhKz9Y[145], and link:http://bit.ly/2SxsrFR[214]).\n\n[[eth_etc_differences_core_development]]", "metadata": {"source": "ethereumbook", "chapter": "appdx-forks-history.asciidoc", "section": "The EVM"}}
{"input": "Explain the Ethereum concept: Core Network Development", "output": "Being open projects, blockchain platforms often have many users and contributors. However, the core network development (i.e., of the code that runs the network) is often done by small groups due to the expertise and knowledge required to develop this type of software. On Ethereum, this work is done by the Ethereum Foundation and volunteers. On Ethereum Classic, it's done by ETCDEV, IOHK, and volunteers.\n\n[[ethereum_forks]]", "metadata": {"source": "ethereumbook", "chapter": "appdx-forks-history.asciidoc", "section": "Core Network Development"}}
{"input": "Explain the Ethereum concept: Other Notable Ethereum Forks", "output": "(((\"Ellaism\")))https://ellaism.org/about/[Ellaism] is an Ethereum-based network that intends to use PoW exclusively to secure the blockchain. It has no pre-mine and no mandatory developer fees, with all support and development donated freely by the community. Its developers believe this makes theirs &#x201c;one of the most honest pure Ethereum projects,&#x201d; and one that is &#x201c;uniquely interesting as a platform for serious developers, educators, and enthusiasts. Ellaism is a pure smart contract platform. Its goal is to create a smart contract platform that is both fair and trustworthy.&#x201d; The principles of the platform are as follows:\n\n____\n* All changes and upgrades to the protocol should strive to maintain and reinforce these Principles of Ellaism.\n* Monetary Policy: 280 million coins.\n* No Censorship: Nobody should be able to prevent valid txs from being confirmed.\n* Open-Source: Ellaism source code should always be open for anyone to read, modify, copy, share.\n* Permissionless: No arbitrary gatekeepers should ever prevent anybody from being part of the network (user, node, miner, etc).\n* Pseudonymous: No ID should be required to own, use Ellaism.\n* Fungible: All coins are equal and should be equally spendable.\n* Irreversible Transactions: Confirmed blocks should be set in stone. Blockchain History should be immutable.\n* No Contentious Hard Forks: Never hard fork without consensus from the whole community. Only break the existing consensus when necessary.\n* Many feature upgrades can be carried out without a hard fork, such as improving the performance of the EVM.\n____\n\nSeveral other forks have occurred on Ethereum as well. Some of these are hard forks, in the sense that they split directly off of the preexisting Ethereum network. Others are software forks: they use Ethereum's client/node software but run entirely separate networks without any history shared with Ethereum. There will likely be more forks over the life of Ethereum.\n\nThere are also several other projects that claim to be Ethereum forks but are actually based on ERC20 tokens and run on the Ethereum network. (((\"airdrops\")))(((\"EMOD (Ethereum Modification)\")))(((\"ETHB (EtherBTC)\")))(((\"EtherBTC (ETHB)\")))(((\"Ethereum Modification (EMOD)\")))Two examples of these are EtherBTC (ETHB) and Ethereum Modification (EMOD). These are not forks in the traditional sense, and may sometimes be called &#x201c;airdrops.&#x201d;\n\nHere's a brief rundown of some of the more notable forks that have occurred:\n\n- (((\"Expanse\")))_Expanse_ was the first fork of the Ethereum blockchain to gain traction. It was announced via the Bitcoin Talk forum on September 7, 2015. The actual fork occurred a week later on September 14, 2015, at a block height of 800,000. It was originally founded by Christopher Franko and James Clayton. Their stated vision was to create an advanced chain for: \"identity, governance, charity, commerce, and equity\".\n- (((\"ETF (EthereumFog)\")))(((\"EthereumFog (ETF)\")))_EthereumFog_ (ETF) was launched on December 14, 2017, and forked at a block height of 4,730,660. The project's stated aim is to develop \"world decentralized fog computing\" by focusing on fog computing and decentralized storage. There is still little information on what this will actually entail.\n- _EtherZero_ (ETZ) (((\"EtherZero (ETZ)\")))was launched on January 19, 2018, at a block height of 4,936,270. Its notable innovations were the introduction of a masternode architecture and the removal of transaction fees for smart contracts to enable a wider diversity of DApps. There has been some criticism from some prominent members of the Ethereum community, MyEtherWallet, and MetaMask, due to the lack of clarity surrounding development and some accusations of possible phishing.\n- (((\"EtherInc (ETI)\")))(((\"ETI (EtherInc)\")))_EtherInc_ (ETI) was launched on February 13, 2018, at a block height of 5,078,585, with a focus on building decentralized organizations. Stated goals include the reduction of block times, increased miner rewards, the removal of uncle rewards, and setting a cap on mineable coins. EtherInc uses the same private keys as Ethereum and has implemented replay protection to protect ether on the original non-forked chain.(((range=\"endofrange\", startref=\"ix_appdx-forks-history-asciidoc2\")))(((range=\"endofrange\", startref=\"ix_appdx-forks-history-asciidoc1\")))(((range=\"endofrange\", startref=\"ix_appdx-forks-history-asciidoc0\")))", "metadata": {"source": "ethereumbook", "chapter": "appdx-forks-history.asciidoc", "section": "Other Notable Ethereum Forks"}}
{"input": "Explain the Ethereum concept: Ethereum EVM Opcodes and Gas Consumption", "output": "(((\"EVM (Ethereum Virtual Machine)\",\"opcodes and gas consumption\")))(((\"gas\",\"EVM opcodes and gas consumption\")))This appendix is based on the consolidation work done by the people of https://github.com/trailofbits/evm-opcodes as a reference for Ethereum VM (EVM) opcodes and instruction information licensed under the http://bit.ly/2zfrv0b[Apache License 2.0].\n\n[[evm_opcodes_table]]\n[cols=\",,,,\",options=\"header\",]\n.EVM opcodes and gas cost\n|=======================================================================================================================================================================================================\n|Opcode |Name |Description |Extra info |Gas\n|`0x00` |+STOP+ |Halts execution |- |0\n\n|`0x01` |+ADD+ |Addition operation |- |3\n\n|`0x02` |+MUL+ |Multiplication operation |- |5\n\n|`0x03` |+SUB+ |Subtraction operation |- |3\n\n|`0x04` |+DIV+ |Integer division operation |- |5\n\n|`0x05` |+SDIV+ |Signed integer division operation (truncated) |- |5\n\n|`0x06` |+MOD+ |Modulo remainder operation |- |5\n\n|`0x07` |+SMOD+ |Signed modulo remainder operation |- |5\n\n|`0x08` |+ADDMOD+ |Modulo addition operation |- |8\n\n|`0x09` |+MULMOD+ |Modulo multiplication operation |- |8\n\n|`0x0a` |+EXP+ |Exponential operation |- |10***\n\n|`0x0b` |+SIGNEXTEND+ |Extend length of two's complement signed integer |- |5\n\n|`0x0c` - `0x0f` |Unused |Unused |- |\n\n|`0x10` |+LT+ |Less-than comparison |- |3\n\n|`0x11` |+GT+ |Greater-than comparison |- |3\n\n|`0x12` |+SLT+ |Signed less-than comparison |- |3\n\n|`0x13` |+SGT+ |Signed greater-than comparison |- |3\n\n|`0x14` |+EQ+ |Equality comparison |- |3\n\n|`0x15` |+ISZERO+ |Simple NOT operator |- |3\n\n|`0x16` |+AND+ |Bitwise AND operation |- |3\n\n|`0x17` |+OR+ |Bitwise OR operation |- |3\n\n|`0x18` |+XOR+ |Bitwise XOR operation |- |3\n\n|`0x19` |+NOT+ |Bitwise NOT operation |- |3\n\n|`0x1a` |+BYTE+ |Retrieve single byte from word |- |3\n\n|`0x1b` - `0x1f` |Unused |Unused |- |\n\n|`0x20` |+SHA3+ |Compute Keccak-256 hash |- |30\n\n|`0x21` - `0x2f` |Unused |Unused |- |\n\n|`0x30` |+ADDRESS+ |Get address of currently executing account |- |2\n\n|`0x31` |+BALANCE+ |Get balance of the given account |- |400\n\n|`0x32` |+ORIGIN+ |Get execution origination address |- |2\n\n|`0x33` |+CALLER+ |Get caller address |- |2\n\n|`0x34` |+CALLVALUE+ |Get deposited value by the instruction/transaction responsible for this execution |- |2\n\n|`0x35` |+CALLDATALOAD+ |Get input data of current environment |- |3\n\n|`0x36` |+CALLDATASIZE+ |Get size of input data in current environment |- |2\n\n|`0x37` |+CALLDATACOPY+ |Copy input data in current environment to memory |- |3\n\n|`0x38` |+CODESIZE+ |Get size of code running in current environment |- |2\n\n|`0x39` |+CODECOPY+ |Copy code running in current environment to memory |- |3\n\n|`0x3a` |+GASPRICE+ |Get price of gas in current environment |- |2\n\n|`0x3b` |+EXTCODESIZE+ |Get size of an account's code |- |700\n\n|`0x3c` |+EXTCODECOPY+ |Copy an account's code to memory |- |700\n\n|`0x3d` |+RETURNDATASIZE+ |Pushes the size of the return data buffer onto the stack |http://bit.ly/2zaBcNe[EIP-211] |2\n\n|`0x3e` |+RETURNDATACOPY+ |Copies data from the return data buffer to memory |http://bit.ly/2zaBcNe[EIP-211] |3\n\n|`0x3f` |Unused |- |- |\n\n|`0x40` |+BLOCKHASH+ |Get the hash of one of the 256 most recent complete blocks |- |20\n\n|`0x41` |+COINBASE+ |Get the block's beneficiary address |- |2\n\n|`0x42` |+TIMESTAMP+ |Get the block's timestamp |- |2\n\n|`0x43` |+NUMBER+ |Get the block's number |- |2\n\n|`0x44` |+DIFFICULTY+ |Get the block's difficulty |- |2\n\n|`0x45` |+GASLIMIT+ |Get the block's gas limit |- |2\n\n|`0x46` - `0x4f` |Unused |- |- |\n\n|`0x50` |+POP+ |Remove word from stack |- |2\n\n|`0x51` |+MLOAD+ |Load word from memory |- |3\n\n|`0x52` |+MSTORE+ |Save word to memory |- |3*\n\n|`0x53` |+MSTORE8+ |Save byte to memory |- |3\n\n|`0x54` |+SLOAD+ |Load word from storage |- |200\n\n|`0x55` |+SSTORE+ |Save word to storage |- |0*\n\n|`0x56` |+JUMP+ |Alter the program counter |- |8\n\n|`0x57` |+JUMPI+ |Conditionally alter the program counter |- |10\n\n|`0x58` |+GETPC+ |Get the value of the program counter prior to the increment |- |2\n\n|`0x59` |+MSIZE+ |Get the size of active memory in bytes |- |2\n\n|`0x5a` |+GAS+ |Get the amount of available gas, including the corresponding reduction in the amount of available gas |- |2\n\n|`0x5b` |+JUMPDEST+ |Mark a valid destination for jumps |- |1\n\n|`0x5c` - `0x5f` |Unused |- |- |\n\n|`0x60` |+PUSH1+ |Place 1-byte item on stack |- |3\n\n|`0x61` |+PUSH2+ |Place 2-byte item on stack |- |3\n\n|`0x62` |+PUSH3+ |Place 3-byte item on stack |- |3\n\n|`0x63` |+PUSH4+ |Place 4-byte item on stack |- |3\n\n|`0x64` |+PUSH5+ |Place 5-byte item on stack |- |3\n\n|`0x65` |+PUSH6+ |Place 6-byte item on stack |- |3\n\n|`0x66` |+PUSH7+ |Place 7-byte item on stack |- |3\n\n|`0x67` |+PUSH8+ |Place 8-byte item on stack |- |3\n\n|`0x68` |+PUSH9+ |Place 9-byte item on stack |- |3\n\n|`0x69` |+PUSH10+ |Place 10-byte item on stack |- |3\n\n|`0x6a` |+PUSH11+ |Place 11-byte item on stack |- |3\n\n|`0x6b` |+PUSH12+ |Place 12-byte item on stack |- |3\n\n|`0x6c` |+PUSH13+ |Place 13-byte item on stack |- |3\n\n|`0x6d` |+PUSH14+ |Place 14-byte item on stack |- |3\n\n|`0x6e` |+PUSH15+ |Place 15-byte item on stack |- |3\n\n|`0x6f` |+PUSH16+ |Place 16-byte item on stack |- |3\n\n|`0x70` |+PUSH17+ |Place 17-byte item on stack |- |3\n\n|`0x71` |+PUSH18+ |Place 18-byte item on stack |- |3\n\n|`0x72` |+PUSH19+ |Place 19-byte item on stack |- |3\n\n|`0x73` |+PUSH20+ |Place 20-byte item on stack |- |3\n\n|`0x74` |+PUSH21+ |Place 21-byte item on stack |- |3\n\n|`0x75` |+PUSH22+ |Place 22-byte item on stack |- |3\n\n|`0x76` |+PUSH23+ |Place 23-byte item on stack |- |3\n\n|`0x77` |+PUSH24+ |Place 24-byte item on stack |- |3\n\n|`0x78` |+PUSH25+ |Place 25-byte item on stack |- |3\n\n|`0x79` |+PUSH26+ |Place 26-byte item on stack |- |3\n\n|`0x7a` |+PUSH27+ |Place 27-byte item on stack |- |3\n\n|`0x7b` |+PUSH28+ |Place 28-byte item on stack |- |3\n\n|`0x7c` |+PUSH29+ |Place 29-byte item on stack |- |3\n\n|`0x7d` |+PUSH30+ |Place 30-byte item on stack |- |3\n\n|`0x7e` |+PUSH31+ |Place 31-byte item on stack |- |3\n\n|`0x7f` |+PUSH32+ |Place 32-byte (full word) item on stack |- |3\n\n|`0x80` |+DUP1+ |Duplicate 1st stack item |- |3\n\n|`0x81` |+DUP2+ |Duplicate 2nd stack item |- |3\n\n|`0x82` |+DUP3+ |Duplicate 3rd stack item |- |3\n\n|`0x83` |+DUP4+ |Duplicate 4th stack item |- |3\n\n|`0x84` |+DUP5+ |Duplicate 5th stack item |- |3\n\n|`0x85` |+DUP6+ |Duplicate 6th stack item |- |3\n\n|`0x86` |+DUP7+ |Duplicate 7th stack item |- |3\n\n|`0x87` |+DUP8+ |Duplicate 8th stack item |- |3\n\n|`0x88` |+DUP9+ |Duplicate 9th stack item |- |3\n\n|`0x89` |+DUP10+ |Duplicate 10th stack item |- |3\n\n|`0x8a` |+DUP11+ |Duplicate 11th stack item |- |3\n\n|`0x8b` |+DUP12+ |Duplicate 12th stack item |- |3\n\n|`0x8c` |+DUP13+ |Duplicate 13th stack item |- |3\n\n|`0x8d` |+DUP14+ |Duplicate 14th stack item |- |3\n\n|`0x8e` |+DUP15+ |Duplicate 15th stack item |- |3\n\n|`0x8f` |+DUP16+ |Duplicate 16th stack item |- |3\n\n|`0x90` |+SWAP1+ |Exchange 1st and 2nd stack items |- |3\n\n|`0x91` |+SWAP2+ |Exchange 1st and 3rd stack items |- |3\n\n|`0x92` |+SWAP3+ |Exchange 1st and 4th stack items |- |3\n\n|`0x93` |+SWAP4+ |Exchange 1st and 5th stack items |- |3\n\n|`0x94` |+SWAP5+ |Exchange 1st and 6th stack items |- |3\n\n|`0x95` |+SWAP6+ |Exchange 1st and 7th stack items |- |3\n\n|`0x96` |+SWAP7+ |Exchange 1st and 8th stack items |- |3\n\n|`0x97` |+SWAP8+ |Exchange 1st and 9th stack items |- |3\n\n|`0x98` |+SWAP9+ |Exchange 1st and 10th stack items |- |3\n\n|`0x99` |+SWAP10+ |Exchange 1st and 11th stack items |- |3\n\n|`0x9a` |+SWAP11+ |Exchange 1st and 12th stack items |- |3\n\n|`0x9b` |+SWAP12+ |Exchange 1st and 13th stack items |- |3\n\n|`0x9c` |+SWAP13+ |Exchange 1st and 14th stack items |- |3\n\n|`0x9d` |SWAP14 |Exchange 1st and 15th stack items |- |3\n\n|`0x9e` |+SWAP15+ |Exchange 1st and 16th stack items |- |3\n\n|`0x9f` |+SWAP16+ |Exchange 1st and 17th stack items |- |3\n\n|`0xa0` |+LOG0+ |Append log record with no topics |- |375\n\n|`0xa1` |+LOG1+ |Append log record with one topic |- |750\n\n|`0xa2` |+LOG2+ |Append log record with two topics |- |1125\n\n|`0xa3` |+LOG3+ |Append log record with three topics |- |1500\n\n|`0xa4` |+LOG4+ |Append log record with four topics |- |1875\n\n|`0xa5` - `0xaf` |Unused |- |- |\n\n|`0xb0` |+JUMPTO+ |Tentative http://bit.ly/2Sx2Vkg[libevmasm has different numbers] | http://bit.ly/2CR77pu[EIP 615] |\n\n|`0xb1` |+JUMPIF+ |Tentative |http://bit.ly/2CR77pu[EIP-615] |\n\n|`0xb2` |+JUMPSUB+ |Tentative |http://bit.ly/2CR77pu[EIP-615] |\n\n|`0xb4` |+JUMPSUBV+ |Tentative |http://bit.ly/2CR77pu[EIP-615] |\n\n|`0xb5` |+BEGINSUB+ |Tentative |http://bit.ly/2CR77pu[EIP-615] |\n\n|`0xb6` |+BEGINDATA+ |Tentative |http://bit.ly/2CR77pu[EIP-615] |\n\n|`0xb8` |+RETURNSUB+ |Tentative |http://bit.ly/2CR77pu[EIP-615] |\n\n|`0xb9` |+PUTLOCAL+ |Tentative |http://bit.ly/2CR77pu[EIP-615] |\n\n|`0xba` |+GETLOCA+ |Tentative |http://bit.ly/2CR77pu[EIP-615] |\n\n|`0xbb` - `0xe0` |Unused |- |- |\n\n|`0xe1` |+SLOADBYTES+ |Only referenced in +pyethereum+ |- |-\n\n|`0xe2` |+SSTOREBYTES+ |Only referenced in +pyethereum+ |- |-\n\n|`0xe3` |+SSIZE+ |Only referenced in +pyethereum+ |- |-\n\n|`0xe4` - `0xef` |Unused |- |- |\n\n|`0xf0` |+CREATE+ |Create a new account with associated code |- |32000\n\n|`0xf1` |+CALL+ |Message-call into an account |- |Complicated\n\n|`0xf2` |+CALLCODE+ |Message-call into this account with alternative account's code |- |Complicated\n\n|`0xf3` |+RETURN+ |Halt execution returning output data |- |0\n\n|`0xf4` |+DELEGATECALL+ |Message-call into this account with an alternative account's code, but persisting into this account with an alternative account's code |- |Complicated\n\n|`0xf5` |+CALLBLACKBOX+ |- |- |40\n\n|`0xf6` - `0xf9` |Unused |- |- |\n\n|`0xfa` |+STATICCALL+ |Similar to +CALL+, but does not modify state |- |40\n\n|`0xfb` |+CREATE2+ |Create a new account and set creation address to `sha3(sender + sha3(init code)) % 2**160` |- |\n\n|`0xfc` |+TXEXECGAS+ |Not in yellow paper FIXME |- |-\n\n|`0xfd` |+REVERT+ |Stop execution and revert state changes, without consuming all provided gas and providing a reason |- |0\n\n|`0xfe` |+INVALID+ |Designated invalid instruction |- |0\n\n|`0xff` |+SELFDESTRUCT+ |Halt execution and register account for later deletion |- |5000*\n|=======================================================================================================================================================================================================", "metadata": {"source": "ethereumbook", "chapter": "appdx-evm-opcodes-gas.asciidoc", "section": "Ethereum EVM Opcodes and Gas Consumption"}}
