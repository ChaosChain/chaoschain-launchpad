{"eip": 2, "url": "https://eips.ethereum.org/EIPS/eip-2", "title": "Homestead Hard-fork Changes", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-2: Homestead Hard-fork Changes": "Homestead.", "": "Homestead.", "Meta reference": "Homestead.", "Parameters": "Ifblock.number >= HOMESTEAD_FORK_BLKNUM, do the following:", "Specification": "Ifblock.number >= HOMESTEAD_FORK_BLKNUM, do the following:", "Rationale": "Currently, there is an excess incentive to create contracts via transactions, where the cost is 21,000, rather than contracts, where the cost is 32,000. Additionally, with the help of suicide refunds, it is currently possible to make a simple ether value transfer using only 11,664 gas; the code for doing this is as follows:", "Implementation": "This is implemented in Python here:", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5, "url": "https://eips.ethereum.org/EIPS/eip-5", "title": "Gas Usage for `RETURN` and `CALL*`", "authors": ["Christian Reitwiessner\u00a0<", "c@ethdev.com", ">"], "sections": {"EIP-5: Gas Usage for `RETURN` and `CALL*`": "This EIP makes it possible to call functions that return strings and other dynamically-sized arrays.\nCurrently, when another contract / function is called from inside the Ethereum Virtual Machine,\nthe size of the output has to be specified in advance. It is of course possible to give a larger\nsize, but gas also has to be paid for memory that is not written to, which makes returning\ndynamically-sized data both costly and inflexible to the extent that it is actually unusable.", "": "This EIP makes it possible to call functions that return strings and other dynamically-sized arrays.\nCurrently, when another contract / function is called from inside the Ethereum Virtual Machine,\nthe size of the output has to be specified in advance. It is of course possible to give a larger\nsize, but gas also has to be paid for memory that is not written to, which makes returning\ndynamically-sized data both costly and inflexible to the extent that it is actually unusable.", "Abstract": "This EIP makes it possible to call functions that return strings and other dynamically-sized arrays.\nCurrently, when another contract / function is called from inside the Ethereum Virtual Machine,\nthe size of the output has to be specified in advance. It is of course possible to give a larger\nsize, but gas also has to be paid for memory that is not written to, which makes returning\ndynamically-sized data both costly and inflexible to the extent that it is actually unusable.", "Specification": "The gas and memory semantics forCALL,CALLCODEandDELEGATECALL(called later asCALL*)\nare changed in the following way (CREATEdoes not write to memory and is thus unaffected):", "Motivation": "In general, it is good practise to reserve a certain memory area for the output of a call,\nbecause letting a subroutine write to arbitrary areas in memory might be dangerous. On the\nother hand, it is often hard to know the output size of a call prior to performing the call:\nThe data could be in the storage of another contract which is generally inaccessible and\ndetermining its size would require another call to that contract.", "Rationale": "This way of dealing with the problem requires a minimal change to the Ethereum Virtual Machine.\nOther means of achieving a similar goal would have changed the opcodes themselves or\nthe number of their arguments. Another possibility would have been to only change the\ngas mechanics ifoutput_sizeis equal to2**256-1. Since the main difficulty in the\nimplementation is that memory has to be enlarged at two points in the code aroundCALL,\nthis would not have been a simplification.", "Backwards Compatibility": "This proposal changes the semantics of contracts because contracts can access the gas counter\nand the size of memory.", "Implementation": "VM implementers should take care not to grow the memory until the end of the call and after a check that sufficient\ngas is still available. Typical uses of the EIP include \u201creserving\u201d2**256-1bytes of memory for the output.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7, "url": "https://eips.ethereum.org/EIPS/eip-7", "title": "DELEGATECALL", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-7: DELEGATECALL": "Homestead", "": "Homestead", "Hard Fork": "Homestead", "Parameters": "Add a new opcode,DELEGATECALLat0xf4, which is similar in idea toCALLCODE, except that it propagates the sender and value from the parent scope to the child scope, i.e. the call created has the same sender and value as the original call.", "Overview": "Add a new opcode,DELEGATECALLat0xf4, which is similar in idea toCALLCODE, except that it propagates the sender and value from the parent scope to the child scope, i.e. the call created has the same sender and value as the original call.", "Specification": "DELEGATECALL:0xf4, takes 6 operands:", "Rationale": "Propagating the sender and value from the parent scope to the child scope makes it much easier for a contract to store another address as a mutable source of code and \u2018\u2018pass through\u2019\u2019 calls to it, as the child code would execute in essentially the same environment (except for reduced gas and increased callstack depth) as the parent.", "Possible arguments against": "Please cite this document as:", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 100, "url": "https://eips.ethereum.org/EIPS/eip-100", "title": "Change difficulty adjustment to target mean block time including uncles", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-100: Change difficulty adjustment to target mean block time including uncles": "Currently, the formula to compute the difficulty of a block includes the following logic:", "": "Currently, the formula to compute the difficulty of a block includes the following logic:", "Specification": "Currently, the formula to compute the difficulty of a block includes the following logic:", "Rationale": "This new formula ensures that the difficulty adjustment algorithm targets a constant average rate of blocks produced including uncles, and so ensures a highly predictable issuance rate that cannot be manipulated upward by manipulating the uncle rate. A formula that accounts for the exact number of included uncles:", "References": "Please cite this document as:", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- uncle rate: Refers to the rate of uncles (stale blocks) included in a block, considered in EIP-100's difficulty adjustment formula .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 140, "url": "https://eips.ethereum.org/EIPS/eip-140", "title": "REVERT instruction", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Nikolai Mushegian\u00a0<", "nikolai@nexusdev.us", ">"], "sections": {"EIP-140: REVERT instruction": "TheREVERTinstruction provides a way to stop execution and revert state changes, without consuming all provided gas and with the ability to return a reason.", "": "TheREVERTinstruction provides a way to stop execution and revert state changes, without consuming all provided gas and with the ability to return a reason.", "Simple Summary": "TheREVERTinstruction provides a way to stop execution and revert state changes, without consuming all provided gas and with the ability to return a reason.", "Abstract": "TheREVERTinstruction will stop execution, roll back all state changes done so far and provide a pointer to a memory section, which can be interpreted as an error code or message. While doing so, it will not consume all the remaining gas.", "Motivation": "Currently this is not possible. There are two practical ways to revert a transaction from within a contract: running out of gas or executing an invalid instruction. Both of these options will consume all remaining gas. Additionally, reverting an EVM execution means that all changes, including LOGs, are lost and there is no way to convey a reason for aborting an EVM execution.", "Specification": "On blocks withblock.number >= BYZANTIUM_FORK_BLKNUM, theREVERTinstruction is introduced at0xfd. It expects two stack items, the top item is thememory_offsetfollowed bymemory_length. It does not produce any stack elements because it stops execution.", "Backwards Compatibility": "This change has no effect on contracts created in the past unless they contain0xfdas an instruction.", "Test Cases": "should:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- revert instruction: Introduces the REVERT opcode (0xfd), which allows contracts to halt execution and revert state changes without consuming all remaining gas. This opcode can return a reason or error message to the caller.\n- revert: All calls to this opcode must emit a log with revert data."}
{"eip": 141, "url": "https://eips.ethereum.org/EIPS/eip-141", "title": "Designated invalid EVM instruction", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-141: Designated invalid EVM instruction": "An instruction is designated to remain as an invalid instruction.", "": "An instruction is designated to remain as an invalid instruction.", "Abstract": "An instruction is designated to remain as an invalid instruction.", "Motivation": "The invalid instruction can be used as a distinct reason to abort execution.", "Specification": "The opcode0xfeis theINVALIDinstruction. It can be used to abort the execution (i.e. duplicates as anABORTinstruction).", "Backwards Compatibility": "This instruction was never used and therefore has no effect on past contracts.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- designated invalid evm instruction: Introduces an explicit INVALID opcode (0xfe), which functions as an abort or fail state for contract execution, distinct from other failure mechanisms.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 145, "url": "https://eips.ethereum.org/EIPS/eip-145", "title": "Bitwise shifting instructions in EVM", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")"], "sections": {"EIP-145: Bitwise shifting instructions in EVM": "Native bitwise shifting instructions are introduced, which are more efficient processing wise on the host and are cheaper to use by a contract.", "To Provide native bitwise shifting with cost on par with other arithmetic operations.": "Native bitwise shifting instructions are introduced, which are more efficient processing wise on the host and are cheaper to use by a contract.", "Abstract": "Native bitwise shifting instructions are introduced, which are more efficient processing wise on the host and are cheaper to use by a contract.", "Motivation": "EVM is lacking bitwise shifting operators, but supports other logical and arithmetic operators. Shift operations can be implemented via arithmetic operators, but that has a higher cost and requires more processing time from the host. ImplementingSHLandSHRusing arithmetic cost each 35 gas, while the proposed instructions take 3 gas.", "Specification": "The following instructions are introduced:", "0x1b:SHL(shift left)": "TheSHLinstruction (shift left) pops 2 values from the stack, firstarg1and thenarg2, and pushes on the stackarg2shifted to the left byarg1number of bits. The result is equal to", "0x1c:SHR(logical shift right)": "TheSHRinstruction (logical shift right) pops 2 values from the stack, firstarg1and thenarg2, and pushes on the stackarg2shifted to the right byarg1number of bits with zero fill. The result is equal to", "0x1d:SAR(arithmetic shift right)": "TheSARinstruction (arithmetic shift right) pops 2 values from the stack, firstarg1and thenarg2, and pushes on the stackarg2shifted to the right byarg1number of bits with sign extension. The result is equal to", "Rationale": "Instruction operands were chosen to fit the more natural use case of shifting a value already on the stack. This means the operand order is swapped compared to most arithmetic instructions.", "Backwards Compatibility": "The newly introduced instructions have no effect on bytecode created in the past.", "Test Cases": "Client support:", "SHL(shift left)": "Client support:", "SHR(logical shift right)": "Client support:", "SAR(arithmetic shift right)": "Client support:", "Implementation": "Client support:", "Tests": "Sources:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- bitwise shifting instructions: Adds efficient bitwise shift operations: SHL (shift left), SHR (logical shift right), and SAR (arithmetic shift right), improving processing efficiency by lowering gas costs compared to arithmetic-based shifting.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 150, "url": "https://eips.ethereum.org/EIPS/eip-150", "title": "Gas cost changes for IO-heavy operations", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-150: Gas cost changes for IO-heavy operations": "Tangerine Whistle.", "": "Tangerine Whistle.", "Meta reference": "Tangerine Whistle.", "Parameters": "Ifblock.number >= FORK_BLKNUM, then:", "Specification": "Ifblock.number >= FORK_BLKNUM, then:", "Rationale": "Recent denial-of-service attacks have shown that opcodes that read the state tree are under-priced relative to other opcodes. There are software changes that have been made, are being made and can be made in order to mitigate the situation; however, the fact will remain that such opcodes will be by a substantial margin the easiest known mechanism to degrade network performance via transaction spam. The concern arises because it takes a long time to read from disk, and is additionally a risk to future sharding proposals as the \u201cattack transactions\u201d that have so far been most successful in degrading network performance would also require tens of megabytes to provide Merkle proofs for. This EIP increases the cost of storage reading opcodes to address this concern. The costs have been derived from an updated version of the calculation table used to generate the 1.0 gas costs: https://docs.google.com/spreadsheets/d/15wghZr-Z6sRSMdmRmhls9dVXTOpxKy8Y64oy9MvDZEQ/edit#gid=0; the rules attempt to target a limit of 8 MB of data that needs to be read in order to process a block, and include an estimate of 500 bytes for a Merkle proof for SLOAD and 1000 for an account.", "References": "Please cite this document as:", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- gas cost changes for io-heavy operations: Adjusts the gas costs for several operations (e.g., EXTCODESIZE, BALANCE, SLOAD, etc.) to address inefficiencies and DoS vulnerabilities due to underpricing of IO-heavy operations.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 152, "url": "https://eips.ethereum.org/EIPS/eip-152", "title": "Add BLAKE2 compression function `F` precompile", "authors": ["Tjaden Hess\u00a0<", "tah83@cornell.edu", ">", "Matt Luongo\u00a0(", "@mhluongo", ")", "Piotr Dyraga\u00a0(", "@pdyraga", ")", "James Hancock\u00a0(", "@MadeOfTin", ")"], "sections": {"EIP-152: Add BLAKE2 compression function `F` precompile": "This EIP will enable the BLAKE2b hash function and other higher-round 64-bit BLAKE2 variants to run cheaply on the EVM, allowing easier interoperability between Ethereum and Zcash as well as other Equihash-based PoW coins.", "": "This EIP will enable the BLAKE2b hash function and other higher-round 64-bit BLAKE2 variants to run cheaply on the EVM, allowing easier interoperability between Ethereum and Zcash as well as other Equihash-based PoW coins.", "Simple Summary": "This EIP will enable the BLAKE2b hash function and other higher-round 64-bit BLAKE2 variants to run cheaply on the EVM, allowing easier interoperability between Ethereum and Zcash as well as other Equihash-based PoW coins.", "Abstract": "This EIP introduces a new precompiled contract which implements the compression functionFused in the BLAKE2 cryptographic hashing algorithm, for the purpose of allowing interoperability between the EVM and Zcash, as well as introducing more flexible cryptographic hash primitives to the EVM.", "Motivation": "Besides being a useful cryptographic hash function and SHA3 finalist, BLAKE2 allows for efficient verification of the Equihash PoW used in Zcash, making a BTC Relay - style SPV client possible on Ethereum. A single verification of an Equihash PoW verification requires 512 iterations of the hash function, making verification of Zcash block headers prohibitively expensive if a Solidity implementation of BLAKE2 is used.", "Specification": "We propose adding a precompiled contract at address0x09wrapping theBLAKE2Fcompression function.", "Example Usage in Solidity": "The precompile can be wrapped easily in Solidity to provide a more development-friendly interface toF.", "Gas costs and benchmarks": "Each operation will costGFROUND * roundsgas, whereGFROUND = 1. Detailed benchmarks are presented in the benchmarks appendix section.", "Rationale": "BLAKE2 is an excellent candidate for precompilation. BLAKE2 is heavily optimized for modern 64-bit CPUs, specifically utilizing 24 and 63-bit rotations to allow parallelism through SIMD instructions and little-endian arithmetic. These characteristics provide exceptional speed on native CPUs: 3.08 cycles per byte, or 1 gibibyte per second on an Intel i5.", "Backwards Compatibility": "There is very little risk of breaking backwards-compatibility with this EIP, the sole issue being if someone were to build a contract relying on the address at0x09being empty. The likelihood of this is low, and should specific instances arise, the address could be chosen to be any arbitrary value with negligible risk of collision.", "Test Cases": "An initial implementation of theFfunction in Go, adapted from the standard library, can be found in ourGolang BLAKE2 library fork. There\u2019s also an implementation of the precompile in our fork ofgo-ethereum.", "Implementation": "An initial implementation of theFfunction in Go, adapted from the standard library, can be found in ourGolang BLAKE2 library fork. There\u2019s also an implementation of the precompile in our fork ofgo-ethereum.", "References": "For reference, further discussion on this EIP also occurred in the following PRs and issues", "Appendix - benchmarks": "Assuming ecRecover precompile is perfectly priced, we executed a set of benchmarks comparing Blake2b F compression function precompile with ecRecover precompile. For benchmarks, we used 3.1 GHz Intel Core i7 64-bit machine.", "12 rounds": "An average gas price of F precompile call with 12 rounds compared to ecRecover should have been6.74153and it gives0.5618gas per round.", "1200 rounds": "An average gas price of F precompile call with 1200 rounds compared to ecRecover should have been436.1288and it gives0.3634gas per round.", "1 round": "An average gas price of F precompile call with 1 round compared to ecRecover should have been2.431701. However, in this scenario the call cost would totally overshadow the dynamic cost anyway.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 155, "url": "https://eips.ethereum.org/EIPS/eip-155", "title": "Simple replay attack protection", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-155: Simple replay attack protection": "Spurious Dragon", "": "Spurious Dragon", "Hard fork": "Spurious Dragon", "Parameters": "Ifblock.number >= FORK_BLKNUMandCHAIN_IDis available, then when computing the hash of a transaction for the purposes of signing, instead of hashing only six rlp encoded elements(nonce, gasprice, startgas, to, value, data), youSHOULDhash nine rlp encoded elements(nonce, gasprice, startgas, to, value, data, chainid, 0, 0).  If you do, then thevof the signatureMUSTbe set to{0,1} + CHAIN_ID * 2 + 35where{0,1}is the parity of theyvalue of the curve point for whichris the x-value in the secp256k1 signing process.  If you choose to only hash 6 values, thenvcontinues to be set to{0,1} + 27as previously.", "Specification": "Ifblock.number >= FORK_BLKNUMandCHAIN_IDis available, then when computing the hash of a transaction for the purposes of signing, instead of hashing only six rlp encoded elements(nonce, gasprice, startgas, to, value, data), youSHOULDhash nine rlp encoded elements(nonce, gasprice, startgas, to, value, data, chainid, 0, 0).  If you do, then thevof the signatureMUSTbe set to{0,1} + CHAIN_ID * 2 + 35where{0,1}is the parity of theyvalue of the curve point for whichris the x-value in the secp256k1 signing process.  If you choose to only hash 6 values, thenvcontinues to be set to{0,1} + 27as previously.", "Example": "Consider a transaction withnonce = 9,gasprice = 20 * 10**9,startgas = 21000,to = 0x3535353535353535353535353535353535353535,value = 10**18,data=''(empty).", "Rationale": "This would provide a way to send transactions that work on Ethereum without working on ETC or the Morden testnet. ETC is encouraged to adopt this EIP but replacingCHAIN_IDwith a different value, and all future testnets, consortium chains and alt-etherea are encouraged to adopt this EIP replacingCHAIN_IDwith a unique value.", "List of Chain ID\u2019s:": "Find more chain ID\u2019s onchainid.networkand contribute toethereum-lists/chains.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- simple replay attack protection: Introduces a method for protecting Ethereum from replay attacks by adding a chainid field to transaction signing, differentiating transactions across chains and preventing cross-chain replay.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 158, "url": "https://eips.ethereum.org/EIPS/eip-158", "title": "State clearing", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-158: State clearing": "For all blocks whereblock.number >= FORK_BLKNUM(TBA):", "": "For all blocks whereblock.number >= FORK_BLKNUM(TBA):", "Specification": "For all blocks whereblock.number >= FORK_BLKNUM(TBA):", "Specification (1c)": "Do not implement point 2 above (ie. no new empty accounts can be created, but existing ones are not automatically destroyed unless their state is actuallychanged). Instead, during each block starting from (and including) N and ending when there are no null accounts left, select the 1000 null accounts that are left-most in order of sha3(address), and delete them (ordering by hash is necessary so as to allow the accounts to be easily found by iterating the tree).", "Rationale": "This removes a large number of empty accounts that have been put in the state at very low cost due to flaws in earlier versions of the Ethereum protocol, thereby greatly reducing state size and hence both reducing the hard disk load of a full client and reducing the time for a fast sync. Additionally, it simplifies the protocol in the long term, as once all \u201cempty\u201d objects are cleared out there is no longer any meaningful distinction between an account being empty and being nonexistent, and indeed one can simply view nonexistence as a compact representation of emptiness.", "References": "Please cite this document as:", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- state clearing: Proposes the deletion of empty accounts (accounts with zero balance, nonce, code, and storage) to reduce state size, simplify execution, and enhance client performance.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 160, "url": "https://eips.ethereum.org/EIPS/eip-160", "title": "EXP cost increase", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-160: EXP cost increase": "Spurious Dragon", "": "Spurious Dragon", "Hard fork": "Spurious Dragon", "Parameters": "Ifblock.number >= FORK_BLKNUM, increase the gas cost of EXP from 10 + 10 per byte in the exponent to 10 + 50 per byte in the exponent.", "Specification": "Ifblock.number >= FORK_BLKNUM, increase the gas cost of EXP from 10 + 10 per byte in the exponent to 10 + 50 per byte in the exponent.", "Rationale": "Benchmarks suggest that EXP is currently underpriced by a factor of about 4\u20138.", "References": "Please cite this document as:", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- exp cost increase: Increases the gas cost of the EXP opcode to better reflect its computational intensity, preventing underpricing.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 161, "url": "https://eips.ethereum.org/EIPS/eip-161", "title": "State trie clearing (invariant-preserving alternative)", "authors": ["Gavin Wood\u00a0(", "@gavofyork", ")"], "sections": {"EIP-161: State trie clearing (invariant-preserving alternative)": "Spurious Dragon", "": "Spurious Dragon", "Hard fork": "Spurious Dragon", "Parameters": "a. Account creation transactions and theCREATEoperation SHALL, prior to the execution of the initialisation code,incrementthenonceover and above its normal starting value byone(for normal networks, this will be simply 1, however test-nets with non-zero default starting nonces will be different).", "Specification": "a. Account creation transactions and theCREATEoperation SHALL, prior to the execution of the initialisation code,incrementthenonceover and above its normal starting value byone(for normal networks, this will be simply 1, however test-nets with non-zero default starting nonces will be different).", "Rationale": "Same as #158 except that several edge cases are avoided since we do not break invariants:", "Addendum (2017-08-15)": "On 2016-11-24, a consensus bug occurred due to two implementations having different behavior in the case of state reverts.[3] The specification was amended to clarify that empty account deletions are reverted when the state is reverted.", "References": "Please cite this document as:", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- state trie clearing: Introduces changes to prevent accounts from transitioning from non-existent to empty state and ensures that empty accounts are deleted after transactions.\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 170, "url": "https://eips.ethereum.org/EIPS/eip-170", "title": "Contract code size limit", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-170: Contract code size limit": "Spurious Dragon", "": "Spurious Dragon", "Hard fork": "Spurious Dragon", "Parameters": "Ifblock.number >= FORK_BLKNUM, then if contract creation initialization returns data with length ofmore thanMAX_CODE_SIZEbytes, contract creation fails with an out of gas error.", "Specification": "Ifblock.number >= FORK_BLKNUM, then if contract creation initialization returns data with length ofmore thanMAX_CODE_SIZEbytes, contract creation fails with an out of gas error.", "Rationale": "Currently, there remains one slight quadratic vulnerability in Ethereum: when a contract is called, even though the call takes a constant amount of gas, the call can trigger O(n) cost in terms of reading the code from disk, preprocessing the code for VM execution, and also adding O(n) data to the Merkle proof for the block\u2019s proof-of-validity. At current gas levels, this is acceptable even if suboptimal. At the higher gas levels that could be triggered in the future, possibly very soon due to dynamic gas limit rules, this would become a greater concern\u2014not nearly as serious as recent denial of service attacks, but still inconvenient especially for future light clients verifying proofs of validity or invalidity. The solution is to put a hard cap on the size of an object that can be saved to the blockchain, and do so non-disruptively by setting the cap at a value slightly higher than what is feasible with current gas limits.", "References": "Please cite this document as:", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- contract code size limit: Sets a hard limit on contract size at 0x6000 bytes, and if a contract exceeds this size during creation, it results in an out-of-gas error.\n- max_code_size: The maximum size of EOF contract code is increased to 64 KiB, allowing more complex contracts to be deployed."}
{"eip": 196, "url": "https://eips.ethereum.org/EIPS/eip-196", "title": "Precompiled contracts for addition and scalar multiplication on the elliptic curve alt_bn128", "authors": ["Christian Reitwiessner\u00a0<", "chris@ethereum.org", ">"], "sections": {"EIP-196: Precompiled contracts for addition and scalar multiplication on the elliptic curve alt_bn128": "Precompiled contracts for elliptic curve operations are required in order to perform zkSNARK verification within the block gas limit.", "": "Precompiled contracts for elliptic curve operations are required in order to perform zkSNARK verification within the block gas limit.", "Simple Summary": "Precompiled contracts for elliptic curve operations are required in order to perform zkSNARK verification within the block gas limit.", "Abstract": "This EIP suggests to add precompiled contracts for addition and scalar multiplication on a specific pairing-friendly elliptic curve. This can in turn be combined withEIP-197to verify zkSNARKs in Ethereum smart contracts. The general benefit of zkSNARKs for Ethereum is that it will increase the privacy for users (because of the Zero-Knowledge property) and might also be a scalability solution (because of the succinctness and efficient verifiability property).", "Motivation": "Current smart contract executions on Ethereum are fully transparent, which makes them unsuitable for several use-cases that involve private information like the location, identity or history of past transactions. The technology of zkSNARKs could be a solution to this problem. While the Ethereum Virtual Machine can make use of zkSNARKs in theory, they are currently too expensive\nto fit the block gas limit. Because of that, this EIP proposes to specify certain parameters for some elementary primitives that enable zkSNARKs so that they can be implemented more efficiently and the gas cost be reduced.", "Specification": "Ifblock.number >= BYZANTIUM_FORK_BLKNUM, add precompiled contracts for point addition (ADD)  and scalar multiplication (MUL) on the elliptic curve \u201calt_bn128\u201d.", "Encoding": "Field elements and scalars are encoded as 32 byte big-endian numbers. Curve points are encoded as two field elements(x, y), where the point at infinity is encoded as(0, 0).", "Exact semantics": "Invalid input: For both contracts, if any input point does not lie on the curve or any of the field elements (point coordinates) is equal or larger than the field modulus p, the contract fails. The scalar can be any number between0and2**256-1.", "Gas costs": "The specific curvealt_bn128was chosen because it is particularly well-suited for zkSNARKs, or, more specifically their verification building block of pairing functions. Furthermore, by choosing this curve, we can use synergy effects with ZCash and re-use some of their components and artifacts.", "Rationale": "The specific curvealt_bn128was chosen because it is particularly well-suited for zkSNARKs, or, more specifically their verification building block of pairing functions. Furthermore, by choosing this curve, we can use synergy effects with ZCash and re-use some of their components and artifacts.", "Backwards Compatibility": "As with the introduction of any precompiled contract, contracts that already use the given addresses will change their semantics. Because of that, the addresses are taken from the \u201creserved range\u201d below 256.", "Test Cases": "Inputs to test:", "Implementation": "Implementation of these primitives are available here:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 197, "url": "https://eips.ethereum.org/EIPS/eip-197", "title": "Precompiled contracts for optimal ate pairing check on the elliptic curve alt_bn128", "authors": ["Vitalik Buterin\u00a0<", "vitalik@ethereum.org", ">", "Christian Reitwiessner\u00a0<", "chris@ethereum.org", ">"], "sections": {"EIP-197: Precompiled contracts for optimal ate pairing check on the elliptic curve alt_bn128": "Precompiled contracts for elliptic curve pairing operations are required in order to perform zkSNARK verification within the block gas limit.", "": "Precompiled contracts for elliptic curve pairing operations are required in order to perform zkSNARK verification within the block gas limit.", "Simple Summary": "Precompiled contracts for elliptic curve pairing operations are required in order to perform zkSNARK verification within the block gas limit.", "Abstract": "This EIP suggests to add precompiled contracts for a pairing function on a specific pairing-friendly elliptic curve. This can in turn be combined withEIP-196to verify zkSNARKs in Ethereum smart contracts. The general benefit of zkSNARKs for Ethereum is that it will increase the privacy for users (because of the Zero-Knowledge property) and might also be a scalability solution (because of the succinctness and efficient verifiability property).", "Motivation": "Current smart contract executions on Ethereum are fully transparent, which makes them unsuitable for several use-cases that involve private information like the location, identity or history of past transactions. The technology of zkSNARKs could be a solution to this problem. While the Ethereum Virtual Machine can make use of zkSNARKs in theory, they are currently too expensive\nto fit the block gas limit. Because of that, this EIP proposes to specify certain parameters for some elementary primitives that enable zkSNARKs so that they can be implemented more efficiently and the gas cost be reduced.", "Specification": "For blocks whereblock.number >= BYZANTIUM_FORK_BLKNUM, add a precompiled contracts for a bilinear function on groups on the elliptic curve \u201calt_bn128\u201d. We will define the precompiled contract in terms of a discrete logarithm. The discrete logarithm is of course assumed to be hard to compute, but we will give an equivalent specification that makes use of elliptic curve pairing functions which can be efficiently computed below.", "Definition of the groups": "The groupsG_1andG_2are cyclic groups of prime orderq = 21888242871839275222246405745257275088548364400416034343698204186575808495617.", "Encoding": "Elements ofF_pare encoded as 32 byte big-endian numbers. An encoding value ofpor larger is invalid.", "Gas costs": "The gas costs of the precompiled contract are80 000 * k + 100 000, wherekis the number of\npoints or, equivalently, the length of the input divided by 192.", "Rationale": "The specific curvealt_bn128was chosen because it is particularly well-suited for zkSNARKs, or, more specifically their verification building block of pairing functions. Furthermore, by choosing this curve, we can use synergy effects with ZCash and re-use some of their components and artifacts.", "Backwards Compatibility": "As with the introduction of any precompiled contract, contracts that already use the given addresses will change their semantics. Because of that, the addresses are taken from the \u201creserved range\u201d below 256.", "Test Cases": "To be written.", "Implementation": "The precompiled contract can be implemented using elliptic curve pairing functions, more specifically, an optimal ate pairing on the alt_bn128 curve, which can be implemented efficiently. In order to see that, first note that a pairing functione: G_1 x G_2 -> G_Tfulfills the following properties (G_1andG_2are written additively,G_Tis written multiplicatively):", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 198, "url": "https://eips.ethereum.org/EIPS/eip-198", "title": "Big integer modular exponentiation", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-198: Big integer modular exponentiation": "At address 0x00\u2026\u202605, add a precompile that expects input in the following format:", "": "At address 0x00\u2026\u202605, add a precompile that expects input in the following format:", "Parameters": "At address 0x00\u2026\u202605, add a precompile that expects input in the following format:", "Specification": "At address 0x00\u2026\u202605, add a precompile that expects input in the following format:", "Rationale": "This allows for efficient RSA verification inside of the EVM, as well as other forms of number theory-based cryptography. Note that adding precompiles for addition and subtraction is not required, as the in-EVM algorithm is efficient enough, and multiplication can be done through this precompile viaa * b = ((a + b)**2 - (a - b)**2) / 4.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 211, "url": "https://eips.ethereum.org/EIPS/eip-211", "title": "New opcodes: RETURNDATASIZE and RETURNDATACOPY", "authors": ["Christian Reitwiessner\u00a0<", "chris@ethereum.org", ">"], "sections": {"EIP-211: New opcodes: RETURNDATASIZE and RETURNDATACOPY": "A mechanism to allow returning arbitrary-length data inside the EVM has been requested for quite a while now. Existing proposals always had very intricate problems associated with charging gas. This proposal solves the same problem while at the same time, it has a very simple gas charging mechanism and requires minimal changes to the call opcodes. Its workings are very similar to the way calldata is handled already; after a call, return data is kept inside a virtual buffer from which the caller can copy it (or parts thereof) into memory. At the next call, the buffer is overwritten. This mechanism is 100% backwards compatible.", "": "A mechanism to allow returning arbitrary-length data inside the EVM has been requested for quite a while now. Existing proposals always had very intricate problems associated with charging gas. This proposal solves the same problem while at the same time, it has a very simple gas charging mechanism and requires minimal changes to the call opcodes. Its workings are very similar to the way calldata is handled already; after a call, return data is kept inside a virtual buffer from which the caller can copy it (or parts thereof) into memory. At the next call, the buffer is overwritten. This mechanism is 100% backwards compatible.", "Simple Summary": "A mechanism to allow returning arbitrary-length data inside the EVM has been requested for quite a while now. Existing proposals always had very intricate problems associated with charging gas. This proposal solves the same problem while at the same time, it has a very simple gas charging mechanism and requires minimal changes to the call opcodes. Its workings are very similar to the way calldata is handled already; after a call, return data is kept inside a virtual buffer from which the caller can copy it (or parts thereof) into memory. At the next call, the buffer is overwritten. This mechanism is 100% backwards compatible.", "Abstract": "Please see summary.", "Motivation": "In some situations, it is vital for a function to be able to return data whose length cannot be anticipated before the call. In principle, this can be solved without alterations to the EVM, for example by splitting the call into two calls where the first is used to compute only the size. All of these mechanisms, though, are very expensive in at least some situations. A very useful example of such a worst-case situation is a generic forwarding contract; a contract that takes call data, potentially makes some checks and then forwards it as is to another contract. The return data should of course be transferred in a similar way to the original caller. Since the contract is generic and does not know about the contract it calls, there is no way to determine the size of the output without adapting the called contract accordingly or trying a logarithmic number of calls.", "Specification": "Ifblock.number >= BYZANTIUM_FORK_BLKNUM, add two new opcodes and amend the semantics of any opcode that creates a new call frame (likeCALL,CREATE,DELEGATECALL, \u2026) called call-like opcodes in the following. It is assumed that the EVM (to be more specific: an EVM call frame) has a new internal buffer of variable size, called the return data buffer. This buffer is created empty for each new call frame. Upon executing any call-like opcode, the buffer is cleared (its size is set to zero). After executing a call-like opcode, the complete return data (or failure data, seeEIP-140) of the call is stored in the return data buffer (of the caller), and its size changed accordingly. As an exception,CREATEandCREATE2are considered to return the empty buffer in the success case and the failure data in the failure case. If the call-like opcode is executed but does not really instantiate a call frame (for example due to insufficient funds for a value transfer or if the called contract does not exist), the return data buffer is empty.", "Rationale": "Other solutions that would allow returning dynamic data were considered, but they all had to deduct the gas from the call opcode and thus were both complicated to implement and specify (5/8). Since this proposal is very similar to the way calldata is handled, it fits nicely into the concept. Furthermore, the eWASM architecture already handles return data in exactly the same way.", "Backwards Compatibility": "This proposal introduces two new opcodes and stays fully backwards compatible apart from that.", "Test Cases": "Copyright and related rights waived viaCC0.", "Implementation": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution ."}
{"eip": 214, "url": "https://eips.ethereum.org/EIPS/eip-214", "title": "New opcode STATICCALL", "authors": ["Vitalik Buterin\u00a0<", "vitalik@ethereum.org", ">", "Christian Reitwiessner\u00a0<", "chris@ethereum.org", ">"], "sections": {"EIP-214: New opcode STATICCALL": "To increase smart contract security, this proposal adds a new opcode that can be used to call another contract (or itself) while disallowing any modifications to the state during the call (and its subcalls, if present).", "": "To increase smart contract security, this proposal adds a new opcode that can be used to call another contract (or itself) while disallowing any modifications to the state during the call (and its subcalls, if present).", "Simple Summary": "To increase smart contract security, this proposal adds a new opcode that can be used to call another contract (or itself) while disallowing any modifications to the state during the call (and its subcalls, if present).", "Abstract": "This proposal adds a new opcode that can be used to call another contract (or itself) while disallowing any modifications to the state during the call (and its subcalls, if present). Any opcode that attempts to perform such a modification (see below for details) will result in an exception instead of performing the modification.", "Motivation": "Currently, there is no restriction about what a called contract can do, as long as the computation can be performed with the amount of gas provided. This poses certain difficulties about smart contract engineers; after a regular call, unless you know the called contract, you cannot make any assumptions about the state of the contracts. Furthermore, because you cannot know the order of transactions before they are confirmed by miners, not even an outside observer can be sure about that in all cases.", "Specification": "Introduce a newSTATICflag to the virtual machine. This flag is set tofalseinitially. Its value is always copied to sub-calls with an exception for the new opcode below.", "Rationale": "This allows contracts to make calls that are clearly non-state-changing, reassuring developers and reviewers that re-entrancy bugs or other problems cannot possibly arise from that particular call; it is a pure function that returns an output and does nothing else. This may also make purely functional HLLs easier to implement.", "Backwards Compatibility": "This proposal adds a new opcode but does not modify the behaviour of other opcodes and thus is backwards compatible for old contracts that do not use the new opcode and are not called via the new opcode.", "Test Cases": "To be written.", "Implementation": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 225, "url": "https://eips.ethereum.org/EIPS/eip-225", "title": "Clique proof-of-authority consensus protocol", "authors": ["P\u00e9ter Szil\u00e1gyi\u00a0<", "peterke@gmail.com", ">"], "sections": {"EIP-225: Clique proof-of-authority consensus protocol": "Clique is a proof-of-authority consensus protocol. It shadows the design of Ethereum mainnet, so it can be added to any client with minimal effort.", "": "Clique is a proof-of-authority consensus protocol. It shadows the design of Ethereum mainnet, so it can be added to any client with minimal effort.", "Abstract": "Clique is a proof-of-authority consensus protocol. It shadows the design of Ethereum mainnet, so it can be added to any client with minimal effort.", "Motivation": "Ethereum\u2019s first official testnet was Morden. It ran from July 2015 to about November 2016, when due to the accumulated junk and some testnet consensus issues between Geth and Parity, it was finally laid to rest in favor of a testnet reboot.", "Standardized proof-of-authority": "As reasoned above, proof-of-work cannot work securely in a network with no value. Ethereum has its long term goal of proof-of-stake based on Casper, but that is heavy research so we cannot rely on that any time soon to fix today\u2019s problems. One solution however is easy enough to implement, yet effective enough to fix the testnet properly, namely a proof-of-authority scheme.", "Design constraints": "There are two approaches to syncing a blockchain in general:", "Repurposing header fields for signing and voting": "The most obvious field that currently is used solely asfun metadatais the 32 byteextra-datasection in block headers. Miners usually place their client and version in there, but some fill it with alternative \u201cmessages\u201d. The protocol would extend this fieldtowith 65 bytes with the purpose of a secp256k1 miner signature. This would allow anyone obtaining a block to verify it against a list of authorized signers. It also makes theminersection in block headers obsolete (since the address can be derived from the signature).", "Attack vector: Malicious signer": "It may happen that a malicious user gets added to the list of signers, or that a signer key/machine is compromised. In such a scenario the protocol needs to be able to defend itself against reorganizations and spamming. The proposed solution is that given a list of N authorized signers, any signer may only mint 1 block out of every K. This ensures that damage is limited, and the remainder of the miners can vote out the malicious user.", "Attack vector: Censoring signer": "Another interesting attack vector is if a signer (or group of signers) attempts to censor out blocks that vote on removing them from the authorization list. To work around this, we restrict the allowed minting frequency of signers to 1 out of N/2. This ensures that malicious signers need to control at least 51% of signing accounts, at which case it\u2019s game over anyway.", "Attack vector: Spamming signer": "A final small attack vector is that of malicious signers injecting new vote proposals inside every block they mint. Since nodes need to tally up all votes to create the actual list of authorized signers, they need to track all votes through time. Without placing a limit on the vote window, this could grow slowly, yet unbounded. The solution is to place amovingwindow of W blocks after which votes are considered stale.A sane window might be 1-2 epochs.We\u2019ll call this an epoch.", "Attack vector: Concurrent blocks": "If the number of authorized signers are N, and we allow each signer to mint 1 block out of K, then at any point in time N-K+1 miners are allowed to mint. To avoid these racing for blocks, every signer would add a small random \u201coffset\u201d to the time it releases a new block. This ensures that small forks are rare, but occasionally still happen (as on the main net). If a signer is caught abusing it\u2019s authority and causing chaos, it can be voted out.", "Specification": "We define the following constants:", "Authorizing a block": "To authorize a block for the network, the signer needs to sign the block\u2019s sighash containingeverything except the signature itself. This means that this hash contains every field of the header (nonceandmixDigestincluded), and also theextraDatawith the exception of the 65 byte signature suffix. The fields are hashed in the order of their definition in the yellow paper. Note that this sighash differs from the final block hash which also includes the signature.", "Voting on signers": "Every epoch transition (genesis block included) acts as a stateless checkpoint, from which capable clients should be able to sync without requiring any previous state. This means epoch headersmust notcontain votes, all non settled votes are discarded, and tallying starts from scratch.", "Test Cases": "A reference implementation is part ofgo-ethereumand has been functioning as the consensus engine behind theRinkebytestnet since April, 2017.", "Implementation": "A reference implementation is part ofgo-ethereumand has been functioning as the consensus engine behind theRinkebytestnet since April, 2017.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- clique proof-of-authority consensus protocol: Proposes a proof-of-authority consensus protocol designed for Ethereum testnets to address issues in low-hashrate PoW networks.\n- genesis: Log entry in system_logs for initial balances at network genesis .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 649, "url": "https://eips.ethereum.org/EIPS/eip-649", "title": "Metropolis Difficulty Bomb Delay and Block Reward Reduction", "authors": ["Afri Schoedon\u00a0(", "@5chdn", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-649: Metropolis Difficulty Bomb Delay and Block Reward Reduction": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) slowly accelerating. This EIP proposes to delay the difficulty bomb for approximately one and a half year and to reduce the block rewards with the Byzantium fork, the first part of the Metropolis fork.", "": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) slowly accelerating. This EIP proposes to delay the difficulty bomb for approximately one and a half year and to reduce the block rewards with the Byzantium fork, the first part of the Metropolis fork.", "Simple Summary": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) slowly accelerating. This EIP proposes to delay the difficulty bomb for approximately one and a half year and to reduce the block rewards with the Byzantium fork, the first part of the Metropolis fork.", "Abstract": "Starting withBYZANTIUM_FORK_BLKNUMthe client will calculate the difficulty based on a fake block number suggesting the client that the difficulty bomb is adjusting around 3 million blocks later than previously specified with the Homestead fork. Furthermore, block rewards will be adjusted to a base of 3 ETH, uncle and nephew rewards will be adjusted accordingly.", "Motivation": "The Casper development and switch to proof-of-stake is delayed, the Ethash proof-of-work should be feasible for miners and allow sealing new blocks every 15 seconds on average for another one and a half years. With the delay of the ice age, there is a desire to not suddenly also increase miner rewards. The difficulty bomb has been known about for a long time and now it\u2019s going to stop from happening. In order to maintain stability of the system, a block reward reduction that offsets the ice age delay would leave the system in the same general state as before. Reducing the reward also decreases the likelihood of a miner driven chain split as Ethereum approaches proof-of-stake.", "Specification": "For the purposes ofcalc_difficulty, simply replace the use ofblock.number, as used in the exponential ice age component, with the formula:", "Rationale": "This will delay the ice age by 42 million seconds (approximately 1.4 years), so the chain would be back at 30 second block times at the end of 2018. An alternate proposal was to add special rules to the difficulty calculation to effectivelypausethe difficulty between different blocks. This would lead to similar results.", "Backwards Compatibility": "This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation, as well as the block, uncle and nephew reward structure. Therefore, it should be included in a scheduled hardfork at a certain block number. It\u2019s suggested to include this EIP in the first of the two Metropolis hard-forks, theByzantiumfork.", "Test Cases": "Test cases exist in ethereum/tests#269.", "Implementation": "The following clients implemented EIP-649:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- metropolis difficulty bomb delay and block reward reduction: Proposes delaying the Ethereum difficulty bomb (ice age) by 1.4 years and reducing block rewards to 3 ETH as part of the Byzantium hard fork.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 658, "url": "https://eips.ethereum.org/EIPS/eip-658", "title": "Embedding transaction status code in receipts", "authors": ["Nick Johnson\u00a0<", "nick@ethereum.org", ">"], "sections": {"EIP-658: Embedding transaction status code in receipts": "This EIP replaces the intermediate state root field of the receipt with a status code indicating if the top-level call succeeded or failed.", "": "This EIP replaces the intermediate state root field of the receipt with a status code indicating if the top-level call succeeded or failed.", "Abstract": "This EIP replaces the intermediate state root field of the receipt with a status code indicating if the top-level call succeeded or failed.", "Motivation": "With the introduction of the REVERT opcode in EIP140, it is no longer possible for users to assume that a transaction failed iff it consumed all gas. As a result, there is no clear mechanism for callers to determine whether a transaction succeeded and the state changes contained in it were applied.", "Specification": "For blocks where block.number >= BYZANTIUM_FORK_BLKNUM, the intermediate state root is replaced by a status code, 0 indicating failure (due to any operation that can cause the transaction or top-level call to revert) and 1 indicating success.", "Rationale": "This constitutes a minimal possible change that permits fetching the success/failure state of transactions, preserving existing capabilities with minimum disruption or additional work for Metropolis.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- transaction status code in receipts: Replaces the intermediate state root in transaction receipts with a status code (1 for success, 0 for failure), allowing users to easily determine transaction outcomes.\n- revert: All calls to this opcode must emit a log with revert data."}
{"eip": 684, "url": "https://eips.ethereum.org/EIPS/eip-684", "title": "Revert creation in case of collision", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Renan Rodrigues de Souza\u00a0(", "@RenanSouza2", ")"], "sections": {"EIP-684: Revert creation in case of collision": "This EIP causes contract creation to throw an error when attempted at an address with pre-existing code. This prevents an attack consisting of deploying contract code and later changing the code arbitrarily by \u201ccreating\u201d an account at that existing address.", "Revert contract creation if address already has code": "This EIP causes contract creation to throw an error when attempted at an address with pre-existing code. This prevents an attack consisting of deploying contract code and later changing the code arbitrarily by \u201ccreating\u201d an account at that existing address.", "Abstract": "This EIP causes contract creation to throw an error when attempted at an address with pre-existing code. This prevents an attack consisting of deploying contract code and later changing the code arbitrarily by \u201ccreating\u201d an account at that existing address.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "One of the core tenants of smart contracts is that its code will not change. However with sufficient computing power an attacker can change the code stored in an address to any other code, steal funds or execute other malicious activity.", "Backwards Compatibility": "This is an execution layer upgrade, and so it requires a hard fork.", "Test Cases": "Given a genesis allocation of", "Security Considerations": "This EIP is a security upgrade: it enforces the imutability of deployed code.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- genesis: Log entry in system_logs for initial balances at network genesis .\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1014, "url": "https://eips.ethereum.org/EIPS/eip-1014", "title": "Skinny CREATE2", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-1014: Skinny CREATE2": "Adds a new opcode (CREATE2) at0xf5, which takes 4 stack arguments: endowment, memory_start, memory_length, salt. Behaves identically toCREATE(0xf0), except usingkeccak256( 0xff ++ address ++ salt ++ keccak256(init_code))[12:]instead of the usual sender-and-nonce-hash as the address where the contract is initialized at.", "": "Adds a new opcode (CREATE2) at0xf5, which takes 4 stack arguments: endowment, memory_start, memory_length, salt. Behaves identically toCREATE(0xf0), except usingkeccak256( 0xff ++ address ++ salt ++ keccak256(init_code))[12:]instead of the usual sender-and-nonce-hash as the address where the contract is initialized at.", "Specification": "Adds a new opcode (CREATE2) at0xf5, which takes 4 stack arguments: endowment, memory_start, memory_length, salt. Behaves identically toCREATE(0xf0), except usingkeccak256( 0xff ++ address ++ salt ++ keccak256(init_code))[12:]instead of the usual sender-and-nonce-hash as the address where the contract is initialized at.", "Motivation": "Allows interactions to (actually or counterfactually in channels) be made with addresses that do not exist yet on-chain but can be relied on to only possibly eventually contain code that has been created by a particular piece of init code. Important for state-channel use cases that involve counterfactual interactions with contracts.", "Rationale": "Since address calculation depends on hashing theinit_code, it would leave clients open to DoS attacks if executions could repeatedly cause hashing of large pieces ofinit_code, since expansion of memory is paid for only once. This EIP uses the same cost-per-word as theSHA3opcode.", "Clarifications": "Theinit_codeis the code that, when executed, produces the runtime bytecode that will be placed into the state, and which typically is used by high level languages to implement a \u2018constructor\u2019.", "Examples": "Example 0", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- skinny create2: Introduces the CREATE2 opcode, allowing contracts to be created at addresses that depend on a hash of the sender's address, a salt, and the contract's initialization code.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1052, "url": "https://eips.ethereum.org/EIPS/eip-1052", "title": "EXTCODEHASH opcode", "authors": ["Nick Johnson\u00a0<", "arachnid@notdot.net", ">", "Pawe\u0142 Bylica\u00a0<", "pawel@ethereum.org", ">"], "sections": {"EIP-1052: EXTCODEHASH opcode": "This EIP specifies a new opcode, which returns the keccak256 hash of a contract\u2019s code.", "": "This EIP specifies a new opcode, which returns the keccak256 hash of a contract\u2019s code.", "Abstract": "This EIP specifies a new opcode, which returns the keccak256 hash of a contract\u2019s code.", "Motivation": "Many contracts need to perform checks on a contract\u2019s bytecode, but do not necessarily need the bytecode itself. For instance, a contract may want to check if another contract\u2019s bytecode is one of a set of permitted implementations, or it may perform analyses on code and whitelist any contract with matching bytecode if the analysis passes.", "Specification": "A new opcode,EXTCODEHASH, is introduced, with number0x3f. TheEXTCODEHASHtakes one argument from the stack, zeros the first 96 bits \nand pushes to the stack the keccak256 hash of the code of the account \nat the address being the remaining 160 bits.", "Rationale": "As described in the motivation section, this opcode is widely useful, and saves \non wasted gas in many cases.", "Backwards Compatibility": "There are no backwards compatibility concerns.", "Test Cases": "TBD", "Implementation": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- extcodehash opcode: Introduces the EXTCODEHASH opcode, which returns the keccak256 hash of a contract\u2019s code, allowing contracts to verify code without needing the entire bytecode.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1108, "url": "https://eips.ethereum.org/EIPS/eip-1108", "title": "Reduce alt_bn128 precompile gas costs", "authors": ["Antonio Salazar Cardozo\u00a0(", "@shadowfiend", ")", "Zachary Williamson\u00a0(", "@zac-williamson", ")"], "sections": {"EIP-1108: Reduce alt_bn128 precompile gas costs": "The elliptic curve arithmetic precompiles are currently overpriced. Re-pricing the precompiles would greatly assist a number of privacy solutions and scaling solutions on Ethereum.", "": "The elliptic curve arithmetic precompiles are currently overpriced. Re-pricing the precompiles would greatly assist a number of privacy solutions and scaling solutions on Ethereum.", "Simple Summary": "The elliptic curve arithmetic precompiles are currently overpriced. Re-pricing the precompiles would greatly assist a number of privacy solutions and scaling solutions on Ethereum.", "Abstract": "Changes in 2018 to the underlying library used by the official Go reference\nimplementation led to significant performance gains for theECADD,ECMUL,\nand pairing check precompiled contracts on thealt_bn128elliptic curve.", "Motivation": "Recently, the underlying library used by theofficial Go reference\nimplementationto implement theECADD(at address0x06),ECMUL(at address0x07), and pairing check (at\naddress0x08) precompiled contracts was shifted toCloudflare\u2019s bn256\nlibrary. Based on theinitial PR that\nintroduced this change,\nand corroborated ina later\nnote,\nthe computational cost ofECADD,ECMUL, and pairing checks (excepting the\nconstant) has dropped roughly an order of magnitude across the board.", "Specification": "Following is a table with the current gas cost and new gas cost:", "Rationale": "Fast elliptic curve cryptography is a keystone of a growing number of protocols built on top of Ethereum. To list a few:", "Existing protocols would benefit immensely from cheaper elliptic curve cryptography": "Fast elliptic curve cryptography is a keystone of a growing number of protocols built on top of Ethereum. To list a few:", "Cheaper elliptic curve cryptography can be used to trade storage for computation": "Solutions such as Rollup and Ignis can be used to batch groups of individual transactions into a zk-SNARK proof, with the on-chain state being represented by a small Merkle root, instead of multiple account balances.", "Parity and Geth already have fast algorithms that justify reduced gas costs": "This EIP does not require Parity or Geth to deploy new cryptographic libraries, as fast bn128 algorithms have already been integrated into these clients. This goal of proposing this EIP for Istanbul, is to supplementEIP-1829(arithmetic over generic elliptic curves), providing an immediate solution to the pressing problem of expensive cryptography, while more advanced solutions are developed, defined and deployed.", "Test Cases": "As no underlying algorithms are being changed, there are no additional test cases to specify.", "Implementation": "Both the Parity and Geth clients have already implemented cryptographic libraries that are fast enough to justify reducing the precompile gas costs. As a reference, here are a list of elliptic curve libraries, inC++,golangandrust, that support thebn128curve, and have run-times that are equal to or faster than the Parity benchmarks.", "Additional References": "@vbuterin independently proposed a similar reduction after this EIP was originally created, with similar rationale, asethereum/EIPs#1187.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1153, "url": "https://eips.ethereum.org/EIPS/eip-1153", "title": "Transient storage opcodes", "authors": ["Alexey Akhunov\u00a0(", "@AlexeyAkhunov", ")", "Moody Salem\u00a0(", "@moodysalem", ")"], "sections": {"EIP-1153: Transient storage opcodes": "This proposal introduces transient storage opcodes, which manipulate state that behaves identically to storage, except that transient storage is discarded after every transaction, andTSTOREis not subject to the gas stipend check as defined inEIP-2200. In other words, the values of transient storage are never deserialized from storage or serialized to storage. Thus transient storage is cheaper since it never requires disk access. Transient storage is accessible to smart contracts via 2 new opcodes,TLOADandTSTORE, where \u201cT\u201d stands for \u201ctransient:\u201d", "Add opcodes for manipulating state that behaves almost identically to storage but is discarded after every transaction": "This proposal introduces transient storage opcodes, which manipulate state that behaves identically to storage, except that transient storage is discarded after every transaction, andTSTOREis not subject to the gas stipend check as defined inEIP-2200. In other words, the values of transient storage are never deserialized from storage or serialized to storage. Thus transient storage is cheaper since it never requires disk access. Transient storage is accessible to smart contracts via 2 new opcodes,TLOADandTSTORE, where \u201cT\u201d stands for \u201ctransient:\u201d", "Abstract": "This proposal introduces transient storage opcodes, which manipulate state that behaves identically to storage, except that transient storage is discarded after every transaction, andTSTOREis not subject to the gas stipend check as defined inEIP-2200. In other words, the values of transient storage are never deserialized from storage or serialized to storage. Thus transient storage is cheaper since it never requires disk access. Transient storage is accessible to smart contracts via 2 new opcodes,TLOADandTSTORE, where \u201cT\u201d stands for \u201ctransient:\u201d", "Motivation": "Running a transaction in Ethereum can generate multiple nested frames of execution, each created byCALL(or similar) instructions. Contracts can be re-entered during the same transaction, in which case there are more than one frame belonging to one contract. Currently, these frames can communicate in two ways: via inputs/outputs passed viaCALLinstructions, and via storage updates. If there is an intermediate frame belonging to another untrusted contract, communication via inputs/outputs is not secure. Notable example is a reentrancy lock which cannot rely on the intermediate frame to pass through the state of the lock. Communication via storage (SSTORE/SLOAD) is costly. Transient storage is a dedicated and gas efficient solution to the problem of inter frame communication.", "Specification": "Two new opcodes are added to EVM,TLOAD(0x5c) andTSTORE(0x5d). (Note that previous drafts of this EIP specified the values0xb3and0xb4forTLOADandTSTORErespectively to avoid conflict with other EIPs. The conflict has since been removed.)", "Rationale": "Another option to solve the problem of inter-frame communication is repricing theSSTOREandSLOADopcodes to be cheaper for the transient storage use case. This has already been done as ofEIP-2200. However,EIP-3529reduced the maximum refund to only 20% of the transaction gas cost, which means the use of transient storage is severely limited.", "Backwards Compatibility": "This EIP requires a hard fork to implement.", "Test Cases": "A test suite for this EIP can be foundhere.", "Reference Implementation": "Because the transient storage must behave almost identically to storage within the context of a single transaction with regards to revert behavior, it is necessary to be able to revert to a previous state of transient storage within a transaction. At the same time reverts are exceptional cases and loads, stores and returns should be cheap.", "Security Considerations": "TSTOREpresents a new way to allocate memory on a node with linear cost. In other words, each TSTORE allows the developer to store 32 bytes for 100 gas, excluding any other required operations to prepare the stack. Given 30 million gas, the maximum amount of memory that can be allocated using TSTORE is:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- transient storage opcodes: Introduces TLOAD and TSTORE opcodes, which behave similarly to storage but discard values after each transaction, allowing more gas-efficient inter-frame communication.\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1234, "url": "https://eips.ethereum.org/EIPS/eip-1234", "title": "Constantinople Difficulty Bomb Delay and Block Reward Adjustment", "authors": ["Afri Schoedon\u00a0(", "@5chdn", ")"], "sections": {"EIP-1234: Constantinople Difficulty Bomb Delay and Block Reward Adjustment": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) slowly accelerating. This EIP proposes to delay the difficulty bomb for approximately 12 months and to reduce the block rewards with the Constantinople fork, the second part of the Metropolis fork.", "": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) slowly accelerating. This EIP proposes to delay the difficulty bomb for approximately 12 months and to reduce the block rewards with the Constantinople fork, the second part of the Metropolis fork.", "Simple Summary": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) slowly accelerating. This EIP proposes to delay the difficulty bomb for approximately 12 months and to reduce the block rewards with the Constantinople fork, the second part of the Metropolis fork.", "Abstract": "Starting withCNSTNTNPL_FORK_BLKNUMthe client will calculate the difficulty based on a fake block number suggesting the client that the difficulty bomb is adjusting around 5 million blocks later than previously specified with the Homestead fork. Furthermore, block rewards will be adjusted to a base of 2 ETH, uncle and nephew rewards will be adjusted accordingly.", "Motivation": "The Casper development and switch to proof-of-stake is delayed, the Ethash proof-of-work should be feasible for miners and allow sealing new blocks every 15 seconds on average for another 12 months. With the delay of the ice age, there is a desire to not suddenly also increase miner rewards. The difficulty bomb has been known about for a long time and now it\u2019s going to stop from happening. In order to maintain stability of the system, a block reward reduction that offsets the ice age delay would leave the system in the same general state as before. Reducing the reward also decreases the likelihood of a miner driven chain split as Ethereum approaches proof-of-stake.", "Specification": "For the purposes ofcalc_difficulty, simply replace the use ofblock.number, as used in the exponential ice age component, with the formula:", "Rationale": "This will delay the ice age by 29 million seconds (approximately 12 months), so the chain would be back at 30 second block times in winter 2019. An alternate proposal was to add special rules to the difficulty calculation to effectivelypausethe difficulty between different blocks. This would lead to similar results.", "Backwards Compatibility": "This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation, as well as the block, uncle and nephew reward structure. Therefore, it should be included in a scheduled hardfork at a certain block number. It\u2019s suggested to include this EIP in the second Metropolis hard-fork,Constantinople.", "Test Cases": "Test cases shall be created once the specification is to be accepted by the developers or implemented by the clients.", "Implementation": "The implementation in it\u2019s logic does not differ fromEIP-649; an implementation for Parity-Ethereum is available inparity-ethereum#9187.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- constantinople difficulty bomb delay and block reward adjustment: Proposes delaying the difficulty bomb by 12 months and reducing block rewards to 2 ETH with the Constantinople fork to maintain system stability.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1283, "url": "https://eips.ethereum.org/EIPS/eip-1283", "title": "Net gas metering for SSTORE without dirty maps", "authors": ["Wei Tang\u00a0(", "@sorpaas", ")"], "sections": {"EIP-1283: Net gas metering for SSTORE without dirty maps": "This EIP proposes net gas metering changes forSSTOREopcode, enabling\nnew usages for contract storage, and reducing excessive gas costs\nwhere it doesn\u2019t match how most implementation works.", "": "This EIP proposes net gas metering changes forSSTOREopcode, enabling\nnew usages for contract storage, and reducing excessive gas costs\nwhere it doesn\u2019t match how most implementation works.", "Abstract": "This EIP proposes net gas metering changes forSSTOREopcode, enabling\nnew usages for contract storage, and reducing excessive gas costs\nwhere it doesn\u2019t match how most implementation works.", "Motivation": "This EIP proposes a way for gas metering on SSTORE (as an alternative\nfor EIP-1087 and EIP-1153), using information that is more universally\navailable to most implementations, and require as little change in\nimplementation structures as possible.", "Specification": "Definitions of terms are as below:", "Explanation": "The new gas cost scheme forSSTOREis divided into three different\ntypes:", "State Transition": "Below is a graph (by\n@Arachnid)\nshowing possible state transition of gas costs. We ignoreNo-opstate because that is trivial:", "Rationale": "This EIP mostly achieves what a transient storage tries to do\n(EIP-1087 and EIP-1153), but without the complexity of introducing the\nconcept of \u201cdirty maps\u201d, or an extra storage struct.", "Backwards Compatibility": "This EIP requires a hard fork to implement. No gas cost increase is\nanticipated, and many contracts will see gas reduction.", "Test Cases": "Below we provide 17 test cases. 15 of them covering consecutive twoSSTOREoperations are based on workby\n@chfast. Two additional\ncase with threeSSTOREoperations is used to test the case when a\nslot is reset and then set again.", "Appendix: Proof": "Because thestorage slot\u2019s original valueis defined as the value\nwhen a reversion happens on thecurrent transaction, it\u2019s easy to\nsee that call frames won\u2019t interfere SSTORE gas calculation. So\nalthough the below proof is discussed without call frames, it applies\nto all situations with call frames. We will discuss the case\nseparately fororiginal valuebeing zero and not zero, and useinductionto prove some properties of SSTORE gas cost.", "Original Value Being Zero": "Whenoriginal valueis 0, we want to prove that:", "Original Value Not Being Zero": "Whenoriginal valueis not 0, we want to prove that:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- net gas metering for sstore: Updates the gas cost for the SSTORE opcode based on the original, current, and new storage values, improving efficiency for contracts with frequent storage updates.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1344, "url": "https://eips.ethereum.org/EIPS/eip-1344", "title": "ChainID opcode", "authors": ["Richard Meissner\u00a0(", "@rmeissner", ")", "Bryant Eisenbach\u00a0(", "@fubuloubu", ")"], "sections": {"EIP-1344: ChainID opcode": "This EIP adds an opcode that returns the current chain\u2019s EIP-155 unique identifier.", "": "This EIP adds an opcode that returns the current chain\u2019s EIP-155 unique identifier.", "Abstract": "This EIP adds an opcode that returns the current chain\u2019s EIP-155 unique identifier.", "Motivation": "EIP-155proposes to use the chain ID to prevent replay attacks between different chains. It would be a great benefit to have the same possibility inside smart contracts when handling signatures, especially for Layer 2 signature schemes usingEIP-712.", "Specification": "Adds a new opcodeCHAINIDat 0x46, which uses 0 stack arguments. It pushes the current chain ID onto the stack. Chain ID is a 256-bit value. The operation costsG_baseto execute.", "Rationale": "The current approach proposed by EIP-712 is to specify the chain ID at compile time. Using this approach will result in problems after a hardfork, as well as human error that may lead to loss of funds or replay attacks on signed messages.\nBy adding the proposed opcode it will be possible to access the current chain ID and validate signatures based on that.", "Backwards Compatibility": "This EIP is fully backwards compatible with all chains which implement EIP-155 chain ID domain separator for transaction signing.", "References": "This was previously suggested as part ofEIP-901.", "Test Cases": "Test Cases added toethereum/tests", "Implementation": "A reference implementation for the Trinity Python client ishere.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- chainid opcode: Adds the CHAINID opcode to return the current chain\u2019s EIP-155 unique identifier, enabling replay protection when handling signed messages in contracts.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1559, "url": "https://eips.ethereum.org/EIPS/eip-1559", "title": "Fee market change for ETH 1.0 chain", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Eric Conner\u00a0(", "@econoar", ")", "Rick Dudley\u00a0(", "@AFDudley", ")", "Matthew Slipper\u00a0(", "@mslipper", ")", "Ian Norden\u00a0(", "@i-norden", ")", "Abdelhamid Bakhta\u00a0(", "@abdelhamidbakhta", ")"], "sections": {"EIP-1559: Fee market change for ETH 1.0 chain": "A transaction pricing mechanism that includes fixed-per-block network fee that is burned and dynamically expands/contracts block sizes to deal with transient congestion.", "": "A transaction pricing mechanism that includes fixed-per-block network fee that is burned and dynamically expands/contracts block sizes to deal with transient congestion.", "Simple Summary": "A transaction pricing mechanism that includes fixed-per-block network fee that is burned and dynamically expands/contracts block sizes to deal with transient congestion.", "Abstract": "We introduce a newEIP-2718transaction type, with the format0x02 || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s]).", "Motivation": "Ethereum historically priced transaction fees using a simple auction mechanism, where users send transactions with bids (\u201cgasprices\u201d) and miners choose transactions with the highest bids, and transactions that get included pay the bid that they specify. This leads to several large sources of inefficiency:", "Specification": "Block validity is defined in the reference implementation below.\nTheGASPRICE(0x3a) opcodeMUSTreturn theeffective_gas_priceas defined in the reference implementation below.", "Backwards Compatibility": "Legacy Ethereum transactions will still work and be included in blocks, but they will not benefit directly from the new pricing system.  This is due to the fact that upgrading from legacy transactions to new transactions results in the legacy transaction\u2019sgas_priceentirely being consumed either by thebase_fee_per_gasand thepriority_fee_per_gas.", "Block Hash Changing": "The datastructure that is passed into keccak256 to calculate the block hash is changing, and all applications that are validating blocks are valid or using the block hash to verify block contents will need to be adapted to support the new datastructure (one additional item).  If you only take the block header bytes and hash them you should still correctly get a hash, but if you construct a block header from its constituent elements you will need to add in the new one at the end.", "GASPRICE": "Previous to this change,GASPRICErepresented both the ETH paid by the signer per gas for a transaction as well as the ETH received by the miner per gas.  As of this change,GASPRICEnow only represents the amount of ETH paid by the signer per gas, and the amount a miner was paid for the transaction is no longer accessible directly in the EVM.", "Security Considerations": "This EIP will increase the maximum block size, which could cause problems if miners are unable to process a block fast enough as it will force them to mine an empty block.  Over time, the average block size should remain about the same as without this EIP, so this is only an issue for short term size bursts.  It is possible that one or more clients may handle short term size bursts poorly and error (such as out of memory or similar) and client implementations should make sure their clients can appropriately handle individual blocks up to max size.", "Increased Max Block Size/Complexity": "This EIP will increase the maximum block size, which could cause problems if miners are unable to process a block fast enough as it will force them to mine an empty block.  Over time, the average block size should remain about the same as without this EIP, so this is only an issue for short term size bursts.  It is possible that one or more clients may handle short term size bursts poorly and error (such as out of memory or similar) and client implementations should make sure their clients can appropriately handle individual blocks up to max size.", "Transaction Ordering": "With most people not competing on priority fees and instead using a baseline fee to get included, transaction ordering now depends on individual client internal implementation details such as how they store the transactions in memory.  It is recommended that transactions with the same priority fee be sorted by time the transaction was received to protect the network from spamming attacks where the attacker throws a bunch of transactions into the pending pool in order to ensure that at least one lands in a favorable position.  Miners should still prefer higher gas premium transactions over those with a lower gas premium, purely from a selfish mining perspective.", "Miners Mining Empty Blocks": "It is possible that miners will mine empty blocks until such time as the base fee is very low and then proceed to mine half full blocks and revert to sorting transactions by the priority fee.  While this attack is possible, it is not a particularly stable equilibrium as long as mining is decentralized.  Any defector from this strategy will be more profitable than a miner participating in the attack for as long as the attack continues (even after the base fee reached 0).  Since any miner can anonymously defect from a cartel, and there is no way to prove that a particular miner defected, the only feasible way to execute this attack would be to control 50% or more of hashing power.  If an attacker had exactly 50% of hashing power, they would make no Ether from priority fee while defectors would make double the Ether from priority fees.  For an attacker to turn a profit, they need to have some amount over 50% hashing power, which means they can instead execute double spend attacks or simply ignore any other miners which is a far more profitable strategy.", "ETH Burn Precludes Fixed Supply": "By burning the base fee, we can no longer guarantee a fixed Ether supply.  This could result in economic instability as the long term supply of ETH will no longer be constant over time.  While a valid concern, it is difficult to quantify how much of an impact this will have.  If more is burned on base fee than is generated in mining rewards then ETH will be deflationary and if more is generated in mining rewards than is burned then ETH will be inflationary.  Since we cannot control user demand for block space, we cannot assert at the moment whether ETH will end up inflationary or deflationary, so this change causes the core developers to lose some control over Ether\u2019s long term quantity.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fee market change for eth 1.0 chain: Proposes a new transaction pricing mechanism with a base fee per gas, dynamically adjusting based on network congestion, and burned. Aims to reduce volatility, improve efficiency, and prevent miner manipulation of fees.\n- treturn: A new opcode that allows returning data directly from transient storage without first copying it to memory.\n- revert: All calls to this opcode must emit a log with revert data."}
{"eip": 1884, "url": "https://eips.ethereum.org/EIPS/eip-1884", "title": "Repricing for trie-size-dependent opcodes", "authors": ["Martin Holst Swende\u00a0(", "@holiman", ")"], "sections": {"EIP-1884: Repricing for trie-size-dependent opcodes": "This EIP proposes repricing certain opcodes, to obtain a good balance between gas expenditure and resource consumption.", "": "This EIP proposes repricing certain opcodes, to obtain a good balance between gas expenditure and resource consumption.", "Simple Summary": "This EIP proposes repricing certain opcodes, to obtain a good balance between gas expenditure and resource consumption.", "Abstract": "The growth of the Ethereum state has caused certain opcodes to be more resource-intensive at this point than \nthey were previously. This EIP proposes to raise thegasCostfor those opcodes.", "Motivation": "An imbalance between the price of an operation and the resource consumption (CPU time, memory etc)\nhas several drawbacks:", "Specification": "At blockN,", "Rationale": "Here are two charts, taken from a full sync using Geth. The execution time was measured for every opcode, and aggregated for 10K blocks. These bar charts show the top 25 \u2018heavy\u2019 opcodes in the ranges 5M to 6M and 6M to 7M:", "SLOAD": "SLOADwas repriced atEIP-150, from50to200. \nThe following graph shows a go-ethereum full sync, where each data point represents\n 10K blocks. During those 10K blocks, the execution time for the opcode was aggregated.", "BALANCE": "BALANCE(a.k.aEXTBALANCE) is an operation which fetches data from the state trie. It was repriced atEIP-150from20to400.", "EXTCODEHASH": "EXTCODEHASHwas introduced in Constantinople, withEIP-1052. It was priced at400with the reasoning:", "Backwards Compatibility": "The changes require a hardfork. The changes have the following consequences:", "Test Cases": "Testcases that should be implemented:", "Implementation": "This EIP has not yet been implemented in any client. \nBoth these opcodes have been repriced before, and the client internals for managing reprices are already in place.", "SELFBALANCE": "This is the implementation for the new opcode in go-ethereum:", "Security considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- extbalance: Renames the BALANCE opcode to EXTBALANCE for clarity, aligning with other EXTCODE opcodes.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2028, "url": "https://eips.ethereum.org/EIPS/eip-2028", "title": "Transaction data gas cost reduction", "authors": ["Alexey Akhunov\u00a0(", "@AlexeyAkhunov", ")", "Eli Ben Sasson\u00a0<", "eli@starkware.co", ">", "Tom Brand\u00a0<", "tom@starkware.co", ">", "Louis Guthmann\u00a0<", "louis@starkware.co", ">", "Avihu Levy\u00a0<", "avihu@starkware.co", ">"], "sections": {"EIP-2028: Transaction data gas cost reduction": "We propose to reduce the gas cost of Calldata (GTXDATANONZERO) from its current value of 68 gas per byte to 16 gas per byte, to be backed by mathematical modeling and empirical estimates. The mathematical model is the one used in the works of Sompolinsky and Zohar [1] and Pass, Seeman and Shelat [2], which relates network security to network delay. We shall (1) evaluate the theoretical impact of lower Calldata gas cost on network delay using this model, (2) validate the model empirically, and (3) base the proposed gas cost on our findings.", "": "We propose to reduce the gas cost of Calldata (GTXDATANONZERO) from its current value of 68 gas per byte to 16 gas per byte, to be backed by mathematical modeling and empirical estimates. The mathematical model is the one used in the works of Sompolinsky and Zohar [1] and Pass, Seeman and Shelat [2], which relates network security to network delay. We shall (1) evaluate the theoretical impact of lower Calldata gas cost on network delay using this model, (2) validate the model empirically, and (3) base the proposed gas cost on our findings.", "Simple Summary": "We propose to reduce the gas cost of Calldata (GTXDATANONZERO) from its current value of 68 gas per byte to 16 gas per byte, to be backed by mathematical modeling and empirical estimates. The mathematical model is the one used in the works of Sompolinsky and Zohar [1] and Pass, Seeman and Shelat [2], which relates network security to network delay. We shall (1) evaluate the theoretical impact of lower Calldata gas cost on network delay using this model, (2) validate the model empirically, and (3) base the proposed gas cost on our findings.", "Motivation": "There are a couple of main benefits to accepting this proposal and lowering gas cost of Calldata\nOn-Chain Scalability: Generally speaking, higher bandwidth of Calldata improves scalability, as more data can fit within a single block.", "Specification": "The gas per non-zero byte is reduced from 68 to 16. Gas cost of zero bytes is unchanged.", "Rationale": "Roughly speaking, reducing the gas cost of Calldata leads to potentially larger blocks, which increases the network delay associated with data transmission over the network. This is only part of the full network delay, other factors are block processing time (and storage access, as part of it). Increasing network delay affects security by lowering the cost of attacking the network, because at any given point in time fewer nodes are updated on the latest state of the blockchain.", "BetaLower Bound": "Notice thatlambda=>beta, because not all blocks that are found will enter the main chain (as is the case with uncles). In [1] it was shown that for a blockchain using the longest chain rule, one may boundbetafrom below bylambda/ (1+ D *lambda). This lower bound holds in the extremal case where the topology of the network is a clique in which the delay between each pair of nodes is D, the maximal possible delay. Recording both the lower and upper bounds onbetawe get", "Security of the network": "An attacker attempting to reorganize the main chain needs to generate blocks at a rate that is greater thanbeta.\nFixing the difficulty level of the PoW puzzle, the total hash rate in the system is correlated tolambda. Thus,beta/lambdais defined as theefficiencyof the system, as it measures the fraction of total hash power that is used to generate the main chain of the network.", "Thedelayparameter D": "The network delay depends on the location of the mining node within the network and on the current network topology (which changes dynamically), and consequently is somewhat difficult to measure directly.\nPreviously, Christian Decker and Roger Wattenhofer [3] showed that propagation time scales with blocksize,  and Vitalik Buterin showed that uncle rate, which is tightly related to efficiency (**) measure, also scales with block size [4].", "Test Cases": "To suggest the gas cost of calldata we shall conduct two types of tests:", "Reference Implementation": "ParityGeth", "References": "[1] Yonatan Sompolinsky, Aviv Zohar:Secure High-Rate Transaction Processing in Bitcoin. Financial Cryptography 2015: 507-527", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- uncle rate: Refers to the rate of uncles (stale blocks) included in a block, considered in EIP-100's difficulty adjustment formula .\n- transaction data gas cost reduction: Reduces the gas cost for non-zero calldata from 68 to 16 gas per byte to improve on-chain scalability, especially for layer 2 solutions.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170."}
{"eip": 2200, "url": "https://eips.ethereum.org/EIPS/eip-2200", "title": "Structured Definitions for Net Gas Metering", "authors": ["Wei Tang\u00a0(", "@sorpaas", ")"], "sections": {"EIP-2200: Structured Definitions for Net Gas Metering": "This is an EIP that implements net gas metering. It\u2019s a combined\nversion ofEIP-1283andEIP-1706, with a structured definition so as\nto make it interoperable with other gas changes such asEIP-1884.", "": "This is an EIP that implements net gas metering. It\u2019s a combined\nversion ofEIP-1283andEIP-1706, with a structured definition so as\nto make it interoperable with other gas changes such asEIP-1884.", "Simple Summary": "This is an EIP that implements net gas metering. It\u2019s a combined\nversion ofEIP-1283andEIP-1706, with a structured definition so as\nto make it interoperable with other gas changes such asEIP-1884.", "Abstract": "This EIP provides a structured definition of net gas metering changes\nforSSTOREopcode, enabling new usages for contract storage, and\nreducing excessive gas costs where it doesn\u2019t match how most\nimplementation works.", "Motivation": "This EIP proposes a way for gas metering onSSTORE, using information\nthat is more universally available to most implementations, and\nrequire as little change in implementation structures as possible.", "Specification": "Define variablesSLOAD_GAS,SSTORE_SET_GAS,SSTORE_RESET_GASandSSTORE_CLEARS_SCHEDULE. The old and new values for those variables\nare:", "Rationale": "This EIP mostly achieves what a transient storage tries to do\n(EIP-1087andEIP-1153), but without the complexity of introducing the\nconcept of \u201cdirty maps\u201d, or an extra storage struct.", "Backwards Compatibility": "This EIP requires a hard fork to implement. No gas cost increase is\nanticipated, and many contracts will see gas reduction.", "Test Cases": "To be added.", "Implementation": "To be added.", "Appendix: Proof": "Because thestorage slot\u2019s original valueis defined as the value\nwhen a reversion happens on thecurrent transaction, it\u2019s easy to\nsee that call frames won\u2019t interfereSSTOREgas calculation. So\nalthough the below proof is discussed without call frames, it applies\nto all situations with call frames. We will discuss the case\nseparately fororiginal valuebeing zero and not zero, and useinductionto prove some properties ofSSTOREgas cost.", "Original Value Being Zero": "Whenoriginal valueis 0, we want to prove that:", "Original Value Not Being Zero": "Whenoriginal valueis not 0, we want to prove that:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2384, "url": "https://eips.ethereum.org/EIPS/eip-2384", "title": "Muir Glacier Difficulty Bomb Delay", "authors": ["Eric Conner\u00a0(", "@econoar", ")"], "sections": {"EIP-2384: Muir Glacier Difficulty Bomb Delay": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) and slowly accelerating. This EIP proposes to delay the difficulty bomb for another 4,000,000 blocks (~611 days).", "": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) and slowly accelerating. This EIP proposes to delay the difficulty bomb for another 4,000,000 blocks (~611 days).", "Simple Summary": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) and slowly accelerating. This EIP proposes to delay the difficulty bomb for another 4,000,000 blocks (~611 days).", "Abstract": "Starting withMUIR_GLACIER_FORK_BLKNUMthe client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 9 million blocks later than the Homestead fork, which is also 7 million blocks later than the Byzantium fork and 4 million blocks later than the Constantinople fork.", "Motivation": "The difficulty bomb started to become noticeable again on October 5th 2019 at block 8,600,000. Block times have been around 13.1s on average and now as of block 8,900,000 are around 14.3s. This will start to accelerate exponentially every 100,000 blocks. Estimating the added impact from the difficulty bomb on block times shows that we will see 20s block times near the end of December 2019 and 30s+ block times starting February 2020. This will start making the chain bloated and more costly to use. It\u2019s best to delay the difficulty bomb again to around the time of expected launch of the Eth2 finality gadget.", "Specification": "For the purposes ofcalc_difficulty, simply replace the use ofblock.number, as used in the exponential ice age component, with the formula:", "Rationale": "This will delay the ice age by 52 million seconds (approximately 611 days), so the chain would be back at 20 second block times around July 2021. It\u2019s important to note this pushes the ice age 4,000,000 blocks from ~block 8,800,000 NOT from when this EIP is activated in a fork.", "Backwards Compatibility": "This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation. Therefore, it should be included in a scheduled hardfork at a certain block number. It\u2019s suggested to include this EIP shortly after the Istanbul fork.", "Test Cases": "Test cases shall be created once the specification is to be accepted by the developers or implemented by the clients.", "Implementation": "The implementation in it\u2019s logic does not differ fromEIP-649orEIP-1234; an implementation for Parity-Ethereum is available inparity-ethereum#9187.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- muir glacier difficulty bomb delay: Proposes delaying the Ethereum difficulty bomb by 4 million blocks (~611 days) to prevent increasing block times and network congestion.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2565, "url": "https://eips.ethereum.org/EIPS/eip-2565", "title": "ModExp Gas Cost", "authors": ["Kelly Olson\u00a0(", "@ineffectualproperty", ")", "Sean Gulley\u00a0(", "@sean-sn", ")", "Simon Peffers\u00a0(", "@simonatsn", ")", "Justin Drake\u00a0(", "@justindrake", ")", "Dankrad Feist\u00a0(", "@dankrad", ")"], "sections": {"EIP-2565: ModExp Gas Cost": "Defines the gas cost of theModExp(0x00..05) precompile.", "": "Defines the gas cost of theModExp(0x00..05) precompile.", "Simple Summary": "Defines the gas cost of theModExp(0x00..05) precompile.", "Abstract": "To accurately reflect the real world operational cost of theModExpprecompile, this EIP specifies an algorithm for calculating the gas cost. This algorithm approximates the multiplication complexity cost and multiplies that by an approximation of the iterations required to execute the exponentiation.", "Motivation": "Modular exponentiation is a foundational arithmetic operation for many cryptographic functions including signatures, VDFs, SNARKs, accumulators, and more. Unfortunately, the ModExp precompile is currently over-priced, making these operations inefficient and expensive. By reducing the cost of this precompile, these cryptographic functions become more practical, enabling improved security, stronger randomness (VDFs), and more.", "Specification": "As ofFORK_BLOCK_NUMBER, the gas cost of calling the precompile at address0x0000000000000000000000000000000000000005will be calculated as follows:", "Rationale": "After benchmarking the ModExp precompile, we discovered that it is \u2018overpriced\u2019 relative to other precompiles. We also discovered that the current gas pricing formula could be improved to better estimate the computational complexity of various ModExp input variables. The following changes improve the accuracy of theModExppricing:", "1. Modify \u2018computational complexity\u2019 formula to better reflect the computational complexity": "The complexity function defined inEIP-198is as follow:", "2. Change the value of GQUADDIVISOR": "After changing the \u2018computational complexity\u2019 formula inEIP-198to the one defined here it is necessary to changeQGUADDIVSORto bring the gas costs inline with their runtime. By setting theQGUADDIVISORto3the cost of the ModExp precompile will have a higher cost (gas/second) than other precompiles such as ECRecover.", "3. Set a minimum gas cost to prevent abuse": "This prevents the precompile from underpricing small input values.", "Test Cases": "There are no changes to the underlying interface or arithmetic algorithms, so the existing test vectors can be reused. Below is a table with the updated test vectors:", "Implementations": "Geth", "Security Considerations": "The biggest security consideration for this EIP is creating a potential DoS vector by making ModExp operations too inexpensive relative to their computation time.", "References": "EIP-198", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- modexp gas cost: Reprices the ModExp precompile (0x05) to more accurately reflect its computational cost, improving efficiency for cryptographic operations.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2681, "url": "https://eips.ethereum.org/EIPS/eip-2681", "title": "Limit account nonce to 2^64-1", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-2681: Limit account nonce to 2^64-1": "Limit account nonce to be between0and2^64-1.", "": "Limit account nonce to be between0and2^64-1.", "Abstract": "Limit account nonce to be between0and2^64-1.", "Motivation": "Account nonces are currently specified to be arbitrarily long unsigned integers. Dealing with arbitrary length data in the state witnesses is not optimal, therefore this EIP will allow proofs to represent the nonce in a more optimized way.", "Specification": "Introduce two new restrictions retroactively from genesis:", "Rationale": "While this is a breaking change, no actual effect should be visible:", "Backwards Compatibility": "While this is a breaking change, no actual effect should be visible:", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- limit account nonce: Limits the account nonce to a maximum value of 2^64-1, improving proof representation and optimizing client storage.\n- genesis: Log entry in system_logs for initial balances at network genesis .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2718, "url": "https://eips.ethereum.org/EIPS/eip-2718", "title": "Typed Transaction Envelope", "authors": ["Micah Zoltu\u00a0(", "@MicahZoltu", ")"], "sections": {"EIP-2718: Typed Transaction Envelope": "TransactionType || TransactionPayloadis a valid transaction andTransactionType || ReceiptPayloadis a valid transaction receipt whereTransactionTypeidentifies the format of the transaction and*Payloadis the transaction/receipt contents, which are defined in future EIPs.", "Defines a new transaction type that is an envelope for future transaction types.": "TransactionType || TransactionPayloadis a valid transaction andTransactionType || ReceiptPayloadis a valid transaction receipt whereTransactionTypeidentifies the format of the transaction and*Payloadis the transaction/receipt contents, which are defined in future EIPs.", "Abstract": "TransactionType || TransactionPayloadis a valid transaction andTransactionType || ReceiptPayloadis a valid transaction receipt whereTransactionTypeidentifies the format of the transaction and*Payloadis the transaction/receipt contents, which are defined in future EIPs.", "Motivation": "In the past, when we have wanted to add new transaction types we have had to ensure they were backward compatible with all other transactions, meaning that you could differentiate them based only on the encoded payload, and it was not possible to have a transaction that matched both types.\nThis was seen inEIP-155where the new value was bit-packed into one of the encoded fields.\nThere are multiple proposals in discussion that define new transaction types such as one that allows EOA accounts to execute code directly within their context, one that enables someone besidesmsg.senderto pay for gas, and proposals related to layer 1 multi-sig transactions.\nThese all need to be defined in a way that is mutually compatible, which quickly becomes burdensome to EIP authors and to clients who now have to follow complex rules for differentiating transaction type.", "Specification": "As ofFORK_BLOCK_NUMBER, the transaction root in the block headerMUSTbe the root hash ofpatriciaTrie(rlp(Index) => Transaction)where:", "Definitions": "As ofFORK_BLOCK_NUMBER, the transaction root in the block headerMUSTbe the root hash ofpatriciaTrie(rlp(Index) => Transaction)where:", "Transactions": "As ofFORK_BLOCK_NUMBER, the transaction root in the block headerMUSTbe the root hash ofpatriciaTrie(rlp(Index) => Transaction)where:", "Receipts": "As ofFORK_BLOCK_NUMBER, the receipt root in the block headerMUSTbe the root hash ofpatriciaTrie(rlp(Index) => Receipt)where:", "Rationale": "For the forseable future, 0x7f is plenty and it leaves open a number of options for extending the range such as using the high bit as a continuation bit.\nThis also prevents us from colliding with legacy transaction types, which always start with a byte>= 0xc0.", "TransactionType only goes up to 0x7f": "For the forseable future, 0x7f is plenty and it leaves open a number of options for extending the range such as using the high bit as a continuation bit.\nThis also prevents us from colliding with legacy transaction types, which always start with a byte>= 0xc0.", "SHOULDinstead ofMUSTfor the TransactionType being first byte of signed data": "While it is strongly recommended that all future transactions sign the first byte to ensure that there is no problem with signature reuse, the authors acknowledge that this may not always make sense or be possible.\nOne example where this isn\u2019t possible is wrapped legacy transactions that are signature compatible with the legacy signing scheme.\nAnother potential situation is one where transactions don\u2019t have a signature in the traditional sense and instead have some other mechanism for determining validity.", "TransactionType selection algorithm": "There was discussion about defining theTransactionTypeidentifier assignment/selection algorithm in this standard.\nWhile it would be nice to have a standardized mechanism for assignment, at the time of writing of this standard there is not a strong need for it so it was deemed out of scope.\nA future EIP may introduce a standard for TransactionType identifier assignment if it is deemed necessary.", "Opaque byte array rather than an RLP array": "By having the second byte on be opaque bytes, rather than an RLP (or other encoding) list, we can support different encoding formats for the transaction payload in the future such as SSZ, LEB128, or a fixed width format.", "ORIGIN and CALLER": "There was discussion about having ORIGIN and CALLER opcodes become dependent on the transaction type, so that each transaction type could define what those opcodes returned.\nHowever, there is a desire to make transaction type opaque to the contracts to discourage contracts treating different types of transactions differently.\nThere also were concerns over backward compatibility with existing contracts which make assumptions about ORIGIN and CALLER opcodes.\nGoing forward, we will assume that all transaction types will have an address that reasonably represents aCALLERof the first EVM frame andORIGINwill be the same address in all cases.\nIf a transaction type needs to supply additional information to contracts, they will need a new opcode.", "Backwards Compatibility": "Clients can differentiate between the legacy transactions and typed transactions by looking at the first byte.\nIf it starts with a value in the range[0, 0x7f]then it is a new transaction type, if it starts with a value in the range[0xc0, 0xfe]then it is a legacy transaction type.0xffis not realistic for an RLP encoded transaction, so it is reserved for future use as an extension sentinel value.", "Security Considerations": "When designing a new 2718 transaction type, it isSTRONGLYrecommended to include the transaction type as the first byte of the signed payload.  If you fail to do this, it is possible that your transaction may be signature compatible with transactions of another type which can introduce security vulnerabilities for users.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- typed transaction envelope: Defines a transaction envelope for supporting multiple transaction types, enabling easier addition of future transaction formats.\n- wrapped legacy transactions: Defines two new transaction types that wrap legacy transactions with and without a chain ID, maintaining signature compatibility with older transactions.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2929, "url": "https://eips.ethereum.org/EIPS/eip-2929", "title": "Gas cost increases for state access opcodes", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Martin Swende\u00a0(", "@holiman", ")"], "sections": {"EIP-2929: Gas cost increases for state access opcodes": "Increases gas cost forSLOAD,*CALL,BALANCE,EXT*andSELFDESTRUCTwhen used for the first time in a transaction.", "": "Increases gas cost forSLOAD,*CALL,BALANCE,EXT*andSELFDESTRUCTwhen used for the first time in a transaction.", "Simple Summary": "Increases gas cost forSLOAD,*CALL,BALANCE,EXT*andSELFDESTRUCTwhen used for the first time in a transaction.", "Abstract": "Increase the gas cost ofSLOAD(0x54) to 2100, and the*CALLopcode family (0xf1,f2,f4,fA),BALANCE0x31and theEXT*opcode family (0x3b,0x3c,0x3f) to 2600. Exempts (i) precompiles, and (ii) addresses and storage slots that have already been accessed in the same transaction, which get a decreased gas cost. Additionally reformsSSTOREmetering andSELFDESTRUCTto ensure \u201cde-facto storage loads\u201d inherent in those opcodes are priced correctly.", "Motivation": "Generally, the main function of gas costs of opcodes is to be an estimate of the time needed to process that opcode, the goal being for the gas limit to correspond to a limit on the time needed to process a block. However, storage-accessing opcodes (SLOAD, as well as the*CALL,BALANCEandEXT*opcodes) have historically been underpriced. In the 2016 Shanghai DoS attacks, once the most serious client bugs were fixed, one of the more durably successful strategies used by the attacker was to simply send transactions that access or call a large number of accounts.", "Specification": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Parameters": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Storage read changes": "When an address is either the target of a (EXTCODESIZE(0x3B),EXTCODECOPY(0x3C),EXTCODEHASH(0x3F) orBALANCE(0x31)) opcode or the target of a (CALL(0xF1),CALLCODE(0xF2),DELEGATECALL(0xF4),STATICCALL(0xFA)) opcode, the gas costs are computed as follows:", "SSTORE changes": "When callingSSTORE, check if the(address, storage_key)pair is inaccessed_storage_keys. If it is not, charge an additionalCOLD_SLOAD_COSTgas, and add the pair toaccessed_storage_keys. Additionally, modify the parameters defined inEIP-2200as follows:", "SELFDESTRUCT changes": "If the ETH recipient of aSELFDESTRUCTis not inaccessed_addresses(regardless of whether or not the amount sent is nonzero), charge an additionalCOLD_ACCOUNT_ACCESS_COSTon top of the existing gas costs, and add the ETH recipient to the set.", "Rationale": "The natural alternative path to changing gas costs to reflect witness sizes is to charge per byte of witness data. However, that would take a longer time to implement, hampering the goal of providing short-term security relief. Furthermore, following that path faithfully would lead to extremely high gas costs to transactions that touch contract code, as one would need to charge for all 24576 contract code bytes; this would be an unacceptably high burden on developers. It is better to wait forcode merklizationto start trying to properly account for gas costs of accessing individual chunks of code; from a short-term DoS prevention standpoint, accessing 24 kB from disk is not much more expensive than accessing 32 bytes from disk, so worrying about code size is not necessary.", "Opcode costs vs charging per byte of witness data": "The natural alternative path to changing gas costs to reflect witness sizes is to charge per byte of witness data. However, that would take a longer time to implement, hampering the goal of providing short-term security relief. Furthermore, following that path faithfully would lead to extremely high gas costs to transactions that touch contract code, as one would need to charge for all 24576 contract code bytes; this would be an unacceptably high burden on developers. It is better to wait forcode merklizationto start trying to properly account for gas costs of accessing individual chunks of code; from a short-term DoS prevention standpoint, accessing 24 kB from disk is not much more expensive than accessing 32 bytes from disk, so worrying about code size is not necessary.", "Adding the accessed_addresses / accessed_storage_keys sets": "The sets of already-accessed accounts and storage slots are added to avoid needlessly charging for things that can be cached (and in all performant implementations already are cached). Additionally, it removes the current undesirable status quo where it is needlessly unaffordable to do self-calls or call precompiles, and enables contract breakage mitigations that involve pre-fetching some storage key allowing a future execution to still take the expected amount of gas.", "SSTORE gas cost change": "The change to SSTORE is needed to avoid the possibility of a DoS attack that \u201cpokes\u201d a randomly chosen zero storage slot, changing it from 0 to 0 at a cost of 800 gas but requiring a de-facto storage load. TheSSTORE_RESET_GASreduction ensures that the total cost of SSTORE (which now requires paying theCOLD_SLOAD_COST) remains unchanged. Additionally, note that applications that doSLOADfollowed bySSTORE(eg.storage_variable += x)would actually get cheaper!", "Change SSTORE accounting only minimally": "The SSTORE gas costs continue to use Wei Tang\u2019s original/current/new approach, instead of being redesigned to use a dirty map, because Wei Tang\u2019s approach correctly accounts for the actual costs of changing storage, which only care about current vs final value and not intermediate values.", "How would gas consumption of average applications increase under this proposal?": "We can look atAlexey Akhunov\u2019s earlier workfor data on average-case blocks. In summary, average blocks have witness sizes of ~1000 kB, of which ~750 kB is Merkle proofs and not code. Assuming a conservative 2000 bytes per Merkle branch this implies ~375 accesses per block (SLOADs have a similar gas-increase-to-bytes ratio so there\u2019s no need to analyze them separately).", "Backwards Compatibility": "These gas cost increases may potentially break contracts that depend on fixed gas costs; see the security considerations section for details and arguments for why we expect the total risks to be low and how if desired they can be reduced further.", "Test Cases": "Some test cases can be found here: https://gist.github.com/holiman/174548cad102096858583c6fbbb0649a", "Implementation": "A WIP early-draft implementation for Geth can be found here: https://github.com/holiman/go-ethereum/tree/access_lists", "Security Considerations": "As with any gas cost increasing EIP, there are three possible cases where it could cause applications to break:", "Contract breakage mitigations": "A second way to look at the risks is to explore mitigations. First of all, the existence of anaccessed_addressesandaccessed_storage_keysmap (present in this EIP, absent in EIP-1884) already makes some cases recoverable: in any case where a contract A needs to send funds to some address B, where that address accepts funds from any source but leaves a storage-dependent log, one can recover by first sending a separate call to B to pull it into the cache, and then call A, knowing that the execution of B triggered by A will only charge 100 gas per SLOAD. This fact does not fix all situations, but it does reduce risks significantly.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- gas cost increases for state access opcodes: Increases the gas cost for SLOAD, *CALL, BALANCE, and EXT* opcodes on first access in a transaction, to address underpriced operations."}
{"eip": 2930, "url": "https://eips.ethereum.org/EIPS/eip-2930", "title": "Optional access lists", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Martin Swende\u00a0(", "@holiman", ")"], "sections": {"EIP-2930: Optional access lists": "Adds a transaction type which contains an access list, a list of addresses and storage keys that the transaction plans to access. Accesses outside the list are possible, but become more expensive.", "": "Adds a transaction type which contains an access list, a list of addresses and storage keys that the transaction plans to access. Accesses outside the list are possible, but become more expensive.", "Simple Summary": "Adds a transaction type which contains an access list, a list of addresses and storage keys that the transaction plans to access. Accesses outside the list are possible, but become more expensive.", "Abstract": "We introduce a newEIP-2718transaction type, with the format0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, signatureYParity, signatureR, signatureS]).", "Motivation": "This EIP serves two functions:", "Specification": "TransactionType1.  SeeEIP-2718", "Definitions": "TransactionType1.  SeeEIP-2718", "Parameters": "As ofFORK_BLOCK_NUMBER, a newEIP-2718transaction is introduced withTransactionType1.", "Rationale": "This is done to encourage transactions to use the access list as much as possible, and because processing transactions is easier when their storage reads are predictable (because clients can pre-load the data from databases and/or ask for witnesses at the time the transaction is received, or at least load the data in parallel).", "Charging less for accesses in the access list": "This is done to encourage transactions to use the access list as much as possible, and because processing transactions is easier when their storage reads are predictable (because clients can pre-load the data from databases and/or ask for witnesses at the time the transaction is received, or at least load the data in parallel).", "Allowing duplicates": "This is done because it maximizes simplicity, avoiding questions of what to prevent duplication against: just between two addresses/keys in the access list, between the access list and the tx sender/recipient/newly created contract, other restrictions? Because gas is charged per item, there is no gain and only cost in including a value in the access list twice, so this should not lead to extra chain bloat in practice.", "Signature signs over the transaction type as well as the transaction data": "This is done to ensure that the transaction cannot be \u201cre-interpreted\u201d as a transaction of a different type.", "Backwards Compatibility": "This EIP does make it more gas-expensive to perform \u201cunexpected\u201d SLOADs and account accesses. Because gas is prepaid and so does not affect fixed-gas local calls, it does not break contracts in the way that previous gas cost increases would risk. However, it does make applications that heavily rely on storage access much less economically viable.", "Security Considerations": "Access lists are difficult to construct in real-time in many situations, and this is exacerbated in environments where there is a high time lag between transaction generation and signing or simplicity of the transaction generator is highly valued (eg. either or both may apply in hardware wallets).", "Access list generation": "Access lists are difficult to construct in real-time in many situations, and this is exacerbated in environments where there is a high time lag between transaction generation and signing or simplicity of the transaction generator is highly valued (eg. either or both may apply in hardware wallets).", "Transaction size bloating": "Average block size will increase as a result of access lists being used. However, the per-byte cost of access lists is1900 / 32 = 59.375for storage keys and2400 / 20 = 120for addresses, making it much more expensive than calldata; hence, worst-case block size will not increase. Additionally, increases in average block size will be partially compensated for by the ability to pre-fetch storage at time of receiving a transaction and/or load storage in parallel upon receiving a block.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- optional access lists: Introduces a transaction type that includes an access list specifying addresses and storage keys the transaction plans to access, reducing gas costs for state access.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3198, "url": "https://eips.ethereum.org/EIPS/eip-3198", "title": "BASEFEE opcode", "authors": ["Abdelhamid Bakhta\u00a0(", "@abdelhamidbakhta", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-3198: BASEFEE opcode": "Adds an opcode that gives the EVM access to the block\u2019s base fee.", "": "Adds an opcode that gives the EVM access to the block\u2019s base fee.", "Simple Summary": "Adds an opcode that gives the EVM access to the block\u2019s base fee.", "Abstract": "Add aBASEFEE (0x48)that returns the value of the base fee of the current block it is executing in.", "Motivation": "The intended use case would be for contracts to get the value of the base fee. This feature would enable or improve existing use cases, such as:", "Specification": "Add aBASEFEEopcode at(0x48), with gas costG_base.", "Rationale": "The value of the base fee is needed to process transactions. That means it\u2019s value is already available before running the EVM code.\nThe opcode does not add extra complexity and additional read/write operations, hence the choice ofG_basegas cost.", "Gas cost": "The value of the base fee is needed to process transactions. That means it\u2019s value is already available before running the EVM code.\nThe opcode does not add extra complexity and additional read/write operations, hence the choice ofG_basegas cost.", "Backwards Compatibility": "There are no known backward compatibility issues with this opcode.", "Test Cases": "Assuming current block base fee is7 wei.\nThis should push the value7(left padded byte32) to the stack.", "Nominal case": "Assuming current block base fee is7 wei.\nThis should push the value7(left padded byte32) to the stack.", "Security Considerations": "The value of the base fee is not sensitive and is publicly accessible in the block header. There are no known security implications with this opcode.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- basefee opcode: Adds the BASEFEE opcode, allowing smart contracts to access the block's base fee, useful for gas-related logic such as gas futures and bounties.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3529, "url": "https://eips.ethereum.org/EIPS/eip-3529", "title": "Reduction in refunds", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Martin Swende\u00a0(", "@holiman", ")"], "sections": {"EIP-3529: Reduction in refunds": "Remove gas refunds forSELFDESTRUCT, and reduce gas refunds forSSTOREto a lower level where the refunds are still substantial, but they are no longer high enough for current \u201cexploits\u201d of the refund mechanism to be viable.", "": "Remove gas refunds forSELFDESTRUCT, and reduce gas refunds forSSTOREto a lower level where the refunds are still substantial, but they are no longer high enough for current \u201cexploits\u201d of the refund mechanism to be viable.", "Simple Summary": "Remove gas refunds forSELFDESTRUCT, and reduce gas refunds forSSTOREto a lower level where the refunds are still substantial, but they are no longer high enough for current \u201cexploits\u201d of the refund mechanism to be viable.", "Motivation": "Gas refunds forSSTOREandSELFDESTRUCTwere originally introduced to motivate application developers to write applications that practice \u201cgood state hygiene\u201d, clearing storage slots and contracts that are no longer needed. However, the benefits of this technique have proven to be far lower than anticipated, and gas refunds have had multiple unexpected harmful consequences:", "Specification": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Parameters": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Rationale": "InEIP-2200, three cases for refunds were introduced:", "Backwards Compatibility": "Refunds are currently only appliedaftertransaction execution, so they cannot affect how much gas is available to any particular call frame during execution. Hence, removing them will not break the ability of any code to execute, though it will render some applications economically nonviable.", "Effect on storage clearing incentives": "A criticism of earlier refund removal EIPs (EIP-3298andEIP-3403) is that these EIPs fully remove the incentive to set a value to zero, encouraging users to not fully clear a storage slot if they expect even the smallest probability that they will want to use that storage slot again.", "Test Cases": "Note, there is a difference between \u2018hot\u2019 and \u2018cold\u2019 slots. This table shows the values as ofEIP-2929assuming that all touched storage slots were already \u2018hot\u2019 (the difference being a one-time cost of2100gas).", "EIP-2929 Gas Costs": "Note, there is a difference between \u2018hot\u2019 and \u2018cold\u2019 slots. This table shows the values as ofEIP-2929assuming that all touched storage slots were already \u2018hot\u2019 (the difference being a one-time cost of2100gas).", "With reduced refunds": "If refunds were to be partially removed, by changingSSTORE_CLEARS_SCHEDULEfrom 15000 to 4800 (and removing selfdestruct refund) this would be the comparative table.", "Security Considerations": "Refunds are not visible to transaction execution, so this should not have any impact on transaction execution logic.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- reduction in refunds: Reduces gas refunds for SSTORE and eliminates refunds for SELFDESTRUCT, limiting block gas refund to 20% of gas used to reduce block size variance and prevent GasToken exploits.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding."}
{"eip": 3541, "url": "https://eips.ethereum.org/EIPS/eip-3541", "title": "Reject new contract code starting with the 0xEF byte", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")", "Alexey Akhunov\u00a0(", "@AlexeyAkhunov", ")", "Christian Reitwiessner\u00a0(", "@chriseth", ")", "Martin Swende\u00a0(", "@holiman", ")"], "sections": {"EIP-3541: Reject new contract code starting with the 0xEF byte": "Disallow new code starting with the0xEFbyte to be deployed. Code already existing in the account trie starting with0xEFbyte is not affected semantically by this change.", "": "Disallow new code starting with the0xEFbyte to be deployed. Code already existing in the account trie starting with0xEFbyte is not affected semantically by this change.", "Abstract": "Disallow new code starting with the0xEFbyte to be deployed. Code already existing in the account trie starting with0xEFbyte is not affected semantically by this change.", "Motivation": "Contracts conforming to the EVM Object Format (EOF) are going to be validated at deploy time. In order to guarantee that every EOF-formatted contract in the state is valid, we need to prevent already deployed (and not validated) contracts from being recognized as such format. This will be achieved by choosing a byte sequence for themagicthat doesn\u2019t exist in any of the already deployed contracts. To prevent the growth of the search space and to limit the analysis to the contracts existing before this fork, we disallow the starting byte of the format (the first byte of the magic).", "Specification": "Afterblock.number == HF_BLOCKnew contract creation (via create transaction,CREATEorCREATE2instructions) results in an exceptional abort if thecode\u2019s first byte is0xEF.", "Remarks": "Theinitcodeis the code executed in the context of thecreatetransaction,CREATE, orCREATE2instructions. Theinitcodereturnscode(via theRETURNinstruction), which is inserted into the account. See section 7 (\u201cContract Creation\u201d) in the Yellow Paper for more information.", "Rationale": "The0xEFbyte was chosen because it resemblesExecutableFormat.", "Test Cases": "Each test case below may be executed in 3 different contexts:", "Backwards Compatibility": "This is a breaking change given new code starting with the0xEFbyte will not be deployable, and contract creation will result in a failure. However, given bytecode is executed starting at its first byte, code deployed with0xEFas the first byte is not executable anyway.", "Security Considerations": "The authors are not aware of any security or DoS risks posed by this change.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- magic: A constant value set as 0xef0100 used in the CREATE_DELEGATE instruction.\n- initcode: The code executed by a contract at its initialization, which must be within 49152 bytes in size before EIP-3860."}
{"eip": 3554, "url": "https://eips.ethereum.org/EIPS/eip-3554", "title": "Difficulty Bomb Delay to December 2021", "authors": ["James Hancock\u00a0(", "@madeoftin", ")"], "sections": {"EIP-3554: Difficulty Bomb Delay to December 2021": "Delays the difficulty bomb to show effect the first week of December 2021.", "": "Delays the difficulty bomb to show effect the first week of December 2021.", "Simple Summary": "Delays the difficulty bomb to show effect the first week of December 2021.", "Abstract": "Starting withFORK_BLOCK_NUMBERthe client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 9,700,000 blocks later than the actual block number.", "Motivation": "Targeting for the Shanghai upgrade and/or the Merge to occur before December 2021. Either the bomb can be readjusted at that time, or removed all together.", "Specification": "For the purposes ofcalc_difficulty, simply replace the use ofblock.number, as used in the exponential ice age component, with the formula:", "Rationale": "The following script predicts a .1 second delay to blocktime the first week of december and a 1 second delay by the end of the month. This gives reason to address because the effect will be seen, but not so much urgency we don\u2019t have space to work around if needed.", "Backwards Compatibility": "No known backward compatibility issues.", "Security Considerations": "Misjudging the effects of the difficulty can mean longer blocktimes than anticipated until a hardfork is released. Wild shifts in difficulty can affect this number severely. Also, gradual changes in blocktimes due to longer-term adjustments in difficulty can affect the timing of difficulty bomb epochs. This affects the usability of the network but unlikely to have security ramifications.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- difficulty bomb delay to december 2021: Delays the difficulty bomb, pushing its effects to December 2021 to align with the planned Ethereum upgrades.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3607, "url": "https://eips.ethereum.org/EIPS/eip-3607", "title": "Reject transactions from senders with deployed code", "authors": ["Dankrad Feist\u00a0(", "@dankrad", ")", "Dmitry Khovratovich\u00a0(", "@khovratovich", ")", "Marius van der Wijden\u00a0(", "@MariusVanDerWijden", ")"], "sections": {"EIP-3607: Reject transactions from senders with deployed code": "Ethereum addresses are currently only 160 bits long. This means it is possible to create a collision between a contract account and an Externally Owned Account (EOA) using an estimated2**80computing operations, which is feasible now given a large budget (ca. 10 billion USD). The fix in this EIP prevents the worst possible attack, where a safe looking contract (e.g. a token wrapper or an AMM-type contract) is deployed to attract user funds, which can then be spent using the EOA key for the same address. The fix is to never allow to use an address that already has code deployed as an EOA address.", "Do not allow transactions for which `tx.sender` has any code deployed.": "Ethereum addresses are currently only 160 bits long. This means it is possible to create a collision between a contract account and an Externally Owned Account (EOA) using an estimated2**80computing operations, which is feasible now given a large budget (ca. 10 billion USD). The fix in this EIP prevents the worst possible attack, where a safe looking contract (e.g. a token wrapper or an AMM-type contract) is deployed to attract user funds, which can then be spent using the EOA key for the same address. The fix is to never allow to use an address that already has code deployed as an EOA address.", "Abstract": "Ethereum addresses are currently only 160 bits long. This means it is possible to create a collision between a contract account and an Externally Owned Account (EOA) using an estimated2**80computing operations, which is feasible now given a large budget (ca. 10 billion USD). The fix in this EIP prevents the worst possible attack, where a safe looking contract (e.g. a token wrapper or an AMM-type contract) is deployed to attract user funds, which can then be spent using the EOA key for the same address. The fix is to never allow to use an address that already has code deployed as an EOA address.", "Motivation": "By creating keys for2**80EOAs and simulating the deployment of2**80contracts from these EOAs (one each), one expects to find about one collision where an EOA has the same address as one contract.", "Generating address collisions": "By creating keys for2**80EOAs and simulating the deployment of2**80contracts from these EOAs (one each), one expects to find about one collision where an EOA has the same address as one contract.", "Background": "There is currently a discussion to move to 256-bit addresses on Ethereum, which would increase collision resistance to a complexity of2**128which is currently thought infeasible for the foreseeable future. However, with 160 bit addresses, the collision problem can be effectively solved now, as demonstrated above.", "Specification": "Any transaction wheretx.senderhas aCODEHASH != EMPTYCODEHASHMUST be rejected as invalid, whereEMPTYCODEHASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470.\nThe invalid transaction MUST be rejected by the client and not be included in a block.\nA block containing such a transaction MUST be considered invalid.", "Rationale": "We note that it was always expected that a contract account\u2019s behaviour is constrained by the code in that contract \u2013 which means that the account\u2019s funds should not suddenly be spendable by some private key. It was just implicitly assumed in the past that a 160 bit address length is enough to provide collision resistance, and thus that this case could never occur. In that sense, this EIP should be seen as a clarification of protocol behaviour in a previously undefined case rather than an explicit upgrade of consensus rules.", "Backwards Compatibility": "It is unlikely that an attack like this has already occurred on the Ethereum mainnet, or we would very likely have heard of it. It is inconceivable that someone would use this as a \u201cfeature\u201d to make a contract an EOA at the same time, when they could simply do this by adding some methods to the contract instead of spending billions on building hardware to find hash collisions.", "Test Cases": "Given a genesis allocation of", "Reference Implementation": "The following check must be added to the state transition checks after checking that the nonce of the sender is correct.\nThe sender is the address recovered from the signature of the transaction.", "Security Considerations": "This EIP is a strict security upgrade: It simply makes some transactions that were formerly valid now invalid. There is no legitimate use for such transactions, so there should be no security downsides.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- genesis: Log entry in system_logs for initial balances at network genesis .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3651, "url": "https://eips.ethereum.org/EIPS/eip-3651", "title": "Warm COINBASE", "authors": ["William Morriss\u00a0(", "@wjmelements", ")"], "sections": {"EIP-3651: Warm COINBASE": "TheCOINBASEaddress shall be warm at the start of transaction execution, in accordance with the actual cost of reading that account.", "Starts the `COINBASE` address warm": "TheCOINBASEaddress shall be warm at the start of transaction execution, in accordance with the actual cost of reading that account.", "Abstract": "TheCOINBASEaddress shall be warm at the start of transaction execution, in accordance with the actual cost of reading that account.", "Motivation": "DirectCOINBASEpayments are becoming increasingly popular because they allow conditional payments, which provide benefits such as implicit cancellation of transactions that would revert.\nBut accessingCOINBASEis overpriced; the address is initially cold under the access list framework introduced inEIP-2929.\nThis gas cost mismatch can incentivize alternative payments besides ETH, such asERC-20, but ETH should be the primary means of paying for transactions on Ethereum.", "Specification": "At the start of transaction execution,accessed_addressesshall be initialized to also include the address returned byCOINBASE(0x41).", "Rationale": "The addresses currently initialized warm are the addresses that should already be loaded at the start of transaction validation.\nTheORIGINaddress is always loaded to check its balance against the gas limit and the gas price.\nThetx.toaddress is always loaded to begin execution.\nTheCOINBASEaddress should also be always be loaded because it receives the block reward and the transaction fees.", "Backwards Compatibility": "There are no known backward compatibility issues presented by this change.", "Security Considerations": "There are no known security considerations introduced by this change.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- warm coinbase: Starts the COINBASE address warm at the start of a transaction to reflect its actual cost and promote its use for payments.\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3675, "url": "https://eips.ethereum.org/EIPS/eip-3675", "title": "Upgrade consensus to Proof-of-Stake", "authors": ["Mikhail Kalinin\u00a0(", "@mkalinin", ")", "Danny Ryan\u00a0(", "@djrtwo", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-3675: Upgrade consensus to Proof-of-Stake": "This EIP deprecates Proof-of-Work (PoW) and supersedes it with the new Proof-of-Stake consensus mechanism (PoS) driven by the beacon chain. Information on the bootstrapping of the new consensus mechanism is documented inEIP-2982. Full specification of the beacon chain can be found in theethereum/consensus-specsrepository.", "Specification of the consensus mechanism upgrade on Ethereum Mainnet that introduces Proof-of-Stake": "This EIP deprecates Proof-of-Work (PoW) and supersedes it with the new Proof-of-Stake consensus mechanism (PoS) driven by the beacon chain. Information on the bootstrapping of the new consensus mechanism is documented inEIP-2982. Full specification of the beacon chain can be found in theethereum/consensus-specsrepository.", "Abstract": "This EIP deprecates Proof-of-Work (PoW) and supersedes it with the new Proof-of-Stake consensus mechanism (PoS) driven by the beacon chain. Information on the bootstrapping of the new consensus mechanism is documented inEIP-2982. Full specification of the beacon chain can be found in theethereum/consensus-specsrepository.", "Motivation": "The beacon chain network has been up and running since December 2020. Neither safety nor liveness failures were detected during this period of time. This long period of running without failure demonstrates the sustainability of the beacon chain system and its readiness to become a security provider for the Ethereum Mainnet.", "Specification": "Events having thePOS_prefix in the name (PoS events) are emitted by the new proof-of-stake consensus mechanism. They signify the corresponding assertion that has been made regarding a block specified by the event. The underlying logic of PoS events can be found in the beacon chain specification. On the occurrence of each PoS event the corresponding action that is specified by this EIPMUSTbe taken.", "Definitions": "Events having thePOS_prefix in the name (PoS events) are emitted by the new proof-of-stake consensus mechanism. They signify the corresponding assertion that has been made regarding a block specified by the event. The underlying logic of PoS events can be found in the beacon chain specification. On the occurrence of each PoS event the corresponding action that is specified by this EIPMUSTbe taken.", "Client software configuration": "The following set of parameters is a part of client software configuration andMUSTbe included into its binary distribution:", "PoW block processing": "PoW blocks that are descendants of any terminal PoW blockMUST NOTbe imported. This implies that a terminal PoW block will be the last PoW block in the canonical chain.", "Constants": "Beginning withTRANSITION_BLOCK, a number of previously dynamic block fields are deprecated by enforcing these values to instead be constants. Each block field listed in the table belowMUSTbe replaced with the corresponding constant value.", "Block structure": "Beginning withTRANSITION_BLOCK, a number of previously dynamic block fields are deprecated by enforcing these values to instead be constants. Each block field listed in the table belowMUSTbe replaced with the corresponding constant value.", "Block validity": "Beginning withTRANSITION_BLOCK, the block validity conditionsMUSTbe altered by the following:", "Block and ommer rewards": "Beginning withTRANSITION_BLOCK, block and ommer rewards are deprecated. Specifically, the following actionsMUSTbe taken:", "Fork choice rule": "If set,TERMINAL_BLOCK_HASHparameter affects the PoW heaviest chain rule in the following way:", "Network": "For the purposes of theEIP-2124fork identifier, nodes implementing this EIPMUSTset theFORK_NEXTparameter to theFORK_NEXT_VALUE.", "Rationale": "The changes specified in this EIP target a minimal requisite set of consensus and client software modifications to safely replace the existing proof-of-work consensus algorithm with the new proof-of-stake consensus represented by the already in-production beacon chain.", "Total difficulty triggering the upgrade": "SeeSecurity considerations.", "Parameterizing terminal block hash": "SeeSecurity considerations.", "Halting the import of PoW blocks": "SeeSecurity considerations.", "Replacing block fields with constants": "Deprecated block fields are replaced with constant values to ensure the block format remains backwards compatible. Preserving the block format aids existing smart contracts and services in providing uninterrupted service during and after this transition.", "Replacingdifficultywith0": "After deprecating the proof-of-work the notion of difficulty no longer exists and replacing the block headerdifficultyfield with0constant is semantically sound.", "Changing block validity rules": "The rule set enforcing the PoW seal validity is replaced with the corresponding PoS rules along with the consensus upgrade as the rationale behind this change.", "Removing block rewards": "Existing rewards for producing and sealing blocks are deprecated along with the PoW mechanism. The new PoS consensus becomes both responsible for sealing blocks and for issuing block rewards once this specification enters into effect.", "Supplanting fork choice rule": "The fork choice rule of the PoW mechanism becomes completely irrelevant after the upgrade and is replaced with the corresponding rule of the new PoS consensus mechanism.", "Remove ofPOS_CONSENSUS_VALIDATED": "In prior draft versions of this EIP, an additional POS event \u2013POS_CONSENSUS_VALIDATED\u2013 was required as a validation condition for blocks. This event gave the signal to either fully incorporate or prune the block from the block tree.", "EIP-2124 fork identifier": "The value ofFORK_NEXTin EIP-2124 refers to the block number of the next fork a given node knows about and0otherwise.", "Removing block gossip": "After the upgrade of the consensus mechanism only the beacon chain network will have enough information to validate a block. Thus, block gossip provided by theethnetwork protocol will become unsafe and is deprecated in favour of the block gossip existing in the beacon chain network.", "Restricting the length ofextraData": "TheextraDatafield is defined as a maximum of32bytes in the yellow paper. Thus mainnet and most PoW testnets cap the value at32bytes.extraDatafields of greater length are used by clique testnets and other networks to carry special signature/consensus schemes. This EIP restricts the length ofextraDatato32bytes because any network that is transitioning from another consensus mechanism to a beacon chain PoS consensus mechanism no longer needs extended or unboundedextraData.", "Backwards Compatibility": "This EIP introduces backward incompatibilities in block validity, block rewards and fork choice rule.", "EVM": "Although this EIP does not introduce any explicit changes to the EVM there are a couple of places where it may affect the logic of existing smart contracts.", "Test Cases": "See Security Considerations section ofEIP-2982.", "Security Considerations": "See Security Considerations section ofEIP-2982.", "Beacon chain": "See Security Considerations section ofEIP-2982.", "Transition process": "The transition process used to take this specification into effect is a more sophisticated version of a hardfork \u2013 the regular procedure of applying backwards incompatible changes in the Ethereum network. This process has multiple successive steps instead of the normal block-height point condition of simpler hardforks.", "Ancient blocks are no longer a requisite for a network security": "Keeping historical blocks starting from genesis is essential in the PoW network. A header of every block that belongs to a particular chain is required to justify the validity of this chain with respect to the PoW seal.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork identifier: Introduces a mechanism to summarize chain configurations using a FORK_HASH and FORK_NEXT for chain compatibility checks.\n- upgrade consensus to proof-of-stake: Specifies the transition from Proof-of-Work (PoW) to Proof-of-Stake (PoS) on Ethereum Mainnet, deprecating PoW and upgrading the consensus mechanism to PoS.\n- genesis: Log entry in system_logs for initial balances at network genesis ."}
{"eip": 3855, "url": "https://eips.ethereum.org/EIPS/eip-3855", "title": "PUSH0 instruction", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Hugo De la cruz\u00a0(", "@hugo-dc", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")"], "sections": {"EIP-3855: PUSH0 instruction": "Introduce thePUSH0(0x5f) instruction, which pushes the constant value 0 onto the stack.", "Introduce a new instruction which pushes the constant value 0 onto the stack": "Introduce thePUSH0(0x5f) instruction, which pushes the constant value 0 onto the stack.", "Abstract": "Introduce thePUSH0(0x5f) instruction, which pushes the constant value 0 onto the stack.", "Motivation": "Many instructions expect offsets as inputs, which in a number of cases are zero. A good example is the return data parameters ofCALLs, which are set to zeroes in case the contract prefers usingRETURNDATA*. This is only one example, but there are many other reasons why a contract would need to push a zero value. They can achieve that today byPUSH1 0, which costs 3 gas at runtime, and is encoded as two bytes which means2 * 200gas deployment cost.", "Specification": "The instructionPUSH0is introduced at0x5f. It has no immediate data, pops no items from the stack, and places a single item with the value 0 onto the stack. The cost of this instruction is 2 gas (akabase).", "Rationale": "Thebasegas cost is used for instructions which place constant values onto the stack, such asADDRESS,ORIGIN, and so forth.", "Gas cost": "Thebasegas cost is used for instructions which place constant values onto the stack, such asADDRESS,ORIGIN, and so forth.", "Opcode": "0x5fmeans it is in a \u201ccontiguous\u201d space with the rest of thePUSHimplementations and potentially could share the implementation.", "Backwards Compatibility": "This EIP introduces a new opcode which did not exist previously. Already deployed contracts using this opcode could change their behaviour after this EIP.", "Test Cases": "The authors are not aware of any impact on security. Note that jumpdest-analysis is unaffected, asPUSH0has no immediate data bytes.", "Security Considerations": "The authors are not aware of any impact on security. Note that jumpdest-analysis is unaffected, asPUSH0has no immediate data bytes.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- push0 instruction: Introduces the PUSH0 instruction, which pushes the constant value 0 onto the stack, reducing gas costs and bytecode size.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3860, "url": "https://eips.ethereum.org/EIPS/eip-3860", "title": "Limit and meter initcode", "authors": ["Martin Holst Swende\u00a0(", "@holiman", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Alex Beregszaszi\u00a0(", "@axic", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")"], "sections": {"EIP-3860: Limit and meter initcode": "We extendEIP-170by introducing a maximum size limit forinitcode(MAX_INITCODE_SIZE = 2 * MAX_CODE_SIZE = 49152).", "Limit the maximum size of initcode to 49152 and apply extra gas cost of 2 for every 32-byte chunk of initcode": "We extendEIP-170by introducing a maximum size limit forinitcode(MAX_INITCODE_SIZE = 2 * MAX_CODE_SIZE = 49152).", "Abstract": "We extendEIP-170by introducing a maximum size limit forinitcode(MAX_INITCODE_SIZE = 2 * MAX_CODE_SIZE = 49152).", "Motivation": "During contract creation the client has to perform jumpdest-analysis on theinitcodeprior to execution. The work performed scales linearly with the size of theinitcode. This work currently is not metered, nor is there a protocol enforced upper bound for the size.", "Specification": "WhereMAX_CODE_SIZEis defined byEIP-170as24576.", "Parameters": "WhereMAX_CODE_SIZEis defined byEIP-170as24576.", "Rules": "The value ofINITCODE_WORD_COSTis selected based on performance benchmarks of differing worst-cases per implementation. The baseline for the benchmarks is the performance ofKECCAK256hashing in geth 1.10.9, which matches the 70 Mgas/s gas limit target on a 4.0 GHz x86_64 CPU.", "Rationale": "The value ofINITCODE_WORD_COSTis selected based on performance benchmarks of differing worst-cases per implementation. The baseline for the benchmarks is the performance ofKECCAK256hashing in geth 1.10.9, which matches the 70 Mgas/s gas limit target on a 4.0 GHz x86_64 CPU.", "Gas cost constant": "The value ofINITCODE_WORD_COSTis selected based on performance benchmarks of differing worst-cases per implementation. The baseline for the benchmarks is the performance ofKECCAK256hashing in geth 1.10.9, which matches the 70 Mgas/s gas limit target on a 4.0 GHz x86_64 CPU.", "Gas cost per word (32-byte chunk)": "We have chosen the cost of 2 gas per word based on Geth\u2019s implementation and comparing withKECCAK256performance. This means the per byte cost is0.0625. While fractional gas costs are not permitted in the EVM, we can approximate it by charging per-word.", "Reason for size limit of initcode": "Estimating and creating worst case scenarios is easier with an upper bound in place, given one parameter for the search is greatly reduced. This allows for selecting a much more optimistic gas per byte.", "Effect of size limit of initcode": "In most, if not all cases when a new contract is being created, the resulting runtime code is copied from the initcode itself. For the basic case the2 * MAX_CODE_SIZElimit allowsMAX_CODE_SIZEfor runtime code and anotherMAX_CODE_SIZEfor contract constructor code. However, the limit may have practical implications for cases where multiple contracts are deployed in a single create transaction.", "Initcode cost for create transaction": "The initcode cost for create transaction data (0.0625 gas per byte) is negligible compared to the transaction data cost (4 or 16 gas per byte). Despite that, we decided to include it in the specification for consistency, and more importantly for forward compatibility.", "How to report initcode limit violation?": "We specified that initcode size limit violation forCREATE/CREATE2results in exceptional abort of the execution. This places it in the group of early out-of-gas checks, including: stack underflow, memory expansion, static call violation, initcode hashing cost, and initcode cost introduced by this EIP. They precede the later \u201clight\u201d checks: call depth and balance. The choice gives consistency to the order of checks and lowers implementation complexity (out-of-gas checks can be performed in any order).", "Backwards Compatibility": "This EIP requires a \u201cnetwork upgrade\u201d, since it modifies consensus rules.", "Test Cases": "Tests should include the following cases:", "Security Considerations": "For client implementations, this EIP makes attacks based on jumpdest-analysis less problematic, so should increase the robustness of clients.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- limit and meter initcode: Sets a maximum size limit for initcode at 49,152 bytes and introduces a gas cost of 2 for every 32-byte chunk of initcode.\n- max_code_size: The maximum size of EOF contract code is increased to 64 KiB, allowing more complex contracts to be deployed."}
{"eip": 4345, "url": "https://eips.ethereum.org/EIPS/eip-4345", "title": "Difficulty Bomb Delay to June 2022", "authors": ["Tim Beiko\u00a0(", "@timbeiko", ")", "James Hancock\u00a0(", "@MadeOfTin", ")", "Thomas Jay Rush\u00a0(", "@tjayrush", ")"], "sections": {"EIP-4345: Difficulty Bomb Delay to June 2022": "Starting withFORK_BLOCK_NUMBERthe client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 10,700,000 blocks later than the actual block number.", "Delays the difficulty bomb to be noticeable in June 2022.": "Starting withFORK_BLOCK_NUMBERthe client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 10,700,000 blocks later than the actual block number.", "Abstract": "Starting withFORK_BLOCK_NUMBERthe client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 10,700,000 blocks later than the actual block number.", "Motivation": "Targeting for The Merge to occur before June 2022. If it is not ready by then, the bomb can be delayed further.", "Specification": "For the purposes ofcalc_difficulty, simply replace the use ofblock.number, as used in the exponential ice age component, with the formula:", "Rationale": "The following script predicts a ~0.1 second delay to block time by June 2022 and a ~0.5 second delay by July 2022. This gives reason to address because the effect will be seen, but not so much urgency we don\u2019t have space to work around if needed.", "Backwards Compatibility": "No known backward compatibility issues.", "Security Considerations": "Misjudging the effects of the difficulty can mean longer blocktimes than anticipated until a hardfork is released. Wild shifts in difficulty can affect this number severely. Also, gradual changes in blocktimes due to longer-term adjustments in difficulty can affect the timing of difficulty bomb epochs. This affects the usability of the network but unlikely to have security ramifications.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- difficulty bomb delay to june 2022: Delays the Ethereum difficulty bomb, making its effects noticeable by June 2022, to allow time for the Merge to Proof-of-Stake.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4399, "url": "https://eips.ethereum.org/EIPS/eip-4399", "title": "Supplant DIFFICULTY opcode with PREVRANDAO", "authors": ["Mikhail Kalinin\u00a0(", "@mkalinin", ")", "Danny Ryan\u00a0(", "@djrtwo", ")"], "sections": {"EIP-4399: Supplant DIFFICULTY opcode with PREVRANDAO": "This EIP supplants the semantics of the return value of existingDIFFICULTY (0x44)opcode and renames the opcode toPREVRANDAO (0x44).", "Expose beacon chain randomness in the EVM by supplanting DIFFICULTY opcode semantics": "This EIP supplants the semantics of the return value of existingDIFFICULTY (0x44)opcode and renames the opcode toPREVRANDAO (0x44).", "Abstract": "This EIP supplants the semantics of the return value of existingDIFFICULTY (0x44)opcode and renames the opcode toPREVRANDAO (0x44).", "Motivation": "Applications may benefit from using the randomness accumulated by the beacon chain. Thus, randomness outputs produced by the beacon chain should be accessible in the EVM.", "Specification": "Beginning withTRANSITION_BLOCK, client softwareMUSTset the value of themixHash, i.e. the field with the number13(0-indexed) in a block header, to the latest RANDAO mix of the post beacon state of the previous block.", "Definitions": "Beginning withTRANSITION_BLOCK, client softwareMUSTset the value of themixHash, i.e. the field with the number13(0-indexed) in a block header, to the latest RANDAO mix of the post beacon state of the previous block.", "Block structure": "Beginning withTRANSITION_BLOCK, client softwareMUSTset the value of themixHash, i.e. the field with the number13(0-indexed) in a block header, to the latest RANDAO mix of the post beacon state of the previous block.", "EVM": "Beginning withTRANSITION_BLOCK, theDIFFICULTY (0x44)instructionMUSTreturn the value of themixHashfield.", "Renaming": "ThemixHashfieldSHOULDfurther be renamed toprevRandao.", "Rationale": "Including a RANDAO output in the block header provides a straightforward method of accessing it from inside of the EVM as block header data is already available in the EVM context.", "Including RANDAO output in the block header": "Including a RANDAO output in the block header provides a straightforward method of accessing it from inside of the EVM as block header data is already available in the EVM context.", "UsingmixHashfield instead ofdifficulty": "ThemixHashheader field is used instead ofdifficultyto avoid a class of hidden forkchoice bugs after the PoS upgrade.", "Reusing existing field instead of appending a new one": "ThemixHashfield is deprecated at the PoS upgrade and set to zero bytes array thereafter. Reusing an existing field as a place for the randomness output saves 32 bytes per block and effectively removes the deprecation of one of the fields induced by the upgrade.", "Reusing theDIFFICULTYopcode instead of introducing a new one": "See theMotivation.", "Renaming the field and the opcode": "The renaming should be done to make the field and the opcode names semantically sound.", "UsingTRANSITION_BLOCKrather than a block or slot number": "By utilizingTRANSITION_BLOCKto trigger the change in logic defined in this EIP rather than a block or slot number, this EIP is tightly coupled to the PoS upgrade defined byEIP-3675.", "Using2**64threshold to determine PoS blocks": "The probability of RANDAO value to fall into the range between0and2**64and, thus, to be mixed with PoW difficulty values, is drastically low. Though, proposed threshold might seem to have insufficient distance from difficulty values on Ethereum Mainnet (they are currently around2**54), it requires a thousand times increase of the hashrate to make this threshold insecure. Such an increase is considered impossible to occur before the upcoming consensus upgrade.", "Backwards Compatibility": "This EIP introduces backward incompatible changes to the execution and validation of EVM state transitions. As written, this EIP utilizesTRANSITION_BLOCKand is thus tightly coupled with the PoS upgrade introduced inEIP-3675. If this EIP is to be adopted, itMUSTbe scheduled at the same time as EIP-3675.", "Test Cases": "ThePREVRANDAO (0x44)opcode in PoS Ethereum (based on the beacon chain RANDAO implementation) is a source of randomness with different properties to the randomness supplied byBLOCKHASH (0x40)orDIFFICULTY (0x44)opcodes in the PoW network.", "Security Considerations": "ThePREVRANDAO (0x44)opcode in PoS Ethereum (based on the beacon chain RANDAO implementation) is a source of randomness with different properties to the randomness supplied byBLOCKHASH (0x40)orDIFFICULTY (0x44)opcodes in the PoW network.", "Biasability": "The beacon chain RANDAO implementation gives every block proposer 1 bit of influence power per slot. Proposer may deliberately refuse to propose a block on the opportunity cost of proposer and transaction fees to prevent beacon chain randomness (a RANDAO mix) from being updated in a particular slot.", "Predictability": "Obviously, historical randomness provided by any decentralized oracle is 100% predictable. On the contrary, the randomness that is revealed in the future is predictable up to a limited extent.", "Tips for application developers": "The following tips attempt to reduce predictability and biasability of randomness outputs returned byPREVRANDAO (0x44):", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- prevrandao: Supplants the DIFFICULTY opcode with PREVRANDAO, which returns the latest beacon chain randomness in PoS blocks, replacing the former PoW-related difficulty value.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- treturn: A new opcode that allows returning data directly from transient storage without first copying it to memory."}
{"eip": 4788, "url": "https://eips.ethereum.org/EIPS/eip-4788", "title": "Beacon block root in the EVM", "authors": ["Alex Stokes\u00a0(", "@ralexstokes", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")", "Danny Ryan\u00a0(", "@djrtwo", ")", "Martin Holst Swende\u00a0(", "@holiman", ")", "lightclient\u00a0(", "@lightclient", ")"], "sections": {"EIP-4788: Beacon block root in the EVM": "Commit to the hash tree root of each beacon chain block in the corresponding execution payload header.", "Expose beacon chain roots in the EVM": "Commit to the hash tree root of each beacon chain block in the corresponding execution payload header.", "Abstract": "Commit to the hash tree root of each beacon chain block in the corresponding execution payload header.", "Motivation": "Roots of the beacon chain blocks are cryptographic accumulators that allow proofs of arbitrary consensus state.\nExposing these roots inside the EVM allows for trust-minimized access to the consensus layer.\nThis functionality supports a wide variety of use cases that improve trust assumptions of staking pools,\nrestaking constructions, smart contract bridges, MEV mitigations and more.", "Specification": "The high-level idea is that each execution block contains the parent beacon block\u2019s root. Even in the event of missed slots since the previous block root does not change,\nwe only need a constant amount of space to represent this \u201coracle\u201d in each execution block. To improve the usability of this oracle, a small history of block roots\nare stored in the contract.", "Background": "The high-level idea is that each execution block contains the parent beacon block\u2019s root. Even in the event of missed slots since the previous block root does not change,\nwe only need a constant amount of space to represent this \u201coracle\u201d in each execution block. To improve the usability of this oracle, a small history of block roots\nare stored in the contract.", "Block structure and validity": "Beginning at the execution timestampFORK_TIMESTAMP, execution clientsMUSTextend the header schema with an additional field: theparent_beacon_block_root.\nThis root consumes 32 bytes and is exactly thehash tree rootof the parent beacon block for the given execution block.", "Block processing": "At the start of processing any execution block whereblock.timestamp >= FORK_TIMESTAMP(i.e. before processing any transactions), callBEACON_ROOTS_ADDRESSasSYSTEM_ADDRESSwith the 32-byte input ofheader.parent_beacon_block_root, a gas limit of30_000_000, and0value. This will trigger theset()routine of the beacon roots contract. This is a system operation and therefore:", "Rationale": "TheBLOCKHASHopcode could be repurposed to provide the beacon root instead of some execution block hash.\nTo minimize code change, avoid breaking changes to smart contracts, and simplify deployment to mainnet, this EIP suggests leavingBLOCKHASHalone and adding new\nfunctionality with the desired semantics.", "Why not repurposeBLOCKHASH?": "TheBLOCKHASHopcode could be repurposed to provide the beacon root instead of some execution block hash.\nTo minimize code change, avoid breaking changes to smart contracts, and simplify deployment to mainnet, this EIP suggests leavingBLOCKHASHalone and adding new\nfunctionality with the desired semantics.", "Beacon block root instead of state root": "Block roots are preferred over state roots so there is a constant amount of work to do with each new execution block. Otherwise, skipped slots would require\na linear amount of work with each new payload. While skipped slots are quite rare on mainnet, it is best to not add additional load under what would already\nbe nonfavorable conditions.", "Why two ring buffers?": "The first ring buffer only tracksHISTORY_BUFFER_LENGTHworth of roots and so for all possible timestamp values would consume a constant amount of storage.\nHowever, this design opens the contract to an attack where a skipped slot that has the same value modulo the ring buffer length would return an old root value,\nrather than the most recent one.", "Size of ring buffers": "The ring buffer data structures are sized to hold 8191 roots from the consensus layer. Using a prime number as the ring buffer size ensures that no value is overwritten until the entire ring buffer has been saturated and thereafter, each value will be updated once per iteration. This also means that even if the slot times were to change, we would continue to use at most 8191 storage slots.", "Backwards Compatibility": "No issues.", "Test Cases": "N/A", "Reference Implementation": "N/A", "Security Considerations": "N/A", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- execution block hash: A hash derived from hash_tree_root, replacing the traditional keccak256-based block hash in various contexts.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding."}
{"eip": 4844, "url": "https://eips.ethereum.org/EIPS/eip-4844", "title": "Shard Blob Transactions", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Dankrad Feist\u00a0(", "@dankrad", ")", "Diederik Loerakker\u00a0(", "@protolambda", ")", "George Kadianakis\u00a0(", "@asn-d6", ")", "Matt Garnett\u00a0(", "@lightclient", ")", "Mofi Taiwo\u00a0(", "@Inphi", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")"], "sections": {"EIP-4844: Shard Blob Transactions": "Introduce a new transaction format for \u201cblob-carrying transactions\u201d which contain a large amount of data that cannot be\naccessed by EVM execution, but whose commitment can be accessed.\nThe format is intended to be fully compatible with the format that will be used in full sharding.", "Shard Blob Transactions scale data-availability of Ethereum in a simple, forwards-compatible manner.": "Introduce a new transaction format for \u201cblob-carrying transactions\u201d which contain a large amount of data that cannot be\naccessed by EVM execution, but whose commitment can be accessed.\nThe format is intended to be fully compatible with the format that will be used in full sharding.", "Abstract": "Introduce a new transaction format for \u201cblob-carrying transactions\u201d which contain a large amount of data that cannot be\naccessed by EVM execution, but whose commitment can be accessed.\nThe format is intended to be fully compatible with the format that will be used in full sharding.", "Motivation": "Rollups are in the short and medium term, and possibly in the long term, the only trustless scaling solution for Ethereum.\nTransaction fees on L1 have been very high for months and there is greater urgency in doing anything required to help facilitate an ecosystem-wide move to rollups.\nRollups are significantly reducing fees for many Ethereum users: Optimism and Arbitrum frequently provide fees that are ~3-8x lower than the Ethereum base layer itself,\nand ZK rollups, which have better data compression and can avoid including signatures, have fees ~40-100x lower than the base layer.", "Specification": "Throughout this proposal we use cryptographic methods and classes defined in the correspondingconsensus 4844 specs.", "Parameters": "Throughout this proposal we use cryptographic methods and classes defined in the correspondingconsensus 4844 specs.", "Type aliases": "Throughout this proposal we use cryptographic methods and classes defined in the correspondingconsensus 4844 specs.", "Cryptographic Helpers": "Throughout this proposal we use cryptographic methods and classes defined in the correspondingconsensus 4844 specs.", "Helpers": "Approximatesfactor * e ** (numerator / denominator)using Taylor expansion:", "Blob transaction": "We introduce a new type ofEIP-2718transaction, \u201cblob transaction\u201d, where theTransactionTypeisBLOB_TX_TYPEand theTransactionPayloadis the RLP serialization of the followingTransactionPayloadBody:", "Header extension": "The current header encoding is extended with two new 64-bit unsigned integer fields:", "Gas accounting": "We introduce blob gas as a new type of gas. It is independent of normal gas and follows its own targeting rule, similar to EIP-1559.\nWe use theexcess_blob_gasheader field to store persistent data needed to compute the blob gas base fee. For now, only blobs are priced in blob gas.", "Opcode to get versioned hashes": "We add an instructionBLOBHASH(with opcodeHASH_OPCODE_BYTE) which readsindexfrom the top of the stack\nas big-endianuint256, and replaces it on the stack withtx.blob_versioned_hashes[index]ifindex < len(tx.blob_versioned_hashes), and otherwise with a zeroedbytes32value.\nThe opcode has a gas cost ofHASH_OPCODE_GAS.", "Point evaluation precompile": "Add a precompile atPOINT_EVALUATION_PRECOMPILE_ADDRESSthat verifies a KZG proof which claims that a blob\n(represented by a commitment) evaluates to a given value at a given point.", "Consensus layer validation": "On the consensus layer the blobs are referenced, but not fully encoded, in the beacon block body.\nInstead of embedding the full contents in the body, the blobs are propagated separately, as \u201csidecars\u201d.", "Execution layer validation": "On the execution layer, the block validity conditions are extended as follows:", "Networking": "Blob transactions have two network representations. During transaction gossip responses (PooledTransactions), the EIP-2718TransactionPayloadof the blob transaction is wrapped to become:", "Rationale": "This EIP introduces blob transactions in the same format in which they are expected to exist in the final sharding specification.\nThis provides a temporary but significant scaling relief for rollups by allowing them to initially scale to 0.375 MB per slot,\nwith a separate fee market allowing fees to be very low while usage of this system is limited.", "On the path to sharding": "This EIP introduces blob transactions in the same format in which they are expected to exist in the final sharding specification.\nThis provides a temporary but significant scaling relief for rollups by allowing them to initially scale to 0.375 MB per slot,\nwith a separate fee market allowing fees to be very low while usage of this system is limited.", "How rollups would function": "Instead of putting rollup block data in transaction calldata, rollups would expect rollup block submitters\nto put the data into blobs. This guarantees availability (which is what rollups need) but would be much cheaper than calldata.\nRollups need data to be available once, long enough to ensure honest actors can construct the rollup state, but not forever.", "Versioned hashes & precompile return data": "We use versioned hashes (rather than commitments) as references to blobs in the execution layer to ensure forward compatibility with future changes.\nFor example, if we need to switch to Merkle trees + STARKs for quantum-safety reasons, then we would add a new version,\nallowing the point evaluation precompile to work with the new format.\nRollups would not have to make any EVM-level changes to how they work;\nsequencers would simply have to switch over to using a new transaction type at the appropriate time.", "Base fee per blob gas update rule": "The base fee per blob gas update rule is intended to approximate the formulabase_fee_per_blob_gas = MIN_BASE_FEE_PER_BLOB_GAS * e**(excess_blob_gas / BLOB_BASE_FEE_UPDATE_FRACTION),\nwhereexcess_blob_gasis the total \u201cextra\u201d amount of blob gas that the chain has consumed relative to the \u201ctargeted\u201d number (TARGET_BLOB_GAS_PER_BLOCKper block).\nLike EIP-1559, it\u2019s a self-correcting formula: as the excess goes higher, thebase_fee_per_blob_gasincreases exponentially, reducing usage and eventually forcing the excess back down.", "Throughput": "The values forTARGET_BLOB_GAS_PER_BLOCKandMAX_BLOB_GAS_PER_BLOCKare chosen to correspond to a target of 3 blobs (0.375 MB) and maximum of 6 blobs (0.75 MB) per block. These small initial limits are intended to minimize the strain on the network created by this EIP and are expected to be increased in future upgrades as the network demonstrates reliability under larger blocks.", "Backwards Compatibility": "This EIP introduces a transaction type that has a distinct mempool version and execution-payload version,\nwith only one-way convertibility between the two. The blobs are in the network representation and not in the consensus representation;\ninstead, they are coupled with the beacon block. This means that there is now a part of a transaction that will not be accessible from the web3 API.", "Blob non-accessibility": "This EIP introduces a transaction type that has a distinct mempool version and execution-payload version,\nwith only one-way convertibility between the two. The blobs are in the network representation and not in the consensus representation;\ninstead, they are coupled with the beacon block. This means that there is now a part of a transaction that will not be accessible from the web3 API.", "Mempool issues": "Blob transactions have a large data size at the mempool layer, which poses a mempool DoS risk,\nthough not an unprecedented one as this also applies to transactions with large amounts of calldata.", "Test Cases": "Execution layer test cases for this EIP can be found in theeip4844_blobsof theethereum/execution-spec-testsrepository. Consensus layer test cases can be foundhere.", "Security Considerations": "This EIP increases the bandwidth requirements per beacon block by a maximum of ~0.75 MB.\nThis is 40% larger than the theoretical maximum size of a block today (30M gas / 16 gas per calldata byte = 1.875M bytes), and so it will not greatly increase worst-case bandwidth.\nPost-merge, block times are static rather than an unpredictable Poisson distribution, giving a guaranteed period of time for large blocks to propagate.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- shard blob transactions: Introduces a new transaction type for blobs of data that improve Ethereum\u2019s data availability, a key step toward full sharding, scaling Ethereum while maintaining backward compatibility.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding."}
{"eip": 4895, "url": "https://eips.ethereum.org/EIPS/eip-4895", "title": "Beacon chain push withdrawals as operations", "authors": ["Alex Stokes\u00a0(", "@ralexstokes", ")", "Danny Ryan\u00a0(", "@djrtwo", ")"], "sections": {"EIP-4895: Beacon chain push withdrawals as operations": "Introduce a system-level \u201coperation\u201d to support validator withdrawals that are \u201cpushed\u201d from the beacon chain to the EVM.", "Support validator withdrawals from the beacon chain to the EVM via a new \"system-level\" operation type.": "Introduce a system-level \u201coperation\u201d to support validator withdrawals that are \u201cpushed\u201d from the beacon chain to the EVM.", "Abstract": "Introduce a system-level \u201coperation\u201d to support validator withdrawals that are \u201cpushed\u201d from the beacon chain to the EVM.", "Motivation": "This EIP provides a way for validator withdrawals made on the beacon chain to enter into the EVM.\nThe architecture is \u201cpush\u201d-based, rather than \u201cpull\u201d-based, where withdrawals are required to be processed in the execution layer as soon as they are dequeued from the consensus layer.", "Specification": "Beginning with the execution timestampFORK_TIMESTAMP, execution clientsMUSTintroduce the following extensions to payload validation and processing:", "System-level operation: withdrawal": "Define a new payload-level object called awithdrawalthat describes withdrawals that have been validated at the consensus layer.Withdrawals are syntactically similar to a user-level transaction but live in a different domain than user-level transactions.", "New field in the execution payload: withdrawals": "The execution payload gains a new field for thewithdrawalswhich is an RLP list ofWithdrawaldata.", "New field in the execution payload header: withdrawals root": "The execution payload header gains a new field committing to thewithdrawalsin the execution payload.", "Execution payload validity": "Assuming the execution payload is well-formatted, the execution client has an additional payload validation to ensure that thewithdrawals_rootmatches the expected value given the list in the payload.", "State transition": "Thewithdrawalsin an execution payload are processedafterany user-level transactions are applied.", "Rationale": "This EIP suggests a new type of object \u2013 the \u201cwithdrawal operation\u201d \u2013 as it has special semantics different from other existing types of EVM transactions.", "Why not a new transaction type?": "This EIP suggests a new type of object \u2013 the \u201cwithdrawal operation\u201d \u2013 as it has special semantics different from other existing types of EVM transactions.", "Why no (gas) costs for the withdrawal type?": "The maximum number of withdrawals that can reach the execution layer at a given time is bounded (enforced by the consensus layer) and this limit has been chosen so that\nany execution layer operational costs are negligible in the context of the broader payload execution.", "Why only balance updates? No general EVM execution?": "More general processing introduces the risk of failures, which complicates accounting on the beacon chain.", "Backwards Compatibility": "No issues.", "Security Considerations": "Consensus-layer validation of withdrawal transactions is critical to ensure that the proper amount of ETH is withdrawn back into the execution layer.\nThis consensus-layer to execution-layer ETH transfer does not have a current analog in the EVM and thus deserves very high security scrutiny.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- beacon chain push withdrawals: Implements push-based validator withdrawals from the beacon chain to the EVM via a system-level operation, allowing for seamless withdrawals without user intervention.\n- withdrawal: Log entry in system_logs for tracking withdrawals under EIP-4895 ."}
{"eip": 5133, "url": "https://eips.ethereum.org/EIPS/eip-5133", "title": "Delaying Difficulty Bomb to mid-September 2022", "authors": ["Tomasz Kajetan Stanczak\u00a0(", "@tkstanczak", ")", "Eric Marti Haynes\u00a0(", "@ericmartihaynes", ")", "Josh Klopfenstein\u00a0(", "@joshklop", ")", "Abhimanyu Nag\u00a0(", "@AbhiMan1601", ")"], "sections": {"EIP-5133: Delaying Difficulty Bomb to mid-September 2022": "Starting withFORK_BLOCK_NUMBERthe client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 11,400,000 blocks later than the actual block number.", "Delays the difficulty bomb by a further 700000 blocks, to the middle of September 2022.": "Starting withFORK_BLOCK_NUMBERthe client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 11,400,000 blocks later than the actual block number.", "Abstract": "Starting withFORK_BLOCK_NUMBERthe client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 11,400,000 blocks later than the actual block number.", "Motivation": "To avoid network degradation due to a premature activation of the difficulty bomb.", "Specification": "For the purposes ofcalc_difficulty, simply replace the use ofblock.number, as used in the exponential ice age component, with the formula:", "Rationale": "The following script predicts the bomb will go off at block 15530314, which is expected to be mined around mid-September.", "Backwards Compatibility": "No known backward compatibility issues.", "Security Considerations": "Misjudging the effects of the difficulty can mean longer blocktimes than anticipated until a hardfork is released. Wild shifts in difficulty can affect this number severely. Also, gradual changes in blocktimes due to longer-term adjustments in difficulty can affect the timing of difficulty bomb epochs. This affects the usability of the network but unlikely to have security ramifications.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5656, "url": "https://eips.ethereum.org/EIPS/eip-5656", "title": "MCOPY - Memory copying instruction", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Paul Dworzanski\u00a0(", "@poemm", ")", "Jared Wasinger\u00a0(", "@jwasinger", ")", "Casey Detrio\u00a0(", "@cdetrio", ")", "Pawel Bylica\u00a0(", "@chfast", ")", "Charles Cooper\u00a0(", "@charles-cooper", ")"], "sections": {"EIP-5656: MCOPY - Memory copying instruction": "Provide an efficient EVM instruction for copying memory areas.", "An efficient EVM instruction for copying memory areas": "Provide an efficient EVM instruction for copying memory areas.", "Abstract": "Provide an efficient EVM instruction for copying memory areas.", "Motivation": "Memory copying is a basic operation, yet implementing it on the EVM comes with overhead.", "Specification": "The instructionMCOPYis introduced at0x5E.", "Input stack": "This ordering matches the other copying instructions, i.e.CALLDATACOPY,RETURNDATACOPY.", "Gas costs": "Per yellow paper terminology, it should be considered part of theW_copygroup of opcodes, and follow the gas calculation forW_copyin the yellow paper. While the calculation in the yellow paper should be considered the final word, for reference, as of time of this writing, that currently means its gas cost is:", "Output stack": "This instruction returns no stack items.", "Semantics": "It copieslengthbytes from the offset pointed atsrcto the offset pointed atdstin memory.\nCopying takes place as if an intermediate buffer was used, allowing the destination and source to overlap.", "Rationale": "Production implementation of exact-word memory copying and partial-word memory copying can be found in the Solidity, Vyper and Fe compilers.", "Backwards Compatibility": "This EIP introduces a new instruction which did not exist previously. Already deployed contracts using this instruction could change their behaviour after this EIP.", "Test Cases": "MCOPY 0 32 32- copy 32 bytes from offset 32 to offset 0.", "Full test suite": "A full suite of tests can be found in the execution spec tests:MCOPY suite.", "Security Considerations": "Clients should take care that their implementation does not use an intermediate buffer (see for instance that the C stdlibmemmovefunction does not use an intermediate buffer), as this is a potential Denial of Service (DoS) vector. Most language builtins / standard library functions for moving bytes have the correct performance characteristics here.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- mcopy: Adds the MCOPY opcode to efficiently copy memory within the EVM, reducing the gas cost of memory operations compared to using MLOAD and MSTORE.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6780, "url": "https://eips.ethereum.org/EIPS/eip-6780", "title": "SELFDESTRUCT only in same transaction", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")", "Dankrad Feist\u00a0(", "@dankrad", ")"], "sections": {"EIP-6780: SELFDESTRUCT only in same transaction": "This EIP changes the functionality of theSELFDESTRUCTopcode. The new functionality will be only to send all Ether in the account to the target, except that the current behaviour is preserved whenSELFDESTRUCTis called in the same transaction a contract was created.", "SELFDESTRUCT will recover all funds to the target but not delete the account, except when called in the same transaction as creation": "This EIP changes the functionality of theSELFDESTRUCTopcode. The new functionality will be only to send all Ether in the account to the target, except that the current behaviour is preserved whenSELFDESTRUCTis called in the same transaction a contract was created.", "Abstract": "This EIP changes the functionality of theSELFDESTRUCTopcode. The new functionality will be only to send all Ether in the account to the target, except that the current behaviour is preserved whenSELFDESTRUCTis called in the same transaction a contract was created.", "Motivation": "TheSELFDESTRUCTopcode requires large changes to the state of an account, in particular removing all code and storage. This will not be possible in the future with Verkle trees: Each account will be stored in many different account keys, which will not be obviously connected to the root account.", "Specification": "The behaviour ofSELFDESTRUCTis changed in the following way:", "Rationale": "Getting rid of theSELFDESTRUCTopcode has been considered in the past, and there are currently no strong reasons to use it. This EIP implements a behavior that will attempt to leave some common uses ofSELFDESTRUCTworking, while reducing the complexity of the change on EVM implementations that would come from contract versioning.", "Backwards Compatibility": "This EIP requires a hard fork, since it modifies consensus rules.", "Test Cases": "Test cases for this EIP can be found in the Execution Spec Tests suiteeip6780_selfdestruct.", "Security Considerations": "The following applications ofSELFDESTRUCTwill be broken and applications that use it in this way are not safe anymore:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- selfdestruct only in same transaction: Limits SELFDESTRUCT to only fully delete contracts if called in the same transaction as contract creation; otherwise, it transfers ether but keeps the contract intact.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7044, "url": "https://eips.ethereum.org/EIPS/eip-7044", "title": "Perpetually Valid Signed Voluntary Exits", "authors": ["Lion\u00a0(", "@dapplion", ")"], "sections": {"EIP-7044: Perpetually Valid Signed Voluntary Exits": "Lock validator voluntary exit signature domain on Capella for perpetual validity. Currently, signed voluntary exits are only valid for two upgrades.", "Lock voluntary exit signature domain on capella for perpetual validity": "Lock validator voluntary exit signature domain on Capella for perpetual validity. Currently, signed voluntary exits are only valid for two upgrades.", "Abstract": "Lock validator voluntary exit signature domain on Capella for perpetual validity. Currently, signed voluntary exits are only valid for two upgrades.", "Motivation": "Currently, signed voluntary exits are valid up-to only two upgrades for block inclusion due to the Beacon Chain state considering only the current and previous fork version. This limitation increases the complexity of some staking operations, specifically those in which the staking operator (holder of active key) is distinct from the owner of the funds (holder of the withdrawal credential). Because voluntary exits can only be signed by the active key, such a relationship requires the exchange of signed exits ahead of time for an unbounded number of forks.", "Specification": "Specification changes are built into the Consensus Specs Deneb upgrade.", "Consensus Layer": "Specification changes are built into the Consensus Specs Deneb upgrade.", "Execution Layer": "This specification does not require any changes to the Execution Layer.", "Rationale": "Perpetually valid signed voluntary exits allow simpler staking operation designs. It also aligns the UX of such objects toBLSToExecutionChangesand deposits, such that downstream tooling does not need to be updated with fork version information.", "Backwards Compatibility": "This change is backwards compatible to the Consensus Layer of Ethereum block processing logic.", "Test Cases": "Test cases for this EIP can be found in thedenebtest suite of theconsensus-specsrepository.", "Security Considerations": "The divergent signature domains across forked networks would previously have prevented the replay of VoluntaryExits after two hard forks. This specification change causes the replay protection to no longer exist. These potential replays could impact individual stakers on both sides of a fork, but does not put funds at risk and does not impact the security of the chain.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- perpetually valid signed voluntary exits: Locks the voluntary exit signature domain on Capella, allowing validator exits to be valid across future forks without needing to be re-signed.\n- withdrawal: Log entry in system_logs for tracking withdrawals under EIP-4895 ."}
{"eip": 7045, "url": "https://eips.ethereum.org/EIPS/eip-7045", "title": "Increase max attestation inclusion slot", "authors": ["Danny Ryan\u00a0(", "@djrtwo", ")"], "sections": {"EIP-7045: Increase max attestation inclusion slot": "Increases max attestation inclusion slot fromattestation.slot + SLOTS_PER_EPOCHto the last slot of epochN+1whereNis the epoch containing the attestation slot.", "Increases max attestation inclusion slot to the last slot in `N+1` where `N` is the epoch containing the attestation's slot.": "Increases max attestation inclusion slot fromattestation.slot + SLOTS_PER_EPOCHto the last slot of epochN+1whereNis the epoch containing the attestation slot.", "Abstract": "Increases max attestation inclusion slot fromattestation.slot + SLOTS_PER_EPOCHto the last slot of epochN+1whereNis the epoch containing the attestation slot.", "Motivation": "Attestations can currently be included after some minimum delay (1slot on mainnet) up untilSLOTS_PER_EPOCHslots after the slot the attestation was created in. This rolling window of one epoch was decided upon during Phase 0 because the equal inclusion window for any attestation was assessed as \u201cfair\u201d. The alternative considered path was to allow inclusion during the current and next epoch which means attestations created during the start of an epoch have more potential slots of inclusion than those at the end of the epoch.", "Specification": "This requires no changes to the Execution Layer.", "Constants": "This requires no changes to the Execution Layer.", "Execution layer": "This requires no changes to the Execution Layer.", "Consensus layer": "Specification changes are built into the Consensus Specs Deneb upgrade.", "Rationale": "As discussed in the Motivation, extending this max inclusion slot to the end of the next epoch is critical for LMD-GHOST security proofs and confirmation rule.", "Extended max inclusion slot": "As discussed in the Motivation, extending this max inclusion slot to the end of the next epoch is critical for LMD-GHOST security proofs and confirmation rule.", "Removal ofinclusion_delayconsideration for target reward": "Previously,get_attestation_participation_flag_indiceswould only set theTIMELY_TARGET_FLAG(and thus reward for an attestation with correct target vote) if the attestation was included within aSLOTS_PER_EPOCHwindow.", "Backwards Compatibility": "This EIP introduces backwards incompatible changes to the block validation rule set on the consensus layer and must be accompanied by a hard fork.", "Test Cases": "Test cases for this EIP can be found in thedenebtest suite of theconsensus-specsrepository.", "Security Considerations": "This improves LMD-GHOST security as well as enables a fast confirmation rule.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- increase max attestation inclusion slot: Extends the maximum inclusion slot for attestations to the last slot of the next epoch (N+1), improving LMD-GHOST security and enabling faster confirmation rules.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding."}
{"eip": 7514, "url": "https://eips.ethereum.org/EIPS/eip-7514", "title": "Add Max Epoch Churn Limit", "authors": ["dapplion\u00a0(", "@dapplion", ")", "Tim Beiko\u00a0(", "@timbeiko", ")"], "sections": {"EIP-7514: Add Max Epoch Churn Limit": "Update the maximum validator growth rate from an exponential to a linear increase by capping the epoch churn limit.", "Modify the churn limit function to upper bound it to a max value": "Update the maximum validator growth rate from an exponential to a linear increase by capping the epoch churn limit.", "Abstract": "Update the maximum validator growth rate from an exponential to a linear increase by capping the epoch churn limit.", "Motivation": "This proposal aims to mitigate the negative externalities of very high level of total ETH supply staked before a proper solution is implemented. In other words, this proposal accepts the complexities of changing the rewards curve and is meant only to slow down growth.", "Specification": "This requires no changes to the Execution Layer.", "Constants": "This requires no changes to the Execution Layer.", "Execution layer": "This requires no changes to the Execution Layer.", "Consensus layer": "The full specification of the proposed change can be found in/specs/deneb/beacon-chain.md.", "Rationale": "Depending on the specific constant selection the churn candecreaseat the activation fork epoch. The Beacon chain spec can handle this without issues. During 2023 Q4 (projected Dencun activation) the churn value will range 14-16. The table below compares the projected validator set assuming a continuous full deposit queue.", "MAX_PER_EPOCH_CHURN_LIMITvalue": "Depending on the specific constant selection the churn candecreaseat the activation fork epoch. The Beacon chain spec can handle this without issues. During 2023 Q4 (projected Dencun activation) the churn value will range 14-16. The table below compares the projected validator set assuming a continuous full deposit queue.", "Backwards Compatibility": "This EIP introduces backward incompatible changes to the block validation rule set on the consensus layer and must be accompanied by a hard fork.", "Test Cases": "Test cases for this EIP can be found in thedenebtest suite of theconsensus-specsrepository.", "Security Considerations": "This EIP breaks the symmetry between the validator entry and exit queues, where the former is bound byMAX_PER_EPOCH_ACTIVATION_CHURN_LIMITwhile the latter isn\u2019t.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- max epoch churn limit: Adds a maximum limit to the validator activation churn per epoch to slow validator growth and allow time for research into long-term solutions.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7516, "url": "https://eips.ethereum.org/EIPS/eip-7516", "title": "BLOBBASEFEE instruction", "authors": ["Carl Beekhuizen\u00a0(", "@carlbeek", ")"], "sections": {"EIP-7516: BLOBBASEFEE instruction": "Add aBLOBBASEFEE (0x4a)instruction that returns the value of the blob base-fee of the current block it is executing in. It is the identical toEIP-3198(BASEFEEopcode) except that it returns the blob base-fee as perEIP-4844.", "Instruction that returns the current data-blob base-fee": "Add aBLOBBASEFEE (0x4a)instruction that returns the value of the blob base-fee of the current block it is executing in. It is the identical toEIP-3198(BASEFEEopcode) except that it returns the blob base-fee as perEIP-4844.", "Abstract": "Add aBLOBBASEFEE (0x4a)instruction that returns the value of the blob base-fee of the current block it is executing in. It is the identical toEIP-3198(BASEFEEopcode) except that it returns the blob base-fee as perEIP-4844.", "Motivation": "The intended use case would be for contracts to get the value of the blob base-fee. This feature enables blob-data users to programmatically account for the blob gas price, eg:", "Specification": "Add aBLOBBASEFEEinstruction with opcode0x4a, with gas cost2.", "Rationale": "The value of the blob base-fee is needed to process data-blob transactions. That means its value is already available before running the EVM code.\nThe instruction does not add extra complexity and additional read/write operations, hence the choice of2gas cost. This is also identical toEIP-3198(BASEFEEopcode)\u2019s cost as it just makes available data that is in the header.", "Gas cost": "The value of the blob base-fee is needed to process data-blob transactions. That means its value is already available before running the EVM code.\nThe instruction does not add extra complexity and additional read/write operations, hence the choice of2gas cost. This is also identical toEIP-3198(BASEFEEopcode)\u2019s cost as it just makes available data that is in the header.", "Backwards Compatibility": "There are no known backward compatibility issues with this instruction.", "Test Cases": "Assume callingget_blob_gasprice(header)(as defined inEIP-4844 \u00a7Gas accounting) on the current block\u2019s header returns7 wei:BLOBBASEFEEshould push the value7(left padded byte32) to the stack.", "Nominal Case": "Assume callingget_blob_gasprice(header)(as defined inEIP-4844 \u00a7Gas accounting) on the current block\u2019s header returns7 wei:BLOBBASEFEEshould push the value7(left padded byte32) to the stack.", "Comprehensive Test Suite": "A complete suite of tests can be foundhere.", "Security Considerations": "The value of the blob base-fee is not sensitive and is publicly accessible in the block header. There are no known security implications with this instruction.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- blobbasefee instruction: Introduces the BLOBBASEFEE opcode to return the blob base fee of the current block, enabling contracts to account for blob data costs.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2537, "url": "https://eips.ethereum.org/EIPS/eip-2537", "title": "2025-04-01", "authors": ["Precompile for BLS12-381 curve operations"], "sections": {"EIP-2537: Precompile for BLS12-381 curve operations": "Add functionality to efficiently perform operations over the BLS12-381 curve, including those for BLS signature verification.", "Adds operation on BLS12-381 curve as a precompile in a set necessary to efficiently perform operations such as BLS signature verification.": "Add functionality to efficiently perform operations over the BLS12-381 curve, including those for BLS signature verification.", "Abstract": "Add functionality to efficiently perform operations over the BLS12-381 curve, including those for BLS signature verification.", "Motivation": "The motivation of this precompile is to add a cryptographic primitive that allows to get 120+ bits of security for operations over pairing friendly curve compared to the existing BN254 precompile that only provides 80 bits of security.", "Specification": "We introducesevenseparate precompiles to perform the following operations:", "Constants": "We introducesevenseparate precompiles to perform the following operations:", "Curve parameters": "The BLS12 curve is fully defined by the following set of parameters (coefficientA=0for all BLS12 curves):", "Fields and Groups": "Field Fp is defined as the finite field of sizepwith elements represented as integers between 0 and p-1 (both inclusive).", "Fine points and encoding of base elements": "In order to produce inputs to an operation, one encodes elements of the base field and the extension field.", "ABI for operations": "G1 addition call expects256bytes as an input that is interpreted as byte concatenation of two G1 points (128bytes each). Output is an encoding of addition operation result - single G1 point (128bytes).", "Gas burning on error": "Following the current state of all other precompiles, if a call to one of the precompiles in this EIP results in an error then all the gas supplied along with aCALLorSTATICCALLis burned.", "DDoS protection": "A sane implementation of this EIPshould notcontain potential infinite loops (it is possible and not even hard to implement all the functionality withoutwhileloops) and the gas schedule accurately reflects the time spent on computations of the corresponding function (precompiles pricing reflects an amount of gas consumed in the worst case where such a case exists).", "Gas schedule": "AssumingEcRecoverprecompile as a baseline.", "Rationale": "The motivation section covers a total motivation to have operations over the BLS12-381 curves available. We also extend a rationale for more specific fine points.", "MSM as a separate call": "Explicit separate MSM operation that allows one to save execution time (so gas) by both the algorithm used (namely Pippenger\u2019s algorithm) and (usually forgotten) by the fact thatCALLoperation in Ethereum is expensive (at the time of writing), so one would have to pay non-negligible overhead if e.g. for MSM of100points would have to call the multiplication precompile100times and addition for99times (roughly138600would be saved).", "No dedicated MUL call": "Dedicated MUL precompiles which perform single G1/G2 point by scalar multiplication have exactly the same ABI as MSM withk == 1.\nMSM has to inspect the input length to reject inputs of invalid lengths. Therefore, it should recognize the case ofk == 1and invoke the underlying implementation of single point multiplication to avoid the overhead of more complex multi-scalar multiplication algorithm.", "Backwards Compatibility": "There are no backward compatibility questions.", "Subgroup checks": "MSMs and pairings MUST perform a subgroup check.\nImplementations SHOULD use the optimized subgroup check method detailed in a dedicateddocument.\nOn any input that fails the subgroup check, the precompile MUST return an error.\nAs endomorphism acceleration requires input on the correct subgroup, implementers MAY use endomorphism acceleration.", "Field to curve mapping": "The algorithms and set of parameters for SWU mapping method are provided by a separatedocument", "Test Cases": "Due to the large test parameters space, we first provide properties that various operations must satisfy. We use additive notation for point operations, capital letters (P,Q) for points, small letters (a,b) for scalars. The generator for G1 is labeled asG, the generator for G2 is labeled asH, otherwise we assume random points on a curve in a correct subgroup.0means either scalar zero or point at infinity.1means either scalar one or multiplicative identity.group_orderis the main subgroup order.e(P, Q)means pairing operation wherePis in G1,Qis in G2.", "Benchmarking test cases": "A set of test vectors for quick benchmarking on new implementations is located in a separatefile", "Reference Implementation": "There are two fully spec compatible implementations on the day of writing:", "Security Considerations": "Strictly following the spec will eliminate security implications or consensus implications in a contrast to the previous BN254 precompile.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2935, "url": "https://eips.ethereum.org/EIPS/eip-2935", "title": "2025-04-01", "authors": ["Serve historical block hashes from state"], "sections": {"EIP-2935: Serve historical block hashes from state": "Store lastHISTORY_SERVE_WINDOWhistorical block hashes in the storage of a system contract as part of the block processing logic. Furthermore this EIP has no impact onBLOCKHASHresolution mechanism (and hence its range/costs etc).", "Store and serve last 8192 block hashes as storage slots of a system contract to allow for stateless execution": "Store lastHISTORY_SERVE_WINDOWhistorical block hashes in the storage of a system contract as part of the block processing logic. Furthermore this EIP has no impact onBLOCKHASHresolution mechanism (and hence its range/costs etc).", "Abstract": "Store lastHISTORY_SERVE_WINDOWhistorical block hashes in the storage of a system contract as part of the block processing logic. Furthermore this EIP has no impact onBLOCKHASHresolution mechanism (and hence its range/costs etc).", "Motivation": "EVM implicitly assumes the client has the recent block (hashes) at hand. This assumption is not future-proof given the prospect of stateless clients. Including the block hashes in the state will allow bundling these hashes in the witness provided to a stateless client. This is already possible in the MPT and will become more efficient post-Verkle.", "Specification": "This EIP specifies for storing lastHISTORY_SERVE_WINDOWblock hashes in a ring buffer storage ofHISTORY_SERVE_WINDOWlength. Note thatHISTORY_SERVE_WINDOW>BLOCKHASH_SERVE_WINDOW(which remains unchanged).", "Block processing": "At the start of processing any block where this EIP is active (ie. before processing any transactions), call toHISTORY_STORAGE_ADDRESSasSYSTEM_ADDRESSwith the 32-byte input ofblock.parent.hash, a gas limit of30_000_000, and0value. This will trigger theset()routine of the history contract. This is a system operation following the same convention asEIP-4788and therefore:", "EVM Changes": "TheBLOCKHASHopcode semantics remains the same as before.", "Block hash history contract": "The history contract has two operations:getandset. Thesetoperation is invoked only when thecalleris equal to theSYSTEM_ADDRESSas perEIP-4788. Otherwise thegetoperation is performed.", "EIP-161handling": "The bytecode above will be deployed \u00e0 laEIP-4788. As such the account atHISTORY_STORAGE_ADDRESSwill have code and a nonce of 1, and will be exempt from EIP-161 cleanup.", "Gas costs": "The system update at the beginning of the block, i.e.process_block_hash_history(or via system call to the contract withSYSTEM_ADDRESScaller), will not warm theHISTORY_STORAGE_ADDRESSaccount or its storage slots as perEIP-2929rules. As such the first call to the contract will pay for warming up the account and storage slots it accesses.To clarify further any contract call to theHISTORY_STORAGE_ADDRESSwill follow normal EVM execution semantics.", "Rationale": "Very similar ideas were proposed before. This EIP is a simplification, removing two sources of needless complexity:", "Inserting the parent block hash": "Clients have generally two options for inserting the parent block hash into state:", "Size of ring buffers": "The ring buffer data structure is sized to hold 8191 hashes. In other system contracts a prime ring buffer size is chosen in because using a prime as the modulus ensures that no value is overwritten until the entire ring buffer has been saturated and thereafter, each value will be updated once per iteration, regardless of if some slot are missing or the slot time changes. However, in this EIP the block number is the value in the modulo operation and it only ever increases by 1 each iteration. Which means we can be confident that the ring buffer will always remain saturated.", "Backwards Compatibility": "This EIP introduces backwards incompatible changes to the block validation rule set. But neither of these changes break anything related to current user activity and experience.", "Test Cases": "TBD", "Security Considerations": "Having contracts (system or otherwise) with hot update paths (branches) poses a risk of \u201cbranch\u201d poisioning attacks where attacker could sprinkle trivial amounts of eth around these hot paths (branches). But it has been deemed that cost of attack would escalate significantly to cause any meaningful slow down of state root updates.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6110, "url": "https://eips.ethereum.org/EIPS/eip-6110", "title": "2025-02-21", "authors": ["Supply validator deposits on chain"], "sections": {"EIP-6110: Supply validator deposits on chain": "Appends validator deposits to the Execution Layer block structure. This shifts responsibility of deposit inclusion and validation to the Execution Layer and removes the need for deposit (oreth1data) voting from the Consensus Layer.", "Provides validator deposits as a list of deposit operations added to the Execution Layer block": "Appends validator deposits to the Execution Layer block structure. This shifts responsibility of deposit inclusion and validation to the Execution Layer and removes the need for deposit (oreth1data) voting from the Consensus Layer.", "Abstract": "Appends validator deposits to the Execution Layer block structure. This shifts responsibility of deposit inclusion and validation to the Execution Layer and removes the need for deposit (oreth1data) voting from the Consensus Layer.", "Motivation": "Validator deposits are a core component of the proof-of-stake consensus mechanism. This EIP allows for an in-protocol mechanism of deposit processing on the Consensus Layer and eliminates the proposer voting mechanism utilized currently. This proposed mechanism relaxes safety assumptions and reduces complexity of client software design, contributing to the security of the deposits flow. It also improves validator UX.", "Specification": "DEPOSIT_CONTRACT_ADDRESS,DEPOSIT_EVENT_SIGNATURE_HASHparametersMUSTbe included into client software binary distribution.", "Execution Layer": "DEPOSIT_CONTRACT_ADDRESS,DEPOSIT_EVENT_SIGNATURE_HASHparametersMUSTbe included into client software binary distribution.", "Consensus layer": "Consensus layer changes can be summarized into the following list:", "Rationale": "Depositindexis used to deterministically initializedeposit_requests_start_indexin theBeaconState, this prevents same deposit from being applied twice duringEth1Datapoll deprecation.", "indexfield": "Depositindexis used to deterministically initializedeposit_requests_start_indexin theBeaconState, this prevents same deposit from being applied twice duringEth1Datapoll deprecation.", "Not limiting the size of deposit operations list": "The list is unbounded because of negligible data complexity and absence of potential DoS vectors. SeeSecurity Considerationsfor more details.", "Filtering events byDEPOSIT_CONTRACT_ADDRESSandDEPOSIT_EVENT_SIGNATURE_HASH": "Depending on the design, Deposit smart contract can emit different type of events when deposit is being processed. For instance, Deposit smart contract on Sepolia emitsTransferin addition toDepositEvent. Thus it is important to filter out irrelevant events.", "Backwards Compatibility": "This EIP introduces backwards incompatible changes to the block structure and block validation rule set. But neither of these changes break anything related to user activity and experience.", "Security Considerations": "At the time of the latest update of this document, the total number of submitted deposits is 1,899,120 which is 348MB of deposit data. Assuming frequency of deposit transactions remains the same, historic chain data complexity induced by this EIP can be estimated as 84MB per year which is negligible in comparison to other historical data.", "Data complexity": "At the time of the latest update of this document, the total number of submitted deposits is 1,899,120 which is 348MB of deposit data. Assuming frequency of deposit transactions remains the same, historic chain data complexity induced by this EIP can be estimated as 84MB per year which is negligible in comparison to other historical data.", "DoS vectors": "The code in the deposit contract costs 15,650 gas to run in the cheapest case (when all storage slots are hot and only a single leaf has to be modified). Some deposits in a batch deposit are more expensive, but those costs, when amortized over a large number of deposits, are small at around ~1,000 gas per deposit. Under current gas pricing rules an extra 6,900 gas is charged to make aCALLthat transfers ETH, this is a case of inefficient gas pricing and may be reduced in the future. For future robustness the beacon chain needs to be able to withstand 1,916 deposits in a 30M gas block (15,650 gas per deposit). The limit under current rules is less than 1,271 deposits in a 30M gas block.", "Optimistic sync": "An optimistically syncing node have to rely on the honest majority assumption. That is, if adversary is powerful enough to finalize a deposit sequence, a syncing node will have to apply these deposits disregarding the validity of deposit requests with respect to the execution of a given block. Thus, an adversary that can finalize an invalid chain can also convince an honest node to accept fake deposits. The same is applicable to the validity of execution layer world state today and a new deposit processing design is within boundaries of the existing security model in that regard.", "Weak subjectivity period": "This EIP removes a hard limit on a number of deposits per epoch and makes a block gas limit the only limitation on this number. That is, the limit on deposits per epoch shifts fromMAX_DEPOSITS * SLOTS_PER_EPOCH = 512tomax_deposits_per_30m_gas_block * SLOTS_PER_EPOCH ~ 32,768at 30M gas block (we considermax_deposits_per_30m_gas_block = 1,024for simplicity).", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6916, "url": "https://eips.ethereum.org/EIPS/eip-6916", "title": "2025-01-15", "authors": ["Automatically Reset Testnet"], "sections": {"EIP-6916: Automatically Reset Testnet": "This EIP proposes a specification for an automatically reset testnet, a novel approach to testnets that can be implemented within Ethereum clients. It enables a single testing infrastructure consisting of ephemeral networks with deterministic parameters. Each network iteration is created by a specified function which deterministically generates genesis states.", "A testnet network that periodically rolls back to genesis": "This EIP proposes a specification for an automatically reset testnet, a novel approach to testnets that can be implemented within Ethereum clients. It enables a single testing infrastructure consisting of ephemeral networks with deterministic parameters. Each network iteration is created by a specified function which deterministically generates genesis states.", "Abstract": "This EIP proposes a specification for an automatically reset testnet, a novel approach to testnets that can be implemented within Ethereum clients. It enables a single testing infrastructure consisting of ephemeral networks with deterministic parameters. Each network iteration is created by a specified function which deterministically generates genesis states.", "Motivation": "A testnet which automatically resets can provide an alternative environment for short-term testing of applications, validators and also breaking changes in client implementations. It avoids issues of long running testnets which suffer from state bloat, lack of testnet funds or consensus issues. Periodically resetting the network back to genesis cleans the validator set and returns funds back to faucets while keeping the network reasonably small for easy bootstrapping.", "Specification": "The testnet is set to always reset after a predefined time period. The reset means the generation of the next genesis, discarding the old one and starting a new network. This is possible by introducing functions for the genesis generation and the client reset.", "Genesis": "To connect to the current instance of the network, the client must implement the genesis function. This function defines how the client stores information about the testnet and generates the current genesis. With each reset, the network starts from a new genesis which needs to be built based on given parameters and correspond in EL and CL clients.", "Reset": "The reset function defines an automatic process of throwing away the old data and starting with a new genesis. It depends on the previously defined function for genesis generation which the client must implement in order to be able to automatically follow the latest network iteration.", "Rationale": "Ephemeral testnets with deterministic parameters provide a sustainable alternative to traditional testnets, with the same infrastructure. At each reset, the validator set is cleared, faucets are filled again and the database is kept small.", "Network parameters": "Constants and variables defining testnet properties are arbitrary but need to be crafted considering certain limitations and security properties set out below.", "Security Considerations": "The network itself is providing a secure environment thanks to regular resets. Even if some sort of vulnerability is exploited, it will be cleared on the next reset. This is also a reason to keep periods relatively short (weeks/months opposed to months/years) with a big enough genesis validator set to keep an honest majority.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- automatically reset testnet: Proposes a testnet that automatically resets to genesis at periodic intervals, preventing state bloat and providing a fresh environment for short-term testing.\n- genesis: Log entry in system_logs for initial balances at network genesis .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7002, "url": "https://eips.ethereum.org/EIPS/eip-7002", "title": "2025-02-21", "authors": ["Execution layer triggerable withdrawals"], "sections": {"EIP-7002: Execution layer triggerable withdrawals": "Adds a new mechanism to allow validators to trigger withdrawals and exits from their execution layer (0x01) withdrawal credentials.", "Allow validators to trigger exits and partial withdrawals via their execution layer (0x01) withdrawal credentials": "Adds a new mechanism to allow validators to trigger withdrawals and exits from their execution layer (0x01) withdrawal credentials.", "Abstract": "Adds a new mechanism to allow validators to trigger withdrawals and exits from their execution layer (0x01) withdrawal credentials.", "Motivation": "Validators have two keys \u2013 an active key and a withdrawal credential. The active key takes the form of a BLS key, whereas the withdrawal credential can either be a BLS key (0x00) or an execution layer address (0x01). The active key is \u201chot\u201d, actively signing and performing validator duties, whereas the withdrawal credential can remain \u201ccold\u201d, only performing limited operations in relation to withdrawing and ownership of the staked ETH. Due to this security relationship, the withdrawal credential ultimately is the key that owns the staked ETH and any rewards.", "Specification": "The new withdrawal request operation is anEIP-7685request\nwith type0x01and consists of the following fields:", "Configuration": "The new withdrawal request operation is anEIP-7685request\nwith type0x01and consists of the following fields:", "Execution layer": "The new withdrawal request operation is anEIP-7685request\nwith type0x01and consists of the following fields:", "Consensus layer": "Full specification", "Rationale": "Multiple validators can utilize the same execution layer withdrawal credential, thus thevalidator_pubkeyfield is utilized to disambiguate which validator is being exited.", "validator_pubkeyfield": "Multiple validators can utilize the same execution layer withdrawal credential, thus thevalidator_pubkeyfield is utilized to disambiguate which validator is being exited.", "Message queue": "The contract maintains an in-state queue of withdrawal request messages to be dequeued each block into the block and thus into the execution layer.", "Rate limiting using a fee": "Transactions are naturally rate-limited in the execution layer via the gas limit, but an adversary willing to pay market-rate gas fees (and potentially utilize builder markets to pay for front-of-block transaction inclusion) can fill up the exit operation limits for relatively cheap, thus griefing honest validators that want to make a withdrawal request.", "TARGET_WITHDRAWAL_REQUESTS_PER_BLOCKconfiguration value": "TARGET_WITHDRAWAL_REQUESTS_PER_BLOCKhas been selected as2such that the growth of the partial withdrawal queue in the beacon state is negligible under extreme scenarios of the exit churn congestion.", "Fee update rule": "The fee update rule is intended to approximate the formulafee = MIN_WITHDRAWAL_REQUEST_FEE * e**(excess / WITHDRAWAL_REQUEST_FEE_UPDATE_FRACTION), whereexcessis the total \u201cextra\u201d amount of withdrawal requests that the chain has processed relative to the \u201ctargeted\u201d number (TARGET_WITHDRAWAL_REQUESTS_PER_BLOCKper block).", "Withdrawal requests inside of the block": "Withdrawal requests are placed into the actual body of the beacon block.", "Submitting requests via execution layer": "Verifyingsecp256k1signatures from the consensus layer via Engine API is one of the alternatives to the proposed requests mechanism which engineering complexity is much lower.\nHowever, this approach would limit usage of withdrawal requests to a large extent by making it impossible for smart contracts owning validator withdrawal credentials to benefit from this functionality.", "Backwards Compatibility": "This EIP introduces backwards incompatible changes to the block structure and block validation rule set. But neither of these changes break anything related to current user activity and experience.", "Security Considerations": "There might be existing custody relationships and/or products that rely upon the assumption that the withdrawal credentialscannottrigger a withdrawal request. We are currently confident that the additional withdrawal credentials feature does not impact the security of existing validators because:", "Impact on existing custody relationships": "There might be existing custody relationships and/or products that rely upon the assumption that the withdrawal credentialscannottrigger a withdrawal request. We are currently confident that the additional withdrawal credentials feature does not impact the security of existing validators because:", "Fee Overpayment": "Calls to the system contract require a fee payment defined by the current contract state. Overpaid fees are not returned to the caller. It is not generally possible to compute the exact required fee amount ahead of time. When adding a withdrawal request from a contract, the contract can perform a read operation to check for the current fee and then pay exactly the required amount. Here is an example in Solidity:", "System Call failure": "Although the likelihood of a failed system call toWITHDRAWAL_REQUEST_PREDEPLOY_ADDRESSis extremely low, the behavior in such cases is well-defined: the block is marked as invalid. However, if the failure results from processing a transaction within the block, the public mempool may still retain the transaction even after the block is invalidated. This can result in the offending transaction being included again, potentially causing one or more subsequent slots to go without valid blocks. To mitigate this, we recommend that the block producer implementation shuffle their transaction set to increase the chances of producing a valid block, without the offending transaction(s). The block producer implementation and/or the mempool should be aware of system call failure scenarios to enable this behavior.", "Empty Code failure": "This EIP should not have been activated if there is no code present atWITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS(i.e., if the chain is not \u201cready\u201d). Doing so would cause the first and all subsequent blocks afterFORK_BLOCKto be marked invalid.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- withdrawal: Log entry in system_logs for tracking withdrawals under EIP-4895 .\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding."}
{"eip": 7251, "url": "https://eips.ethereum.org/EIPS/eip-7251", "title": "2025-02-21", "authors": ["Increase the MAX_EFFECTIVE_BALANCE"], "sections": {"EIP-7251: Increase the MAX_EFFECTIVE_BALANCE": "Increases the constantMAX_EFFECTIVE_BALANCE, while keeping the minimum staking balance32 ETH. This permits large node operators to consolidate into fewer validators while also allowing solo-stakers to earn compounding rewards and stake in more flexible increments.", "Allow validators to have larger effective balances, while maintaining the 32 ETH lower bound.": "Increases the constantMAX_EFFECTIVE_BALANCE, while keeping the minimum staking balance32 ETH. This permits large node operators to consolidate into fewer validators while also allowing solo-stakers to earn compounding rewards and stake in more flexible increments.", "Abstract": "Increases the constantMAX_EFFECTIVE_BALANCE, while keeping the minimum staking balance32 ETH. This permits large node operators to consolidate into fewer validators while also allowing solo-stakers to earn compounding rewards and stake in more flexible increments.", "Motivation": "As of October 3, 2023, there are currently over 830,000 validators participating in the consensus layer. The size of this set continues to grow due, in part, to theMAX_EFFECTIVE_BALANCE, which limits the stake of a single validator to32 ETH. This leads to large amounts of \u201credundant validators\u201d, which are controlled by a single entity, possibly running on the same beacon node, but with distinct BLS signing keys. The limit on theMAX_EFFECTIVE_BALANCEis technical debt from the original sharding design, in which subcommittees (not the attesting committee but the committee calculated inis_aggregator) needed to be majority honest. As a result, keeping the weights of subcommittee members approximately equal reduced the risk of a single large validator containing too much influence. Under the current design, these subcommittees are only used for attestation aggregation, and thus only have a1/Nhonesty assumption.", "Specification": "The new consolidation request is anEIP-7685request with type0x02consisting of the following fields:", "Constants": "The new consolidation request is anEIP-7685request with type0x02consisting of the following fields:", "Execution layer": "The new consolidation request is anEIP-7685request with type0x02consisting of the following fields:", "Consensus layer": "The defining features of this EIP are:", "Rationale": "This EIP aims to reduce the total number of validators without changing anything about the economic security of the protocol. It provides a mechanism by which large node operators who control significant amounts of stake can consolidate into fewer validators. We analyze the reasoning behind each of the core features.", "Increasing theMAX_EFFECTIVE_BALANCE, while creating aMIN_ACTIVATION_BALANCE": "While increasing theMAX_EFFECTIVE_BALANCEto allow larger-stake validators, it is important to keep the lower bound of32 ETH(by introducing a new constant \u2013MIN_ACTIVATION_BALANCE) to encourage solo-staking.", "Allowing for multiple validator indices to be combined through the protocol": "For large staking pools that already control thousands of validators, exiting and re-entering would be extremely slow and costly. The adoption of the EIP will be much higher by allowing in-protocol consolidation.", "Adding execution layer partial withdrawals (part ofEIP-7002)": "For validators that choose to raise their effective balance ceiling, allowing for custom partial withdrawals triggered from the execution layer increases the flexibility of the staking configurations. Validators can choose when and how much they withdraw but will have to pay gas for the EL transaction.", "Making the initial slashing penalty negligible": "To encourage consolidation, we could modify the slashing penalties. The biggest hit comes from the initial penalty of1/32of the validator\u2019s effective balance. Since this scales linearly on the effective balance, the higher-stake validators directly incur higher risk. By changing the scaling properties, we could make consolidation more attractive.", "Consolidation contract parameter values": "The consolidation smart contract uses a fee mechanism to rate limit the number of requests per block. Details of the fee mechanism are available inEIP-7002.", "Backwards Compatibility": "This EIP introduces backward incompatible changes to the block validation rule set and must be accompanied by a hard fork. These changes do not break anything related to current user activity and experience.", "Security Considerations": "This change modifies committees and churn, but doesn\u2019t significantly impact the security properties.", "Security of attestation committees": "Given full consolidation as the worst case, the probability of an adversarial takeover of a committee remains low. Even in a high consolidation scenario, the required share of honest validators remains well below the 2/3 supermajority needed for finality.", "Aggregator selection": "In the original sharding roadmap, subcommittees were required to be secure with extremely high probability. Now with the sole responsibility of attestation aggregation, we only require each committee to have at least one honest aggregator. Currently, aggregators are selected through a VRF lottery, targeting several validator units that can be biased by non-consolidated attackers. This proposal changes the VRF lottery to consider weight, so the probability of having at least one honest aggregator is not worse.", "Proposer selection probability": "Proposer selection is already weighted by the ratio of their effective balance toMAX_EFFECTIVE_BALANCE. Due to the lower probabilities, this change will slightly increase the time it takes to calculate the next proposer index.", "Sync committee selection probability": "Sync committee selection is also already weighted by effective balance, so this proposal does not require modifications to the sync protocol. Light clients can still check that a super-majority of participants have signed an update irrespective of their weights since we maintain a weight-based selection probability.", "Churn invariants": "This proposal maintains the activation and exit churn invariants limiting active weight instead of validator count. Balance top-ups are now handled explicitly, being subject to the same activation queue as full deposits.", "Fee Overpayment": "Calls to the system contract require a fee payment defined by the current contract state. Overpaid fees are not returned to the caller. It is not generally possible to compute the exact required fee amount ahead of time. When adding a consolidation request from a contract, the contract can perform a read operation to check for the current fee and then pay exactly the required amount. Here is an example in Solidity:", "Consolidation queue hard limit": "Consolidations exceeding the hard limit of the consolidation queue (262,144 requests) will be discarded by the consensus layer and will need to be re-submitted,\nnote that the fee is not refunded in this case.", "System Call failure": "Although the likelihood of a failed system call toCONSOLIDATION_REQUEST_PREDEPLOY_ADDRESSis extremely low, the behavior in such cases is well-defined: the block is marked as invalid. This consideration directly follows fromEIP-7002", "Empty Code failure": "This EIP should not have been activated if there is no code present atCONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS(i.e., if the chain is not \u201cready\u201d). This is also similar to the consideration inEIP-7002", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- withdrawal: Log entry in system_logs for tracking withdrawals under EIP-4895 .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7523, "url": "https://eips.ethereum.org/EIPS/eip-7523", "title": "2024-03-26", "authors": ["Empty accounts deprecation"], "sections": {"EIP-7523: Empty accounts deprecation": "This EIP prohibits the state of any post-merge network from containing empty accounts. Since no empty accounts exist outside the testsuite and no new ones can be created this requirement is already achieved in practice. An explicit ban reduces technical debt going forward.", "Prohibit empty accounts on post-merge networks": "This EIP prohibits the state of any post-merge network from containing empty accounts. Since no empty accounts exist outside the testsuite and no new ones can be created this requirement is already achieved in practice. An explicit ban reduces technical debt going forward.", "Abstract": "This EIP prohibits the state of any post-merge network from containing empty accounts. Since no empty accounts exist outside the testsuite and no new ones can be created this requirement is already achieved in practice. An explicit ban reduces technical debt going forward.", "Motivation": "The possibility of empty accounts is a historical artifact of the early history of Ethereum. The only networks that have ever been capable of containing them are Ethereum Mainnet, the deprecated testnet Ropsten, Etheruem Classic Mainnet and various Ethereum Classic testnets. All remaining empty accounts on Mainnet were cleared in block14049881(transaction0xf955834bfa097458a9cf6b719705a443d32e7f43f20b9b0294098c205b4bcc3d) and a similar transaction was sent on Ethereum Classic. None of the other myriad EVM-compatible networks are old enough to have empty accounts and there is no realistic prospect that anyone will encounter an empty account in a production context.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "This EIP was drafted to be the simplest possible way of eliminating the long term technical debt imposed by empty accounts. The Merge was chosen as a natural easily identifiable cutoff point.", "Backwards Compatibility": "As EIP does not change any behaviour that can occur outside the testsuite, it has no backwards compatibility consequences.", "Security Considerations": "The validity of this EIP is dependent on the assertion that all empty accounts on Ethereum Mainnet were cleared prior to the merge. This should be subject to appropriate verification.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7549, "url": "https://eips.ethereum.org/EIPS/eip-7549", "title": "2025-02-21", "authors": ["Move committee index outside Attestation"], "sections": {"EIP-7549: Move committee index outside Attestation": "Move the committeeindexfield outside of the signed Attestation message to allow aggregation of equal consensus votes.", "Move committee index outside of the signed Attestation message": "Move the committeeindexfield outside of the signed Attestation message to allow aggregation of equal consensus votes.", "Abstract": "Move the committeeindexfield outside of the signed Attestation message to allow aggregation of equal consensus votes.", "Motivation": "This proposal aims to make Casper FFG clients more efficient by reducing the average number of pairings needed to verify consensus rules. While all types of clients can benefit from this EIP, ZK circuits proving Casper FFG consensus are likely to have the most impact.", "Specification": "This requires no changes to the Execution Layer.", "Execution layer": "This requires no changes to the Execution Layer.", "Consensus layer": "The full specification of the proposed change can be found in/specs/electra/beacon-chain.md.", "Rationale": "Theindexfield inAttestationDatacan be deprecated by:", "Deprecation strategy": "Theindexfield inAttestationDatacan be deprecated by:", "MAX_ATTESTATIONSvalue": "The maximum size of an attestation increases, with a bitfield 64 times larger on networks with maxed committees.MAX_ATTESTATIONSvalue is reduced to limit the beacon block size while still increasing the total capacity of votes. A value of 8 increases the voting capacity by 4 while having the same attestation space size with a network of 1.2M active indices.\nRead the detailshere.", "MAX_ATTESTER_SLASHINGSvalue": "On-chainAttesterSlashingincludes a list of participants\u2019 indices. With this EIP the worst-case size increases by 64 times, resulting in an uncompressed size of 488 KB perAttesterSlashingin a network of 1M validators. Snappy compression reduces it to 320 KB, which is still significant. To bound the maximum size of the block this proposal reducesMAX_ATTESTER_SLASHINGSfrom 2 to 1, the minimum value.\nRead the detailshere.", "UsingBitvectorforcommittee_bits": "Thecommittee_bitssequence has a variable length with the max sizeMAX_COMMITTEES_PER_SLOT = 64. Encoding of theBitlistincludes its actual length which doubles the size of thecommittee_bitscomparing to theBitvectortype. Beacon chain state transition ensures correctness of thecommittee_bitswhen effective number of committees in a slot is less than its max value.", "Backwards Compatibility": "This EIP introduces backward incompatible changes to the block validation rule set on the consensus layer and must be accompanied by a hard fork.", "Security Considerations": "Because the on-chainAttestationcontainer changes, attestations from the prior fork can\u2019t be included in post-electra blocks. Therefore the first block after the fork may have zero attestations. LMD votes can still be applied to fork-choice viaon_attestationhandler, so there will be only a 1/32 loss of FFG votes. Attesters assigned to the last slot of the fork will incur one epoch worth of offline penalties. One possible mitigation is to change the Electra block body type to allow including attestations from both forks. However, the mitigation increases complexity for little gain so this proposal chooses to not address the issue.", "First block after the fork": "Because the on-chainAttestationcontainer changes, attestations from the prior fork can\u2019t be included in post-electra blocks. Therefore the first block after the fork may have zero attestations. LMD votes can still be applied to fork-choice viaon_attestationhandler, so there will be only a 1/32 loss of FFG votes. Attesters assigned to the last slot of the fork will incur one epoch worth of offline penalties. One possible mitigation is to change the Electra block body type to allow including attestations from both forks. However, the mitigation increases complexity for little gain so this proposal chooses to not address the issue.", "Mutation over gossip": "Moving theindexfield outside of the signed message allows malicious mutation only on the p2p gossip topicbeacon_attestation_${subnet_id}. Everywhere else, theAttestationmessage is wrapped with an outer signature that prevents mutation.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7610, "url": "https://eips.ethereum.org/EIPS/eip-7610", "title": "2024-11-20", "authors": ["Revert creation in case of non-empty storage"], "sections": {"EIP-7610: Revert creation in case of non-empty storage": "This EIP causes contract creation to throw an error when attempted at an address with pre-existing storage.", "Revert contract creation if address already has the non-empty storage": "This EIP causes contract creation to throw an error when attempted at an address with pre-existing storage.", "Abstract": "This EIP causes contract creation to throw an error when attempted at an address with pre-existing storage.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "EIP-684 defines two conditions for contract deployment: the destination address must have zero nonce and zero code length. Unfortunately, this is not sufficient. BeforeEIP-161was applied, the nonce of a newly deployed contract remained set to zero. Therefore, it was entirely possible to create a contract with a zero nonce and zero code length but with non-empty storage, if slots were set in the constructor. There exists 28 such contracts on Ethereum mainnet at this time.", "Backwards Compatibility": "This is an execution layer upgrade, and so it requires a hard fork.", "Test Cases": "There exists quite a number of tests in the ethereum tests repo as well as in the execution spec tests, which test the scenario of deployment to targets with non-empty storage. These tests have been considered problematic in the past; Reth and EELS both intentionally implement a version of the account reset solely to pass the tests. Py-evm declared the situation impossible and never implemented account reset.", "Security Considerations": "This EIP is a security upgrade: it enforces the imutability of deployed code.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7623, "url": "https://eips.ethereum.org/EIPS/eip-7623", "title": "2025-03-01", "authors": ["Increase calldata cost"], "sections": {"EIP-7623: Increase calldata cost": "The current calldata pricing permits EL payloads of up to 7.15 MB, while the average size is much smaller at around 100 KB.\nThis EIP proposes adjusting the calldata cost to reduce the maximum possible block size and its variance without negatively impacting regular users.\nThis is achieved by increasing calldata costs for transactions that predominantly post data.", "Increase calldata cost to reduce maximum block size": "The current calldata pricing permits EL payloads of up to 7.15 MB, while the average size is much smaller at around 100 KB.\nThis EIP proposes adjusting the calldata cost to reduce the maximum possible block size and its variance without negatively impacting regular users.\nThis is achieved by increasing calldata costs for transactions that predominantly post data.", "Abstract": "The current calldata pricing permits EL payloads of up to 7.15 MB, while the average size is much smaller at around 100 KB.\nThis EIP proposes adjusting the calldata cost to reduce the maximum possible block size and its variance without negatively impacting regular users.\nThis is achieved by increasing calldata costs for transactions that predominantly post data.", "Motivation": "The block gas limit has not been increased sinceEIP-1559, while the average size of blocks has continuously increased due to the growing number of rollups posting data to Ethereum. Moreover, calldata costs have remained unchanged sinceEIP-2028.EIP-4844introduces blobs as a preferred method for data availability (DA).\nThis transition demands a reevaluation of calldata pricing, especially in order to address the disparity between average and maximum block sizes.\nBy introducing a floor cost dependent on the ratio of gas spent on EVM operations to calldata, this proposal aims to reduce the maximum block size to make room for additional blobs or potential block gas limit increases.", "Specification": "Lettokens_in_calldata = zero_bytes_in_calldata + nonzero_bytes_in_calldata * 4.", "Rationale": "The current maximum EL payload size is approximately 1.79 MB (30_000_000/16). It is possible to create payloads filled with zero bytes that expand to 7.15 MB. However, since blocks are typically compressed with Snappy at the P2P layer, zero-byte-heavy EL payloads generally compress to under 1.79 MB. The implementation ofEIP-4844increased the maximum possible compressed block size to approximately 2.54 MB.", "Backwards Compatibility": "This is a backwards incompatible gas repricing that requires a scheduled network upgrade.", "Security Considerations": "As the maximum possible block size is reduced, no security concerns have been raised.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7685, "url": "https://eips.ethereum.org/EIPS/eip-7685", "title": "2025-02-21", "authors": ["General purpose execution layer requests"], "sections": {"EIP-7685: General purpose execution layer requests": "This proposal defines a general purpose framework for storing contract-triggered\nrequests. It extends the execution header with a single field to store the\nrequest information. Requests are later on exposed to the consensus layer, which\nthen processes each one.", "A general purpose bus for sharing EL triggered requests with the CL": "This proposal defines a general purpose framework for storing contract-triggered\nrequests. It extends the execution header with a single field to store the\nrequest information. Requests are later on exposed to the consensus layer, which\nthen processes each one.", "Abstract": "This proposal defines a general purpose framework for storing contract-triggered\nrequests. It extends the execution header with a single field to store the\nrequest information. Requests are later on exposed to the consensus layer, which\nthen processes each one.", "Motivation": "The proliferation of smart contract controlled validators has caused there to be\na demand for additional EL triggered behaviors. By allowing these systems to\ndelegate administrative operations to their governing smart contracts, they can\navoid intermediaries needing to step in and ensure certain operations occur.\nThis creates a safer system for end users. By abstracting each individual request\ndetails from the EL, adding new request types is simpler and does not require an\nupdate on the execution block structure.", "Specification": "Arequestsobject consists of arequest_typebyte prepended to an opaque byte arrayrequest_data. Therequest_datacontains zero or more encoded request objects.", "Execution Layer": "Arequestsobject consists of arequest_typebyte prepended to an opaque byte arrayrequest_data. Therequest_datacontains zero or more encoded request objects.", "Consensus Layer": "Each proposal may choose how to extend the beacon chain types to include new EL request\ntypes.", "Rationale": "By having the bytes ofrequest_dataarray from second byte on be opaque bytes, rather\nthan an RLP (or other encoding) list, we can support different encoding formats for the\nrequest payload in the future such as SSZ, LEB128, or a fixed width format.", "Opaque byte array rather than an RLP array": "By having the bytes ofrequest_dataarray from second byte on be opaque bytes, rather\nthan an RLP (or other encoding) list, we can support different encoding formats for the\nrequest payload in the future such as SSZ, LEB128, or a fixed width format.", "Request source and validity": "This EIP makes no strict requirement where a request may come from nor when/how\na request must be validated. This is to provide future protocol designers\nmaximum flexibility.", "Ordering": "The ordering across types is ascending by type. This is to simplify the process\nof verifying that all requests which were committed to inrequests_hashmatch.", "Removing empty requests in commitment": "We exclude empty requests elements from therequests_hashcommitment in order to get a\nstable \u2018empty\u2019 hash value that is independent of the blockchain fork. For a block with no\nrequests data, therequests_hashis simplysha256(\"\").", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "TODO", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7691, "url": "https://eips.ethereum.org/EIPS/eip-7691", "title": "2025-04-01", "authors": ["Blob throughput increase"], "sections": {"EIP-7691: Blob throughput increase": "Increases the number of blobs in a block to provide more scale to Ethereum via L2 solution that rely on L1 data capacity.", "Increase the number of blobs to reach a new target and max of 6 and 9 blobs per block respectively": "Increases the number of blobs in a block to provide more scale to Ethereum via L2 solution that rely on L1 data capacity.", "Abstract": "Increases the number of blobs in a block to provide more scale to Ethereum via L2 solution that rely on L1 data capacity.", "Motivation": "Ethereum, with its rollup centric roadmap, scales by relying on L2. Since the Dencun fork, the blob gas target and maximum was set to 3/6 respectively. The blob gas limit was arrived at based on a series of big block tests performed on the Ethereum mainnet network as well as a series of testnets. The values were chosen cautiously, as it\u2019s extremely hard to predict the exact p2p behaviour of Ethereum mainnet.", "Specification": "MAX_BLOBS_PER_BLOCK_ELECTRAandTARGET_BLOBS_PER_BLOCK_ELECTRAare consumed by the consensus layer clients, and starting atPECTRA_FORK_EPOCHreplace the respective old max and target values.", "Parameters": "MAX_BLOBS_PER_BLOCK_ELECTRAandTARGET_BLOBS_PER_BLOCK_ELECTRAare consumed by the consensus layer clients, and starting atPECTRA_FORK_EPOCHreplace the respective old max and target values.", "Rationale": "The EIP aims to minimize the amount of testing and implementation effort from the perspective of the client teams, to allow for more resources to be allocated to peerDAS and other scaling research.", "Simplicity": "The EIP aims to minimize the amount of testing and implementation effort from the perspective of the client teams, to allow for more resources to be allocated to peerDAS and other scaling research.", "Update Fraction": "The original target and max values fromEIP-4844were at a 1:2 ratio. As a consequence, responsiveness to full and empty blob sections was symmetrical:", "Backwards Compatibility": "The consensus clients would continue to useMAX_BLOBS_PER_BLOCKandTARGET_BLOBS_PER_BLOCKfor the deneb fork and once theELECTRAfork is active, they would useMAX_BLOBS_PER_BLOCK_ELECTRAandTARGET_BLOBS_PER_BLOCK_ELECTRArespectively.", "Security Considerations": "Through the use of big block/blob tests on Ethereum mainnet as well as testnets, we can earn a high degree of certainty that the blob limit increase would not negatively impact the network. These tests as well as the associated analysis can be performed mostly by non-client team entities, with minimal input required. Since the changes are quite contained, the EIP should be able to reduce the risk of the blob limit increase.", "Network Impacts": "Through the use of big block/blob tests on Ethereum mainnet as well as testnets, we can earn a high degree of certainty that the blob limit increase would not negatively impact the network. These tests as well as the associated analysis can be performed mostly by non-client team entities, with minimal input required. Since the changes are quite contained, the EIP should be able to reduce the risk of the blob limit increase.", "Stability Around Fork Epoch": "A blob limit increase at the fork transition is relatively straightforward from an implementation perspective. We would need to deploy an increased amount of monitoring around the fork epoch, but after a period of stability we can assume that the blob limit increase was successful, reducing any unexpected co-ordination efforts.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- blob limit: The total number of blocks that can be stored as blobs before the network is full.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7702, "url": "https://eips.ethereum.org/EIPS/eip-7702", "title": "2025-04-01", "authors": ["Set EOA account code"], "sections": {"EIP-7702: Set EOA account code": "Add a new transaction type that adds a list of[chain_id, address, nonce,\ny_parity, r, s]authorization tuples. For each tuple, write a delegation\ndesignator(0xef0100 || address)to the signing account\u2019s code. All code\nexecuting operations must load the code pointed to by the designator.", "Add a new tx type that permanently sets the code for an EOA": "Add a new transaction type that adds a list of[chain_id, address, nonce,\ny_parity, r, s]authorization tuples. For each tuple, write a delegation\ndesignator(0xef0100 || address)to the signing account\u2019s code. All code\nexecuting operations must load the code pointed to by the designator.", "Abstract": "Add a new transaction type that adds a list of[chain_id, address, nonce,\ny_parity, r, s]authorization tuples. For each tuple, write a delegation\ndesignator(0xef0100 || address)to the signing account\u2019s code. All code\nexecuting operations must load the code pointed to by the designator.", "Motivation": "There is a lot of interest in adding short-term functionality improvements to\nEOAs, increasing the usability of applications and in some cases allowing\nimproved security. Three particular applications include:", "Specification": "We introduce a newEIP-2718transaction, \u201cset code\ntransaction\u201d, where theTransactionTypeisSET_CODE_TX_TYPEand theTransactionPayloadis the RLP serialization of the following:", "Parameters": "We introduce a newEIP-2718transaction, \u201cset code\ntransaction\u201d, where theTransactionTypeisSET_CODE_TX_TYPEand theTransactionPayloadis the RLP serialization of the following:", "Set Code Transaction": "We introduce a newEIP-2718transaction, \u201cset code\ntransaction\u201d, where theTransactionTypeisSET_CODE_TX_TYPEand theTransactionPayloadis the RLP serialization of the following:", "Rationale": "ThePER_AUTH_BASE_COSTis the cost to process the authorization tuple and set\nthe delegation destination. We are able to compute a fair cost for this\noperation by reviewing its impact on the system:", "Cost of Delegation": "ThePER_AUTH_BASE_COSTis the cost to process the authorization tuple and set\nthe delegation destination. We are able to compute a fair cost for this\noperation by reviewing its impact on the system:", "No initcode": "Running initcode is not desirable for many reasons. The chief concern is it\u2019s\nunnatural. Initcode is intended to initialize and deploy contracts. With this\nEIP, it will take on a new role of determining whether it is appropriate to\ndeploy code to the EOA. Suppose a user only wants code deployed to their account\nif they also have an operation bundled with the general transaction calldata.\nThis gives EOAs a unique power to control when and what code executes in their\naccount. AlthoughEIP-7702as written still allows this to a\ndegree, the lack of programmability in the decision will force wallets to not\nsign many authorization tuples and instead focus on signing only a tuple\npointing to a configurable proxy. This affords EOAs a similar experience to\nsmart contract wallets.", "Creation by template": "Initcode or not, there is a question of how users should specify the code they\nintend to run in their account. The two main options are to specify the bytecode\ndirectly in the transaction or to specify a pointer to the code. The simplest\npointer would just be the address of some code deployed on-chain.", "Lack of instruction prohibition": "Consistency is a valuable property in the EVM, both from an implementation\nperspective and a user understanding perspective. Despite considering bans on\nseveral families of instructions in the context of EOAs, the authors feel there\nis not a compelling reason to do so. It will force smart contract wallets and\nEOA smart contract wallets to proceed down distinct paths of contract\ndevelopment.", "Signature structure": "The signature scheme in this EIP supports flexible design patterns, allowing for\nboth full delegation toaddressand more protected delegations toaddress.", "Self-sponsoring: allowingtx.originto set code": "Allowingtx.originto set code enables simple transaction batching, where the\nsender of the outer transaction would be the signing account. The ERC-20\napprove-then-transfer pattern, which currently requires two separate\ntransactions, could be completed in a single transaction with this proposal.", "Forward-compatibility with future account abstraction": "This EIP is designed to be very forward-compatible with endgame account\nabstraction, without over-enshrining any fine-grained details ofERC-4337or RIP-7560.", "Clearing Delegation Designations": "A general design goal of state transition changes is to minimize the number of\nspecial cases an EIP has. In early iterations, this EIP resisted a special case\nfor clearing an account\u2019s delegation designation.", "Delegation of code execution only": "Other code retrieving operations likeEXTCODEHASHdo not automatically follow\ndelegations, they operate on the delegation designator itself. If instead\ndelegations were followed, an account would be able to temporarily masquerade as\nhaving a particular codehash, which would break contracts that rely on\ncodehashes as an indicator of possible account behavior. A change of behavior in\na contract is currently only possible if its code explicitly allows it (in\nparticular viaDELEGATECALL), and a change of codehash is only possible in the\npresence ofSELFDESTRUCT(and as of Cancun only in the same transaction as\ncontract creation), so choosing to follow delegations inEXTCODE*opcodes\nwould have created a new type of account that broke prior assumptions.", "Charge maximum cost upfront": "While computing the intrinsic gas cost, the transaction is charged the\nworst-case cost for each delegation. Later, while processing the authorization\nlist, a refund is issued if the account already exists in state. This mechanism\nis designed to avoid state lookups for each authorization when computing the\nintrinsic gas and can quickly determine the validity of the transaction with\nonly a state lookup on the sender\u2019s account.", "Backwards Compatibility": "This EIP breaks the invariant that an account balance can only decrease as a\nresult of transactions originating from that account. It also breaks the\ninvariant that an EOA nonce may not increase after transaction execution has\nbegun. These breakages have consequences for mempool design, and for other EIPs\nsuch as inclusion lists. However, because the accounts are listed statically in\nthe outer transaction, it is possible to modify transaction propagation rules so\nthat conflicting transactions are not forwarded.", "Security Considerations": "The following is a non-exhaustive list of checks/pitfalls/conditions that\ndelegate contractsshouldbe wary of and require a signature over from the\naccount\u2019s authority:", "Secure delegation": "The following is a non-exhaustive list of checks/pitfalls/conditions that\ndelegate contractsshouldbe wary of and require a signature over from the\naccount\u2019s authority:", "Setting code astx.origin": "Allowing the sender of an EIP-7702 to also set code has the possibility to:", "Sponsored transaction relayers": "It is possible for theauthorizedaccount to cause sponsored transaction\nrelayers to spend gas without being reimbursed by either invalidating the\nauthorization (i.e., increasing the account\u2019s nonce) or by sweeping the relevant\nassets out of the account. Relayers should be designed with these cases in mind,\npossibly by requiring a bond to be deposited or by implementing a reputation\nsystem.", "Front running initialization": "Smart contract wallet developers must consider the implications of setting code\nin an account without execution. Contracts are normally deployed by executing\ninitcode to determine the exact code to be placed in the account. This gives\ndevelopers the opportunity to initialize storage slots at the same time. The\ninitial values of the account cannot be replaced by an observer, because they\nare either signed over by an EOA in the case of a creation transaction or they\nare committed to by computing the contract\u2019s address deterministically from the\nhash of the initcode.", "Transaction propagation": "Allowing EOAs to behave as smart contracts via the delegation designation poses\nsome challenges for transaction propagation. Traditionally, EOAs have only be\nable to send value via a transaction. This invariant allows nodes to statically\ndetermine the validity of transactions for that account. In other words, a\nsingle transaction has only been able to invalidate transactions pending from\nthe senders account.", "Storage management": "Changing an account\u2019s delegation is a security-critical operation that should\nnot be done lightly, especially if the newly delegated code is not purposely\ndesigned and tested as an upgrade to the old one.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- inclusion lists: Introduces a mechanism allowing proposers to specify transactions that must be included in subsequent blocks, improving censorship resistance."}
{"eip": 663, "url": "https://eips.ethereum.org/EIPS/eip-663", "title": "SWAPN, DUPN and EXCHANGE instructions", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Charles Cooper\u00a0(", "@charles-cooper", ")", "Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-663: SWAPN, DUPN and EXCHANGE instructions": "Currently,SWAP*andDUP*instructions are limited to a stack depth of 16. Introduce three new instructions,SWAPN,DUPNandEXCHANGEwhich lift this limitation and allow accessing the stack at higher depths.", "Introduce additional instructions for manipulating the stack which allow accessing the stack at higher depths": "Currently,SWAP*andDUP*instructions are limited to a stack depth of 16. Introduce three new instructions,SWAPN,DUPNandEXCHANGEwhich lift this limitation and allow accessing the stack at higher depths.", "Abstract": "Currently,SWAP*andDUP*instructions are limited to a stack depth of 16. Introduce three new instructions,SWAPN,DUPNandEXCHANGEwhich lift this limitation and allow accessing the stack at higher depths.", "Motivation": "While the stack is 1024 items deep, easy access is only possible for the top 16 items. Supporting more local variables is possible via manually keeping them in memory or through a \u201cstack to memory elevation\u201d in a compiler. This can result in complex and inefficient code.", "Specification": "We introduce three new instructions:", "Rationale": "Allowing dynamic selection of the arguments to swap, dup, or exchange could be used to prevent static analysis of the contents of the stack. Since static analysis is an important tool for security auditors we want to do what we can to make their jobs easier. Hence, the operands require an immediate argument that is not dynamic in nature.", "Use of an immediate argument": "Allowing dynamic selection of the arguments to swap, dup, or exchange could be used to prevent static analysis of the contents of the stack. Since static analysis is an important tool for security auditors we want to do what we can to make their jobs easier. Hence, the operands require an immediate argument that is not dynamic in nature.", "EOF-only": "Since this instruction depends on an immediate argument encoding, it can only be enabled within EOF. In legacy bytecode that encoding could contradict jumpdest-analysis.", "Size of immediate argument": "ForDUPNandSWAPNa 16-bit size was considered to accommodate the full stack space of 1024 items, however:", "Gas cost": "The gas cost for these operations is the same as for existingDUP*andSWAP*instructions, because they are just implemented as pointer swaps.", "EXCHANGEvsSWAPN": "As mentioned before,EXCHANGEis important to compilers implementing stack scheduling algorithms. Specifically, in the case that a stack item is scheduled to be consumed deeper in the stack (for instance, the 3rd item in the stack needs to be moved into 2nd position in order to be consumed by the next operation), that currently takes three instructions,SWAP2 SWAP3 SWAP2. However, in the EVM implementation, the implementation is just a pointer swap, so it could be implemented in a single instruction at no extra runtime cost to the client.", "Backwards Compatibility": "This has no effect on backwards compatibility because the opcodes were not previously allocated and the feature is only enabled in EOF.", "Test Cases": "Givenstack[]is a 0-based data structure, andn,mandimmare defined as according to the spec:", "Security Considerations": "The authors are not aware of any additional risks introduced here. The EVM stack is fixed at 1024 items and most implementations keep that in memory at all times. This change will increase the number of stack items accessible via single instruction.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3540, "url": "https://eips.ethereum.org/EIPS/eip-3540", "title": "EOF - EVM Object Format v1", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")", "Matt Garnett\u00a0(", "@lightclient", ")", "Piotr Dobaczewski\u00a0(", "@pdobacz", ")"], "sections": {"EIP-3540: EOF - EVM Object Format v1": "We introduce an extensible and versioned container format for the EVM with a once-off validation at deploy time. The version described here brings the tangible benefit of code and data separation, and allows for easy introduction of a variety of changes in the future. This change relies on the reserved byte introduced byEIP-3541.", "EOF is an extensible and versioned container format for EVM bytecode with a once-off validation at deploy time.": "We introduce an extensible and versioned container format for the EVM with a once-off validation at deploy time. The version described here brings the tangible benefit of code and data separation, and allows for easy introduction of a variety of changes in the future. This change relies on the reserved byte introduced byEIP-3541.", "Abstract": "We introduce an extensible and versioned container format for the EVM with a once-off validation at deploy time. The version described here brings the tangible benefit of code and data separation, and allows for easy introduction of a variety of changes in the future. This change relies on the reserved byte introduced byEIP-3541.", "Motivation": "On-chain deployed EVM bytecode contains no pre-defined structure today. Code is typically validated in clients to the extent ofJUMPDESTanalysis at runtime, every single time prior to execution. This poses not only an overhead, but also a challenge for introducing new or deprecating existing features.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Remarks": "If code starts with theMAGIC, it is considered to be EOF formatted, otherwise it is considered to belegacycode. For clarity, theMAGICtogether with a version numbernis denoted as theEOFn prefix, e.g.EOF1 prefix.", "Code validation": "We introducecode validationfor new contract creation. To achieve this, we define a format called EVM Object Format (EOF), containing a version indicator, and a ruleset of validity tied to a given version.", "Container specification": "EOF container is a binary format with the capability of providing the EOF version number and a list of EOF sections.", "EOF version 1": "EOF version 1 is made up of several EIPs, including this one. Some values in this specification are only discussed briefly. To understand the full scope of EOF, it is necessary to review each EIP in-depth.", "Changes to execution semantics": "For an EOF contract:", "Rationale": "EVM and/or account versioning has been discussed numerous times over the past years. This proposal aims to learn from them.\nSee \u201cEthereum account versioning\u201d on the Fellowship of Ethereum Magicians Forum for a good starting point.", "Execution vs. creation time validation": "This specification introduces creation time validation, which means:", "The MAGIC": "NOTE: This EIP MUST NOT be enabled on chains which contain bytecodes starting withMAGICand not being valid EOF.", "EOF version range start with 1": "The version number 0 will never be used in EOF, so we can call legacy codeEOF0.\nAlso, implementations may use APIs where 0 version number denotes legacy code.", "Section structure": "We have considered different questions for the sections:", "Data-only contracts": "See sectionLack ofEXTDATACOPYin EIP-7480.", "EOF1 contracts can onlyDELEGATECALLEOF1 contracts": "Currently contracts can selfdestruct in three different ways (directly throughSELFDESTRUCT, indirectly throughCALLCODEand indirectly throughDELEGATECALL).EIP-3670disables the first two possibilities, however the third possibility remains. Allowing EOF1 contracts to onlyDELEGATECALLother EOF1 contracts allows the following strong statement: EOF1 contract can never be destructed. Attacks based onSELFDESTRUCTcompletely disappear for EOF1 contracts. These include destructed library contracts (e.g. Parity Multisig).", "EOF1 containers have a size limit": "Imposing an EOF-validation time limit for the size of EOF containers provides a reference limit of how large the containers should EVM implementations be able to handle when validating and processing containers.MAX_INITCODE_SIZEwas chosen for EOF1, as it is what contract creation currently allows for.", "kind_datacould be0x04not0xff": "Putting the data section last as0xffhas the advantage of aligning with the fact that it always comes last. We\u2019re avoiding a situation that a new section kind would need to go before the data section and break the section kind ordering. At the same time, data section being last is advantageous because it is the section which gets data appended to during contract deployment.", "Backwards Compatibility": "This is a breaking change given that any code starting with0xEFwas not deployable before (and resulted in exceptional abort if executed), but now some subset of such codes can be deployed and executed successfully.", "Security Considerations": "With the anticipated EOF extensions, the validation is expected to have linear computational and space complexity.\nWe think that the validation cost is sufficiently covered by:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- magic: A constant value set as 0xef0100 used in the CREATE_DELEGATE instruction."}
{"eip": 3670, "url": "https://eips.ethereum.org/EIPS/eip-3670", "title": "EOF - Code Validation", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")"], "sections": {"EIP-3670: EOF - Code Validation": "Introduce code validation at contract creation time for EOF formatted (EIP-3540)\ncontracts. Reject contracts which contain truncatedPUSH-data or undefined instructions.\nLegacy bytecode (code which is not EOF formatted) is unaffected by this change.", "Validate EOF bytecode for correctness at the time of deployment.": "Introduce code validation at contract creation time for EOF formatted (EIP-3540)\ncontracts. Reject contracts which contain truncatedPUSH-data or undefined instructions.\nLegacy bytecode (code which is not EOF formatted) is unaffected by this change.", "Abstract": "Introduce code validation at contract creation time for EOF formatted (EIP-3540)\ncontracts. Reject contracts which contain truncatedPUSH-data or undefined instructions.\nLegacy bytecode (code which is not EOF formatted) is unaffected by this change.", "Motivation": "Currently existing contracts require no validation of correctness and EVM implementations can decide\nhow they handle truncated bytecode or undefined instructions. This change aims to bring code\nvalidity into consensus, so that it becomes easier to reason about bytecode.\nMoreover, EVM implementations may require fewer paths to decide which instruction is valid in\nthe current execution context.", "EOF1 forward compatibility": "The EOF1 format provides following forward compatibility properties:", "Specification": "This feature is introduced on the same block EIP-3540 is enabled, therefore every EOF1-compatible bytecode MUST be validated according to these rules.", "Rationale": "Allowing implicit zero immediate data forPUSHinstructions introduces inefficiencies to EVM implementations without any practical use-case (the value of aPUSHinstruction at the code end cannot be observed by EVM). This EIP requires all immediate bytes to be explicitly present in the code.", "Immediate data": "Allowing implicit zero immediate data forPUSHinstructions introduces inefficiencies to EVM implementations without any practical use-case (the value of aPUSHinstruction at the code end cannot be observed by EVM). This EIP requires all immediate bytes to be explicitly present in the code.", "Rejection of deprecated instructions": "The deprecated instructionsCALLCODE(0xf2) andSELFDESTRUCT(0xff) are removed from thevalid_opcodeslist to prevent their use in the future.", "BLOCKHASH instruction": "TheBLOCKHASHinstruction is well replaced by the system contract introduced inEIP-2935.\nHowever, despite a replacement being introduced this opcode has not been deprecated.\nThis opcode will remain valid in EOF not to differentiate from legacy bytecode.", "Backwards Compatibility": "This change poses no risk to backwards compatibility, as it is introduced at the same time EIP-3540 is. The validation does not cover legacy bytecode (code which is not EOF formatted).", "Test Cases": "Each case should be tested by submitting an EOF container to EOF contract creation (as specced out in a separate EIP). Each case should be tested with code placed in code sections at different indices.", "Contract creation": "Each case should be tested by submitting an EOF container to EOF contract creation (as specced out in a separate EIP). Each case should be tested with code placed in code sections at different indices.", "Valid codes": "SeeSecurity Considerations of EIP-3540.", "Invalid codes": "SeeSecurity Considerations of EIP-3540.", "Reference Implementation": "SeeSecurity Considerations of EIP-3540.", "Security Considerations": "SeeSecurity Considerations of EIP-3540.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- eof - code validation: Adds validation for EOF contracts at deployment time, ensuring correctness by rejecting bytecode with undefined instructions or truncated PUSH data.\n- eof contract creation: Introduces EOFCREATE and RETURNCONTRACT instructions to handle contract creation in the EOF format, replacing legacy CREATE and CREATE2."}
{"eip": 4200, "url": "https://eips.ethereum.org/EIPS/eip-4200", "title": "EOF - Static relative jumps", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")"], "sections": {"EIP-4200: EOF - Static relative jumps": "Three new EVM jump instructions are introduced (RJUMP,RJUMPIandRJUMPV) which encode destinations as signed immediate values. These can be useful in the majority of (but not all) use cases and offer a cost reduction.", "RJUMP, RJUMPI and RJUMPV instructions with a signed immediate encoding the jump destination": "Three new EVM jump instructions are introduced (RJUMP,RJUMPIandRJUMPV) which encode destinations as signed immediate values. These can be useful in the majority of (but not all) use cases and offer a cost reduction.", "Abstract": "Three new EVM jump instructions are introduced (RJUMP,RJUMPIandRJUMPV) which encode destinations as signed immediate values. These can be useful in the majority of (but not all) use cases and offer a cost reduction.", "Motivation": "A recurring discussion topic is that EVM only has a mechanism for dynamic jumps. They provide a very flexible architecture with only 2 (!) instructions. This flexibility comes at a cost however: it makes analysis of code more complicated and it also (partially) resulted in the need to have theJUMPDESTmarker.", "Specification": "We introduce three new instructions on the same block numberEIP-3540is activated on:", "Rationale": "We chose relative addressing in order to support code which is relocatable. This also means a code snippet can be injected. A technique seen used prior to this EIP to achieve the same goal was to inject code likePUSHn PC ADD JUMPI.", "Relative addressing": "We chose relative addressing in order to support code which is relocatable. This also means a code snippet can be injected. A technique seen used prior to this EIP to achieve the same goal was to inject code likePUSHn PC ADD JUMPI.", "Immediate size": "The signed 16-bit immediate means that the largest jump distance possible is 32767. In the case the bytecode atPC=0starts with anRJUMP, it will be possible to jump as far asPC=32770.", "PUSHn JUMPsequences": "If we chose absolute addressing, thenRJUMPcould be viewed similar to the sequencePUSHn JUMP(andRJUMPIsimilar toPUSHn JUMPI). In that case one could argue that instead of introducing a new instruction, such sequences should get a discount, because EVMs could optimise them.", "Relation to dynamic jumps": "The goal was not to completely replace the current control flow system of the EVM, but to augment it. There are many cases where dynamic jumps are useful, such as returning to the caller.", "Lack ofJUMPDEST": "JUMPDESTserves two purposes:", "RJUMPVfallback case": "If no match is found (i.e. thedefaultcase) in theRJUMPVinstruction execution will continue without branching. This allows for gaps in the arguments to be filled with0s, and a choice of implementation by the programmer. Alternate options would include exceptional aborts in case of no match.", "Backwards Compatibility": "This change poses no risk to backwards compatibility, as it is introduced at the same time EIP-3540 is. The new instructions are not introduced for legacy bytecode (code which is not EOF formatted).", "Test Cases": "TBA", "Validation": "TBA", "Execution": "TBA", "Security Considerations": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4750, "url": "https://eips.ethereum.org/EIPS/eip-4750", "title": "EOF - Functions", "authors": ["Andrei Maiboroda\u00a0(", "@gumb0", ")", "Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")"], "sections": {"EIP-4750: EOF - Functions": "Introduce the ability to have several code sections in EOF-formatted (EIP-3540) bytecode, each one representing a separate subroutine/function. Two new opcodes,CALLFandRETF, are introduced to call and return from such a function. Dynamic jump instructions are disallowed.", "Individual sections for functions with `CALLF` and `RETF` instructions": "Introduce the ability to have several code sections in EOF-formatted (EIP-3540) bytecode, each one representing a separate subroutine/function. Two new opcodes,CALLFandRETF, are introduced to call and return from such a function. Dynamic jump instructions are disallowed.", "Abstract": "Introduce the ability to have several code sections in EOF-formatted (EIP-3540) bytecode, each one representing a separate subroutine/function. Two new opcodes,CALLFandRETF, are introduced to call and return from such a function. Dynamic jump instructions are disallowed.", "Motivation": "Currently, in the EVM everything is a dynamic jump. Languages like Solidity generate most jumps in a static manner (i.e. the destination is pushed to the stack right before,PUSHn .. JUMP). Unfortunately however this cannot be used by most EVM interpreters, because of added requirement of validation/analysis. This also restricts them from making optimisations and potentially reducing the cost of jumps.", "Specification": "The type section of EOF containers must adhere to following requirements:", "Type Section": "The type section of EOF containers must adhere to following requirements:", "New execution state in EVM": "A return stack is introduced, separate from the operand stack. It is a stack of items representing execution state to return to after function execution is finished. Each item is comprised of code section index and offset in the code section (PC value).", "New instructions": "We introduce two new instructions:", "Code Validation": "In addition to container format validation rules above, we extend code section validation rules (as defined inEIP-3670).", "Disallowed instructions": "Dynamic jump instructionsJUMP(0x56) andJUMPI(0x57) are invalid and their opcodes are undefined.", "Execution": "Alternative logic forRETFin the top frame could be to allow it during code validation and make it either:", "Rationale": "Alternative logic forRETFin the top frame could be to allow it during code validation and make it either:", "RETFin the top frame ends execution vs exceptionally halts vs is not allowed during validation": "Alternative logic forRETFin the top frame could be to allow it during code validation and make it either:", "\u201cMinimal\u201d function type": "Let\u2019s consider a trivial function with single instructionRETF.\nSuch function have the \u201cminimal\u201d type ofinputs = 0, outputs = 0.\nHowever, any other type likeinputs = k, outputs = kis also valid for such function.\nIt has been considered to enforce usage of the \u201cminimal\u201d type for all functions.\nThis requires additional validation rule that checks if any instruction in the function accesses the bottom stack operand.\nThis rule can be obeyed by compilers, but causes quite significant annoyance.\nOn the other hand, it provides close to zero benefits for the EVM implementations.\nIn the end, it has been decided that this is not enforced.", "Code section limit and instruction size": "The number of code sections is limited to 1024. This requires 2-byte immediate forCALLFand leaves room for increasing the limit in the future. The 256 limit (1-byte immediate) was discussed and concerns were raised that it might not be sufficient.", "NOPinstruction": "Instead of deprecatingJUMPDESTwe repurpose it asNOPinstruction, becauseJUMPDESTeffectively was a \u201cno-operation\u201d instruction and was already used as such in various contexts. It can be useful for some off-chain tooling, e.g. benchmarking EVM implementations (performance ofNOPinstruction is performance of EVM interpreter loop), as a padding to force code alignment, as a placeholder in dynamic code composition.", "DeprecatingJUMPDESTanalysis": "The purpose ofJUMPDESTanalysis was to find in code the validJUMPDESTbytes that do not happen to be insidePUSHimmediate data. Only dynamic jump instructions (JUMP,JUMPI) required destination to beJUMPDESTinstruction. Relative static jumps (RJUMPandRJUMPI) do not have this requirement and are validated once at deploy-time EOF instruction validation. Therefore, without dynamic jump instructions,JUMPDESTanalysis is not required.", "Backwards Compatibility": "This change poses no risk to backwards compatibility, as it is introduced only for EOF1 contracts, for which deploying undefined instructions is not allowed, therefore there are no existing contracts using these instructions. The new instructions are not introduced for legacy bytecode (code which is not EOF formatted).", "Security Considerations": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- eof - functions: Introduces function isolation and CALLF and RETF instructions, allowing separate code sections for each function in EOF contracts and removing the need for dynamic jumps.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4803, "url": "https://eips.ethereum.org/EIPS/eip-4803", "title": "Limit transaction gas to a maximum of 2^63-1", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-4803: Limit transaction gas to a maximum of 2^63-1": "Limit transaction gas to be between0and2^63-1.", "Valid transactions must have a reasonable gas limit": "Limit transaction gas to be between0and2^63-1.", "Abstract": "Limit transaction gas to be between0and2^63-1.", "Motivation": "The gas limit field in the transaction is specified to be an arbitrary long unsigned integer, but various clients put limits on this value. This EIP brings a reasonable limit into consensus.", "Specification": "Introduce one new restriction retroactively from genesis: any transaction is invalid and not includeable in a block, where the gas limit exceeds2^63-1.", "Rationale": "2^63-1is chosen because it allows representing the gas value as a signed integer, and so the out of gas check can be done as a simple \u201cless than zero\u201d check after subtraction.", "2^63-1vs2^64-1": "2^63-1is chosen because it allows representing the gas value as a signed integer, and so the out of gas check can be done as a simple \u201cless than zero\u201d check after subtraction.", "Consider2^31-1": "An alternative is considering a lower limit, because this can be handled easily in Javascript, since it handles numbers as floating point (the actual upper bound is2^53-1).", "Current limit": "Due to the nature of RLP encoding, there is no fixed upper bound for the value, but most implementations limit it to 256-bits. Furthermore, most client implementations (such as geth) internally handle gas as a 64-bit value.", "Backwards Compatibility": "While this is a breaking change, no actual effect should be visible.", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- genesis: Log entry in system_logs for initial balances at network genesis .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5450, "url": "https://eips.ethereum.org/EIPS/eip-5450", "title": "EOF - Stack Validation", "authors": ["Andrei Maiboroda\u00a0(", "@gumb0", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Alex Beregszaszi\u00a0(", "@axic", ")", "Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-5450: EOF - Stack Validation": "Introduce extended validation of EOF code sections to guarantee that neither stack underflow nor overflow can happen during execution of validated contracts.", "Deploy-time validation of stack usage for EOF functions.": "Introduce extended validation of EOF code sections to guarantee that neither stack underflow nor overflow can happen during execution of validated contracts.", "Abstract": "Introduce extended validation of EOF code sections to guarantee that neither stack underflow nor overflow can happen during execution of validated contracts.", "Motivation": "The current EVM performs a number of validity checks for each executed instruction, such as checking\nfor instruction being defined, stack overflow and underflow, and enough amount of gas remaining.", "Specification": "Remark:We rely on the notions ofoperand stackandtype sectionas defined byEIP-4750.", "Code validation": "Remark:We rely on the notions ofoperand stackandtype sectionas defined byEIP-4750.", "Execution": "Given the deploy-time validation guarantees, an EVM implementation is not required anymore to have run-time stack underflow nor overflow checks for each executed instruction. The exception is theCALLFandJUMPFperforming operand stack overflow check for the entire called function.", "Rationale": "Any code section validated according to operand stack validation has the following properties:", "Properties of validated code": "Any code section validated according to operand stack validation has the following properties:", "Stack overflow check only in CALLF/JUMPF": "In this EIP, we provide a more efficient variant of the EVM where stack overflow check is performed only inCALLFandJUMPFinstructions using the called function\u2019smax_stack_heightinformation. This decreases flexibility of an EVM program becausemax_stack_heightcorresponds to the worst-case control-flow path in the function.", "Unreachable code": "The operand stack validation algorithm rejects any code having any unreachable instructions. This check can be performed very cheaply. It prevents deploying degenerated code. Moreover, it enables combining instruction validation and operand stack validation into single pass.", "Clean stack upon termination": "It is currently required that the operand stack is empty (in the current function context) after theRETFinstruction.\nOtherwise, theRETFsemantic would be more complicated. Fornfunction outputs andsthe stack height atRETFthe EVM would have to erases-nnon-top stack items and move thenstack items to the place of erased ones. Cost of such operation may be relatively cheap but is not constant.\nHowever, lifting the requirement and modifying theRETFsemantic as described above is backward\ncompatible and can be easily introduced in the future.", "More restrictive stack validation": "Originally another variant of stack validation was proposed, where instead of linear scan of the code section, all code paths were examined by following the target(s) of every jump instruction in a breadth-first-search manner, tracking stack height for each visited instruction and checking that for every possible code path to a particular instruction its stack height remains constant.", "Ordering of basic blocks": "The prerequisite to stack validation algorithm is ordering of code basic blocks in a way that no block is referenced only by backwards jump.", "Backwards Compatibility": "This change requires a \u201cnetwork upgrade,\u201d since it modifies consensus rules.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- eof - stack validation: Introduces deploy-time validation for EVM Object Format (EOF) functions, ensuring that stack underflows and overflows cannot occur during execution, reducing runtime checks.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5920, "url": "https://eips.ethereum.org/EIPS/eip-5920", "title": "PAY opcode", "authors": ["Gavin John\u00a0(", "@Pandapip1", ")", "Zainan Victor Zhou\u00a0(", "@xinbenlv", ")", "Sam Wilson\u00a0(", "@SamWilsn", ")"], "sections": {"EIP-5920: PAY opcode": "This EIP introduces a new opcode,PAY, taking two stack parameters,addrandval, that transfersvalwei to the addressaddrwithout calling any of its functions.", "Introduces a new opcode, PAY, to send ether to an address without calling any of its functions": "This EIP introduces a new opcode,PAY, taking two stack parameters,addrandval, that transfersvalwei to the addressaddrwithout calling any of its functions.", "Abstract": "This EIP introduces a new opcode,PAY, taking two stack parameters,addrandval, that transfersvalwei to the addressaddrwithout calling any of its functions.", "Motivation": "Currently, to send ether to an address requires you to call into that address, which transfers execution context to that address, which creates several issues:", "Specification": "A new opcode is introduced:PAY(0xfc), which:", "Constants": "A new opcode is introduced:PAY(0xfc), which:", "Behavior": "A new opcode is introduced:PAY(0xfc), which:", "Gas Cost": "The gas cost forPAYis the sum of the following:", "Rationale": "The order of arguments mimics that ofCALL, which popsaddrbeforeval. Beyond consistency, though, this ordering aids validators pattern-matching MEV opportunities, soPAYalways appears immediately afterCOINBASE.", "Argument order": "The order of arguments mimics that ofCALL, which popsaddrbeforeval. Beyond consistency, though, this ordering aids validators pattern-matching MEV opportunities, soPAYalways appears immediately afterCOINBASE.", "Halting for invalid address": "The halting behavior is designed to allow for Address Space Extension.\nIf the high bytes were truncated, as inCALL, contracts could depend on the truncating behavior.\nIf the address space were extended beyond 20 bytes,PAYwould either not be able to target those accounts, or code expecting truncation could send ether to the wrong address.", "Backwards Compatibility": "This change requires a hard fork.", "Security Considerations": "Existing contracts should not rely on their balance being under their control, since it is already possible to send ether to an address without calling it, by creating a temporary contract and immediatelySELFDESTRUCTing it, sending the ether to an arbitrary address.\nIt is also possible to involuntarily fund an account using priority fees.\nHowever, this opcode does make this process cheaper and easier for already-vulnerable contracts.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- pay opcode: Adds the PAY opcode to transfer ether to an address without executing any code on the recipient\u2019s side, preventing reentrancy attacks and reducing gas costs for simple ether transfers.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6206, "url": "https://eips.ethereum.org/EIPS/eip-6206", "title": "EOF - JUMPF and non-returning functions", "authors": ["Andrei Maiboroda\u00a0(", "@gumb0", ")", "Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Matt Garnett\u00a0(", "@lightclient", ")"], "sections": {"EIP-6206: EOF - JUMPF and non-returning functions": "This EIP allows for tail call optimizations in EOF functions (EIP-4750) by introducing a new instructionJUMPF, which jumps to a code section without adding a new return stack frame.", "Introduces instruction for chaining function calls.": "This EIP allows for tail call optimizations in EOF functions (EIP-4750) by introducing a new instructionJUMPF, which jumps to a code section without adding a new return stack frame.", "Abstract": "This EIP allows for tail call optimizations in EOF functions (EIP-4750) by introducing a new instructionJUMPF, which jumps to a code section without adding a new return stack frame.", "Motivation": "It is common for functions to make a call at the end of the routine only to then return.JUMPFoptimizes this behavior by changing code sections without needing to update the return stack.", "Specification": "We define a non-returning section as one that cannot return control to its caller section.", "Type section changes": "We define a non-returning section as one that cannot return control to its caller section.", "Execution Semantics": "A new instruction,JUMPF (0xe5), is introduced.", "Code Validation": "Let the definition oftype[i]be inherited fromEIP-4750and definestack_height_minandstack_height_maxto be the stack height bounds at a certain instruction during the instruction flow traversal.", "Rationale": "An alternative rule forJUMPFstack validation could require the target section\u2019s outputs to be exactly equal to the current section\u2019s outputs. Under such rule, a particular target section (a shared \u201chelper\u201d piece of code) would only \u201cmatch\u201d sections (requiring some shared \u201chelper\u201d code to execute before returning)with the same number of outputs.", "AllowingJUMPFto section with less outputs": "An alternative rule forJUMPFstack validation could require the target section\u2019s outputs to be exactly equal to the current section\u2019s outputs. Under such rule, a particular target section (a shared \u201chelper\u201d piece of code) would only \u201cmatch\u201d sections (requiring some shared \u201chelper\u201d code to execute before returning)with the same number of outputs.", "Backwards Compatibility": "This change is backward compatible as EOF does not allow undefined instructions to be used or deployed, meaning no contracts will be affected.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7069, "url": "https://eips.ethereum.org/EIPS/eip-7069", "title": "Revamped CALL instructions", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Danno Ferrin\u00a0(", "@shemnon", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")", "Charles Cooper\u00a0(", "@charles-cooper", ")"], "sections": {"EIP-7069: Revamped CALL instructions": "Introduce three new call instructions,EXTCALL,EXTDELEGATECALLandEXTSTATICCALL, with simplified semantics. Introduce another instruction,RETURNDATALOADfor loading a word from return data into stack. Modify the behavior ofRETURNDATACOPYinstruction executed within EOF formatted code (as defined byEIP-3540). The existing*CALLinstructions remain unchanged.", "Introduce EXTCALL, EXTDELEGATECALL and EXTSTATICCALL with simplified semantics": "Introduce three new call instructions,EXTCALL,EXTDELEGATECALLandEXTSTATICCALL, with simplified semantics. Introduce another instruction,RETURNDATALOADfor loading a word from return data into stack. Modify the behavior ofRETURNDATACOPYinstruction executed within EOF formatted code (as defined byEIP-3540). The existing*CALLinstructions remain unchanged.", "Abstract": "Introduce three new call instructions,EXTCALL,EXTDELEGATECALLandEXTSTATICCALL, with simplified semantics. Introduce another instruction,RETURNDATALOADfor loading a word from return data into stack. Modify the behavior ofRETURNDATACOPYinstruction executed within EOF formatted code (as defined byEIP-3540). The existing*CALLinstructions remain unchanged.", "Motivation": "Observability of gas has been a problem for very long. The system of gas has been (and likely must be) flexible in adapting to changes to both how Ethereum is used as well as changes in underlying hardware.", "Specification": "We introduce four new instructions:", "Rationale": "One major change from the originalCALLseries of instructions is that the caller has no control over the amount of gas passed in as part of the call. The number of cases where such a feature is essential are probably better served by direct protocol integration.", "Removing gas selectability": "One major change from the originalCALLseries of instructions is that the caller has no control over the amount of gas passed in as part of the call. The number of cases where such a feature is essential are probably better served by direct protocol integration.", "Stipend and 63/64th rule": "The purpose of the stipend is to have enough gas to emit logs (i.e. perform non-state-changing operations) when a \u201ccontract wallet\u201d is called. The stipend is only added when theCALLinstruction is used and the value is non-zero.", "Output buffers": "The functionality of specifying output buffer address is removed, because it is added complexity and in a large number of cases implementers prefer to useRETURNDATACOPYinstead. Even if they rely on the output buffer (like in the case of Vyper), they would still check the length withRETURNDATASIZE. In Solidity one exception is the case when the expected return size is known (i.e. non-dynamic return values), in this case Solidity still uses the output buffer. For these cases,RETURNDATALOADis introduced, which simplifies the workflow of copying returndata into a (known) output buffer and usingMLOADfrom there; instead,RETURNDATALOADcan be used directly.", "Status codes": "Current call instructions return a boolean value to signal success: 0 means failure, 1 means success. The Solidity compiler assumed this value is a boolean and thus uses the value as branch condition to status (if iszero(status) { /* failure */ }). This prevents us from introducing new status codes without breaking existing contracts. At the time of the design ofEIP-211the idea of return a specific code for revert was discussed, but ultimately abandoned for the above reason.", "Parameter order": "The order of parameters has been changed to move thevaluefield to be the last. This allows the instructions to have identical encoding with the exception of the last parameter, and simplifies EVM and compiler implementations slightly.", "Opcode encoding": "Instead of introducing three newEXT*CALLopcodes we have discussed a version with an immediate configuration byte (flags). There are two main disadvantages to this:", "CALLCODE": "SinceCALLCODEis deprecated, we do not introduce a counterpart here.", "Halting whentarget_addressis not a 20-byte ethereum addresses": "When existingCALLseries operations encounter an address that does not fit into 20 bytes the current behavior is to mask the address so that it fits into 20 bytes, ignoring all high bytes. For theEXT*CALLoperations a halt was chosen over treating the contract as empty for two reasons. First, it handles the case of sending value to an address that doesn\u2019t exist without having to create a special case. Second, it keeps thewarm_access_listfrom needing to track anything that is not a 20-byte ethereum address.", "New instructions undefined in legacy (only if this EIP is part of EOF)": "There is an alternative scenario where, in case this EIP is included as part of the greater EOF upgrade, the four new instructions areadditionallyavailable in legacy EVM. There is, however, a preference to limit changes to legacy EVM in the fork where EOF is included as well as in subsequent ones.", "RETURNDATALOADandRETURNDATACOPYpadding behavior": "This EIP initially proposed keeping the halt-on-OOB behavior of legacyRETURNDATACOPY. This makes compilers optimizations harder, because unnecessaryRETURNDATA*instructions cannot be optimized out without change to code semantics.", "EOF1 contracts canEXTDELEGATECALLonly EOF1 contracts": "Legacy contracts can selfdestruct in three different ways (directly throughSELFDESTRUCT, indirectly throughCALLCODEand indirectly throughDELEGATECALL).EIP-3670disables the first two possibilities, however the third possibility remains. Allowing EOF1 contracts toEXTDELEGATECALLonly other EOF1 contracts allows the following strong statement: EOF1 contract can never be destructed. Attacks based onSELFDESTRUCTcompletely disappear for EOF1 contracts. These include destructed library contracts (e.g. Parity Multisig).", "Backwards Compatibility": "No existing instructions are changed and so we do not think any backwards compatibility issues can occur.", "Security Considerations": "It is expected that the attack surface will not grow. All of these operations can be modeled by existing operations with fixed gas (all available) and output range (zero length at zero memory).", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- revamped call instructions: Introduces EXTCALL, EXTDELEGATECALL, and EXTSTATICCALL with simplified gas semantics and clearer status codes, optimizing call operations in EOF contracts."}
{"eip": 7480, "url": "https://eips.ethereum.org/EIPS/eip-7480", "title": "EOF - Data section access instructions", "authors": ["Andrei Maiboroda\u00a0(", "@gumb0", ")", "Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")"], "sections": {"EIP-7480: EOF - Data section access instructions": "Four new instructions are introduced, that allow to read EOF container\u2019s data section:DATALOADloads 32-byte word to stack,DATALOADNloads 32-byte word to stack where the word is addressed by a static immediate argument,DATASIZEloads data section size andDATACOPYcopies a segment of data section to memory.", "Instructions to read data section of EOF container": "Four new instructions are introduced, that allow to read EOF container\u2019s data section:DATALOADloads 32-byte word to stack,DATALOADNloads 32-byte word to stack where the word is addressed by a static immediate argument,DATASIZEloads data section size andDATACOPYcopies a segment of data section to memory.", "Abstract": "Four new instructions are introduced, that allow to read EOF container\u2019s data section:DATALOADloads 32-byte word to stack,DATALOADNloads 32-byte word to stack where the word is addressed by a static immediate argument,DATASIZEloads data section size andDATACOPYcopies a segment of data section to memory.", "Motivation": "Clear separation between code and data is one of the main features of EOF1. Data section may contain anything, e.g. compiler\u2019s metadata, but to make it useful for smart contracts, EVM has to have instructions that allow to read from data section. Previously existing instructions for bytecode inspection (CODECOPY,CODESIZEetc.) are deprecated in EOF1 and cannot be used for this purpose.", "Specification": "We introduce four new instructions on the same block numberEIP-3540is activated on:", "DATALOAD": "[offset:offset+32]is guaranteed to be within data bounds bycode validation.", "DATALOADN": "[offset:offset+32]is guaranteed to be within data bounds bycode validation.", "DATASIZE": "We extend code section validation rules (as defined inEIP-3670).", "DATACOPY": "We extend code section validation rules (as defined inEIP-3670).", "Code Validation": "We extend code section validation rules (as defined inEIP-3670).", "Rationale": "Existing instructions for reading other kinds of data implicitly pad with zeroes on out of bounds access, with the only exception of return data copying.", "Zero-padding on out of bounds access": "Existing instructions for reading other kinds of data implicitly pad with zeroes on out of bounds access, with the only exception of return data copying.", "Lack ofEXTDATACOPY": "EXTCODECOPYinstruction is deprecated and rejected in EOF contracts and does not copy contract code when being called in legacy with an EOF contract as target. A replacement instructionEXTDATACOPYhas been considered, but decided against in order to reduce the scope of changes.", "Backwards Compatibility": "This change poses no risk to backwards compatibility, as it is introduced only for EOF1 contracts, for which deploying undefined instructions is not allowed, therefore there are no existing contracts using these instructions. The new instructions are not introduced for legacy bytecode (code which is not EOF formatted).", "Security Considerations": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation.\n- codecopy: Data spans used to invalidate subsequent JUMPDEST checks"}
{"eip": 7620, "url": "https://eips.ethereum.org/EIPS/eip-7620", "title": "EOF Contract Creation", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")", "Piotr Dobaczewski\u00a0(", "@pdobacz", ")"], "sections": {"EIP-7620: EOF Contract Creation": "EVM Object Format (EOF) removes the possibility to create contracts usingCREATEorCREATE2instructions. We introduce a new/replacement method in form of pair of instructions :EOFCREATEandRETURNCODEto provide a way to create contracts using EOF containers.", "Introduce `EOFCREATE` and `RETURNCODE` instructions": "EVM Object Format (EOF) removes the possibility to create contracts usingCREATEorCREATE2instructions. We introduce a new/replacement method in form of pair of instructions :EOFCREATEandRETURNCODEto provide a way to create contracts using EOF containers.", "Abstract": "EVM Object Format (EOF) removes the possibility to create contracts usingCREATEorCREATE2instructions. We introduce a new/replacement method in form of pair of instructions :EOFCREATEandRETURNCODEto provide a way to create contracts using EOF containers.", "Motivation": "This EIP uses terminology from theEIP-3540which introduces the EOF format.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Parameters": "We introduce two new instructions on the same block numberEIP-3540is activated on:", "Execution Semantics": "In EOF EVM, new bytecode is introduced to the state by means ofInitcodeTransactiondelivering an EOF container (initcontainer). Such a container may include arbitrarily deeply nesting subcontainers. Theinitcontainerand its subcontainers are recursively validated according to all the validation rules applicable for the EOF version in question. Next, the 0th code section of theinitcontaineris executed and may eventually call aRETURNCODEinstruction, which will refer to a subcontainer to be finally deployed to an address.", "Code Validation": "We extend code section validation rules (as defined inEIP-3670).", "Data Section Lifecycle": "For an EOF container which has not yet been deployed, thedata_sectionis only a portion of the finaldata_sectionafter deployment.\nLet\u2019s define it aspre_deploy_data_sectionand aspre_deploy_data_sizethedata_sizedeclared in that container\u2019s header.pre_deploy_data_size >= len(pre_deploy_data_section), which anticipates more data to be appended to thepre_deploy_data_sectionduring the process of deploying.", "Rationale": "The data section is appended to during contract creation and also its size needs to be updated in the header. Alternative designs were considered, where:", "Data section appending": "The data section is appended to during contract creation and also its size needs to be updated in the header. Alternative designs were considered, where:", "keccak256(initcontainer)in thenew_addresshashing scheme": "new_address = keccak256(0xff || sender || salt || keccak256(initcontainer))[12:]was originally proposed as the way to calculate the address of newly created contract, similar, but not exactly equal, to whatCREATE2uses.", "EOFCREATEstack argument order": "EXT*CALLinstructions fromEIP-7069have had their stack argument order changed, as compared to that of legacy instructions*CALL. We follow the same change to haveEOFCREATEstack arg order match those ofEXTCALL.", "Backwards Compatibility": "This change poses no risk to backwards compatibility, as it is introduced at the same time EIP-3540 is. The new instructions are not introduced for legacy bytecode (code which is not EOF formatted), and the contract creation options do not change for legacy bytecode.", "Test Cases": "Creation transaction,CREATEandCREATE2cannot have itscodestarting with0xEF, but such cases are covered already inEIP-3541. However, new cases must be added whereCREATEorCREATE2have itsinitcodebeing (validly or invalidly) EOF formatted:", "Security Considerations": "It is the EOFInitcodeTransaction(specified inEIP-7873) which needs a detailed review and discussion as that is where external unverified code enters the state. Among others:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- eof contract creation: Introduces EOFCREATE and RETURNCONTRACT instructions to handle contract creation in the EOF format, replacing legacy CREATE and CREATE2.\n- initcodetransaction: A new transaction type that enables the deployment of EOF contracts using the TXCREATE instruction."}
{"eip": 7698, "url": "https://eips.ethereum.org/EIPS/eip-7698", "title": "EOF - Creation transaction", "authors": ["Piotr Dobaczewski\u00a0(", "@pdobacz", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-7698: EOF - Creation transaction": "Creation transactions (i.e. the ones with emptyto) can be used to deploy EOF contracts by providing EOF initcontainer concatenated withcalldatafor initcontainer execution in transaction\u2019sdata. Initcontainer execution is similar to its execution duringEOFCREATEinstruction, ending withRETURNCODEinstruction. New account address calculation is based on sender\u2019s address and nonce.", "Deploy EOF contracts using creation transactions": "Creation transactions (i.e. the ones with emptyto) can be used to deploy EOF contracts by providing EOF initcontainer concatenated withcalldatafor initcontainer execution in transaction\u2019sdata. Initcontainer execution is similar to its execution duringEOFCREATEinstruction, ending withRETURNCODEinstruction. New account address calculation is based on sender\u2019s address and nonce.", "Abstract": "Creation transactions (i.e. the ones with emptyto) can be used to deploy EOF contracts by providing EOF initcontainer concatenated withcalldatafor initcontainer execution in transaction\u2019sdata. Initcontainer execution is similar to its execution duringEOFCREATEinstruction, ending withRETURNCODEinstruction. New account address calculation is based on sender\u2019s address and nonce.", "Motivation": "Creation transaction is one of the three ways alongside creation instructions provided by legacy EVM to deploy new code. Given that legacy creation instructions (CREATEandCREATE2) are not allowed to deploy EOF code, supporting EOF in creation transactions is the only way to get the first EOF on-chain.", "Specification": "Wherever not explicitly listed, the rules of EOF contract creation should be identical or analogous to those of legacy creation transaction. This includes but is not limited to:", "Parameters": "In case a creation transaction (transaction with emptyto) hasdatastarting withEOF_MAGIC,datais interpreted as a concatenation of EOFinitcontainerandcalldata. More specifically:", "Rationale": "Originally it was proposed to deploy the first EOF contract via irregular state change. This contract would executeTXCREATEinstruction and could be used then as an entry point to deploy any other EOF code. This would also require an introduction ofInitcodeTransaction, required byTXCREATE. It was decided against this variant for the benefit of reduced scope of changes.", "Irregular state change to deploy Creator Contract": "Originally it was proposed to deploy the first EOF contract via irregular state change. This contract would executeTXCREATEinstruction and could be used then as an entry point to deploy any other EOF code. This would also require an introduction ofInitcodeTransaction, required byTXCREATE. It was decided against this variant for the benefit of reduced scope of changes.", "Constructor arguments outside of initcontainer vs in data section": "Alternative mechanism for providing constructor arguments to initcontainer execution was considered, where they are concatenated with data section of the initcontainer and are accessed viaDATA*instructions instead ofCALLDATA*. This has a benefit of not requiring the step finding the split oftransaction.dataintoinitcontainerandcalldata, as entiretransaction.datais an EOF container. However it was rejected for the following reasons:", "Backwards Compatibility": "Creation transactions deploying legacy code are not affected, because any such transaction starting withEFbyte previously would fail on executing invalid instruction.", "Security Considerations": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- eof contract creation: Introduces EOFCREATE and RETURNCONTRACT instructions to handle contract creation in the EOF format, replacing legacy CREATE and CREATE2.\n- magic: A constant value set as 0xef0100 used in the CREATE_DELEGATE instruction."}
{"eip": 7742, "url": "https://eips.ethereum.org/EIPS/eip-7742", "title": "Uncouple blob count between CL and EL", "authors": ["Alex Stokes\u00a0(", "@ralexstokes", ")"], "sections": {"EIP-7742: Uncouple blob count between CL and EL": "Update blob maximum and target verification fromEIP-4844.", "Have CL verify blob maximum and have EL get target value from CL": "Update blob maximum and target verification fromEIP-4844.", "Abstract": "Update blob maximum and target verification fromEIP-4844.", "Motivation": "Following EIP-4844, the execution layer (EL) maintains a hard-coded blob target value and blob maximum value. Given the relationship\nof the EL and the consensus layer (CL) node software, the verification of the blob maximum is redundant so it can be removed\nentirely without any change in security. The blob maximum is still provided during block construction via the Engine API.\nThis EIP also changes how the EL sources the current blob target value for two reasons:", "Background": "The data facility introduced via EIP-4844 adds blobs to Ethereum blocks, which are simply fixed sets of data that can be\nincluded in the canonical chain but have no execution semantics (cf.calldatain an Ethereum transaction).", "Specification": "Upon activation of this EIP, execution clientsMUSTextend the header schema with an\nadditional 64-bit field: thetarget_blobs_per_block. This value is set to the current target blob count. The Engine API\nis modified along with this EIP to provide thetarget_blobs_per_blockwith each payload and implementations can use this\nvalue to correctly set the block header field.", "Block structure and validity": "Upon activation of this EIP, execution clientsMUSTextend the header schema with an\nadditional 64-bit field: thetarget_blobs_per_block. This value is set to the current target blob count. The Engine API\nis modified along with this EIP to provide thetarget_blobs_per_blockwith each payload and implementations can use this\nvalue to correctly set the block header field.", "Block processing": "Upon activating this EIP (i.e. before processing any transactions),\nthe verification of the blob maximum as given in EIP-4844 can be skipped. Concretely, this means any logic relating\ntoMAX_BLOB_GAS_PER_BLOCKas given in EIP-4844 can be deprecated.", "Block construction": "The Engine API is extended to provide both thetarget_blobs_per_blockand themax_blobs_per_blockwhen the CL requests the EL to construct a payload for proposal.", "Rationale": "Hoisting the full computation into the CL is possible, but it does violate the separation of concerns between these two layers of the protocol stack.\nThe CL maintains a maximum value to address e.g. DoS risks, and the EL maintains knowledge of the target value to address fee accounting.\nPutting the target computation in the CL violates the respective responsibilities of each layer.", "Why not have the CL also compute the blob base fee and remove any notion of blob counts from EL processing?": "Hoisting the full computation into the CL is possible, but it does violate the separation of concerns between these two layers of the protocol stack.\nThe CL maintains a maximum value to address e.g. DoS risks, and the EL maintains knowledge of the target value to address fee accounting.\nPutting the target computation in the CL violates the respective responsibilities of each layer.", "Backwards Compatibility": "No issues.", "Test Cases": "N/A", "Reference Implementation": "N/A", "Security Considerations": "N/A", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- uncouple blob count between cl and el: Separates blob count verification between the consensus and execution layers, allowing the consensus layer to verify blob targets while the execution layer dynamically receives the target from the consensus layer.\n- blob target: The maximum amount of data allowed in blobs on a given block."}
{"eip": 7761, "url": "https://eips.ethereum.org/EIPS/eip-7761", "title": "EXTCODETYPE instruction", "authors": ["Andrei Maiboroda\u00a0(", "@gumb0", ")", "Piotr Dobaczewski\u00a0(", "@pdobacz", ")", "Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-7761: EXTCODETYPE instruction": "Allow EOF contracts to discriminate between EOAs (Externally Owned Accounts) and contract accounts by introducing anEXTCODETYPEinstruction.", "Add EXTCODETYPE instruction to EOF to address common uses of EXTCODE* instructions": "Allow EOF contracts to discriminate between EOAs (Externally Owned Accounts) and contract accounts by introducing anEXTCODETYPEinstruction.", "Abstract": "Allow EOF contracts to discriminate between EOAs (Externally Owned Accounts) and contract accounts by introducing anEXTCODETYPEinstruction.", "Motivation": "EOFv1 as scoped inEIP-7692removes code introspection capabilities from the EVM, including theEXTCODESIZEinstruction (inEIP-3540). This makes it hard forERC-721andERC-1155standard contracts to be implemented, as they rely on discovering whether a token\u2019ssafeTransfercall target was an EOA or a contract account:", "Specification": "We introduce a new EOFv1 instruction on the block numberFORK_BLKNUM:EXTCODETYPE(0xe9)", "Parameters": "We introduce a new EOFv1 instruction on the block numberFORK_BLKNUM:EXTCODETYPE(0xe9)", "Execution Semantics": "Note: if there is not enough gas to deduct for delegation designation the whole message frame will halt, making updating theaccessed_addressesirrelevant.", "Rationale": "There have been other solutions proposed to alleviate the problems related to lack of code introspection required for ERC-721 and ERC-1155 standards:", "Alternative solutions": "There have been other solutions proposed to alleviate the problems related to lack of code introspection required for ERC-721 and ERC-1155 standards:", "Reuse the0x3b(EXTCODESIZE) opcode forEXTCODETYPE": "A new opcode is preferred by a general policy to not reuse opcodes. AlsoEXTCODETYPEcan be rolled out in legacy EVM if desired.", "Keep code introspection banned": "Removing code introspection is one of the tenets of EOF andEXTCODETYPEwould be an exception from the principle. WithoutEXTCODETYPE, ERC-721 and ERC-1155 standard implementations have to resort to either:", "\u201cEndgame Account Abstraction\u201d issues": "EXTCODETYPE(and earlierEXTCODESIZEavailable in legacy EVM) are claimed to slow down AA adoption, because they encourage patterns which discriminate between smart contract and EOA accounts, e.g. not allowing the former to interact. However, there are counterarguments that it is up to other factors which slow down AA adoption (assumption that accounts can produce ECDSA signatures, and the lack of adoption of smart contract signatures).", "Including safeguarding against proxy bricking": "In parallel to the ERC-721 / ERC-1155 problem, another potential risk has been brought to attention. Since EOFv1 prohibitsEXTDELEGATECALLtargeting legacy contracts, there exists a scenario where an EOF proxy contract accidentally upgrades its implementation to a legacy EVM one. Since reverting this or upgrading again (using current proxy standards) requires the implementation contract to be called, it would effectively render the contract unusable.", "Relation toEIP-7702\u201cSet EOA account code\u201d": "AfterEIP-7702is activated, the discrimination between EOAs and contract accounts usingEXTCODESIZE(orEXTCODETYPE) has an edge case: Whenever an EOA sets its code to a contract account which does not respond as expected to anonERC721Received(onERC1155Received) callback, transfers to it will revert, despite the recipient being able to interact with the token. This has been deemed unlikely to be a problem, as for the intended real-world uses of EIP-7702, those callbacks will be implemented by designator codes.", "Backwards Compatibility": "EXTCODETYPEat0xe9can be introduced in a backwards compatible manner into EOFv1 (no bump to version), because0xe9has been rejected by EOF validation beforeFORK_BLKNUMand there are no EOF contracts on-chain with a0xe9which would have their behavior altered.", "Security Considerations": "Needs discussion", "Copyright": "Copyright and related rights waived viaCC0", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- revert: All calls to this opcode must emit a log with revert data."}
{"eip": 7762, "url": "https://eips.ethereum.org/EIPS/eip-7762", "title": "Increase MIN_BASE_FEE_PER_BLOB_GAS", "authors": ["Max Resnick\u00a0(", "@MaxResnick", ")", "Davide Crapis\u00a0(", "@dcrapis", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")"], "sections": {"EIP-7762: Increase MIN_BASE_FEE_PER_BLOB_GAS": "This EIP proposes an increase to the MIN_BASE_FEE_PER_BLOB_GAS to speed up price discovery on blob space. It also resets the excess blob gas to 0, to avoid a blob basefee spike.", "Adjust the MIN_BASE_FEE_PER_BLOB_GAS to speed up price discovery on blob space": "This EIP proposes an increase to the MIN_BASE_FEE_PER_BLOB_GAS to speed up price discovery on blob space. It also resets the excess blob gas to 0, to avoid a blob basefee spike.", "Abstract": "This EIP proposes an increase to the MIN_BASE_FEE_PER_BLOB_GAS to speed up price discovery on blob space. It also resets the excess blob gas to 0, to avoid a blob basefee spike.", "Motivation": "When scoping 4844, the thinking was that blobs would only enter price discovery once, relatively quickly after the blob rollout; however, this has not been the case. In fact, blobs have entered price discovery several times, and the frequency of price discovery events is likely to increase in the short term as we approach saturation of capacity. Moreover, the roadmap calls for further increases in blob capacity in subsequent hardforks, which may lead to price discovery events happening around those changes in the future.", "Specification": "The main specification change introduced by this EIP is setting MIN_BASE_FEE_PER_BLOB_GAS to 2**25:", "MIN_BASE_FEE_PER_BLOB_GASIncrease": "The main specification change introduced by this EIP is setting MIN_BASE_FEE_PER_BLOB_GAS to 2**25:", "excess_blob_gasReset": "To avoid a blob basefee spike, thecalc_excess_blob_gasis modified to resetexcess_blob_gasto 0 at the fork. To detect the fork height, the block timestamp needs to be passed intocalc_excess_blob_gas.", "Rationale": "The current MIN_BASE_FEE_PER_BLOB_GAS is 1 wei. This is many orders of magnitude lower than the prevailing price of blobs when blobs enter price discovery. Whenever demand for blobs exceeds supply, blobs enter price discovery, but traversing the 8 orders of magnitude between 1 wei and the point where elasticity of demand starts to decrease takes a long time.", "Backwards Compatibility": "This EIP is not backwards compatible and requires a coordinated upgrade across all clients at a specific block number.", "Security Considerations": "Rollups that use blobs as a data availability layer will need to update their posting strategies.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- increase min_base_fee_per_blob_gas: Proposes increasing the MIN_BASE_FEE_PER_BLOB_GAS to speed up price discovery on blob space, enhancing the Ethereum network\u2019s efficiency during high demand.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7784, "url": "https://eips.ethereum.org/EIPS/eip-7784", "title": "GETCONTRACT opcode", "authors": ["Tim Pechersky\u00a0(", "@peersky", ")"], "sections": {"EIP-7784: GETCONTRACT opcode": "This is a proposal to add a new opcode,GETCONTRACT. TheGETCONTRACTopcode would return the address containing the bytecode by its hash.", "Global byte code accessing by its hash": "This is a proposal to add a new opcode,GETCONTRACT. TheGETCONTRACTopcode would return the address containing the bytecode by its hash.", "Abstract": "This is a proposal to add a new opcode,GETCONTRACT. TheGETCONTRACTopcode would return the address containing the bytecode by its hash.", "Motivation": "Content addressing by hash is a common pattern in database design. It allows to store and retrieve data by its unique footprint in the storage. This pattern is widely used in the industry and it allows abstracting the actual storage location and allows reusing the same bytecode in multiple contracts.", "Specification": "Every contract stored in EVM MUST be added to the state trie with the key being the keccak256 hash of the contract\u2019s bytecode, provided it is:", "Opcode Definition": "Every contract stored in EVM MUST be added to the state trie with the key being the keccak256 hash of the contract\u2019s bytecode, provided it is:", "Example Usage": "Bytecode over Addresses: Bytecode is deterministic and can be verified on-chain, while addresses are opaque and mutable.", "Rationale": "Bytecode over Addresses: Bytecode is deterministic and can be verified on-chain, while addresses are opaque and mutable.", "Security Considerations": "Malicious Code: The index does NOT guarantee the safety or functionality of indexed contracts. Users MUST exercise caution and perform their own due diligence before interacting with indexed contracts.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- getcontract: Introduces the GETCONTRACT opcode to return the address containing the bytecode by its hash, allowing contracts to identify and interact based on deterministic and tamper-proof bytecode identifiers. This opcode enhances security, auditability, and efficiency in the Ethereum ecosystem by enabling deterministic references to contract code, bypassing the mutability and opacity of contract addresses.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7823, "url": "https://eips.ethereum.org/EIPS/eip-7823", "title": "Set upper bounds for MODEXP", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Radoslaw Zagorowicz\u00a0(", "@rodiazet", ")"], "sections": {"EIP-7823: Set upper bounds for MODEXP": "Introduce an upper bound on the inputs of the MODEXP precompile. This can reduce the number of potential bugs, because the testing surface is not infinite anymore, and makes it easier to be replaced using EVMMAX.", "Each input field is restricted to a maximum of 8192 bits": "Introduce an upper bound on the inputs of the MODEXP precompile. This can reduce the number of potential bugs, because the testing surface is not infinite anymore, and makes it easier to be replaced using EVMMAX.", "Abstract": "Introduce an upper bound on the inputs of the MODEXP precompile. This can reduce the number of potential bugs, because the testing surface is not infinite anymore, and makes it easier to be replaced using EVMMAX.", "Motivation": "The MODEXP precompile has been a source of numerous consensus bugs. Many of them were due to specifically crafted cases using impractical input lengths.", "Specification": "Recap fromEIP-198:", "Rationale": "This upper bound allows the existing use cases of MODEXP:", "Limit": "This upper bound allows the existing use cases of MODEXP:", "EVMMAX": "Replacing the precompile with EVM code using an instruction set like EVMMAX would be made simpler with this limit: Common cases (256, 381, 1024, 2048) could be implemented in special fast paths, while a slow fallback could be provided for the rest. Or even special, frequently used, moduli could have their own paths.", "Analysis": "Since MODEXP was introduced in the Byzantium hard fork, an analysis has been conducted between block 5472266 (April 20, 2018) and block 21550926 (January 4th, 2025). All lengths of inputs are expressed in bytes.", "Backwards Compatibility": "This is a backwards incompatible change. However, based on analysis until block 21550926 (see above), no past transaction would have behaved differently after this change.", "Security Considerations": "Since only the accepted input range is reduced, no new security surface area is expected.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- byzantium hard fork: Specifies the Byzantium hard fork, part of the Metropolis upgrade, introducing features like the REVERT opcode, elliptic curve precompiles, and transaction status codes.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7830, "url": "https://eips.ethereum.org/EIPS/eip-7830", "title": "Contract size limit increase for EOF", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-7830: Contract size limit increase for EOF": "Revise the contract size limit for EOF contracts to be 64 KiB instead of the existing 24 KiB limit. Legacy contracts are unaffected.", "Raise the limit for only EOF contracts to 64 KiB": "Revise the contract size limit for EOF contracts to be 64 KiB instead of the existing 24 KiB limit. Legacy contracts are unaffected.", "Abstract": "Revise the contract size limit for EOF contracts to be 64 KiB instead of the existing 24 KiB limit. Legacy contracts are unaffected.", "Motivation": "The contract size limit was introduced as a measure against DoS attacks.JUMPDEST-analysis is required for legacy contracts, and many of the algorithms performing it are not linear and/or have unknown unknowns. This is one of the reasons for the hesitance of a limit increase.", "Specification": "EIP-170specifiesMAX_CODE_SIZEas 24576 bytes, andEIP-3860specifiesMAX_INITCODE_SIZEas2 * MAX_CODE_SIZE(49152 bytes).", "Rationale": "The 64 KiB limit is over 2x of existing limit, while it is not a significant increase, it is the realistic increase given the limitations of initcode. In EOF deployment the to-be-deployed code is stored as a section (\u201csubcontainer\u201d), which has a size limit of 64 KiB, therefore it is not possible to deploy larger contracts without introducing a large or variable-length-encoded size field.", "Backwards Compatibility": "This is a backwards compatible change. Existing contracts are unaffected, and only new deployments see the effect.", "Security Considerations": "Given the analysis cost is paid as part of deployment, the size of contract should have no effect on the runtime.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- max_code_size: The maximum size of EOF contract code is increased to 64 KiB, allowing more complex contracts to be deployed.\n- max_initcode_size: The maximum size for EOF contract initialization code is set to 128 KiB, reflecting the updated MAX_CODE_SIZE.\n- initcode: The code executed by a contract at its initialization, which must be within 49152 bytes in size before EIP-3860."}
{"eip": 7834, "url": "https://eips.ethereum.org/EIPS/eip-7834", "title": "Separate Metadata Section for EOF", "authors": ["Kaan Uzdogan\u00a0(", "@kuzdogan", ")", "Marco Castignoli\u00a0(", "@marcocastignoli", ")", "Manuel Wedler\u00a0(", "@manuelwedler", ")"], "sections": {"EIP-7834: Separate Metadata Section for EOF": "Introduce a new separate metadata section to the Ethereum Object Format (EOF) that is unreachable by the code, and any changes to which does not affect the code.", "Introduce a new separate metadata section to the EOF": "Introduce a new separate metadata section to the Ethereum Object Format (EOF) that is unreachable by the code, and any changes to which does not affect the code.", "Abstract": "Introduce a new separate metadata section to the Ethereum Object Format (EOF) that is unreachable by the code, and any changes to which does not affect the code.", "Motivation": "It is desirable to include metadata in contract\u2019s bytecode for various reasons. For instance, both the Solidity and Vyper compilers by default include the language and compiler version used to compile. Vyper (with 0.4.1) appends an integrity hash to the initcode in CBOR encoding. Solidity additionally includes the IPFS or the Swarm hash of the Solidity contract metadata.json file, and the experimental Solidity flag. The current (pre-EOF) practice is to append this CBOR encoded metadata section in the contract\u2019s runtime bytecode, followed by the 2 bytes length of the CBOR encoded bytes.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Header": "The strucure and the encoding of themetadata_sectionis not defined by this EIP. It is left to the compilers, tooling, or the contract developers to define the encoding and the content. The current practice by the Solidity and Vyper compilers is to use CBOR encoding.", "Body": "The strucure and the encoding of themetadata_sectionis not defined by this EIP. It is left to the compilers, tooling, or the contract developers to define the encoding and the content. The current practice by the Solidity and Vyper compilers is to use CBOR encoding.", "Rationale": "Themetadata_sectionin thebody, as well as thekind_metadataandmetadata_sizefields in theheader, are OPTIONAL. This way, the compilers can avoid additional bytes in the container if they don\u2019t want to write any metadata. Thedata_sectioncan change in its size and content during deployment, therefore it needs to be REQUIRED, even if the data is empty. Themetadata_sectionis not expected to change during the deployment.", "Backwards Compatibility": "No backward compatibility issues are expected sinceEIP-3540is not implemented yet.", "Security Considerations": "No security considerations as this section is meant not to be executed.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- metadata_section: A new optional section in the Ethereum Object Format (EOF) body that is distinct from the executable code and data sections, allowing metadata changes without affecting code behavior or source verification. \u200b\n- initcode: The code executed by a contract at its initialization, which must be within 49152 bytes in size before EIP-3860.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785."}
{"eip": 7873, "url": "https://eips.ethereum.org/EIPS/eip-7873", "title": "EOF - TXCREATE and InitcodeTransaction type", "authors": ["Piotr Dobaczewski\u00a0(", "@pdobacz", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Alex Beregszaszi\u00a0(", "@axic", ")", "Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-7873: EOF - TXCREATE and InitcodeTransaction type": "EVM Object Format (EOF) removes the possibility to create contracts using creation transactions (with an emptytofield),CREATEorCREATE2instructions. We introduce a new instruction:TXCREATE, as well as a new transaction type (InitcodeTransaction), to provide a way to create contracts using EOF containers in transaction data.", "Adds a `TXCREATE` instruction to EOF and an accompanying transaction type allowing to create EOF contracts from transaction data": "EVM Object Format (EOF) removes the possibility to create contracts using creation transactions (with an emptytofield),CREATEorCREATE2instructions. We introduce a new instruction:TXCREATE, as well as a new transaction type (InitcodeTransaction), to provide a way to create contracts using EOF containers in transaction data.", "Abstract": "EVM Object Format (EOF) removes the possibility to create contracts using creation transactions (with an emptytofield),CREATEorCREATE2instructions. We introduce a new instruction:TXCREATE, as well as a new transaction type (InitcodeTransaction), to provide a way to create contracts using EOF containers in transaction data.", "Motivation": "This EIP uses terminology from theEIP-3540which introduces the EOF format.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Parameters": "Introduce new transactionInitcodeTransaction(typeINITCODE_TX_TYPE) which extendsEIP-1559(type 2) transaction by adding a new fieldinitcodes: List[ByteList[MAX_INITCODE_SIZE], MAX_INITCODE_COUNT].", "Transaction Types": "Introduce new transactionInitcodeTransaction(typeINITCODE_TX_TYPE) which extendsEIP-1559(type 2) transaction by adding a new fieldinitcodes: List[ByteList[MAX_INITCODE_SIZE], MAX_INITCODE_COUNT].", "Execution Semantics": "Wherever not explicitly listed, the rules of EOF contract creation, as well as theTXCREATEinstruction, should be identical or analogous to those ofCREATE2instruction. This includes but is not limited to:", "Rationale": "TXCREATEhas two \u201clight\u201d failure modes in case the initcontainer is not present and in case the EOF validation is unsuccessful. An alternative design where both cases led to a \u201chard\u201d failure (consuming the entire gas available) was considered. We decided to have the more granular and forgiving failure modes in order to align the gas costs incurred to the actual work the EVM performs.", "TXCREATEfailure modes": "TXCREATEhas two \u201clight\u201d failure modes in case the initcontainer is not present and in case the EOF validation is unsuccessful. An alternative design where both cases led to a \u201chard\u201d failure (consuming the entire gas available) was considered. We decided to have the more granular and forgiving failure modes in order to align the gas costs incurred to the actual work the EVM performs.", "AllowingTXCREATEin legacy EVM": "EOF contract creation requires an exceptional possibility of calling an EOF opcode in legacy code -TXCREATE, because otherwise neither legacy contracts nor create transactions can deploy EOF code to bootstrap. The alternative approach was to continue using legacy creation mechanisms, by either still relying on fetching theinitcodefrom memory and not satisfy the overarching requirement of code non-observability, or to abuse the legacy creation transactions mechanism, or to introduce a predeployed Creator Contract into the state.", "New address hashing scheme": "TXCREATEuses the schemenew_address = keccak256(0xff || sender32 || salt)[12:], same asEOFCREATEinstruction. The decision whether to include initcontainer hash into salt is left to theTXCREATEcaller. SeeEIP-7620for detailed rationale.", "EOF creation transactions vs deployment patterns": "Relying on the EOF creation transactions as the alternative solution makes it impossible for smart contract wallets to deploy arbitrary EOF contracts (only EOAs can). At the same time, it is a use case current legacy creation rules allow, thanks toCREATEandCREATE2instructions. A workaround where those arbitrary EOF contracts are first \u201cuploaded\u201d to a factory contract, and then deployed using anEXTDELEGATECALL-EOFCREATEsequence, is very expensive, as it requires the deployed contract to be put on-chain twice. Because of this, the approach proposed in this EIP is more compatible with the Account Abstraction (AA) roadmap, where smart contract wallets should have feature parity with EOAs.", "Backwards Compatibility": "This change poses no risk to backwards compatibility, as it is introduced at the same time EIP-3540 is. Despite the new instruction being introduced for legacy bytecode (code which is not EOF formatted), there is little chance that a meaningful contract would unintentionally execute0xedinstruction with formally valid operands and inadvertently cause it to run EOF initcode (which would also require anInitcodeTransactionto be used, otherwise the initcode lookup will fail).", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures."}
{"eip": 7880, "url": "https://eips.ethereum.org/EIPS/eip-7880", "title": "EOF - EXTCODEADDRESS instruction", "authors": ["Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-7880: EOF - EXTCODEADDRESS instruction": "Add an instruction to EOF that reads code delegation designations from an account without requiring code introspection.", "Add EXTCODEADDRESS instruction to EOF to address code delegation use cases": "Add an instruction to EOF that reads code delegation designations from an account without requiring code introspection.", "Abstract": "Add an instruction to EOF that reads code delegation designations from an account without requiring code introspection.", "Motivation": "EOFv1 as scoped inEIP-7692removes code introspection capabilities from the EVM, preventing EOF from reading raw code values such as code delegation designations set byEIP-7702. There are a number of use cases where reading the delegation designation ofEIP-7702would allow contracts to be more proactive about user experience issues.", "Specification": "We introduce a new EOFv1 instructionEXTCODEADDRESS(0xea).", "Parameters": "We introduce a new EOFv1 instructionEXTCODEADDRESS(0xea).", "Execution Semantics": "Note: Iftarget_addresspoints to an account with a contract mid-creation, thentarget_addressis returned. If delegation designator points to an account with a contract mid-creation, then address of the designation is returned.", "Rationale": "This EIP is very similar toEIP-7761, which introduces account type introspection. Its rationale is included by reference as they all apply to this situation.", "Alternative: Return the whole designation, have contract parse": "One alternative is to have a specially limitedEXTCODECOPYthat would return just delegation designations. Apart from the general objections to code introspection this would then lock in and limit delegation designation formats and capabilities that must be preserved in future forks. By allowing access to the effect of the delegation rather than the mechanism, EOF preserves space for the mechanism to be changed without breaking existing code.", "Backwards Compatibility": "EXTCODEADDRESSat0xeacan be introduced in a backwards compatible manner into EOFv1 (no bump to version), because0xeahas been rejected by EOF validation prior to the actication of this EIP, and there are no EOF contracts on-chain with an0xeainstruction which would have their behavior altered.", "Security Considerations": "EIP-7702code delegation is a new feature that has not been made accessible to mainnet yet. EIP authors will keep abreast of any developments and reflect on their impact to this proposed instruction.", "Copyright": "Copyright and related rights waived viaCC0", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation.\n- codecopy: Data spans used to invalidate subsequent JUMPDEST checks"}
{"eip": 7918, "url": "https://eips.ethereum.org/EIPS/eip-7918", "title": "Blob base fee bounded by execution cost", "authors": ["Anders Elowsson\u00a0(", "@anderselowsson", ")"], "sections": {"EIP-7918: Blob base fee bounded by execution cost": "This EIP imposes that the price of the targeted number blobsTARGET_BLOB_GAS_PER_BLOCK * base_fee_per_blob_gasstays above the price of a simple blob-carrying transactionTX_BASE_COST * base_fee_per_gas. This ensures that the blob fee auction can function properly, because the equilibrium always forms relative to the fee that carries the price signal. The proposedifstatement to check fee parity incalc_excess_blob_gas()represents a neutral, simple, and future-proof resolution to current blob fee auction idiosyncrasies.", "Imposes that the price for TARGET_BLOB_GAS_PER_BLOCK is greater than the price for TX_BASE_COST": "This EIP imposes that the price of the targeted number blobsTARGET_BLOB_GAS_PER_BLOCK * base_fee_per_blob_gasstays above the price of a simple blob-carrying transactionTX_BASE_COST * base_fee_per_gas. This ensures that the blob fee auction can function properly, because the equilibrium always forms relative to the fee that carries the price signal. The proposedifstatement to check fee parity incalc_excess_blob_gas()represents a neutral, simple, and future-proof resolution to current blob fee auction idiosyncrasies.", "Abstract": "This EIP imposes that the price of the targeted number blobsTARGET_BLOB_GAS_PER_BLOCK * base_fee_per_blob_gasstays above the price of a simple blob-carrying transactionTX_BASE_COST * base_fee_per_gas. This ensures that the blob fee auction can function properly, because the equilibrium always forms relative to the fee that carries the price signal. The proposedifstatement to check fee parity incalc_excess_blob_gas()represents a neutral, simple, and future-proof resolution to current blob fee auction idiosyncrasies.", "Motivation": "Ethereum deploys a dynamic pricing auction to set the blob base fee, lowering the fee if less gas is consumed thanTARGET_BLOB_GAS_PER_BLOCKand raising the fee if more gas is consumed. Such an auction can function well when the blob base fee represents the price signal, allowing the mechanism to control the real price facing the consumer. However, when the cost of execution gas in the blob-carrying transaction dominates, the price signal is lost. The blob base fee no longer represents the actual cost facing the consumer, and the protocol cannot adjust the blob base fee to regulate the equilibrium quantity of blobs consumed. Under these circumstances, the current mechanism will continue lowering the blob base fee until it eventually settles at 1 wei. Whenever demand picks up, a sustained succession of near-full blocks is required to restore equilibrium, with the mechanism intermittently resorting to a first-price auction, considered a worse UX by blob consumers. The resulting spikiness in resource consumption is suboptimal for scaling blobspace.", "Specification": "The functioncalc_excess_blob_gas()fromEIP-4844is changed to addparent.blob_gas_used // 3and not subtractTARGET_BLOB_GAS_PER_BLOCKwhen updating theexcess_blob_gas, if the price ofTARGET_BLOB_GAS_PER_BLOCKis below the price ofTX_BASE_COST.", "Rationale": "This proposal alleviates idiosyncrasies in the blob base fee auction. Fundamentally, the issue is that the demand curve becomes fee-inelastic as the cost of blob data falls relative to the cost of the blob-carrying transaction. When the execution cost dominates, it does not matter to the blob consumer how the blob fee evolves\u2014it is ultimately the execution cost that determines equilibrium formation. Given that the protocol stipulates a long-run perfectly inelastic supply curve (vertical blue line in Figure 1), the blob base fee will simply fall to the boundary of 1 wei whenever the execution cost is too high for equilibrium formation atTARGET_BLOB_GAS_PER_BLOCK. Thus, in the regime where execution fees dominate, the demand curve isblob fee-inelastic, and whenever the blob fees dominate, the demand curve isexecution fee-inelastic. Figure 1 maps the quantity of blobs demanded $Q$ to the blob base fee $f_b$ and the execution cost $c_\\text{tx}$:", "Fee-inelasticity": "This proposal alleviates idiosyncrasies in the blob base fee auction. Fundamentally, the issue is that the demand curve becomes fee-inelastic as the cost of blob data falls relative to the cost of the blob-carrying transaction. When the execution cost dominates, it does not matter to the blob consumer how the blob fee evolves\u2014it is ultimately the execution cost that determines equilibrium formation. Given that the protocol stipulates a long-run perfectly inelastic supply curve (vertical blue line in Figure 1), the blob base fee will simply fall to the boundary of 1 wei whenever the execution cost is too high for equilibrium formation atTARGET_BLOB_GAS_PER_BLOCK. Thus, in the regime where execution fees dominate, the demand curve isblob fee-inelastic, and whenever the blob fees dominate, the demand curve isexecution fee-inelastic. Figure 1 maps the quantity of blobs demanded $Q$ to the blob base fee $f_b$ and the execution cost $c_\\text{tx}$:", "Designing for the future": "Figure 2 once again shows the permitted (green) and restricted (red) regions also captured in Figure 1, but this time with execution base fee on the x-axis. Various settings for fee parity are indicated by black lines. When fee parity is imposed based on a transaction carrying many blobs (e.g., 48), its total cost will be relatively higher, and the blob base fee will as a result be operational at a relatively lower level. Such a shift is inherent by design and as intended. If blob consumers include many more blobs in their blob-carrying transactions, the execution gas may no longer carry the price signal at the same blob base fee, and the blob base fee should be able to settle relatively lower. This is also why fixed thresholds not relating to blob quantity or the execution fee may not be sustainable. In a scenario where Ethereum provides many orders of magnitude more blobs, the equilibrium blob base fee should ideally have a relatively lower floor. To understand why potential future blob scaling is important to account for when designing the mechanism, consider how the price of storing a fixed amount of data has fallen over the last 80 years.", "Delayed response during a quick rise in execution fees": "When theifstatement concludes that Ethereum operates in the execution-fee-led pricing regime, the blob base fee rises in accordance withblob_gas_used // 3, without subtractingTARGET_BLOB_GAS_PER_BLOCK. This is an intuitive way to return to the blob-fee-led pricing regime, retaining the same maximum fee increase while not allowing for a decrease. If the execution base fee rises quickly, there may however be a few blocks before the blob base fee catches up (during whichTARGET_BLOB_GAS_PER_BLOCKwill never be subtracted and the blob fee moves in the direction of the arrows in Figure 2). This is arguably not an issue, and the smooth response in the blob base fee under these circumstances may even be seen as a benefit.", "Alternative specifications": "The specification outlines the simplest way to achieve the desired goals and is therefore preferred. Here, two alternative variants are outlined. In the first, the fee-parity comparison is instead made on the current block\u2019s base fees, as derived from the parent block. The computation for the execution base fee is omitted and the variable instead provided as input. This would also require a change to the block validityassertstatement (omitted here).", "Security Considerations": "The blob base fee will settle at a level where posting the target number of blobs costs at least as much as its blob-carrying transaction. To the best of the author\u2019s knowledge, there are no security risks associated with this.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- base_cost: A constant gas cost set as 12500 for calculating refunds during the CREATE_DELEGATE process.\n- blob base fee: the base fee for blob gas usage\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4762, "url": "https://eips.ethereum.org/EIPS/eip-4762", "title": "Statelessness gas cost changes", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")", "Dankrad Feist\u00a0(", "@dankrad", ")", "Ignacio Hagopian\u00a0(", "@jsign", ")", "Tanishq Jasoria\u00a0(", "@tanishqjasoria", ")", "Gajinder Singh\u00a0(", "@g11tech", ")"], "sections": {"EIP-4762: Statelessness gas cost changes": "This EIP introduces changes in the gas schedule to reflect the costs of creating a witness. It requires clients to update their database layout to match this, so as to avoid potential DoS attacks.", "Changes the gas schedule to reflect the costs of creating a witness by requiring clients update their database layout to match.": "This EIP introduces changes in the gas schedule to reflect the costs of creating a witness. It requires clients to update their database layout to match this, so as to avoid potential DoS attacks.", "Abstract": "This EIP introduces changes in the gas schedule to reflect the costs of creating a witness. It requires clients to update their database layout to match this, so as to avoid potential DoS attacks.", "Motivation": "The introduction of Verkle trees into Ethereum requires fundamental changes and as a preparation, this EIP is targeting the fork coming right before the verkle tree fork, in order to incentivize Dapp developers to adopt the new storage model, and ample time to adjust to it. It also incentivizes client developers to migrate their database format ahead of the verkle fork.", "Specification": "Whenever the state is read, one or more of the access events of the form(address, sub_key, leaf_key)take place, determining what data is being accessed. We define access events as follows:", "Helper functions": "Whenever the state is read, one or more of the access events of the form(address, sub_key, leaf_key)take place, determining what data is being accessed. We define access events as follows:", "Access events": "Whenever the state is read, one or more of the access events of the form(address, sub_key, leaf_key)take place, determining what data is being accessed. We define access events as follows:", "Write Events": "We definewrite eventsas follows. Note that when a write takes place, an access event also takes place (so the definition below should be a subset of the definition of access events). A write event is of the form(address, sub_key, leaf_key), determining what data is being written to.", "Transaction": "For a transaction, make these access events:", "Witness gas costs": "Remove the following gas costs:", "Block-level operations": "None of:", "System contracts": "When (and only when) calling a system contract either", "Account abstraction": "TODO : still waiting on a final decision between 7702 and 3074", "Rationale": "Gas costs for reading storage and code are reformed to more closely reflect the gas costs under the new Verkle tree design.WITNESS_CHUNK_COSTis set to charge 6.25 gas per byte for chunks, andWITNESS_BRANCH_COSTis set to charge ~13,2 gas per byte for branches on average (assuming 144 byte branch length) and ~2.5 gas per byte in the worst case if an attacker fills the tree with keys deliberately computed to maximize proof length.", "Gas reform": "Gas costs for reading storage and code are reformed to more closely reflect the gas costs under the new Verkle tree design.WITNESS_CHUNK_COSTis set to charge 6.25 gas per byte for chunks, andWITNESS_BRANCH_COSTis set to charge ~13,2 gas per byte for branches on average (assuming 144 byte branch length) and ~2.5 gas per byte in the worst case if an attacker fills the tree with keys deliberately computed to maximize proof length.", "Backwards Compatibility": "This EIP requires a hard fork, since it modifies consensus rules.", "Security Considerations": "This EIP will mean that certain operations, mostly reading and writing several elements in the same suffix tree, become cheaper. If clients retain the same database structure as they have now, this would result in a DOS vector.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- statelessness gas cost changes: Revises gas costs to reflect the cost of generating stateless witnesses, updating the gas schedule for access events and storage operations in preparation for Verkle trees.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6404, "url": "https://eips.ethereum.org/EIPS/eip-6404", "title": "SSZ transactions", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Gajinder Singh\u00a0(", "@g11tech", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-6404: SSZ transactions": "This EIP defines a migration process ofEIP-2718Recursive-Length Prefix (RLP) transactions toSimple Serialize (SSZ).", "Migration of RLP transactions to SSZ": "This EIP defines a migration process ofEIP-2718Recursive-Length Prefix (RLP) transactions toSimple Serialize (SSZ).", "Abstract": "This EIP defines a migration process ofEIP-2718Recursive-Length Prefix (RLP) transactions toSimple Serialize (SSZ).", "Motivation": "RLP transactions have a number of shortcomings:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Existing definitions": "Definitions from existing specifications that are used throughout this document are replicated here for reference.", "ExecutionSignaturecontainer": "Signatures use their native, opaque representation, and are extended with an on-chain commitment to the signing address.", "Transactioncontainer": "All transactions are represented as a single, normalized SSZ container. The definition uses theStableContainer[N]SSZ type andOptional[T]as defined inEIP-7495.", "Transactionprofiles": "EIP-7495Profiledefinitions provide type safety for valid transactions. Their original RLPTransactionTypeis retained to enable recovery of their original RLP representation and associatedsig_hashandtx_hashvalues where necessary.", "Execution block header changes": "Theexecution block header\u2019stxs-rootis transitioned from MPT to SSZ.", "Engine API": "In the engine API, the structure of thetransactionsfield inExecutionPayloadversions adopting this EIP is changed fromArray of DATAtoArray of TransactionV1.", "ConsensusExecutionPayloadchanges": "When building a consensusExecutionPayload, thetransactionslist is no longer opaque and uses the newTransactiontype.", "SSZPooledTransactioncontainer": "During transaction gossip responses (PooledTransactions), eachTransactionis wrapped into aPooledTransaction.", "Transaction gossip announcements": "The semantics of thetypeselementin transaction gossip announcements (NewPooledTransactionHashes) are changed to matchssz(PooledTransaction.active_fields()). The separate control flow for fetching blob transactions compared to basic transactions is retained.", "Networking": "When exchanging SSZ transactions via theEthereum Wire Protocol, the followingEIP-2718compatible envelopes are used:", "Rationale": "Switching to a single, unified and forward compatible transaction format within execution blocks reduces implementation complexity for client applications and smart contracts. Future use cases such as transaction inclusion proofs or submitting individual verifiable chunks of calldata to a smart contract become easier to implement with SSZ.", "Backwards Compatibility": "Applications that rely on the replaced MPTtransactions_rootin the block header require migration to the SSZtransactions_root.", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- ssz transactions: Migrates transaction serialization from RLP to SSZ, aligning the transaction format with consensus and providing extensibility for future transaction features.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6465, "url": "https://eips.ethereum.org/EIPS/eip-6465", "title": "SSZ withdrawals root", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Mikhail Kalinin\u00a0(", "@mkalinin", ")"], "sections": {"EIP-6465: SSZ withdrawals root": "This EIP defines a migration process of the existing Merkle-Patricia Trie (MPT) commitment for withdrawals toSimple Serialize (SSZ).", "Migration of withdrawals MPT commitment to SSZ": "This EIP defines a migration process of the existing Merkle-Patricia Trie (MPT) commitment for withdrawals toSimple Serialize (SSZ).", "Abstract": "This EIP defines a migration process of the existing Merkle-Patricia Trie (MPT) commitment for withdrawals toSimple Serialize (SSZ).", "Motivation": "While the consensusExecutionPayloadHeaderand the execution block header map to each other conceptually, they are encoded differently. This EIP aims to align the encoding of thewithdrawals_root, taking advantage of the more modern SSZ format. This brings several advantages:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Existing definitions": "Definitions from existing specifications that are used throughout this document are replicated here for reference.", "SSZWithdrawalcontainer": "The existing consensusWithdrawalSSZ container is used to represent withdrawals.", "Execution block header changes": "The execution block header\u2019swithdrawals-rootis updated to match the consensusExecutionPayloadHeader.withdrawals_root.", "Typed withdrawal envelope": "A typed withdrawal envelope similar toEIP-2718is introduced for exchanging withdrawals via theEthereum Wire Protocol.", "Networking": "When exchanging SSZ withdrawals via theEthereum Wire Protocol, the following withdrawal envelope is used:", "Rationale": "This change was originally a candidate for inclusion in Shanghai, but was postponed to accelerate the rollout of withdrawals.", "Why typed withdrawal envelopes?": "The RLPx serialization layer may not be aware of the fork schedule and the block timestamp when withdrawals are exchanged. The typed withdrawal envelope assists when syncing historical blocks based on RLP and the MPTwithdrawals_root.", "Backwards Compatibility": "Applications that rely on the replaced MPTwithdrawals_rootin the block header require migration to the SSZwithdrawals_root.", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- ssz withdrawals root: Migrates the withdrawal Merkle-Patricia Trie (MPT) root to Simple Serialize (SSZ), aligning the withdrawals_root across consensus and execution layers.\n- withdrawal: Log entry in system_logs for tracking withdrawals under EIP-4895 .\n- executionpayloadheader: Replaces ExecutionPayload in BeaconBlockBody"}
{"eip": 6466, "url": "https://eips.ethereum.org/EIPS/eip-6466", "title": "SSZ receipts", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Gajinder Singh\u00a0(", "@g11tech", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-6466: SSZ receipts": "This EIP defines a migration process ofEIP-2718Recursive-Length Prefix (RLP) receipts toSimple Serialize (SSZ)", "Migration of RLP receipts to SSZ": "This EIP defines a migration process ofEIP-2718Recursive-Length Prefix (RLP) receipts toSimple Serialize (SSZ)", "Abstract": "This EIP defines a migration process ofEIP-2718Recursive-Length Prefix (RLP) receipts toSimple Serialize (SSZ)", "Motivation": "RLP receipts have a number of shortcomings:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Existing definitions": "Definitions from existing specifications that are used throughout this document are replicated here for reference.", "Receiptcontainer": "All receipts are represented as a single, normalized SSZ container. The definition uses theStableContainer[N]SSZ type andOptional[T]as defined inEIP-7495.", "Receiptconstruction": "Receipts are constructed as follows.", "Execution block header changes": "Theexecution block header\u2019sreceipts-rootis transitioned from MPT to SSZ.", "JSON-RPC API": "Transaction receipt objects in the context of the JSON-RPC API are extended to include:", "ConsensusExecutionPayloadchanges": "When building a consensusExecutionPayload, thereceipts_rootis now based on theReceipttype, changing the type ofreceipts_rootfrom an MPTHash32to an SSZRoot.", "Networking": "When exchanging SSZ receipts via theEthereum Wire Protocol, the followingEIP-2718compatible envelope is used:", "Rationale": "Switching to a single, unified and forward compatible receipt format within execution blocks reduces implementation complexity for client applications and smart contracts. Individual chunks of receipt data can now be verified, simplifying implementation of bridges.", "Backwards Compatibility": "Applications that rely on the replaced MPTreceipts_rootin the block header require migration to the SSZreceipts_root.", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- ssz receipts: Migrates RLP receipts to SSZ, enabling efficient proofs for individual receipt components, simplifying gas calculations, and unifying receipt handling across transaction types.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6493, "url": "https://eips.ethereum.org/EIPS/eip-6493", "title": "SSZ transaction signature scheme", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Gajinder Singh\u00a0(", "@g11tech", ")", "Matt Garnett\u00a0(", "@lightclient", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-6493: SSZ transaction signature scheme": "This EIP defines a signature scheme for nativeSimple Serialize (SSZ)encoded transactions.", "Signature scheme for native SSZ transactions": "This EIP defines a signature scheme for nativeSimple Serialize (SSZ)encoded transactions.", "Abstract": "This EIP defines a signature scheme for nativeSimple Serialize (SSZ)encoded transactions.", "Motivation": "EIP-6404introduces SSZ transactions by converting from RLP transactions. Defining a signature scheme for native SSZ transactions further reduces required conversions and unlocks the forward compatibility benefits of SSZStableContainer.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Transaction signature scheme": "Native SSZ transactions are based on theTransactionPayloadandTransactiontypes defined inEIP-6404and emit anEIP-6466Receipt. To distinguish native SSZ transactions from those converted from RLP, native SSZ transactions do not set an RLPTransactionTypein theirTransactionPayload.", "JSON-RPC": "Certain JSON-RPC endpoints such aseth_getTransactionByHashindicate the correspondingEIP-2718envelope type prefix in atypefield.", "Transactionprofiles": "NewEIP-7495Profiledefinitions are introduced to represent native SSZ transactions:", "Rationale": "The SSZ signature scheme reduces hashing overhead and ensures thattx_hashcommitments are available on-chain. It also provides a flexible basis for future transaction functionality.", "Backwards Compatibility": "The new transaction signature scheme is solely used for SSZ transactions and is represented using a differentEIP-2718envelope type prefix as existing RLP transactions.", "Security Considerations": "SSZ signatures MUST NOT collide with RLP transaction and message hashes.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- ssz transactions: Migrates transaction serialization from RLP to SSZ, aligning the transaction format with consensus and providing extensibility for future transaction features.\n- ssz transaction signature scheme: A new signature scheme for native use of SSZ transactions without conversion through trusted API gateways.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785."}
{"eip": 6690, "url": "https://eips.ethereum.org/EIPS/eip-6690", "title": "EVM Modular Arithmetic Extensions", "authors": ["Jared Wasinger\u00a0(", "@jwasinger", ")", "Alex Beregszaszi\u00a0(", "@axic", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")", "Rados\u0142aw Zag\u00f3rowicz\u00a0(", "@rodiazet", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")"], "sections": {"EIP-6690: EVM Modular Arithmetic Extensions": "This EIP proposes new EVM modular arithmetic opcodes which support operations on odd or power-of-two moduli between 3 and 2**768-1", "Expanded-width, efficient modular arithmetic operations for the EVM": "This EIP proposes new EVM modular arithmetic opcodes which support operations on odd or power-of-two moduli between 3 and 2**768-1", "Abstract": "This EIP proposes new EVM modular arithmetic opcodes which support operations on odd or power-of-two moduli between 3 and 2**768-1", "Motivation": "Current opcodes for modular arithmetic only support values up to 256 bits wide.  In addition, they are permissive and accept any representable value for the inputs.", "Specification": "The execution state of an EVM call frame is modified to include a mapping ofid(a number 0-256) to a field context.  A field context comprises a modulus and an allocated space of virtual registers to perform modular arithmetic operations on.", "Constants": "The execution state of an EVM call frame is modified to include a mapping ofid(a number 0-256) to a field context.  A field context comprises a modulus and an allocated space of virtual registers to perform modular arithmetic operations on.", "Conventions": "The execution state of an EVM call frame is modified to include a mapping ofid(a number 0-256) to a field context.  A field context comprises a modulus and an allocated space of virtual registers to perform modular arithmetic operations on.", "Overview": "The execution state of an EVM call frame is modified to include a mapping ofid(a number 0-256) to a field context.  A field context comprises a modulus and an allocated space of virtual registers to perform modular arithmetic operations on.", "New Opcodes": "Input:<top of stack> id modulus_offset modulus_size alloc_count.", "EVM Memory Expansion Cost Modification": "When expanding EVM memory or allocating a new field context viaSETMODX, expansion cost will now consider the size of all allocated virtual registers in the current call frame.", "Rationale": "It is assumed that optimized implementations will not store values in EVM-compatible big-endian serialization format, but instead convert them to an internal working representation.  The costs in the spec explicitly reflect the choice of Montgomery form as an optimal internal representation.", "Separation of EVM Memory and EVMMAX Virtual Register Space": "It is assumed that optimized implementations will not store values in EVM-compatible big-endian serialization format, but instead convert them to an internal working representation.  The costs in the spec explicitly reflect the choice of Montgomery form as an optimal internal representation.", "Total Virtual Register Allocation Cap": "24576 bytes is chosen as the per-call-context allocation limit with the goal of ensuring that the virtual register space can be contained in the L1 CPU data cache of most machines (with room to spare), in order that arithmetic operation costs do not have to account for memory access latency.", "SETMODX cost": "For odd moduli,SETMODXprecomputes two values used for optimized modular multiplication via Montgomery reduction.  This is dominated by a modular reduction by the modulus, so the cost model is assumed to be linear.", "LOADX/STOREX costs": "For power-of-two moduli,LOADX/STOREXare assumed to copy values directly between EVM/EVMMAX memories without measurable conversion cost to convert between EVM big-endian serialization and whatever internal representation is used.", "Arithmetic Costs": "Addition/subtraction/multiplication are assumed to have constant-time implementations.  Addition/subtraction can be implemented with linear complexity, while multiplication is quadratic in the size of the modulus.", "Montgomery Modular Multiplication": "For a valueA, an odd modulusMand a valueR(must be coprime and greater thanM, chosen as a power of two for efficient performance), the Montgomery representation isA * R % M.", "Test Cases": "There are tests contained in the Geth implementation.  However, no cross-client tests exist yet.", "Reference Implementation": "There is an implementation of this EIP in an open PR to Go Ethereum.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6800, "url": "https://eips.ethereum.org/EIPS/eip-6800", "title": "Ethereum state using a unified verkle tree", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Dankrad Feist\u00a0(", "@dankrad", ")", "Kevaundray Wedderburn\u00a0(", "@kevaundray", ")", "Guillaume Ballet\u00a0(", "@gballet", ")", "Piper Merriam\u00a0(", "@pipermerriam", ")", "Gottfried Herold\u00a0(", "@GottfriedHerold", ")", "Ignacio Hagopian\u00a0(", "@jsign", ")", "Tanishq Jasoria\u00a0(", "@tanishqjasoria", ")", "Gajinder Singh\u00a0(", "@g11tech", ")", "Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-6800: Ethereum state using a unified verkle tree": "Introduce a new Verkle state tree alongside the existing hexary Patricia tree. After the hard fork, the Verkle tree stores all edits to state and a copy of all accessed state, and the hexary Patricia tree can no longer be modified. This is a first step in a multi-phase transition to Ethereum exclusively relying on Verkle trees to store execution state.", "This introduces a new Verkle state tree alongside the existing MPT.": "Introduce a new Verkle state tree alongside the existing hexary Patricia tree. After the hard fork, the Verkle tree stores all edits to state and a copy of all accessed state, and the hexary Patricia tree can no longer be modified. This is a first step in a multi-phase transition to Ethereum exclusively relying on Verkle trees to store execution state.", "Abstract": "Introduce a new Verkle state tree alongside the existing hexary Patricia tree. After the hard fork, the Verkle tree stores all edits to state and a copy of all accessed state, and the hexary Patricia tree can no longer be modified. This is a first step in a multi-phase transition to Ethereum exclusively relying on Verkle trees to store execution state.", "Motivation": "Verkle trees solve a key problem standing in the way of Ethereum being stateless-client-friendly: witness sizes. A witness accessing an account in today\u2019s hexary Patricia tree is, in the average case, close to 3 kB, and in the worst case it may be three times larger. Assuming a worst case of 6000 accesses per block (15m gas / 2500 gas per access), this corresponds to a witness size of ~18 MB, which is too large to safely broadcast through a p2p network within a 12-second slot. Verkle trees reduce witness sizes to ~200 bytes per account in the average case, allowing stateless client witnesses to be acceptably small.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Verkle tree definition": "We define a Verkle tree here by providing the function to compute the root commitment given a set of 32-byte keys and 32-byte values. Algorithms for updating and inserting values are up to the implementer; the only requirement is that the root commitment after the update must continue to match the value computed from this specification. We will then define an embedding that provides the 32-byte key at which any particular piece of state information (account headers, code, storage) should be stored.", "Illustration": "This is an illustration of the tree structure.", "Tree embedding": "Instead of a two-layer structure as in the Patricia tree, in the Verkle tree we will embed all information into a singlekey: valuetree. This section specifies which tree keys store the information (account header data, code, storage) in the state.", "Rationale": "This implements all of the logic in transitioning to a Verkle tree, and at the same time reforms gas costs, but does so in a minimally disruptive way that does not require simultaneously changing the whole tree structure. Instead, we add a new Verkle tree that starts out empty, and only new changes to state and copies of accessed state are stored in the tree. The Patricia tree continues to exist, but is frozen.", "Verkle tree design": "The Verkle tree uses a single-layer tree structure with 32-byte keys and values for several reasons:", "Gas reform": "Gas costs for reading storage and code are reformed to more closely reflect the gas costs under the new Verkle tree design. WITNESS_CHUNK_COST is set to charge 6.25 gas per byte for chunks, and WITNESS_BRANCH_COST is set to charge ~13,2 gas per byte for branches on average (assuming 144 byte branch length) and ~2.5 gas per byte in the worst case if an attacker fills the tree with keys deliberately computed to maximize proof length.", "Backwards Compatibility": "The main backwards-compatibility-breaking changes are:", "Test Cases": "TODO", "Reference Implementation": "Needs discussion.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6888, "url": "https://eips.ethereum.org/EIPS/eip-6888", "title": "Arithmetic verification at EVM level", "authors": ["Renan Rodrigues de Souza\u00a0(", "@RenanSouza2", ")"], "sections": {"EIP-6888: Arithmetic verification at EVM level": "This EIP adds arithmetics checks to EVM arithmetic and a new opcode jump conditionally if there were events. The list of check includes overflows, division by zero.", "Check for math overflows and division by zero at EVM level": "This EIP adds arithmetics checks to EVM arithmetic and a new opcode jump conditionally if there were events. The list of check includes overflows, division by zero.", "Abstract": "This EIP adds arithmetics checks to EVM arithmetic and a new opcode jump conditionally if there were events. The list of check includes overflows, division by zero.", "Motivation": "The importance of math checks in smart contract projects is very clear. It was an OpenZeppelin library and then incorporated in Solidity\u2019s default behavior. Bringing this to EVM level can combine both gas efficiency and safety.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Constants": "Two new flags are added to the EVM state: unsigned warning (carry) and signed warning (overflow). The scope of those flags are the same as the program counter.", "Flags": "Two new flags are added to the EVM state: unsigned warning (carry) and signed warning (overflow). The scope of those flags are the same as the program counter.", "Definitions": "From this point forwarda,bandcreferences the arguments in a math operation andresthe output.cis only used if the operation takes 3 inputs.", "Contidions": "Thecarryflag MUST be set in the following circumstances:", "Opcodes": "Consumes one argument from the stack, the possible pc dest,\nConditionally alter the program counter depending on thecarryflag.J_JUMPC = carry ? \u00b5_s[0] : \u00b5_pc + 1Clears both flags.carry = overflow = false", "gas": "The gas cost for both instructions isG_high, the same asJUMPI.", "Rationale": "EVM uses two\u2019s complement for negative numbers. The opcodes listed above triggers one or two flags depending if they are used for signed and unsigned numbers.", "Backwards Compatibility": "This EIP introduces a new opcode and changes int EVM behavior.", "Test Cases": "TBD", "Reference Implementation": "TBD", "Security Considerations": "This is a new EVM behavior but each code will decide how to interact with it.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7495, "url": "https://eips.ethereum.org/EIPS/eip-7495", "title": "SSZ StableContainer", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Cayman\u00a0(", "@wemeetagain", ")"], "sections": {"EIP-7495: SSZ StableContainer": "This EIP introduces two newSimple Serialize (SSZ) typesto enable forward-compatible containers.", "New SSZ type to represent a flexible container with stable serialization and merkleization": "This EIP introduces two newSimple Serialize (SSZ) typesto enable forward-compatible containers.", "Abstract": "This EIP introduces two newSimple Serialize (SSZ) typesto enable forward-compatible containers.", "Motivation": "Stable containers and profiles are currently not representable in SSZ. Adding support provides these benefits:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "StableContainer[N]": "Similar to the regularSSZContainer,StableContainer[N]defines an ordered heterogeneous collection of fields.Nindicates the potential maximum number of fields to which it can ever grow in the future.NMUST be> 0.", "Profile[B]": "Profile[B]also defines an ordered heterogeneous collection of fields, a subset of fields of a baseStableContainertypeBwith the following constraints:", "Rationale": "Current SSZ types are only stable within one version of a specification, i.e., one fork of Ethereum. This is alright for messages pertaining to a specific fork, such as attestations or beacon blocks. However, it is a limitation for messages that are expected to remain valid across forks, such as transactions or receipts. In order to support evolving the features of such perpetually valid message types, a new SSZ scheme needs to be defined. Furthermore, consumers of Merkle proofs may have a different software update cadence as Ethereum; an implementation should not break just because a new fork introduces unrelated new features.", "What are the problems solved byStableContainer[N]?": "Current SSZ types are only stable within one version of a specification, i.e., one fork of Ethereum. This is alright for messages pertaining to a specific fork, such as attestations or beacon blocks. However, it is a limitation for messages that are expected to remain valid across forks, such as transactions or receipts. In order to support evolving the features of such perpetually valid message types, a new SSZ scheme needs to be defined. Furthermore, consumers of Merkle proofs may have a different software update cadence as Ethereum; an implementation should not break just because a new fork introduces unrelated new features.", "What are the problems solved byProfile[B]?": "The forward-compatible merkleization ofStableContainermay be desirable even in situations where only a single sub-type is valid at any given time, e.g., as determined by the fork schedule. In such situations, message size can be reduced and type safety increased by exchangingProfile[B]instead of the underlying base type. This can be useful, e.g., for consensus data structures such asBeaconState, to ensure that Merkle proofs for its fields remain compatible across forks.", "Why notUnion[T, U, V]?": "There is combinatorial complexity when new optional features are introduced. For example, if there are three transaction types, and then priority fees are introduced as an optional feature, one has to define three additional transaction types to allow inclusion of a priority fee, raising the total to six transaction types. If, subsequently, optional access lists are introduced, that doubles again, to twelve transaction types.", "Why not modelOptional[T]as an SSZ type?": "IfOptional[T]is modeled as an SSZ type, each individual field introduces serialization and merkleization overhead. As anOptional[T]would be required to be\u201cvariable-size\u201d, lots of additional offset bytes would have to be used in the serialization. For merkleization, each individualOptional[T]would require mixing in a bit to indicate presence or absence of the value.", "Backwards Compatibility": "StableContainer[N]andProfile[B]are new SSZ types and, therefore, do not conflict with other SSZ types currently in use.", "Test Cases": "SeeEIP assets.", "Reference Implementation": "SeeEIP assets, based onprotolambda/remerkleable.", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- optional access lists: Introduces a transaction type that includes an access list specifying addresses and storage keys the transaction plans to access, reducing gas costs for state access.\n- ssz stablecontainer: Introduces StableContainer[N] to create flexible, forward-compatible containers with stable serialization and merkleization. It also introduces Profile[B] to support specialized subtypes of StableContainer.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7503, "url": "https://eips.ethereum.org/EIPS/eip-7503", "title": "Zero-Knowledge Wormholes", "authors": ["Keyvan Kambakhsh\u00a0(", "@keyvank", ")", "Hamid Bateni\u00a0(", "@irnb", ")", "Amir Kahoori\u00a0<", "a.kahoorizadeh@gmail.com", ">", "Nobitex Labs\u00a0<", "labs@nobitex.ir", ">", "0xwormhole\u00a0(", "@0xwormhole", ")"], "sections": {"EIP-7503: Zero-Knowledge Wormholes": "While researching on privacy solutions and applications of ZKP, we discovered a technique, \nby which people can burn their digital asset (E.g ETH) by sending it to an unspendable address, \nand later build a ZK proof showing that some amount of tokens reside in an account that are \nunspendable, without revealing the account.", "Enable minting of secretly burnt Ethers as a native privacy solution for Ethereum": "While researching on privacy solutions and applications of ZKP, we discovered a technique, \nby which people can burn their digital asset (E.g ETH) by sending it to an unspendable address, \nand later build a ZK proof showing that some amount of tokens reside in an account that are \nunspendable, without revealing the account.", "Abstract": "While researching on privacy solutions and applications of ZKP, we discovered a technique, \nby which people can burn their digital asset (E.g ETH) by sending it to an unspendable address, \nand later build a ZK proof showing that some amount of tokens reside in an account that are \nunspendable, without revealing the account.", "Specification": "We define a newEIP-2718transaction type, whereTransactionTypeisWormholeTxTypeand theTransactionPayloadformat is as follows:", "Parameters": "We define a newEIP-2718transaction type, whereTransactionTypeisWormholeTxTypeand theTransactionPayloadformat is as follows:", "Rationale": "In Elliptic-Curve based digital signatures, normally there is a secret scalar $s$, from which \na public-key is calculated (By multiplying the generator point with the scalar: $s \\times G$). An \nEthereum EOA-address is the keccak hash of a public-key.", "Scalability Implications": "In case the circuits are able to simultaneously re-mint the sum of multiple burns in a single-proof, \nmerchants and CEXs will be able to accept their payments in burn-addresses and accumulate their funds\nin a single address by storing a single proof (And a bunch of nullifiers) on the blockchain, which\nsignificantly reduces the transaction count on the blockchain. The people who will use this EIP as a\nscalability solution, will also increase the privacy guarantees of the protocol.", "Backwards Compatibility": "The Ethers generated using the mint function should not have any difference with original Ethers.\nPeople should be able to use those minted Ethers for paying the gas fees.", "Reference Implementation": "To be determined (TBD).", "ZK-SNARK Implementation": "Also TBD, but the implementation must meet the following conditions:", "Security Considerations": "In case of faulty implementation of this EIP, people may mint infinite amount of ETH, collapsing the price of Ethereum.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- zero-knowledge wormholes: Proposes a minting function to re-mint Ethers that have been secretly burned, enabling privacy-preserving transfers using ZK proofs without smart contract interactions.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7519, "url": "https://eips.ethereum.org/EIPS/eip-7519", "title": "Atomic Storage Operations SCREDIT and SDEBIT", "authors": ["Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-7519: Atomic Storage Operations SCREDIT and SDEBIT": "Two new opcodes that atomically mutate smart contract storage are proposed:\nSCREDIT, which increments a storage slot by a specified value, and SDEBIT, which\ndecrements a storage slot by a specified value. Overflow and underflow errors\nare enforced, reverting when an unsigned 256-bit integer would overflow or\nunderflow.", "Add atomic operations for incrementing and decrementing storage slots": "Two new opcodes that atomically mutate smart contract storage are proposed:\nSCREDIT, which increments a storage slot by a specified value, and SDEBIT, which\ndecrements a storage slot by a specified value. Overflow and underflow errors\nare enforced, reverting when an unsigned 256-bit integer would overflow or\nunderflow.", "Abstract": "Two new opcodes that atomically mutate smart contract storage are proposed:\nSCREDIT, which increments a storage slot by a specified value, and SDEBIT, which\ndecrements a storage slot by a specified value. Overflow and underflow errors\nare enforced, reverting when an unsigned 256-bit integer would overflow or\nunderflow.", "Motivation": "There has been a large amount of energy around parallel EVMs across multiple\nchains, however there is a lack of parallel primitives within the EVM to support\nany model other than optimistic concurrency control (OCC). By adding concurrent\nincrement and decrement operations more advanced parallel environments can be\nintroduced in Layer 2 networks.", "Specification": "Two operations to atomically increment and decrement a storage will be\nintroduced\nat0xTBD. Each operation takes two stack arguments and has no immediate\narguments. Gas schedule will be the same as SSTORE.", "SCREDIT": "SCREDIT: slot, value", "SDEBIT": "SDEBIT: slot, value", "Rationale": "The primary consideration when choosing between alternatives is that the primary\nintended audiences is token contracts and other asset-tracking contracts\ncombined with a desire to ship the minimum necessary changes to enable that use\ncase. General concurrency controls is not a goal of this EIP.", "Enforcing Overflow Semantics": "When allowing for out-of-order execution there needs to be mechanism to handle\nany possible order of execution. OCC handles this by validating pre- and\npost-conditions, and re-evaluating the transactions if those invariants did not\nhold. This technique breaks down around writing to balances and counters.", "Gas Schedule": "The decision to cost the operations at the exact same value as SSTORE is partly\nfor ease of implementation and partly as an incentive to compilers and\ndevelopers.", "Storage Slots Only": "This most important use case for this EIP asset balances and not general\nconcurrency controls. Hence, only enabling credit and debit operations on\nstorage slots (which persist across transactions). Parallel execution within a\ntransaction and more generic tools like locks and semaphores have very limited\nutility within this scope. The lack of in-transaction parallel execution also\nprecludes the use of such primitives against transient storage (as defined inEIP-1153).", "Opcode Instead of System Contract": "One alternative, particularly viable for Layer 2 chains, would be to implement\nSCREDIT and SDEBIT as system contracts. The primary objection to system\ncontracts for other operations is the gas cost overhead of constructing a call.\nBecause a SSTORE is always greater than the cost of a call it would be possible\nto build in a discount. However, there is no such accommodation that can be made\nfor the code size needed to invoke such a call.", "Backwards Compatibility": "These opcodes are not simple replacements for SLOAD-(ADD|SUB)-SSTORE sequence\nbecause there is an overflow/underflow check", "Test Cases": "Test for overflow and non-overflow for the following values and values before\nand after:", "Reference Implementation": "/# TBD", "Security Considerations": "The use of revert to handle over/underflow represents a new halt condition that\nauditors will need to consider when examining reentrancy concerns.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7557, "url": "https://eips.ethereum.org/EIPS/eip-7557", "title": "Block-level Warming with fair cost savings", "authors": ["Yoav Weiss\u00a0(", "@yoavw", ")", "Alex Forshtat\u00a0(", "@forshtat", ")", "Dror Tirosh\u00a0(", "@drortirosh", ")", "Shahaf Nacson\u00a0(", "@shahafn", ")"], "sections": {"EIP-7557: Block-level Warming with fair cost savings": "A mechanism for a fair distribution of the gas costs associated with access to addresses and storage slots\namong multiple transactions with shared items in theiraccessList.", "Block-level warming of addresses and slots with access lists": "A mechanism for a fair distribution of the gas costs associated with access to addresses and storage slots\namong multiple transactions with shared items in theiraccessList.", "Abstract": "A mechanism for a fair distribution of the gas costs associated with access to addresses and storage slots\namong multiple transactions with shared items in theiraccessList.", "Motivation": "EIP-2929: Gas cost increases for state access opcodesintroduced a new gas cost model that differentiates\nbetween \u201ccold\u201d and \u201cwarm\u201d access to accounts and storage slots.", "Specification": "TheEIP-2930: Optional access listsalready introduced the first part of the solution.\nEach transaction can specify an array ofaccessed_addressesandaccessed_storage_keysto announce its intention to\nread those values during the execution of the transaction.", "Overview": "During the transaction execution, the cost of all storage-related operations is not affected,\nand all rules from EIP-2929 and EIP-2930 continue to apply.", "Participant transactions mapping": "After the block builder finalizes the contents of the block, it iterates over all included transactions to read\ntheaccessListcomponent of each supported transaction.", "Calculating a reimbursement of the burned base fee": "Considering that the same amount of computation is needed to access an address or a slot regardless of the number of\ntransactions using one, it is reasonable for the protocol to only burn the gas cost of the cold access once.\nAs all transactions in the same block pay exactly the samebaseFeePerGas, the single cost of accessing a cold item is\ndivided evenly among all transactions containing such access and the rest of the burned base fee is reimbursed.", "Setting an absolute minimal cost of cold state access": "If a large number of transactions all access the same addresses or slots, the cost of each cold access may get\nway too low which may represent a potential DoS attack vector.", "Calculating a reimbursement of the charged priority fee": "Each transaction pays an individualpriorityFeePerGasvalue and redistributing this part of the cold access cost\nis more complex.", "Efficiently storing the access lists in the block history": "The contents of theaccessListparameter are part of the Ethereum history and the potential cost of keeping this\ndata in the blockchain must be accounted for when implementing this change.\nThere is currently no additional charge applied to theaccessListparameter, due to the cost of including\nan address or a storage slot in theaccessListbeing a constant value that is significantly higher than the\npotential cost of storing theaccessListat the cost of  a\ndynamically sizedcalldatafield.", "Pseudocode implementation of the reimbursement calculation algorithm": "Note that two accumulating values,reimbursementFromBurnandreimbursementFromCoinbase,\nare necessary in light ofEIP-1559: Fee market change for ETH 1.0 chainin order to differentiate\nbetween the Ether reimbursement that is originating from a reduced block gas burn,\nand from the reduced block proposer priority fee per gas reward.", "Future EIP-6800 gas reform support": "OnceEIP-6800is active, the cost of accessing a contract code for a cold address is expected to change.", "Cost redistribution system operation": "TheEIP-4895: Beacon chain push withdrawals as operationssets a precedent by introducing a concept of asystem-level withdrawal operation.", "Rationale": "As described in theMotivationsection, the amount of gas that users spend on accessing the contract code does not reflect the actual cost of this access for the block builder or a validator.", "Current cold storage gas cost is unfair": "As described in theMotivationsection, the amount of gas that users spend on accessing the contract code does not reflect the actual cost of this access for the block builder or a validator.", "Issuing a regular gas refund after a transaction is not possible": "There exists a list of EVM instructions that trigger both a gas charge and a gas refund.\nA notable example of such operations is the0x55 SSTOREopcode as defined inEIP-1283: Net gas metering for SSTORE without dirty maps.\nIntuitively it seems reasonable to issue the gas reimbursements for the shared cold storage access in the same fashion.", "Weighting priority fee reimbursement": "A common game-theoretical answer to the problem of calculating a fair redistribution of the payoff of the\nresults of the participants\u2019 cooperation is the use of Shapley values.", "Backwards Compatibility": "This proposal does not introduce a change to any behavior that can be observed by a smart contract during its execution.\nThe only effect this change has is a lower effective gas cost for the transaction senders.", "Security Considerations": "The upper limit of storage reads in one block is not affected by this change as the gas charge is done with the\nfull cost ofCOLD_ACCOUNT_ACCESS_COSTorCOLD_SLOAD_COST.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- net gas metering for sstore: Updates the gas cost for the SSTORE opcode based on the original, current, and new storage values, improving efficiency for contracts with frequent storage updates.\n- fee market change for eth 1.0 chain: Proposes a new transaction pricing mechanism with a base fee per gas, dynamically adjusting based on network congestion, and burned. Aims to reduce volatility, improve efficiency, and prevent miner manipulation of fees.\n- gas cost increases for state access opcodes: Increases the gas cost for SLOAD, *CALL, BALANCE, and EXT* opcodes on first access in a transaction, to address underpriced operations."}
{"eip": 7612, "url": "https://eips.ethereum.org/EIPS/eip-7612", "title": "Verkle state transition via an overlay tree", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")", "Ignacio Hagopian\u00a0(", "@jsign", ")", "Gottfried Herold\u00a0(", "@GottfriedHerold", ")", "Jamie Lokier\u00a0(", "@jlokier", ")", "Tanishq Jasoria\u00a0(", "@tanishqjasoria", ")", "Parithosh Jayanthi\u00a0(", "@parithosh", ")", "Gabriel Rocheleau\u00a0(", "@gabrocheleau", ")", "Karim Taam\u00a0(", "@matkt", ")"], "sections": {"EIP-7612: Verkle state transition via an overlay tree": "This EIP proposes a method to switch the state tree tree format from hexary Merkle Patricia Tree (MPT) to a Verkle Tree (VKT): the MPT tree is frozen, and new writes to the state are stored in a VKT \u201claid over\u201d the hexary MPT. The historical MPT state is left untouched and its eventual migration is handled at a later time.", "Describes the use of an overlay tree to use the verkle tree structure, while leaving the historical state untouched.": "This EIP proposes a method to switch the state tree tree format from hexary Merkle Patricia Tree (MPT) to a Verkle Tree (VKT): the MPT tree is frozen, and new writes to the state are stored in a VKT \u201claid over\u201d the hexary MPT. The historical MPT state is left untouched and its eventual migration is handled at a later time.", "Abstract": "This EIP proposes a method to switch the state tree tree format from hexary Merkle Patricia Tree (MPT) to a Verkle Tree (VKT): the MPT tree is frozen, and new writes to the state are stored in a VKT \u201claid over\u201d the hexary MPT. The historical MPT state is left untouched and its eventual migration is handled at a later time.", "Motivation": "The Ethereum state is growing, and VKTs offer a good mitigation strategy to stem this growth and enable weak statelessness. Owing to the difficulty of translating contracts with large storage while they are being accessed, proposals for migrating the current MPT state are complex and will require client teams to undergo a long process of refactoring their code to handle this conversion.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Constants": "In the execution spec, modify theStateclass as such:", "Helper functions": "In the execution spec, modify theStateclass as such:", "Changes to the execution spec": "In the execution spec, modify theStateclass as such:", "Changes to the block header": "AtFORK_TIMEthe block header state root is changed from the MPT root to the VKT root.", "Rationale": "This approach doesn\u2019t convert the state, which is left to a subsequent EIP. This is meant as a stopgap in case we decide to push the conversion itself to a later time. It has the advantage of simplicity, which means that the Verge fork could happen at the same time as other, simpler EIPs. It also requires no change at the consensus layer.", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "Needs discussion.", "Reference Implementation": "Needs discussion.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7688, "url": "https://eips.ethereum.org/EIPS/eip-7688", "title": "Forward compatible consensus data structures", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Cayman\u00a0(", "@wemeetagain", ")"], "sections": {"EIP-7688: Forward compatible consensus data structures": "This EIP defines the changes needed to adoptStableContainerfromEIP-7495in consensus data structures.", "Transition consensus SSZ data structures to StableContainer": "This EIP defines the changes needed to adoptStableContainerfromEIP-7495in consensus data structures.", "Abstract": "This EIP defines the changes needed to adoptStableContainerfromEIP-7495in consensus data structures.", "Motivation": "Ethereum\u2019s consensus data structures make heavy use ofSimple Serialize (SSZ)Container, which defines how they are serialized and merkleized. The merkleization scheme allows application implementations to verify that individual fields (and partial fields) have not been tampered with. This is useful, for example, in smart contracts of decentralized staking pools that wish to verify that participating validators have not been slashed.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Conversion procedure": "For each converted data structure, a new fork agnosticStableContainertypeBis introduced that serves as the primary definition of each data structure.", "Immutable types": "These types are used as part of theStableContainerdefinitions, and, as they are notStableContainerthemselves, are considered to have immutable Merkleization. If a future fork requires changing these types in an incompatible way, a new type SHALL be defined and assigned a new field name.", "StableContainercapacities": "Maximum proof depth:", "Fork-agnosticStableContainerdefinitions": "These type definitions are fork independent and shared across all forks. They are not exchanged over libp2p.", "Fork-specificProfiledefinitions": "The consensus type definitions specific to the fork that introduces this EIP are updated to inherit the Merkleization of theStableContainerdefinitions. Fields are kept as is.", "Rationale": "Applying this EIP breakshash_tree_rootand Merkle tree verifiers a single time, while promising forward compatibility from the fork going forward. It is best to apply it before merkleization would be broken by different changes. Merkleization is broken by aContainerreaching a new power of 2 in its number of fields.", "Best timing?": "Applying this EIP breakshash_tree_rootand Merkle tree verifiers a single time, while promising forward compatibility from the fork going forward. It is best to apply it before merkleization would be broken by different changes. Merkleization is broken by aContainerreaching a new power of 2 in its number of fields.", "Can this be applied retroactively?": "WhileProfileserializes in the same way as the legacyContainer, the merkleization andhash_tree_rootof affected data structures changes. Therefore, verifiers that wish to process Merkle proofs of legacy variants still need to support the corresponding legacy schemes.", "Immutability": "Once a field in aStableContainerhas been published, its name can no longer be used to represent a different type in the future. This includes list types with a higher capacity than originally intended. This is in line with historical management of certain cases:", "Backwards Compatibility": "Existing Merkle proof verifiers need to be updated to support the new Merkle tree shape. This includes verifiers in smart contracts on different blockchains and verifiers in hardware wallets, if applicable.", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- forward compatible consensus data structures: Transitions consensus SSZ data structures to StableContainer, enabling forward compatibility for verifiers and decentralized staking pools.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- stablecontainer: A container that stores data in a single SSZ format, forward compatible across forks."}
{"eip": 7701, "url": "https://eips.ethereum.org/EIPS/eip-7701", "title": "Native Account Abstraction with EOF", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Yoav Weiss\u00a0(", "@yoavw", ")", "Alex Forshtat\u00a0(", "@forshtat", ")", "Dror Tirosh\u00a0(", "@drortirosh", ")", "Shahaf Nacson\u00a0(", "@shahafn", ")"], "sections": {"EIP-7701: Native Account Abstraction with EOF": "We propose splitting the Ethereum transaction scope into multiple steps: validations, execution, and post-operation logic. Transaction validity is determined by the result of the validation steps of a transaction.", "Native Account Abstraction protocol, relying on EOF code sections, new transaction type and a family of opcodes": "We propose splitting the Ethereum transaction scope into multiple steps: validations, execution, and post-operation logic. Transaction validity is determined by the result of the validation steps of a transaction.", "Abstract": "We propose splitting the Ethereum transaction scope into multiple steps: validations, execution, and post-operation logic. Transaction validity is determined by the result of the validation steps of a transaction.", "Motivation": "Native Account Abstraction allows custom validation logic of a transaction and custom gas payment logic, opening new use-cases and features for wallets and dApps.", "Specification": "A newEIP-2718transaction with typeAA_TX_TYPEis introduced.\nTransactions of this type are referred to as \u201cAA transactions\u201d.", "Constants": "A newEIP-2718transaction with typeAA_TX_TYPEis introduced.\nTransactions of this type are referred to as \u201cAA transactions\u201d.", "New Transaction Type": "A newEIP-2718transaction with typeAA_TX_TYPEis introduced.\nTransactions of this type are referred to as \u201cAA transactions\u201d.", "Definitions": "The base gas cost of this transaction is set toAA_BASE_GAS_COSTinstead of 21000 to reflect the lack of \u201cintrinsic\u201d\nECDSA signature verification.", "System-level code entry points": "Modify the EOF container format, by adding the fieldskind_entry_pointsandentry_points_sizeto the container header, and adding a sectionentry_points_sectionto the container body.", "Validation and PostOp code entry points": "We define the following as a validentry_point_rolevalues:", "Non-EOF Proxy Contract Support": "We want to support legacy proxy contracts upgrading to add EIP-7701 support.", "Execution entry point for Sender, Paymaster and Deployer": "During a regular contract code execution, its behaviour is defined as follows by EIP-3540:", "NewTXPARAMLOAD,TXPARAMSIZE, andTXPARAMCOPYopcodes": "Accessing transaction details within call frames is performed using the newTXPARAM*opcode family.\nThe instructions are followed by an 8-bit immediate value, which we calln, and can have a value of 0 to 255.", "Limitations onTXPARAM*opcodes": "TheexecutionStatusandexecutionGasCostparameters are only accessible in therole_paymaster_post_opsection.", "TXPARAM*opcodes gas prices": "The new opcodes have gas prices equivalent to correspondingCALLDATA*opcodes:", "Transaction Execution Flow": "All legacy transaction types only have an implicit validation phase where balance, nonce, and signature are checked,\nand an implicit execution phase with a single top-level execution frame.", "Transaction execution context": "Note that some behaviours in the EVM depend on the transaction context. These behaviours include:", "Costs of accessing cold addresses for Sender, Paymaster and Deployer": "The Sender address is pre-warmed as part of theAA_BASE_GAS_COST.", "Flow diagrams": "", "Pseudocode": "The validation section of a Smart Contract Account code needs to have full access to the majority of transaction\ndetails in order to be able to make an informed decision about either accepting or rejecting the transaction.", "Rationale": "The validation section of a Smart Contract Account code needs to have full access to the majority of transaction\ndetails in order to be able to make an informed decision about either accepting or rejecting the transaction.", "Introduction of theTXPARAM*opcode family": "The validation section of a Smart Contract Account code needs to have full access to the majority of transaction\ndetails in order to be able to make an informed decision about either accepting or rejecting the transaction.", "Backwards Compatibility": "An EOF contract withkind_entry_pointssection is not valid according to EIP-3540 and cannot exist on-chain\nbefore this proposal is implemented.", "Security Considerations": "As thekind_entry_pointscode sections represent a generic way to authorize any action on behalf of the contract,\ncorrect and secure implementation of this code is critical.\nWe expect that compilers targeting EVM will play a major role in enabling and ensuring Smart Contract Accounts\u2019 security.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- native account abstraction with eof: Proposes a variant of native account abstraction relying on EOF, separating validation and execution code sections for smart contract accounts.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170."}
{"eip": 7703, "url": "https://eips.ethereum.org/EIPS/eip-7703", "title": "Increase calldata cost", "authors": ["William Morriss\u00a0(", "@wjmelements", ")"], "sections": {"EIP-7703: Increase calldata cost": "An adjustment in the Ethereum calldata cost which reduces the maximum possible block size and allows a higher block gas limit.", "Increase calldata cost to decrease the maximum block size": "An adjustment in the Ethereum calldata cost which reduces the maximum possible block size and allows a higher block gas limit.", "Abstract": "An adjustment in the Ethereum calldata cost which reduces the maximum possible block size and allows a higher block gas limit.", "Motivation": "Larger blocks take longer to propagate through the network. \nIn this way, the maximum potential block size is constraining the block gas limit.\nTherefore, in order to safely increase the block gas limit, the calldata gas must be increased.", "Specification": "Tripling the gas cost of calldata reduces the maximum possible block size by a factor of three.", "Rationale": "Tripling the gas cost of calldata reduces the maximum possible block size by a factor of three.", "Backwards Compatibility": "Activation can cause some transactions to revert due to the increased gas costs.\nAhead of activation,eth_estimateGascould be calculated using the new parameters in order to provide results viable for activation, avoiding out-of-gas reverts.", "Security Considerations": "No security issues have been found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- increase calldata cost: Increases the gas cost for calldata to reduce the maximum possible block size and allow for a higher block gas limit.\n- revert: All calls to this opcode must emit a log with revert data.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170."}
{"eip": 7709, "url": "https://eips.ethereum.org/EIPS/eip-7709", "title": "Read BLOCKHASH from storage and update cost", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Tomasz Stanczak\u00a0(", "@tkstanczak", ")", "Guillaume Ballet\u00a0(", "@gballet", ")", "Gajinder Singh\u00a0(", "@g11tech", ")", "Tanishq Jasoria\u00a0(", "@tanishqjasoria", ")", "Ignacio Hagopian\u00a0(", "@jsign", ")", "Jochem Brouwer\u00a0(", "@jochem-brouwer", ")", "Gabriel Rocheleau\u00a0(", "@gabrocheleau", ")"], "sections": {"EIP-7709: Read BLOCKHASH from storage and update cost": "Update theBLOCKHASH (0x40)opcode to read and serve from the system contract storage and charge theadditional(cold or warm) storage costs.", "Read the `BLOCKHASH (0x40)` opcode from the EIP-2935 system contract storage and adjust its gas cost to reflect storage access.": "Update theBLOCKHASH (0x40)opcode to read and serve from the system contract storage and charge theadditional(cold or warm) storage costs.", "Abstract": "Update theBLOCKHASH (0x40)opcode to read and serve from the system contract storage and charge theadditional(cold or warm) storage costs.", "Motivation": "TheBLOCKHASH (0x40)opcode currently assumes that the client has knowledge of the previous blocks, which in VerkleEIP-6800would prevent stateless execution. However withEIP-2935blockhashes can be retrieved and served from its system contract storage which allows Verkle blocks to include a storage access witness for stateless execution.", "Specification": "TheBLOCKHASHopcode semantics remains the same as before. From thefork_block(defined asfork_block.timestamp >= FORK_TIMESTAMP and fork_block.parent.timestamp < FORK_TIMESTAMP), theBLOCKHASHinstruction should be updated to resolve block hash in the following manner:", "Activation": "This EIP specifies the transition to the new logic assuming thatEIP-2935has been activated:", "Gas costs": "As described above, if theargto be resolved is within the correct window, the correspondingSLOADcharges and accesses are to be applied for the slotarg % HISTORY_SERVE_WINDOW. Note that theHISTORY_SERVE_WINDOWandBLOCKHASH_SERVE_WINDOWare different.", "Reading from the System contract": "Even if the clients choose to resolveBLOCKHASHthrough system call toEIP-2935contract, the gas cost for the system code execution (and also the code witnesses if Verkle activated) is not applied. Only the effect ofSLOADis applied as described above.", "Rationale": "Note thatBLOCKHASHopcode only serves a limitedBLOCKHASH_SERVE_WINDOWto be backward compatible (and to not extend the above exemptions). For deeper accesses one will need to directly callEIP-2935system contract which will lead to a normal contract execution (as well as charges and accesses)", "Backwards Compatibility": "This EIP introduces a significant increase in the cost ofBLOCKHASH, which could break use-cases that rely on the previous gas cost. Also, this EIP introduces a breaking change in the case where less thanBLOCKHASH_SERVE_WINDOWelapse between theEIP-2935fork and this EIP\u2019s fork (unlessEIP-2935is activated in genesis for e.g. in testnets/devnets) as theEIP-2935system contract would not have saved the required history.", "Test Cases": "No security considerations other than the ones contained inEIP-2935are determined as of now.", "Security Considerations": "No security considerations other than the ones contained inEIP-2935are determined as of now.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- read blockhash from storage: Modifies the BLOCKHASH opcode to retrieve the block hash from storage, adjusting its gas cost to reflect the storage access.\n- genesis: Log entry in system_logs for initial balances at network genesis .\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding."}
{"eip": 7732, "url": "https://eips.ethereum.org/EIPS/eip-7732", "title": "Enshrined Proposer-Builder Separation", "authors": ["Francesco D'Amato\u00a0<", "francesco.damato@ethereum.org", ">", "Barnab\u00e9 Monnot\u00a0<", "barnabe.monnot@ethereum.org", ">", "Michael Neuder\u00a0<", "michael.neuder@ethereum.org", ">", "Potuz\u00a0(", "@potuz", ")", "Terence Tsao\u00a0<", "ttsao@offchainlabs.com", ">"], "sections": {"EIP-7732: Enshrined Proposer-Builder Separation": "This EIP fundamentally changes the way an Ethereum block is validated by decoupling the execution validation from the consensus validation both logically as well as temporally. It does so by introducing a new optional attribution (being abuilder) and a new duty (submittingpayload timeliness attestations) to Ethereum validators. TheExecutionPayloadfield of theBeaconBlockBodyis removed and instead it is replaced by a signed commitment (aSignedExecutionPayloadHeaderobject) from a builder to later reveal the corresponding execution payload. This commitment specifies in particular the blockhash of the execution block and avalueto be paid to the beacon block proposer. When processing theBeaconBlock, the committed value is deducted from the builder\u2019s beacon chain balance and credited to the beacon block proposer. A subset of validators in the beacon committee is assigned to thePayload Timeliness Committee(PTC), these validators are tasked to attest (by broadcasting aPayloadAttestationMessage) to whether the corresponding builder has revealed the committed execution payload (with the right blockhash) in a timely fashion. PTC members are not required to validate the execution payload, execution validation is thus deferred until the next beacon block validation.", "Separates the ethereum block in consensus and execution parts, adds a mechanism for the consensus proposer to choose the execution proposer.": "This EIP fundamentally changes the way an Ethereum block is validated by decoupling the execution validation from the consensus validation both logically as well as temporally. It does so by introducing a new optional attribution (being abuilder) and a new duty (submittingpayload timeliness attestations) to Ethereum validators. TheExecutionPayloadfield of theBeaconBlockBodyis removed and instead it is replaced by a signed commitment (aSignedExecutionPayloadHeaderobject) from a builder to later reveal the corresponding execution payload. This commitment specifies in particular the blockhash of the execution block and avalueto be paid to the beacon block proposer. When processing theBeaconBlock, the committed value is deducted from the builder\u2019s beacon chain balance and credited to the beacon block proposer. A subset of validators in the beacon committee is assigned to thePayload Timeliness Committee(PTC), these validators are tasked to attest (by broadcasting aPayloadAttestationMessage) to whether the corresponding builder has revealed the committed execution payload (with the right blockhash) in a timely fashion. PTC members are not required to validate the execution payload, execution validation is thus deferred until the next beacon block validation.", "Abstract": "This EIP fundamentally changes the way an Ethereum block is validated by decoupling the execution validation from the consensus validation both logically as well as temporally. It does so by introducing a new optional attribution (being abuilder) and a new duty (submittingpayload timeliness attestations) to Ethereum validators. TheExecutionPayloadfield of theBeaconBlockBodyis removed and instead it is replaced by a signed commitment (aSignedExecutionPayloadHeaderobject) from a builder to later reveal the corresponding execution payload. This commitment specifies in particular the blockhash of the execution block and avalueto be paid to the beacon block proposer. When processing theBeaconBlock, the committed value is deducted from the builder\u2019s beacon chain balance and credited to the beacon block proposer. A subset of validators in the beacon committee is assigned to thePayload Timeliness Committee(PTC), these validators are tasked to attest (by broadcasting aPayloadAttestationMessage) to whether the corresponding builder has revealed the committed execution payload (with the right blockhash) in a timely fashion. PTC members are not required to validate the execution payload, execution validation is thus deferred until the next beacon block validation.", "Motivation": "This EIP solves a different set of unrelated important problems.", "Specification": "No changes are required.", "Execution Layer": "No changes are required.", "Consensus Layer": "The full consensus changes can be found in the consensus-specs Github repository. They are split between:", "Engine API": "No changes needed.", "Rationale": "Being a builder is a new attribution of validators. As such builders are staked in the beacon chain. This allows for in-protocol trustless enforcement of the builder\u2019s payment to the proposer. Alternatively, payment could be enforced in the Execution Layer (EL) at the cost of adding the corresponding EL consensus-changing logic. Payments in the EL have the advantage of not requiring the builder to periodically submit deposit transactions to replenish their validator balance. Both systems require availability of funds before the payload is revealed: in the Consensus Layer (CL) this is done by getting builders to stake. In the EL this is done with a balance check and a payment transaction. This transaction can be checked without executing the payload only if it the first transaction of the block.", "Staked builders": "Being a builder is a new attribution of validators. As such builders are staked in the beacon chain. This allows for in-protocol trustless enforcement of the builder\u2019s payment to the proposer. Alternatively, payment could be enforced in the Execution Layer (EL) at the cost of adding the corresponding EL consensus-changing logic. Payments in the EL have the advantage of not requiring the builder to periodically submit deposit transactions to replenish their validator balance. Both systems require availability of funds before the payload is revealed: in the Consensus Layer (CL) this is done by getting builders to stake. In the EL this is done with a balance check and a payment transaction. This transaction can be checked without executing the payload only if it the first transaction of the block.", "Delayed validation": "The Payload Timeliness Committee members do not need to validate the execution payload before attesting to it. They perform basic checks such as verifying the builder\u2019s signature, and the correct blockhash is included. This takes away the full execution payload validation from the hot path of validation of an Ethereum block, giving the next proposer 6 seconds (SECONDS_PER_SLOT * 2 // INTERVALS_PER_SLOT) to validate the payload and every other validator 9 seconds (SECONDS_PER_SLOT * 3 // INTERVALS_PER_SLOT). From a user UX perspective, a transaction included in slotNby the builder is not widely validated until the proposer of slotN+1releases their beacon block on top of blockNfirst and the attesters of slotN+1vote on this beacon block as the head of the chain.", "(Block, Slot, Payload) - Fork choice": "The following features of fork choice are guaranteed under specified margins of security:", "Builder timeliness boosts": "When a builder reveals an expected payload and the PTC achieved consensus that it was timely, that is, when at leastPAYLOAD_TIMELY_THRESHOLDvotes have been received forPAYLOAD_PRESENT, the forkchoice node containing the full slot (that is the consensus block together with its payload present) receives a boost equivalent to 40% of the beacon committee.", "PTC equivocations": "There is no penalty for PTC nor payload equivocation (that is revealing the right payload and also a withheld message at the same time). A collusion of a builder controlling network partition with a single malicious PTC member could cause a split view by achieving consensus both on payload withheld and a payload present. This could be mitigated by settingPAYLOAD_TIMELY_THRESHOLDto be 2/3 of the PTC, in which case the malicious operator would have to control at least 33% of the PTC.", "Withdrawals": "Withdrawals from the beacon chain are complex in nature, they involve removing funds from one layer and crediting them on another, with different trigger mechanisms that can start from either layer. Before applying the consensus layer state transition function to a given beacon statepre_stateand processing a given signed beacon blockblock, the set of withdrawals that are expected to be deducted from the beacon chain are completely determined bypre_state. Previous to this EIP the set of withdrawals that are credited on the execution layer are included inblock. The block is deemed invalid if these withdrawals do not match. With the separation included in this EIP, these operations of deducting and crediting become asynchronous:", "Three state transition functions": "The current EIP adds an extra state transition function to the block processing in Ethereum. Processing aSignedBeaconBlockchanges the consensus layerBeaconState. ASignedExecutionPayloadEnvelopechanges both the execution layer state and the consensus layer one. As such, the envelope commits to the consensus layer post-state-transition beacon state root.", "Compatible designs": "This EIP is fully compatible with forward inclusion lists as specified inEIP-7547or similar.", "Backwards Compatibility": "This EIP introduces backward incompatible changes to the block validation rule set on the consensus layer and must be accompanied by a hard fork.", "Security Considerations": "PROPOSER_SCORE_BOOSTis reduced from 40 to 20. This does not allow however a ex-ante reorg by a proposer with 20% of the total stake as the attacker\u2019s payload will also not be included. Proposers are protected against1-slot sandwichreorgs by a colluding set of validators and builders controlling more than 20% of the total stake.", "Reorg resistance": "PROPOSER_SCORE_BOOSTis reduced from 40 to 20. This does not allow however a ex-ante reorg by a proposer with 20% of the total stake as the attacker\u2019s payload will also not be included. Proposers are protected against1-slot sandwichreorgs by a colluding set of validators and builders controlling more than 20% of the total stake.", "Builder safety": "The expected time for a malicious attacker, controlling 35% of the total stake, to have a majority control on the PTC is 205 000 years.", "Malicious PTC": "The expected time for a malicious attacker, controlling 35% of the total stake, to have a majority control on the PTC is 205 000 years.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- inclusion lists: Introduces a mechanism allowing proposers to specify transactions that must be included in subsequent blocks, improving censorship resistance.\n- enshrined proposer-builder separation: Decouples the execution and consensus parts of an Ethereum block by allowing the proposer to delegate block construction to a builder, adding new validation mechanisms like Payload Timeliness Committees."}
{"eip": 7745, "url": "https://eips.ethereum.org/EIPS/eip-7745", "title": "Light client and DHT friendly log index", "authors": ["Zsolt Felf\u00f6ldi\u00a0(", "@zsfelfoldi", ")"], "sections": {"EIP-7745: Light client and DHT friendly log index": "Replace the fixed 2048 bit log event bloom filters in block headers with a new data structure that can adapt to the changing number of events per block and consistently guarantee a sufficiently low false positive ratio.", "An efficient, light client and DHT friendly replacement for block header bloom filters": "Replace the fixed 2048 bit log event bloom filters in block headers with a new data structure that can adapt to the changing number of events per block and consistently guarantee a sufficiently low false positive ratio.", "Abstract": "Replace the fixed 2048 bit log event bloom filters in block headers with a new data structure that can adapt to the changing number of events per block and consistently guarantee a sufficiently low false positive ratio.", "Motivation": "Adding logs has a significantly lower gas cost and should accordingly be less resource consuming than writing to the state. The original design of bloom filters in each block achieves this goal as there is no complex data structure like the state to update, the set of logs emitted in each block is all contained within the header and receipts belonging to that block. Logs mostly just have long term storage costs. On the other hand, searching logs in a long range of blocks is very expensive.", "Specification": "Beginning at the execution timestampFORK_TIMESTAMP, execution clients MUST replace thelogs_bloomfield of the header schema withlog_index_rootwhich is the root hash of theLogIndexstructure after adding the logs emitted in the given block.", "Terms and definitions": "Beginning at the execution timestampFORK_TIMESTAMP, execution clients MUST replace thelogs_bloomfield of the header schema withlog_index_rootwhich is the root hash of theLogIndexstructure after adding the logs emitted in the given block.", "Consensus data format": "Beginning at the execution timestampFORK_TIMESTAMP, execution clients MUST replace thelogs_bloomfield of the header schema withlog_index_rootwhich is the root hash of theLogIndexstructure after adding the logs emitted in the given block.", "Constructing the filter map": "For eachVALUES_PER_MAPlong section of thelog value indexspace afilter mapis generated. These are fixed sizeMAP_WIDTHbyMAP_HEIGHTsparse bit maps and eachlog valueis marked on the map with a single bit being set to one. Block delimiters are not marked on the map but otherwise the density of the maps are close to constant. The number of marks in a row (the length of the sparse encoded row) is referred to as \u201crow length\u201d, not to be confused with the constantMAP_WIDTH.", "Design goals": "The proposed data structure is intended to represent a balance between the cost of adding items and accessing old ones. Thefilter mapshave a fixed tree shape, making in-memory maintenance, Merkle hashing and DHT distribution easy to implement. Filter entries are sorted into rows based on content and position in a way that allows quick linear database access and size efficient Merkle proofs. The difficulties arising from certain types of events being much more frequent than others are also mitigated.", "Epochs and mapping layers": "In order to allow efficient search of a certainlog valuein a long historical range,filter mapsare organized into epochs, each consisting of a fixedMAPS_PER_EPOCHnumber of maps. In the most usual case (when row density is around average or below) row mapping stays the same  during an entire epoch. The database and the hash tree both should be organized in a way that instead of putting all rows of a single map close to each other, rows of the same _row index_throughout an entire epoch are close to each other and therefore are cheap to access and/or prove with a Merkle proof.", "Row mapping": "While base layer row mapping stays the same for an entire epoch, higher layer mappings are changed more frequently. Each mapping change has a cost in terms of database access overhead and Merkle proof size overhead and epoch size is determined in a way that these overheads stay sufficiently low compared to the cost of accessing the actual useful data. On higher layers where the rows are longer, a more frequent remapping is possible because the useful data size per map is also higher. It is also desirable so that a less frequentlog valuewill only suffer from colliding with longer rows for a shorter time.", "Column mapping": "Column mapping assumes thatMAP_WIDTHis a multiple ofVALUES_PER_MAP.column indexis calculated as follows:", "Initialization and minimal state": "A Merkle tree updated with strictly monotonically increasing keys can be initialized with a Merkle branch of the next leaf to be added. If the keys are non-strictly monotonical (the same leaf can be updated multiple times) then the previous leaf value itself is also needed. In case ofLogIndexMinimalStateepochs are strictly monotinically added. Thelog_entriestrees are also strictly monotinical while theMAPS_PER_EPOCHsized subtrees belonging to eachrow indexare non-strictly monotonically updated.", "Rationale": "In each block a varying number oflog valuesare emitted. In addition to inefficient search, another drawback of per-block fixed size bloom filters is the varying filter utilization leading to over-utilized filters giving many false positives in some blocks and/or wastefully under-utilized filters in some blocks. Block gas limits also tend to change significantly over the long term so any future-proof solution has to be able to adapt to the varying number oflog valuesper block.", "Log value index space": "In each block a varying number oflog valuesare emitted. In addition to inefficient search, another drawback of per-block fixed size bloom filters is the varying filter utilization leading to over-utilized filters giving many false positives in some blocks and/or wastefully under-utilized filters in some blocks. Block gas limits also tend to change significantly over the long term so any future-proof solution has to be able to adapt to the varying number oflog valuesper block.", "Log entries tree": "Hashing entire logs along with position info into a tree greatly simplifies the remote proving/verifying process. There is no need to separately prove the canonicalness of block headers and the receipts referenced in them, everything can be proven with Merkle proof of a singleLogIndexstructure and theBlockDelimiterMetabelonging to the same block number if the block hash is needed.", "Alternative filter structures considered": "In a search structure of a constantly growing dataset there is typically a tradeoff between the cost of adding new data and the cost of searcing the existing dataset. One extreme is just linearly storing the data, which is practically the case now with logs, with the bloom filters being mostly useless. The other extreme is one big Merkle tree with alllog valuesever used as keys and the list of all occurences (possibly in a further merkleized format) as values. With billions of uniquelog values, adding new entries here is expected to have costs similar to that of the state, with multiple lookups and modifications/insertions at random places in a database on the order of magnitude of hundreds of gigabytes. Another issue where this is similar to the state is that removing old entries is hard and expensive. Adding logs is supposed to be cheaper than writing the state so solutions between these two extremes were considered as potentially practical, with multiple smaller structures generated periodically.", "False positive rate": "From thefilter mapsa set of potential matches can be derived for any block range andlog valueor pattern oflog values. These matches can then be looked up in the correspondinglog_entriestrees and actually matching logs can be added to the set of results. The design guarantees that the set of potential matches includes all actual matches but and also has a consistent rate of random false positive rate.", "Backwards Compatibility": "The existing log filter API (eth_getLogs,eth_newFilter,eth_getFilterLogs,eth_getFilterChanges) can be implemented with the new filter data structure. Applications relying on this API can operate without any change, with a higher performance. Repricing theLOGopcode might be considered after performing benchmarks but the extra processing cost is not significant while the extra storage cost is around 15%. Other than that the EVM is not affected in any way as it only emits logs but does not directly access them.", "Security Considerations": "In order to prove a complete set of matches matching a given search pattern in a given block range, the prover needs to", "Safe access with a remote prover": "In order to prove a complete set of matches matching a given search pattern in a given block range, the prover needs to", "Deliberate false positive attacks": "The design guarantees that false positive rates do even out statistically over several epochs, even in case of random collisions with very frequent values, ensuring that an excessive amount false positives will not make the bandwidth and processing costs of the search prohibitively high. All of this is true for random collisions only though, not deliberately created collisions. A deliberate attack on a certain importantlog valuein order to raise its false positive rate can not be ruled out entirely since with a low amount of filter data generated perlog valueit is always possible to \u201cmine\u201d another value that generates colliding filter data. The column mapping used here makes this attack a lot harder though, since thecolumn indexdepends on both thelog valueand the exactlog value index, making this attack only possible for block creators who are probably offered MEV rewards for much more lucrative manipulations of the transaction set than making the search of certain log events slightly more expensive.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7748, "url": "https://eips.ethereum.org/EIPS/eip-7748", "title": "State conversion to Verkle Tree", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")", "Ignacio Hagopian\u00a0(", "@jsign", ")", "Gajinder Singh\u00a0(", "@g11tech", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")", "Gottfried Herold\u00a0(", "@GottfriedHerold", ")", "Jamie Lokier\u00a0(", "@jlokier", ")", "Tanishq Jasoria\u00a0(", "@tanishqjasoria", ")", "Parithosh Jayanthi\u00a0(", "@parithosh", ")", "Gabriel Rocheleau\u00a0(", "@gabrocheleau", ")", "Karim Taam\u00a0(", "@matkt", ")"], "sections": {"EIP-7748: State conversion to Verkle Tree": "This EIP proposes a procedure to convert, on each block, a fixed number of key-values from the existing  Merkle Patricia Tree (MPT) to the Verkle Tree (VKT).", "Describes a state conversion procedure to migrate key-values from the Merkle Patricia Tree to the Verkle Tree.": "This EIP proposes a procedure to convert, on each block, a fixed number of key-values from the existing  Merkle Patricia Tree (MPT) to the Verkle Tree (VKT).", "Abstract": "This EIP proposes a procedure to convert, on each block, a fixed number of key-values from the existing  Merkle Patricia Tree (MPT) to the Verkle Tree (VKT).", "Motivation": "The accounts state is too large to wait for transactions to organically move all of them to the VKT through the Overlay Tree. Thus, we need a strategy to convert all the state within a reasonable time. The state conversion completion allows removing the Overlay Tree abstraction introduced inEIP-7612and use directly the VKT for all state access.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Constants": "Aconversion unitis:", "Changes to the execution spec": "Include the following code in the existingapply_body(...)function:", "Rationale": "Performing the conversion step before the block txs execution has some benefits:", "State conversion step position in block execution": "Performing the conversion step before the block txs execution has some benefits:", "CONVERSION_STRIDEproposed value": "Performance benchmarks were done to achieve the right balance between:", "Account code chunking done in a single step": "If an account has code, this is chunked and inserted in the VKT in one go. An alternative is including aCodePhaseand let each inserted chunk consume one unit ofCONVERSION_STRIDE.", "Expected time for the conversion to finish": "TODO: We have an estimation, but it might be worth recalculating it closer to the proposed fork having a more up to date state size estimate.", "Missed slots": "The conversion logic runs at the start of each block, so missed slots don\u2019t create special situations.", "Accounts storage->account-data order": "The proposed order synergizes with many EL client flat-db architectures, minimizing random disk-IO.", "Not countingEIP-161accounts forCONVERSION_STRIDElimit": "TheCONVERSION_STRIDEparameter tries to limit the load of effective writes. These special accounts are skipped since we try to perform a bulkEIP-158deletion of the remaining accounts.", "MPT preimage resolving": "EL clients are expected to satisfy at least one of these conditions:", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "TODO: currently described in an external document.", "Reference Implementation": "Needs discussion.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- state conversion to verkle tree: Describes a procedure to gradually convert key-values from the Merkle Patricia Tree (MPT) to the Verkle Tree, allowing the migration of the Ethereum state in a manageable timeframe.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7775, "url": "https://eips.ethereum.org/EIPS/eip-7775", "title": "BURN opcode", "authors": ["Dev Bear\u00a0(", "@itsdevbear", ")"], "sections": {"EIP-7775: BURN opcode": "This proposal introduces aBURNopcode to the EVM. When called, the opcode is to burn native ether at the address of the current evm context.", "An opcode to burn native ether at the given address": "This proposal introduces aBURNopcode to the EVM. When called, the opcode is to burn native ether at the address of the current evm context.", "Abstract": "This proposal introduces aBURNopcode to the EVM. When called, the opcode is to burn native ether at the address of the current evm context.", "Motivation": "The motivation for this proposal is to provide a standardized and efficient way to burn native ether directly within the EVM. Historically, contracts such as the BeaconDepositContract have \u201cburned\u201d ether by making it irrecoverable from the given address. This approach can lead to confusion and potential misuse. By introducing a dedicatedBURNopcode, we can ensure a clear and consistent method for burning native ether. This could become useful for Ethereum L2s when transferring ether back to the L1, as well as other EVM L1 chains that could leverage this for their cryptoeconomics.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Behaviour": "TheBURNopcode(0xFC)is introduced with the following behavior:", "Gas Cost": "The base gas cost for theBURNopcode is 100 gas. The dynamic gas cost is determined as follows:", "Pseudocode": "Example pseudocode for theBURNopcode:", "Rationale": "The introduction of theBURNopcode helps clean up a piece of weird semantics in the Ethereum. Historically, burning native ether involved sending them to an address from which they could not be recovered, such as the zero address or a contract with no withdrawal functionality. This method is not only inefficient but also confusing for indexers and other tools that track token movements. By providing a dedicatedBURNopcode, we eliminate this ambiguity and ensure that the act of burning tokens is explicit and standardized.", "Backwards Compatibility": "This EIP introduces a new opcode and thus must be activated via a scheduled hardfork.", "Test Cases": "Needs discussion.", "Reference Implementation": "Needs discussion.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- withdrawal: Log entry in system_logs for tracking withdrawals under EIP-4895 .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7778, "url": "https://eips.ethereum.org/EIPS/eip-7778", "title": "Prevent Block Gas Smuggling", "authors": ["Ben Adams\u00a0(", "@benaadams", ")"], "sections": {"EIP-7778: Prevent Block Gas Smuggling": "Prevent the circumvention of the block gas limit by excluding certain gas discounts and refunds from block gas accounting, except for those reflecting actual reductions in computational work.", "Exclude Discounts & Refunds for Block GasLimit Enforcement": "Prevent the circumvention of the block gas limit by excluding certain gas discounts and refunds from block gas accounting, except for those reflecting actual reductions in computational work.", "Abstract": "This EIP modifies the gas accounting mechanism to prevent block gas smuggling \u2014 situations where transactions include more gas-consuming operations than the block gas limit intends due to gas discounts and refunds.", "Motivation": "WithEIP-7623for transactions, the gas used (tx.gasUsed) is calculated as:", "Preventing Block Gas Smuggling": "Copyright and related rights waived via CC0 1.0 Universal.", "Complementing EIP-7623": "Copyright and related rights waived via CC0 1.0 Universal.", "Specification": "WithEIP-7623for transactions, the gas used (tx.gasUsed) is calculated as:", "Gas Cost Adjustments": "WithEIP-7623for transactions, the gas used (tx.gasUsed) is calculated as:", "Transaction Gas Calculation (Adjusted)": "WithEIP-7623for transactions, the gas used (tx.gasUsed) is calculated as:", "Block Gas Limit Enforcement": "Copyright and related rights waived via CC0 1.0 Universal.", "Implementation": "Copyright and related rights waived via CC0 1.0 Universal.", "Rationale": "Copyright and related rights waived via CC0 1.0 Universal.", "Backwards Compatibility": "Copyright and related rights waived via CC0 1.0 Universal.", "Test Cases": "Copyright and related rights waived via CC0 1.0 Universal.", "Security Considerations": "Copyright and related rights waived via CC0 1.0 Universal.", "Copyright": "Copyright and related rights waived via CC0 1.0 Universal.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- prevent block gas smuggling: Modifies gas accounting to exclude discounts and refunds from block gas calculations, ensuring block gas usage aligns with the actual workload.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7782, "url": "https://eips.ethereum.org/EIPS/eip-7782", "title": "Reduce Slot Time for Lower Peak Bandwidth", "authors": ["Ben Adams\u00a0(", "@benaadams", ")"], "sections": {"EIP-7782: Reduce Slot Time for Lower Peak Bandwidth": "Propose reducing Ethereum\u2019s slot time from 12 seconds to 8 seconds to increase transaction throughput by one-third. This approach distributes bandwidth usage over time, lowering peak bandwidth requirements without increasing individual block or blob counts. It requiresEIP-7623andEIP-7778to ensure network stability and efficiency with the higher block rate.", "Reduce Ethereum's slot time from 12s to 8s to increase throughput by ~33%, distribute bandwidth usage, and improve rollup latency.": "Propose reducing Ethereum\u2019s slot time from 12 seconds to 8 seconds to increase transaction throughput by one-third. This approach distributes bandwidth usage over time, lowering peak bandwidth requirements without increasing individual block or blob counts. It requiresEIP-7623andEIP-7778to ensure network stability and efficiency with the higher block rate.", "Abstract": "This EIP suggests decreasing the slot time in Ethereum\u2019s Proof-of-Stake (PoS) consensus mechanism from 12 seconds to 8 seconds. The reduction increases the number of slots per unit time, boosting the network\u2019s transaction processing capacity by approximately 33%.", "Motivation": "Copyright and related rights waived via CC0 1.0 Universal.", "Distributing Bandwidth and Reducing Peak Usage": "Copyright and related rights waived via CC0 1.0 Universal.", "Complementing EIP-7623": "Copyright and related rights waived via CC0 1.0 Universal.", "Specification": "Copyright and related rights waived via CC0 1.0 Universal.", "Slot Time Reduction": "Copyright and related rights waived via CC0 1.0 Universal.", "Adjustments to Timing Parameters": "Copyright and related rights waived via CC0 1.0 Universal.", "Validator Operations": "Copyright and related rights waived via CC0 1.0 Universal.", "Rationale": "Copyright and related rights waived via CC0 1.0 Universal.", "Based Rollup Latency": "Copyright and related rights waived via CC0 1.0 Universal.", "Throughput Increase Without Raising Peak Bandwidth": "Copyright and related rights waived via CC0 1.0 Universal.", "Validator Capability": "Copyright and related rights waived via CC0 1.0 Universal.", "Alternative to Increasing Block Size or Blob Count": "Copyright and related rights waived via CC0 1.0 Universal.", "Backwards Compatibility": "Copyright and related rights waived via CC0 1.0 Universal.", "Test Cases": "Copyright and related rights waived via CC0 1.0 Universal.", "Network Propagation Considerations": "Copyright and related rights waived via CC0 1.0 Universal.", "Consensus Adjustments": "Copyright and related rights waived via CC0 1.0 Universal.", "Implementation": "Copyright and related rights waived via CC0 1.0 Universal.", "Security Considerations": "Copyright and related rights waived via CC0 1.0 Universal.", "Copyright": "Copyright and related rights waived via CC0 1.0 Universal.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- reduce slot time for lower peak bandwidth: Proposes reducing Ethereum's slot time from 12 seconds to 8 seconds, increasing throughput by ~33% and improving bandwidth distribution.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7788, "url": "https://eips.ethereum.org/EIPS/eip-7788", "title": "Dynamic target blob count", "authors": ["Marc Harvey-Hill\u00a0(", "@Marchhill", ")"], "sections": {"EIP-7788: Dynamic target blob count": "This EIP proposes to make the target blob count adjust dynamically up to a safe maximum target. This adjustment will target a constant price in ETH for blobs, aiming for consistent costs of L2 transactions.", "Target blob count changes dynamically to aim for constant blob costs": "This EIP proposes to make the target blob count adjust dynamically up to a safe maximum target. This adjustment will target a constant price in ETH for blobs, aiming for consistent costs of L2 transactions.", "Abstract": "This EIP proposes to make the target blob count adjust dynamically up to a safe maximum target. This adjustment will target a constant price in ETH for blobs, aiming for consistent costs of L2 transactions.", "Motivation": "Ethereum currently uses a target of 50% capacity for blob count, withEIP-1559smoothing out short term spikes and pushing average throughput towards the target. A dynamic target is orthogonal to EIP-1559, tweaking the target itself over a longer timescale to aim for some desired blob cost.", "Specification": "The target blob count changes each epoch based on the mean blob cost over the previous epoch. If the average cost exceeds the desired amount beyond some margin then the target is increased; likewise if it is below the desired amount by some margin the target will decrease. The target can increase up toMAX_TARGET_BLOB_COUNT, which is deemed to be a safe average throughput for the network, and down to a minimum ofMIN_TARGET_BLOB_COUNT.", "Parameters": "The target blob count changes each epoch based on the mean blob cost over the previous epoch. If the average cost exceeds the desired amount beyond some margin then the target is increased; likewise if it is below the desired amount by some margin the target will decrease. The target can increase up toMAX_TARGET_BLOB_COUNT, which is deemed to be a safe average throughput for the network, and down to a minimum ofMIN_TARGET_BLOB_COUNT.", "Dynamic targeting": "The target blob count changes each epoch based on the mean blob cost over the previous epoch. If the average cost exceeds the desired amount beyond some margin then the target is increased; likewise if it is below the desired amount by some margin the target will decrease. The target can increase up toMAX_TARGET_BLOB_COUNT, which is deemed to be a safe average throughput for the network, and down to a minimum ofMIN_TARGET_BLOB_COUNT.", "Engine API change": "The Engine API is extended to provide themean_blob_costfor the current epoch when the CL requests it from the EL. The CL requests this at the end of an epoch to set the target for the next epoch (depends onEIP-7742).", "Rationale": "A constant blob cost target can keep L2 transaction costs affordable for end users. Volatility in the price of ETH would affect affordability, but is unlikely to be significant compared to normal fluctuations in blob gas costs due to spikes in activity. In future the costs could be adjusted in the case of changes in the order of magnitude of ETH price.", "Constant blob cost target": "A constant blob cost target can keep L2 transaction costs affordable for end users. Volatility in the price of ETH would affect affordability, but is unlikely to be significant compared to normal fluctuations in blob gas costs due to spikes in activity. In future the costs could be adjusted in the case of changes in the order of magnitude of ETH price.", "Target block gas": "The same logic could be applied to the target block gas, but generally blockspace is in high demand so arguably gas costs are never too low. The target should be set to the maximum average throughput that the network can safely handle, a dynamic target is not necessary.", "Parameter choices": "TARGET_BLOB_COSTis chosen so that the system targets affordable L2 transactions. Assuming that the theoretical compressed size of a simple transfer is 23 bytes, this gives a blobspace cost for L2 transactions of:", "Backwards Compatibility": "N/A", "Test Cases": "N/A", "Reference Implementation": "N/A", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- dynamic target blob count: Adjusts the target blob count dynamically to maintain constant blob costs, aiming to optimize network resources and economic incentives related to blob space utilization, making L2 transactions costs predictable and stable.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7791, "url": "https://eips.ethereum.org/EIPS/eip-7791", "title": "GAS2ETH opcode", "authors": ["Charles Cooper\u00a0(", "@charles-cooper", ")", "Pascal Caversaccio\u00a0(", "@pcaversaccio", ")"], "sections": {"EIP-7791: GAS2ETH opcode": "This EIP introduces a newGAS2ETHopcode that enables the direct conversion of gas into ether (ETH).", "Introduces a new opcode, `GAS2ETH`, to convert gas to ETH": "This EIP introduces a newGAS2ETHopcode that enables the direct conversion of gas into ether (ETH).", "Abstract": "This EIP introduces a newGAS2ETHopcode that enables the direct conversion of gas into ether (ETH).", "Motivation": "This EIP is based on the premise that smart contract authors, compiler teams and public goods projects in general should be compensated for their contributions.\nMoreover, their compensation should scale with the usage of their contracts.\nA widely used and popular contract offers significant value to its users through its functionality and to the network by driving demand for blockspace \u2014 Ethereum\u2019sraison d\u2019\u00eatre.\nThis increased demand also benefits miners and validators, who are rewarded for executing these contracts.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Gas cost": "The proposed cost of this opcode is identical to the recently proposedPAYopcode.", "Rationale": "No backward compatibility issues found.", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "TBD", "Reference Implementation": "TBD", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7792, "url": "https://eips.ethereum.org/EIPS/eip-7792", "title": "Verifiable logs", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Gajinder Singh\u00a0(", "@g11tech", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-7792: Verifiable logs": "This EIP defines a method to make theeth_getLogsJSON-RPC response verifiable.", "Scheme to make the eth_getLogs response verifiable": "This EIP defines a method to make theeth_getLogsJSON-RPC response verifiable.", "Abstract": "This EIP defines a method to make theeth_getLogsJSON-RPC response verifiable.", "Motivation": "Theeth_getLogsendpoint is used by wallets to obtain the transaction history pertaining to an account or a topic. To verify correctness and completeness of the logs, a wallet would also have to obtain all block headers and check against their logs bloom. However, that mechanism is inefficient due to its high false positive rate and also involves an unpractical amount of network round trips. This EIP defines a replacement mechanism to efficiently and incrementally verify correctness and completeness ofeth_getLogsresponses.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Configuration": "After executing all transactions of a block, commitments of all emitted logs are accumulated into the storage ofLOG_CONTRACT_ADDRESS. The contract has no code, and its storage layout consists of three slots of typemapping. However to preventEIP-158cleanup, the contract\u2019s nonce is set to1at the first write.", "Log accumulation": "After executing all transactions of a block, commitments of all emitted logs are accumulated into the storage ofLOG_CONTRACT_ADDRESS. The contract has no code, and its storage layout consists of three slots of typemapping. However to preventEIP-158cleanup, the contract\u2019s nonce is set to1at the first write.", "JSON-RPC API": "Theeth_getLogsresponse format is extended to include:", "Verification": "Foreth_getLogs(address, topics, fromBlock, toBlock), the response data can be verified for correctness and completion by obtaining:", "Rationale": "Making theeth_getLogsresponse verifiable adds the necessary security attributes to enable wallets to transition away from relying on trusted data providers, ultimately improving the wallet\u2019s privacy guarantees as it is no longer subject to the privacy policy of any given provider.", "Gas cost": "The gas cost produced by this scheme is significantly higher than whatLOG#opcodes produce as of Prague, primarily due to the additionalSLOAD/SSTORErequirement and the double cost ofSHA256opcodes compared toKECCAK256opcodes. The gas cost increases outweigh the savings from dropping logs blooms.", "Block number / transaction index in meta instead of hashes": "As long as the accumulators are stored in the state trie, they cannot refer to the block hash as the block hash hashes over the state trie, producing a cyclic dependency. If an external system is used, hashes may be included as in that scenario the state root is not affected by the IVC.", "Backwards Compatibility": "It is still possible to processeth_getLogsresponses from trusted servers as is, without verifying them. Client applications with strict response validation may need to be updated to allow the additionalblockTimestampfield.", "Security Considerations": "This scheme reuses existingeth_getProofand SSZ Merkle proofs; it does not introduce new security risks.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- eth_getproof: Adds a new RPC method to return account and storage values along with Merkle proofs, allowing offline verification of account and storage data.\n- verifiable logs: Introduces a scheme to make the eth_getLogs response verifiable, enhancing the security and reliability of log information used by applications, by verifying log entries against accumulative commitments stored in a dedicated contract.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding."}
{"eip": 7793, "url": "https://eips.ethereum.org/EIPS/eip-7793", "title": "TXINDEX precompile", "authors": ["Marc Harvey-Hill\u00a0(", "@Marchhill", ")", "Ahmad Bitar\u00a0(", "@smartprogrammer93", ")"], "sections": {"EIP-7793: TXINDEX precompile": "This EIP proposes to add a new precompile that returns the index of the transaction being executed within the current block.", "Precompile to get index of transaction within block": "This EIP proposes to add a new precompile that returns the index of the transaction being executed within the current block.", "Abstract": "This EIP proposes to add a new precompile that returns the index of the transaction being executed within the current block.", "Motivation": "The new precompile aims to improve support for encrypted mempools. In order to be secure, the validity of encrypted mempool transactions should be tied to the inclusion of all transactions by a proposer in the correct slot, and following the ordering rules. If these rules are not enshrined as block validity conditions then they can be enforced by a smart contract.", "Specification": "Ifblock.timestamp >= TBDa new precompiled contractTXINDEXshall be created at addressTBD.", "Gas Cost": "The gas cost forTXINDEXis a fixed fee of2", "Rationale": "The precompile is priced to match similar opcodes in theW_baseset.", "Gas Price": "The precompile is priced to match similar opcodes in theW_baseset.", "Precompile": "Making the feature a precompile rather than an opcode gives L2s flexibility to decide whether to implement it.", "ZK-VM proving": "The TXINDEX precompile should not increase the complexity of proving EVM execution, as it is similar to existing opcodes such as GAS. If a whole block is proven then no additional inputs to the circuit are required to prove transaction indices, as they can be inferred from the transaction ordering. If a transaction is proved individually then the index must be provided as an input to the circuit, along with the remaining gas for GAS, and more for other introspective opcodes.", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "N/A", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7797, "url": "https://eips.ethereum.org/EIPS/eip-7797", "title": "Double speed for hash_tree_root", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")"], "sections": {"EIP-7797: Double speed for hash_tree_root": "This EIP explains how to customizehash_tree_rootto double its performance.", "Double the performance of hash_tree_root by customizing SHA-256": "This EIP explains how to customizehash_tree_rootto double its performance.", "Abstract": "This EIP explains how to customizehash_tree_rootto double its performance.", "Motivation": "Hashing is a dominant performance bottleneck for Consensus Layer implementations. To support large validator counts, it is critical to optimize hashing performance.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "SHA-256 preprocessing": "Before SHA-256 hash computation begins, the input message is preprocessed. A single1bit is appended to the input message, followed by a varying number of0bits, and finally a big endianuint64indicating the input message bit length. The number of0bits is chosen so that the message size is the smallest possible multiple of 512 bits. In the context ofhash_tree_rootwhere the input message size is 512 bits, preprocessing results in the following padded message:", "SHA-256 blocks": "SHA-256 operates on message blocks of 512 bits. Therefore, in the context ofhash_tree_rootwhere the input message size is 512 bits, two message blocks are formed, the first containing the entire input message, and the second containing entirely static data resulting from the preprocessing step.", "SHA-256-512": "A new algorithm SHA-256-512 is defined as a modified SHA-256 algorithm that skips input message preprocessing and is restricted to inputs of exactly 512 bits. The input message SHALL be processed as is, as a single 512-bit SHA-256 message block.", "Consensus types": "Starting with the hard fork that introduces this EIP, the SHA-256-512 based composite SSZ types SHOULD be preferred over existing SHA-256 based types.", "Rationale": "Doubling the throughput of the underlying hash algorithm allows scaling to more validators on the same hardware, or allows using the freed CPU time for other tasks. Even when caching rarely-changed intermediate hashes across computations such as thevalidatorslist of aBeaconState, and employing hardware-accelerated SHA-256 implementations that are further optimized for the tree structure using libraries such asprysmaticlabs/hashtree, the state root validation step of the Consensus Layer state transition function can still consume ~25% of CPU time (Holesky test network, ~1.7m validators), mostly dominated by frequently changing per-validator structures such as theEpochParticipationFlagslists.", "Backwards Compatibility": "Smart contracts and client applications that verify Consensus Layer data require updates to remain compatible with data hashed using SHA-256-512. New logic may be required to correctly select the hash algorithm for historical structures such asBeaconBlockHeader.", "Security Considerations": "Certain SHA-256-512 hashes of 512 bit data may collide with regular SHA-256 hashes of shorter data. For example:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- sha-256-512: Modified SHA-256 algorithm that skips preprocessing, limited to 512-bit inputs .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7799, "url": "https://eips.ethereum.org/EIPS/eip-7799", "title": "System logs", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Gajinder Singh\u00a0(", "@g11tech", ")"], "sections": {"EIP-7799: System logs": "This EIP defines an extension for eth_getLogs to provide logs for events that are not associated with a given transaction, such as block rewards and withdrawals.", "Per-block logs without associated transactions": "This EIP defines an extension for eth_getLogs to provide logs for events that are not associated with a given transaction, such as block rewards and withdrawals.", "Abstract": "This EIP defines an extension for eth_getLogs to provide logs for events that are not associated with a given transaction, such as block rewards and withdrawals.", "Motivation": "WithEIP-7708wallets gain the ability to use eth_getLogs to track changes to their ETH balance. However, the ETH balance may change without an explicit transaction, through block production and withdrawals. By having such operations emit block-level system logs, eth_Logs provides a complete picture of ETH balance changes.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "System logs list": "A new list is introduced to track all block level logs emitted from system interactions. The definition uses theLogSSZ type fromEIP-6466.", "Priority fee processing": "EIP-1559priority fees SHALL no longer be credited after each individual transaction. Instead, they SHALL be summed up and credited after all transactions of a block are processed but beforeEIP-4895withdrawals are processed.", "Withdrawal processing": "A log SHALL be appended to the system logs list on everyEIP-4895withdrawal.", "Genesis processing": "A log SHALL be appended to the system logs list when generating genesis blocks for networks that adopt this EIP from the beginning.", "Execution block header changes": "Theexecution block headeris extended with a new field,system-logs-root.", "JSON-RPC API": "Block header objects in the context of the JSON-RPC API are extended to include:", "Engine API": "In the engine API, theExecutionPayloadfor versions corresponding to forks adopting this EIP is extended to include:", "ConsensusExecutionPayloadchanges": "The consensusExecutionPayloadtype is extended with a new field to store the system logs root.", "Rationale": "Together withEIP-7708this EIP provides the ability for wallets to compute the exact ETH balance from logs without requiring download of every single block header and all withdrawals.", "Alternatives / Future": "The fee recipient now receives priority fees at the end of the block rather than incrementally after each transaction, making it only possible to spend them in the next block. This may require updates to block builder infrastructure and change liquidity requirements for MEV use cases.", "Backwards Compatibility": "The fee recipient now receives priority fees at the end of the block rather than incrementally after each transaction, making it only possible to spend them in the next block. This may require updates to block builder infrastructure and change liquidity requirements for MEV use cases.", "Security Considerations": "The emitted logs useSYSTEM_ADDRESSas theiraddresswhich cannot conflict with user controlled smart contracts.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- withdrawal: Log entry in system_logs for tracking withdrawals under EIP-4895 .\n- genesis: Log entry in system_logs for initial balances at network genesis .\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785."}
{"eip": 7804, "url": "https://eips.ethereum.org/EIPS/eip-7804", "title": "Withdrawal Credential Update Request", "authors": ["Lucas Saldanha\u00a0(", "@lucassaldanha", ")", "Mikhail Kalinin\u00a0(", "@mkalinin", ")"], "sections": {"EIP-7804: Withdrawal Credential Update Request": "This proposal defines a mechanism to allow validators to update their withdrawal\ncredentials using a new execution request type (0x03). The request allows for\nchanging the execution address and the withdrawal credential prefix (0x01 or 0x02).", "Allow validators to update their withdrawal credentials via execution requests": "This proposal defines a mechanism to allow validators to update their withdrawal\ncredentials using a new execution request type (0x03). The request allows for\nchanging the execution address and the withdrawal credential prefix (0x01 or 0x02).", "Abstract": "This proposal defines a mechanism to allow validators to update their withdrawal\ncredentials using a new execution request type (0x03). The request allows for\nchanging the execution address and the withdrawal credential prefix (0x01 or 0x02).", "Motivation": "When the ability to update a validator BLS withdrawal credentials to execution\naddress was introduced in Capella, one of the most common questions was about\nallowing the withdrawal credential to be changed in the future.\nEither for security (e.g. credential rotation) or to allow for alternative ways\nof handling withdrawals (e.g. having a contract address as credentials).\nThe main reason for not adding this options was because implementing\nthis communication channel between the Execution Layer and the Consensus Layer is\ncomplex (based on the experience with the Eth1 bridge).", "Specification": "The new withdrawal credential update request operation is anEIP-7685request\nwith type0x03and consists of the following fields:", "Constants": "The new withdrawal credential update request operation is anEIP-7685request\nwith type0x03and consists of the following fields:", "Configuration": "The new withdrawal credential update request operation is anEIP-7685request\nwith type0x03and consists of the following fields:", "Execution Layer": "The new withdrawal credential update request operation is anEIP-7685request\nwith type0x03and consists of the following fields:", "Consensus Layer": "Summary of changes:", "Rationale": "Ownership is defined based on control of the withdrawal credential account, either as a private key (for EOA accounts) or controlling\nthe smart contract at the address set as withdrawal credential. Therefore allowing an update should not bring any security implications.", "Backwards Compatibility": "Ownership is defined based on control of the withdrawal credential account, either as a private key (for EOA accounts) or controlling\nthe smart contract at the address set as withdrawal credential. Therefore allowing an update should not bring any security implications.", "Test Cases": "Ownership is defined based on control of the withdrawal credential account, either as a private key (for EOA accounts) or controlling\nthe smart contract at the address set as withdrawal credential. Therefore allowing an update should not bring any security implications.", "Security Considerations": "Ownership is defined based on control of the withdrawal credential account, either as a private key (for EOA accounts) or controlling\nthe smart contract at the address set as withdrawal credential. Therefore allowing an update should not bring any security implications.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- withdrawal: Log entry in system_logs for tracking withdrawals under EIP-4895 .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7805, "url": "https://eips.ethereum.org/EIPS/eip-7805", "title": "Fork-choice enforced Inclusion Lists (FOCIL)", "authors": ["Thomas Thiery (@soispoke)\u00a0<", "thomas.thiery@ethereum.org", ">", "Francesco D'Amato\u00a0<", "francesco.damato@ethereum.org", ">", "Julian Ma\u00a0<", "julian.ma@ethereum.org", ">", "Barnab\u00e9 Monnot\u00a0<", "barnabe.monnot@ethereum.org", ">", "Terence Tsao\u00a0<", "ttsao@offchainlabs.com", ">", "Jacob Kaufmann\u00a0<", "jacob.kaufmann@ethereum.org", ">", "Jihoon Song\u00a0<", "jihoonsong.dev@gmail.com", ">"], "sections": {"EIP-7805: Fork-choice enforced Inclusion Lists (FOCIL)": "FOCIL implements a robust mechanism to preserve Ethereum\u2019s censorship resistance properties by guaranteeing timely transaction inclusion.", "Allow a committee of validators to force-include a set of transactions in every block": "FOCIL implements a robust mechanism to preserve Ethereum\u2019s censorship resistance properties by guaranteeing timely transaction inclusion.", "Abstract": "FOCIL implements a robust mechanism to preserve Ethereum\u2019s censorship resistance properties by guaranteeing timely transaction inclusion.", "Motivation": "In an effort to shield the Ethereum validator set from centralizing forces, the right to build blocks has been auctioned off to specialized entities known asbuilders. This has led to a few sophisticated builders dominating block production, leading to a deterioration of the network\u2019s censorship resistance properties. To address this issue, research has focused on improving Ethereum\u2019s transaction inclusion guarantees by enabling validators to impose constraints on builders. This is achieved by force-including transactions in blocks via ILs.", "High-level Overview": "FOCIL is a committee-based, fork-choice enforced inclusion list (IL) design that improves upon previous IL mechanisms and block co-creation proposals. It addresses issues related to bribing/extortion attacks, IL equivocation, account abstraction (AA), and transaction invalidation.", "Roles And Participants": "This section outlines the workflow of FOCIL, detailing the roles and responsibilities of various participants: IL committee members, validators, builders, proposers and attesters.", "Specification": "On the execution layer, the block validity conditions are extended such that, after all of the transactions in the block have been executed, we attempt to execute each valid transaction from ILs that was not present in the block.\nIf one of those transactions executes successfully, then the block is invalid.", "Execution Layer": "On the execution layer, the block validity conditions are extended such that, after all of the transactions in the block have been executed, we attempt to execute each valid transaction from ILs that was not present in the block.\nIf one of those transactions executes successfully, then the block is invalid.", "Consensus Layer": "The full consensus changes can be found in the following GitHub repository. They are split between:", "Rationale": "This EIP introduces backward incompatible changes to the block validation rule set on the consensus layer and must be accompanied by a hard fork. These changes do not break anything related to current user activity and experience.", "Core Properties": "This EIP introduces backward incompatible changes to the block validation rule set on the consensus layer and must be accompanied by a hard fork. These changes do not break anything related to current user activity and experience.", "Backwards Compatibility": "This EIP introduces backward incompatible changes to the block validation rule set on the consensus layer and must be accompanied by a hard fork. These changes do not break anything related to current user activity and experience.", "Security Considerations": "The builder ofslot N+1cannot construct a canonical block without first receiving the ILs broadcast duringslot N. This means that the builder (including cases in which the proposer locally builds its block) must be well-connected to the IL committee members to ensure timely access to these inclusion lists. Additionally, there must be sufficient time between the view freeze deadline (t=9sofslot N) and the moment the proposer must broadcastblock Bto the rest of the network. This buffer allows the builder to gather all available ILs and update the execution payload ofblock Baccordingly.", "Consensus Liveness": "The builder ofslot N+1cannot construct a canonical block without first receiving the ILs broadcast duringslot N. This means that the builder (including cases in which the proposer locally builds its block) must be well-connected to the IL committee members to ensure timely access to these inclusion lists. Additionally, there must be sufficient time between the view freeze deadline (t=9sofslot N) and the moment the proposer must broadcastblock Bto the rest of the network. This buffer allows the builder to gather all available ILs and update the execution payload ofblock Baccordingly.", "IL Equivocation": "To mitigate IL equivocation, FOCIL introduces a new P2P network rule that allows forwarding up to two ILs per IL committee member. If the proposer or attesters detect two different ILs sent by the same IL committee member, they should ignore all ILs from that member. In the worst case, the bandwidth of the IL gossip subnet can at most double.", "Payload Construction": "The builder, responsible for constructing the execution payload, must ensure that the IL is satisfied. A naive way to do so would be to build an initial payload in whatever way the builder desires, then execute the following algorithm:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- inclusion lists: Introduces a mechanism allowing proposers to specify transactions that must be included in subsequent blocks, improving censorship resistance."}
{"eip": 7807, "url": "https://eips.ethereum.org/EIPS/eip-7807", "title": "SSZ execution blocks", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Gajinder Singh\u00a0(", "@g11tech", ")"], "sections": {"EIP-7807: SSZ execution blocks": "This EIP defines a migration process of execution blocks toSimple Serialize (SSZ).", "Migration of execution blocks to SSZ": "This EIP defines a migration process of execution blocks toSimple Serialize (SSZ).", "Abstract": "This EIP defines a migration process of execution blocks toSimple Serialize (SSZ).", "Motivation": "WithEIP-6404SSZ transactions,EIP-6466SSZ receipts, andEIP-6465SSZ withdrawals, all Merkle-Patricia Trie (MPT) besides the state trie are converted to SSZ. This enables the surrounding data structure, in this case, the execution block itself, to also convert to SSZ, achieving a unified block representation across both Consensus Layer and Execution Layer.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "ExecutionBlockHeadercontainer": "Execution blocks are represented as a single, normalized SSZ container. The definition uses theStableContainer[N]SSZ type andOptional[T]as defined inEIP-7495.", "Requests hash computation": "requests_hashis changed toExecutionRequests.hash_tree_root()using the same structure as in the Consensus LayerBeaconBlockBody.", "Execution block hash computation": "The execution block hash is changed to be based onhash_tree_rootin all contexts, including (1) the BLOCKHASH opcode, (2) engine API interactions (blockHashfield), (3) JSON-RPC API interactions, (4) devp2p networking.", "Rationale": "In the initial draft, only the requests hash and block hash are changed to be SSZhash_tree_root()based. No Consensus Layer changes are required.", "Future": "This breaks compatibility of smart contracts that depend on the previous block header binary format, including for \u201cgeneric\u201d implementations that assume a common prefix and run the entire data through a linear keccak256 hash.", "Backwards Compatibility": "This breaks compatibility of smart contracts that depend on the previous block header binary format, including for \u201cgeneric\u201d implementations that assume a common prefix and run the entire data through a linear keccak256 hash.", "Security Considerations": "The SSZ block hash is based on SHA256 and shares the namespace with existing keccak256 based block hashes. As these hash algorithms are fundamentally different, no significant collision risk is expected.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- devp2p: A networking protocol for Ethereum. EIP-8 introduces forward compatibility requirements for devp2p implementations .\n- ssz transactions: Migrates transaction serialization from RLP to SSZ, aligning the transaction format with consensus and providing extensibility for future transaction features."}
{"eip": 7819, "url": "https://eips.ethereum.org/EIPS/eip-7819", "title": "Create delegate", "authors": ["Hadrien Croubois\u00a0(", "@amxx", ")", "Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-7819: Create delegate": "Introduce a new EVM instruction toEOFthat allows smart contracts to create (and update) delegation accounts that matchEIP-7702\u2019s design. These accounts can be used similarly toERC-1167clones, with significant advantages.", "Add a new EVM instruction allowing contracts to create clones using EIP-7702 delegation designations": "Introduce a new EVM instruction toEOFthat allows smart contracts to create (and update) delegation accounts that matchEIP-7702\u2019s design. These accounts can be used similarly toERC-1167clones, with significant advantages.", "Abstract": "Introduce a new EVM instruction toEOFthat allows smart contracts to create (and update) delegation accounts that matchEIP-7702\u2019s design. These accounts can be used similarly toERC-1167clones, with significant advantages.", "Motivation": "Many on-chain applications involve creating multiple instances of the same code at different locations. These applications often rely on clones, or proxies, to reduce deployment costs.", "Specification": "A new instruction (CREATE_DELEGATE) is added to EOF at0xf6.", "Behavior": "Executing this instruction does the following:", "Parameters": "The execution of theCREATE_DELEGATEinstruction involves fewer moving pieces than what EIP-7702 gas costs account for:", "Rationale": "The execution of theCREATE_DELEGATEinstruction involves fewer moving pieces than what EIP-7702 gas costs account for:", "Gas cost": "The execution of theCREATE_DELEGATEinstruction involves fewer moving pieces than what EIP-7702 gas costs account for:", "Backwards Compatibility": "TODO", "Security Considerations": "Reusing EIP-7702 behavior, including clearing the code if the target is 0, results in the ability to upgrade or even \u201cremove\u201d the created designator. This process is controlled (and can be restricted) by the factory (the contract that callsCREATE_DELEGATE). Some factories will add checks that prevent re-executingCREATE_DELEGATEwith a salt that was already used, making the create designator immutable. Others may allow access-restricted upgrades, but prevent deletion. In any case, guarantees about the lifecycle of the designator created usingCREATE_DELEGATEare provided by the contracts that call it and not by the protocol.", "Delegator upgrades & deletion": "Reusing EIP-7702 behavior, including clearing the code if the target is 0, results in the ability to upgrade or even \u201cremove\u201d the created designator. This process is controlled (and can be restricted) by the factory (the contract that callsCREATE_DELEGATE). Some factories will add checks that prevent re-executingCREATE_DELEGATEwith a salt that was already used, making the create designator immutable. Others may allow access-restricted upgrades, but prevent deletion. In any case, guarantees about the lifecycle of the designator created usingCREATE_DELEGATEare provided by the contracts that call it and not by the protocol.", "Delegator chaining": "As documented in EIP-7702, designator chains or loops are not resolved. This means that, unlike clones, chaining is an issue. This is however something developers are used to, as chaining proxy can result in strange behaviors, including infinite delegation loops.", "Front running initialization": "Unlike EIP-7702 signature, which can be included in any transaction, and can thus lead to initialization front-running if the implementation doesn\u2019t check the authenticity of the initialization parameters,CREATE_DELEGATIONis executed by a smart contract that can execute the initialization logic atomically, just after the delegation is created. This process is well-known to developers that initialize clones and proxies just after creation.", "Multiple delegation changes within a single transaction.": "If a contract performs multipleCREATE_DELEGATEoperations with the same salt but different targets within the same transaction, while doing calls corresponding address, this would have, in the same transaction without reverts, an address that has multiple different codes associated with it, two or more of which are executed. This include the delegation being removed/reset any number of time during the transaction.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create_delegate: A new EVM instruction at 0xf6 allowing contracts to create clones using EIP-7702 delegation designations.\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7825, "url": "https://eips.ethereum.org/EIPS/eip-7825", "title": "Transaction Gas Limit Cap", "authors": ["Giulio Rebuffo\u00a0(", "@Giulio2002", ")"], "sections": {"EIP-7825: Transaction Gas Limit Cap": "This proposal introduces a protocol-level cap on the maximum gas usage per transaction to 30 million gas. By implementing this limit, Ethereum can enhance its resilience against certain DoS vectors, improve network stability, and provide more predictability to transaction processing costs, especially in the context of increasing the Gas Limit.", "Introduce a protocol-level cap on the maximum gas used by a transaction to 30 million.": "This proposal introduces a protocol-level cap on the maximum gas usage per transaction to 30 million gas. By implementing this limit, Ethereum can enhance its resilience against certain DoS vectors, improve network stability, and provide more predictability to transaction processing costs, especially in the context of increasing the Gas Limit.", "Abstract": "This proposal introduces a protocol-level cap on the maximum gas usage per transaction to 30 million gas. By implementing this limit, Ethereum can enhance its resilience against certain DoS vectors, improve network stability, and provide more predictability to transaction processing costs, especially in the context of increasing the Gas Limit.", "Motivation": "Currently, transactions can theoretically consume up to the entire block gas limit, which poses several risks:", "Specification": "The proposed cap of 30 million gas is based on the typical size of Ethereum blocks today, which often range between 30-40 million gas. This value is large enough to allow complex transactions, such as contract deployments and advanced DeFi interactions, while still reserving space for other transactions within a block.", "Gas Cap": "The proposed cap of 30 million gas is based on the typical size of Ethereum blocks today, which often range between 30-40 million gas. This value is large enough to allow complex transactions, such as contract deployments and advanced DeFi interactions, while still reserving space for other transactions within a block.", "Changes to EVM Behavior": "The proposed cap of 30 million gas is based on the typical size of Ethereum blocks today, which often range between 30-40 million gas. This value is large enough to allow complex transactions, such as contract deployments and advanced DeFi interactions, while still reserving space for other transactions within a block.", "Protocol Adjustment": "The proposed cap of 30 million gas is based on the typical size of Ethereum blocks today, which often range between 30-40 million gas. This value is large enough to allow complex transactions, such as contract deployments and advanced DeFi interactions, while still reserving space for other transactions within a block.", "Rationale": "The proposed cap of 30 million gas is based on the typical size of Ethereum blocks today, which often range between 30-40 million gas. This value is large enough to allow complex transactions, such as contract deployments and advanced DeFi interactions, while still reserving space for other transactions within a block.", "Why 30 Million?": "The proposed cap of 30 million gas is based on the typical size of Ethereum blocks today, which often range between 30-40 million gas. This value is large enough to allow complex transactions, such as contract deployments and advanced DeFi interactions, while still reserving space for other transactions within a block.", "Compatibility with Current Gas Dynamics": "This change isnot backward-compatiblewith transactions that specify gas limits exceeding 30 million. Transactions with such high limits will need to be split into smaller operations. This adjustment is expected to impact a minimal number of users and dApps, as most transactions today fall well below the proposed cap.", "Backwards Compatibility": "This change isnot backward-compatiblewith transactions that specify gas limits exceeding 30 million. Transactions with such high limits will need to be split into smaller operations. This adjustment is expected to impact a minimal number of users and dApps, as most transactions today fall well below the proposed cap.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- gas limit cap: Sets an in-protocol cap for the gas limit at 30,000,000, preventing block proposers from increasing the gas limit beyond this threshold.\n- transaction gas limit cap: A protocol-level cap on the maximum gas used by a single transaction, set to 30 million gas. Transactions exceeding this limit are invalidated.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7833, "url": "https://eips.ethereum.org/EIPS/eip-7833", "title": "Scheduled function calls", "authors": ["Keyvan Kambakhsh\u00a0(", "@keyvank", ")", "Nobitex Labs\u00a0<", "labs@nobitex.ir", ">"], "sections": {"EIP-7833: Scheduled function calls": "Ethereum\u2019s smart contracts enable users to delegate control of their funds to code, but these contracts require an external trigger to execute. Timing is often critical, and issues such as network delays or malicious behavior by block producers\u2014like MEV attacks\u2014can prevent timely execution. To address these challenges, this Ethereum Improvement Proposal (EIP) introduces a new opcode, OFFERCALL, which allows contracts to schedule function calls. When functions self-schedule, they exhibit bot-like behavior. These scheduled calls would offer ETH to block producers as an incentive to prioritize their execution over manually submitted transactions. If the offer is not fulfilled, the bot is deactivated until manually re-ignited by the owner. The EIP proposes enforcing the execution of scheduled calls as a requirement for block validity. This could help mitigate MEV attacks, as block producers would be compelled to execute bots that neutralize market manipulation within the blockchain.", "Giving life to smart contracts by enabling their functions to be automatically invoked by block producers.": "Ethereum\u2019s smart contracts enable users to delegate control of their funds to code, but these contracts require an external trigger to execute. Timing is often critical, and issues such as network delays or malicious behavior by block producers\u2014like MEV attacks\u2014can prevent timely execution. To address these challenges, this Ethereum Improvement Proposal (EIP) introduces a new opcode, OFFERCALL, which allows contracts to schedule function calls. When functions self-schedule, they exhibit bot-like behavior. These scheduled calls would offer ETH to block producers as an incentive to prioritize their execution over manually submitted transactions. If the offer is not fulfilled, the bot is deactivated until manually re-ignited by the owner. The EIP proposes enforcing the execution of scheduled calls as a requirement for block validity. This could help mitigate MEV attacks, as block producers would be compelled to execute bots that neutralize market manipulation within the blockchain.", "Abstract": "Ethereum\u2019s smart contracts enable users to delegate control of their funds to code, but these contracts require an external trigger to execute. Timing is often critical, and issues such as network delays or malicious behavior by block producers\u2014like MEV attacks\u2014can prevent timely execution. To address these challenges, this Ethereum Improvement Proposal (EIP) introduces a new opcode, OFFERCALL, which allows contracts to schedule function calls. When functions self-schedule, they exhibit bot-like behavior. These scheduled calls would offer ETH to block producers as an incentive to prioritize their execution over manually submitted transactions. If the offer is not fulfilled, the bot is deactivated until manually re-ignited by the owner. The EIP proposes enforcing the execution of scheduled calls as a requirement for block validity. This could help mitigate MEV attacks, as block producers would be compelled to execute bots that neutralize market manipulation within the blockchain.", "Specification": "Adding bot-like behavior to an EVM function is achieved by recursively scheduling a call to the same function in the next block. We propose introducing a new EVM opcode, OFFERCALL, which, as the name implies, offers ETH to be burnt to the block producer of the next block in exchange for invoking a function. These offers are aggregated and ranked by the Ethereum node, with only the top N offers being retained; all others are discarded. Scheduled calls must be executed before any user transactions, with execution order determined by their rank in the sorted list. The offered ETH is burnt to prevent block producers from exploiting the system by scheduling calls that pay the offered amounts back to themselves.", "Rationale": "The rationale behind this Ethereum Improvement Proposal (EIP) stems from the need to enhance the reliability and fairness of smart contract execution on the Ethereum network. While Ethereum\u2019s smart contracts allow for a high degree of programmability and automation, the execution of these contracts often depends on external triggers, such as user transactions or network conditions. This dependency introduces significant challenges, particularly in situations where timing is critical or when malicious actors, like block producers, can exploit the system for profit.", "Backwards Compatibility": "The introduction of the new OFFERCALL opcode in this EIP requires a network upgrade, as it adds new functionality that is not currently supported by the Ethereum Virtual Machine (EVM). This change will affect how smart contracts can schedule and incentivize the execution of specific function calls, introducing a new mechanism that block producers must accommodate.", "Reference Implementation": "N/A", "Security Considerations": "The main concern with this EIP is whether it could lead to centralization, as wealthier users might dominate execution priorities. Burning unfulfilled offers partly addresses this by preventing endless offers.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- deactivate: Replaces SELFDESTRUCT, keeping the account\u2019s storage and marking the account as deactivated by setting its nonce to 2^64-1, while transferring the balance and leaving the option to reuse the account via CREATE2.\n- offercall: A new EVM opcode that allows contracts to schedule function calls by offering ETH to block producers as an incentive to prioritize their execution. Unfulfilled offers result in the bot's deactivation until manually reignited by the owner. \u200b\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7843, "url": "https://eips.ethereum.org/EIPS/eip-7843", "title": "SLOT precompile", "authors": ["Marc Harvey-Hill\u00a0(", "@Marchhill", ")"], "sections": {"EIP-7843: SLOT precompile": "This EIP proposes to add a new precompile that returns the corresponding slot number for the current block.", "Precompile to get the current slot number": "This EIP proposes to add a new precompile that returns the corresponding slot number for the current block.", "Abstract": "This EIP proposes to add a new precompile that returns the corresponding slot number for the current block.", "Motivation": "It is currently possible to calculate the slot number from the block timestamp. However, this requires hardcoding the chain slot length into a smart contract. This would require the contract code to be changed in the event of a future change to slot length. A better approach is for the slot length to be abstracted away from applications, and instead the slot number can be calculated in the consensus layer client and exposed in a precompile.", "Example application: Encrypted Mempools": "An example of a smart contract that needs the slot number is a validation contract for an encrypted mempool. In order to be secure, the validity of encrypted mempool transactions should be tied to the inclusion of all transactions by a proposer in the correct slot. This rule can be enforced by a smart contract using this precompile.", "Specification": "Ifblock.timestamp >= TBDa new precompiled contractSLOTshall be created at addressTBD.", "Gas Cost": "The gas cost forSLOTis a fixed fee of2.", "RPC changes": "The slot number is calculated in the consensus layer and passed to the execution layer through the engine API.", "Rationale": "The precompile is priced to match similar opcodes in theW_baseset.", "Gas Price": "The precompile is priced to match similar opcodes in theW_baseset.", "Precompile": "Making the feature a precompile rather than an opcode gives L2s flexibility to decide whether to implement it.", "Calculation in consensus layer": "The slot number could alternatively be calculated in the execution layer using the timestamp, but it is more appropriate to calculate values pertaining to the beacon chain in the consensus layer. Additionally this avoids code duplication, as the slot number is already calculated in the consensus layer.", "ZK-VM proving": "The SLOT precompile should not increase the complexity of proving EVM execution, as it is similar to existing opcodes such as TIMESTAMP. The slot number is included in the block header rather than as anew_payloadparameter, ensuring that the block is self-contained for proving; no extra inputs to the circuit are required.", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "N/A", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7848, "url": "https://eips.ethereum.org/EIPS/eip-7848", "title": "On-chain upgrade signaling", "authors": ["William Entriken\u00a0(", "@fulldecent", ")"], "sections": {"EIP-7848: On-chain upgrade signaling": "This proposal adds a mechanism for clients to signal their willingness for a network upgrade by including a \u201creference implementation hash\u201d field in each block. A network upgrade activates only if enough blocks specify that they are using the new software.", "Allows participants to indicate readiness for a client upgrade when producing blocks": "This proposal adds a mechanism for clients to signal their willingness for a network upgrade by including a \u201creference implementation hash\u201d field in each block. A network upgrade activates only if enough blocks specify that they are using the new software.", "Abstract": "This proposal adds a mechanism for clients to signal their willingness for a network upgrade by including a \u201creference implementation hash\u201d field in each block. A network upgrade activates only if enough blocks specify that they are using the new software.", "Motivation": "Currently, upgrades to Ethereum Mainnet are announced on the ethereum.org blog. This proposal changes that process by activating upgrades based on the consent of network participants.", "Specification": "Ethereum consensus clients shall identify with a reference implementation having its equivalent behaviors.", "The Reference Implementation Hash": "When proposing a network upgrade, the proposer shall point to a published, feature-complete reference implementation including the new software behaviors.", "Verification": "Network participants shall study the reference implementation and decide whether they support an upgrade.", "Upgrade": "Upgrade proposals (often referred to as hard fork EIPs) must specify an upgrade window and threshold. These parameters are implemented in the consensus client:", "Rationale": "Since the merge, forking Ethereum Mainnet has become practically impossible. Validators stake valuable assets to participate in the network, so any rational validator will choose to upgrade only if they expect widespread adoption. If a validator expects 95% or more participants to upgrade, they should upgrade; if they expect only 5% or less, they should not. For intermediate cases, there is a threshold where a validator would rationally shut down (incurring a small penalty) rather than risk participating in the wrong network\u2014which could result in slashing 100% of their staked ether (currently 16 Ether per share).", "Forking is no Longer Possible": "Since the merge, forking Ethereum Mainnet has become practically impossible. Validators stake valuable assets to participate in the network, so any rational validator will choose to upgrade only if they expect widespread adoption. If a validator expects 95% or more participants to upgrade, they should upgrade; if they expect only 5% or less, they should not. For intermediate cases, there is a threshold where a validator would rationally shut down (incurring a small penalty) rather than risk participating in the wrong network\u2014which could result in slashing 100% of their staked ether (currently 16 Ether per share).", "Community Direction": "Using a voting window to count votes provides real-time on-chain feedback about upgrade readiness. The upgrade is activated only after the successful completion of the voting window.", "Window": "Using a voting window to count votes provides real-time on-chain feedback about upgrade readiness. The upgrade is activated only after the successful completion of the voting window.", "Backwards Compatibility": "The Ethereum Foundation (Stiftung Ethereum), Zug, Switzerland, owns the trademark \u201cEthereum.\u201d As a result, if anybody publishes a proposed Ethereum Mainnet consensus client, the foundation may have the right to restrict marketing of that software as an \u201cEthereum\u201d client. That also posess unique risks related to securities rules.", "Trademark": "The Ethereum Foundation (Stiftung Ethereum), Zug, Switzerland, owns the trademark \u201cEthereum.\u201d As a result, if anybody publishes a proposed Ethereum Mainnet consensus client, the foundation may have the right to restrict marketing of that software as an \u201cEthereum\u201d client. That also posess unique risks related to securities rules.", "EIP-2124": "EIP-2124 introduces a mechanism to communicate software versions between nodes. However, it does not allow for signaling readiness before an upgrade, nor does it specify what software is being upgraded to.", "Security Considerations": "Any upgrade that achieves less than 100% participation will harm validators who do not participate.", "Copyright": "Copyright and related rights have been waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7851, "url": "https://eips.ethereum.org/EIPS/eip-7851", "title": "Deactivate/Reactivate a Delegated EOA's Key", "authors": ["Liyi Guo\u00a0(", "@colinlyguo", ")"], "sections": {"EIP-7851: Deactivate/Reactivate a Delegated EOA's Key": "This EIP introduces a precompiled contract that enables Externally Owned Accounts (EOAs) with delegated control to smart contracts viaEIP-7702to deactivate or reactivate their private keys. This design does not require additional storage fields or account state changes. By leveraging delegated code, reactivation can be performed securely through mechanisms such as social recovery.", "Introduce a new precompiled contract for EOAs with delegated code to deactivate or reactivate private keys.": "This EIP introduces a precompiled contract that enables Externally Owned Accounts (EOAs) with delegated control to smart contracts viaEIP-7702to deactivate or reactivate their private keys. This design does not require additional storage fields or account state changes. By leveraging delegated code, reactivation can be performed securely through mechanisms such as social recovery.", "Abstract": "This EIP introduces a precompiled contract that enables Externally Owned Accounts (EOAs) with delegated control to smart contracts viaEIP-7702to deactivate or reactivate their private keys. This design does not require additional storage fields or account state changes. By leveraging delegated code, reactivation can be performed securely through mechanisms such as social recovery.", "Motivation": "EIP-7702enables EOAs to gain smart contract capabilities, but the private key of the EOA still retains full control over the account.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Parameters": "The deactivation status is encoded by appending or removing the0x00byte at the end of the delegated code. The transitions between two states are as follows:", "Definitions": "The deactivation status is encoded by appending or removing the0x00byte at the end of the delegated code. The transitions between two states are as follows:", "Delegated Code Encoding": "The deactivation status is encoded by appending or removing the0x00byte at the end of the delegated code. The transitions between two states are as follows:", "Precompiled Contract": "A new precompiled contract is introduced at addressPRECOMPILE_ADDRESS. It costsPRECOMPILE_GAS_COSTand executes the following logic:", "Transaction Validation": "Validation to check whether a private key is deactivated (identified by a code prefix0xef0100and a code length of24) MUST be performed in the following scenarios:", "Rationale": "ThePRECOMPILE_GAS_COSTrepresents the gas required to validate and potentially update an account\u2019s code. A fair cost for calling this precompiled contract can be determined by analyzing its impact on the node:", "Cost of Precompiled Contract": "ThePRECOMPILE_GAS_COSTrepresents the gas required to validate and potentially update an account\u2019s code. A fair cost for calling this precompiled contract can be determined by analyzing its impact on the node:", "Additional Transaction Validation Overhead": "Due toEIP-3607andEIP-7702, nodes already load the account code during transaction validation to verify whether the sender is an EOA (empty code or code with prefix0xef0100). This EIP introduces only a code length check after loading the code, resulting in minimal additional overhead. Similarly,EIP-7702\u2019s authorization validation already involves retrieving the account code, with this EIP adding only a code length check, which is negligible compared to code reading.", "An Alternative EOA Deprecation Approach": "An alternative deprecation approach involves using a hard fork to edit all existing and new EOAs to pre-written upgradeable smart contracts, which utilize the original EOA private key for authorization. Users can add and replace keys, or upgrade the smart contracts to other implementations. However, this approach is incompatible with EOAs already delegated to smart contracts, as it will overwrite the existing smart contract implementations. This EIP aims to fill this migration gap.", "Using a Precompiled Contract": "Alternative methods for deactivating and reactivating EOA private keys include:", "In-Protocol Reactivation": "This approach ensures maximum compatibility with future migrations. EOAs can reactivate their private keys, delegate their accounts to anEIP-7701contract, and then deactivate their private keys again. This avoids the limitations of contract upgrades. e.g., to remove legacy proxy contracts (reducing gas overhead) when upgrading to EOF contracts, one can reactivate the EOA and redelegate it to an EOF proxy contract.", "Avoiding Delegated Code Prefix Modification": "This EIP appends a byte (0x00) to the delegated code instead of modifying the prefix (0xef0100) ofEIP-7702to ensure forward compatibility. If new prefixes such as0xef0101are introduced in the future, changing the prefix to represent the deactivated status (e.g.,0xef01ff) makes it unclear which prefix to restore (0xef0100or0xef0101) upon reactivation.", "Avoiding Account State Changes": "An alternative is to add adeactivatedfield in the account state to track the status. However, this approach will introduce backward compatibility logic and more test vectors related to this optional field when enabling this EIP, because the field is not present in existing accounts.", "Backwards Compatibility": "When the private key is deactivated, this EIP introduces: (i) an extra byte (0x00) to be appended to the end of the delegated code, and (ii) the delegated code length becomes24bytes (e.g.,EXTCODESIZEwould return24).", "Test Cases": "Contracts that have already been deployed and use ECDSAsecp256k1signatures outside of transaction signatures (e.g.,ERC-20tokens that supportERC-2612, thepermitfunction) will not be able to verify the deactivated status of the EOA. This means that signatures signed by private keys will remain valid in these functions.", "Reference Implementation": "Contracts that have already been deployed and use ECDSAsecp256k1signatures outside of transaction signatures (e.g.,ERC-20tokens that supportERC-2612, thepermitfunction) will not be able to verify the deactivated status of the EOA. This means that signatures signed by private keys will remain valid in these functions.", "Security Considerations": "Contracts that have already been deployed and use ECDSAsecp256k1signatures outside of transaction signatures (e.g.,ERC-20tokens that supportERC-2612, thepermitfunction) will not be able to verify the deactivated status of the EOA. This means that signatures signed by private keys will remain valid in these functions.", "Contracts Using ECDSASecp256k1Signatures": "Contracts that have already been deployed and use ECDSAsecp256k1signatures outside of transaction signatures (e.g.,ERC-20tokens that supportERC-2612, thepermitfunction) will not be able to verify the deactivated status of the EOA. This means that signatures signed by private keys will remain valid in these functions.", "Irreversible Deactivation": "Delegating to a wallet that lacks reactivation support (e.g., by calling the precompiled contract through an appropriate interface) may result in irreversible deactivation. To mitigate this risk, users should delegate their EOAs only to thoroughly audited implementations that explicitly support this EIP.", "Deactivation and Reactivation Replay": "Replay attacks can occur in two scenarios: (i) repeating the same authorization on a single chain, or (ii) using the authorization across different chains.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- deactivate: Replaces SELFDESTRUCT, keeping the account\u2019s storage and marking the account as deactivated by setting its nonce to 2^64-1, while transferring the balance and leaving the option to reuse the account via CREATE2.\n- precompile_address: The address of the new precompiled contract for deactivating or reactivating a delegated EOA's private key.\n- precompile_gas_cost: The gas cost for executing the new precompiled contract, tentatively set at 5000."}
{"eip": 7862, "url": "https://eips.ethereum.org/EIPS/eip-7862", "title": "Delayed Execution Layer State Root", "authors": ["Charlie Noyes\u00a0<", "charlie@paradigm.xyz", ">", "Dan Robinson\u00a0<", "dan@paradigm.xyz", ">", "Justin Drake\u00a0<", "justin@ethereum.org", ">", "Toni Wahrst\u00e4tter\u00a0(", "@nerolation", ")"], "sections": {"EIP-7862: Delayed Execution Layer State Root": "This EIP proposes that, for each blockn, thestate_rootin blockn\u2019sExecutionPayloadreferences thepost-state of blockn-1. As a result, blocknno longer needs to compute & include or verify the post state root for blockn. This removes the expensive state root computation from the block-propagation critical path, reducing end-to-end latency for block production and potentially increasing throughput.", "Delays the ExecutionPayload's state root reference by one block.": "This EIP proposes that, for each blockn, thestate_rootin blockn\u2019sExecutionPayloadreferences thepost-state of blockn-1. As a result, blocknno longer needs to compute & include or verify the post state root for blockn. This removes the expensive state root computation from the block-propagation critical path, reducing end-to-end latency for block production and potentially increasing throughput.", "Abstract": "This EIP proposes that, for each blockn, thestate_rootin blockn\u2019sExecutionPayloadreferences thepost-state of blockn-1. As a result, blocknno longer needs to compute & include or verify the post state root for blockn. This removes the expensive state root computation from the block-propagation critical path, reducing end-to-end latency for block production and potentially increasing throughput.", "Motivation": "Currently, every Ethereum block includes twostate_root.", "Specification": "No changes are required in the CL validation process or block structure:", "Execution Layer Changes": "No changes are required in the CL validation process or block structure:", "Consensus Layer": "No changes are required in the CL validation process or block structure:", "Transition / Fork Activation": "Upon the hard fork that activates this proposal (call this activation blockF):", "Rationale": "This EIP is a consensus-breaking change and requires a coordinated hard fork on mainnet or any network that adopts it. Once activated, older clients that expect blocks to contain their own (execution layer) post-state root will be incompatible and fail to sync.", "Backwards Compatibility": "This EIP is a consensus-breaking change and requires a coordinated hard fork on mainnet or any network that adopts it. Once activated, older clients that expect blocks to contain their own (execution layer) post-state root will be incompatible and fail to sync.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delayed execution layer state root: The state_root in block n's ExecutionPayload now references the post-state of block n-1, eliminating the need to compute and verify the post-state root for block n, reducing block production latency.\n- delayed execution: A mechanism allowing block validation without executing transactions by deferring execution-related fields and charging the COINBASE upfront for inclusion costs.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7863, "url": "https://eips.ethereum.org/EIPS/eip-7863", "title": "Block-level Warming", "authors": ["Toni Wahrst\u00e4tter\u00a0(", "@nerolation", ")", "Jochem Brouwer\u00a0(", "@jochem-brouwer", ")", "Alex Stokes\u00a0(", "@ralexstokes", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")"], "sections": {"EIP-7863: Block-level Warming": "This proposal introduces block-level address and storage key warming, allowing accessed addresses and storage keys to maintain their \u201cwarm\u201d status throughout an entire block\u2019s execution. Accessed slots can be effectively cached at the block level, allowing for this opimization.", "Warm addresses and storage keys over the duration of a block": "This proposal introduces block-level address and storage key warming, allowing accessed addresses and storage keys to maintain their \u201cwarm\u201d status throughout an entire block\u2019s execution. Accessed slots can be effectively cached at the block level, allowing for this opimization.", "Abstract": "This proposal introduces block-level address and storage key warming, allowing accessed addresses and storage keys to maintain their \u201cwarm\u201d status throughout an entire block\u2019s execution. Accessed slots can be effectively cached at the block level, allowing for this opimization.", "Motivation": "Currently, the EVM\u2019s storage slot warming mechanism operates at the transaction level, requiring each transaction to \u201cwarm up\u201d slots independently, even when accessing the same storage locations within the same block. This design does not take advantage of the fact that modern node implementations can effectively cache storage access patterns at the block level. By extending the slot warming duration to the block level, we can:", "Specification": "When a storage slot is accessed within a block:", "Mechanics": "When a storage slot is accessed within a block:", "Block Processing": "The implementation modifies the block execution process to maintain block-level sets of accessed addresses and storage slots.", "Implementation Details": "The implementation modifies the block execution process to maintain block-level sets of accessed addresses and storage slots.", "Rationale": "The proposal builds on several key observations:", "Backwards Compatibility": "This change is not backward compatible and requires a hard fork activation. However, it does not introduce any breaking changes for existing contracts, as:", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- block-level warming: Addresses and storage keys remain \"warm\" throughout an entire block\u2019s execution, reducing redundant cold access costs for frequently accessed storage slots.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7864, "url": "https://eips.ethereum.org/EIPS/eip-7864", "title": "Ethereum state using a unified binary tree", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Guillaume Ballet\u00a0(", "@gballet", ")", "Dankrad Feist\u00a0(", "@dankrad", ")", "Ignacio Hagopian\u00a0(", "@jsign", ")", "Kevaundray Wedderburn\u00a0(", "@kevaundray", ")", "Tanishq Jasoria\u00a0(", "@tanishqjasoria", ")", "Gajinder Singh\u00a0(", "@g11tech", ")", "Danno Ferrin\u00a0(", "@shemnon", ")", "Piper Merriam\u00a0(", "@pipermerriam", ")", "Gottfried Herold\u00a0(", "@GottfriedHerold", ")"], "sections": {"EIP-7864: Ethereum state using a unified binary tree": "Introduce a new binary state tree, intended to replace the hexary patricia trees. Account and storage tries are merged into a single tree with 32-byte keys, which also contains contracts code. Account data is broken into independent leaves which  are grouped by 256 in order to provide some locality.", "Switch Ethereum state tree to a unified binary tree": "Introduce a new binary state tree, intended to replace the hexary patricia trees. Account and storage tries are merged into a single tree with 32-byte keys, which also contains contracts code. Account data is broken into independent leaves which  are grouped by 256 in order to provide some locality.", "Abstract": "Introduce a new binary state tree, intended to replace the hexary patricia trees. Account and storage tries are merged into a single tree with 32-byte keys, which also contains contracts code. Account data is broken into independent leaves which  are grouped by 256 in order to provide some locality.", "Motivation": "Ethereum\u2019s long-term goal is to allow blocks to be proved with validity proof so that chain verification is as simple and fast as possible. One of the most challenging parts of achieving that goal is proving the state of the tree, which is required for EVM execution.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Notable changes from the hexary structure": "The proposed Binary Tree stores key-value entries where both the key and value are 32 bytes. The first 31-bytes of the key define the entry stem, and the last byte is the subindex in that stem. If two keys have the same stem, they live in the same \u201cbig branch\u201d \u2014 this co-locates groups of 256 keys (i.e: keys with the same first 31-bytes).", "Tree structure": "The proposed Binary Tree stores key-value entries where both the key and value are 32 bytes. The first 31-bytes of the key define the entry stem, and the last byte is the subindex in that stem. If two keys have the same stem, they live in the same \u201cbig branch\u201d \u2014 this co-locates groups of 256 keys (i.e: keys with the same first 31-bytes).", "Node merkelization": "Definehash(value)as:", "Tree embedding": "Instead of a two-layer structure like the MPT, we will embed all information into a uniquekey: valuespace in the proposed single tree. This section specifies which tree keys store the state\u2019s information (account header data, code, storage). The data is colocated in such way that data that is usually accessed together lives in the sameStemNodewhich reduces branch openings.", "Header values": "These are the positions in the tree at which header fields of an account are stored.", "Code": "Chunkistores a 32 byte value, where bytes 1\u202631 are bytesi*31...(i+1)*31 - 1of the code (i.e. the i\u2019th 31-byte slice of it), and byte 0 is the number of leading bytes that are part of PUSHDATA (e.g. if part of the code is...PUSH4 99 98 | 97 96 PUSH1 128 MSTORE...where|is the position where a new chunk begins, then the encoding of the latter chunk would begin2 97 96 PUSH1 128 MSTOREto reflect that the first 2 bytes are PUSHDATA).", "Storage": "Note that storage slots in the same sizeSTEM_SUBTREE_WIDTHrange (i.e. a range with the formx*STEM_SUBTREE_WIDTH ... (x+1)*STEM_SUBTREE_WIDTH-1)are all, except for theHEADER_STORAGE_OFFSETspecial case, part of a single stem.", "Fork": "Described inEIP-7612.", "Access events": "Described inEIP-4762.", "Rationale": "This EIP defines a new Binary Tree that starts empty. Only new state changes are stored in the tree. The MPT continues to exist but is frozen. This sets the stage for a future hard fork that migrates the MPT data to this Binary Tree (EIP-7748).", "Single tree design": "The proposal uses a single-layer tree structure with 32-byte keys and values for several reasons:", "SNARK friendliness and Post-Quantum security": "The proposed design should consider the usual complexity, performance, and efficiency for out-of-circuit implementations (i.e. EL clients) and in-circuit ones for generating proofs in ZK circuits.", "Arity-2": "Binary tries have been chosen primarily because they reduce the witness size. In general, in anN-element tree with each element havingkchildren, the average size of a branch is roughly32 * (k-1) * log(N) / log(k)plus a few percent for overhead. 32 is the length of a hash; thek-1refers to the fact that a Merkle proof needs to provide allk-1sister nodes at each level, andlog(N) / log(k)is an approximation of the number of levels in the tree (e.g. a tree where each node has 5 children, with 625 nodes total, would have depth 4, as625 = 5**4and solog(625) / log(5) = 4).", "Tree depth": "The tree design attempts to be as simple as possible considering both out-of-circuit and circuit implementations, while satisfying our throughput constraints on proving hashes.", "State-expiry": "State-expiry strategies such asEIP-7736could still be applied, requiring a change in the design. One potential solution is adding a field theStemNodewithepochas described in the mentioned EIP. Another alternative is to use 247-bits for the stem, and have two subtreesStemValuesNode, which would correspond to the current 256-values, andStemMetaNodewhich is also a 256-subtree that can be used to store arbitrary stem metadata.", "Backwards Compatibility": "The main breaking changes are:", "Test Cases": "TODO:", "Reference Implementation": "Python reference implementation (github.com/jsign/binary-tree-spec).", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- unified binary tree: A new Ethereum state structure that replaces hexary Patricia trees with a single binary tree, merging account and storage tries into one, improving proof efficiency and state organization.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7877, "url": "https://eips.ethereum.org/EIPS/eip-7877", "title": "Enhanced RETURN opcodes", "authors": ["Josh Weintraub\u00a0(", "@jhweintraub", ")"], "sections": {"EIP-7877: Enhanced RETURN opcodes": "This EIP specifies a series of newRETURNopcodes which allow the user to specify which data location to return from\ninstead of defaulting to returning from memory.", "Deprecate RETURN opcode in favor of new opcodes that allow returning data from various locations without first having to write to memory.": "This EIP specifies a series of newRETURNopcodes which allow the user to specify which data location to return from\ninstead of defaulting to returning from memory.", "Abstract": "This EIP specifies a series of newRETURNopcodes which allow the user to specify which data location to return from\ninstead of defaulting to returning from memory.", "Motivation": "With the introduction of transient storage, many smart contracts have begun to store data using the new transient opcodes to optimize for gas usage, whereby a callback\ninvolves returning the data previously stored transiently. However, the currentRETURNopcode only allows for returning sequential bytes in memory. This requires\ndevelopers to incur additional gas overhead by manually writing data from transient storage to memory before returning,\nincuring both an additional memory expansion and opcode cost from complicated for-loops. Similar\ninefficiencies already occur when attempting to return data already placed in storage. This EIP attempts to rectify\nthis by allowing developers to optimize their code by deciding where to return data from directly, instead of requiring\nthe intermediate step of first copying the data to memory.", "Specification": "This EIP introduces 3 new opcodes as well as renaming/aliasing an existing one.", "Rationale": "Allowing for more targeted return opcodes allows for saving gas at all levels of smart contract optimization by eliminating\nthe intermediate steps of first writing any data to memory before returning. In events where this data may be large, this can result in significant gas savings. These opcodes can be built into the Solidity compiler directly so that all contracts\ncan take advantage of them. Similarly, by making return more explicit it allows for better static analysis by avoiding messy memory allocations.", "Backwards Compatibility": "There are no backwards compatibility concerns, asMRETURNwill utilize the same gas cost and opcode asRETURNdoes now. Due to EOF, it is suggested that these changes be\nactivated in future EVM version once EOF has been fully implemented.", "Security Considerations": "There are no security considerations as it is fully backwards compatible, and reduces potential attack space through simplified bytecode.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- sreturn: A new opcode that allows returning data directly from storage without first copying it to memory.\n- treturn: A new opcode that allows returning data directly from transient storage without first copying it to memory.\n- mreturn: A renamed version of the existing RETURN opcode, which returns sequential bytes from memory."}
{"eip": 7883, "url": "https://eips.ethereum.org/EIPS/eip-7883", "title": "ModExp Gas Cost Increase", "authors": ["Marcin Sobczak\u00a0(", "@marcindsobczak", ")", "Marek Moraczy\u0144ski\u00a0(", "@MarekM25", ")", "Marcos Maceo\u00a0(", "@stdevMac", ")"], "sections": {"EIP-7883: ModExp Gas Cost Increase": "This EIP is modifying theModExpprecompile pricing algorithm introduced inEIP-2565.", "Increases cost of ModExp precompile": "This EIP is modifying theModExpprecompile pricing algorithm introduced inEIP-2565.", "Abstract": "This EIP is modifying theModExpprecompile pricing algorithm introduced inEIP-2565.", "Motivation": "There are cases where theModExpprecompile is underpriced for it\u2019s resource consumption. By modifying theModExppricing formula these scenarios would be covered with minimal impact on real world applications. The target is to makeModExpat least as fast as EcRecover precompile in all cases.", "Specification": "Upon activation of this EIP, the gas cost of calling the precompile at address0x0000000000000000000000000000000000000005will be calculated as follows:", "1. Increase minimal price from 200 to 500": "This part of equation:", "2. Increase cost when exponent is larger than 32 bytes": "This part of equation:", "3. Increase cost when base or modulus is larger than 32 bytes": "This part of equation:", "Rationale": "After benchmarking theModExpprecompile, we identified certain scenarios that are underpriced and require repricing to ensure appropriate costs. Further research revealed that all underpriced edge cases can be addressed by adjusting the parameters in the currentModExppricing formula. With these changes, the minimum cost for using theModExpprecompile will increase from 200 to 500 (a 150% increase), and the cost will scale higher when thebase,modulus, orexponentexceed 32 bytes. These adjustments will ensure that the worst-performing edge cases of theModExpprecompile perform no worse than theEcRecoverprecompile.", "Backwards Compatibility": "This change is backwards incompatible. However, similar gas repricings have occurred multiple times in the Ethereum ecosystem, and their effects are well understood.", "Test Cases": "There are no changes to the underlying interface or arithmetic algorithms, so the existing test vectors can be reused. Below is a table with the updated test vectors:", "Security Considerations": "There are no security concerns since no new functionality is introduced or made cheaper. The primary consideration for this EIP is the risk of potentially overpricedModExpscenarios.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- modexp gas cost: Reprices the ModExp precompile (0x05) to more accurately reflect its computational cost, improving efficiency for cryptographic operations.\n- modexp gas cost increase: A change in the pricing formula of the ModExp precompile to ensure it is not underpriced for its resource consumption.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7886, "url": "https://eips.ethereum.org/EIPS/eip-7886", "title": "Delayed execution", "authors": ["Francesco D`Amato\u00a0(", "@fradamt", ")", "Toni Wahrst\u00e4tter\u00a0(", "@nerolation", ")"], "sections": {"EIP-7886: Delayed execution": "This proposal makes (execution) blocks statically verifiable through minimal checks that only require the previous state, but no execution of the block\u2019s transactions, allowing validators attest to a block\u2019s validity without completing its execution. We allow transactions to be skipped when invalid at execution time, without invalidating the whole block. To ensure that even skipped transactions pay for their resources, theCOINBASEpays for all inclusion costs upfront (base cost, calldata and blobs), and recovers the costs only when transactions are successfully executed.", "Make blocks statically verifiable by charging coinbase for inclusion costs upfront": "This proposal makes (execution) blocks statically verifiable through minimal checks that only require the previous state, but no execution of the block\u2019s transactions, allowing validators attest to a block\u2019s validity without completing its execution. We allow transactions to be skipped when invalid at execution time, without invalidating the whole block. To ensure that even skipped transactions pay for their resources, theCOINBASEpays for all inclusion costs upfront (base cost, calldata and blobs), and recovers the costs only when transactions are successfully executed.", "Abstract": "This proposal makes (execution) blocks statically verifiable through minimal checks that only require the previous state, but no execution of the block\u2019s transactions, allowing validators attest to a block\u2019s validity without completing its execution. We allow transactions to be skipped when invalid at execution time, without invalidating the whole block. To ensure that even skipped transactions pay for their resources, theCOINBASEpays for all inclusion costs upfront (base cost, calldata and blobs), and recovers the costs only when transactions are successfully executed.", "Motivation": "A key advantage of this proposal is that it enablesasynchronous block validation. Currently, blocks must be fully executed before validators can attest to their validity. This requirement creates a bottleneck in the consensus process, as attestors must wait for execution results before committing their votes.", "Specification": "In order to be verifiable before execution, the header cannot commit to any execution output. In particular, we need to defer these fields:state_root, receipt_root, bloom, gas_used, requests_hash. We replace them with the equivalent execution outputs from the parent block.", "Change to the header structure": "In order to be verifiable before execution, the header cannot commit to any execution output. In particular, we need to defer these fields:state_root, receipt_root, bloom, gas_used, requests_hash. We replace them with the equivalent execution outputs from the parent block.", "Static block validation": "We split up a block\u2019s validation from its execution. In the ethereum/execution-specs, static validation is done in[validate_block](https://github.com/ethereum/execution-specs/blob/ae2c77989cb83e5d5e5eb1f51d9da840a337d5b0/src/ethereum/prague/fork.py#L480), after which a block is guaranteed to be valid and can be attested to, while execution remains within[apply_body](https://github.com/ethereum/execution-specs/blob/ae2c77989cb83e5d5e5eb1f51d9da840a337d5b0/src/ethereum/prague/fork.py#L696). Invalidate_block, we do some formal checks, as well as:", "Block execution": "This logic is implemented into the ethereum/execution-specs, in[apply_body](https://github.com/ethereum/execution-specs/blob/ae2c77989cb83e5d5e5eb1f51d9da840a337d5b0/src/ethereum/prague/fork.py#L696).", "Rationale": "Enabling delayed execution by making the block\u2019s validity statically verifiable requires two things:", "Overview": "Enabling delayed execution by making the block\u2019s validity statically verifiable requires two things:", "Coinbase signature over the header": "By signing over the header, theCOINBASEaddress explicitly accepts responsibility for the upfront inclusion costsof this block. Therefore, the recovered address MUST equal the block\u2019sCOINBASE. TheCOINBASE\u2019s commitment is protected from replay attacks, because the header is a commitment to the block, so the signature only serves as an authorization for the exact block for which theCOINBASEhas agreed to take responsibility.", "Backwards Compatibility": "This change is not backward compatible and requires a hard fork activation.", "Security Considerations": "At the time of block creation, theCOINBASEmust be sufficiently funded to cover up toblock.gas_limit * base_fee_per_gas+blob_gas_price * max_blob_gas_per_blockto be able to cover the maximum possible inclusion cost. For instance, with a base fee of 100 gwei and a 36 million gas limit, theCOINBASEwould need to hold 3.6 ETH to front this cost (ignoring the blob fees) for a worst-case block. This requirement could introduce additional liquidity constraints for block proposers, especially under high base fee conditions. However, the inclusion costs under normal conditions (lower base fee, inclusion gas much below the gas limit) are significantly lower. Over a one year period of blocks from ~19.1M to ~21.7M, the average inclusion costs would have been ~5.5M gas per block, or ~0.55 ETH even at 100 gwei.", "Coinbase funding": "At the time of block creation, theCOINBASEmust be sufficiently funded to cover up toblock.gas_limit * base_fee_per_gas+blob_gas_price * max_blob_gas_per_blockto be able to cover the maximum possible inclusion cost. For instance, with a base fee of 100 gwei and a 36 million gas limit, theCOINBASEwould need to hold 3.6 ETH to front this cost (ignoring the blob fees) for a worst-case block. This requirement could introduce additional liquidity constraints for block proposers, especially under high base fee conditions. However, the inclusion costs under normal conditions (lower base fee, inclusion gas much below the gas limit) are significantly lower. Over a one year period of blocks from ~19.1M to ~21.7M, the average inclusion costs would have been ~5.5M gas per block, or ~0.55 ETH even at 100 gwei.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delayed execution: A mechanism allowing block validation without executing transactions by deferring execution-related fields and charging the COINBASE upfront for inclusion costs.\n- skipped transaction: A transaction included in a block but not executed due to insufficient funds, gas limits, incorrect nonce, or invalid sender type, with its inclusion cost still paid by COINBASE.\n- inclusion cost: The upfront fee paid by COINBASE for each transaction, covering base cost, calldata, and blob fees, which is refunded if the transaction executes successfully."}
{"eip": 7889, "url": "https://eips.ethereum.org/EIPS/eip-7889", "title": "Emit log on revert", "authors": ["Shoham Chakraborty\u00a0(", "@shohamc1", ")", "Alex Forshtat\u00a0(", "@forshtat", ")"], "sections": {"EIP-7889: Emit log on revert": "All calls to the REVERT opcode with non-zero size must emit a log with revert data, making it accessible via standard RPC without the need for tracing.", "Top level reverts emit a log with revert message": "All calls to the REVERT opcode with non-zero size must emit a log with revert data, making it accessible via standard RPC without the need for tracing.", "Abstract": "All calls to the REVERT opcode with non-zero size must emit a log with revert data, making it accessible via standard RPC without the need for tracing.", "Motivation": "Revert messages are currently inaccessible to users as they are not available via standard RPC. Instead, users have to request a node to trace the transaction and check the stack and memory at the moment when the REVERT opcode was executed.", "Specification": "WheneverREVERTis called with non-zero size, emit a log identical to a LOG1 with the topicREVERTTOPIC. The log data is the raw bytes of the revert message. The data is truncated toDATA_LIMIT.", "Parameters": "WheneverREVERTis called with non-zero size, emit a log identical to a LOG1 with the topicREVERTTOPIC. The log data is the raw bytes of the revert message. The data is truncated toDATA_LIMIT.", "Functionality": "WheneverREVERTis called with non-zero size, emit a log identical to a LOG1 with the topicREVERTTOPIC. The log data is the raw bytes of the revert message. The data is truncated toDATA_LIMIT.", "Rationale": "This is the simplest possible implementation that allows revert messages to be accessible via RPC methods. It does not require any changes to client libraries, or other RPC consumers as it is backward compatible. It does not introduce new RPC methods or new opcodes.", "Backwards Compatibility": "Reverted transactions may now contain up to one log.", "Security Considerations": "Reverted transactions must cost at least intrinsic gas (21000 gas), which is much more expensive than the LOG1 opcode (750 gas). Hence, this EIP does not introduce any new avenues to inflate Ethereum storage requirements. However, it is expected to increase the average number of logs.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- log1: A special type of log that can be used by reverted transactions.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7898, "url": "https://eips.ethereum.org/EIPS/eip-7898", "title": "Uncouple execution payload from beacon block", "authors": ["Gajinder Singh\u00a0(", "@g11tech", ")"], "sections": {"EIP-7898: Uncouple execution payload from beacon block": "Currently, the beacon block in Ethereum Consensus embed transactions withinExecutionPayloadfield ofBeaconBlockBody. This EIP proposes to replaceExecutionPayloadwithExecutionPayloadHeaderinBeaconBlockBodyand to independently transmitExecutionPayloadWithInclusionProof.", "Separates the execution payload from beacon block to independently transmit them": "Currently, the beacon block in Ethereum Consensus embed transactions withinExecutionPayloadfield ofBeaconBlockBody. This EIP proposes to replaceExecutionPayloadwithExecutionPayloadHeaderinBeaconBlockBodyand to independently transmitExecutionPayloadWithInclusionProof.", "Abstract": "Currently, the beacon block in Ethereum Consensus embed transactions withinExecutionPayloadfield ofBeaconBlockBody. This EIP proposes to replaceExecutionPayloadwithExecutionPayloadHeaderinBeaconBlockBodyand to independently transmitExecutionPayloadWithInclusionProof.", "Motivation": "Ethereum protocol has an ambitious goal to grow thegasLimitof the execution payloads (possibly by 10X). This leads to larger messages, negatively affecting the networking and block processing pipelines of the consensus layer (CL) clients leading to following issues:", "Specification": "ELs can optionally introduce agetExecutionPayloadmethod (similar togetBlobs) to assist with faster recovery of execution payload from the EL\u2019s p2p network peers who could annouce new payload hashes when they see newVALIDpayloads. However, as noted above, that mechanism could be independently specified and is out of scope for this EIP.", "Rationale": "There is another choice we could have made to go forSignedExecutionPayloadinstead ofExecutionPayloadWithInclusionProofand having aSignedExecutionPayloadHeaderwith builder signing these messages (validator is the builder in local block building). But without builder enshrinment tight gossip validation ofSignedExecutionPayloadwould be an issue and could become a DOS vector.", "Backwards Compatibility": "This change isn\u2019t backward compatible and a new hardfork is required to activate this EIP.", "Test Cases": "<\u2013 TODO \u2013>", "Reference Implementation": "<\u2013 TODO \u2013>", "Security Considerations": "<\u2013 TODO \u2013>", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- executionpayloadheader: Replaces ExecutionPayload in BeaconBlockBody\n- executionpayloadwithinclusionproof: Independent transmission of execution payload and inclusion proof"}
{"eip": 7903, "url": "https://eips.ethereum.org/EIPS/eip-7903", "title": "Remove Initcode Size Limit", "authors": ["Charles Cooper\u00a0(", "@charles-cooper", ")"], "sections": {"EIP-7903: Remove Initcode Size Limit": "This EIP proposes the removal of theinitcodesize limit of 49152 bytes introduced inEIP-3860. The restriction complicates deploying multiple contracts addressing theEIP-170limit (24576 bytes) within a single transaction, while the existing gas metering forinitcode, already ensures fairinitcodecosting, including forJUMPDESTanalysis.", "Removes the initcode size limit introduced in EIP-3860": "This EIP proposes the removal of theinitcodesize limit of 49152 bytes introduced inEIP-3860. The restriction complicates deploying multiple contracts addressing theEIP-170limit (24576 bytes) within a single transaction, while the existing gas metering forinitcode, already ensures fairinitcodecosting, including forJUMPDESTanalysis.", "Abstract": "This EIP proposes the removal of theinitcodesize limit of 49152 bytes introduced inEIP-3860. The restriction complicates deploying multiple contracts addressing theEIP-170limit (24576 bytes) within a single transaction, while the existing gas metering forinitcode, already ensures fairinitcodecosting, including forJUMPDESTanalysis.", "Motivation": "The EIP-3860initcodesize limit imposes an unnecessary constraint on deployment patterns, particularly for creation transactions creating largelogicalcontracts composed of multiplephysical sub-contractsin a single transaction.\nA key argument for retaining EIP-170\u2019s 24KB runtime code limit is that high-level languages (HLLs) should abstract it away.\nHowever, the EIP-3860 limit prevents HLLs from cleanly abstracting this, as deploying large logical contracts exceeding 49152 bytes ofinitcoderequires splitting into multiple transactions, undermining the abstraction.", "Specification": "Revert theinitcodesize limit introduced in EIP-3860. Specifically:", "Rationale": "This proposal is driven by the need to restore flexibility in contract deployment patterns, such as factory contracts creating multiple sub-contracts in one transaction. The design decision to remove the 49152-byte cap leverages the pre-existing gas metering system, which scales linearly withinitcodesize (i.e., 2 gas per byte), ensuring fair cost attribution without artificial limits.", "Backwards Compatibility": "This change is fully backwards compatible. Existing contracts and transactions remain unaffected, as the proposal only lifts a restriction without altering execution semantics or gas costs.", "Test Cases": "No new security risks are introduced. The current gas schedule already mitigates denial-of-service concerns by charging per-byte forinitcode. Benchmarks were performed, and ns/byte remained consistent across a range of different bytecodes, ranging from 128 bytes to 15MB.", "Security Considerations": "No new security risks are introduced. The current gas schedule already mitigates denial-of-service concerns by charging per-byte forinitcode. Benchmarks were performed, and ns/byte remained consistent across a range of different bytecodes, ranging from 128 bytes to 15MB.", "Copyright": "Copyright and related rights waived via CC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- initcode: The code executed by a contract at its initialization, which must be within 49152 bytes in size before EIP-3860.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7907, "url": "https://eips.ethereum.org/EIPS/eip-7907", "title": "Meter Contract Code Size And Increase Limit", "authors": ["Charles Cooper\u00a0(", "@charles-cooper", ")", "Qi Zhou\u00a0(", "@qizhou", ")"], "sections": {"EIP-7907: Meter Contract Code Size And Increase Limit": "This EIP substantially increases the hard contract code size limit from 24KB (24576 bytes) introduced inEIP-170to 256KB, and adds gas metering. It introduces a gas cost of 2 gas per (32 byte) word for contract code exceeding 24KB, allowing deployment of contracts of any size while preventing DoS attacks through appropriate gas metering. Lastly, it also commensurately increases initcode size limit from 48KB, introduced inEIP-3860, to 512KB.", "Increases the contract code size limit introduced in EIP-170 and adds a gas metering to code loading": "This EIP substantially increases the hard contract code size limit from 24KB (24576 bytes) introduced inEIP-170to 256KB, and adds gas metering. It introduces a gas cost of 2 gas per (32 byte) word for contract code exceeding 24KB, allowing deployment of contracts of any size while preventing DoS attacks through appropriate gas metering. Lastly, it also commensurately increases initcode size limit from 48KB, introduced inEIP-3860, to 512KB.", "Abstract": "This EIP substantially increases the hard contract code size limit from 24KB (24576 bytes) introduced inEIP-170to 256KB, and adds gas metering. It introduces a gas cost of 2 gas per (32 byte) word for contract code exceeding 24KB, allowing deployment of contracts of any size while preventing DoS attacks through appropriate gas metering. Lastly, it also commensurately increases initcode size limit from 48KB, introduced inEIP-3860, to 512KB.", "Motivation": "EIP-170 introduced a 24KB contract code size limit to prevent potential DoS attacks, as large contract code requires O(n) resource cost in terms of disk reads, VM preprocessing, and Merkle proof sizes, all of which are not directly compensated by gas fees. However, this limit restricts legitimate use cases for large contracts.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "The gas cost of 2 per word was chosen in-line with EIP-3860. This accounts for:", "Backwards Compatibility": "This EIP is backward compatible with existing contracts. All contracts that were valid before this EIP will remain valid after it, and their gas costs will not change.", "Test Cases": "Clients should add an efficient way to determine the code size without loading the entire code, e.g. storing it in a separate table keyed by code hash. This way, they can charge for the access cost before physically loading the code. Otherwise, a client may load a contract, even when there is not enough gas left to pay for the code load.", "Reference Implementation": "Clients should add an efficient way to determine the code size without loading the entire code, e.g. storing it in a separate table keyed by code hash. This way, they can charge for the access cost before physically loading the code. Otherwise, a client may load a contract, even when there is not enough gas left to pay for the code load.", "Security Considerations": "Clients should add an efficient way to determine the code size without loading the entire code, e.g. storing it in a separate table keyed by code hash. This way, they can charge for the access cost before physically loading the code. Otherwise, a client may load a contract, even when there is not enough gas left to pay for the code load.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- contract code size limit: Sets a hard limit on contract size at 0x6000 bytes, and if a contract exceeds this size during creation, it results in an out-of-gas error.\n- initcode: The code executed by a contract at its initialization, which must be within 49152 bytes in size before EIP-3860.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7915, "url": "https://eips.ethereum.org/EIPS/eip-7915", "title": "Adaptive mean reversion blob pricing", "authors": ["Anders Elowsson\u00a0(", "@anderselowsson", ")"], "sections": {"EIP-7915: Adaptive mean reversion blob pricing": "Reworks the excess blob gas update incalc_excess_blob_gas()so that the blob base fee rises relatively more during high gas usage than it falls during low usage whenever the current fee is below the long-run average. This establishes a smoothly adapting, neutral lower bound for the base fee. The exponential moving average (EMA) is computed in the linear domain and stored as a header variable.", "Fee schedule accounting for the long-run average to quickly restore equilibrium under inelastic demand": "Reworks the excess blob gas update incalc_excess_blob_gas()so that the blob base fee rises relatively more during high gas usage than it falls during low usage whenever the current fee is below the long-run average. This establishes a smoothly adapting, neutral lower bound for the base fee. The exponential moving average (EMA) is computed in the linear domain and stored as a header variable.", "Abstract": "Reworks the excess blob gas update incalc_excess_blob_gas()so that the blob base fee rises relatively more during high gas usage than it falls during low usage whenever the current fee is below the long-run average. This establishes a smoothly adapting, neutral lower bound for the base fee. The exponential moving average (EMA) is computed in the linear domain and stored as a header variable.", "Motivation": "Demand for blobspace is fee-inelastic, leading to a blob base fee that may fluctuate excessively with minor shifts in aggregate demand. The lower end of the fee range of 1 wei is under current circumstances economically inconsequential, but can be reached after a period of blocks consuming fewer blobs than the target. During increases in demand, the existing fee mechanism requires sustained periods of near-full blocks to re-establish equilibrium. This exacerbates spikiness in resource consumption, which can hamper efficient scaling of throughput. Furthermore, users may intermittently need to compete in a first-price auction for inclusion, degrading UX. The appropriate fee range will inadvertently vary going forward due to changes in the ETH token price and circulating supply, as well as the protocol\u2019s ability to scale throughput. To remain neutral and future-proof, the operational range should be established relative to the long-run average fee, smoothly affecting the equilibrium quantity of blobs consumed. Thus, this EIP introduces a new fee update mechanism that accounts for the long-run average fee when responding to shifts in demand. This allows the protocol to quickly converge to desirable equilibria while also remaining neutral and future-proof.", "Specification": "The functioncalc_excess_blob_gas()fromEIP-4844is updated. A mean reversion weightwis computed based on the ratio between the long-run base fee and the current base fee. The weight influences the excess gas update by smoothly increasing the gas used and decreasing the gas target as the current base fee falls below the long-run base fee (see Figure 2 below). The variableUpupsampleswto retain precision. Note that the function appliesinteger_squareroot(), which must be implemented at the execution layer; it is currently implemented at the consensus layer. Thresholding atMEAN_REVERSION_FULLBANDand strategic deployment ofUpallows the mechanism to rely on theuint64type internally.", "Parameters": "The functioncalc_excess_blob_gas()fromEIP-4844is updated. A mean reversion weightwis computed based on the ratio between the long-run base fee and the current base fee. The weight influences the excess gas update by smoothly increasing the gas used and decreasing the gas target as the current base fee falls below the long-run base fee (see Figure 2 below). The variableUpupsampleswto retain precision. Note that the function appliesinteger_squareroot(), which must be implemented at the execution layer; it is currently implemented at the consensus layer. Thresholding atMEAN_REVERSION_FULLBANDand strategic deployment ofUpallows the mechanism to rely on theuint64type internally.", "Functions": "The functioncalc_excess_blob_gas()fromEIP-4844is updated. A mean reversion weightwis computed based on the ratio between the long-run base fee and the current base fee. The weight influences the excess gas update by smoothly increasing the gas used and decreasing the gas target as the current base fee falls below the long-run base fee (see Figure 2 below). The variableUpupsampleswto retain precision. Note that the function appliesinteger_squareroot(), which must be implemented at the execution layer; it is currently implemented at the consensus layer. Thresholding atMEAN_REVERSION_FULLBANDand strategic deployment ofUpallows the mechanism to rely on theuint64type internally.", "Header extension": "The current header encoding is extended with theuintfieldbase_fee_per_blob_gas_ema. For the first post-fork block,parent.base_fee_per_blob_gas_emais evaluated as4*10**9(4 gwei).", "Execution layer validation": "The block validity conditions on the execution layer are extended to assert thatbase_fee_per_blob_gas_emawas correctly updated:", "Rationale": "Since the introduction of blobs, the reservation fee of the marginal consumer of blobs has periodically been very low. Whenever demand picks up, a sustained succession of near-full blocks is required to restore equilibrium, with the mechanism intermittently resorting to a first-price auction, considered a worse UX by blob consumers. The resulting spikiness in resource consumption is suboptimal for scaling blobspace. At a fundamental level, the issue is that Ethereum faces a fee-inelastic demand curve while operating a perfectly inelastic supply curve\u2014with supply fixed atTARGET_BLOB_GAS_PER_BLOCK. When an equilibrium forms between fee-inelastic supply and demand curves, even a small shift in aggregate demand can lead to huge shifts in the equilibrium fee. This proposal smoothly increases the elasticity of the supply curve as it diverges from the long-run average, restricting the equilibrium fee from forming much below the average. Combined with the faster fee adjustments in the direction of the average, a desirable equilibrium can then quickly be established during temporary shifts in demand.", "Supply and demand": "Since the introduction of blobs, the reservation fee of the marginal consumer of blobs has periodically been very low. Whenever demand picks up, a sustained succession of near-full blocks is required to restore equilibrium, with the mechanism intermittently resorting to a first-price auction, considered a worse UX by blob consumers. The resulting spikiness in resource consumption is suboptimal for scaling blobspace. At a fundamental level, the issue is that Ethereum faces a fee-inelastic demand curve while operating a perfectly inelastic supply curve\u2014with supply fixed atTARGET_BLOB_GAS_PER_BLOCK. When an equilibrium forms between fee-inelastic supply and demand curves, even a small shift in aggregate demand can lead to huge shifts in the equilibrium fee. This proposal smoothly increases the elasticity of the supply curve as it diverges from the long-run average, restricting the equilibrium fee from forming much below the average. Combined with the faster fee adjustments in the direction of the average, a desirable equilibrium can then quickly be established during temporary shifts in demand.", "Proposed base fee update schedule": "The update schedule adheres to the following design principles:", "Computing the long-run average base fee": "An average of the base fee $\\bar{f}_g$ is maintained in the header variablebase_fee_per_blob_gas_ema, computed as an exponential moving average. Each slot, $\\bar{f}_g$ is updated by taking", "Alternative approach": "One alternative way to structure the adaptive mean reversion was referenced in the previous subsection and will be described here. It differs in that that the protocol would rely on and store a log-domain representation ofbase_fee_per_blob_gas_ema:excess_blob_gas_ema. The EMA computation would still be performed in the linear domain, butget_base_fee_per_blob_gas()and its inverse\u2014relying on a newfake_log()function\u2014would be applied during computations to first go to the linear domain and then return to the log-domain", "Security Considerations": "The blob base fee doubles during full blocks if the current fee is several orders of magnitude below the average. As a result, a single-block delay in inclusion results in users paying twice as much, potentially influencing inclusion and fee-market strategies. However, practical implications should be limited, given that this aggressive fee schedule only operates at fees well below the average.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- blob base fee: the base fee for blob gas usage"}
{"eip": 7916, "url": "https://eips.ethereum.org/EIPS/eip-7916", "title": "SSZ ProgressiveList", "authors": ["Zsolt Felf\u00f6ldi\u00a0(", "@zsfelfoldi", ")", "Cayman\u00a0(", "@wemeetagain", ")", "Etan Kissling\u00a0(", "@etan-status", ")"], "sections": {"EIP-7916: SSZ ProgressiveList": "This EIP introduces a newSimple Serialize (SSZ)type,ProgressiveList[T], to represent lists of arbitrary length with stable merkleization. Unlike the existingList[T, N]type, which imposes a fixed capacityN,ProgressiveList[T]supports unbounded growth using a recursive tree structure during merkleization to efficiently handle lists of any size while maintaining stablegeneralized indices (gindices)for individual elements. This enables reduced hash overhead for small lists and avoids arbitrary predefined limits.", "New SSZ type to improve efficiency for short lists": "This EIP introduces a newSimple Serialize (SSZ)type,ProgressiveList[T], to represent lists of arbitrary length with stable merkleization. Unlike the existingList[T, N]type, which imposes a fixed capacityN,ProgressiveList[T]supports unbounded growth using a recursive tree structure during merkleization to efficiently handle lists of any size while maintaining stablegeneralized indices (gindices)for individual elements. This enables reduced hash overhead for small lists and avoids arbitrary predefined limits.", "Abstract": "This EIP introduces a newSimple Serialize (SSZ)type,ProgressiveList[T], to represent lists of arbitrary length with stable merkleization. Unlike the existingList[T, N]type, which imposes a fixed capacityN,ProgressiveList[T]supports unbounded growth using a recursive tree structure during merkleization to efficiently handle lists of any size while maintaining stablegeneralized indices (gindices)for individual elements. This enables reduced hash overhead for small lists and avoids arbitrary predefined limits.", "Motivation": "Current SSZList[T, N]types require a predefined capacityN, which leads to several issues:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "ProgressiveList[T]": "ProgressiveList[T]defines an ordered, homogeneous collection of elements of typeT, whereTis any valid SSZ type (e.g.,uint64,Container, etc.).", "ProgressiveByteList": "For convenienceProgressiveByteListis defined as an alias toProgressiveList[byte].", "Rationale": "Dynamic-depth Merkleization destabilizes gindices:", "Why a Recursive Structure?": "Dynamic-depth Merkleization destabilizes gindices:", "Why Not Dynamic Depth?": "Dynamic-depth Merkleization destabilizes gindices:", "Why Not Fixed-Capacity Lists?": "List[T, N]:", "Why Are Base Size and Scaling Factors Not Exposed Parameters?": "ProgressiveList[T]is a new SSZ type, coexisting withList[T, N]and other types without conflict. ItsList-equivalent serialization ensures compatibility with existing serializers.", "Backwards Compatibility": "ProgressiveList[T]is a new SSZ type, coexisting withList[T, N]and other types without conflict. ItsList-equivalent serialization ensures compatibility with existing serializers.", "Test Cases": "SeeEIP assets.", "Reference Implementation": "SeeEIP assets, based onprotolambda/remerkleable.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- progressivelist[t]: A SSZ type representing lists of arbitrary length with stable merkleization.\n- gindices: Generalized indices for individual elements in a list.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7917, "url": "https://eips.ethereum.org/EIPS/eip-7917", "title": "Deterministic proposer lookahead", "authors": ["Lin Oshitani (@linoscope)\u00a0<", "lin@nethermind.io", ">", "Justin Drake (@JustinDrake)\u00a0<", "justin@ethereum.org", ">"], "sections": {"EIP-7917: Deterministic proposer lookahead": "At the start of each epoch, pre-calculate and store in thebeacon_statea deterministicproposer_lookaheadfor the nextMIN_SEED_LOOKAHEAD + 1epochs.", "Pre-calculate and store a deterministic proposer lookahead in the beacon state at the start of every epoch": "At the start of each epoch, pre-calculate and store in thebeacon_statea deterministicproposer_lookaheadfor the nextMIN_SEED_LOOKAHEAD + 1epochs.", "Abstract": "At the start of each epoch, pre-calculate and store in thebeacon_statea deterministicproposer_lookaheadfor the nextMIN_SEED_LOOKAHEAD + 1epochs.", "Motivation": "Unlike RANDAO seeds, which have a deterministic lookahead of at leastMIN_SEED_LOOKAHEAD == 1epochs, the beacon proposer schedule of epochN + 1is not fully predictable from the beacon state during epochN. The reason is that, under certain edge cases, the effective balances (EBs) of active validators\u2014themselves used as input for proposer election in epochN + 1\u2014can change within epochN.", "Specification": "TheBeaconStatecontainer is extended with aproposer_lookaheadfield, which is a list of validator indices covering the full visible lookahead period, starting from the beginning of the current epoch to the nextMIN_SEED_LOOKAHEADepochs.", "Rationale": "An alternative approach would be to cache the effective balances at the start of epochNso it can be used to calculate the proposer lookahead at the start of epochN+MIN_SEED_LOOKAHEAD. However, this approach would require additional footprint in the beacon state, and would not be able to provide the proposer lookahead to the EVM via the beacon root.", "Considered Alternatives": "An alternative approach would be to cache the effective balances at the start of epochNso it can be used to calculate the proposer lookahead at the start of epochN+MIN_SEED_LOOKAHEAD. However, this approach would require additional footprint in the beacon state, and would not be able to provide the proposer lookahead to the EVM via the beacon root.", "Single Secret Leader Election Compatibility": "In the future, we may introduce a Single Secret Leader Election (SSLE) mechanism in which only the selected validator knows their role until they propose a block. However, current SSLE designs still rely on a lookahead, albeit an encrypted one. In such designs, we could reuse theproposer_lookaheadfield by changing its type to something likeList[EncryptedValidatorIndex]. And if a construction were to remove lookahead entirely, we could simply setproposer_lookaheadto an empty list, meaning this wouldn\u2019t be a blocker.", "Added Computation at the Epoch Boundary": "Before this EIP, consensus clients only needed to compute the current proposer\u2019s index at each slot. With the changes introduced by this EIP, they must calculate the entire epoch\u2019s proposer schedule at the start of each epoch. However, computing the proposer index is light, involving sampling validators until we reach a validator with sufficient effective balance to be selected as a proposer. Still, testing is needed to confirm that these additional calculations do not create performance bottlenecks in practice.", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "Seethe spec testsin consensus-specs.", "Security Considerations": "A critical consideration for any proposer election mechanism is preventing validators from manipulating lookahead to gain an unfair advantage. This proposal does not increase the chances of such attacks, as we do not alter the \u201cRANDAO delay\u201d used in the lookahead\u2014the lookahead of epochNis still determined by the RANDAO of epochN - MIN_SEED_LOOKAHEAD - 1(which becomes available at the start of epochN - MIN_SEED_LOOKAHEAD). The only difference is that it changes the \u201ceffective balances delay\u201d: rather than using the effective balances (EB) at the start of epochN, it now uses the EB at the start of epochN - MIN_SEED_LOOKAHEAD.", "Malicious Lookahead Alteration": "A critical consideration for any proposer election mechanism is preventing validators from manipulating lookahead to gain an unfair advantage. This proposal does not increase the chances of such attacks, as we do not alter the \u201cRANDAO delay\u201d used in the lookahead\u2014the lookahead of epochNis still determined by the RANDAO of epochN - MIN_SEED_LOOKAHEAD - 1(which becomes available at the start of epochN - MIN_SEED_LOOKAHEAD). The only difference is that it changes the \u201ceffective balances delay\u201d: rather than using the effective balances (EB) at the start of epochN, it now uses the EB at the start of epochN - MIN_SEED_LOOKAHEAD.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- proposer_lookahead: a deterministic value pre-calculated and stored in the beacon state at the start of every epoch"}
{"eip": 7921, "url": "https://eips.ethereum.org/EIPS/eip-7921", "title": "Skip `JUMPDEST` immediate argument check", "authors": ["William Morriss\u00a0(", "@wjmelements", ")"], "sections": {"EIP-7921: Skip `JUMPDEST` immediate argument check": "AllowJUMPandJUMPIto arrive at any byte matchingJUMPDEST(0x5b), even if that byte is an immediate argument.", "All `JUMPDEST` bytes become valid `JUMPDEST`": "AllowJUMPandJUMPIto arrive at any byte matchingJUMPDEST(0x5b), even if that byte is an immediate argument.", "Abstract": "AllowJUMPandJUMPIto arrive at any byte matchingJUMPDEST(0x5b), even if that byte is an immediate argument.", "Motivation": "Immediate arguments are opcode parameters supplied within the code rather than the stack.\nCurrently determining the validity of aJUMPDESTrequires determining which bytes are immediate arguments to other opcodes, such asPUSH1.\nThis presents several problems:", "Specification": "When activated, all0x5bbytes are validJUMPDESTforJUMPIandJUMPopcodes.", "Rationale": "Removing the check solves several problems while reducing EVM complexity.", "Backwards Compatibility": "Code previously only had one interpretation for disassembly.\nWith this change, aJUMPDESTlocated inside an immediate argument can cause multiple disassembly interpretations.\nUsually the interpretations will converge after a few bytes but the length of such a dispute can be unbounded.CODECOPYdata has always been difficult to identify.\nIt is recommended that disassemblers provide all possible interpretations in their output in order to reveal possible underhanded functionality.", "Security Considerations": "Current contracts performing dynamic jumps may gain new unintended functionality if it is possible to jump to an immediate argument containingJUMPDEST.\nIt is expected that very few contracts will become vulnerable in this way.\nMost smart contract programming languages do not even allow dynamic jumps, and of those that do, few will haveJUMPDESTin an accessible immediate argument.\nTherefore it is expected that few contracts will become vulnerable, and for many of them the newly possible codepaths will contain invalid opcodes.\nA static analysis tool should be developed and made publicly available to test if a contract might become vulnerable, and the program should be run for all current contracts in order to notify projects about potential security issues.\nAffected programs will have ample time to migrate.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- codecopy: Data spans used to invalidate subsequent JUMPDEST checks"}
{"eip": 7922, "url": "https://eips.ethereum.org/EIPS/eip-7922", "title": "Dynamic exit queue rate limit", "authors": ["Mikhail Kalinin\u00a0(", "@mkalinin", ")", "Mike Neuder\u00a0(", "@michaelneuder", ")", "Mallesh Pai\u00a0(", "@Mmp610", ")"], "sections": {"EIP-7922: Dynamic exit queue rate limit": "This EIP proposes updating Ethereum\u2019s validator exit churn calculation by dynamically adjusting the churn limit at the start of each 256-epoch period (\u201cgeneration\u201d) based on historical validator exits. Specifically, the maximum churn allowed in each generation will adjust according to the unused churn from the past 16 generations. This approach reduces validator wait times during periods of high exit demandwithout sacrificing network safety.", "Update the validator exit process by dynamically adjusting the churn limit based on historical validator exits.": "This EIP proposes updating Ethereum\u2019s validator exit churn calculation by dynamically adjusting the churn limit at the start of each 256-epoch period (\u201cgeneration\u201d) based on historical validator exits. Specifically, the maximum churn allowed in each generation will adjust according to the unused churn from the past 16 generations. This approach reduces validator wait times during periods of high exit demandwithout sacrificing network safety.", "Abstract": "This EIP proposes updating Ethereum\u2019s validator exit churn calculation by dynamically adjusting the churn limit at the start of each 256-epoch period (\u201cgeneration\u201d) based on historical validator exits. Specifically, the maximum churn allowed in each generation will adjust according to the unused churn from the past 16 generations. This approach reduces validator wait times during periods of high exit demandwithout sacrificing network safety.", "Motivation": "Ethereum currently implements a fixed, rate-limited queue for validator exits to ensure the security and stability of the network. The exit queue ensures the economic security of transactions finalized by the validator set. Suppose a malicious validator could immediately exit the set without any delay. In that case, they may attempt to execute a double spend attack by publishing a block while withholding a conflicting block, which they release after their stake has exited the protocol. The slashing mechanism can no longer hold the malicious validator accountable, and two conflicting finalized transactions may exist (if the attacker has 1/3 of the total stake and successfully splits the 2/3 honest majority in half).", "Specification": "Since the validator exit process is complex, we start with the stack trace and a verbal description of the end-to-end process in Electra.", "Definitions": "Add the following to the state:", "Preset": "Add the following to the state:", "New State Variables": "Add the following to the state:", "Initialization": "Upon activation of this EIP, initialize new variables:", "New Functions": "Design note: This function resets the lookahead generation churn upon switching to the next generation. Ifstate.earliest_exit_epochfalls into the generation earlier than the lookahead, the lookahead generation churn usage is reset. Otherwise, it is marked as fully used.", "Modified Functions": "Replace the existingcompute_exit_epoch_and_update_churnfunction with this simplified MINSLACK-inspired version:", "Rationale": "As we described earlier, by computing unused churn from the previous 14 generations, the churn limit dynamically responds to actual validator behavior. This mechanism:", "Backwards Compatibility": "This EIP requires a hard fork.", "Security Considerations": "Copyright and related rights waived via CC0.", "Copyright": "Copyright and related rights waived via CC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation.\n- churn limit: The maximum number of validators allowed to exit within a given time frame."}
{"eip": 7923, "url": "https://eips.ethereum.org/EIPS/eip-7923", "title": "Linear, Page-Based Memory Costing", "authors": ["Charles Cooper\u00a0(", "@charles-cooper", ")", "Qi Zhou\u00a0(", "@qizhou", ")"], "sections": {"EIP-7923: Linear, Page-Based Memory Costing": "This EIP replaces the quadratic memory model in the EVM with a linear, page-based costing model. Memory is virtually addressable. Page allocation and page thrashing are included in the cost model. After applying this EIP, memory limits are invariant to the state of the message call stack.", "Linearize Memory Costing and replace the current quadratic formula with a page-based cost model.": "This EIP replaces the quadratic memory model in the EVM with a linear, page-based costing model. Memory is virtually addressable. Page allocation and page thrashing are included in the cost model. After applying this EIP, memory limits are invariant to the state of the message call stack.", "Abstract": "This EIP replaces the quadratic memory model in the EVM with a linear, page-based costing model. Memory is virtually addressable. Page allocation and page thrashing are included in the cost model. After applying this EIP, memory limits are invariant to the state of the message call stack.", "Motivation": "The EVM currently uses a quadratic pricing model for its memory. This was originally put in place to defend against DoS attacks. However, the memory model has several drawbacks.", "Specification": "Consider the following constants:", "Rationale": "Benchmarks were performed on a 2019-era CPU, with the ability tokeccak256around 256MB/s, giving it a gas-to-ns ratio of 20 ns per 1 gas (given thatkeccak256costs 6 gas per 32 bytes). The following benchmarks were performed:", "Backwards Compatibility": "Addressed in Security Considerations section. No backwards compatibility is broken, although some contracts that previously ran out of gas may now successfully complete.", "Test Cases": "A ~60-line reference implementation is provided below. It is implemented as a patch against thepy-evmcodebase at commit ethereum/py-evm@fec63b8c4b9dad9fcb1022c48c863bdd584820c6. (This is a reference implementation, it does not, for example, contain fork choice rules).", "Reference Implementation": "A ~60-line reference implementation is provided below. It is implemented as a patch against thepy-evmcodebase at commit ethereum/py-evm@fec63b8c4b9dad9fcb1022c48c863bdd584820c6. (This is a reference implementation, it does not, for example, contain fork choice rules).", "Security Considerations": "There are two primary security considerations regarding this EIP.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 86, "url": "https://eips.ethereum.org/EIPS/eip-86", "title": "Abstraction of transaction origin and signature", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-86: Abstraction of transaction origin and signature": "Implements a set of changes that serve the combined purpose of \u201cabstracting out\u201d signature verification and nonce checking, allowing users to create \u201caccount contracts\u201d that perform any desired signature/nonce checks instead of using the mechanism that is currently hard-coded into transaction processing.", "": "Implements a set of changes that serve the combined purpose of \u201cabstracting out\u201d signature verification and nonce checking, allowing users to create \u201caccount contracts\u201d that perform any desired signature/nonce checks instead of using the mechanism that is currently hard-coded into transaction processing.", "Summary": "Implements a set of changes that serve the combined purpose of \u201cabstracting out\u201d signature verification and nonce checking, allowing users to create \u201caccount contracts\u201d that perform any desired signature/nonce checks instead of using the mechanism that is currently hard-coded into transaction processing.", "Parameters": "Ifblock.number >= METROPOLIS_FORK_BLKNUM, then:", "Specification": "Ifblock.number >= METROPOLIS_FORK_BLKNUM, then:", "Rationale": "The goal of these changes is to set the stage for abstraction of account security. Instead of having an in-protocol mechanism where ECDSA and the default nonce scheme are enshrined as the only \u201cstandard\u201d way to secure an account, we take initial steps toward a model where in the long term all accounts are contracts, contracts can pay for gas, and users are free to define their own security model.", "Miner and transaction replaying strategy": "Note that miners would need to have a strategy for accepting these transactions. This strategy would need to be very discriminating, because otherwise they run the risk of accepting transactions that do not pay them any fees, and possibly even transactions that have no effect (eg. because the transaction was already included and so the nonce is no longer current).", "Copyright": "Copyright and related rights waived via CC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 101, "url": "https://eips.ethereum.org/EIPS/eip-101", "title": "Serenity Currency and Crypto Abstraction", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-101: Serenity Currency and Crypto Abstraction": "Note thatECRECOVER, sequence number/nonce incrementing and ether are now nowhere in the bottom-level spec (NOTE: ether is going to continue to have a privileged role in Casper PoS). To replicate existing functionality under the new model, we do the following.", "": "Note thatECRECOVER, sequence number/nonce incrementing and ether are now nowhere in the bottom-level spec (NOTE: ether is going to continue to have a privileged role in Casper PoS). To replicate existing functionality under the new model, we do the following.", "Specification": "Note thatECRECOVER, sequence number/nonce incrementing and ether are now nowhere in the bottom-level spec (NOTE: ether is going to continue to have a privileged role in Casper PoS). To replicate existing functionality under the new model, we do the following.", "Rationale": "This allows for a large increase in generality, particularly in a few\nareas:", "Implementation": "Coming soon.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- serenity currency and crypto abstraction: Introduces the concept of abstracting away the native Ether storage within accounts. Instead of Ether being stored directly, a contract at address 0 manages all Ether. Transactions no longer use msg.value, and a tx.gas opcode is added to access the original amount of gas.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 210, "url": "https://eips.ethereum.org/EIPS/eip-210", "title": "Blockhash refactoring", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-210: Blockhash refactoring": "Stores blockhashes in the state, reducing the protocol complexity and the need for client implementation complexity in order to process the BLOCKHASH opcode. Also extends the range of how far back blockhash checking can go, with the side effect of creating direct links between blocks with very distant block numbers, facilitating much more efficient initial light client syncing.", "": "Stores blockhashes in the state, reducing the protocol complexity and the need for client implementation complexity in order to process the BLOCKHASH opcode. Also extends the range of how far back blockhash checking can go, with the side effect of creating direct links between blocks with very distant block numbers, facilitating much more efficient initial light client syncing.", "Summary": "Stores blockhashes in the state, reducing the protocol complexity and the need for client implementation complexity in order to process the BLOCKHASH opcode. Also extends the range of how far back blockhash checking can go, with the side effect of creating direct links between blocks with very distant block numbers, facilitating much more efficient initial light client syncing.", "Parameters": "Ifblock.number == CONSTANTINOPLE_FORK_BLKNUM, then when processing the block, before processing any transactions set the code of BLOCKHASH_CONTRACT_ADDR to BLOCKHASH_CONTRACT_CODE.", "Specification": "Ifblock.number == CONSTANTINOPLE_FORK_BLKNUM, then when processing the block, before processing any transactions set the code of BLOCKHASH_CONTRACT_ADDR to BLOCKHASH_CONTRACT_CODE.", "BLOCKHASH_CONTRACT_CODE": "The Serpent source code is:", "Rationale": "This removes the need for implementations to have an explicit way to look into historical block hashes, simplifying the protocol definition and removing a large component of the \u201cimplied state\u201d (information that is technically state but is not part of the state tree) and thereby making the protocol more \u201cpure\u201d. Additionally, it allows blocks to directly point to blocks far behind them, which enables extremely efficient and secure light client protocols.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- blockhash refactoring: Refactors the way blockhashes are stored in the state to simplify the protocol and enable more efficient light client synchronization.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 615, "url": "https://eips.ethereum.org/EIPS/eip-615", "title": "Subroutines and Static Jumps for the EVM", "authors": ["Greg Colvin\u00a0<", "greg@colvin.org", ">", "Brooklyn Zelenka\u00a0(", "@expede", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Christian Reitwiessner\u00a0(", "@chriseth", ")"], "sections": {"EIP-615: Subroutines and Static Jumps for the EVM": "In the 21st century, on a blockchain circulating billions of ETH, formal specification and verification are an essential tool against loss. Yet the design of the EVM makes this unnecessarily difficult. Further, the design of the EVM makes near-linear-time compilation to machine code difficult. We propose to move forward with proposals to resolve these problems by tightening EVM security guarantees and reducing barriers to performance.", "": "In the 21st century, on a blockchain circulating billions of ETH, formal specification and verification are an essential tool against loss. Yet the design of the EVM makes this unnecessarily difficult. Further, the design of the EVM makes near-linear-time compilation to machine code difficult. We propose to move forward with proposals to resolve these problems by tightening EVM security guarantees and reducing barriers to performance.", "Simple Summary": "In the 21st century, on a blockchain circulating billions of ETH, formal specification and verification are an essential tool against loss. Yet the design of the EVM makes this unnecessarily difficult. Further, the design of the EVM makes near-linear-time compilation to machine code difficult. We propose to move forward with proposals to resolve these problems by tightening EVM security guarantees and reducing barriers to performance.", "Abstract": "EVM code is currently difficult to statically analyze, hobbling critical tools for preventing the many expensive bugs our blockchain has experienced. Further, none of the current implementations of the Ethereum Virtual Machine\u2014including the compilers\u2014are sufficiently performant to reduce the need for precompiles and otherwise meet the network\u2019s long-term demands.  This proposal identifies dynamic jumps as a major reason for these issues, and proposes changes to the EVM specification to address the problem, making further efforts towards a safer and more performant the EVM possible.", "Motivation": "Currently the EVM supports only dynamic jumps, where the address to jump to is an argument on the stack.  Worse, the EVM fails to provide ordinary, alternative control flow facilities like subroutines and switches provided by Wasm and most CPUs.  So dynamic jumps cannot be avoided, yet they obscure the structure of the code and thus mostly inhibit control- and data-flow analysis.  This puts the quality and speed of optimized compilation fundamentally at odds.  Further, since many jumps can potentially be to any jump destination in the code, the number of possible paths through the code can go up as the product of the number of jumps by the number of destinations, as does the time complexity of static analysis.  Many of these cases are undecidable at deployment time, further inhibiting static and formal analyses.", "Specification": "We propose to deprecate two existing instructions\u2014JUMPandJUMPI\u2014and propose new instructions to support their legitimate uses.  In particular, it must remain possible to compile Solidity and Vyper code to EVM bytecode, with no significant loss of performance or increase in gas price.", "Dependencies": "We propose to deprecate two existing instructions\u2014JUMPandJUMPI\u2014and propose new instructions to support their legitimate uses.  In particular, it must remain possible to compile Solidity and Vyper code to EVM bytecode, with no significant loss of performance or increase in gas price.", "Proposal": "We propose to deprecate two existing instructions\u2014JUMPandJUMPI\u2014and propose new instructions to support their legitimate uses.  In particular, it must remain possible to compile Solidity and Vyper code to EVM bytecode, with no significant loss of performance or increase in gas price.", "Semantics": "Jumps to and returns from subroutines are described here in terms of", "Validity": "We would like to consider EVM code valid iff no execution of the program can lead to an exceptional halting state, but we must validate code in linear time. So our validation does not consider the code\u2019s data and computations, only its control flow and stack use.  This means we will reject programs with invalid code paths, even if those paths are not reachable.  Most conditions can be validated, and will not need to be checked at runtime; the exceptions are sufficient gas and sufficient stack.  As such, static analysis may yield false negatives belonging to well-understood classes of code requiring runtime checks.  Aside from those cases, we can validate large classes at validation time and with linear complexity.", "Backwards Compatibility": "These changes would need to be implemented in phases at decent intervals:", "Rationale": "This design was highly constrained by the existing EVM semantics, the requirement for eWasm compatibility, and the security demands of the Ethereum environment.  It was also informed by the lead author\u2019s previous work implementing Java and Scheme interpreters.  As such there was very little room for alternative designs.", "Implementation": "Implementation of this proposal need not be difficult.  At the least, interpreters can simply be extended with the new opcodes and run unchanged otherwise.  The new opcodes require only stacks for the frame pointers and return offsets and the few pushes, pops, and assignments described above. The bulk of the effort is the validator, which in most languages can almost be transcribed from the pseudocode above.", "Appendix A": "Validation comprises two tasks:", "Validation": "Validation comprises two tasks:", "Appendix B": "There is a large and growing ecosystem of researchers, authors, teachers, auditors, and analytic tools\u2013providing software and services focused on the correctness and security of EVM code.  A small sample is given here.", "EVM Analysis": "There is a large and growing ecosystem of researchers, authors, teachers, auditors, and analytic tools\u2013providing software and services focused on the correctness and security of EVM code.  A small sample is given here.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- subroutines and static jumps: Proposes static jumps and subroutines for the EVM to replace dynamic jumps, enhancing performance, formal verification, and code security.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 616, "url": "https://eips.ethereum.org/EIPS/eip-616", "title": "SIMD Operations for the EVM", "authors": ["Greg Colvin\u00a0<", "greg@colvin.org", ">"], "sections": {"EIP-616: SIMD Operations for the EVM": "A proposal to provide Single Instruction Multiple Data types and operations for the Ethereum Virtual Machine, making full use of the 256-bit wide EVM stack items, and offering substantial performance gains for both vector and scalar operations.", "": "A proposal to provide Single Instruction Multiple Data types and operations for the Ethereum Virtual Machine, making full use of the 256-bit wide EVM stack items, and offering substantial performance gains for both vector and scalar operations.", "ABSTRACT": "A proposal to provide Single Instruction Multiple Data types and operations for the Ethereum Virtual Machine, making full use of the 256-bit wide EVM stack items, and offering substantial performance gains for both vector and scalar operations.", "MOTIVATION": "Most all modern CPUs include SIMD hardware that operates on wide registers of data, applying a Single Instruction to Multiple Data lanes in parallel, where lanes divide a register into a vector of scalar elements of equal size.  This model is an excellent fit for the wide stack items of the EVM, offering substantial performance boosts for operations that can be expressed as parallel operations on vectors of scalars.  For some examples, a brief literature search finds SIMD speedups of", "SPECIFICATION": "We propose a simple encoding of SIMD operations as extended two-byte codes.  The first byte is the opcode, and the second byte is the SIMD type: scalar type, lane width, and number of elements.", "Encoding": "We propose a simple encoding of SIMD operations as extended two-byte codes.  The first byte is the opcode, and the second byte is the SIMD type: scalar type, lane width, and number of elements.", "Semantics": "We define the following extended versions of the EVM\u2019s arithmetic, logic, and comparison operations.  As with the normal versions, they consume their arguments from the stack and place their results on the stack, except that their arguments are vectors rather than scalars.", "Subroutines": "IfEIP-187is accepted a type-safe syntax for declaring subroutines taking vector arguments will be needed.", "RATIONALE": "Currently, the lowest common denominator for SIMD hardware (e.g. Intel SSE2 and ARM Neon) is 16-byte registers supporting integer lanes of 1, 2, 4, and 8 bytes, and floating point lanes of 4 and 8 bytes.  More recent SIMD hardware (e.g. Intel AVX) supports 32-byte registers, and EVM stack items are also 32 bytes wide.  The limits above derive from these numbers, assuring that EVM code is within the bounds of available hardware - and the reserved bits provide room for growth.", "Gas": "One motivation for these operations, besides taking full advantage of the hardware, is assigning lower gas costs for operations on smaller scalars.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- simd operations for the evm: Suggests adding SIMD (Single Instruction Multiple Data) operations to the EVM, utilizing 256-bit stack items for parallel computation, boosting performance for certain cryptographic algorithms and vectorized operations.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 665, "url": "https://eips.ethereum.org/EIPS/eip-665", "title": "Add precompiled contract for Ed25519 signature verification", "authors": ["Tobias Oberstein\u00a0<", "tobias.oberstein@crossbario.com", ">"], "sections": {"EIP-665: Add precompiled contract for Ed25519 signature verification": "Support performant and cheap verification of Ed25519 cryptographic signatures in smart contracts in general by adding a precompiled contract for Ed25519 signature verification to the EVM.", "": "Support performant and cheap verification of Ed25519 cryptographic signatures in smart contracts in general by adding a precompiled contract for Ed25519 signature verification to the EVM.", "Simple Summary": "Support performant and cheap verification of Ed25519 cryptographic signatures in smart contracts in general by adding a precompiled contract for Ed25519 signature verification to the EVM.", "Abstract": "Verification of Ed25519 cryptographic signatures is obviously possible in EVM bytecode. However, the gas cost will be very high, and computationally expensive, as such tight, wide word operations intensive code as required for Ed25519 is not a good fit for the EVM bytecode model.", "Motivation": "Ed25519 and Ed448 (that is, EdDSA using Curve25519 or Curve448) are IETF recommendations (RFC7748) with some attractive properties:", "Specification": "Ifblock.number >= CONSTANTINOPLE_FORK_BLKNUM, add a precompiled contract for Ed25519 signature verification (ED25519VFY).", "Address": "The address ofED25519VFYis0x9.", "Gas costs": "Gas cost forED25519VFYis2000.", "Rationale": "The proposedED25519VFYfunction takes the signer public key as a call parameter, as with Ed25519, I don\u2019t believe it is possible to derive the signers public key from the signature and message alone.", "Backwards Compatibility": "As the proposed precompiled contract is deployed at a reserved (<255) and previously unused address, an implementation of the proposal should not introduce any backward compatibility issues.", "Test Cases": "Test vectors for Ed25519 can be found in this IETF ID https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-6.", "Implementation": "libsodium is a mature, high-quality C implementation of Ed25519, with bindings for many languages.", "libsodium": "libsodium is a mature, high-quality C implementation of Ed25519, with bindings for many languages.", "libsodium bindings": "Here is an overview of the language bindings to libsodium for four Ethereum clients this proposal recommends:", "PRs": "Implementations of this proposal are here:", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 689, "url": "https://eips.ethereum.org/EIPS/eip-689", "title": "Address Collision of Contract Address Causes Exceptional Halt", "authors": ["Yoichi Hirai\u00a0<", "i@yoichihirai.com", ">"], "sections": {"EIP-689: Address Collision of Contract Address Causes Exceptional Halt": "This EIP proposes to make contract creation fail on an account with nonempty code or non-zero nonce.", "": "This EIP proposes to make contract creation fail on an account with nonempty code or non-zero nonce.", "Simple Summary": "This EIP proposes to make contract creation fail on an account with nonempty code or non-zero nonce.", "Abstract": "Some test cases in the consensus test suite try to deploy a contract at an address already with nonempty code. Although such cases can virtually never happen on the main network before the Constantinople fork block, the test cases detected discrepancies in clients\u2019 behavior.  Currently, the Yellow Paper says that the contract creation starts with the empty code and the initial nonce even in the case of address collisions. To simplify the semantics, this EIP proposes that address collisions cause failures of contract creation.", "Motivation": "This EIP has no practical relevance to the main net history, but simplifies testing and reasoning.", "Specification": "Ifblock.number >= 0, when a contract creation is on an account with non-zero nonce or non-empty code, the creation fails as if init code execution resulted in an exceptional halt.  This applies to contract creation triggered by a contract creation transaction and by CREATE instruction.", "Rationale": "It seems impractical to implement never-used features just for passing tests.  Client implementations will be simpler with this EIP.", "Backwards Compatibility": "This EIP is backwards compatible on the main network.", "Test Cases": "At least the BlockchainTest calledcreateJS\\_ExampleContract\\_d0g0v0\\_EIP158will distinguish clients that implement this EIP.", "Implementation": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 698, "url": "https://eips.ethereum.org/EIPS/eip-698", "title": "OPCODE 0x46 BLOCKREWARD", "authors": ["Cody Burns\u00a0<", "dontPanic@codywburns.com", ">"], "sections": {"EIP-698: OPCODE 0x46 BLOCKREWARD": "This EIP adds an additional opcode to the EVM which will return a finalized blocks reward value.", "": "This EIP adds an additional opcode to the EVM which will return a finalized blocks reward value.", "Simple Summary": "This EIP adds an additional opcode to the EVM which will return a finalized blocks reward value.", "Abstract": "In the EVM, the 0x40 opcodes are reserved forBlock Information. Currently reserved opcodes are:", "Motivation": "Per EIP-649 ( #669 ) periodic block reward reductions/variance are now planned in the roadmap, however, this EIP is consensus system agnostic and is most useful in decentralized pool operations and for any contract that benefits from knowing a block reward payout(i.e. Merge mined tokens)", "Specification": "After blocknall clients should process opcode0x46as follows:", "Rationale": "For distributed consensus systems(staking pools and mining pools) ad hoc groups combine resources in order to reduce variance in payouts. Broadly, pool operations function by allowing a collective of  miners / stakers  to verify their contribution to solving PoW or staking share by periodically submitting solutions which are representative of the miners probability of finding a true block.", "Contract Mining Pools": "For distributed consensus systems(staking pools and mining pools) ad hoc groups combine resources in order to reduce variance in payouts. Broadly, pool operations function by allowing a collective of  miners / stakers  to verify their contribution to solving PoW or staking share by periodically submitting solutions which are representative of the miners probability of finding a true block.", "Merge mined tokens": "Contracts could create tokens which could be variably \u2018minted\u2019 as a function of block reward by calling0x46", "Backwards Compatibility": "No impact", "Currently deployed contracts": "No impact", "Current clients": "This EIP would be incompatible with currently deployed clients that are not able to handle0x46and would process all transactions and block containing the opcode as invalid.", "Implementation": "Mining Pools", "Further reading": "Mining Pools", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 858, "url": "https://eips.ethereum.org/EIPS/eip-858", "title": "Reduce block reward and delay difficulty bomb", "authors": ["Carl Larson\u00a0<", "cslarson@gmail.com", ">"], "sections": {"EIP-858: Reduce block reward and delay difficulty bomb": "Reduce the block reward to 1 ETH and delay the difficulty bomb.", "": "Reduce the block reward to 1 ETH and delay the difficulty bomb.", "Simple Summary": "Reduce the block reward to 1 ETH and delay the difficulty bomb.", "Abstract": "The current public Ethereum network has a hashrate that corresponds to a tremendous level of energy consumption. As this energy consumption has a correlated environmental cost the network participants have an ethical obligation to ensure this cost is not higher than necessary. At this time, the most direct way to reduce this cost is to lower the block reward in order to limit the appeal of ETH mining. Unchecked growth in hashrate is also counterproductive from a security standpoint.\nRecent research developments also now time the switch to POS as sometime in 2019 and as a result there is need to further delay the difficulty bomb so the network doesn\u2019t grind to a halt.", "Motivation": "The current public Ethereum network has a hashrate of 296 TH/s. This hashrate corresponds to a power usage of roughly1 TWand yearly energy consumption of 8.8 TWh (roughly 0.04% oftotalglobal electricity consumption). A future switch to full Proof of Stake will solve this issue entirely. Yet that switch remains enough in the future that action should be taken in the interim to limit excess harmful side affects of the present network.", "Specification": "Delay difficulty bomb by 2,000,000 blocks\nAdjust block, uncle, and nephew rewards to reflect a new block reward of 1 ETH.", "Rationale": "This will delay the difficulty bomb by roughly a year. The difficulty bomb remains a community supported mechanism to aid a future transition to POS.", "Backwards Compatibility": "This EIP is consensus incompatible with the current public Ethereum chain and would cause a hard fork when enacted. The resulting fork would allow users to chose between two chains: a chain with a block reward of 1 ETH/block and another with a block reward of 3 ETH/block. This is a good choice to allow users to make. In addition, the difficulty bomb would be delayed - ensuring the network would not grind to a halt.", "Test Cases": "Tests have, as yet, not been completed.", "Implementation": "No implementation including both block reward and difficulty adjustment is currently available.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- reduce block reward and delay difficulty bomb: Proposes reducing the block reward to 1 ETH and delaying the difficulty bomb to mitigate energy consumption and control mining growth.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 969, "url": "https://eips.ethereum.org/EIPS/eip-969", "title": "Modifications to ethash to invalidate existing dedicated hardware implementations", "authors": ["David Stanfill\u00a0<", "david@airsquirrels.com", ">"], "sections": {"EIP-969: Modifications to ethash to invalidate existing dedicated hardware implementations": "This EIP modifies ethash in order to break ASIC miners specialized for the current ethash\nmining algorithm.", "": "This EIP modifies ethash in order to break ASIC miners specialized for the current ethash\nmining algorithm.", "Simple Summary": "This EIP modifies ethash in order to break ASIC miners specialized for the current ethash\nmining algorithm.", "Abstract": "There are companies who currently have dedicated hardware based ethereum miners in\nproduction, and may be actively mining.  This EIP aims to \u201cpoison\nthe well\u201d by modifying the block mining algorithm in a low risk manner that\nmay\u201cbreak\u201dthese miners if they are in-fact built as traditional ASICs.", "Motivation": "ASIC-based miners will have lower operational costs than GPU-based miners, which\nwill result in GPU-based mining quickly becoming unprofitable.  Given that\nproduction of ASIC-based miners has a high barrier to entry and few market players,\nthis will cause a trend towards centralization of mining power.", "Specification": "Ifblock.number >= ASIC_MITIGATION_FORK_BLKNUM, require that the ethash solution\nsealing the block has been mined usingethashV2.", "EthashV2": "ethashV2will be identical in specification to the currentethash(v1) algorithm, with\nthe exception of the implementation offnv.", "Agent Changes (Optional Variant)": "The JSON-RPCeth_GetWorkcall may optionally return the proposed blocks algorithm.\nWhile a miner or pool may infer the requirement forethashV2based on the computed\nepoch of the provided seedHash, it is beneficial to explicitly provide this\nfield so a miner does not require special configuration when mining on a chain\nthat chooses not to implement theASIC_Mitigationhardfork.", "Rationale": "This EIP is aimed at breaking existing ASIC-based miners via small changes to the\nexisting ethash algorithm.  We hope to accomplish the following:", "Backwards Compatibility": "This change implements a backwards incompatible change to proof of work based\nblock mining.  All existing miners will be required to update to clients which\nimplement this new algorithm, and all nodes will require updates to accept\nsolutions from the new proof of work algorithm.", "Test Cases": "TODO: will need to generate test cases forethereum/testsrepository corresponding to the consensus\nchanges.", "Implementation": "TODO", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1010, "url": "https://eips.ethereum.org/EIPS/eip-1010", "title": "Uniformity Between 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B and 0x15E55EF43efA8348dDaeAa455F16C43B64917e3c", "authors": ["Anderson Wesley\u00a0(", "@andywesley", ")"], "sections": {"EIP-1010: Uniformity Between 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B and 0x15E55EF43efA8348dDaeAa455F16C43B64917e3c": "This document proposes to improve the uniformity of ether distribution\nbetween wallet address0xAb5801a7D398351b8bE11C439e05C5B3259aeC9Band\nwallet address0x15E55EF43efA8348dDaeAa455F16C43B64917e3cwhich are\ncurrently experiencing a significant non-uniformity.", "": "This document proposes to improve the uniformity of ether distribution\nbetween wallet address0xAb5801a7D398351b8bE11C439e05C5B3259aeC9Band\nwallet address0x15E55EF43efA8348dDaeAa455F16C43B64917e3cwhich are\ncurrently experiencing a significant non-uniformity.", "Simple Summary": "This document proposes to improve the uniformity of ether distribution\nbetween wallet address0xAb5801a7D398351b8bE11C439e05C5B3259aeC9Band\nwallet address0x15E55EF43efA8348dDaeAa455F16C43B64917e3cwhich are\ncurrently experiencing a significant non-uniformity.", "Abstract": "As of the date of this EIP, the difference in balance between\naddress0xAb5801a7D398351b8bE11C439e05C5B3259aeC9Band address0x15E55EF43efA8348dDaeAa455F16C43B64917e3cis far from equitable\nor uniform, with the former having more than 365,000 ether\nmore than the latter. The distribution of ether between these two\naddresses must be improved in order to protect the Ethereum economy\nfrom centralized control. This will be accomplished by transferring\n100,000 ether from the former address to the latter. This is a properly\nmotivated improvement in keeping with the core Ethereum philosophy of\ndecentralization.", "Motivation": "This proposal is necessary because the Ethereum protocol does not allow\nthe owner of an address which does not own an equitable amount of ether\nto claim their share of ether from an address which owns a dangerously\ncentralized quantity. Rather than proposing an overly complicated generic\nmechanism for any user to claim ether to which they believe they are\nequitably entitled, this proposal will take the simple route of a one-time\ntransfer of 100,000 ether from0xAb5801a7D398351b8bE11C439e05C5B3259aeC9Bto0x15E55EF43efA8348dDaeAa455F16C43B64917e3c. This avoids duplicating\nthe effort of other proposals and provides a net improvement to the\nEthereum project and community.", "Specification": "The balance of0xAb5801a7D398351b8bE11C439e05C5B3259aeC9Bwill be decreased\nby 100,000 ether. The balance of0x15E55EF43efA8348dDaeAa455F16C43B64917e3cwill be increased by 100,000 ether. No net change in the amount of extant\nether will occur unless at the time of implementation the former address does not\ncontain sufficient ether for such a deduction.", "Rationale": "The value 100,000 was chosen after careful technically sound analysis of various economic theories\ndeveloped over the past century. In spite of the fact that it is a convenient round\nnumber, it is actually the exact output of a complex statistical process iterated to\ndetermine the optimal distribution of ether between these addresses.", "Backwards Compatibility": "Clients that fail to implement this change will not be aware of the correct balances\nfor these addresses. This will create a hard fork. The implementation of this change\nconsistently among all clients as intended by the proposal process will be sufficient\nto ensure that backwards compatibility is not a concern.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1011, "url": "https://eips.ethereum.org/EIPS/eip-1011", "title": "Hybrid Casper FFG", "authors": ["Danny Ryan\u00a0(", "@djrtwo", ")", "Chih-Cheng Liang\u00a0(", "@ChihChengLiang", ")"], "sections": {"EIP-1011: Hybrid Casper FFG": "Specification of the first step to transition Ethereum main net from Proof of Work (PoW) to Proof of Stake (PoS). The resulting consensus model is a PoW/PoS hybrid.", "": "Specification of the first step to transition Ethereum main net from Proof of Work (PoW) to Proof of Stake (PoS). The resulting consensus model is a PoW/PoS hybrid.", "Simple Summary": "Specification of the first step to transition Ethereum main net from Proof of Work (PoW) to Proof of Stake (PoS). The resulting consensus model is a PoW/PoS hybrid.", "Abstract": "This EIP specifies a hybrid PoW/PoS consensus model for Ethereum main net. Existing PoW mechanics are used for new block creation, and a novel PoS mechanism called Casper the Friendly Finality Gadget (FFG) is layered on top using a smart contract.", "Glossary": "Transitioning the Ethereum network from PoW to PoS has been on the roadmap and in theYellow Papersince the launch of the protocol. Although effective in coming to a decentralized consensus, PoW consumes an incredible amount of energy, has no economic finality, and has no effective strategy in resisting cartels. Excessive energy consumption, issues with equal access to mining hardware, mining pool centralization, and an emerging market of ASICs each provide a distinct motivation to make the transition as soon as possible.", "Motivation": "Transitioning the Ethereum network from PoW to PoS has been on the roadmap and in theYellow Papersince the launch of the protocol. Although effective in coming to a decentralized consensus, PoW consumes an incredible amount of energy, has no economic finality, and has no effective strategy in resisting cartels. Excessive energy consumption, issues with equal access to mining hardware, mining pool centralization, and an emerging market of ASICs each provide a distinct motivation to make the transition as soon as possible.", "Parameters": "Ifblock.number == HYBRID_CASPER_FORK_BLKNUM, then when processing the block before processing any transactions:", "Casper Contract Parameters": "Ifblock.number == HYBRID_CASPER_FORK_BLKNUM, then when processing the block before processing any transactions:", "Specification": "Ifblock.number == HYBRID_CASPER_FORK_BLKNUM, then when processing the block before processing any transactions:", "Rationale": "Naive PoS specifications and implementations have existed since early blockchain days, but most are vulnerable to serious attacks and do not hold up under crypto-economic analysis. Casper FFG solves problems such as \u201cNothing at Stake\u201d and \u201cLong Range Attacks\u201d through requiring validators to post slashable deposits and through defining economic finality.", "Backwards Compatibility": "This EIP is not forward compatible and introduces backwards incompatibilities in the state, fork choice rule, block reward, transaction validity, and gas calculations on certain transactions. Therefore, all changes should be included in a scheduled hardfork atHYBRID_CASPER_FORK_BLKNUM.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- hybrid casper ffg: Specifies a hybrid consensus model combining Proof of Work (PoW) and Proof of Stake (PoS), known as Casper FFG, to provide finality and reduce energy consumption in Ethereum's transition to PoS.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1015, "url": "https://eips.ethereum.org/EIPS/eip-1015", "title": "Configurable On Chain Issuance", "authors": ["Alex Van de Sande\u00a0<", "avsa@ethereum.org", ">"], "sections": {"EIP-1015: Configurable On Chain Issuance": "This EIP changes the block reward step by instead of setting it to be hard coded on the clients and to be given to the miner/validator etherbase, it should instead go to an address decided by an on-chain contract, with hard limits on how it would be issued (six month lock-in; issuance can only decrease or be maintained, but not increase;). A decision method is suggested but not essential to the notion of this EIP. This wouldnot be a generic governance solution, which is a much broader and harder topic, wouldnotaffect technical upgrade decisions or other hard forks, but seen asa forum to attempt to prevent contentious hard forksthat can be solved with the issuance.", "": "This EIP changes the block reward step by instead of setting it to be hard coded on the clients and to be given to the miner/validator etherbase, it should instead go to an address decided by an on-chain contract, with hard limits on how it would be issued (six month lock-in; issuance can only decrease or be maintained, but not increase;). A decision method is suggested but not essential to the notion of this EIP. This wouldnot be a generic governance solution, which is a much broader and harder topic, wouldnotaffect technical upgrade decisions or other hard forks, but seen asa forum to attempt to prevent contentious hard forksthat can be solved with the issuance.", "Simple Summary": "This EIP changes the block reward step by instead of setting it to be hard coded on the clients and to be given to the miner/validator etherbase, it should instead go to an address decided by an on-chain contract, with hard limits on how it would be issued (six month lock-in; issuance can only decrease or be maintained, but not increase;). A decision method is suggested but not essential to the notion of this EIP. This wouldnot be a generic governance solution, which is a much broader and harder topic, wouldnotaffect technical upgrade decisions or other hard forks, but seen asa forum to attempt to prevent contentious hard forksthat can be solved with the issuance.", "Summary": "These are current EIPs that are being developed or debated. They might seem unrelated but they have something in common, that they can be resolved by proper channel of funds.", "Thesis: many controversial issues boil down to resources": "These are current EIPs that are being developed or debated. They might seem unrelated but they have something in common, that they can be resolved by proper channel of funds.", "Proposed Solution": "This EIP proposes a future hard fork where block reward is not issued to miners/validators etherbase, but instead to a single contract, that then will activate the default function (with a fixed amount of gas) and then it will forward the ether to other contracts which will finally distribute to their final destinations.", "Issuance Contract": "This EIP proposes a future hard fork where block reward is not issued to miners/validators etherbase, but instead to a single contract, that then will activate the default function (with a fixed amount of gas) and then it will forward the ether to other contracts which will finally distribute to their final destinations.", "Questions to be debated": "A lot of things are suggested in this EIP, so I would like to propose these questions to be debated:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1051, "url": "https://eips.ethereum.org/EIPS/eip-1051", "title": "Overflow checking for the EVM", "authors": ["Nick Johnson\u00a0<", "arachnid@notdot.net", ">"], "sections": {"EIP-1051: Overflow checking for the EVM": "This EIP adds overflow checking for EVM arithmetic operations, and two new opcodes that check and clear the overflow flags.", "": "This EIP adds overflow checking for EVM arithmetic operations, and two new opcodes that check and clear the overflow flags.", "Abstract": "This EIP adds overflow checking for EVM arithmetic operations, and two new opcodes that check and clear the overflow flags.", "Motivation": "The correct functioning of many contracts today is dependent on detecting and preventing overflow of arithmetic operations. Since the EVM operates on mod 2^256 integers and provides no built-in overflow detection or prevention, this requires manual checks on every arithmetic operation.", "Specification": "Two new flags are added to the EVM state: overflow (ovf) and signed overflow (sovf).", "Rationale": "Any change to implement overflow protection needs to preserve behaviour of existing contracts, which precludes many changes to the arithmetic operations themselves. One option would be to provide an opcode that enables overflow protection, causing a throw or revert if an overflow happens. However, this limits the manner in which overflows can be handled.", "Backwards Compatibility": "This EIP introduces no backwards compatibility issues.", "Test Cases": "TBD", "Implementation": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- overflow checking for the evm: Adds overflow detection for arithmetic operations in the EVM, introducing two new opcodes (OFV and SOVF) to check and clear overflow flags.\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1057, "url": "https://eips.ethereum.org/EIPS/eip-1057", "title": "ProgPoW, a Programmatic Proof-of-Work", "authors": ["Greg Colvin\u00a0<", "greg@colvin.org", ">", "Andrea Lanfranchi\u00a0(", "@AndreaLanfranchi", ")", "Michael Carter\u00a0(", "@bitsbetrippin", ")", "IfDefElse\u00a0<", "ifdefelse@protonmail.com", ">"], "sections": {"EIP-1057: ProgPoW, a Programmatic Proof-of-Work": "A new Proof-of-Work algorithm to replace Ethash that utilizes almost all parts of commodity GPUs.", "": "A new Proof-of-Work algorithm to replace Ethash that utilizes almost all parts of commodity GPUs.", "Simple Summary": "A new Proof-of-Work algorithm to replace Ethash that utilizes almost all parts of commodity GPUs.", "Abstract": "ProgPoW is a proof-of-work algorithm designed to close the efficiency gap available to specialized ASICs. It utilizes almost all parts of commodity hardware (GPUs), and comes pre-tuned for the most common hardware utilized in the Ethereum network.", "Motivation": "Ever since the first bitcoin mining ASIC was released, many new Proof of Work algorithms have been created with the intention of being \u201cASIC-resistant\u201d. The goal of \u201cASIC-resistance\u201d is to resist the centralization of PoW mining power such that these coins couldn\u2019t be so easily manipulated by a few players.", "ProgPoW Overview": "The design goal of ProgPoW is to have the algorithm\u2019s requirements match what is available on commodity GPUs:  If the algorithm were to be implemented on a custom ASIC there should be little opportunity for efficiency gains compared to a commodity GPU.", "Rationale for PoW on Commodity Hardware": "With the growth of large mining pools, the control of hashing power has been delegated to the top few pools to provide a steadier economic return for small miners. While some have made the argument that large centralized pools defeats the purpose of \u201cASIC resistance,\u201d it\u2019s important to note that ASIC based coins are even more centralized for several reasons.", "Review of Existing PoW Algorithms": "The SHA algorithm is a sequence of simple math operations - additions, logical ops, and rotates.", "Specification": "ProgPoW can be tuned using the following parameters.  The proposed settings have been tuned for a range of existing, commodity GPUs:", "Security Considerations": "This proposal has been software and hardware audited:", "Test Cases": "The random sequence generated for block 30,000 (prog_seed 3,000) can been seen inkernel.cu.", "Implementation": "The reference ProgPoW mining implementation is located atthe @ifdefelse ProgPOW repository.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- progpow: A new Proof-of-Work algorithm designed to be ASIC-resistant by utilizing more parts of commodity GPUs, minimizing the efficiency gap between general-purpose hardware and specialized ASICs.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1087, "url": "https://eips.ethereum.org/EIPS/eip-1087", "title": "Net gas metering for SSTORE operations", "authors": ["Nick Johnson\u00a0(", "@arachnid", ")"], "sections": {"EIP-1087: Net gas metering for SSTORE operations": "This EIP proposes a change to how gas is charged for EVMSSTOREoperations, in order to reduce excessive gas costs in situations where these are unwarranted, and to enable new use-cases for contract storage.", "": "This EIP proposes a change to how gas is charged for EVMSSTOREoperations, in order to reduce excessive gas costs in situations where these are unwarranted, and to enable new use-cases for contract storage.", "Abstract": "This EIP proposes a change to how gas is charged for EVMSSTOREoperations, in order to reduce excessive gas costs in situations where these are unwarranted, and to enable new use-cases for contract storage.", "Motivation": "Presently,SSTORE(0x55) operations are charged as follows:", "Specification": "The following changes are made to the EVM:", "Rationale": "We believe the proposed mechanism represents the simplest way to reduce storage gas costs in situations where they do not reflect the actual costs borne by nodes. Several alternative designs were considered and dismissed:", "Backwards Compatibility": "This EIP requires a hard fork to implement.", "Test Cases": "TBD", "Implementation": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- net gas metering for sstore: Updates the gas cost for the SSTORE opcode based on the original, current, and new storage values, improving efficiency for contracts with frequent storage updates.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1109, "url": "https://eips.ethereum.org/EIPS/eip-1109", "title": "PRECOMPILEDCALL opcode (Remove CALL costs for precompiled contracts)", "authors": ["Jordi Baylina\u00a0(", "@jbaylina", ")"], "sections": {"EIP-1109: PRECOMPILEDCALL opcode (Remove CALL costs for precompiled contracts)": "This EIP creates a specific opcode namedPRECOMPILEDCALLto call Precompiled contracts without the costs of a normalCALL.", "": "This EIP creates a specific opcode namedPRECOMPILEDCALLto call Precompiled contracts without the costs of a normalCALL.", "Simple Summary": "This EIP creates a specific opcode namedPRECOMPILEDCALLto call Precompiled contracts without the costs of a normalCALL.", "Abstract": "This EIP tries to resolve the problem of high gas consumption when calling precompiled contracts with a small gas cost. Using this opcode for calling precompiled contracts allows to define precompiled contracts whose effective cost it is less than 700.", "Motivation": "Each precompiled contract has an already defined cost for calling it. It does not make sense to add the implicit extra gas cost of the CALL opcode.", "Specification": "Ifblock.number >= XXXXX, define a new opcode namedPRECOMPILEDCALLwith code value0xfb.", "Rationale": "There was a first proposal for removing the gast consts for theCALL, but it looks that it\u2019s easier to implement and test a new opcode just for that.", "Backwards Compatibility": "This EIP is backwards compatible.  Smart contracts that call precompiled contracts using this new opcode will cost less from now on.", "Test Cases": "Not implemented yet.", "Implementation": "Not implemented yet.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- precompiledcall opcode: Introduces a new opcode that allows direct calls to precompiled contracts without the overhead of the CALL opcode, reducing gas costs for these operations.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1227, "url": "https://eips.ethereum.org/EIPS/eip-1227", "title": "Defuse Difficulty Bomb and Reset Block Reward", "authors": ["SmeargleUsedFly\u00a0(", "@SmeargleUsedFly", ")"], "sections": {"EIP-1227: Defuse Difficulty Bomb and Reset Block Reward": "This EIP proposes to permanently disable the \u201cdifficulty bomb\u201d and reset the block reward to pre-Byzantium levels.", "": "This EIP proposes to permanently disable the \u201cdifficulty bomb\u201d and reset the block reward to pre-Byzantium levels.", "Simple Summary": "This EIP proposes to permanently disable the \u201cdifficulty bomb\u201d and reset the block reward to pre-Byzantium levels.", "Abstract": "Starting withFORK_BLKNUMthe client will calculate the difficulty without the additional exponential component. Furthermore, block rewards will be adjusted to a base of 5 ETH, uncle and nephew rewards will be adjusted accordingly.", "Motivation": "Due to the \u201cdifficulty bomb\u201d (also known as the \u201cice age\u201d), introduced in EIP#2, an artificial exponential increase in difficulty until chain freeze, users may find it much more challenging to remain on the unforked chain after a hard-fork. This is a desirable effect of the ice age (in fact, its only stated purpose) in the case of a scheduled network upgrade, but is especially problematic when a hard-fork includes a controversial change.", "Specification": "For the purposes ofcalc_difficulty, simply remove the exponential difficulty adjustment component,epsilon, i.e. theint(2**((block.number // 100000) - 2)).", "Rationale": "This will permanently, without further changes, disable the \u201cice age.\u201d It will also reset the block reward to pre-Byzantium levels. Both of these changes are specified similarly to EIP#649, so they should require only minimal changes from client developers.", "Backwards Compatibility": "This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation, as well as the block, uncle and nephew reward structure. However, it may be controversial in nature among different sections of the userbase\u2014the very problem this EIP is made to address. Therefore, it should not be included in a scheduled hardfork at a certain block number. It is suggested to implement this EIP in an isolated hard-fork before the second of the two Metropolis hard-forks.", "Test Cases": "Forthcoming.", "Implementation": "Forthcoming.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- defuse difficulty bomb and reset block reward: Proposes permanently disabling the difficulty bomb and resetting the block reward to 5 ETH to give users more freedom over Ethereum's governance.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1276, "url": "https://eips.ethereum.org/EIPS/eip-1276", "title": "Eliminate Difficulty Bomb and Adjust Block Reward on Constantinople Shift", "authors": ["EOS Classic\u00a0(", "@eosclassicteam", ")"], "sections": {"EIP-1276: Eliminate Difficulty Bomb and Adjust Block Reward on Constantinople Shift": "The average block times are increasing due to the factor of difficulty logic well known as difficulty bomb. This EIP proposes to eliminate the difficulty bomb forever and to reduce the block rewards with the Constantinople fork, the second part of the Metropolis fork.", "": "The average block times are increasing due to the factor of difficulty logic well known as difficulty bomb. This EIP proposes to eliminate the difficulty bomb forever and to reduce the block rewards with the Constantinople fork, the second part of the Metropolis fork.", "Simple Summary": "The average block times are increasing due to the factor of difficulty logic well known as difficulty bomb. This EIP proposes to eliminate the difficulty bomb forever and to reduce the block rewards with the Constantinople fork, the second part of the Metropolis fork.", "Abstract": "Starting withCNSTNTNPL_FORK_BLKNUMthe client will calculate the difficulty without considering the current block number. Furthermore, block rewards will be adjusted to a base of 2 ETH, uncle and nephew rewards will be adjusted accordingly.", "Motivation": "Block time has been played a most important role on blockchain ecosystem, and it is being adjusted by the logic of mining difficulty calculation that is already implemented on the node client as a part of proof-of-work consensus. Last year, average block time rapidly increased due to the wrong design of difficulty logic that is meant to be changed on the part of Casper upgrade, however, implementation of casper has been delayed therefore it was inevitable to delay the difficulty bomb in order to prevent the significant delay of processing transactions on ethereum network.", "Specification": "For the purposes ofcalc_difficulty, simply remove the exponential difficulty adjustment component,epsilon, i.e. theint(2**((block.number // 100000) - 2)).", "Rationale": "This will completely remove the difficulty bomb on difficulty adjustment algorithm without delaying the difficulty bomb again, therefore it is possible to prevent network delay on the beginning of 2019.", "Backwards Compatibility": "This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation, as well as the block, uncle and nephew reward structure. Therefore, it should be included in a scheduled hardfork at a certain block number. It\u2019s suggested to include this EIP in the second Metropolis hard-fork,Constantinople.", "Test Cases": "Test cases shall be created once the specification is to be accepted by the developers or implemented by the clients.", "Implementation": "The implementation shall be created once the specification is to be accepted by the developers or implemented by the clients.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- eliminate difficulty bomb and adjust block reward: Proposes eliminating the difficulty bomb entirely and reducing block rewards to 2 ETH as part of the Constantinople fork to maintain network efficiency and reduce issuance.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1285, "url": "https://eips.ethereum.org/EIPS/eip-1285", "title": "Increase Gcallstipend gas in the CALL opcode", "authors": ["Ben Kaufman\u00a0<", "ben@daostack.io", ">", "Adam Levi\u00a0<", "adam@daostack.io", ">"], "sections": {"EIP-1285: Increase Gcallstipend gas in the CALL opcode": "Increase theGcallstipendfee parameter in theCALLopcode from2,300to3,500gas units.", "": "Increase theGcallstipendfee parameter in theCALLopcode from2,300to3,500gas units.", "Simple Summary": "Increase theGcallstipendfee parameter in theCALLopcode from2,300to3,500gas units.", "Abstract": "Currently, theCALLopcode forwards a stipend of2,300gas units for a non zero valueCALLoperations where a contract is called. This stipend is given to the contract to allow execution of itsfallbackfunction. The stipend given is intentionally small in order to prevent the called contract from spending the call gas or performing an attack (like re-entrancy).\nWhile the stipend is small it should still give the sufficient gas required for some cheap opcodes likeLOG, but it\u2019s not enough for some more complex and modern logics to be implemented.\nThis EIP proposes to increase the given stipend from2,300to3,500to increase the usability of  thefallbackfunction.", "Motivation": "The main motivation behind this EIP is to allow simple fallback functions to be implemented for contracts following the\"Proxy\"pattern. Simply explained, a\"Proxy Contract\"is a contract which useDELEGATECALLin itsfallbackfunction to behave according to the logic of another contract and serve as an independent instance for the logic of the contract it points to.\nThis pattern is very useful for saving gas per deployment (as Proxy contracts are very lean) and it opens the ability to experiment with upgradability of contracts.\nOn average, theDELEGATECALLfunctionality of a proxy contract costs about1,000gas units.\nWhen a contract transfers ETH to a proxy contract, the proxy logic will consume about1,000gas units before thefallbackfunction of the logic contract will be executed. This leaves merely about 1,300 gas units for the execution of the logic. This is a severe limitation as it is not enough for an averageLOGoperation (it might be enough for aLOGwith one parameter).\nBy slightly increasing the gas units given in the stipend we allow proxy contracts have properfallbacklogic without increasing the attack surface of the calling contract.", "Specification": "Increase theGcallstipendfee parameter in theCALLopcode from2,300to3,500gas unit.\nThe actual change to the Ethereum clients would be to change theCallStipendthey store as a constant.\nFor an implementation example you can find a Geth client implementation linkedhere. The actual change to the code can be foundhere.", "Rationale": "The rational for increasing theGcallstipendgas parameter by1,200gas units comes from the cost of performingDELEGATECALLandSLOADwith a small margin for some small additional operations. All while still keeping the stipend relatively small and insufficient for accessing the storage or changing the state.", "Backwards Compatibility": "This EIP requires a backwards incompatible change for theGcallstipendgas parameter in theCALLopcode.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1295, "url": "https://eips.ethereum.org/EIPS/eip-1295", "title": "Modify Ethereum PoW Incentive Structure and Delay Difficulty Bomb", "authors": ["Brian Venturo\u00a0(", "@atlanticcrypto", ")"], "sections": {"EIP-1295: Modify Ethereum PoW Incentive Structure and Delay Difficulty Bomb": "Network security and overall ecosystem maturity warrants the continued incentivization of Proof of Work participation but may allow for a reduction in ancillary ETH issuance and the delay of the Difficulty Bomb. This EIP proposes a reduction of Uncle and removal of Nephew rewards while delaying the Difficulty Bomb with the Constantinople hard fork.", "": "Network security and overall ecosystem maturity warrants the continued incentivization of Proof of Work participation but may allow for a reduction in ancillary ETH issuance and the delay of the Difficulty Bomb. This EIP proposes a reduction of Uncle and removal of Nephew rewards while delaying the Difficulty Bomb with the Constantinople hard fork.", "Simple Summary": "Network security and overall ecosystem maturity warrants the continued incentivization of Proof of Work participation but may allow for a reduction in ancillary ETH issuance and the delay of the Difficulty Bomb. This EIP proposes a reduction of Uncle and removal of Nephew rewards while delaying the Difficulty Bomb with the Constantinople hard fork.", "Abstract": "Starting with CNSTNTNPL_FORK_BLKNUM the client will calculate the difficulty based on a fake block number suggesting the client that the difficulty bomb is adjusting around 6 million blocks later than previously specified with the Homestead fork.", "Motivation": "Network scalability and security are at the forefront of risks to the Ethereum protocol. With great strides being made towards on and off chain scalability, the existence of an artificial throughput limiting device in the protocol is not warranted. Removing the risk of reducing throughput through the initialization of the Difficulty Bomb is \u201clow-hanging-fruit\u201d to ensure continued operation at a minimum of current throughput through the next major hard fork (scheduled for late 2019).", "Specification": "For the purposes ofcalc_difficulty, simply replace the use ofblock.number, as used in the exponential ice age component, with the formula:", "Rationale": "The security layer of the Ethereum network is and should remain robust. Incentives for continued operation of the growing ecosystem\u2019s security are paramount.", "Backwards Compatibility": "This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation, as well as the block, uncle and nephew reward structure. Therefore, it should be included in a scheduled hardfork at a certain block number. It\u2019s suggested to include this EIP in the second Metropolis hard-fork, Constantinople.", "Test Cases": "Test cases shall be created once the specification is to be accepted by the developers or implemented by the clients.", "Implementation": "Forthcoming.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- constantinople hard fork: Specifies the changes included in the Constantinople hard fork, such as bitwise shifting instructions, CREATE2, and reducing gas costs for certain operations.\n- modify ethereum pow incentive structure and delay difficulty bomb: Proposes reducing uncle rewards, removing nephew rewards, and delaying the difficulty bomb while maintaining the current block reward of 3 ETH."}
{"eip": 1352, "url": "https://eips.ethereum.org/EIPS/eip-1352", "title": "Specify restricted address range for precompiles/system contracts", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-1352: Specify restricted address range for precompiles/system contracts": "Specify an Ethereum address range occupied by precompiles and future system contracts. Regular accounts and contracts cannot obtain such an address.", "": "Specify an Ethereum address range occupied by precompiles and future system contracts. Regular accounts and contracts cannot obtain such an address.", "Simple Summary": "Specify an Ethereum address range occupied by precompiles and future system contracts. Regular accounts and contracts cannot obtain such an address.", "Abstract": "The address range between 0x0000000000000000000000000000000000000000 and 0x000000000000000000000000000000000000ffff is reserved for precompiles and system contracts.", "Motivation": "This will simplify certain future features where unless this is implemented, several exceptions must be specified.", "Specification": "The address range between 0x0000000000000000000000000000000000000000 and 0x000000000000000000000000000000000000ffff is reserved for precompiles and system contracts.", "Rationale": "N/A", "Backwards Compatibility": "No contracts on the main network have been created at the specified addresses. As a result it should pose no backwards compatibility problems.", "Test Cases": "N/A", "Implementation": "N/A", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- restricted address range for precompiles/system contracts: Reserves the address range from 0x0000000000000000000000000000000000000000 to 0x000000000000000000000000000000000000ffff for precompiles and system contracts.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1380, "url": "https://eips.ethereum.org/EIPS/eip-1380", "title": "Reduced gas cost for call to self", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Jacques Wagener\u00a0(", "@jacqueswww", ")"], "sections": {"EIP-1380: Reduced gas cost for call to self": "Reduce the gas cost for call instructions, when the goal is to run a new instance of the currently loaded contract.", "": "Reduce the gas cost for call instructions, when the goal is to run a new instance of the currently loaded contract.", "Abstract": "Reduce the gas cost for call instructions, when the goal is to run a new instance of the currently loaded contract.", "Motivation": "The current gas cost of 700 for all call types (CALL,DELEGATECALL,CALLCODEandSTATICCALL) does not take into account that a call to a contract itself\ndoes not need to perform additional I/O operations, because the current contract code has already been loaded into memory.", "Specification": "Ifblock.number >= FORK_BLKNUM, then decrease the cost ofCALL,DELEGATECALL,CALLCODEandSTATICCALLfrom 700 to 40,\nif and only if, the destination address of the call equals to the address of the caller.", "Rationale": "EIP150 has increased the cost of these instructions from 40 to 700 to more fairly charge for loading new contracts from disk, e.g. to reflect the I/O charge more closely.\nBy assuming that 660 is the cost of loading a contract from disk, one can assume that the original 40 gas is a fair cost of creating a new VM instance of an already loaded contract code.", "Backwards Compatibility": "This should pose no risk to backwards compatibility. Currently existing contracts should not notice the difference, just see cheaper execution.\nWith EIP150 contract (and language) developers had a lesson that relying on strict gas costs is not feasible as costs may change.\nThe impact of this EIP is even less that of EIP150 because the costs are changing downwards and not upwards.", "Test Cases": "TBA", "Implementation": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- reduced gas cost for call to self: Proposes reducing the gas cost for call instructions when the destination address equals the caller\u2019s address, to encourage using CALL for internal function calls in smart contracts."}
{"eip": 1418, "url": "https://eips.ethereum.org/EIPS/eip-1418", "title": "Blockchain Storage Rent Payment", "authors": ["William Entriken\u00a0(", "@fulldecent", ")"], "sections": {"EIP-1418: Blockchain Storage Rent Payment": "At each block, deduct an amount of value (\u201crent\u201d) from every account based on the quantity of storage used by that account.", "At each block, deduct value from every account based on the quantity of storage used by that account.": "At each block, deduct an amount of value (\u201crent\u201d) from every account based on the quantity of storage used by that account.", "Abstract": "At each block, deduct an amount of value (\u201crent\u201d) from every account based on the quantity of storage used by that account.", "Motivation": "Ethereum is a public utility and we are underpricing the long-term costs of storage. Storage cost can be approximately modeled as bytes \u00d7 time.", "Specification": "Updated transaction type", "Rationale": "No call", "Economics & constants": "AnSSTOREexecuted in 2015 cost 20,000 gas and has survived about 6 million blocks. The gas price has been around 1 ~ 50 Gwei. So basically 4,000 Wei per block per word so far. Maybe storing an account is 10 times more intensive than storing a word. But actuallyG_transactionis 21,000 andG_sstoreis 20,000 so these are similar and they can both create new accounts / words.", "Backwards Compatibility": "EIP-1559 already introduces a mechanism for nodes to participate without recording the full network state and for clients to warm cache with storage data in their type 2 transactions.", "Security Considerations": "Many smart contracts allow anybody to use an arbitrary amount of storage in them.", "Copyright": "Copyright and related rights waived via CC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- blockchain storage rent payment: Introduces rent payments for storage used by accounts, with rent deducted based on the quantity of storage each account uses.\n- storage rent: Proposes a system where users must pay rent for storing data on the Ethereum blockchain, with accounts becoming inactive if they cannot pay. Inactive accounts can be restored by re-uploading their storage.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1482, "url": "https://eips.ethereum.org/EIPS/eip-1482", "title": "Define a maximum block timestamp drift", "authors": ["Maurelian\u00a0(", "@Maurelian", ")"], "sections": {"EIP-1482: Define a maximum block timestamp drift": "Include an explicit definition of the acceptable timestamp drift in the protocol specification.", "": "Include an explicit definition of the acceptable timestamp drift in the protocol specification.", "Simple Summary": "Include an explicit definition of the acceptable timestamp drift in the protocol specification.", "Abstract": "On the basis that both Geth and Parity implement the same timestamp validation requirements, this should be written into the reference specification.", "Motivation": "There is a lack of clarity about how accurate timestamps in the block header must be. The yellow paper describes the timestamp as", "Specification": "The yellow paper should define a timestamp as:", "Rationale": "BothGethandParityreject blocks with timestamp more than 15 seconds in the future. This establishes a defacto standard, which should be made explicit in the reference specification.", "Backwards Compatibility": "It may be necessary to relax this requirement for blocks which were mined early in the main chain\u2019s history, if they would be considered invalid.", "Test Cases": "These would be important to have.", "Implementation": "_The implementations must be completed before any EIP is given status \u201cFinal\u201d, but it need not be completed before the EIP is accepted. While there is merit to the approach of reaching consensus on the specification and rationale before writing code, the principle of \u201crough consensus and running code\u201d is still useful when it comes to resolving many discussions of API details.\n_", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- define a maximum block timestamp drift: Specifies that block timestamps must be greater than the previous block\u2019s timestamp and no more than 15 seconds ahead of system time.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1485, "url": "https://eips.ethereum.org/EIPS/eip-1485", "title": "TEthashV1", "authors": ["trustfarm\u00a0<", "trustfarm.info@gmail.com", ">", "trustfarm\u00a0<", "cpplover@trustfarm.net", ">"], "sections": {"EIP-1485: TEthashV1": "This EIP modifies ethash in order to break ASIC miners specialized for the current ethash mining algorithm.", "": "This EIP modifies ethash in order to break ASIC miners specialized for the current ethash mining algorithm.", "Simple Summary": "This EIP modifies ethash in order to break ASIC miners specialized for the current ethash mining algorithm.", "Abstract": "This EIP pursue \u201cobsolete current ASIC miners\u201d by modifying PoW algorithm in a very low risk manner and update to latest hash algorithm from deprecated FNV Hash algorithms.", "Motivation": "Provide original Ethash proof of work verification with minimal set of changes by updating FNV0 algorithm", "Specification": "[FNV-0hash (deprecated)](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-0_hash(deprecated))", "Rationale": "In case of ethash algorithm, it can\u2019t prevent ASIC forever.", "Test Results::": "Tethash miner has 2~3% of hashrate degrade on GPU, due to more core computation time.", "Copyright": "This work is licensed under aCreative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- tethashv1: Modifies the Ethash PoW algorithm to obsolete current ASIC miners by replacing the deprecated FNV-0 hash with the FNV1A hash function.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1681, "url": "https://eips.ethereum.org/EIPS/eip-1681", "title": "Temporal Replay Protection", "authors": ["Martin Holst Swende\u00a0(", "@holiman", ")"], "sections": {"EIP-1681: Temporal Replay Protection": "This EIP proposes adding a \u2018temporal\u2019 replay protection to transactions, in the form of avalid-untiltimestamp. \nThis EIP is very similar to https://github.com/ethereum/EIPs/pull/599 by Nick Johnson and Konrad Feldmeier, the main difference\nbeing that this EIP is based on clock-time / walltime instead of block numbers.", "": "This EIP proposes adding a \u2018temporal\u2019 replay protection to transactions, in the form of avalid-untiltimestamp. \nThis EIP is very similar to https://github.com/ethereum/EIPs/pull/599 by Nick Johnson and Konrad Feldmeier, the main difference\nbeing that this EIP is based on clock-time / walltime instead of block numbers.", "Simple Summary": "This EIP proposes adding a \u2018temporal\u2019 replay protection to transactions, in the form of avalid-untiltimestamp. \nThis EIP is very similar to https://github.com/ethereum/EIPs/pull/599 by Nick Johnson and Konrad Feldmeier, the main difference\nbeing that this EIP is based on clock-time / walltime instead of block numbers.", "Motivation": "There are a couple of different motivators for introducing a timebased transaction validity.", "Specification": "The roll-out would be performed in two phases,X(hardfork), andY(softfork).", "Rationale": "For the dust-account clearing usecase,", "Rationale for this EIP": "For the dust-account clearing usecase,", "Rationale for walltime": "Why use walltime instead of block numbers, as proposed in https://github.com/ethereum/EIPs/pull/599 ?", "Backwards Compatibility": "This EIP means that all software/hardware that creates transactions need to add timestamps to the transactions, or will otherwise be incapable of signing transactions after blockY. Note: this EIP does not introduce any maximumvalid-untildate, so it would still be possible to create\ntransactions with near infinite validity.", "Test Cases": "todo", "Implementation": "None yet", "Security considerations": "The most notable security impact is that pre-signed transactions stored on paper backups, will become invalid as of blockY. There are a couple of cases where this might be used", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- temporal replay protection: Introduces a time-based replay protection mechanism for Ethereum transactions, allowing users to set a validity period for their transactions using a valid-until timestamp.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1702, "url": "https://eips.ethereum.org/EIPS/eip-1702", "title": "Generalized Account Versioning Scheme", "authors": ["Wei Tang\u00a0(", "@sorpaas", ")"], "sections": {"EIP-1702: Generalized Account Versioning Scheme": "Introduce account versioning for smart contracts so upgrading the VM\nor introducing new VMs can be easier.", "": "Introduce account versioning for smart contracts so upgrading the VM\nor introducing new VMs can be easier.", "Simple Summary": "Introduce account versioning for smart contracts so upgrading the VM\nor introducing new VMs can be easier.", "Abstract": "This defines a method of hard forking while maintaining the exact\nfunctionality of existing account by allowing multiple versions of the\nvirtual machines to execute in the same block. This is also useful to\ndefine future account state structures when we introduce the on-chain\nWebAssembly virtual machine.", "Motivation": "By allowing account versioning, we can execute different virtual\nmachine for contracts created at different times. This allows breaking\nfeatures to be implemented while making sure existing contracts work\nas expected.", "Specification": "Re-define account state stored in the world state trie to have 5\nitems:nonce,balance,storageRoot,codeHash, andversion. The newly added fieldversionis a 256-bitscalar. We\nuse the definition of \u201cscalar\u201d from Yellow Paper. Note that this is\nthe same type asnonceandbalance, and it is equivalent to a RLP\nvariable-sized byte array with no leading zero, of maximum length 32.", "Account State": "Re-define account state stored in the world state trie to have 5\nitems:nonce,balance,storageRoot,codeHash, andversion. The newly added fieldversionis a 256-bitscalar. We\nuse the definition of \u201cscalar\u201d from Yellow Paper. Note that this is\nthe same type asnonceandbalance, and it is equivalent to a RLP\nvariable-sized byte array with no leading zero, of maximum length 32.", "Contract Execution": "When fetching an account code from state, we always fetch the\nassociated version field together. We refer to this as thecode\u2019s\nversionbelow. The code of the account is always executed in thecode\u2019s version.", "Contract Deployment": "In Ethereum, a contract has a deployment method, either by a contract\ncreation transaction, or by another contract. If we regard this\ndeployment method a contract\u2019sparent, then we find them forming a\nfamily of contracts, with therootbeing a contract creation\ntransaction.", "Validation": "A new phrase,validationis added to contract deployment (byCREATE/CREATE2opcodes, or by contract creation\ntransaction). Whenversionis0, the phrase does nothing and\nalways succeeds. Future VM versions can define additional validation\nthat has to be passed.", "Contract Creation Transaction": "DefineLATEST_VERSIONin a hard fork to be the latest supported VM\nversion. A contract creation transaction is always executed inLATEST_VERSION(which means thecode\u2019s versionisLATEST_VERSION), and deploys contracts ofLATEST_VERSION. Before a\ncontract creation transaction is executed, runvalidationon the\ncontract creation code. If it does not pass, return out-of-gas.", "Precompiled Contract and Externally-owned Address": "Precompiled contracts and externally-owned addresses do not haveversion. If a message-call transaction orCALL/CALLCODE/STATICCALL/DELEGATECALLtouches a new externally-owned address\nor a non-existing precompiled contract address, it is always created\nwithversionfield being0.", "Additional Fields in Account State RLP": "In the future we may need to associate more information into an\naccount, and we already have some EIPs that define new additional\nfields in the account state RLP. In this section, we define the\nparsing strategy when additional fields are added.", "Extensions": "In relation to the above \u201cSpecification\u201d section, we have defined the\nbase account versioning layer. The base account versioning layer is\nalready useful by itself and can handle most EVM improvements. Below\nwe define two specifications that can be deployed separately, which\nimproves functionality of base layer account versioning.", "Usage Template": "This section defines how other EIPs might use this account\nversioning specification. Note that currently we only define the usage\ntemplate for base layer.", "Rationale": "This introduces account versioning via a new RLP item in account\nstate. The design above gets account versioning by making the contractfamilyalways have the same version. In this way, versions are only\nneeded to be provided by contract creation transaction, and there is\nno restrictions on formats of code for any version. If we want to\nsupport multiple newest VMs (for example, EVM and WebAssembly running\ntogether), then this will requires extensions such as 44-VERTXN and\n45-VEROP.", "Backwards Compatibility": "Account versioning is fully backwards compatible, and it does not\nchange how current contracts are executed.", "Discussions": "Currently nearly all full node implementations uses config parameters\nto decide which virtual machine version to use. Switching virtual\nmachine version is simply an operation that changes a pointer using a\ndifferent set of config parameters. As a result, this scheme has\nnearly zero impact to performance.", "Performance": "Currently nearly all full node implementations uses config parameters\nto decide which virtual machine version to use. Switching virtual\nmachine version is simply an operation that changes a pointer using a\ndifferent set of config parameters. As a result, this scheme has\nnearly zero impact to performance.", "WebAssembly": "This scheme can also be helpful when we deploy on-chain WebAssembly\nvirtual machine. In that case, WASM contracts and EVM contracts can\nco-exist and the execution boundary and interaction model are clearly\ndefined as above.", "Test Cases and Implementations": "To be added.", "References": "The source of this specification can be found at43-VER.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- generalized account versioning scheme: Introduces a scheme for account versioning, allowing multiple versions of virtual machines to coexist, facilitating upgrades to Ethereum\u2019s execution environments."}
{"eip": 1829, "url": "https://eips.ethereum.org/EIPS/eip-1829", "title": "Precompile for Elliptic Curve Linear Combinations", "authors": ["Remco Bloemen\u00a0<", "Recmo@0x.org", ">"], "sections": {"EIP-1829: Precompile for Elliptic Curve Linear Combinations": "Currently the EVM only supportssecp256k1in a limited way throughecrecoverandaltbn128through two pre-compiles. There are draft proposals to add more curves. There are many more elliptic curve that have useful application for integration with existing systems or newly developed curves for zero-knowledge proofs.", "": "Currently the EVM only supportssecp256k1in a limited way throughecrecoverandaltbn128through two pre-compiles. There are draft proposals to add more curves. There are many more elliptic curve that have useful application for integration with existing systems or newly developed curves for zero-knowledge proofs.", "Precompile for Elliptic Curve Linear Combinations": "Currently the EVM only supportssecp256k1in a limited way throughecrecoverandaltbn128through two pre-compiles. There are draft proposals to add more curves. There are many more elliptic curve that have useful application for integration with existing systems or newly developed curves for zero-knowledge proofs.", "Simple Summary": "Currently the EVM only supportssecp256k1in a limited way throughecrecoverandaltbn128through two pre-compiles. There are draft proposals to add more curves. There are many more elliptic curve that have useful application for integration with existing systems or newly developed curves for zero-knowledge proofs.", "Abstract": "A precompile that takes a curve and computes a linear combination of curve points.", "Motivation": "Given integersm, \u03b1and\u03b2, scalarss_i, and curve pointsA_iconstruct the elliptic curve", "Specification": "Given integersm, \u03b1and\u03b2, scalarss_i, and curve pointsA_iconstruct the elliptic curve", "Gas cost": "The total gas cost isBASE_GASplusADD_GASfor eachs_ithat is1andMUL_GASfor eachs_i > 1(s_i = 0is free).", "Encoding of points": "Encode as(x, y')wheresindicates whetheryor-yis to be taken. It follows SEC 1 v 1.9 2.3.4, except uncompressed points (y' = 0x04) are not supported.", "Special cases": "Coordinate recovery.Sets\u2080 = 1. The output will be the recovered coordinates ofA\u2080.", "Edge cases": "Generic Field and Curve.Many important optimizations are independent of the field and curve used. Some missed specific optimizations are:", "Rationale": "Generic Field and Curve.Many important optimizations are independent of the field and curve used. Some missed specific optimizations are:", "Backwards Compatibility": "There will be a reference implementation in Rust based on the existing libraries (in particular those by ZCash and The Matter Inc.).", "Test Cases": "There will be a reference implementation in Rust based on the existing libraries (in particular those by ZCash and The Matter Inc.).", "Implementation": "There will be a reference implementation in Rust based on the existing libraries (in particular those by ZCash and The Matter Inc.).", "References": "This EIP overlaps in scope with", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1895, "url": "https://eips.ethereum.org/EIPS/eip-1895", "title": "Support for an Elliptic Curve Cycle", "authors": ["Alexandre Belling\u00a0<", "alexandrebelling8@gmail.com", ">"], "sections": {"EIP-1895: Support for an Elliptic Curve Cycle": "The EVM currently supports elliptic curves operations for curvealt-bn128thanks to precompilesecaddandecmulandecpairing. The classes MNT4 and 6 contain cycles of curves. Those cycles enable doing operations on one curve inside a SNARK on the other curve (and reversely). This EIP suggests adding support for those curves.", "": "The EVM currently supports elliptic curves operations for curvealt-bn128thanks to precompilesecaddandecmulandecpairing. The classes MNT4 and 6 contain cycles of curves. Those cycles enable doing operations on one curve inside a SNARK on the other curve (and reversely). This EIP suggests adding support for those curves.", "Simple Summary": "The EVM currently supports elliptic curves operations for curvealt-bn128thanks to precompilesecaddandecmulandecpairing. The classes MNT4 and 6 contain cycles of curves. Those cycles enable doing operations on one curve inside a SNARK on the other curve (and reversely). This EIP suggests adding support for those curves.", "Abstract": "Adds supports for the following operations through precompiles:", "Motivation": "Elliptic curve is the basic block of recursive SNARKs (ie: verifying a SNARK inside a SNARK) and this addresses the issue of scalable zero-knowledge. More generally this addresses partly the scalability issue as SNARKs verification are constant time in the size of the circuit being verified.", "Specification": "The proposed cycle has been introduced inScalable Zero Knowledge via Cycles of Elliptic Curves.", "The curve": "The proposed cycle has been introduced inScalable Zero Knowledge via Cycles of Elliptic Curves.", "MNT4 definition": "The groupsG_1andG_2are cyclic groups of prime order :", "The operations and gas cost": "The following operations and their gas cost would be implemented", "Encoding": "The curves points P(X, Y) over F_p are represented in their compressed form C(X, Y):", "Edge cases": "The curve has 80 bits of security (whereas MNT6 has 120 bits) which might not be considered enough for critical security level, (for instance transferring several billions), but enough for others. If it turns out this is not enough security for adoption, there is another option : another cycle is being used by Coda but is defined over a 753 bits sized field which might also be prohibitively low (no reference to this curve from Coda\u2019s publications found).", "Rationale": "The curve has 80 bits of security (whereas MNT6 has 120 bits) which might not be considered enough for critical security level, (for instance transferring several billions), but enough for others. If it turns out this is not enough security for adoption, there is another option : another cycle is being used by Coda but is defined over a 753 bits sized field which might also be prohibitively low (no reference to this curve from Coda\u2019s publications found).", "Test Cases": "Copyright and related rights waived viaCC0.", "References": "Copyright and related rights waived viaCC0.", "Implementation": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1930, "url": "https://eips.ethereum.org/EIPS/eip-1930", "title": "CALLs with strict gas semantic. Revert if not enough gas available.", "authors": ["Ronan Sandford\u00a0(", "@wighawag", ")"], "sections": {"EIP-1930: CALLs with strict gas semantic. Revert if not enough gas available.": "Add the ability for smart contract to execute calls with a specific amount of gas. If this is not possible the execution should revert.", "": "Add the ability for smart contract to execute calls with a specific amount of gas. If this is not possible the execution should revert.", "Simple Summary": "Add the ability for smart contract to execute calls with a specific amount of gas. If this is not possible the execution should revert.", "Abstract": "The current CALL, DELEGATE_CALL, STATIC_CALL opcode do not enforce the gas being sent, they simply consider the gas value as a maximum. This pose serious problem for applications that require the call to be executed with a precise amount of gas.", "Specification": "There are 2 possibilities", "Rationale": "Currently the gas specified as part of these opcodes is simply a maximum value. And due to the behavior ofEIP-150it is possible for an external call to be given less gas than intended (less than the gas specified as part of the CALL) while the rest of the current call is given enough to continue and succeed. Indeed since with EIP-150, the external call is given at maxG - Math.floor(G/64)where G is the gasleft() at the point of the CALL, the rest of the current call is givenMath.floor(G/64)which can be plenty enough for the transaction to succeed. For example, when G = 6,400,000 the rest of the transaction will be given 100,000 gas plenty enough in many case to succeed.", "Backwards Compatibility": "for specification a) : Backwards compatible as it introduce new opcodes.", "Test Cases": "None fully implemented yet. But see Specifications for an example in geth.", "Implementation": "None fully implemented yet. But see Specifications for an example in geth.", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1959, "url": "https://eips.ethereum.org/EIPS/eip-1959", "title": "New Opcode to check if a chainID is part of the history of chainIDs", "authors": ["Ronan Sandford\u00a0(", "@wighawag", ")"], "sections": {"EIP-1959: New Opcode to check if a chainID is part of the history of chainIDs": "To protect off-chain messages from being reused across different chain, a mechanism need to be given to smart contract to only accept messages for that chain. Since a chain can change its chainID, the mechanism should consider old chainID valid.", "": "To protect off-chain messages from being reused across different chain, a mechanism need to be given to smart contract to only accept messages for that chain. Since a chain can change its chainID, the mechanism should consider old chainID valid.", "Simple Summary": "To protect off-chain messages from being reused across different chain, a mechanism need to be given to smart contract to only accept messages for that chain. Since a chain can change its chainID, the mechanism should consider old chainID valid.", "Abstract": "This EIP adds an opcode that returns whether the specific number passed in has been a valid chainID (EIP-155 unique identifier) in the history of the chain (including the current chainID).", "Motivation": "EIP-155proposes to use the chain ID to prevent replay attacks between different chains. It would be a great benefit to have the same possibility inside smart contracts when handling signatures, especially for Layer 2 signature schemes usingEIP-712.", "Specification": "Adds a new opcodeVALID_CHAINIDat 0x46, which uses 1 stack argument : a 32 bytes value that represent the chainID to test. It will push0x1onto the stack if the uint256 value is part of the history (since genesis) of chainIDs of that chain,0x0otherwise.", "Rationale": "The only approach available today is to specify the chain ID at compile time. Using this approach will result in problems after a contentious hardfork as the contract can\u2019t accept message signed with a new chainID.", "Test Cases": "TBD", "Implementation": "TBD", "Backwards Compatibility": "This EIP is fully backwards compatible with all chains which implement EIP-155 chain ID domain separator for transaction signing. Existing contract are not affected.", "References": "This was previously suggested as part ofEIP-1344 discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- valid_chainid: Introduces the VALID_CHAINID opcode, allowing contracts to check if a chainID has been valid at any point in the chain\u2019s history.\n- genesis: Log entry in system_logs for initial balances at network genesis .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1962, "url": "https://eips.ethereum.org/EIPS/eip-1962", "title": "EC arithmetic and pairings with runtime definitions", "authors": ["Alex Vlasov\u00a0(", "@shamatar", ")"], "sections": {"EIP-1962: EC arithmetic and pairings with runtime definitions": "This proposal is an extension and formalization ofEIP-1829with an inclusion of pairings.EIP-1109is required due to low cost of some operations compared to theSTATICCALLopcode (more information in the corresponding section below).", "": "This proposal is an extension and formalization ofEIP-1829with an inclusion of pairings.EIP-1109is required due to low cost of some operations compared to theSTATICCALLopcode (more information in the corresponding section below).", "Simple summary": "This proposal is an extension and formalization ofEIP-1829with an inclusion of pairings.EIP-1109is required due to low cost of some operations compared to theSTATICCALLopcode (more information in the corresponding section below).", "Abstract": "This EIP proposes a new precompile to bring cryptographic functionality desired for privacy and scaling solutions. Functionality of such precompile will require the following:", "Motivation": "Functionality of this newly proposed precompile is different fromEIP-1829in the following aspects:", "Specification": "Ifblock.number >= XXXXX, define a set of10new precompiles with an addresses[0x.., 0x.., ...]and the following functionality.", "Possible simplifications": "Due to high complexity of the proposed operations in the aspects of implementation, debugging and evaluation of the factors for gas costs it may be appropriate to either limit the set of curves at the moment of acceptance to some list and then extend it. Another approach (if it\u2019s technically possible) would be to have the \u201cwhilelist\u201d contract that can be updated without consensus changes (w/o fork).", "Rationale": "Only the largest design decisions will be covered:", "This precompile and EIP 1109": "While there is no strict requirement of EIP 1109 for functionality, here is an example why it would be desired:", "Backwards Compatibility": "This change is not backwards compatible and requires hard fork to be activated.", "Test Cases": "Test cases are the part of the implementation with a link below.", "Implementation": "There is an ongoing implementation efforthere. Right now:", "Preliminary benchmarks": "cp6 in benchmarks is a Cocks-Pinch method curve that embeds BLS12-377. Machine: Core i7, 2.9 GHz.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1965, "url": "https://eips.ethereum.org/EIPS/eip-1965", "title": "Method to check if a chainID is valid at a specific block Number", "authors": ["Ronan Sandford\u00a0(", "@wighawag", ")"], "sections": {"EIP-1965: Method to check if a chainID is valid at a specific block Number": "This EIP adds a precompile that returns whether a specific chainID (EIP-155 unique identifier) is valid at a specific blockNumber. ChainID are assumed to be valid up to the blockNumber at which they get replaced by a new chainID.", "": "This EIP adds a precompile that returns whether a specific chainID (EIP-155 unique identifier) is valid at a specific blockNumber. ChainID are assumed to be valid up to the blockNumber at which they get replaced by a new chainID.", "Abstract": "This EIP adds a precompile that returns whether a specific chainID (EIP-155 unique identifier) is valid at a specific blockNumber. ChainID are assumed to be valid up to the blockNumber at which they get replaced by a new chainID.", "Motivation": "EIP-155proposes to use the chain ID to prevent the replay of transactions between different chains. It would be a great benefit to have the same possibility inside smart contracts when handling off-chain message signatures, especially for Layer 2 signature schemes usingEIP-712.", "Specification": "Adds a new precompile which uses 2 argument : a 32 bytes value that represent the chainID to test and a 32 bytes value representing the blockNumber at which the chainID is tested. It return 0x1  if the chainID is valid at the specific blockNumber, 0x0 otherwise. Note that chainID are considered valid up to the blockNumber at which they are replaced. So they are valid for every blockNumber past their replacement.", "Rationale": "The rationale at EIP-1959 applies here as well too :", "Backwards Compatibility": "EIP-712 is still in draft but would need to be updated to include the blockNumber as part of the values that wallets need to verify for the protection of their users.", "References": "This was previously suggested as part ofEIP1959 discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1985, "url": "https://eips.ethereum.org/EIPS/eip-1985", "title": "Sane limits for certain EVM parameters", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")"], "sections": {"EIP-1985: Sane limits for certain EVM parameters": "Introduce an explicit value range for certain EVM parameters\n(such as gas limit, block number, block timestamp, size field when returning/copying data within EVM).\nSome of these already have an implicit value range due to various (practical) reasons.", "": "Introduce an explicit value range for certain EVM parameters\n(such as gas limit, block number, block timestamp, size field when returning/copying data within EVM).\nSome of these already have an implicit value range due to various (practical) reasons.", "Abstract": "Introduce an explicit value range for certain EVM parameters\n(such as gas limit, block number, block timestamp, size field when returning/copying data within EVM).\nSome of these already have an implicit value range due to various (practical) reasons.", "Motivation": "Having such an explicit value range can help in creating compatible client implementations,\nin certain cases it can also offer minor speed improvements,\nand can reduce the effort needed to create consensus critical test cases\nby eliminating unrealistic edge cases.", "Specification": "Ifblock.number >= {FORK_BLOCK}, the following value ranges are introduced.\nThey restrict the results (i.e. values pushed to the stack) of the instructions listed below.", "Rationale": "These limits have been:", "Timestamp": "TheYellow Paperdefines the timestamp in block as \u201cA scalar value equal to the reasonable output of Unix\u2019s time() at this block\u2019s inception\u201d.\nIEEE Std 1003.1-2001 (POSIX.1) leaves that definition implementation defined.", "Addresses": "The size of addresses is specified in theYellow Paperas 20 bytes.\nE.g. theCOINBASEinstruction is specified to returnHc\u2208 \ud835\udd3920which has 20 bytes.", "Memory size": "Memory expansion cost is not linear and is determined by the following formula:\n        cost = cost_per_word * number_of_words + (number_of_words ^ 2 / 512)", "Code size": "EIP-170has implemented a code size limit of 0x6000, however even before that, it was practically impossible to deploy a code blob exceeding2**32 - 1bytes in size.", "Comparing current implementations": "All of these limits are already enforced mostly through the block gas limit. Since the out of range case results in a transaction failure, there should not be a change in behaviour.", "Backwards Compatibility": "All of these limits are already enforced mostly through the block gas limit. Since the out of range case results in a transaction failure, there should not be a change in behaviour.", "Test Cases": "TBA", "Implementation": "TBA", "References": "Copyright and related rights waived viaCC0.", "TODO": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- memory expansion: An operation that expands the contract's memory space to accommodate additional data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2014, "url": "https://eips.ethereum.org/EIPS/eip-2014", "title": "Extended State Oracle", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-2014: Extended State Oracle": "Introduce a new system contract with an extensible interface following theContract ABI Encodingto access extended data sets, such as chain identifiers, block hashes, etc.", "": "Introduce a new system contract with an extensible interface following theContract ABI Encodingto access extended data sets, such as chain identifiers, block hashes, etc.", "Simple Summary": "Introduce a new system contract with an extensible interface following theContract ABI Encodingto access extended data sets, such as chain identifiers, block hashes, etc.", "Abstract": "Introduce a new system contract with an extensible interface following theContract ABI Encodingto access extended data sets, such as chain identifiers, block hashes, etc.", "Motivation": "Over the past couple of years several proposals were made to extend the EVM with more data. Some examples include extended access to block hashes (EIP-210) and chain identifiers (EIP-1344).", "Specification": "A new system contract (\u201cprecompile\u201d) is introduced at address0x0000000000000000000000000000000000000009called ESO (Extended State Oracle).", "Chain identifier": "Initially, a feature to read the current chain identifier is introduced:getCurrentChainId()returns the current chain identifier as auint64encoded value.\nIt should be a non-payable function, which means sending any value would revert the transaction as described inEIP-140.\nThis has been proposed asEIP-1344.", "Rationale": "TBA", "Backwards Compatibility": "TBA", "Test Cases": "TBA", "Implementation": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2026, "url": "https://eips.ethereum.org/EIPS/eip-2026", "title": "State Rent H - Fixed Prepayment for accounts", "authors": ["Alexey Akhunov\u00a0(", "@AlexeyAkhunov", ")"], "sections": {"EIP-2026: State Rent H - Fixed Prepayment for accounts": "Creation of new accounts (both contracts and non-contracts) requires a fixed one-off rent prepayment. Pre-existed accounts require the same prepayment upon\nthe first modification. The act of rent prepayment causes the addition of an extra field to accounts, calledrentbalance. This field becomes part of state.", "": "Creation of new accounts (both contracts and non-contracts) requires a fixed one-off rent prepayment. Pre-existed accounts require the same prepayment upon\nthe first modification. The act of rent prepayment causes the addition of an extra field to accounts, calledrentbalance. This field becomes part of state.", "Simple Summary": "Creation of new accounts (both contracts and non-contracts) requires a fixed one-off rent prepayment. Pre-existed accounts require the same prepayment upon\nthe first modification. The act of rent prepayment causes the addition of an extra field to accounts, calledrentbalance. This field becomes part of state.", "Abstract": "This is part of the State Rent roadmap. This particular change introduces a fixed charge for state expansion that comes from adding new accounts to the state. Theoretically, it puts a bound on the number of accounts that can be ever created, because that fixed charge cannot be recycled via mining.", "Motivation": "The penalty is levied to the transaction sender. Rather than raising the gas cost of account creation (that would direct levy towards the miner), this change directs prepayment into the account\u2019s special field,rentbalance. It addresses several shortcomings of the simple raising of the gas cost:", "Specification": "On and after blockH, every newly created account gets a new fieldrentbalanceof type unsigned 256-bit integer.\nOn and after blockH, any operation that leads to the creation of a new account, deducts the amountACCOUNT_PREPAYMENTfromtx.origin. This amount is added to therentbalancefield of the created account.\nOn and after blockH, any operation that modifies an account that does not yet haverentbalancefield, deducts the amountACCOUNT_PREPAYEMENTfromtx.origin. This amount is added to therentbalancefield of the modified account. This is an anti-hoarding measure.", "Rationale": "Prior to rent prepayments, other alternatives were considered:", "Backwards Compatibility": "This change is not backwards compatible and requires hard fork to be activated.\nIt might have some adverse effects on the existing contracts, due to more gas needed to be allocated for the creation of new accounts. These adverse effects need to analysed in more detail.", "Test Cases": "Tests cases will be generated out of a reference implementation.", "Implementation": "There will be proof of concept implementation to refine and clarify the specification.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2027, "url": "https://eips.ethereum.org/EIPS/eip-2027", "title": "State Rent C - Net contract size accounting", "authors": ["Alexey Akhunov\u00a0(", "@AlexeyAkhunov", ")"], "sections": {"EIP-2027: State Rent C - Net contract size accounting": "Ethereum starts counting the number of storage slots filled and emptied in the contracts. Since the number of pre-existing slots is not currently accounted\nin the state, effectively, only net change in the number of slots is tracked. In the subsequent change, calledGross contract size accounting, the total\nnumber of storage slots starts being tracked.", "": "Ethereum starts counting the number of storage slots filled and emptied in the contracts. Since the number of pre-existing slots is not currently accounted\nin the state, effectively, only net change in the number of slots is tracked. In the subsequent change, calledGross contract size accounting, the total\nnumber of storage slots starts being tracked.", "Simple Summary": "Ethereum starts counting the number of storage slots filled and emptied in the contracts. Since the number of pre-existing slots is not currently accounted\nin the state, effectively, only net change in the number of slots is tracked. In the subsequent change, calledGross contract size accounting, the total\nnumber of storage slots starts being tracked.", "Abstract": "This is part of the State Rent roadmap. This particular change introduces initial, net accounting of the number of the contract storage slots. Though not very\nuseful on its own, it makes it possible to introduce gross accounting of the number of storage slots, which is useful for number of things:", "Motivation": "Ethereum currently does not track the number of contract storage slots at all, and producing such number given the downloaded state cannot be done in\nconstantO(1)time.", "Specification": "Each contract (account withcodeHashfield not equal to 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470, which the hash of the empty code) gets a new uint64 field, calledstoragesize. On and after blockC, the semantics of the operationSSTORE(location,value) changes as follows:", "Semantics ofincrementstoragesize": "Ifstoragesizeis not present,storagesize=HUGE_NUMBER+ 1.\nIfstoragesizeis present,storagesize=storagesize+ 1.", "Semantics ofdecrementstoragesize": "Ifstoragesizeis not present,storagesize=HUGE_NUMBER- 1.\nIfstoragesizeis present,storagesize=storagesize- 1.", "Note ofHUGE_NUMBER": "There is a constantHUGE_NUMBER. It needs to be large enough so that no real metrics (contract storage size, number of accounts, number of contracts, total size of code, total size of storage) will never reach that number, and small enough that it fits in an unsigned 64-bit integer.\nCurrent suggestion is to haveHUGE_NUMBER= 2^63, which is binary representation is the a single bit in a 64-bit number.", "Rationale": "A mechanism for estimation of contract storage size has been proposedhere. But it does have a big drawback of introducing a lot of complexity into the consensus\n(in the form of estimation algorithm, which has quite a few edge cases to cater for different sizes of the storage).", "Backwards Compatibility": "This change is not backwards compatible and requires hard fork to be activated. Since the newly introduced field is not observable, this change does not impact any operations of the existing smart contracts.", "Test Cases": "Tests cases will be generated out of a reference implementation.", "Implementation": "There will be proof of concept implementation to refine and clarify the specification.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- net contract size accounting: Begins tracking the net change in the number of storage slots used by contracts, preparing for future state rent and stateless client improvements.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2029, "url": "https://eips.ethereum.org/EIPS/eip-2029", "title": "State Rent A - State counters contract", "authors": ["Alexey Akhunov\u00a0(", "@AlexeyAkhunov", ")"], "sections": {"EIP-2029: State Rent A - State counters contract": "A smart contract is deployed on all Ethereum networks, at a pre-determined address, with the code that simply reads the slot in its storage specified by the\nonly parameter. Later, this contract becomes \u201cspecial\u201d in that Ethereum start writing state counters (number of total transactions, number of accounts,\netc.) into that contract.", "": "A smart contract is deployed on all Ethereum networks, at a pre-determined address, with the code that simply reads the slot in its storage specified by the\nonly parameter. Later, this contract becomes \u201cspecial\u201d in that Ethereum start writing state counters (number of total transactions, number of accounts,\netc.) into that contract.", "Simple Summary": "A smart contract is deployed on all Ethereum networks, at a pre-determined address, with the code that simply reads the slot in its storage specified by the\nonly parameter. Later, this contract becomes \u201cspecial\u201d in that Ethereum start writing state counters (number of total transactions, number of accounts,\netc.) into that contract.", "Abstract": "This is part of the State Rent roadmap. This particular change introduces a place in the Ethereum state where various state counters can be stored. At this\npoint, the most important counter is the total number of transactions happened, and this counter will be used to populate the nonces of newly created\nnon-contract accounts. This way of populating nonce ensures replay protection for accounts that were evicted and then brought back by sending ether to them.", "Motivation": "Ethereum currently does not have a special place in the state for tracking state counters such as number of transactions or number of accounts.", "Specification": "Prior to the block A, a contract is deployed with the following code:0x60 0x20 0x60 0x00 0x80 0x80 0x35 0x54 0x90 0x52 0xF3, which corresponds to this assembly:PUSH1 32 PUSH1 0 DUP1 DUP1 CALLDATALOAD SLOAD SWAP1 MSTORE RETURNCall to this contract accepts one 32-byte argument,x, and returns the value of the storage item [x].", "Rationale": "Two alternative solutions were considered so far:", "Backwards Compatibility": "This change is backwards compatible and does not require hard fork to be activated.", "Test Cases": "Tests cases will be created to ensure that the state counter contract returns its storage items correctly.", "Implementation": "Implementation is envisaged as a transaction that can be posted from any Ethereum address and will cause the deployment of the state counter contract.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- state counters contract: A contract deployed to store state counters (e.g., total transactions, accounts) to track state-related metrics for Ethereum.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170."}
{"eip": 2031, "url": "https://eips.ethereum.org/EIPS/eip-2031", "title": "State Rent B - Net transaction counter", "authors": ["Alexey Akhunov\u00a0(", "@AlexeyAkhunov", ")"], "sections": {"EIP-2031: State Rent B - Net transaction counter": "Ethereum starts to track the number of transactions inside its state (for now, only number of transactions after this change is introduced, therefore\nit is calledNettransaction count).\nIt is done by incrementing a storage slot in the special contract, calledState counter contract(EIP-2029).", "": "Ethereum starts to track the number of transactions inside its state (for now, only number of transactions after this change is introduced, therefore\nit is calledNettransaction count).\nIt is done by incrementing a storage slot in the special contract, calledState counter contract(EIP-2029).", "Simple Summary": "Ethereum starts to track the number of transactions inside its state (for now, only number of transactions after this change is introduced, therefore\nit is calledNettransaction count).\nIt is done by incrementing a storage slot in the special contract, calledState counter contract(EIP-2029).", "Abstract": "It is part of the State Rent roadmap. This particular change makes any Ethereum transaction increment the transaction counter, which is a special storage slot\nin theState counter contract. This counter will be used to populate the nonces of newly created\nnon-contract accounts. This way of populating nonce ensures replay protection for accounts that were evicted and then brought back by sending ether to them.", "Motivation": "Ethereum currently does not have a special place in the state for tracking number of transactions.", "Specification": "A new field, with the location 0 (that means it resides in the storage slot 0 in the state counter contract, and can\nbe read by calling that contract with argument being 32 zero bytes), is added to the state counter contract. It will eventually containtxCount, the total number of transactions processed up until that point.\nOn an after block B, or after the deployment of the state counter contract (which comes first), the fieldtxCountis incremented after each transaction. UpdatingtxCountmeans updating the storage of state counter contract at the location 0. These changes are never reverted.", "Rationale": "Two main alternatives were proposed for the replay protection of the accounts that were evicted by subsequently brought back by sending ether to them:", "Backwards Compatibility": "This change is not backwards compatible and requires hard fork to be activated.", "Test Cases": "Tests cases will be generated out of a reference implementation.", "Implementation": "There will be proof of concept implementation to refine and clarify the specification.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- net transaction counter: Introduces a counter in the state counters contract that tracks the number of Ethereum transactions after the change is introduced.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- revert: All calls to this opcode must emit a log with revert data."}
{"eip": 2035, "url": "https://eips.ethereum.org/EIPS/eip-2035", "title": "Stateless Clients - Repricing SLOAD and SSTORE to pay for block proofs", "authors": ["Alexey Akhunov\u00a0(", "@AlexeyAkhunov", ")"], "sections": {"EIP-2035: Stateless Clients - Repricing SLOAD and SSTORE to pay for block proofs": "The gas cost of EVM opcodesSLOADandSSTOREincreases in order to accommodate extra bandwidth required to propagate block proof together with the block\nheaders and block bodies, as explainedhere.", "": "The gas cost of EVM opcodesSLOADandSSTOREincreases in order to accommodate extra bandwidth required to propagate block proof together with the block\nheaders and block bodies, as explainedhere.", "Simple Summary": "The gas cost of EVM opcodesSLOADandSSTOREincreases in order to accommodate extra bandwidth required to propagate block proof together with the block\nheaders and block bodies, as explainedhere.", "Abstract": "It is part of the State Rent roadmap. This particular change prepares Ethereum for introduction of the block proofs (current understanding is that they\ncan be introuced without a hard fork). The introduction of the block proofs allows any Ethereum node that wishes to receive them, to process transactions\nin the blocks without needing to access the Ethereum state. All necessary information for the execution (and the proof of validity) is continued in the\nblock proofs. In most Ethereum nodes, it will speed up the block processing and reduce the memory footprint of such processing. For mining nodes, however,\nthere will be more work to do to construct and transmit the block proofs. Therefore, the extra charge (payable to the miners) is introduced. In the first\nphase, only contract storage will be covered by the block proofs. It means that the Ethereum nodes will still need access to the accounts in the state,\nbut block proofs will make it optional to have access to contract storage for executing transactions. Therefore, onlySSTOREandSLOADopcodes are\naffected.", "Motivation": "There isempirical analysisshowing thatSLOADopcode is currently underpriced in terms\nof execution latency it adds to the block processing. The hypothesis is that it is due to the latency of the database accesses. In the same\nanalysis,SSTOREis not considered, because its effect on the database accesses can be (and are in many implementations) delayed until the end of\nthe block. Stateless clients approach to the contract storage will largely negate that latency because no database accesses will be required.\nInstead, bandwidth consumption goes up. There is emprical analysis (unpublished, but will be) suggesting that 1 uncachedSSTOREorSLOADadds\nat most 1 kB to the block proofs. At the current cost of data transmission (68 gas per byte), this translates to the increase of gas cost of both\noperations by 69k gas. However, in light of proposal inEIP-2028, the increase can be made much smaller.", "Specification": "Not very formal at the moment, but will be formalised with more research and prototyping. Gas of operationsSLOADandSSTOREincreases byXgas when the storage slots accessed (read bySLOADor written bySSTORE) were not previously accessed (by anotherSLOADorSSTORE) during the same transaction.", "Rationale": "EIP-1884seeks to increase the gas cost ofSLOADbut using a different justification\n(latency of the execution as described in the Motivation). This EIP is likely to increase the cost ofSLOADby a larger amount, therefore partially\n(because EIP-1884 also proposed other increases) supersedes EIP-1884.", "Backwards Compatibility": "This change is not backwards compatible and requires hard fork to be activated.\nThere might also be an adverse effect of this change on the already deployed contract. It is expected that after this EIP andEIP-2026(rent prepayment for accounts), the recommendation will be made to raise the gas limit. This can somewhat dampen the\nadverse effect of EIP. The most problematic cases would be with the contracts that assume certain gas costs ofSLOADandSSTOREand hard-code them in their internal gas computations. For others, the cost of interacting with the contract\nstorage will rise and may make some dApps based on such interactions, non-viable. This is a trade off to avoid even bigger\nadverse effect of the rent proportional to the contract storage size. However, more research is needed to more fully\nanalyse the potentially impacted contracts.", "Test Cases": "Tests cases will be generated out of a reference implementation.", "Implementation": "There will be proof of concept implementation to refine and clarify the specification.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- repricing sload and sstore: Increases the gas cost of SLOAD and SSTORE operations to accommodate the additional bandwidth needed for stateless clients using block proofs.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2045, "url": "https://eips.ethereum.org/EIPS/eip-2045", "title": "Particle gas costs for EVM opcodes", "authors": ["Casey Detrio\u00a0(", "@cdetrio", ")", "Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-2045: Particle gas costs for EVM opcodes": "According to recent benchmarks, EVM opcodes for computation (ADD,SUB,MUL, etc.) are generally overpriced relative to opcodes for storage I/O (SLOAD,SSTORE, etc.). Currently the minimum gas cost is 1 (i.e. one unit of gas), and most computational opcodes have a cost near to 1 (e.g. 3, 5, or 8), so the range in possible cost reduction is limited. A new minimum unit of gas, called a \u201cparticle\u201d, which is a fraction of 1 gas, would expand the range of gas costs and thus enable reductions below the current minimum.", "": "According to recent benchmarks, EVM opcodes for computation (ADD,SUB,MUL, etc.) are generally overpriced relative to opcodes for storage I/O (SLOAD,SSTORE, etc.). Currently the minimum gas cost is 1 (i.e. one unit of gas), and most computational opcodes have a cost near to 1 (e.g. 3, 5, or 8), so the range in possible cost reduction is limited. A new minimum unit of gas, called a \u201cparticle\u201d, which is a fraction of 1 gas, would expand the range of gas costs and thus enable reductions below the current minimum.", "Abstract": "According to recent benchmarks, EVM opcodes for computation (ADD,SUB,MUL, etc.) are generally overpriced relative to opcodes for storage I/O (SLOAD,SSTORE, etc.). Currently the minimum gas cost is 1 (i.e. one unit of gas), and most computational opcodes have a cost near to 1 (e.g. 3, 5, or 8), so the range in possible cost reduction is limited. A new minimum unit of gas, called a \u201cparticle\u201d, which is a fraction of 1 gas, would expand the range of gas costs and thus enable reductions below the current minimum.", "Motivation": "The transaction capacity of an Ethereum block is determined by the gas cost of transactions relative to the block gas limit. One way to boost the transaction capacity is to raise the block gas limit. Unfortunately, raising the block gas limit would also increase the rate of state growth, unless the costs of state-expanding storage opcodes (SSTORE,CREATE, etc.) are simultaneously increased to the same proportion. Increasing the cost of storage opcodes may have adverse side effects, such as shifting the economic assumptions around gas fees of deployed contracts, or possibly breaking invariants in current contract executions (as mentioned inEIP-20351, more research is needed on the potential effects of increasing the cost of storage opcodes).", "Specification": "A new gas counterparticlesUsedis added to the EVM, in addition to the existing gas countergasUsed. The unit 1 gas is equal to 10000 particles (PARTICLES_PER_GAS). TheparticlesUsedcounter is only increased for opcodes priced in particles (i.e. opcodes that cost less than 1 gas). If increasingparticlesUsedresults in an excess of 1 gas, then 1 gas is added togasUsed(and deducted fromparticlesUsed).", "Rationale": "Adoption of fractional gas costs should only be an implementation detail inside the EVM, and not alter the current user experience around transaction gas limits and block gas limits. The concept ofparticlesneed not be exposed to Ethereum users nor most contract authors, but only to EVM implementers and contract developers concerned with optimized gas usage. Furthermore, only the EVM logic for charging gas per opcode executed should be affected by this change. All other contexts dealing with gas and gas limits, such as block headers and transaction formats, should be unaffected.", "Ewasm": "The term \u201cparticles\u201d was first introduced for Ewasm3to enable gas accounting for low cost wasm instructions, while remaining compatible with EVM gas costs. This EIP proposes introducing particles as a new minimum gas unit for EVM opcodes, and is not related to Ewasm.", "Backwards Compatibility": "This change is not backwards compatible and requires a hard fork to be activated.", "Test Cases": "TODO", "Implementation": "TODO", "References": "1.EIP-2035: Stateless Clients - Repricing SLOAD and SSTORE to pay for block proofs", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- repricing sload and sstore: Increases the gas cost of SLOAD and SSTORE operations to accommodate the additional bandwidth needed for stateless clients using block proofs.\n- particle gas costs: Introduces a new unit of gas called \"particles\" (a fraction of gas) to reduce the cost of computational opcodes, enabling more efficient gas pricing.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2046, "url": "https://eips.ethereum.org/EIPS/eip-2046", "title": "Reduced gas cost for static calls made to precompiles", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-2046: Reduced gas cost for static calls made to precompiles": "This change reduces the gas cost of using precompiled contracts.", "": "This change reduces the gas cost of using precompiled contracts.", "Simple Summary": "This change reduces the gas cost of using precompiled contracts.", "Abstract": "Reduce the base gas cost of calling precompiles usingSTATICCALLfrom 700 to 40. This should allow more efficient use of precompiles as well as precompiles with a total cost below 700.", "Motivation": "The Spurious Dragon hard fork increased the cost of calls significantly to account for loading contract code from the state without making an exception for precompiles, whose \u201ccode\u201d is always loaded.", "Specification": "After blockHFtheSTATICCALL(0xfa) instruction charges different basic gas cost (GcallinYellow Paper\u2019s notation) depending on the destination address provided:", "Rationale": "Only theSTATICCALLinstruction was changed to reduce the impact of the change. This should not be a limiting factor, given precompiles (currently) do not have a state and cannot change the state.\nHowever, contracts created and deployed before Byzantium likely will not useSTATICCALLand as a result this change will not reduce their costs.", "Backwards Compatibility": "This EIP should be backwards compatible. The only effect is that the cost is reduced. Since the cost is not reduced to zero, it should not be possible for a malicious proxy contract, when deployed before\ntheHF, to do any state changing operation.", "Test Cases": "TBA", "Implementation": "TBA", "References": "This has been previously suggested as part ofEIP-1109andEIP-1231.\nHowever EIP-1109 was later changed to a very different approach. The authorhas suggested to change EIP-1109.", "Acknowledgements": "Jordi Baylina (@jbaylina) and Matthew Di Ferrante (@mattdf) who have proposed this before.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- spurious dragon hard fork: Specifies changes for the Spurious Dragon hard fork, including replay attack protection, state trie clearing, and contract code size limits.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2242, "url": "https://eips.ethereum.org/EIPS/eip-2242", "title": "Transaction Postdata", "authors": ["John Adler\u00a0(", "@adlerjohn", ")"], "sections": {"EIP-2242: Transaction Postdata": "An additional, optional transaction field is added for \u201cpostdata,\u201d data that is posted on-chain but that cannot be read from the EVM.", "": "An additional, optional transaction field is added for \u201cpostdata,\u201d data that is posted on-chain but that cannot be read from the EVM.", "Simple Summary": "An additional, optional transaction field is added for \u201cpostdata,\u201d data that is posted on-chain but that cannot be read from the EVM.", "Abstract": "A paradigm shift in how blockchains are used has been seen recently in Eth 2.0, with the rise ofExecution Environments(EEs), andstateless clients. This shift involves blockchains serving as a secure data availability and arbitration layer,i.e., they provide a globally-accepted source of available data, and process fraud/validity and data availability proofs. This same paradigm can be applied on Eth 1.x, replacing EEs withtrust-minimized side chains.", "Motivation": "WhileEIP-2028provides a reduction in gas cost of calldata, and is a step in the right direction of encouraging use of history rather than state, the EVM does not actually need to see all data that is posted on-chain. Following the principle of \u201cdon\u2019t pay for what you don\u2019t use,\u201d a distinct way of posting data on-chain, but without actually being usable within the EVM, is needed.", "Specification": "We propose a consensus modification, beginning atFORK_BLKNUM:", "Rationale": "The changes proposed are as minimal and non-disruptive to the existing EVM and transaction format as possible while also supporting possiblefuture extensionsthrough a version code.", "Backwards Compatibility": "The new transaction format is backwards compatible, as the newpostdatafield is optionally appended to existing transactions.", "Test Cases": "TODO", "Implementation": "TODO", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- transaction postdata: Introduces an optional postdata field in transactions for posting data on-chain, but not readable by the EVM, with a cost of 1 gas per byte.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170."}
{"eip": 2327, "url": "https://eips.ethereum.org/EIPS/eip-2327", "title": "BEGINDATA opcode", "authors": ["Martin Lundfall\u00a0(", "@MrChico", ")"], "sections": {"EIP-2327: BEGINDATA opcode": "Introduces a new opcodeBEGINDATA, which indicates that the remaining bytes of the contract should be regarded as data rather than contract code\nand cannot be executed.", "": "Introduces a new opcodeBEGINDATA, which indicates that the remaining bytes of the contract should be regarded as data rather than contract code\nand cannot be executed.", "Simple Summary": "Introduces a new opcodeBEGINDATA, which indicates that the remaining bytes of the contract should be regarded as data rather than contract code\nand cannot be executed.", "Abstract": "It is common for smart contracts to efficiently store data directly in the contract bytecode. Examples include constructor arguments, constant variables, compiler metadata and the contract runtime during the init phase. Currently, such data is not distinguished from normal bytecode and is still being analysed forJUMPDESTs by EVM interpreters. This EIP introduces a new opcodeBEGINDATAat byte0xb6, which marks the remainding bytecode as data, indicating to EVM interpreters, static analysis tools and chain explorers that the remaining bytes do not represent opcodes.", "Motivation": "TheBEGINDATAopcode has been suggested before as part of the EIPSubroutines and Static Jumps for the EVMEIP-615as a way to determine the position of jumptables in contract bytecode. It is here introduced in its own right in order to exclude data from theJUMPDESTanalysis of contracts, making it impossible to jump to data. This makes it easier for static analysis tools to analyse contracts, allows disassemblers, chain explorers and debuggers to not display data as a mess of INVALID opcodes and may even provide a marginal improvement in performance. It also helps scalability because it improves on-chain evaluation of transactions from other chains in that the validation that the code conforms to a certain pattern does not need to do a full jumpdest analysis to see that data is not executed and thus does not have to conform to the pattern (used by the optimism project). Additionally, it paves the way for suggestions such asEIP-1712to disallow unused opcodes, jumptablesEIP-615and speculative proposals to disallow for deployment of contracts with stack usage violations.", "Specification": "While computing the validJUMPDESTs of a contract, halt analysis once the firstBEGINDATAis encountered. In other words: A jump to any codelocation equal to or greater than the location of the firstBEGINDATAcauses aBAD_JUMP_DESTINATIONerror.\nIfBEGINDATAis encountered during contract execution, it has the same semantics asSTOP. It uses 0 gas.", "Rationale": "The byte0xb6was chosen to align withEIP-615.\nThe choice toSTOPifBEGINDATAis encountered is somewhat arbitrary. An alternative would be to be to abort the execution with an out-of-gas error.", "Backwards Compatibility": "The proposal will not change any existing contracts unless their current behaviour relies upon the usage of unused opcodes.", "Test Cases": "Test cases should include:\n1) A contract which jumps to a destinationX, whereXhas a pc value higher than theBEGINDATAopcode, and the byte atXis0x5b. This should fail with aBAD_JUMP_DESTINATIONerror.\n2) A contract which encounters theBEGINDATAopcode (should stop executing the current call frame)", "Implementation": "Not yet.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- subroutines and static jumps: Proposes static jumps and subroutines for the EVM to replace dynamic jumps, enhancing performance, formal verification, and code security.\n- begindata: Introduces the BEGINDATA opcode to mark the start of data in contract bytecode, signaling that the remaining bytes are non-executable.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2330, "url": "https://eips.ethereum.org/EIPS/eip-2330", "title": "EXTSLOAD opcode", "authors": ["Dominic Letz\u00a0(", "@dominicletz", ")", "Santiago Palladino\u00a0(", "@spalladino", ")"], "sections": {"EIP-2330: EXTSLOAD opcode": "This proposal adds a new opcodeEXTSLOADat0x5cwhich pops two items from the stack:<account address> <storage key>and pushes one item:<storage value>. The gas cost is sum of account access cost and storage read based onEIP-2929Access Lists.", "A new EVM opcode to read external contract storage data.": "This proposal adds a new opcodeEXTSLOADat0x5cwhich pops two items from the stack:<account address> <storage key>and pushes one item:<storage value>. The gas cost is sum of account access cost and storage read based onEIP-2929Access Lists.", "Abstract": "This proposal adds a new opcodeEXTSLOADat0x5cwhich pops two items from the stack:<account address> <storage key>and pushes one item:<storage value>. The gas cost is sum of account access cost and storage read based onEIP-2929Access Lists.", "Motivation": "While any off-chain application can read all contract storage data of all contracts, this is not possible for deployed smart contracts themselves. These are bound to use contract calls for any interaction including reading data from other contracts. This EIP adds an EVM opcode to directly read external contract storage.", "Specification": "A new EVM instructionEXTSLOAD (0x5c)that works likeSLOAD (0x54)but an additional parameter representing the contract that is to be read from.", "Gas cost pre-verkle": "Gas to be charged before Verkle Tree change is specified asACCOUNT_ACCESS_COST + STORAGE_READ_COSTwhere:", "Gas cost post-verkle": "It is important to consider that post Verkle tree change,ACCOUNT_ACCESS_COSTwill not be needed since a single account\u2019s storage would be spread across the entire global trie. Hence gas to be charged post Verkle Tree change is justSTORAGE_READ_COST, which is as specified inGas cost pre-verkle.", "Rationale": "This change is fully backwards compatible since it adds a new instruction.", "Backwards Compatibility": "This change is fully backwards compatible since it adds a new instruction.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- extsload: Introduces the EXTSLOAD opcode, allowing contracts to directly read external contract storage data, reducing gas costs and improving efficiency.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2474, "url": "https://eips.ethereum.org/EIPS/eip-2474", "title": "Coinbase calls", "authors": ["Ricardo Guilherme Schmidt\u00a0(", "@3esmit", ")"], "sections": {"EIP-2474: Coinbase calls": "Allow contracts to be called directly byblock.coinbase(block validator), without a transaction.", "": "Allow contracts to be called directly byblock.coinbase(block validator), without a transaction.", "Simple Summary": "Allow contracts to be called directly byblock.coinbase(block validator), without a transaction.", "Abstract": "In proof-of-work blockchains, validators are known as miners.", "Motivation": "In order to reduce the overhead of calls that don\u2019t usemsg.senderand are being called by validator withtx.gasPrice = 0.", "Specification": "The calls to be executed byblock.coinbasewould be included first at block, and would consume normally the gas of block, however they won\u2019t pay/cost gas, instead the call logic would pay the validator in other form.", "Rationale": "TBD", "Backwards Compatibility": "tx.origin = block.coinbasecould cause some issues on bad designed contracts, such as usingtx.originto validate a signature, an analysis on how contracts use tx.origin might be useful to decide if this is a good choice.", "Test Cases": "TBD", "Implementation": "TBD", "Security Considerations": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- coinbase calls: Allows the block coinbase (validator) to execute contracts directly without a transaction, where tx.origin = block.coinbase and gas.price = 0.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2488, "url": "https://eips.ethereum.org/EIPS/eip-2488", "title": "Deprecate the CALLCODE opcode", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-2488: Deprecate the CALLCODE opcode": "DeprecateCALLCODEin asomewhatbackwards compatible way, by making it always return failure.", "": "DeprecateCALLCODEin asomewhatbackwards compatible way, by making it always return failure.", "Abstract": "DeprecateCALLCODEin asomewhatbackwards compatible way, by making it always return failure.", "Motivation": "CALLCODEwas part of the Frontier release of Ethereum. In the first few weeks/months it became clear\nthat it cannot accomplish its intended design goal. This was rectified with introducingDELEGATECALL(EIP-7) in the Homestead update (early 2016).", "Specification": "Ifblock.number >= FORK_BLOCK, theCALLCODE(0xf2) instruction always returns0, which signals failure.", "Rationale": "It would be possible just to remove the opcode and exceptionally abort if it is encountered.\nHowever, by returning failure, the contract has a chance to act on it and potentially recover.", "Backwards Compatibility": "This is a breaking change and has a potential to break contracts. The author expects no contracts of any value\nshould be affected.", "Security Considerations": "TBA", "Test Cases": "TBA", "Implementation": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2515, "url": "https://eips.ethereum.org/EIPS/eip-2515", "title": "Implement Difficulty Freeze", "authors": ["James Hancock\u00a0(", "@madeoftin", ")"], "sections": {"EIP-2515: Implement Difficulty Freeze": "The difficulty Freeze is an alternative to the Difficulty Bomb that is implemented within the protocols difficulty adjustment algorithm. The Difficulty Freeze begins at a certain block height, determined in advance, freezes the difficulty and increases by 1% after that block forever. This does not stop the chain, but it incentivizes devs to upgrade at a regular cadence and requires any chain split to address the difficulty freeze.", "": "The difficulty Freeze is an alternative to the Difficulty Bomb that is implemented within the protocols difficulty adjustment algorithm. The Difficulty Freeze begins at a certain block height, determined in advance, freezes the difficulty and increases by 1% after that block forever. This does not stop the chain, but it incentivizes devs to upgrade at a regular cadence and requires any chain split to address the difficulty freeze.", "Simple Summary": "The difficulty Freeze is an alternative to the Difficulty Bomb that is implemented within the protocols difficulty adjustment algorithm. The Difficulty Freeze begins at a certain block height, determined in advance, freezes the difficulty and increases by 1% after that block forever. This does not stop the chain, but it incentivizes devs to upgrade at a regular cadence and requires any chain split to address the difficulty freeze.", "Abstract": "The difficulty Freeze is a mechanism that is easy to predict and model, and the pressures of missing it are more readily felt by the core developers and client maintainers. The client maintainers are also positioned as the group that is most able to respond to an incoming Difficulty Freeze. This combined with the predictability is more likely to lead to the timely diffusual of the bomb.", "Motivation": "The current difficulty bombs\u2019 effect on the Block Time Targeting mechanism is rather complex to model, and it has both appeared when it was not expected (Muir Glacier) and negatively affected miners when they are not the target (in the case of delaying forks due to technical difficulties). Miners are affected by a reduction in block rewards due to the increase in block time. Users are affected as a function of the usability of the chain is affected by increased block times. Both of these groups are unable on their own to address the difficulty bomb. In the case of the Difficulty Freeze, the consequences of missing it are more directly felt by the client maintainers and it is more predictiable and so knowing when to make the change is readily apparent.", "Specification": "Add variableDIFFICULTY_FREEZE_HEIGHT", "Rationale": "Block height is very easy to predict and evaluate within the system. This removes the effect of the Difficulty Bomb on block time, simplifying the block time targeting mechanism. The addition of an increase in the difficulty was added after feedback that the game theory of the mechanism did not reliably result in .", "Backwards Compatibility": "No backward incompatibilities", "Test Cases": "TBD", "Implementation": "TBD", "Security Considerations": "The effect of missing the Difficulty Freeze has a different impact than missing the Difficulty Bomb. At the point of a Difficulty freeze, the protocol is no longer able to adapt to changes in hash power on the network. This can lead to one of three scenarios.", "Economic Considerations": "Under the current Difficult, Bomb issuance of ETH is reduced as the Ice Age takes affect. Under the Difficulty Freeze, it is more likely that issuance would increase for a short time; however, clients are motivated to prevent this and keep clients syncing effectively. This means it is much less likely to occur. The increase to the difficulty over time will eventually reduce blocktimes and also issuance.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- difficulty freeze: Replaces the difficulty bomb with a difficulty freeze that begins at a specific block height, freezing difficulty and increasing it by 1% after that block.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2539, "url": "https://eips.ethereum.org/EIPS/eip-2539", "title": "BLS12-377 curve operations", "authors": ["Alex Vlasov\u00a0(", "@shamatar", ")", "hujw77\u00a0(", "@hujw77", ")"], "sections": {"EIP-2539: BLS12-377 curve operations": "This precompile adds operation on BLS12-377 curve (from Zexe paper) as a precompile in a set necessary toefficientlyperform operations such as BLS signature verification and perform SNARKs verifications. Unique properties of BLS12-377 also later allow to have SNARKs that check BLS12-377 pairing in an efficient way and allow e.g. constant-size BLS signature aggregation.", "Precompiles for BLS12-377 curve operations": "This precompile adds operation on BLS12-377 curve (from Zexe paper) as a precompile in a set necessary toefficientlyperform operations such as BLS signature verification and perform SNARKs verifications. Unique properties of BLS12-377 also later allow to have SNARKs that check BLS12-377 pairing in an efficient way and allow e.g. constant-size BLS signature aggregation.", "Abstract": "This precompile adds operation on BLS12-377 curve (from Zexe paper) as a precompile in a set necessary toefficientlyperform operations such as BLS signature verification and perform SNARKs verifications. Unique properties of BLS12-377 also later allow to have SNARKs that check BLS12-377 pairing in an efficient way and allow e.g. constant-size BLS signature aggregation.", "Proposed addresses table": "Motivation of this precompile is to add a cryptographic primitive that allows to get 120+ bits of security for operations over pairing friendly curve compared to the existing BN254 precompile that only provides 80 bits of security. In addition it allows efficient one-time recursive proof aggregations, e.g. proofs about existence of BLS12-377 based signature.", "Motivation": "Motivation of this precompile is to add a cryptographic primitive that allows to get 120+ bits of security for operations over pairing friendly curve compared to the existing BN254 precompile that only provides 80 bits of security. In addition it allows efficient one-time recursive proof aggregations, e.g. proofs about existence of BLS12-377 based signature.", "Specification": "Curve parameters:", "Fine points and encoding of base elements": "To encode points involved in the operation one has to encode elements of the base field and the extension field.", "ABI for operations": "G1 addition call expects256bytes as an input that is interpreted as byte concatenation of two G1 points (128bytes each). Output is an encoding of addition operation result - single G1 point (128bytes).", "Prevention of DDoS on error handling": "This precompile performs extensive computations and in case of any errors during execution it MUST consume all gas from the gas schedule for the corresponding operation.", "Gas schedule": "Assuming a constant30 MGas/secondfollowing prices are suggested.", "Rationale": "Motivation section covers a total motivation to have operations over BLS12-377 curve available. We also extend a rationale for move specific fine points.", "Multiexponentiation as a separate call": "Explicit separate multiexponentiation operation that allows one to save execution time (so gas) by both the algorithm used (namely Peppinger algorithm) and (usually forgotten) by the fact thatCALLoperation in Ethereum is expensive (at the time of writing), so one would have to pay non-negigible overhead if e.g. for multiexponentiation of100points would have to call the multipication precompile100times and addition for99times (roughly138600would be saved).", "Backwards Compatibility": "There are no backward compatibility questions.", "Important notes": "Subgroup checkis mandatoryduring the pairing call. Implementationsshoulduse fast subgroup checks: at the time of writing multiplication gas cost is based ondouble-and-addmultiplication method that has a clear \u201cworst case\u201d (all bits are equal to one). For pairing operation it\u2019s expected that implementation uses faster subgroup check, e.g. by using wNAF multiplication method for elliptic curves that is ~40%cheaper with windows size equal to 4. (Tested empirically. Savings are due to lower hamming weight of the group order and even lower hamming weight for wNAF. Concretely, subgroup check for both G1 and G2 points in a pair are around35000combined).", "Test Cases": "Due to the large test parameters space we first provide properties that various operations must satisfy. We use additive notation for point operations, capital letters (P,Q) for points, small letters (a,b) for scalars. Generator for G1 is labeled asG, generator for G2 is labeled asH, otherwise we assume random point on a curve in a correct subgroup.0means either scalar zero or point of infinity.1means either scalar one or multiplicative identity.group_orderis a main subgroup order.e(P, Q)means pairing operation wherePis in G1,Qis in G2.", "Reference Implementation": "There is a various choice of existing implementations of the curve operations. It may require extra work to add an ABI:\n\t- Code bases with fixed parameters\n\t  - Rust: matter-labs\n\t  - C++: matter-labs\n\t- Original implementation linked in Zexe paper in Rust: github.com/scipr-lab/zexe\n\t- Standalone in Go: github.com/kilic/bls12-377", "Security Considerations": "Strictly following the spec will eliminate security implications or consensus implications in a contrast to the previous BN254 precompile.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2542, "url": "https://eips.ethereum.org/EIPS/eip-2542", "title": "New opcodes TXGASLIMIT and CALLGASLIMIT", "authors": ["Alex Forshtat\u00a0<", "forshtat1@gmail.com", ">"], "sections": {"EIP-2542: New opcodes TXGASLIMIT and CALLGASLIMIT": "A mechanism to allow smart contracts to access information on gas limits for the current transaction and execution frame.", "": "A mechanism to allow smart contracts to access information on gas limits for the current transaction and execution frame.", "Simple Summary": "A mechanism to allow smart contracts to access information on gas limits for the current transaction and execution frame.", "Abstract": "Currently, there is an existing opcode0x45 GASLIMITthat provides access to the block gas limit. While this information may be useful in some cases, it is probably not a value that smart contract developers may be concerned about. The opcode0x5a GASprovides the remaining gas, not the initial one. Also, it is worth noting how existing0x32 ORIGIN,0x33 CALLER,0x34 CALLVALUEand0x3a GASPRICEopcodes set a pattern of having access to both the transaction and current execution frame state.\nTBD: as 0x30 opcode range is exhausted, the proposed opcodes can be added to 0x50 range, or a new range can be added.", "Motivation": "As concepts of relaying, meta-transactions, gas fees, and account abstraction gain popularity, it becomes critical for some contracts to be able to track gas expenditure with absolute precision. Without access to this data on an EVM level, such contracts resort to approximation, mimicking EVM logic on-chain, and some use-cases even become infeasible.", "Specification": "If block.number >= TBD, add three new opcodes:", "Rationale": "Consider a solidity smart contract that wants to know how much gas the entire transaction or a part of it had consumed. It is not entirely possible with the current EVM. With proposed changes, using a pseudo-Solidity syntax, this information would be easily available:", "Backwards Compatibility": "This proposal introduces two new opcodes and renames an existing one, but stays fully backwards compatible apart from that.", "Forwards Compatibility": "A major consideration for this proposal is its alignment with one or many possible future modifications to the EVM:", "Security considerations": "Existing smart contracts are not affected by this change.Smart contracts that will use proposed opcodes must not use them for the core of any security features, but only as a source of information about their execution environment.", "Implementation": "The implementations must be completed before any EIP is given status \u201cFinal\u201d, but it need not be completed before the EIP is accepted. While there is merit to the approach of reaching consensus on the specification and rationale before writing code, the principle of \u201crough consensus and running code\u201d is still useful when it comes to resolving many discussions of API details.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- txgaslimit and callgaslimit: Introduces two new opcodes: TXGASLIMIT to push the transaction gas limit and CALLGASLIMIT to push the current execution frame's gas limit onto the stack.\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2583, "url": "https://eips.ethereum.org/EIPS/eip-2583", "title": "Penalty for account trie misses", "authors": ["Martin Holst Swende\u00a0(", "@holiman", ")"], "sections": {"EIP-2583: Penalty for account trie misses": "This EIP introduces a gas penalty for opcodes which access the account for trie non-existent accounts.", "": "This EIP introduces a gas penalty for opcodes which access the account for trie non-existent accounts.", "Simple Summary": "This EIP introduces a gas penalty for opcodes which access the account for trie non-existent accounts.", "Abstract": "This EIP adds a gas penalty for accesses to the account trie, where the address being looked up does not exist. Non-existing accounts can be used in \nDoS attacks, since they bypass cache mechanisms, thus creating a large discrepancy between \u2018normal\u2019 mode of execution and \u2018worst-case\u2019 execution of an opcode.", "Motivation": "As the ethereum trie becomes more and more saturated, the number of disk lookups that a node is required to do in order to access a piece of state increases too. This means that checking e.g.EXTCODEHASHof an account at block5wasinherentlya cheaper operation that it is at, say8.5M.", "Specification": "We define the constantpenaltyasTBD(suggested2000gas).", "Detailed specification": "These are the opcodes which triggers lookup into the main account trie:", "Notes on Call-derivatives": "ACALLtriggers a lookup of theCALLdestination address. The base cost forCALLis at700gas. A few other characteristics determine the actual gas cost of a call:", "Note onSELFDESTRUCT": "TheSELFDESTRUCTopcode also triggers an account trie lookup of thebeneficiary. However, due to the following reasons, it has been omitted from having apenaltysince it already costs5Kgas.", "Clarifications:": "With this scheme, we could continue to price these operations based on the \u2018normal\u2019 usage, but gain protection from attacks that try to maximize disk lookups/cache misses. \nThis EIP does not modify anything regarding storage trie accesses, which might be relevant for a future EIP. However, there are a few crucial differences.", "Rationale": "With this scheme, we could continue to price these operations based on the \u2018normal\u2019 usage, but gain protection from attacks that try to maximize disk lookups/cache misses. \nThis EIP does not modify anything regarding storage trie accesses, which might be relevant for a future EIP. However, there are a few crucial differences.", "Determining thepenalty": "A transaction with10Mgas can today cause ~14Ktrie lookups.", "Backwards Compatibility": "This EIP requires a hard-fork.", "Ether transfers": "A regulartransactionfrom one EOA to another, with value, is not affected.", "Layer 2": "Regarding layer-2 backward compatibility, this EIP is a lot less disruptive than EIPs which modify thebasecost of an opcode. For state accesses, there are \nseldom legitimate scenarios where", "Other": "The contractDentacoinwould be affected.", "Test Cases": "The following cases need to be considered and tested:", "Security Considerations": "See \u2018Backwards Compatibility\u2019", "Implementation": "Not yet available.", "Alternative variants": "Bump all trie accesses withpenalty.EXTCODEHASHbecomes2700instead of700.", "Alt 1: Insta-refunds": "Bump all trie accesses withpenalty.EXTCODEHASHbecomes2700instead of700.", "Alt 2: Parent bail": "Usepenaltyas described, but if a child context goes OOG on thepenalty, then the remainder is subtracted from the \nparent context (recursively).", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- penalty for account trie misses: Adds a gas penalty for trie accesses to non-existent accounts, reducing the discrepancy between normal and worst-case execution paths.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2584, "url": "https://eips.ethereum.org/EIPS/eip-2584", "title": "Trie format transition with overlay trees", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")"], "sections": {"EIP-2584: Trie format transition with overlay trees": "This EIP proposes a method to convert the state trie format from hexary to binary: new values are directly stored in a binary trie \u201claid over\u201d the hexary trie. Meanwhile, the hexary trie is converted to a binary trie in the background. When the process is finished, both layers are merged.", "": "This EIP proposes a method to convert the state trie format from hexary to binary: new values are directly stored in a binary trie \u201claid over\u201d the hexary trie. Meanwhile, the hexary trie is converted to a binary trie in the background. When the process is finished, both layers are merged.", "Simple Summary": "This EIP proposes a method to convert the state trie format from hexary to binary: new values are directly stored in a binary trie \u201claid over\u201d the hexary trie. Meanwhile, the hexary trie is converted to a binary trie in the background. When the process is finished, both layers are merged.", "Abstract": "This EIP describes a four phase process to complete the conversion.", "Motivation": "There is a long running interest in switching the state trie from a hexary format to a binary format, for reasons pertaining to proof and storage sizes. The conversion process poses a catch-up issue, caused by the sheer size of the full state: it can not be translated in a reasonable time (i.e. on the same order of magnitude as the block time).", "Specification": "This specification follows the notation introduced by theYellow Paper. Prior to reading it is advisable to be familiar with the Yellow Paper.", "Binary tries": "This EIP assumes that a binary trie is defined like the MPT, except that:", "Phase 1": "Leth\u2081be the previously agreed-upon block height at which phase 1 starts, andh\u2082the block at which phase 2 starts. For each block of height h\u2081 \u2264h< h\u2082:", "Phase 2": "This phase differs from the previous one on the following points:", "Phase 3": "Phase 3 is the same as phase 2, except for the following change:", "Rationale": "Methods that have been discussed until now include a \u201cstop the world\u201d approach, in which the chain is stopped for the significant amount of time that is required by the conversion, and a \u201ccopy on write\u201d approach, in which branches are converted upon being accessed.\nThe approach suggested here has the advantage that the chain continues to operate normally during the conversion process, and that the tree is fully converted to a binary format, in a predictable time.", "Backwards Compatibility": "This requires a fork and will break backwards compatibility, as the hashes and block formats will necessarily be different. This will cause a fork in clients that don\u2019t implement the overlay tree, and those that do not accept the new binary root. No mitigation is proposed, as this is a hard fork.", "Test Cases": "A prototype version of the conversion process (phase 1) is available forgethinthis PR.", "Implementation": "A prototype version of the conversion process (phase 1) is available forgethinthis PR.", "Security Considerations": "There are three attack vectors that I can foresee:", "Community feedback": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- trie format transition: Proposes a method to convert the Ethereum state trie from hexary to binary using overlay trees, enabling a phased transition.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2593, "url": "https://eips.ethereum.org/EIPS/eip-2593", "title": "Escalator fee market change for ETH 1.0 chain", "authors": ["Dan Finlay\u00a0<", "dan@danfinlay.com", ">"], "sections": {"EIP-2593: Escalator fee market change for ETH 1.0 chain": "The current \u201cfirst price auction\u201d fee model in Ethereum is inefficient and needlessly costly to users. This EIP proposes a way to replace this with a mechanism that allows dynamically priced transaction fees and efficient transaction price discovery.", "": "The current \u201cfirst price auction\u201d fee model in Ethereum is inefficient and needlessly costly to users. This EIP proposes a way to replace this with a mechanism that allows dynamically priced transaction fees and efficient transaction price discovery.", "Simple Summary": "The current \u201cfirst price auction\u201d fee model in Ethereum is inefficient and needlessly costly to users. This EIP proposes a way to replace this with a mechanism that allows dynamically priced transaction fees and efficient transaction price discovery.", "Abstract": "Based onThe Agoric Papers.", "Motivation": "Ethereum currently prices transaction fees using a simple first-price auction, which leads to well documented inefficiencies (some of which are documented inEIP-1559) when users are trying to estimate what price will get a transaction included in a block, especially during times of price volatility and full blocks.", "User Strategies Under Various Conditions and Algorithms": "First I will suggest a likely optimal strategy for different players under the conditions of the different algorithms being considered.", "User Results Under Various Conditions and Algorithms": "Now I will consider the ultimate results of the strategies listed above. Are users happy under these conditions? Did we save users money? Were users who wanted urgent inclusion able to secure it?", "Specification": "Client-Wide Parameters", "Backwards Compatibility": "Since a currentgasPricetransaction is effectively a flat-escalated transaction bid, it is entirely compatible with this model, and so there is no concrete requirement to deprecate current transaction processing logic, allowing cold wallets and hardware wallets to continue working for the foreseeable future.", "Test Cases": "TBD", "Implementation": "TBD", "Security Considerations": "The security considerations for this EIP are:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fee market change for eth 1.0 chain: Proposes a new transaction pricing mechanism with a base fee per gas, dynamically adjusting based on network congestion, and burned. Aims to reduce volatility, improve efficiency, and prevent miner manipulation of fees.\n- escalator fee market: Introduces the \"escalator\" fee model, allowing transactions to specify a start price, maximum price, and escalation over time for dynamic fee pricing.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2666, "url": "https://eips.ethereum.org/EIPS/eip-2666", "title": "Repricing of precompiles and Keccak256 function", "authors": ["Alex Vlasov\u00a0(", "@shamatar", ")"], "sections": {"EIP-2666: Repricing of precompiles and Keccak256 function": "This EIP tries to set prices of certain precompiles and built-in EVM function to be in line with their performance, consumed resources and newer changes in EVM itself.", "": "This EIP tries to set prices of certain precompiles and built-in EVM function to be in line with their performance, consumed resources and newer changes in EVM itself.", "Simple Summary": "This EIP tries to set prices of certain precompiles and built-in EVM function to be in line with their performance, consumed resources and newer changes in EVM itself.", "Abstract": "Costs of many precompiles and built-in functions are invalid at the current state of the clients. This EIP contains a list of changes to the pricing formulas to better reflect underlying computations\u2019 structure.", "Motivation": "Historical pricing for these functions in EVM does not reflect inner structure of the underlying computations (inner structure of the hash functions).", "Specification": "Ifblock_number >= Xset the gas cost of the following precompiles and Keccak256 opcode:", "Rationale": "Cost of functions being executed must accurately reflect real CPU time spent on computations, so benchmarking was performed for current precompiles and Keccak256 function to measure running time versus input parameters.", "Detailed summary of repricing approach": "This EIP relies on two facts:", "Benchmarks on the most popular clients": "Necessary benchmarks for EIP-2666 were provided by the clients and raw form is assembled inhere", "Tooling and data": "Reference material (from benchmarks of different clients) with raw data can be foundhere.", "Note on formulas structure": "There are terms in formulas that look likeA * 1and those are explicitly not combined to theBcoefficient to reflect that hash of an empty byte array requires to perform a round of hashing anyway.", "Backwards Compatibility": "Precompile repricings has happened in a past and can be considered standard procedure. Gas costs of many contracts is expected to reduce that may break re-entrancy protection measures based on fixed gas costs. In any case, such protection should have never been considered good and final.", "Test Cases": "Let\u2019s consider a simple example of Keccak256 hash of0,64and160bytes that can is a simple sanity check for implementation.", "Implementation": "There is no reference implementation at the time of writing as it requires just a simple change of constants in major clients.", "Security Considerations": "As described in backward compatibility section in some cases reduction of cost may allow e.g. re-entrancy that was not expected before, but we think that re-entrancy protection based on fixed gas costs is anyway flawed design decision.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2803, "url": "https://eips.ethereum.org/EIPS/eip-2803", "title": "Rich Transactions", "authors": ["Micah Zoltu\u00a0(", "@MicahZoltu", ")"], "sections": {"EIP-2803: Rich Transactions": "If a transaction has atoof addressx, then thedataof the transaction will be treated as EVM bytecode and it will be executed from the context of theCALLERof the transaction (aka: the transaction signer).", "Support 'rich transactions' by allowing transactions from externally owned accounts to execute bytecode directly.": "If a transaction has atoof addressx, then thedataof the transaction will be treated as EVM bytecode and it will be executed from the context of theCALLERof the transaction (aka: the transaction signer).", "Abstract": "If a transaction has atoof addressx, then thedataof the transaction will be treated as EVM bytecode and it will be executed from the context of theCALLERof the transaction (aka: the transaction signer).", "Motivation": "Many Ethereum DApps presently require users to approve multiple transactions in order to produce one effect - for example, the common pattern of first approving a contract to spend a token, then calling that contract. This results in a poor user-experience, and complicates the experience of interacting with DApps.", "Specification": "A new reserved address is specified atx, in the range used for precompiles. When a transaction is sent to this address from an externally owned account, the payload of the transaction is treated as EVM bytecode, and executed with the signer of the transaction as the current account. For clarity:", "Rationale": "The intent of this EIP is for the new precompile to act in all ways possible like aDELEGATECALLfrom an externally owned account. Some changes are required to reflect the fact that the code being executed is not stored on chain, and for special cases such asSELFDESTRUCT, to prevent introducing new edge-cases such as the ability to zero-out an EOA\u2019s nonce.", "Backwards Compatibility": "This EIP introduces a new feature that will need to be implemented in a future hard fork. No backwards compatibility issues with existing code are expected.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- rich transactions: Enables externally owned accounts (EOAs) to execute EVM bytecode directly, allowing EOAs to perform multiple atomic operations in a single transaction."}
{"eip": 2926, "url": "https://eips.ethereum.org/EIPS/eip-2926", "title": "Chunk-Based Code Merkleization", "authors": ["Sina Mahmoodi\u00a0(", "@s1na", ")", "Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-2926: Chunk-Based Code Merkleization": "Code merkleization, along with binarification of the trie and gas cost bump of state accessing opcodes, are considered as the main levers for decreasing block witness sizes in stateless or partial-stateless Eth1x roadmaps. Here we specify a fixed-sized chunk approach to code merkleization and outline how the transition of existing contracts to this model would look like.", "": "Code merkleization, along with binarification of the trie and gas cost bump of state accessing opcodes, are considered as the main levers for decreasing block witness sizes in stateless or partial-stateless Eth1x roadmaps. Here we specify a fixed-sized chunk approach to code merkleization and outline how the transition of existing contracts to this model would look like.", "Abstract": "Code merkleization, along with binarification of the trie and gas cost bump of state accessing opcodes, are considered as the main levers for decreasing block witness sizes in stateless or partial-stateless Eth1x roadmaps. Here we specify a fixed-sized chunk approach to code merkleization and outline how the transition of existing contracts to this model would look like.", "Motivation": "Bytecode is currently thesecond contributorto block witness size, after the proof hashes. Transitioning the trie from hexary to binary reduces the hash section of the witness by 3x, thereby making code the first contributor. By breaking contract code into chunks and committing to those chunks in a merkle tree, stateless clients would only need the chunks that were touched during a given transaction to execute it.", "Specification": "This specification assumes thatEIP-2584is deployed, and the merkleization rules and gas costs are proposed accordingly. What follows is structured to have two sections:", "Constants and Definitions": "For an account recordAwith codeC, the fieldA.codeHashis replaced withcodeRoot.codeRootisEMPTY_CODE_ROOTifCis empty. Otherwise it contains the root ofcodeTrie, abinary triewith the following leaves:", "Code merkleization": "For an account recordAwith codeC, the fieldA.codeHashis replaced withcodeRoot.codeRootisEMPTY_CODE_ROOTifCis empty. Otherwise it contains the root ofcodeTrie, abinary triewith the following leaves:", "Updating existing code (transition process)": "The transition process involves reading all contracts in the state and applying the above procedure to them. A benchmark showing how long this process will take is still pending, but intuitively it should take longer than the time between two blocks (in the order of hours). Hence we recommend clients to pre-process the changes before the EIP is activated.", "Rationale": "The Ethereum mainnet state is encoded as of now in a hexary Merkle Patricia Tree. As part of the Eth1x roadmap, a transition to abinary triehas beeninvestigatedwith the goal of reducing witness sizes. Because code chunks are also stored in the trie, this EIP would benefit from the witness size reduction offered by the binarification. Therefore we have decided to explicitly stateEIP-2584to be a requirement of this change. Note that if code merkleization is included in a hard-fork beforehand, then all code must be re-merkleized after the binary transition.", "Hexary vs binary trie": "The Ethereum mainnet state is encoded as of now in a hexary Merkle Patricia Tree. As part of the Eth1x roadmap, a transition to abinary triehas beeninvestigatedwith the goal of reducing witness sizes. Because code chunks are also stored in the trie, this EIP would benefit from the witness size reduction offered by the binarification. Therefore we have decided to explicitly stateEIP-2584to be a requirement of this change. Note that if code merkleization is included in a hard-fork beforehand, then all code must be re-merkleized after the binary transition.", "Chunk size": "The current recommended chunk size of 32 bytes has been selected based on a few observations. Smaller chunks are more efficient (i.e. have higherchunk utilization), but incur a larger hash overhead (i.e. number of hashes as part of the proof) due to a higher trie depth. Larger chunks are less efficient, but incur less hash overhead. We plan to run a larger experiment comparing various chunk sizes to arrive at a final recommendation.", "First instruction offset": "ThefirstInstructionOffsetfields allows safe jumpdest analysis when a client doesn\u2019t have all the chunks, e.g. a stateless clients receiving block witnesses.", "Gas cost of code-accessing opcodes": "How merkleized code is stored in the client database affects the performance of code-accessing opcodes, i.e: CALL, CALLCODE, DELEGATECALL, STATICCALL, EXTCODESIZE, EXTCODEHASH, and EXTCODECOPY. Storing the code trie with all intermediate nodes in the database implies multiple look-ups to fetch the code of the callee, which is more than the current one look-up (excluding the trie traversal to get the account) required. Note CODECOPY and CODESIZE are not affected since the code for the current contract has already been loaded to memory.", "Different chunking logic": "We have considered an alternative option to package chunks, where each chunk is prepended with itschunkLengthand would only contain complete opcodes (i.e. any multi-byte opcode not fitting theCHUNK_SIZEwould be deferred to the next chunk).", "RLP and SSZ": "To remain consistent with the binary transition proposal we avoid using RLP for serializing the leaf values. We have furthermore considered SSZ for both serializing data and merkleization and remain open to adopting it, but decided to use the binary trie format for simplicity.", "Metadata fields": "The metadata fieldsversion,codeLenandcodeHashare added mostly to facilitate a cheaper implementation ofEXTCODESIZEandEXTCODEHASHin a stateless paradigm. The version field allows for differentiating between bytecode types (e.g.EVM1.5/EIP-615,EIP-2315, etc.) or code merkleization schemes (or merkleization settings, such as largerCHUNK_SIZE) in future.", "The keys in the code trie (andKEY_LENGTH)": "As explained in the specification above, the keys in the code trie are indices of thechunksarray. Having a key length of 2 bytes means the trie can address 65536 - 3 (minus metadata fields) chunks, which corresponds to ~2Mb code size. That allows for roughly ~85x increase in the code size limit in future without requiring a change in merkleization.", "Alternate values of codeRoot for EoAs": "This proposal changes the meaning of the fourth field (codeHash) of the account. Prior to this change, that field represents the Keccak-256 hash of the bytecode, which is logically hash of an empty input for EoAs.", "Backwards Compatibility": "From the perspective of contracts, the design aims to be transparent, with the exception of changes in gas costs.", "Test Cases": "TBD", "Implementation": "The implementation of the chunking and merkleization logic in Typescript can be foundhere, and in Pythonhere. Please note neither of these examples currently use a binary tree.", "Security Considerations": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- chunk-based code merkleization: Splits contract code into fixed-size chunks and stores them in a Merkle tree, reducing witness sizes for stateless Ethereum clients.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2936, "url": "https://eips.ethereum.org/EIPS/eip-2936", "title": "EXTCLEAR Opcode For SELFDESTRUCTed contracts", "authors": ["William Morriss\u00a0(", "@wjmelements", ")"], "sections": {"EIP-2936: EXTCLEAR Opcode For SELFDESTRUCTed contracts": "Enable new opcode to clear storage forSELFDESTRUCTEDed contracts.", "": "Enable new opcode to clear storage forSELFDESTRUCTEDed contracts.", "Simple Summary": "Enable new opcode to clear storage forSELFDESTRUCTEDed contracts.", "Abstract": "ChangesSELFDESTRUCT(0xff) to not clear any storage and adds a newEXTCLEAR(0x5c) opcode that will clear a specific storage slot for a contract that has previously been self destructed.", "Motivation": "SELFDESTRUCT(0xFF) is unnecessarily complex because it clears an unbounded amount of contract storage.\nIt is computationally expensive for nodes to track all of the storage used in every contract in case the contractSELFDESTRUCTs.\nFurther, contracts can be re-initialized usingCREATE2(0xF5), and thenSLOAD(0x54) prior storage.\nTherefore, several ethereum clients do not clear storage at all, and just check if the contract was initiated sinceSSTORE(0x55) duringSLOAD.CREATE2was not intended to complicateSLOAD, and this change reverts that complexity.\nAlso, bugs in this implementation could split the network.", "Specification": "AfterFORK_BLOCK_NUM, a new opcode,EXTCLEAR, is enabled at0x5Cto clear storage forSELFDESTRUCTed contracts.EXTCLEAR:", "Rationale": "0x5Cis available in the same range asSSTOREandSLOAD.", "Backwards Compatibility": "A reincarnation upgrade mechanism that expects all internal storage to be cleared might break, but such an upgrade mechanism would allow adaptation to this new behavior.", "Test Cases": "TODO", "Implementation": "Implementation is required on all major clients to add the opcode.", "Security Considerations": "A reincarnated contract that does not expect its state to be cleared by malicious actors SHOULD reinitialize itself to avoid antagonisticEXTCLEAR.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- extclear opcode: Introduces the EXTCLEAR opcode to clear storage for contracts that have been SELFDESTRUCTed, without clearing storage during SELFDESTRUCT."}
{"eip": 2937, "url": "https://eips.ethereum.org/EIPS/eip-2937", "title": "SET_INDESTRUCTIBLE opcode", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-2937: SET_INDESTRUCTIBLE opcode": "Add aSET_INDESTRUCTIBLE (0xA8)opcode that prevents the contract from callingSELFDESTRUCT (0xFF).", "": "Add aSET_INDESTRUCTIBLE (0xA8)opcode that prevents the contract from callingSELFDESTRUCT (0xFF).", "Simple Summary": "Add aSET_INDESTRUCTIBLE (0xA8)opcode that prevents the contract from callingSELFDESTRUCT (0xFF).", "Abstract": "The intended use case would be for contracts to make their first byte of code be theSET_INDESTRUCTIBLEopcode if they wish to serve as libraries that guarantee to users that their code will exist unmodified forever. This is useful in account abstraction as well as other contexts.", "Motivation": "The intended use case would be for contracts to make their first byte of code be theSET_INDESTRUCTIBLEopcode if they wish to serve as libraries that guarantee to users that their code will exist unmodified forever. This is useful in account abstraction as well as other contexts.", "Specification": "Add a transaction-wide global variableglobals.indestructible: Set[Address](i.e. a variable that operates the same way as the selfdestructs set), initialized to the empty set.", "Rationale": "Alternative proposals to this include:", "Backwards Compatibility": "TBD", "Security Considerations": "This breaks forward compatibility withsomeforms of state rent, which would simply delete contracts that get too old without paying some maintenance fee. However, this is not the case with all state size control schemes; for example this is not an issue if we useReGenesis.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- set_indestructible opcode: Adds the SET_INDESTRUCTIBLE opcode, preventing a contract from being destroyed via SELFDESTRUCT.\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures."}
{"eip": 2938, "url": "https://eips.ethereum.org/EIPS/eip-2938", "title": "Account Abstraction", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")", "Matt Garnett\u00a0(", "@lightclient", ")", "Will Villanueva\u00a0(", "@villanuevawill", ")", "Sam Wilson\u00a0(", "@SamWilsn", ")"], "sections": {"EIP-2938: Account Abstraction": "Account abstraction (AA) allows a contract to be the top-level account that pays fees and starts transaction execution.", "": "Account abstraction (AA) allows a contract to be the top-level account that pays fees and starts transaction execution.", "Simple Summary": "Account abstraction (AA) allows a contract to be the top-level account that pays fees and starts transaction execution.", "Abstract": "See also:https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020and the links therein for historical work and motivation.", "Motivation": "The existing limitations preclude innovation in a number of important areas, particularly:", "Specification": "AfterFORK_BLOCK, the following changes will be recognized by the protocol.", "Single Tenant": "AfterFORK_BLOCK, the following changes will be recognized by the protocol.", "Single Tenant+": "If theindestructible contracts EIPis added, Single Tenant AA can be adapted to allow forDELEGATECALLduring transaction verification: during execution of a new AA transaction, external state access that reads code (EXTCODESIZE,EXTCODEHASH,EXTCODECOPY,CALLCODE,DELEGATECALL) of any contract whose first byte is theSET_INDESTRUCTIBLEopcode is no longer banned. However, calls to anything but thetargetor a precompile that change thecallee(i.e., calls other thanCALLCODEandDELEGATECALL) are still not permitted.", "Multi-Tenant & Beyond": "In a later stage, we can add support for multiple pending transactions per account in the mempool. The main challenge here is that a single transaction can potentially cause state changes that invalidate all other transactions to that same account. Additionally, if we naively prioritize transactions by gasprice, there is an attack vector where the user willing to pay the highest gasprice publishes many (mutually exclusive) versions of their transaction with small alterations, thereby pushing everyone else\u2019s transactions out of the mempool.", "Rationale": "The core problem in an account abstraction setup is always that miners and network nodes need to be able to verify that a transaction that they attempt to include, or rebroadcast, will actually pay a fee. Currently, this is fairly simple, because a transaction is guaranteed to be includable and pay a fee as long as the signature and nonce are valid and the balance and gasprice are sufficient. These checks can be done quickly.", "Nonces still enshrined in single-tenant AA": "Nonces are still enforced in single-tenant AA to ensure that single-target AA does not break the invariant that each transaction (and hence each transaction hash) can only be included in the chain once. While there is some limited value in allowing arbitrary-order transaction inclusion in single-tenant AA, there is not enough value to justify breaking that invariant.", "Nonces are exposed to the EVM": "This is done to allow signature checking done in validation code to validate the nonce.", "Replay Protection": "One of the above two approaches (requiringSET_INDESTRUCTIBLEor modifyingSELFDESTRUCTbehavior) must be implemented so that nonces cannot be reused. It must be a consensus change, and not simply part ofAA_PREFIX, so that transaction hash uniqueness is maintained.", "Miners refuse transactions that access external data or the target\u2019s own balance, before PAYGAS": "An important property of traditional transactions is that activity happening as part of transactions that originate outside of some given account X cannot make transactions whose sender is X invalid. The only state change that an outside transaction can impose on X is increasing its balance, which cannot invalidate a transaction.", "AA transactions must call contracts with prefix": "The prelude is used to ensure thatonlyAA transactions can call the contract. This is another measure taken to ensure the invariant described above. If this check did not occur, it would be possible for a transaction originating outside some AA account X to call into X and make a storage change, forcing transactions targeting that account to be reprocessed at the cost of a mere 5000 gas.", "Multi-tenant AA": "Multi-tenant AA extends single-tenant AA bybetter handling cases where distinct and uncoordinated users attempt to send transactions for/to the same account and those transactions may interfere with each other.", "Backwards Compatibility": "This AA implementation preserves the existing transaction type. The use ofassert origin == callerto verify that an account is an EOA remains sound, but is not extensible to AA accounts; AA transactions will always haveorigin == AA_ENTRY_POINT.", "Test Cases": "See:https://github.com/quilt/tests/tree/account-abstraction", "Implementation": "See:https://github.com/quilt/go-ethereum/tree/account-abstraction", "Security Considerations": "Seehttps://ethresear.ch/t/dos-vectors-in-account-abstraction-aa-or-validation-generalization-a-case-study-in-geth/7937for an analysis of DoS issues.", "Re-validation": "When a transaction enters the mempool, the client is able to quickly ascertain whether the transaction is valid. Once it determines this, it can be confident that the transaction will continue to be valid unless a transaction from the same account invalidates it.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures."}
{"eip": 2970, "url": "https://eips.ethereum.org/EIPS/eip-2970", "title": "IS_STATIC opcode", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-2970: IS_STATIC opcode": "Add aIS_STATIC (0x4A)opcode that pushes1if the current context is static (ie. the execution is in aSTATICCALLor a descendant thereof, so state-changing operations are not possible), and0if it is not.", "": "Add aIS_STATIC (0x4A)opcode that pushes1if the current context is static (ie. the execution is in aSTATICCALLor a descendant thereof, so state-changing operations are not possible), and0if it is not.", "Simple Summary": "Add aIS_STATIC (0x4A)opcode that pushes1if the current context is static (ie. the execution is in aSTATICCALLor a descendant thereof, so state-changing operations are not possible), and0if it is not.", "Abstract": "The main intended use case is to allow account abstraction (EIP 2938) to be extended so that accounts can allow static calls from the outside (which are harmless to AA\u2019s security model) but not state-changing calls.", "Motivation": "The main intended use case is to allow account abstraction (EIP 2938) to be extended so that accounts can allow static calls from the outside (which are harmless to AA\u2019s security model) but not state-changing calls.", "Specification": "Add aIS_STATIC (0x4A)opcode that pushes1if the current context is static (ie. the execution is in aSTATICCALLor a descendant thereof, so state-changing operations are not possible), and0if it is not.", "Rationale": "Determining staticness is already possibly using the following hacky technique: make aCALLwith limited gas, and inside thatCALLissue oneLOGand exit. If the context is static, theCALLwould fail and leave a 0 on the stack; if the context is non-static, theCALLwould succeed. However, this technique is fragile against changes to gas costs, and is needlessly wasteful. Hence, the status quo neither allows a reasonably effective way of determining whether or not the context is static, nor provides any kind of invariant that executions that do not fail outright will execute the same way in a static and non-static context. This EIP provides a cleaner way of determining staticness.", "Backwards Compatibility": "TBD", "Security Considerations": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- is_static opcode: Introduces the IS_STATIC opcode, which indicates if the current context is static (i.e., part of a STATICCALL) to enhance account abstraction and security.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2997, "url": "https://eips.ethereum.org/EIPS/eip-2997", "title": "IMPERSONATECALL Opcode", "authors": ["Sergio Demian Lerner\u00a0(", "@SergioDemianLerner", ")"], "sections": {"EIP-2997: IMPERSONATECALL Opcode": "Add a new opcode,IMPERSONATECALLat0xf6, which is similar in idea toCALL (0xF1), except that it impersonates a sender, i.e. the callee sees a sender different from the real caller. The impersonated sender address is derived from the real caller address and a salt.", "": "Add a new opcode,IMPERSONATECALLat0xf6, which is similar in idea toCALL (0xF1), except that it impersonates a sender, i.e. the callee sees a sender different from the real caller. The impersonated sender address is derived from the real caller address and a salt.", "Abstract": "Add a new opcode,IMPERSONATECALLat0xf6, which is similar in idea toCALL (0xF1), except that it impersonates a sender, i.e. the callee sees a sender different from the real caller. The impersonated sender address is derived from the real caller address and a salt.", "Motivation": "This proposal enables native multi-user wallets (wallets that serve multiple users) that can be commanded by EIP-712 based messages and therefore enable meta-transactions. Multi-user wallets also enable the aggregation of transfer operations in batches similar to rollups, but maintaining the same address space as normal onchain transactions, so the sender\u2019s wallet does not need to be upgraded to support sinding ether or tokens to a user of a multi-user wallet. \nAdditionally, many times a sponsor company wants to deploy non-custodial smart wallets for all its users. The sponsor does not want to pay the deployment cost of each user contract in advance. Counterfactual contract creation enables this, yet it forces the sponsor to create the smart wallet (or a proxy contract to it) when the user wants to transfer ether or tokens out of his/her account for the first time. This proposal avoids this extra cost, which is at least 42000 gas per user.", "Specification": "IMPERSONATECALL:0xf6, takes 7 operands:", "Computation of impersonated sender": "The impersonated sender address is computed askeccak256( 0xff ++ address ++ salt ++ zeros32)[12:].", "Notes": "Even ifIMPERSONATECALLrequires hashing 3 words, implying an additional cost of 180 gas, we think the benefit of accounting for hashing doesn\u2019t not compensate increasing the complexity of the implementation.", "Rationale": "Even ifIMPERSONATECALLrequires hashing 3 words, implying an additional cost of 180 gas, we think the benefit of accounting for hashing doesn\u2019t not compensate increasing the complexity of the implementation.", "Clarifications": "The opcode number0xf6is currently unused and results in an out-of-gas (OOG) exception.  Solidity uses theINVALID (0xfe)opcode (calledABORTby EIP-1803) to raise OOG exceptions, so the0xf6opcode does not appear in normal Solidity programs. Programmers are already advised not to include this opcode in contracts written in EVM assembly.  Therefore is does not pose any backward compatibility risk.", "Backward Compatibility": "The opcode number0xf6is currently unused and results in an out-of-gas (OOG) exception.  Solidity uses theINVALID (0xfe)opcode (calledABORTby EIP-1803) to raise OOG exceptions, so the0xf6opcode does not appear in normal Solidity programs. Programmers are already advised not to include this opcode in contracts written in EVM assembly.  Therefore is does not pose any backward compatibility risk.", "Test Cases": "We present 4 examples of impersonated address derivation:", "Security Considerations": "The address derivation scheme prevents address collision with another deployed contract or an externally owned account, as the impersonated sender address is derived from the real caller address and a salt.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- impersonatecall: Introduces the IMPERSONATECALL opcode, allowing a contract to impersonate a sender derived from the real caller and a salt, enabling meta-transactions and native multi-user wallets.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3026, "url": "https://eips.ethereum.org/EIPS/eip-3026", "title": "BW6-761 curve operations", "authors": ["Youssef El Housni\u00a0(", "@yelhousni", ")", "Michael Connor\u00a0(", "@iAmMichaelConnor", ")", "Aurore Guillevic\u00a0<", "aurore.guillevic@inria.fr", ">", "hujw77\u00a0(", "@hujw77", ")"], "sections": {"EIP-3026: BW6-761 curve operations": "This precompile adds operations for the BW6-761 curve (from the EY/InriaOptimized and secure pairing-friendly elliptic curves suitable for one layer proof compositionresearch paper) as a precompile in a set necessary toefficientlyperform verification of one-layer composed zkSNARKs proofs.\nIfblock.number >= Xwe introducesevenseparate precompiles to perform the following operations (addresses to be determined):", "Precompiles for BW6-761 curve operations": "This precompile adds operations for the BW6-761 curve (from the EY/InriaOptimized and secure pairing-friendly elliptic curves suitable for one layer proof compositionresearch paper) as a precompile in a set necessary toefficientlyperform verification of one-layer composed zkSNARKs proofs.\nIfblock.number >= Xwe introducesevenseparate precompiles to perform the following operations (addresses to be determined):", "Abstract": "This precompile adds operations for the BW6-761 curve (from the EY/InriaOptimized and secure pairing-friendly elliptic curves suitable for one layer proof compositionresearch paper) as a precompile in a set necessary toefficientlyperform verification of one-layer composed zkSNARKs proofs.\nIfblock.number >= Xwe introducesevenseparate precompiles to perform the following operations (addresses to be determined):", "Motivation": "This EIP is based on and tends to replace matter-labs\u2019 proposol for significant performance reasons. In most applications, BW6-761 is used as an outer curve to BLS12-377 considered inEIP-2539.\nThe motivation of this precompile is to allow efficient one-layer composition of SNARK proofs. Currently this is done by Zexe using the BLS12-377/CP6-782 pair of curves. This precompile proposes a replacement of CP6-782 by BW6-761, which allows much faster operations. For example, it was shown that verifying a Groth16 proof with BW6-761 is 30 times faster than with CP6-782.", "Proposed addresses table": "Curve parameters:", "Specification": "Curve parameters:", "Encoding": "To encode points involved in the operation one has to encode elements of only the base field.", "ABI for operations": "G1 addition call expects384bytes as an input that is interpreted as the byte concatenation of two G1 points (point-encoded as192bytes each). Output is a point-encoding of the addition operation result.", "Prevention of DDoS on error handling": "This precompile performs extensive computations and in case of any errors during execution itMUSTconsume all gas from the gas schedule for the corresponding operation.", "Gas schedule": "180gas", "Rationale": "Gas costs are based onEIP-1962estimation strategy (but do not fully include yet parsing of ABI, decoding and encoding of the result as a byte array).", "Gas estimation strategy": "Gas cost is derived by taking the average timing of the same operations over different implementations and assuming a constant30 MGas/second. Since the execution time is machine-specific, this constant is determined based on execution times ofECRECOVERandBNPAIRprecompiles on my machine and their proposed gas price (43.5 MGas/sfor ECRECOVER and16.5 MGas/sfor BNPAIR). Following are the proposed methods to time the precompile operations:", "Multiexponentiation as a separate call": "Explicit separate multiexponentiation operation that allows one to save execution time (so gas) by both the algorithm used (namely Peppinger algorithm) and (usually forgotten) by the fact thatCALLoperation in Ethereum is expensive (at the time of writing), so one would have to pay non-negigible overhead if e.g. for multiexponentiation of100points would have to call the multipication precompile100times and addition for99times (roughly138600would be saved).", "Explicit subgroup checks": "G2 subgroup check has the same cost as G1 subgroup check. Endomorphisms can be leverages to optimize this operation.", "Backwards Compatibility": "There are no backward compatibility questions.", "Test Cases": "Due to the large test parameters space we first provide properties that various operations must satisfy. We use additive notation for point operations, capital letters (P,Q) for points, small letters (a,b) for scalars. Generator for G1 is labeled asG, generator for G2 is labeled asH, otherwise we assume random point on a curve in a correct subgroup.0means either scalar zero or point of infinity.1means either scalar one or multiplicative identity.group_orderis a main subgroup order.e(P, Q)means pairing operation wherePis in G1,Qis in G2.", "Reference Implementation": "There is a various choice of existing implementations:", "Security Considerations": "Strictly following the spec will eliminate security implications or consensus implications in a contrast to the previous BN254 precompile.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- bw6-761 curve operations: Introduces precompiles for performing elliptic curve operations on the BW6-761 curve, enabling efficient verification of zkSNARK proofs.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3068, "url": "https://eips.ethereum.org/EIPS/eip-3068", "title": "Precompile for BN256 HashToCurve Algorithms", "authors": ["Dr. Christopher Gorman\u00a0(", "@chgormanMH", ")"], "sections": {"EIP-3068: Precompile for BN256 HashToCurve Algorithms": "This EIP defines a hash-to-curve precompile for use in BN256\nand would allow for cheaper BLS signature verification.", "": "This EIP defines a hash-to-curve precompile for use in BN256\nand would allow for cheaper BLS signature verification.", "Simple Summary": "This EIP defines a hash-to-curve precompile for use in BN256\nand would allow for cheaper BLS signature verification.", "Abstract": "There is currently no inexpensive way to perform BLS signature\nverification for arbitrary messages.\nThis stems from the fact that there is no precompiled contract\nin the EVM for a hash-to-curve algorithm for the BN256 elliptic curve.\nThe gas cost of calling a deterministic hash-to-curve algorithm\nwritten in Solidity is approximately that of one pairing check,\nalthough the latter requires an order of magnitude\nmore computation.\nThis EIP remedies this by implementing a hash-to-curve algorithm\nfor the BN256 G1 curve, which would reduce the cost of\nsignature verification to essentially that of the pairing check\nprecompiled contract.\nWe also include a hash-to-curve algorithm for the BN256 G2 group.", "Motivation": "The precompiled contracts inEIP-198andEIP-1108increased usage of cryptographic operations in the EVM\nby reducing the gas costs.\nIn particular, the cost reduction fromEIP-1108helps increase the use of SNARKs in Ethereum\nvia an elliptic curve pairing check;\nhowever, a hash-to-curve algorithm enabling arbitrary\nBLS signature verification on BN256 in the EVM was noticeably missing.\nThere is interest in having a precompiled contract which would allow\nfor signature verification, as notedhere.", "Specification": "Here is the pseudocode for theHashToG1function:", "Rationale": "The BaseToG1 algorithm is based on the original Fouque and Tibouchipaperwith modifications based on Wahby and Boneh\u2019spaper.\nThere is freedom in choosing the HashToBase function\nand this could easily be changed.\nWithin HashToBase, the particular hashing algorithm\n(Keccak256 in our case) could also be modified.\nIt may be desired to change the call tosign0at the end of BaseToG1 and BaseToTwist withis_square,\nas this would result in the same deterministic map to curve from the\nFouque and Tibouchipaperand ensure HashToG1 is indifferentiable from a random oracle;\nthey proved this result in their paper.\nIt may be possible to show that switching theis_squarecall withsign0does not affect indifferentiability,\nalthough this has not been proven.", "Backwards Compatibility": "There are no backward compatibility concerns.", "Test Cases": "TBD", "Implementation": "TBD", "Security Considerations": "Due to recentwork, the\n128-bit security promised by the BN256 elliptic curve no longer applies;\nthis was mentioned in the Cloudflare BN256library.\nThere has been some discussion on the exact security decrease\nfrom this advancement; see thesetwopapersfor different estimates.\nThe more conservative estimate puts the security of BN256 at\n100-bits.\nWhile this is likely still out of reach for many adversaries,\nit should give us pause.\nThis reduced security was noted in the recent MadNetwhitepaper,\nand this security concern was partially mitigated by\nrequiring Secp256k1 signatures of the partial group signatures\nin order for those partial signatures to be valid.\nFull disclosure: the author of this EIP works for MadHive,\nassisted in the development of MadNet, and\nhelped write the MadNet whitepaper.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- bn256 hashtocurve algorithms: Introduces a precompile for the BN256 curve to enable efficient hash-to-curve operations, facilitating cheaper BLS signature verification.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3074, "url": "https://eips.ethereum.org/EIPS/eip-3074", "title": "AUTH and AUTHCALL opcodes", "authors": ["Sam Wilson\u00a0(", "@SamWilsn", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")", "Matt Garnett\u00a0(", "@lightclient", ")", "Micah Zoltu\u00a0(", "@micahzoltu", ")"], "sections": {"EIP-3074: AUTH and AUTHCALL opcodes": "This EIP introduces two EVM instructionsAUTHandAUTHCALL. The first sets a context variableauthorizedbased on an ECDSA signature. The second sends a call as theauthorizedaccount. This essentially delegates control of the externally owned account (EOA) to a smart contract.", "Allow externally owned accounts to delegate control to a contract.": "This EIP introduces two EVM instructionsAUTHandAUTHCALL. The first sets a context variableauthorizedbased on an ECDSA signature. The second sends a call as theauthorizedaccount. This essentially delegates control of the externally owned account (EOA) to a smart contract.", "Abstract": "This EIP introduces two EVM instructionsAUTHandAUTHCALL. The first sets a context variableauthorizedbased on an ECDSA signature. The second sends a call as theauthorizedaccount. This essentially delegates control of the externally owned account (EOA) to a smart contract.", "Motivation": "Adding more functionality to EOAs has been a long-standing feature request. The requests have spanned from implementing batching capabilities, allowing for gas sponsoring, expirations, scripting, and beyond. These changes often mean increased complexity and rigidity of the protocol. In some cases, it also means increased attack surfaces.", "Specification": "MAGICis used forEIP-3074signatures to prevent signature collisions with other signing formats.", "Conventions": "MAGICis used forEIP-3074signatures to prevent signature collisions with other signing formats.", "Constants": "MAGICis used forEIP-3074signatures to prevent signature collisions with other signing formats.", "Context Variables": "The context variableauthorizedshall indicate the active account forAUTHCALLinstructions in the current frame of execution. If set,authorizedshall only contain an account which has given the contract authorization to act on its behalf. An unset value shall indicate that no such account is set and that there is not yet an active account forAUTHCALLinstructions in the current frame of execution.", "AUTH(0xf6)": "A new opcodeAUTHshall be created at0xf6. It shall take three stack element inputs (the last two describing a memory range), and it shall return one stack element.", "AUTHCALL(0xf7)": "A new opcodeAUTHCALLshall be created at0xf7. It shall take seven stack elements and return one stack element. It matches the behavior of the existingCALL(0xF1) instruction, except where noted below.", "Rationale": "The signature format (yParity,r, ands) is fixed, so it might seem curious thatauthaccepts a dynamic memory range. The signature is placed in memory so thatauthcan be upgraded in the future to work with contract accounts (which might use non-ECDSA signatures) and not just EOAs.", "Signature in Memory": "The signature format (yParity,r, ands) is fixed, so it might seem curious thatauthaccepts a dynamic memory range. The signature is placed in memory so thatauthcan be upgraded in the future to work with contract accounts (which might use non-ECDSA signatures) and not just EOAs.", "Signing AddressauthArgument": "Includingauthority(the signing address) as an argument toauthallows future upgrades to the instruction to work with contract accounts, and not just EOAs.", "Reserving One Sixty-Fourth of Available Gas": "AUTHCALLwill not pass more than 63/64th of the available gas for the reasons enumerated inEIP-150.", "Throwing for UnsetauthorizedDuringAUTHCALL": "A well-behaved contract should never reach anAUTHCALLwithout having successfully setauthorizedbeforehand. The safest behavior, therefore, is to exit the current frame of execution immediately. This is especially important in the context of transaction sponsoring / relaying, which is expected to be one of the main use cases for this EIP. In a sponsored transaction, the inability to distinguish between a sponsee-attributable fault (like a failing sub-call) and a sponsor-attributable fault (like a failingAUTH) is especially dangerous and should be prevented because it charges unfair fees to the sponsee.", "Another Sponsored Transaction EIP": "There are two general approaches to separating the \u201cfee payer\u201d from the \u201caction originator\u201d.", "What to Sign?": "As originally written, this proposal specified a precompile with storage to track nonces. Since a precompile with storage is unprecedented, a revision moved replay protection into the invoker contract, necessitating a certain level of user trust in the invoker. Expanding on this idea of trusted invokers, the other signed fields were eventually eliminated, one by one, until onlyinvokerandcommitremained. To appease concerns about cross-chain replay attacks and irrevocable signatures, thechainIdandnoncefields returned to the signed message.", "Understandingcommit": "Earlier iterations of this EIP included mechanisms for replay protection, and also signed over value, gas, and other arguments toAUTHCALL. After further investigation, we revised this EIP to its current state: explicitly delegate these responsibilities to the invoker contract.", "Invoker Contracts": "The invoker contract is a trustless intermediary between the sponsor and sponsee. A sponsee signs overinvokerto require the transaction to be processed only by a contract they trust. This allows them to interact with sponsors without needing to trust them.", "On Call Depth": "The EVM limits the maximum number of nested calls, and naively allowing a sponsor to manipulate the call depth before reaching the invoker would introduce a griefing attack against the sponsee. That said, with the 63/64th gas rule, and the cost ofAUTHCALL, the stack is effectively limited to a much smaller depth than the hard maximum by thegasparameter.", "Source ofvalue": "In previous iterations of this EIP, it was thought that deducting value from an EOA mid-execution was problematic. This was due to an invariant of pending transactions which allows tx pools to statically determine the validity of a given transaction.", "Allowingtx.originas Signer": "Allowingauthorizedto equaltx.originhas the possibility to:", "AUTHCALLcheaper thanCALLwhen sending value": "Sending non-zero value withCALLincreases its cost by 9,000. Of that, 6,700 covers the increased overhead of the balance transfer and 2,300 is used as a stipend into the subcall to seed its gas counter.AUTHCALLdoes not provide a stipend and thus only charges the base 6,700.", "In-Protocol Revocation": "This EIP has goneback and forthon how to deal withAUTHmessage revocation. Without revocation, this EIP is a supremely powerful and flexible primitive for developers. However, it does have risk for users who use insecure and/or actively malicious invokers.", "Failing onEXTCODESIZEcheck": "InEIP-3607, it was determined that the protocol should reject any transaction which originates from an account with code. Although this EIP focused on transaction origination, the authors of EIP-3074 feel the intention is clear: an account that has both code and a known private key should not be allowed to make arbitrary calls on behalf of said account. Therefore, the property is upheld in this EIP. For full rationale, please refer toEIP-3607.", "Backwards Compatibility": "Although this EIP poses no issues for backwards compatibility, there are concerns that it limits future changes to accounts by further enshrining ECDSA signatures. For example, it might be desirable to eradicate the concept of EOAs altogether, and replace them with smart contract wallets that emulate the same behavior. This is fully compatible with the EIP as written, however, it gets tricky if users can then elect to \u201cupgrade\u201d their smart contract wallets to use other methods of authentication \u2013 e.g. convert into a multi-sig. Without any changes,AUTHwould not respect this new logic and continue allowing the old private key to perform actions on behalf of the account.", "Security Considerations": "The following is a non-exhaustive list of checks/pitfalls/conditions that invokersshouldbe wary of:", "Secure Invokers": "The following is a non-exhaustive list of checks/pitfalls/conditions that invokersshouldbe wary of:", "Sponsored Transaction Relayers": "It is possible for theauthorizedaccount to cause sponsored transaction relayers to spend gas without being reimbursed by either invalidating the authorization (i.e. increasing the account\u2019s nonce) or by sweeping the relevant assets out of the account. Relayers should be designed with these cases in mind, possibly by requiring a bond to be deposited or by implementing a reputation system.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- auth and authcall: Introduces two opcodes, AUTH and AUTHCALL, allowing externally owned accounts (EOAs) to delegate control to a contract, enabling sponsored transactions and other flexible transaction schemes.\n- magic: A constant value set as 0xef0100 used in the CREATE_DELEGATE instruction.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3102, "url": "https://eips.ethereum.org/EIPS/eip-3102", "title": "Binary trie structure", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-3102: Binary trie structure": "Change the storage structure from hexary to binary, merge the account and storage tries, and use blake2b.", "": "Change the storage structure from hexary to binary, merge the account and storage tries, and use blake2b.", "Simple Summary": "Change the storage structure from hexary to binary, merge the account and storage tries, and use blake2b.", "Abstract": "This proposal presents a binary structure and merkelization rule for the account and storage tries, which are merged into a single \u201cstate\u201d trie. RLP and most of the MPT\u2019s optimizations are dropped to simplify the design. Keccak256 is replaced with blake2b.", "Motivation": "The current design of the Merkle Patricia Trie (MPT) uses an hexary trie. Hexary Merkle trees are more shallow than their binary counterparts, which means less hashing.\nOver the course of the 5 years of Ethereum\u2019s existence, it has become apparent that disk accesses are a greater bottleneck than hashing. Clients are therefore moving away from a storage model in which all internal nodes are stored, in favor of a flat (key, value) storage model first used by turbo-geth, in which the intermediate nodes are recalculated only when needed.", "Specification": "The trie structure is made up ofnodes. A nodeN \u2261 (N_l,N_r,N_p,N_v)has the following 4 components:", "Conventions": "The trie structure is made up ofnodes. A nodeN \u2261 (N_l,N_r,N_p,N_v)has the following 4 components:", "Notable changes from the hexary structure": "The trie structure is made up ofnodes. A nodeN \u2261 (N_l,N_r,N_p,N_v)has the following 4 components:", "The trie": "The trie structure is made up ofnodes. A nodeN \u2261 (N_l,N_r,N_p,N_v)has the following 4 components:", "Node merkelization rule": "Leaves and nodes that have no prefix are hashed according to the rule below:", "Rationale": "BLAKE2 offers better performance, which is key to compensate for the loss of performance associated to a ~4x increase in the number of nodes.", "blake2b": "BLAKE2 offers better performance, which is key to compensate for the loss of performance associated to a ~4x increase in the number of nodes.", "Merging of the account and storage tries": "The trend in clients is to store the keys and values in a \u201cflat\u201d database. Having the key of any storage slot prefixed with the address key of the account it belongs to helps grouping all of an account\u2019s data on disk, as well as simplifying the witness structure.", "Prefixes and extension nodes": "An alternative proposal has been made, which provides optimal witnesses. The trade-off is that extension nodes must be removed.", "2x32-byte inputs": "It has been requested to keep each node hash calculation as a function that takes two 256-bit integer as an input and outputs one 256-bit integer. This property is expected to play nice with circuit constructions and is therefore expected to greatly help with future zero-knowledge applications.", "Binary tries": "Binary tries have been chosen primarily because they reduce the witness size. In general, in anN-element tree with each element havingkchildren, the average length of a branch is roughly32 * (k-1) * log(N) / log(k)plus a few percent for overhead. 32 is the length of a hash; thek-1refers to the fact that a Merkle proof needs to provide allk-1sister nodes at each level, andlog(N) / log(k)is an approximation of the number of levels in the tree (eg. a tree where each node has 5 children, with 625 nodes total, would have depth 4, as625 = 5**4and solog(625) / log(5) = 4).", "Path length instead of bit prefix": "In order to remove the complexity associated with byte manipulation, only the bit-length of the extension is used to merkelize a node with a prefix.", "Value hashing": "Except for the code, all values in the trie are less than 32 bytes. EIP-2926 introduces code chunks, withCHUNK_SIZE = 32 bytes. The hashing of the leaf\u2019s value could therefore be saved. The authors of the EIP are however considering a future increase ofCHUNK_SIZE, makinghash(value)the future-proof choice.", "Backwards Compatibility": "A hard fork is required in order for blocks to have a trie root using a different structure.", "Test Cases": "TBD", "Implementation": "Issues could arise when performing the transition. In particular, a heavy conversion process could incentivize clients to wait the transition out. This could lead to a lowered network security at the time of the transition. A transition process has been proposed withEIP-2584.", "Security Considerations": "Issues could arise when performing the transition. In particular, a heavy conversion process could incentivize clients to wait the transition out. This could lead to a lowered network security at the time of the transition. A transition process has been proposed withEIP-2584.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- binary trie structure: Proposes a transition from a hexary to a binary trie structure for Ethereum\u2019s account and storage tries, improving stateless Ethereum support and reducing proof sizes.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3143, "url": "https://eips.ethereum.org/EIPS/eip-3143", "title": "Increase block rewards to 5 ETH", "authors": ["Ben Tinner\u00a0(", "@Terra854", ")"], "sections": {"EIP-3143: Increase block rewards to 5 ETH": "Changes the block reward paid to proof-of-work (POW) miners to 5 ETH.", "": "Changes the block reward paid to proof-of-work (POW) miners to 5 ETH.", "Simple Summary": "Changes the block reward paid to proof-of-work (POW) miners to 5 ETH.", "Abstract": "Starting withFORK_BLKNUMblock rewards will be increased to a base of 5 ETH, uncle and nephew rewards will be adjusted accordingly.", "Motivation": "Currently, the transaction fees (tx fees) portion of the mining rewards makes up a significant portion of the total rewards per block, at times almost exceeded the block reward of 2 ETH. This have resulted in situations where at times of low tx fees, POW miners decide to point their rigs away from ETH as they will always prefer to mine coins that are the most profitable at any point in time, reducing the security of the ETH network till transaction activity picks up again. By increasing the block rewards back to the original 5 ETH when the network first started, the voliatility will be reduced in terms of the percentage of tx fees that make up the mining rewards per block while increasing the total rewards per block, making it more financially attractive to POW miners to mine ETH barring any gigantic ETH price drops. The increase in block rewards will also allow smaller POW miners ample opporturnity to build up their stores of ETH so that when the time comes to fully transition to ETH 2.0, they may be more willing to become validators as they already have earned the requite amount of ETH needed to do so as opposed to having to spend tens of thousands of dollars to purchase the required ETH directly, increasing the number of validators in the network and therefore strengthening network security.", "Specification": "Adjust the block reward tonew_block_reward, where", "Rationale": "A 5 ETH base reward was chosen as a middle ground between wanting to prevent too high of an inflation rate (10.4% per annum for the first year at 5 ETH per block) and converting as many POW miners as possible into POS validators by making it easier to amass the required ETH needed through POW mining.", "Backwards Compatibility": "There are no known backward compatibility issues with the introduction of this EIP.", "Security Considerations": "There are no known security issues presented by this change.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- increase block rewards to 5 eth: Increases the block reward for proof-of-work mining from 2 ETH to 5 ETH to stabilize miner incentives during Ethereum\u2019s transition to proof-of-stake.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3220, "url": "https://eips.ethereum.org/EIPS/eip-3220", "title": "Crosschain Identifier Specification", "authors": ["Weijia Zhang\u00a0(", "@weijia31415", ")", "Peter Robinson\u00a0(", "@drinkcoffee", ")"], "sections": {"EIP-3220: Crosschain Identifier Specification": "A self-verifying unique blockchain identifier that deals with forks.", "": "A self-verifying unique blockchain identifier that deals with forks.", "Simple Summary": "A self-verifying unique blockchain identifier that deals with forks.", "Abstract": "The crosschain-id is a 32 byte hex string and with some bytes extracted from blockchain hash and some manually defined to characterize a blockchain.\nWe also propose a registration and lookup service to retrieve blockchain metadata from the crosschain-id.", "Motivation": "With the success of Bitcoin and Ethereum, various blockchains such as EOS, Ripple, Litecoin, Besu, Wanchain and the like have been developed and are growing at a fast pace.  There are also other private and consortium blockchains such as Hyperledger Fabric, Hyperledger Besu, Stellar, Corda, Quorum that only allow nodes with permitted identities to join the blockchain network.  The growth of public and private blockchains imposes challenges for inter-chain interoperability, particularly when these chains are heterogeneous and incompatible. Enterprise Ethereum Alliance formed Crosschain Interoperability Task Force (CITF) to look into common crosschain problems and solutions. CITF team noticed that there is a lack of unique identifier to charaterise and describe a blockchain. Several proprosals were discussed in EEA Crosschain Interoperability Task Force meetings and discussions.", "Specification": "We have considered various alternative specifications such as using a random unique hex string to represent a blockchain.  The drawback of this method is that the random id can not be used to verify a blockchain\u2019s intrinsic identity such as the blockhash of the genesis block.  A second alternative is simply using a genesis blockhash to represent a blockchain id for crosschain operations.  The drawback of this is that this id does not have information about the property of the blockchain and it has problem when a blockchain is forked into two blockchain.", "Definition of a 32 byte crosschain id": "We have considered various alternative specifications such as using a random unique hex string to represent a blockchain.  The drawback of this method is that the random id can not be used to verify a blockchain\u2019s intrinsic identity such as the blockhash of the genesis block.  A second alternative is simply using a genesis blockhash to represent a blockchain id for crosschain operations.  The drawback of this is that this id does not have information about the property of the blockchain and it has problem when a blockchain is forked into two blockchain.", "Rationale": "We have considered various alternative specifications such as using a random unique hex string to represent a blockchain.  The drawback of this method is that the random id can not be used to verify a blockchain\u2019s intrinsic identity such as the blockhash of the genesis block.  A second alternative is simply using a genesis blockhash to represent a blockchain id for crosschain operations.  The drawback of this is that this id does not have information about the property of the blockchain and it has problem when a blockchain is forked into two blockchain.", "Backwards Compatibility": "Crosschainid can be backward compatible with EIP-155.  The crosschain id contains an 8 byte segment to record theNative Chain ID.\nFor Ethereum chains, that can be used for a value intended to be used with EIP-155.", "Security Considerations": "Collision of crosschain id:  Two blockchains can contain the same crosschain id and hence making the mistakenly transfer assets to a wrong blockchain.This security concern is addressed by comparing the hash of the crosschain id with the hash of the genesis block.  If it matches, then the crosschain id is verified.  If not, the crosschain id can be compared with the forked blockhash.  If none of the blockhash match the crosschain id hash, then the crosschain id cannot be verified.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- crosschain identifier specification: Defines a self-verifying blockchain identifier, incorporating chain metadata to differentiate blockchains, including forks, for crosschain operations.\n- genesis: Log entry in system_logs for initial balances at network genesis .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3238, "url": "https://eips.ethereum.org/EIPS/eip-3238", "title": "Difficulty Bomb Delay to Q2/2022", "authors": ["Afri Schoedon\u00a0(", "@q9f", ")"], "sections": {"EIP-3238: Difficulty Bomb Delay to Q2/2022": "Delays the difficulty bomb so 30 second blocks won\u2019t happen until around Q2/2022.", "": "Delays the difficulty bomb so 30 second blocks won\u2019t happen until around Q2/2022.", "Simple Summary": "Delays the difficulty bomb so 30 second blocks won\u2019t happen until around Q2/2022.", "Abstract": "Starting withFORK_BLOCK_NUMBERthe client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting eleven million blocks later than the actual block number.", "Motivation": "Even after the Ethereum 2.0 mainnet launch, Ethash proof-of-work mining on the legacy chain should be feasible. It should allow miners sealing new blocks every 13~15 seconds on average for another ten months and allow both Ethereum 1.x and Ethereum 2.0 developers to conclude the merge.", "Specification": "For the purposes ofcalc_difficulty, simply replace the use ofblock.number, as used in the exponential ice age component, with the formula:", "Rationale": "This will delay the ice age by another ~26 million seconds (approximately ~9.89 months), so the chain would be back at ~30 second block times in Q2/2022. Hopefully, by then the Eth1-to-Eth2 merge will be concluded and the ice age fulfilled its task.", "Backwards Compatibility": "This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation. Therefore, it should be included in a scheduled hardfork at a certain block number. It\u2019s suggested to consider this EIP either with or shortly after the Berlin hard-fork but not later than July 2021.", "Security Considerations": "There are no known security issues with this proposal.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- difficulty bomb delay to q2/2022: Delays the Ethereum difficulty bomb, pushing back the impact of increasing block times to allow Eth1 and Eth2 development to conclude the merge.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3267, "url": "https://eips.ethereum.org/EIPS/eip-3267", "title": "Giving Ethereum fees to Future Salaries", "authors": ["Victor Porton\u00a0(", "@vporton", ")", "Victor Porton\u00a0<", "porton@narod.ru", ">"], "sections": {"EIP-3267: Giving Ethereum fees to Future Salaries": "Transfer a part of Ethereum transfer/mining fees to Future Salaries contract", "": "Transfer a part of Ethereum transfer/mining fees to Future Salaries contract", "Simple Summary": "Transfer a part of Ethereum transfer/mining fees to Future Salaries contract", "Abstract": "Transfer a part (exact fractions - TBD) of mining/transfer fees + (probably: TBD) some minted ETH to theDonateETHcontract configured to transfer toSalaryWithDAOcontract.", "Motivation": "This proposal solves two problems at once:", "Specification": "(TBD)", "Rationale": "The Future Salaries is theonlyknown system of distributing significant funds to common good producers. (Quadratic funding aimed to do a similar thing, but in practice as we see on GitCoin it favors a few developers, ignores project of highly advanced scientific research that is hard to explain to an average developer, and encourages colluding, and it just highly random due to small number of donors. Also quadratic funding simply does not gather enough funds to cover common good needs). So this EIP is the only known way to recover the economy.", "Backwards Compatibility": "Because transferring to the aforementioned account is neither mining nor a transaction, we get a new kinds of ETH transfers, so there may be some (expected moderate impact) troubles with applications that have made assumptions about ETH transfers all occurring either as miner payments or transactions.", "Security Considerations": "The security considerations are:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- giving ethereum fees to future salaries: Proposes transferring a portion of Ethereum mining and transfer fees to a Future Salaries contract, which funds common good producers, while also locking ETH to reduce circulating supply.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3298, "url": "https://eips.ethereum.org/EIPS/eip-3298", "title": "Removal of refunds", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Martin Swende\u00a0(", "@holiman", ")"], "sections": {"EIP-3298: Removal of refunds": "Remove gas refunds for SSTORE and SELFDESTRUCT.", "": "Remove gas refunds for SSTORE and SELFDESTRUCT.", "Simple Summary": "Remove gas refunds for SSTORE and SELFDESTRUCT.", "Motivation": "Gas refunds for SSTORE and SELFDESTRUCT were originally introduced to motivate application developers to write applications that practice \u201cgood state hygiene\u201d, clearing storage slots and contracts that are no longer needed. However, they are not widely used for this, and poor state hygiene continues to be the norm. It is now widely accepted that the only solution to state growth is some form ofstatelessness or state expiry, and if such a solution is implemented, then disused storage slots and contracts would start to be ignored automatically.", "Specification": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Parameters": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Rationale": "A full removal of refunds is the simplest way to solve the issues with refunds; any gains from partial retention of the refund mechanism are not worth the complexity that that would leave remaining in the Ethereum protocol.", "Backwards Compatibility": "Refunds are currently only appliedaftertransaction execution, so they cannot affect how much gas is available to any particular call frame during execution. Hence, removing them will not break the ability of any code to execute, though it will render some applications economically nonviable.", "Implementation": "An implementation can be found here: https://gist.github.com/holiman/460f952716a74eeb9ab358bb1836d821#gistcomment-3642048", "Test case changes": "Gas costs are provided with refunds subtracted; if the number is negative this means that refunds exceed gas costs. The 50% refund limit is not applied (due to the implied assumption that this code is only a small fragment of a much larger execution).", "Security Considerations": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- removal of refunds: Proposes removing gas refunds for SSTORE and SELFDESTRUCT operations, primarily to reduce block size variance and eliminate the use of GasToken.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding."}
{"eip": 3300, "url": "https://eips.ethereum.org/EIPS/eip-3300", "title": "Phase out refunds", "authors": ["William Morriss\u00a0(", "@wjmelements", ")"], "sections": {"EIP-3300: Phase out refunds": "Phases out theSSTOREandSELFDESTRUCTgas refunds.", "": "Phases out theSSTOREandSELFDESTRUCTgas refunds.", "Simple Summary": "Phases out theSSTOREandSELFDESTRUCTgas refunds.", "Abstract": "This EIP would define a block when theSSTOREandSELFDESTRUCTrefunds would begin to diminish.\nThe refund would step linearly downward, eroding the implicit value of such refunds at an accelerating pace.", "Motivation": "Refunds increase block elasticity, so the block gas target can exceed the number established by miners by up to 2x.\nThis can cause hesitancy for miners to increase the block gas target.", "Specification": "Parameters:", "EIP-2929": "The refunds as of EIP-2929 are as follows:", "Rationale": "Persisted refunds would become worthless before they fall below their activation cost.\nOnce the refunds are worthless, they can be removed by another hard fork without waiting for 0.\nThe rate of diminishing specified would currently require (24000-5000) * 100 = 1,900,000 blocks forSELFDESTRUCTand (15000-5000) * 100 = 1,000,000 blocks forSSTORE.\nThis timeframe is currently about a year, which should be enough flexibility for the remaining refunds to be consumed.", "Backwards Compatibility": "This proposal breaks gas refunds, which contribute to block elasticity.\nThe effect of this will be increased gas price volatility: higher highs and lower lows.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- phase out refunds: Suggests gradually reducing gas refunds for SSTORE and SELFDESTRUCT operations over time to reduce block gas elasticity more smoothly than a sudden removal.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3322, "url": "https://eips.ethereum.org/EIPS/eip-3322", "title": "Account gas storage opcodes", "authors": ["William Morriss\u00a0(", "@wjmelements", ")"], "sections": {"EIP-3322: Account gas storage opcodes": "Allows contract accounts to store gas that can be transferred to the refund counter.", "": "Allows contract accounts to store gas that can be transferred to the refund counter.", "Simple Summary": "Allows contract accounts to store gas that can be transferred to the refund counter.", "Abstract": "Contracts can persist gas for later transfer to the refund counter.\nThree opcodes are introduced to read, add to, and use this gas counter.", "Motivation": "The refund mechanism is currently being used by gas tokens to arbitrage gas price.\nThis brings gas supply elasticity and price stability by moving gas from blocks with less demand to blocks with more demand.\nUnfortunately this rewards unnecessary state growth.\nBy introducing a superior gas storage mechanism, the gas market will require less storage and computation.", "Specification": "Contract accounts gain an unsigned gas refund counter, initially zero.", "Rationale": "By reusing the execution context\u2019s refund counter we can reuse its 50% DoS protection, which limits its block elasticity contribution to 2x.", "Backwards Compatibility": "Because the gas is added to the refund counter, no compatibility issues are anticipated.", "Test Cases": "| Code             | Used Gas | Refund | Original | Final |\n|\u2014\u2014\u2014\u2014\u2014\u2014|\u2014\u2014\u2014-|\u2014\u2014\u2013|\u2014\u2014\u2014-|\u2014\u2014-|\n| 0x60004900       |     5003 |      0 |        0 |     0 |\n| 0x60034900       |     5003 |      2 |        2 |     0 |\n| 0x60034900       |     5003 |      3 |        3 |     0 |\n| 0x60034900       |     5003 |      3 |        4 |     1 |\n| 0x60034960034900 |    10006 |      4 |        4 |     0 |\n| 0x60034960034900 |    10006 |      6 |        6 |     0 |\n| 0x484900         |     5010 | 100000 |   100000 |     0 |\n| 0x61ffff4a00     |    70538 |      0 |        0 | 65535 |", "Security Considerations": "DoS is already limited by the 50% refund limit.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account gas storage opcodes: Introduces new opcodes (SELFGAS, USEGAS, STOREGAS) that allow contracts to store gas for later use, improving gas management without increasing state size.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3336, "url": "https://eips.ethereum.org/EIPS/eip-3336", "title": "Paged memory allocation for the EVM", "authors": ["Nick Johnson\u00a0(", "@arachnid", ")"], "sections": {"EIP-3336: Paged memory allocation for the EVM": "Changes the memory model for the EVM to use pagination.", "": "Changes the memory model for the EVM to use pagination.", "Simple Summary": "Changes the memory model for the EVM to use pagination.", "Abstract": "Presently, the EVM charges for memory as a linear array starting at address 0 and extending to the highest address that has been read from or written to. This suffices for simple uses, but means that compilers have to generate programs that use memory compactly, which leads to wasted gas with reallocation of memory elements, and makes some memory models such as separate heap and stack areas impractical. This EIP proposes changing to a page-based billing model, which adds minimal complexity to implementations, while providing for much more versatility in EVM programs.", "Motivation": "Most modern computers implement \u201cvirtual memory\u201d for userspace programs, where programs have access to a large address space, with pages of RAM that are allocated as needed by the OS. This allows them to distribute data throughout memory in ways that minimises the amount of reallocation and copying that needs to go on, and permits flexible use of memory for data with different lifetimes. Implementing a simple version of paged memory inside the EVM will provide the same flexibility to compilers targeting the EVM.", "Specification": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Parameters": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Changes to memory allocation in EVM implementations": "Memory is now allocated in pages of2**PAGE_BITSbytes each. The most significant256 - PAGE_BITSbits of each memory address denote the page number, while the least significantPAGE_BITSbits of the memory address denote the location in the page. Pages are initialized to contain all zero bytes and allocated when the first byte from a page is read or written.", "Changes to memory expansion gas cost": "Presently, the total cost to extend the memory toawords long isCmem(a) = 3 * a + floor(a ** 2 / 512). If the memory is alreadybwords long, the incremental cost isCmem(a) - Cmem(b).ais the number of words required to cover the range from memory address 0 to the last word that has been read or written by the EVM.", "Changes toMLOADandMSTORE": "Loading a word from memory or storing a word to memory requires instantiating any pages that it touches that do not already exist, with the resulting gas cost as described above. If the word being loaded or stored resides in a single page, the gas cost remains unchanged at 3 gas. If the word being loaded spans two pages, the cost is 6 gas.", "Changes to other memory-touching opcodes": "CALLDATACOPY,CODECOPY,EXTCODECOPY,CALL,CALLCODE,DELEGATECALL,STATICCALL,CREATE,MSTORE8and any other opcodes that read or write memory are modified as follows:", "Rationale": "The new gas cost follows the same curve as the previous one, while ensuring that the new gas cost is always less than or equal to the previous cost. This prevents existing programs that make assumptions about memory allocation gas costs from resulting in errors, without unduly discounting memory below what it costs today. Intuitively, a program that uses up to a page boundary pays for one page less than they would under the old model, while a program that uses one word more than a page boundary pays for one word less than they would under the old model.", "Memory expansion gas cost": "The new gas cost follows the same curve as the previous one, while ensuring that the new gas cost is always less than or equal to the previous cost. This prevents existing programs that make assumptions about memory allocation gas costs from resulting in errors, without unduly discounting memory below what it costs today. Intuitively, a program that uses up to a page boundary pays for one page less than they would under the old model, while a program that uses one word more than a page boundary pays for one word less than they would under the old model.", "Additional cost for MLOADs and MSTOREs spanning two pages": "Loading or storing data spanning two memory pages requires more work from the EVM implementation, which must split the word at the page boundary and update the two (possibly disjoint) pages. Since we cannot guarantee loads and stores in existing EVM programs are page-aligned, we cannot prohibit this behaviour for efficiency. Instead, we propose treating each as two loads or stores for gas accounting purposes. This discourages the use of this functionality, and accounts for the additional execution cost, without prohibiting it outright.", "Backwards Compatibility": "The new function for memory expansion gas cost is designed specifically to avoid backwards compatibility issues by always charging less than or equal to the amount the current EVM would charge. Under some circumstances existing programs will be charged more for MLOADs and MSTOREs that span page boundaries as described above; we believe these changes will affect a minimum of programs and have only a small impact on their gas consumption.", "Test Cases": "TBD", "Security Considerations": "Potential CPU DoS issues arising from additional work done under the new model are alleviated by charging more for non-page-aligned reads and writes. Charges for memory expansion asymptotically approach those currently in force, so this change will not permit programs to allocate substantially more memory than they can today.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- paged memory allocation: Proposes changing the EVM\u2019s memory model to use paged memory, improving flexibility for smart contract memory management while keeping gas costs manageable.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170."}
{"eip": 3337, "url": "https://eips.ethereum.org/EIPS/eip-3337", "title": "Frame pointer support for memory load and store operations", "authors": ["Nick Johnson\u00a0(", "@arachnid", ")"], "sections": {"EIP-3337: Frame pointer support for memory load and store operations": "Introduces four new opcodes for loading data from and storing data to memory offset by a frame pointer.", "": "Introduces four new opcodes for loading data from and storing data to memory offset by a frame pointer.", "Simple Summary": "Introduces four new opcodes for loading data from and storing data to memory offset by a frame pointer.", "Abstract": "This EIP introduces four new opcodes,MLOADFP,MSTOREFP,GETFPandSETFPthat allow for more efficient memory access offset by a user-controlled quantity called the \u201cframe pointer\u201d. This permits compilers to more efficiently offload ephemeral data such as local variables to memory instead of the EVM\u2019s evaluation stack, which has a number of benefits, including the effective elimination of restrictions on the number of local variables in a function.", "Motivation": "In most commonly used VMs, ephemeral data such as local variables, function arguments, and return addresses is stored in a region of memory called the stack. In contrast to the EVM\u2019s evaluation stack, this area of memory is randomly accessible, and thus can store an arbitrary amount of data, which can be referenced from anywhere they remain in scope. Although this model is possible in the current EVM design, it is made difficult by the linear model of memory (addressed inEIP-3336) and by the lack of opcodes for relative memory access commonly found in other architectures. This EIP proposes new opcodes that permit this form of memory use, without imposing undue burden on EVM implementers or on runtime efficiency.", "Specification": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Parameters": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Frame pointer": "A new EVM internal state variable called the \u201cframe pointer\u201d is introduced. This is a signed integer that starts at 0.", "SETFPopcode": "A new opcode,SETFPis introduced with value0x5c. This opcode costsG_low(3 gas) and takes one argument from the stack. The argument is stored as the new value of the frame pointer.", "GETFPopcode": "A new opcode,GETFPis introduced with value0x5d. This opcode costsG_low(3 gas) and takes no arguments. It takes the current value of the frame pointer and pushes it to the stack.", "MLOADFPopcode": "A new opcodeMLOADFPis introduced with value0x5e. This opcode acts in all ways identical toMLOAD, except that the value of the frame pointer is added to the address before loading data from memory. An attempt to load data from a negative address should be treated identically to an invalid opcode, consuming all gas and reverting the current execution context.", "MSTOREFPopcode": "A new opcodeMSTOREFPis introduced with value0x5f. This opcode acts in all ways identical toMSTORE, except that the value of the frame pointer is added to the address before storing data to memory. An attempt to store data to a negative address should be treated identically to an invalid opcode, consuming all gas and reverting the current execution context.", "Rationale": "The cost of the new opcodesMLOADFPandMSTOREFPreflects the cost ofMLOADandMSTORE. They are generally equivalent in cost with the exception of an extra addition operation, which imposes negligible cost.", "Cost of new opcodes": "The cost of the new opcodesMLOADFPandMSTOREFPreflects the cost ofMLOADandMSTORE. They are generally equivalent in cost with the exception of an extra addition operation, which imposes negligible cost.", "Absence ofMSTORE8FP": "MSTORE8FPopcode was not included because it is expected that it would be used infrequently, and there is a desire to minimise the size of the instruction set and to conserve opcodes for future use.", "Backwards Compatibility": "This EIP exclusively introduces new opcodes, and as a result should not impact any existing programs unless they operate under the assumption that these opcodes are undefined, which we believe will not be the case.", "Security Considerations": "DoS risks are mitigated by correct pricing of opcodes to reflect current execution costs. No other security considerations pertain to this EIP.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- frame pointer support: Adds four new opcodes (MLOADFP, MSTOREFP, GETFP, SETFP) to support memory operations relative to a frame pointer, improving memory management efficiency for smart contracts.\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3368, "url": "https://eips.ethereum.org/EIPS/eip-3368", "title": "Increase block rewards to 3 ETH, with 2 Year Decay to 1 ETH Scheduled", "authors": ["Michael D. Carter\u00a0(", "@BitsBeTrippin", ")"], "sections": {"EIP-3368: Increase block rewards to 3 ETH, with 2 Year Decay to 1 ETH Scheduled": "Changes the block reward paid to proof-of-work (POW) miners to 3 ETH from existing 2 ETH and starts a decay schedule for next two years to 1 ETH Block Reward.", "": "Changes the block reward paid to proof-of-work (POW) miners to 3 ETH from existing 2 ETH and starts a decay schedule for next two years to 1 ETH Block Reward.", "Simple Summary": "Changes the block reward paid to proof-of-work (POW) miners to 3 ETH from existing 2 ETH and starts a decay schedule for next two years to 1 ETH Block Reward.", "Abstract": "Set the block reward to 3 ETH and then decrease it slightly every block for 4,724,000 blocks (approximately 2 years) until it reaches 1 ETH.", "Motivation": "A sudden drop in PoW mining rewards could result in a sudden precipitous decrease in mining profitability that may drive miners to auction off their hashrate to the highest bidder while they figure out what to do with their now \u201cworthless\u201d hardware. If enough hashrate is auctioned off in this way at the same time, an attacker will be able to rent a large amount of hashing power for a short period of time at relatively low cost vs. reward and potentially attack the network. By setting the block reward to X (where X is enough to offset the sudden profitability decrease) and then decreasing it over time to Y (where Y is a number below the sudden profitability decrease), we both avoid introducing long term inflation while at the same time spreading out the rate that individual miners cross into a transitional range. This approach offers a higher level of confidence and published schedule of yield, while allowing mining participants time to gracefully repurpose/sell their hardware. This greatly increases ethereums PoW security by keeping incentives aligned to ethereum and not being force projected to short term brokerage for the highest bidder. Additionally the decay promotes a known schedule of a deflationary curve, aligning to the overall Minimal Viable Issuance directive aligned to a 2 year transition schedule for Proof of Stake, consensus replacement of Proof of Work. Security is paramount in cryptocurrency blockchains and the risk to a 51% non-resistant chain is real. The scope of Ethereum\u2019s current hashrate has expanded to hundreds of thousands of new participants and over 2.5x original ATH hashrate/difficulty. While the largest by hashrate crypto is bitcoin, ethereum is not far behind the total network size in security aspects. This proposal is focused to keep that superiority in security one of the key aspects.", "Specification": "Adjust block, uncle, and nephew rewards", "Constants": "2 years was chosen because it gives miners sufficient time to find alternative uses for their hardware and/or get their hardware back out onto the open market (e.g., in the form of gaming GPUs) without flooding the market suddenly. This proposal should ONLY be considered as a last resort as something we have in our pocket should the \u201cnetwork need to attract hashing power quickly and then bleed it off over time\u201d rather than \u201csomething that is scheduled to be included in X hard fork\u201d ; Recommendation to have in a fast track state, but NOT deployed to mainnet unless needed.", "Rationale": "2 years was chosen because it gives miners sufficient time to find alternative uses for their hardware and/or get their hardware back out onto the open market (e.g., in the form of gaming GPUs) without flooding the market suddenly. This proposal should ONLY be considered as a last resort as something we have in our pocket should the \u201cnetwork need to attract hashing power quickly and then bleed it off over time\u201d rather than \u201csomething that is scheduled to be included in X hard fork\u201d ; Recommendation to have in a fast track state, but NOT deployed to mainnet unless needed.", "Backwards Compatibility": "There are no known backward compatibility issues with the introduction of this EIP.", "Security Considerations": "There are no known security issues with the introduction of this EIP.", "Copyright": "Copyright and related rights waived via CC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3372, "url": "https://eips.ethereum.org/EIPS/eip-3372", "title": "5 FNV primes for ethash", "authors": ["mineruniter969\u00a0(", "@mineruniter969", ")", "mineruniter969\u00a0<", "mineruniter969@tutanota.com", ">"], "sections": {"EIP-3372: 5 FNV primes for ethash": "Introduce 5 new FNV primes into the ethash algorithm.", "": "Introduce 5 new FNV primes into the ethash algorithm.", "Simple Summary": "Introduce 5 new FNV primes into the ethash algorithm.", "Abstract": "This EIP is to kick current ASIC implementations out of the network to keep the Ethereum network secure and healthy by changing thefnvconstants.", "Motivation": "ASICs provide a severe centralization risk for the Ethereum network. If we do not get rid of them, small GPU miners will be forced to exit the Ethereum mining because EIP-1559 will make them mining at a loss. Furthermore, ASIC production will be concentrated only at one or two parties, which will make the Ethereum hashrate centralized. Also, it is worth noting that Ethash ASIC machines cost 10k+ USD, while GPUs are priced less than 1000 USD.", "Specification": "Ifblock.number >= ETHASH11_BLKNUM, activate theethash1.1algorithm version.", "ethash1.1": "Prior to this change,fnvhash function is used throughout thehashimotofunction.fnvis identical for all steps,ethash1.1will introduce additionalfnvA,fnvB,fnvC,fnvD, andfnvEfunctions. All those functions will have different FNV constants.", "Rationale": "ASIC Miners have become a threat to the future of Ethereum and a hard fork is required to remove them from the network before additional damage is caused. EIP-3372 proposes the minimum necessary to do so and will not affect ETH stakeholders or the network like Ethash 2.0 would. The threat ASICs pose is legal, social, moral, technical, monetary, and environmental. As we continue to come closer to the merge ASICs will attack the network and the developers personally as they have done in the past because miners will always pursue profits.", "Technical Overview": "Ethash 1.1 will replace the only FNV prime with five new primes at the stage of the hash computation. The prime used for the DAG generation is remained unchanged, while all others are be changed. This will not prevent ASIC companies from creating new ASICs that adapt but so close to the merge it is unlikely they will do so, and even if they do they are unlikely to be able to produce enough to again be a threat.\nThe choice of FNV constants are based on the formal specification that is available onhttps://tools.ietf.org/html/draft-eastlake-fnv-14#section-2.1", "Backwards Compatibility": "Mining hardware that is optimized for ethash may no longer work if thefnvconstants are baked into the hardware and cannot be changed.", "Test Vectors": "There are no known security issues with this change.", "Security Considerations": "There are no known security issues with this change.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- 5 fnv primes for ethash: Modifies the Ethash algorithm by introducing five new FNV primes to replace the single FNV prime, aiming to disrupt existing ASIC miners and maintain Ethereum\u2019s ASIC resistance.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3403, "url": "https://eips.ethereum.org/EIPS/eip-3403", "title": "Partial removal of refunds", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Martin Swende\u00a0(", "@holiman", ")"], "sections": {"EIP-3403: Partial removal of refunds": "Remove gas refunds for SELFDESTRUCT, and restrict gas refunds for SSTORE to one specific case.", "": "Remove gas refunds for SELFDESTRUCT, and restrict gas refunds for SSTORE to one specific case.", "Simple Summary": "Remove gas refunds for SELFDESTRUCT, and restrict gas refunds for SSTORE to one specific case.", "Motivation": "Gas refunds for SSTORE and SELFDESTRUCT were originally introduced to motivate application developers to write applications that practice \u201cgood state hygiene\u201d, clearing storage slots and contracts that are no longer needed. However, they are not widely used for this, and poor state hygiene continues to be the norm. It is now widely accepted that the only solution to state growth is some form of statelessness or state expiry, and if such a solution is implemented, then disused storage slots and contracts would start to be ignored automatically.", "The mutex usecase": "There are two typical ways to implement mutexes: \u20180-1-0\u2019 and \u20181-2-1. Let\u2019s see how they differ", "Specification": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Parameters": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Rationale": "Preserving refunds in thenew = original = 0 != currentcase ensures that a few key use cases that deserve favorable gas cost treatment continue to receive favorable gas cost treatment, particularly:", "Backwards Compatibility": "Refunds are currently only appliedaftertransaction execution, so they cannot affect how much gas is available to any particular call frame during execution. Hence, removing them will not break the ability of any code to execute, though it will render some applications economically nonviable.", "Test Cases": "Note, there is a difference between \u2018hot\u2019 and \u2018cold\u2019 slots. This table shows the values as ofEIP-2929assuming that all touched storage slots were already \u2018hot\u2019 (the difference being a one-time cost of2100gas).", "2929 Gas Costs": "Note, there is a difference between \u2018hot\u2019 and \u2018cold\u2019 slots. This table shows the values as ofEIP-2929assuming that all touched storage slots were already \u2018hot\u2019 (the difference being a one-time cost of2100gas).", "With EIP-3403 partial refunds": "If refunds were to be partially removed, as specifiedhere, this would be the comparative table.This table also assumes touched storage slots were already \u2018hot\u2019.", "Security Considerations": "Refunds are not visible to transaction execution, so this should not have any impact on transaction execution logic.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- removal of refunds: Proposes removing gas refunds for SSTORE and SELFDESTRUCT operations, primarily to reduce block size variance and eliminate the use of GasToken.\n- partial removal of refunds: Removes gas refunds for SELFDESTRUCT and restricts SSTORE refunds to a specific case, targeting the elimination of GasToken while preserving efficiency for certain use cases like anti-reentrancy locks."}
{"eip": 3416, "url": "https://eips.ethereum.org/EIPS/eip-3416", "title": "Median Gas Premium", "authors": ["HexZorro\u00a0(", "@hexzorro", ")", "Mojtaba Tefagh\u00a0(", "@mtefagh", ")"], "sections": {"EIP-3416: Median Gas Premium": "A transaction pricing mechanism with a fixed-per-block network fee and a median inclusion fee with additive updates.", "": "A transaction pricing mechanism with a fixed-per-block network fee and a median inclusion fee with additive updates.", "Simple Summary": "A transaction pricing mechanism with a fixed-per-block network fee and a median inclusion fee with additive updates.", "Abstract": "There is a base fee per gas in protocol, which can move up or down by a maximum of 1/8 in each block. The base fee per gas is adjusted by the protocol to target an average gas usage per block instead of an absolute gas usage per block.  The base fee is increased when blocks are over the gas limit target and decreases when blocks are under the gas limit target. Transaction senders specify their fees by providingonly one value:", "Motivation": "We target the following goals:", "Specification": "This is a classic fork without a long migration time.", "Definitions": "This is a classic fork without a long migration time.", "Process": "The miners can still use agreedystrategy to include new transactions in the proposed blocks by adding the transactions ordered by largerFEE_CAPfirst. This is similar to how current blocks are filled, and is a consequence ofFEE_CAPandGAS_PREMIUMbeing a positive linear function of each other.", "Rationale": "The rationale behind the premium being 50% of (fee cap - base fee) is that at any given point the average network sender has an average fee cap, and we assume that between base fee and fee cap the sender has no specific preference, as long as the transaction is included in some block. Then, the sender is happy with a median premium among this uniform range. Another justification can be that the user also knows that this new version of the pricing protocol for the complete block uses a median, then is fair for him to apply a median within his preferential range, assuming an uniform sampling there. Simulations (here) with Ethereum gas data shows indeed that median one of the most robust metric.s", "Backwards Compatibility": "The backward compatibility is very straightforward because there are no new fields added to the transactions. Pricing of the gas per block on the miner/validator side is still fast to compute but a little more complex. Changes only affect miners/validators. Wallets are no affected by this proposal.", "Test Cases": "TBD.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- median gas premium: Proposes a transaction pricing mechanism where a fixed base fee is combined with a gas premium based on the median of included transactions, aiming to smooth gas price volatility.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3436, "url": "https://eips.ethereum.org/EIPS/eip-3436", "title": "Expanded Clique Block Choice Rule", "authors": ["Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-3436: Expanded Clique Block Choice Rule": "Add a four step block rule to Clique that should reduce block production deadlocks", "": "Add a four step block rule to Clique that should reduce block production deadlocks", "Simple Summary": "Add a four step block rule to Clique that should reduce block production deadlocks", "Abstract": "The current specification of Clique allows for multiple competing blocks from producers but does not\nprovide any strategies to pick blocks aside from the current \u201chighest total difficulty\u201d rule. This\nEIP proposes a four step choice rule of highest total difficulty, shortest chain, most recently\nin-turn, and lowest hash. This would prevent deadlocks that have occurred in production systems.", "Motivation": "There has been more than one deadlock in the Goerli multi-client Clique network. The number of\nactive validators was greater than 1/2 of the available validators so a chain halt should not have\noccurred. The halt was resolved by an inactive validator coming back on line. The state of the chain\nwas in one of two configurations of 8 validators that can result in a chain halt. Three of the four\nclients observed a choice sequence of lowest total difficulty followed by first observed block. Geth\nadded one extra rule of preferring the shortest chain before preferring the first observed block.\nThis fork would have resolved itself with Geth\u2019s rule, but there is still a configuration where the\nchain can halt with a shortest chain rule.", "Specification": "When a Clique validator is arbitrating the canonical status between two different chain head blocks,\nthey should choose the canonical block with the following ordered priorities.", "Rationale": "Two scenarios of a halted chain are known based on the current total difficulty then first observed\nrule. One of the scenarios is also resistant to the shortest chain rule.", "Backwards Compatibility": "The current block choice rules are a mix of most total difficulty and most total difficulty plus\nshortest chain.", "Security Considerations": "Malicious and motivated attackers who are participating in the network can force the chain to halt\nwith well crafted block production. With a fully deterministic choice rule the opportunity to halt\nis diminished. Attackers still have the same opportunities to flood the network with multiple blocks\nat the same height. A deterministic rule based on the lowest hash reduces the impact of such a\nflooding attack. A malicious validator could exploit this deterministic rule to produce a\nreplacement block. Such an attack exists in current implementations but a deterministic hash rule\nmakes such replacements more likely. However the impact of such an attack seems low to trivial at\nthis time.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- expanded clique block choice rule: Introduces a four-step block choice rule for the Clique consensus algorithm to reduce the occurrence of deadlocks in multi-validator environments.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3455, "url": "https://eips.ethereum.org/EIPS/eip-3455", "title": "SUDO Opcode", "authors": ["William Morriss\u00a0(", "@wjmelements", ")", "Baptiste Vauthey\u00a0(", "@thabaptiser", ")"], "sections": {"EIP-3455: SUDO Opcode": "A new opcode,SUDO, is introduced with the same parameters asCALL, plus another parameter to specify the sender address.", "A new opcode is introduced to allow calling from an arbitrary sender address.": "A new opcode,SUDO, is introduced with the same parameters asCALL, plus another parameter to specify the sender address.", "Abstract": "A new opcode,SUDO, is introduced with the same parameters asCALL, plus another parameter to specify the sender address.", "Motivation": "There are many use cases for being able to set the sender.", "Specification": "Adds a new opcode (SUDO) at0xf8.SUDOpops 8 parameters from the stack.\nBesides the sender parameter, the parameters shall matchCALL.", "Rationale": "TheGASparameter is first so that callers can tediously compute how much of their remaining gas to send at the last possible moment.\nThe remaining parameters inherited fromCALLare in the same order, with sender inserted between.", "Security Considerations": "It will be fine.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- sudo opcode: Adds the SUDO opcode, which allows calling from an arbitrary sender address, enabling recovery of assets from addresses with lost keys or bugs.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3508, "url": "https://eips.ethereum.org/EIPS/eip-3508", "title": "Transaction Data Opcodes", "authors": ["Alex Papageorgiou\u00a0(", "@alex-ppg", ")"], "sections": {"EIP-3508: Transaction Data Opcodes": "Provide access to original transaction data.", "": "Provide access to original transaction data.", "Simple Summary": "Provide access to original transaction data.", "Abstract": "This EIP introduces the following three EVM instructions:ORIGINDATALOAD,ORIGINDATASIZE, andORIGINDATACOPY.", "Motivation": "As the Ethereum development scene matures, more ambitious and complex features are introduced into smart contracts more often than not requiring the utilization of complex and at times large data structures. Given the inherent limits of the EVM, however, transporting large data structures in between contracts is a costly task that can at times lead to even futile scenarios whereby the gas consumption of such an operation is impossible to execute within the gas limit bounds as well as without sacrificing a large chunk of ETH to facilitate its gas cost.", "Specification": "These instructions are meant to operate similarly to their call-prefixed counterparts with the exception that they instead operate on the originaldataof a transaction instead of the current call\u2019s data. In detail:", "ORIGINDATALOAD (0x47), ORIGINDATASIZE (0x48) and ORIGINDATACOPY (0x49)": "These instructions are meant to operate similarly to their call-prefixed counterparts with the exception that they instead operate on the originaldataof a transaction instead of the current call\u2019s data. In detail:", "Rationale": "TheEIP-3074that will be part of the London fork has introduced a new call instruction calledAUTHCALL(0xf7) that will replace a transaction\u2019sORIGIN(0x32) with the context variableauthorized. The intention ofAUTHCALLis to prevent discrimination between smart contracts and EOAs whichORIGINinitially facilitated and as a result, it is sensible also replace the values retrieved by theORIGINDATA*opcodes to the ones used in theAUTHCALL.", "AUTHCALL (0xf7) Interaction": "TheEIP-3074that will be part of the London fork has introduced a new call instruction calledAUTHCALL(0xf7) that will replace a transaction\u2019sORIGIN(0x32) with the context variableauthorized. The intention ofAUTHCALLis to prevent discrimination between smart contracts and EOAs whichORIGINinitially facilitated and as a result, it is sensible also replace the values retrieved by theORIGINDATA*opcodes to the ones used in theAUTHCALL.", "Naming Conventions": "TheORIGIN-prefixed instructions attempted to conform to the existing naming convention ofCALL-prefixed instructions given the existence of theORIGIN(0x32) instruction which is equivalent to theCALLER(0x33) instruction but on the original transaction\u2019s context.", "Instruction Address Space": "The instruction address space of the0x30-0x3fhas been exhausted by calls that already provide information about the execution context of a call so a new range had to be identified that is suitable for the purposes of the EIP.", "Gas Costs": "The opcodes ORIGINDATALOAD (0x47), ORIGINDATASIZE (0x48), and ORIGINDATACOPY (0x49) essentially perform the same thing as opcodes CALLDATALOAD (0x35), CALLDATASIZE (0x36), and CALLDATACOPY (0x37) respectively and thus share the exact same gas costs.", "Instruction Space Pollution": "One can argue that multiple new EVM instructions pollute the EVM instruction address space and could cause issues in assigning sensible instruction codes to future instructions. This particular issue was assessed and a methodology via which the raw RLP encoded transaction may be accessible to the EVM was ideated. This wouldfuture-proofthe new instruction set as it would be usable for other members of the transaction that may be desired to be accessible on-chain in the future, however, it would also cause a redundancy in theORIGINopcode.", "Backwards Compatibility": "The EIP does not alter or adjust existing functionality provided by the EVM and as such, no known issues exist.", "Test Cases": "TODO.", "Security Considerations": "Atomically, theORIGINDATALOADandORIGINDATACOPYvalues should be considered insecure as they can easily be spoofed by creating an entry smart contract with the appropriate function signature and arguments that consequently invokes other contracts within the call chain. In brief, one should always assume thattx.data != calldataand these instructions should not be used as an introspection tool alone.", "Introspective Contracts": "Atomically, theORIGINDATALOADandORIGINDATACOPYvalues should be considered insecure as they can easily be spoofed by creating an entry smart contract with the appropriate function signature and arguments that consequently invokes other contracts within the call chain. In brief, one should always assume thattx.data != calldataand these instructions should not be used as an introspection tool alone.", "Denial-of-Service Attack": "An initial concern that may arise from this EIP is the additional contextual data that must be provided at the software level of nodes to the EVM in order for it to be able to access the necessary data via theORIGINDATALOADandORIGINDATACOPYinstructions.", "Multi-Contract System Gas Reduction": "Given that most complex smart contract systems deployed on Ethereum today rely on cross-contract interactions whereby values are passed from one contract to another via function calls, theORIGIN-prefixed instruction set would enable a way for smart contract systems to acquire access to the original transaction data at any given step in the call chain execution which could result in cross-contract calls ultimately consuming less gas if the data passed between them is reduced as a side-effect of this change.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- transaction data opcodes: Introduces the opcodes ORIGINDATALOAD, ORIGINDATASIZE, and ORIGINDATACOPY to provide access to the original transaction\u2019s data payload, improving efficiency for multi-contract systems.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3520, "url": "https://eips.ethereum.org/EIPS/eip-3520", "title": "Transaction Destination Opcode", "authors": ["Alex Papageorgiou\u00a0(", "@alex-ppg", ")"], "sections": {"EIP-3520: Transaction Destination Opcode": "Provide access to the original recipient of a transaction.", "": "Provide access to the original recipient of a transaction.", "Simple Summary": "Provide access to the original recipient of a transaction.", "Abstract": "This EIP introduces the following EVM instruction:ENTRYPOINT.", "Motivation": "It is undeniable that smart contracts are becoming more interconnected than ever. Up until this point, smart contracts have entirely relied on compliant interfaces and introspection to introduce a new step in the call chain of a complex multi-contract interaction. However, this presents a forwards-only approach which limits the types of interactions that can manifest.", "Specification": "TheENTRYPOINTinstruction uses 0 stack arguments and pushes the originaltomember of the transaction onto the stack. The address yielded by the instruction is a 160-bit value padded to 256-bits. The operation costsG_baseto execute, similarly toORIGIN(0x32).", "ENTRYPOINT (0x4a)": "TheENTRYPOINTinstruction uses 0 stack arguments and pushes the originaltomember of the transaction onto the stack. The address yielded by the instruction is a 160-bit value padded to 256-bits. The operation costsG_baseto execute, similarly toORIGIN(0x32).", "Rationale": "TheEIP-3074introduced a new call instruction calledAUTHCALL(0xf7) that will replace a transaction\u2019sORIGIN(0x32) with the context variableauthorized. The intention ofAUTHCALLis to prevent discrimination between smart contracts and EOAs whichORIGINinitially facilitated. TheENTRYPOINTopcode by itself re-introduces discrimination into the system as it indirectly allows one to evaluate whether the smart contract code being executed is done so by an EOA by validating thatENTRYPOINT == ADDRESSwhereADDRESS(0x30) retrieves the currently executing account address. Therefore, it is sensible also replace the values retrieved by theENTRYPOINTopcode to the target of anAUTHCALL.", "AUTHCALL (0xf7) Interaction": "TheEIP-3074introduced a new call instruction calledAUTHCALL(0xf7) that will replace a transaction\u2019sORIGIN(0x32) with the context variableauthorized. The intention ofAUTHCALLis to prevent discrimination between smart contracts and EOAs whichORIGINinitially facilitated. TheENTRYPOINTopcode by itself re-introduces discrimination into the system as it indirectly allows one to evaluate whether the smart contract code being executed is done so by an EOA by validating thatENTRYPOINT == ADDRESSwhereADDRESS(0x30) retrieves the currently executing account address. Therefore, it is sensible also replace the values retrieved by theENTRYPOINTopcode to the target of anAUTHCALL.", "Naming Conventions": "TheENTRYPOINTinstruction came to be by defining a sensible name that immediately and clearly depicts what it is meant to achieve by signaling the first interaction of a particular call, i.e. the entry-point.", "Instruction Address Space": "Equivalent toEIP-3508.", "Gas Cost": "The opcode ENTRYPOINT (0x4a) essentially performs the same thing as the opcode ORIGIN (0x32) and thus shares the exact same gas cost.", "Dependency on EIP-3508": "TheENTRYPOINT(0x4a) instruction alone has no perceivable benefit as it can be replaced by theAUTHCALL(0xf7) instruction and as such should solely be introduced to the system in conjunction with theORIGINDATA*opcodes defined inEIP-3508.", "Backwards Compatibility": "The EIP does not alter or adjust existing functionality provided by the EVM and as such, no known issues exist.", "Test Cases": "TODO.", "Security Considerations": "TheENTRYPOINTinstruction allows the association of theORIGINDATALOADandORIGINDATACOPYvalues with a particular smart contract address and interface, enabling introspection to be applied based on the function signature invoked and the arguments provided to reliably deduce the call-path via which a particular smart contract was invoked and allowing a more granular level of interaction to be defined in such special cases.", "Introspective Contracts": "TheENTRYPOINTinstruction allows the association of theORIGINDATALOADandORIGINDATACOPYvalues with a particular smart contract address and interface, enabling introspection to be applied based on the function signature invoked and the arguments provided to reliably deduce the call-path via which a particular smart contract was invoked and allowing a more granular level of interaction to be defined in such special cases.", "Caller Discrimination": "The instructions of this EIP should not be utilized as a way to discriminate between EOA callers and smart contracts, as this type of differentiation can be broken by anAUTHCALLas defined in the specification chapter.", "Contract Creation Behaviour": "The behaviour of theENTRYPOINTopcode during a contract creation will result in the opcode yielding the zero-address as the first address interacted with in the transaction. This should be taken into account by contract implementations in a similar fashion to howecrecoverinvalid signatures are handled to prevent software misbehaviours from arising.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- transaction destination opcode: Adds the ENTRYPOINT opcode, allowing contracts to access the original recipient of a transaction, facilitating introspection and new contract interaction patterns.\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3521, "url": "https://eips.ethereum.org/EIPS/eip-3521", "title": "Reduce access list cost", "authors": ["Matt Garnett\u00a0(", "@lightclient", ")"], "sections": {"EIP-3521: Reduce access list cost": "Reduce the cost of declaringtx.tostorage keys in access lists.", "": "Reduce the cost of declaringtx.tostorage keys in access lists.", "Simple Summary": "Reduce the cost of declaringtx.tostorage keys in access lists.", "Motivation": "Currently, a transaction must read at least 25 distinct storage slots intx.tobefore it\u2019s more expensive to forego an access list.", "Specification": "Treat the first occurrence oftx.toin an access list ascalldatafor gas\naccounting purposes. Do not chargeACCESS_LIST_ADDRESS_COSTfor it. Storage\nkeys underneath the address are unaffected.", "Rationale": "EIP-2930 is specifically written to make access lists simple to reason about and\nvalidate. It may be possible to modify the structure of the access list to avoid\nincludingtx.toexplicitly, but this would renege on the spirit of EIP-2930.", "Why charge at all?": "EIP-2930 is specifically written to make access lists simple to reason about and\nvalidate. It may be possible to modify the structure of the access list to avoid\nincludingtx.toexplicitly, but this would renege on the spirit of EIP-2930.", "Why charge ascalldata?": "The cost ofcalldatawas  thoroughly analyzed in EIP-2028 to determine\na fair value that is not susceptible to denial-of-service attacks. We consider\nthis the lower bound on how much transaction data should cost. Since there is\nno computation burden imposed for addingtx.toto theaccessed_addressesmap (it\u2019s added by default byEIP-2929), there is no reason to charge more than\nthe absolute minimum for the data.", "Test Cases": "No issues.", "Backwards Compatibility": "No issues.", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- reduce access list cost: Reduces the cost of declaring tx.to storage keys in access lists, making access lists more cost-effective for transactions involving storage access.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170."}
{"eip": 3534, "url": "https://eips.ethereum.org/EIPS/eip-3534", "title": "Restricted Chain Context Type Transactions", "authors": ["Isaac Ardis\u00a0(", "@whilei", ")"], "sections": {"EIP-3534: Restricted Chain Context Type Transactions": "Defines a new transaction type with constraints on ancestor block hash, block author, and/or block timestamp.", "": "Defines a new transaction type with constraints on ancestor block hash, block author, and/or block timestamp.", "Simple Summary": "Defines a new transaction type with constraints on ancestor block hash, block author, and/or block timestamp.", "Abstract": "We introduce a new EIP-2718 transaction type with the format0x4 || rlp([chainId, chainContext, nonce, gasPrice, gasLimit, to, value, data, access_list, yParity, senderR, senderS]).", "Motivation": "Establish a protocol-based mechanism with which transactions are able to articulate constraints on eligible chain contexts.\nGenerally, these constraints give the consumer (the transactor) an ability to express requirements about the transaction\u2019s relationship to blockchain data and its provenance.", "Specification": "As ofFORK_BLOCK_NUMBER, a new EIP-2718 transaction is introduced withTransactionTypeTRANSACTION_TYPE_NUMBER.", "Parameters": "As ofFORK_BLOCK_NUMBER, a new EIP-2718 transaction is introduced withTransactionTypeTRANSACTION_TYPE_NUMBER.", "Definitions": "ThechainContextvalue should be of the formANNOTATION_COMPOSITE_PREFIX || [{subclass value}...], where", "Validation": "The values defined as subclasses below acts as constraints on transaction validity for specific chain contexts.\nTransactions defining constraints which are not satisfied by their chain context should be rejected as invalid.\nBlocks containing invalid transactions should be rejected as invalid themselves, per thestatus quo.", "Subclass Combination": "Since subclasses use octal-based values forANNOTATION_PREFIX, they can be distinguishably combined as sums, provided as we assume annotation cardinality (ie ordering).\nFor example:", "Subclasses": "Subclasses are defined with a high level of conceptual independence, and can be modified and/or extended independently from this EIP.\nTheir specification definitions allow arbitrary mutual (AND) combinations.", "Rationale": "Subclasses are defined with a high level of conceptual independence, and can be modified and/or extended independently from this EIP.\nTheir specification definitions allow arbitrary mutual (AND) combinations.", "EIP-2930 Inheritance": "TheEIP-2930 Optional Access List Type Transactionis used as an assumed \u201cbase\u201d transaction type for this proposal. \nHowever, this is NOT a conceptual dependency; the includedaccessListportion of this proposal (the only differential from post-EIP-155 legacy transaction fields) can readily be removed. \nStanding on the shoulders of EIP-2930 is only intended to support and further the adoption of next-generation transactions.", "Signature target": "The signature signs over the transaction type as well as the transaction data.\nThis is done to ensure that the transaction cannot be \u201cre-interpreted\u201d as a transaction of a different type.", "Backwards Compatibility": "There are no known backward compatibility issues.", "Test Cases": "Further test cases, TODO.", "Security Considerations": "TL;DR: The chance of an ineffectualancestorIdis about 1 in between ~4 billion and ~40 billion, with the greater chance for intentional duplication scenarios, eg. malicious reorgs.", "Why 4 bytes of a block hash is \u201csafe enough\u201d for theancestorId": "TL;DR: The chance of an ineffectualancestorIdis about 1 in between ~4 billion and ~40 billion, with the greater chance for intentional duplication scenarios, eg. malicious reorgs.", "eligibleMinerList": "Miners who do not find themselves listed in an annotatedeligibleMinerListshould be expected to immediately remove the transaction from their transaction pool.", "ineligibleMinerList": "In addition to the concerns and arguments presented byeligibleMinerListabove, there is a unique concern forineligibleMinerList: in order for a miner entity to avoid ineligibility by a blacklist, they only need to use an alternative adhoc address as the block beneficiary.\nIn principle, this is ineluctable.", "Validation costs": "Miner lists and expiry depend on easily cached and contextually available conditions (ie. the containing block header). The infrastructural overhead costs for enforcing these validations are expected to be nominal.", "Transaction size increase": "The proposed additional fields potentially increase transaction size.\nThe proposed fields are not associated with any gas costs, establishing no protocol-defined economic mitigation for potential spam.\nHowever, transactions which are considered by a miner to be undesirable can be simply dropped from the transaction pool and ignored.", "Copyright": "Copyright and related rights waved viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- restricted chain context type transactions: Introduces a new transaction type that restricts its validity based on block context conditions, such as block hash, miner, and block timestamp.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3584, "url": "https://eips.ethereum.org/EIPS/eip-3584", "title": "Block Access List", "authors": ["Gajinder Singh\u00a0(", "@g11in", ")", "Piper Merriam\u00a0(", "@pipermerriam", ")"], "sections": {"EIP-3584: Block Access List": "A proposal to build a block\u2019saccess_listand include its fingerprintAccessListRootin the block header.", "": "A proposal to build a block\u2019saccess_listand include its fingerprintAccessListRootin the block header.", "Simple Summary": "A proposal to build a block\u2019saccess_listand include its fingerprintAccessListRootin the block header.", "Abstract": "EIP-2929/EIP-2930centers around normalizing the (low) gas costs of data/storage accesses made by a transaction as well as providing for (and encouraging) a new transaction type format:", "Motivation": "Motivation for collating thetransactionaccess_lists for all the transactions in ablock\u2019saccess_listis to have anaccess indexof the block with following benefits:", "Specification": "A blockaccess_listrepresents:", "Canonical Block Access List": "Anaccess_listis defined to be comprised of manyaccess_list_entryelements:", "AccessListRoot": "AccessListRootis generated to prevent anygriefingattacks and hence will need to be included (and validated) in theblock header.\nEven thoughAccessListRootis currently specified to be a simplesha256hash of the canonicalaccess_list, it would be beneficial to consider other constructions", "Additional Block Validation": "Validating a new block requires an additional validation check that the block\u2019sAccessListRootmatches the one generated by executing the block using the construction as defined by theAccessListRootURN.", "Rationale": "It is specified to be sorted in lexicographic ordering or integer sorting wherever applicable and specified. Sorting with respect to access time was considered but didn\u2019t seem to provide any additional benefit at the cost of adding implementation complexity and bookkeeping.", "Sorting of canonicalaccess_list": "It is specified to be sorted in lexicographic ordering or integer sorting wherever applicable and specified. Sorting with respect to access time was considered but didn\u2019t seem to provide any additional benefit at the cost of adding implementation complexity and bookkeeping.", "Future extensions ofaccess_list": "We can extend the notion of a block\u2019saccess_listto include witnesses:", "Backwards Compatibility": "The extra block validation will only be mandatory post the block number this EIP comes into effect, but the clients can still provide a way to generate (and possibly store) this access list  on request (via theJSON/RPCapi). However this is optional and client dependent.", "Security Considerations": "There are no known security issues as a result of this change.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- block access list: Proposes building a block\u2019s access_list by collating transaction access lists and including a fingerprint of this list in the block header, improving execution and validation efficiency.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3690, "url": "https://eips.ethereum.org/EIPS/eip-3690", "title": "EOF - JUMPDEST Table", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")"], "sections": {"EIP-3690: EOF - JUMPDEST Table": "Introduce a section in the EOF format (EIP-3540) for storing the list ofJUMPDESTs, validate the correctness of this list at the time of contract creation, and remove the need forJUMPDEST-analysis at execution time. In EOF contracts, theJUMPDESTinstruction is not needed anymore and becomes invalid. Legacy contracts are entirely unaffected by this change.", "A special EOF section for storing the list of JUMPDESTs, which simplifies execution time analysis.": "Introduce a section in the EOF format (EIP-3540) for storing the list ofJUMPDESTs, validate the correctness of this list at the time of contract creation, and remove the need forJUMPDEST-analysis at execution time. In EOF contracts, theJUMPDESTinstruction is not needed anymore and becomes invalid. Legacy contracts are entirely unaffected by this change.", "Abstract": "Introduce a section in the EOF format (EIP-3540) for storing the list ofJUMPDESTs, validate the correctness of this list at the time of contract creation, and remove the need forJUMPDEST-analysis at execution time. In EOF contracts, theJUMPDESTinstruction is not needed anymore and becomes invalid. Legacy contracts are entirely unaffected by this change.", "Motivation": "Currently existing contracts require no validation of correctness, but every time they are executed, a list must be built containing all the valid jump-destinations. This is an overhead which can be avoided, albeit the effect of the overhead depends on the client implementation.", "Specification": "This feature is introduced on the very same blockEIP-3540is enabled, therefore every EOF1-compatible bytecode MUST have a JUMPDEST-table if it uses jumps.", "EOF container changes": "The length of thejumpdestssection is bounded by the EOF maximum section size value 0xffff. Moreover, for deployed code this additionally limited by the max bytecode size 0x6000. Then any validjumpdestssection may not be more larger than 0x3000.", "Validation rules": "The length of thejumpdestssection is bounded by the EOF maximum section size value 0xffff. Moreover, for deployed code this additionally limited by the max bytecode size 0x6000. Then any validjumpdestssection may not be more larger than 0x3000.", "Execution": "The length of thejumpdestssection is bounded by the EOF maximum section size value 0xffff. Moreover, for deployed code this additionally limited by the max bytecode size 0x6000. Then any validjumpdestssection may not be more larger than 0x3000.", "Rationale": "The length of thejumpdestssection is bounded by the EOF maximum section size value 0xffff. Moreover, for deployed code this additionally limited by the max bytecode size 0x6000. Then any validjumpdestssection may not be more larger than 0x3000.", "Jumpdests section is bounded": "The length of thejumpdestssection is bounded by the EOF maximum section size value 0xffff. Moreover, for deployed code this additionally limited by the max bytecode size 0x6000. Then any validjumpdestssection may not be more larger than 0x3000.", "Delta encoding": "Delta-encoding is very efficient for this job. From a quick analysis of a small set of contractsJUMPDESTopcodes are relatively close to each other. In the delta-encoding the values almost never exceed 128. Combined with any form of variable-length quantity (VLQ) where values < 128 occupy one byte, encoding of single jumpdest takes ~1 byte. We also removeJUMPDESTopcodes from the code section therefore the total bytecode length remains the same if extreme examples are ignored.", "LEB128 for offsets": "The LEB128 encoding is the most popular VLQ used in DWARF and WebAssembly.", "Size-prefix for offsets": "This is another option for encoding inspired by UTF-8. The benefit is that the number of following bytes is encoded in the first byte (the top two bits), so the expected length is known upfront.", "Empty table": "In case code does not use jumps, an empty JUMPDEST table is represented by omittingjumpdestssection as opposed to a section that is always present, but allowed to be empty. This is consistent with the requirement of EIP-3540 for section size to be non-zero. Additionally, omitting the section saves 3 bytes of code storage.", "Why jumpdests before code?": "The contents ofjumpdestssection are always needed to start EVM execution. For chunked and/or merkleized bytecode it is more efficient to havejumpdestsjust after the EOF header so they can share the same first chunk(s).", "Code chunking / merkleization": "In code chunking the contract code is split into (fixed size) chunks. Due to the requirement of jumpdest-analysis, it must be known where the first instruction starts in a given chunk, in case the split happened within a PUSH-data. This is commonly accomplished with reserving the first byte of the chunk as the \u201cfirst instruction offset\u201d (FIO) field.", "Benchmarks / performance analysis": "We compared the performance ofjumpdestssection loading to JUMPDEST analysis in evmone/Baseline interpreter. In both cases a bitset of valid jumpdest positions is built.", "Reference Implementation": "We extend thevalidate_code()function ofEIP-3670:", "Test Cases": "This change poses no risk to backwards compatibility, as it is introduced at the same time EIP-3540 is. The requirement of a JUMPDEST table does not cover legacy bytecode.", "Backwards Compatibility": "This change poses no risk to backwards compatibility, as it is introduced at the same time EIP-3540 is. The requirement of a JUMPDEST table does not cover legacy bytecode.", "Security Considerations": "The authors are not aware of any security or DoS risks posed by this change.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- eof - jumpdest table: Introduces a section in the EOF format to store the list of JUMPDEST instructions, removing the need for JUMPDEST-analysis at runtime and validating the table during contract creation.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3756, "url": "https://eips.ethereum.org/EIPS/eip-3756", "title": "Gas Limit Cap", "authors": ["lightclient\u00a0(", "@lightclient", ")"], "sections": {"EIP-3756: Gas Limit Cap": "Set an in-protocol cap for the gas limit of 30,000,000.", "Set an in-protocol cap for the gas limit": "Set an in-protocol cap for the gas limit of 30,000,000.", "Abstract": "Set an in-protocol cap for the gas limit of 30,000,000.", "Motivation": "A high gas limit increases pressure on the network. In the benign case, it\nincreases the size of the state and history faster than we can sustain. In the\nmalicious case, it amplifies the devastation of certain denial-of-service\nattacks.", "Specification": "As of the fork blockN, consider blocks with agas_limitgreater than30,000,000invalid.", "Rationale": "The gas limit is currently under the control of block proposers. They have the\nability to increase the gas limit to whatever value they desire. This allows\nthem to bypass the EIP and All Core Devs processes in protocol decisions that\nmay negatively affect the security and/or decentralization of the network.", "Why Cap the Gas Limit": "The gas limit is currently under the control of block proposers. They have the\nability to increase the gas limit to whatever value they desire. This allows\nthem to bypass the EIP and All Core Devs processes in protocol decisions that\nmay negatively affect the security and/or decentralization of the network.", "No Fixed Gas Limit": "A valuable property of proposers choosing the gas limit is they can scale it\ndown quickly if the network becomes unstable or is undergoing certain types of\nattacks. For this reason, we maintain their ability to lower the gas limitbelow30,000,000.", "Backwards Compatibility": "No backwards compatibility issues.", "Test Cases": "TBD", "Security Considerations": "No security considerations.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- gas limit cap: Sets an in-protocol cap for the gas limit at 30,000,000, preventing block proposers from increasing the gas limit beyond this threshold.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3788, "url": "https://eips.ethereum.org/EIPS/eip-3788", "title": "Strict enforcement of chainId", "authors": ["Gregory Markou\u00a0(", "@GregTheGreek", ")"], "sections": {"EIP-3788: Strict enforcement of chainId": "Reject transactions that do not explicitly have the same chainId as the node\u2019s configuration.", "Reject transactions that do not explicitly have the same chainId as the node's configuration.": "Reject transactions that do not explicitly have the same chainId as the node\u2019s configuration.", "Abstract": "Reject transactions that do not explicitly have the same chainId as the node\u2019s configuration.", "Motivation": "PerEIP-155a transaction with achainId = 0is considered to be a valid \ntransaction. This was a feature to offer developers the ability to submit replayable transactions \nacross different chains. With the rise of evm compatible chains, many of which use forks, or packages\nfrom popular Ethereum clients, we are putting user funds at risk. This is because most wallet\ninterfaces do not expose the chainId to the user, meaning they typically do not have insight\ninto what chainId they are signing. Should a malicious actor (or accidental) choose to, they\ncan easily have users submit transactions with achainId = 0on a non-mainnet network, allowing\nthe malicious actor to replay the transaction on ethereum mainnet (or other networks for that matter)\nas a grief or sophisticated attack.", "Specification": "As of the fork blockN, consider transactions with achaindId = 0to be invalid. Such that \ntransactions are verified based on the nodes configuration. Eg:", "Rationale": "The configuration set by the node is the main source of truth, and thus should be explicitly used\nwhen deciding how to filter out a transaction. This check should exist in two places, as a filter\non the JSON-RPC (eg:eth_sendTransaction), and strictly enforced on the EVM during transaction \nvalidation.", "Backwards Compatibility": "This breaks all applications or tooling that submit transactions with achainId == 0after block numberN.", "Test Cases": "TBD", "Security Considerations": "It should be noted this will not prevent a malicious actor from deploying a network withchainId = 1, or copying any other networks chainId.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- strict enforcement of chainid: Requires transactions to have an explicit chainId that matches the node's configuration, preventing cross-chain transaction replay attacks.\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785."}
{"eip": 3978, "url": "https://eips.ethereum.org/EIPS/eip-3978", "title": "Gas refunds on reverts", "authors": ["Anton Bukov\u00a0(", "@k06a", ")", "Mikhail Melnik\u00a0(", "@ZumZoom", ")"], "sections": {"EIP-3978: Gas refunds on reverts": "For reverted state modification operations, keep access cost, but refund modification cost.", "Reprice reverted SSTORE/CREATE/SELFDESTRUCT/LOGX operations gas via gas refund mechanism": "For reverted state modification operations, keep access cost, but refund modification cost.", "Abstract": "For reverted state modification operations, keep access cost, but refund modification cost.", "Motivation": "Reverting a transaction, or any of its sub-calls, drops any state modifications that happened inside.\nBut now, users are being charged for the dropped modifications as if they persisted.", "Specification": "For each callframe, trackrevert_gas_refund, initially 0.", "Rationale": "Gas should reflect the cost of use.\nThe revert cost reflects the cost of access during execution, but not the cost of modification.", "Backwards Compatibility": "No known backward incompatibilities.", "Test Cases": "TBD", "Reference Implementation": "TBD", "Security Considerations": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- gas refunds on reverts: Proposes refunds for reverted SSTORE, CREATE, SELFDESTRUCT, and LOGX operations, only charging for access costs but not modification costs.\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4396, "url": "https://eips.ethereum.org/EIPS/eip-4396", "title": "Time-Aware Base Fee Calculation", "authors": ["Ansgar Dietrichs\u00a0(", "@adietrichs", ")"], "sections": {"EIP-4396: Time-Aware Base Fee Calculation": "This EIP proposes accounting for time between blocks in the base fee calculation to target a stable throughput by time, instead of by block. Aiming to minimize changes to the calculation, it only introduces a variable block gas target proportional to the block time. The EIP can, in principle, be applied to either a Proof-of-Work or a Proof-of-Stake chain, however the security implications for the Proof-of-Work case remain unexplored.", "Accounts for block time in the base fee calculation to target a stable throughput by time instead of by block.": "This EIP proposes accounting for time between blocks in the base fee calculation to target a stable throughput by time, instead of by block. Aiming to minimize changes to the calculation, it only introduces a variable block gas target proportional to the block time. The EIP can, in principle, be applied to either a Proof-of-Work or a Proof-of-Stake chain, however the security implications for the Proof-of-Work case remain unexplored.", "Abstract": "This EIP proposes accounting for time between blocks in the base fee calculation to target a stable throughput by time, instead of by block. Aiming to minimize changes to the calculation, it only introduces a variable block gas target proportional to the block time. The EIP can, in principle, be applied to either a Proof-of-Work or a Proof-of-Stake chain, however the security implications for the Proof-of-Work case remain unexplored.", "Motivation": "The current base fee calculation chooses the gas usage of a block as the signal to determine whether demand for block space is too low (indicating that the base fee should be lowered) or too high (indicating that the base fee should be increased). While simple, this choice of signal has drawbacks: it does not take the block time into account. Assuming a relatively constant demand, a proposer constructing a block after 20 seconds will have transactions available with twice the gas of a proposer constructing a block after 10 seconds. Using the same gas target for both is accordingly sub-optimal. In practice, there are several undesirable consequences of this flawed signal:", "Base Fee Volatility Under Proof-of-Work": "Under Proof-of-Work (PoW), block times are stochastic, and for that reason there exists large block time variability. This variability contributes to the base fee volatility, where the base fee can be expected to oscillate around the equilibrium value even under perfectly stable demand.", "Missed Slots": "Under Proof-of-Stake (PoS), block times are ideally uniform (always 12s), but missed slots lead to individual blocks with increased block time (24s, 36s, \u2026). Such missed slots will result in the next block being overfull, and with the current update rule, signal a fake demand spike and thus cause a small unwarranted base fee spike.", "Throughput Degradation During Consensus Issues": "A more severe version of individual missed slots can be caused by consensus issues that prevent a significant portion of block proposers from continuing to create blocks. This can be due to block proposers forking off (and creating blocks on their own fork), being unable to keep up with the current chain head for another reason, or simply being unable to create valid blocks.", "Specification": "Using the pseudocode language ofEIP-1559, the updated base fee calculation becomes:", "Rationale": "The proposed new base fee calculation only adjusts the block gas target by scaling it with the block time, capped at a maximum percent of the overall block gas limit:", "Mechanism": "The proposed new base fee calculation only adjusts the block gas target by scaling it with the block time, capped at a maximum percent of the overall block gas limit:", "Limitations": "Under PoS, block time increases always come in multiples of full blocks (e.g. a single missed slot = 24s instead of 12s block time). Accounting for this already requires doubling the block gas target, even for a single missed slot. However, with the block elasticity currently set to 2, this target would be equal to the block gas limit. Having the new target equal to the block gas limit is less than ideal, and thus is reduced slightly, according to theMAX_GAS_TARGET_PERCENTparameter. The reason for the existence of this parameter is twofold:", "Possible Extensions": "These limitations directly result from the design goal of a minimal change, to maximize chances of being included in the merge. There are natural ways of extending the EIP design to more effectively handle offline validators, at the expense of somewhat more extensive changes:", "Backwards Compatibility": "The EIP has minimal impact on backwards compatibility, only requiring updates to existing base fee calculation tooling.", "Test Cases": "tbd", "Reference Implementation": "tbd", "Security Considerations": "Under PoW, miners are in control over the timestamp field of their blocks. While there are some enforced limits to valid timestamps, implications regarding potential timestamp manipulation are nontrivial and remain unexplored for this EIP.", "Timestamp Manipulation": "Under PoW, miners are in control over the timestamp field of their blocks. While there are some enforced limits to valid timestamps, implications regarding potential timestamp manipulation are nontrivial and remain unexplored for this EIP.", "Suppressing Base Fee Increases": "As discussed in the rationale, a high value forMAX_GAS_TARGET_PERCENTduring times of many offline block proposers results in a small remaining signal space for genuine demand increases that should result in base fee increases. This in turn decreases the cost for block proposers for suppresing these base fee increases, instead forcing the fallback to a first-price priority fee auction.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- time-aware base fee calculation: Proposes adjusting the block gas target based on block time to target stable throughput by time, helping to smooth base fee volatility under PoW and missed slots under PoS.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4488, "url": "https://eips.ethereum.org/EIPS/eip-4488", "title": "Transaction calldata gas cost reduction with total calldata limit", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")"], "sections": {"EIP-4488: Transaction calldata gas cost reduction with total calldata limit": "Decrease transaction calldata gas cost, and add a limit of how much total transaction calldata can be in a block.", "Greatly decreases the gas cost of transaction calldata and simultaneously caps total transaction calldata in a block": "Decrease transaction calldata gas cost, and add a limit of how much total transaction calldata can be in a block.", "Abstract": "Decrease transaction calldata gas cost, and add a limit of how much total transaction calldata can be in a block.", "Motivation": "Rollups are in the short and medium term, and possibly the long term, the only trustless scaling solution for Ethereum. Transaction fees on L1 have been very high for months and there is greater urgency in doing anything required to help facilitate an ecosystem-wide move to rollups. Rollups are significantly reducing fees for many Ethereum users: Optimism and Arbitrum frequently provide fees that are ~3-8x lower than the Ethereum base layer itself, and ZK rollups, which have better data compression and can avoid including signatures, have fees ~40-100x lower than the base layer.", "Specification": "Reduce the gas cost of transaction calldata toNEW_CALLDATA_GAS_COSTper byte, regardless of whether the byte is zero or nonzero.", "Rationale": "A natural alternative proposal is to decreaseNEW_CALLDATA_GAS_COSTwithout adding a limit. However, this presents a security concern: today, the average block sizeis 60-90 kB, but themaximumblock size is30M / 16 = 1,875,000bytes (plus about a kilobyte of block and tx overhead). Simply decreasing the calldata gas cost from 16 to 3 would increase the maximum block size to 10M bytes. This would push the Ethereum p2p networking layer to unprecedented levels of strain and risk breaking the network; some previous live tests of ~500 kB blocks a few years ago had already taken down a few bootstrap nodes.", "Backwards Compatibility": "This is a backwards incompatible gas repricing that requires a scheduled network upgrade.", "Security Considerations": "Theburstdata capacity of the chain does not increase as a result of this proposal (in fact, it slightly decreases). However, theaveragedata capacity will increase. This means that the storage requirements of history-storing will go up. A worst-case scenario would be a theoretical long-run maximum of ~1,262,861 bytes per 12 sec slot, or ~3.0 TB per year.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- transaction calldata gas cost reduction: Reduces the gas cost for transaction calldata to 3 gas per byte and introduces a cap on the total calldata per block to mitigate the increased network strain.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170."}
{"eip": 4520, "url": "https://eips.ethereum.org/EIPS/eip-4520", "title": "Multi-byte opcodes prefixed by EB and EC.", "authors": ["Brayton Goodall\u00a0(", "@Spore-Druid-Bray", ")", "Mihir Faujdar\u00a0(", "@uink45", ")"], "sections": {"EIP-4520: Multi-byte opcodes prefixed by EB and EC.": "Reserve0xEBand0xECfor usage as extended opcode space.", "Reserve `0xEB` and `0xEC` for usage as extended opcode space.": "Reserve0xEBand0xECfor usage as extended opcode space.", "Abstract": "Reserve0xEBand0xECfor usage as extended opcode space.", "Motivation": "It would be convenient to introduce new opcodes that are likely to be infrequently used, whilst also being able to have greater than 256 opcodes in total. As a single byte opcode is half the size of a double byte opcode, the greatest efficiency in code sizes will be one where frequently used opcodes are single bytes. Two prefix bytes are used to accommodate up to 510 double byte opcodes.", "Specification": "For example, a new arithmetic opcode may be allocated to0xEC 01(ADD), and a novel opcode may be introduced at0xEB F4(DELEGATECALL).", "Rationale": "It was considered that two prefix bytes rather than one would be adequate for reservation as extension addresses. Both0xEBand0xECwere chosen to be part of the E-series of opcodes. For example, the0xEFbyte is reserved for contracts conforming to the Ethereum Object Format. By having unassigned opcodes for extending the opcode space, there will be a lower risk of breaking the functionalities of deployed contracts compared to choosing assigned opcodes.", "Backwards Compatibility": "Previous usage of0xEBand0xECmay result in unexpected behaviour and broken code.", "Security Considerations": "There are no known security considerations.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- multi-byte opcodes: Reserves 0xEB and 0xEC as prefixes to introduce extended multi-byte opcodes, allowing more opcodes to be defined in a larger opcode space.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4573, "url": "https://eips.ethereum.org/EIPS/eip-4573", "title": "Procedures for the EVM", "authors": ["Greg Colvin\u00a0(", "@gcolvin", ")", "Greg Colvin\u00a0<", "greg@colvin.org", ">"], "sections": {"EIP-4573: Procedures for the EVM": "Five EVM instructions are introduced to define, call, and return from named EVMproceduresand access theircall framesin memory -ENTERPROC,LEAVEPROC,CALLPROC,RETURNPROC, andFRAMEADDRESS.", "Introduces support for EVM Procedures.": "Five EVM instructions are introduced to define, call, and return from named EVMproceduresand access theircall framesin memory -ENTERPROC,LEAVEPROC,CALLPROC,RETURNPROC, andFRAMEADDRESS.", "Abstract": "Five EVM instructions are introduced to define, call, and return from named EVMproceduresand access theircall framesin memory -ENTERPROC,LEAVEPROC,CALLPROC,RETURNPROC, andFRAMEADDRESS.", "Motivation": "Currently, Ethereum bytecode has no syntactic structure, andsubroutineshave no defined interfaces.", "Prior Art": "The terminology is not well-defined, but we will follow Intel in calling the low-level conceptsubroutinesand the higher level conceptprocedures.  The distinction is thatsubroutinesare little more than a jump that knows where it came from, whereas procedures have a defined interface and manage memory as a stack.EIP-2315introducessubroutines, and this EIP introducesprocedures.", "Specification": "Marks the entry point to a procedure", "Instructions": "Marks the entry point to a procedure", "Memory Costs": "Presently,MSTOREis defined as", "Call Frame Stack": "These instructions make use of aframe stackto allocate and free frames of local data forproceduresin memory.  Frame memory begins at address 0 in memory and grows downwards, towards more negative addresses.  A frame is allocated for each procedure when it is called, and freed when it returns.", "Rationale": "There is actually not much new here.  It amounts toEIP-615, refined and refactored into bite-sized pieces, along lines common to other machines.", "Backwards Compatibility": "This proposal adds new EVM opcodes.  It doesn\u2019t remove or change the semantics of any existing opcodes, so there should be no backwards compatibility issues.", "Security": "Safe use of these constructs must be checked completely at validation time \u2013 per EIP-3779 \u2013 so there should be no security issues at runtime.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- procedures for the evm: Introduces ENTERPROC, LEAVEPROC, CALLPROC, and RETURNPROC instructions to define and manage EVM procedures with automatic memory stack management.\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4747, "url": "https://eips.ethereum.org/EIPS/eip-4747", "title": "Simplify EIP-161", "authors": ["Peter Davies\u00a0(", "@petertdavies", ")"], "sections": {"EIP-4747: Simplify EIP-161": "Simplify the definition ofEIP-161, removing the requirement for implementors to support edge cases that are impossible on Ethereum Mainnet.", "Simplify EIP-161 and retroactively deprecate unused aspects of it": "Simplify the definition ofEIP-161, removing the requirement for implementors to support edge cases that are impossible on Ethereum Mainnet.", "Abstract": "Simplify the definition ofEIP-161, removing the requirement for implementors to support edge cases that are impossible on Ethereum Mainnet.", "Motivation": "EIP-161 is overly complex and has a number of edge cases that are poorly documented and tested. This EIP takes advantage of the complete removal of all remaining empty accounts in block 14049881 (tx0xf955834bfa097458a9cf6b719705a443d32e7f43f20b9b0294098c205b4bcc3d) to clarify it, and allows implementors to not implement various edge cases that never occurred and are not possible in the future.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "EIP-161 provides that empty accounts (accounts that have zero nonce, zero balance and no code, but that might have storage) can no longer be created and provides mechanism to remove old empty accounts. The last empty accounts were removed in block 14049881 (tx0xf955834bfa097458a9cf6b719705a443d32e7f43f20b9b0294098c205b4bcc3d).", "Backwards Compatibility": "This EIP is identical to EIP-161 except for the following differences, none of which affect Ethereum Mainnet. The differences are:", "\u201cPotentially state-changing operations\u201d": "EIP-161 specifies 11 \u201cpotentially state-changing operations\u201d that trigger state clearing. All but the 3 listed in this EIP are irrelevant, for the following reasons:", "Interaction withSTATICCALL": "The interaction betweenSTATICCALLand account clearing has never been specified in an EIP. The Ethereum currently testsuite requires thatSTATICCALLtriggers state clearing.", "\u201cAt the end of the transaction\u201d": "This only makes a difference if an account is deleted and later recreated in the same transaction. This never happens on Ethereum Mainnet.", "Test Cases": "All test cases involving empty accounts in the Ethereum execution layer test suite shall be removed unless they relate to the Spurious Dragon Hardfork. If a Spurious Dragon test relates involved deprecated edgecase the test must be removed or reworked.", "Other networks": "Ropsten had empty accounts seeded at genesis. They appear to have been cleared early in Ropsten\u2019s history before the Byzantium hardfork. Ropsten has never been checked for edgecases occurring. All other Ethereum testnets have had EIP-161 from genesis.", "Security considerations": "This EIP is only equivalent to EIP-161 on Ethereum Mainnet if the following facts are true:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- state clearing: Proposes the deletion of empty accounts (accounts with zero balance, nonce, code, and storage) to reduce state size, simplify execution, and enhance client performance.\n- simplify eip-161: Simplifies and retroactively deprecates unused aspects of EIP-161 related to state-clearing mechanisms, removing unnecessary edge cases that cannot occur on Ethereum Mainnet.\n- genesis: Log entry in system_logs for initial balances at network genesis ."}
{"eip": 4758, "url": "https://eips.ethereum.org/EIPS/eip-4758", "title": "Deactivate SELFDESTRUCT", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")", "Dankrad Feist\u00a0(", "@dankrad", ")"], "sections": {"EIP-4758: Deactivate SELFDESTRUCT": "This EIP renames theSELFDESTRUCTopcode toSENDALL, and replaces its functionality. The new functionality will be only to send all Ether in the account to the caller.", "Deactivate SELFDESTRUCT by changing it to SENDALL, which does recover all funds to the caller but does not delete any code or storage.": "This EIP renames theSELFDESTRUCTopcode toSENDALL, and replaces its functionality. The new functionality will be only to send all Ether in the account to the caller.", "Abstract": "This EIP renames theSELFDESTRUCTopcode toSENDALL, and replaces its functionality. The new functionality will be only to send all Ether in the account to the caller.", "Motivation": "TheSELFDESTRUCTopcode requires large changes to the state of an account, in particular removing all code and storage. This will not be possible in the future with Verkle trees: Each account will be stored in many different account keys, which will not be obviously connected to the root account.", "Specification": "Getting rid of theSELFDESTRUCTopcode has been considered in the past, and there are currently no strong reasons to use it. Disabling it will be a requirement for statelessness.", "Rationale": "Getting rid of theSELFDESTRUCTopcode has been considered in the past, and there are currently no strong reasons to use it. Disabling it will be a requirement for statelessness.", "Backwards Compatibility": "This EIP requires a hard fork, since it modifies consensus rules.", "Security Considerations": "The following applications ofSELFDESTRUCTwill be broken and applications that use it in this way are not safe anymore:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- deactivate selfdestruct: Renames the SELFDESTRUCT opcode to SENDALL, allowing contracts to transfer all ETH to a target without deleting code or storage, to prepare for future stateless Ethereum.\n- deactivate: Replaces SELFDESTRUCT, keeping the account\u2019s storage and marking the account as deactivated by setting its nonce to 2^64-1, while transferring the balance and leaving the option to reuse the account via CREATE2."}
{"eip": 4760, "url": "https://eips.ethereum.org/EIPS/eip-4760", "title": "SELFDESTRUCT bomb", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")", "Dankrad Feist\u00a0(", "@dankrad", ")"], "sections": {"EIP-4760: SELFDESTRUCT bomb": "This EIP renames theSELFDESCRUCTopcode toSENDALL, and replaces its functionality. The new functionality will be only to send all Ether in the account to the caller.", "Deactivate SELFDESTRUCT by changing it to SENDALL and stage this via a stage of exponential gas cost increases.": "This EIP renames theSELFDESCRUCTopcode toSENDALL, and replaces its functionality. The new functionality will be only to send all Ether in the account to the caller.", "Abstract": "This EIP renames theSELFDESCRUCTopcode toSENDALL, and replaces its functionality. The new functionality will be only to send all Ether in the account to the caller.", "Motivation": "TheSELFDESTRUCTopcode requires large changes to the state of an account, in particular removing all code and storage. This will not be possible in the future with Verkle trees: Each account will be stored in many different account keys, which will not be obviously connected to the root account.", "Specification": "The idea behind this EIP is to disableSELFDESTRUCTin a way that gives ample warning to Dapp developers. Many developers do not watch the EIP process closely and can therefore be caught by surprise when an opcode is deactivated and does not fulfill its original purpose anymore. However, at least if the smart contract has regular use, then users will notice the price of the operation going up tremendously. The period over which this is happening (HARD_FORK_BLOCK + DOUBLING_SLOTS * DOUBLINGS_BEFORE_SENDALL) is chosen to be long enough (ca. 4 months) such that it gives developers time to react to this change and prepare their application.", "Constants": "The idea behind this EIP is to disableSELFDESTRUCTin a way that gives ample warning to Dapp developers. Many developers do not watch the EIP process closely and can therefore be caught by surprise when an opcode is deactivated and does not fulfill its original purpose anymore. However, at least if the smart contract has regular use, then users will notice the price of the operation going up tremendously. The period over which this is happening (HARD_FORK_BLOCK + DOUBLING_SLOTS * DOUBLINGS_BEFORE_SENDALL) is chosen to be long enough (ca. 4 months) such that it gives developers time to react to this change and prepare their application.", "Rationale": "The idea behind this EIP is to disableSELFDESTRUCTin a way that gives ample warning to Dapp developers. Many developers do not watch the EIP process closely and can therefore be caught by surprise when an opcode is deactivated and does not fulfill its original purpose anymore. However, at least if the smart contract has regular use, then users will notice the price of the operation going up tremendously. The period over which this is happening (HARD_FORK_BLOCK + DOUBLING_SLOTS * DOUBLINGS_BEFORE_SENDALL) is chosen to be long enough (ca. 4 months) such that it gives developers time to react to this change and prepare their application.", "Backward Compatibility": "This EIP requires a hard fork, since it modifies consensus rules.", "Security Considerations": "The following applications ofSELFDESTRUCTwill be broken and applications that use it in this way are not safe anymore:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- selfdestruct bomb: Phases out the SELFDESTRUCT opcode by exponentially increasing its gas cost over time, eventually converting it to SENDALL, which transfers all ETH in the account but no longer deletes code or storage.\n- deactivate: Replaces SELFDESTRUCT, keeping the account\u2019s storage and marking the account as deactivated by setting its nonce to 2^64-1, while transferring the balance and leaving the option to reuse the account via CREATE2."}
{"eip": 4863, "url": "https://eips.ethereum.org/EIPS/eip-4863", "title": "Beacon chain push withdrawals", "authors": ["Alex Stokes\u00a0(", "@ralexstokes", ")", "Danny Ryan\u00a0(", "@djrtwo", ")"], "sections": {"EIP-4863: Beacon chain push withdrawals": "Introduce a newEIP-2718 transaction typeto support validator withdrawals that are \u201cpushed\u201d from the beacon chain to the EVM.", "Support validator withdrawals from the beacon chain to the EVM via a new \"push-style\" transaction type.": "Introduce a newEIP-2718 transaction typeto support validator withdrawals that are \u201cpushed\u201d from the beacon chain to the EVM.", "Abstract": "Introduce a newEIP-2718 transaction typeto support validator withdrawals that are \u201cpushed\u201d from the beacon chain to the EVM.", "Motivation": "This EIP provides a way for validator withdrawals made on the beacon chain to enter into the EVM.\nThe architecture is \u201cpush\u201d-based, rather than \u201cpull\u201d-based, where withdrawals are required to be processed in the execution block as soon as they are dequeued from the beacon chain.", "Specification": "Beginning with the execution timestampFORK_TIMESTAMP, execution clientsMUSTintroduce the following extensions to transaction processing and block validation:", "New transaction type": "Define a newEIP-2718transaction type withTransactionTypeWITHDRAWAL_TX_TYPE.", "Block validity": "If a block containsanytransactions withWITHDRAWAL_TX_TYPEtype, theyMUSTcome afterALLother transactions in the block.", "Transaction processing": "When processing a transaction withWITHDRAWAL_TX_TYPEtype, the implementation should increase the balance of theaddressspecified by\ntheWithdrawalTransactionby theamountof wei specified.", "Rationale": "This push approach gives validators a small subsidy with respect to processing, in lieu of needing to buy gas via normal EVM processing that would be required for a pull-based approach.", "Push vs pull approach": "This push approach gives validators a small subsidy with respect to processing, in lieu of needing to buy gas via normal EVM processing that would be required for a pull-based approach.", "Why a new transaction type?": "This EIP suggests a new transaction type as it has special semantics different from other existing types of EVM transactions.", "Why no (gas) costs for new transaction type?": "The maximum number of this transaction type that can reach the execution layer at a given time is bounded (enforced by the consensus layer) and this limit is kept small so that\nany execution layer operational costs are negligible in the context of the broader block execution.", "Why only balance updates? No general EVM execution?": "More general processing introduces the risk of failures, which complicates accounting on the beacon chain.", "Why new block validations?": "The beacon chain must be able to efficiently validate that the withdrawal transactions in a given execution block are\nthe ones expected based on its own internal scheduling logic to maintain the soundness of the withdrawal mechanism.", "Backwards Compatibility": "No issues.", "Security Considerations": "Consensus-layer validation of withdrawal transactions is critical to ensure that the proper amount of ETH is withdrawn back into the execution layer.\nThis consensus-layer to execution-layer ETH transfer does not have a current analog in the EVM and thus deserves very high security scrutiny.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- beacon chain push withdrawals: Implements push-based validator withdrawals from the beacon chain to the EVM via a system-level operation, allowing for seamless withdrawals without user intervention.\n- withdrawal: Log entry in system_logs for tracking withdrawals under EIP-4895 ."}
{"eip": 5000, "url": "https://eips.ethereum.org/EIPS/eip-5000", "title": "MULDIV instruction", "authors": ["Harikrishnan Mulackal\u00a0(", "@hrkrshnn", ")", "Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")"], "sections": {"EIP-5000: MULDIV instruction": "Introduce a new instruction,MULDIV(x, y, z), to perform((x * y) / z) % 2**256in 512-bit precision.z = 0is a special case for(x * y) / 2**256.", "Introduce a new instruction to perform x * y / z in 512-bit precision": "Introduce a new instruction,MULDIV(x, y, z), to perform((x * y) / z) % 2**256in 512-bit precision.z = 0is a special case for(x * y) / 2**256.", "Abstract": "Introduce a new instruction,MULDIV(x, y, z), to perform((x * y) / z) % 2**256in 512-bit precision.z = 0is a special case for(x * y) / 2**256.", "Motivation": "Fixed point operations in high level languages are very commonly used on Ethereum, especially in the domain of financial applications.", "Specification": "A new instruction is introduced:MULDIV(0x1e).", "Rationale": "All the arithmetic instructions in EVM handle division or modulo 0 specially: the instructions return 0. We have decided to break consistency in order to provide a flexible opcode, which can be used to detect wrapping behaviour.", "The special 0 case": "All the arithmetic instructions in EVM handle division or modulo 0 specially: the instructions return 0. We have decided to break consistency in order to provide a flexible opcode, which can be used to detect wrapping behaviour.", "Argument ordering": "The order of arguments matchesaddmodandmulmod.", "Backwards Compatibility": "This is a new instruction not present prior.", "Test Cases": "TBA", "Security Considerations": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- muldiv instruction: Introduces the MULDIV instruction, which performs x * y / z in 512-bit precision, providing an efficient way to perform fixed-point arithmetic and cryptographic calculations in EVM.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5003, "url": "https://eips.ethereum.org/EIPS/eip-5003", "title": "Insert Code into EOAs with AUTHUSURP", "authors": ["Dan Finlay\u00a0(", "@danfinlay", ")", "Sam Wilson\u00a0(", "@SamWilsn", ")"], "sections": {"EIP-5003: Insert Code into EOAs with AUTHUSURP": "This EIP introduces a new opcode,AUTHUSURP, which deploys code at anEIP-3074authorized address. For externally owned accounts (EOAs), together withEIP-3607, this effectively revokes the original signing key\u2019s authority.", "Allow migrating away from ECDSA by deploying code in place of an externally owned account.": "This EIP introduces a new opcode,AUTHUSURP, which deploys code at anEIP-3074authorized address. For externally owned accounts (EOAs), together withEIP-3607, this effectively revokes the original signing key\u2019s authority.", "Abstract": "This EIP introduces a new opcode,AUTHUSURP, which deploys code at anEIP-3074authorized address. For externally owned accounts (EOAs), together withEIP-3607, this effectively revokes the original signing key\u2019s authority.", "Motivation": "EOAs currently hold a significant amount of user-controlled value on Ethereum blockchains, but are limited by the protocol in a variety of critical ways. These accounts do not support rotating keys for security, batching to save gas, or sponsored transactions to reduce the need to hold ether yourself. There are countless other benefits that come from having a contract account or account abstraction, like choosing one\u2019s own authentication algorithm, setting spending limits, enabling social recovery, allowing key rotation, arbitrarily and transitively delegating capabilities, and just about anything else we can imagine.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Conventions": "A new opcodeAUTHUSURPshall be created at0xf8. It shall take two stack elements and return one stack element.", "AUTHUSURP(0xf8)": "A new opcodeAUTHUSURPshall be created at0xf8. It shall take two stack elements and return one stack element.", "Rationale": "AUTHUSURPdoes not check the nonce of theauthorizedaccount because it must work with accounts that have previously sent transactions.", "Backwards Compatibility": "AUTHUSURPwith EIP-3607 revokes the authority of the original ECDSA signature to send transactions from the account. This is completely new behavior, although it is somewhat similar to theCREATE2opcode.", "Security Considerations": "Contracts using ECDSA signatures outside of transactions will not be aware that the usurped account is no longer controlled by a private key. This means that, for example, the private key willalwayshave access to thepermitfunction on token contracts. This can\u2014and should\u2014be mitigated by modifying theecrecoverpre-compiled contract.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- authusurp: Introduces an opcode that deploys code to an authorized address, allowing externally owned accounts (EOAs) to migrate to contract accounts, effectively revoking the original ECDSA signature authority."}
{"eip": 5022, "url": "https://eips.ethereum.org/EIPS/eip-5022", "title": "Increase price of SSTORE from zero to non-zero to 40k gas", "authors": ["Green\u00a0(", "@greenlucid", ")"], "sections": {"EIP-5022: Increase price of SSTORE from zero to non-zero to 40k gas": "Increase the price of the SSTORE opcode from20_000gas to40_000gas when the original slot is zero and the resultant slot is non-zero.", "": "Increase the price of the SSTORE opcode from20_000gas to40_000gas when the original slot is zero and the resultant slot is non-zero.", "Abstract": "Increase the price of the SSTORE opcode from20_000gas to40_000gas when the original slot is zero and the resultant slot is non-zero.", "Motivation": "The cost of creating a piece of new state increases as state is larger. However, the price for creating every new storage slot has not increased.\nAll resources are merged into the same pricing mechanism. If the price for creating new storage slots is fixed, then it needs to be manually changed.", "Rationale": "Rewriting storage does not affect state growth, which is the main issue this EIP is addressing. Rewriting storage may also be underpriced.\nIncreasing the price of state growth will, at least, incentivize developers to reuse storage instead.", "Why not also raise the cost of non-zero to non-zero?": "Rewriting storage does not affect state growth, which is the main issue this EIP is addressing. Rewriting storage may also be underpriced.\nIncreasing the price of state growth will, at least, incentivize developers to reuse storage instead.", "Why not also increase the gas refund from setting non-zero to zero?": "More discussion is needed on this.", "Why not a better state solution?": "Whereas solutions like state rent, or state expiry have been researched for a long time, they will not be ready on the short to medium term. So, it is desirable to patch pricing for the short term. Opcode repricing has been done before, so it should not impose a large development time investment for clients.", "Why was that specific amount chosen?": "The current pricing was made off a naive approach of benchmarking opcodes in a laptop. Not only it did not consider the long term problem of having the same price for a resource that costs more over time, the benchmark itself was wrong. This price is closer to what the naive original benchmark should have been. It could go higher, but that may be too disruptive.", "Is this too distruptive?": "This change will severely impact the gas cost of many applications. The network does not have to subsidize state growth at the expense of more expensive regular transactions, so even if it is too disruptive, it will increase the health of the network.", "Specification": "For blocks whereblock.number >= FORK_BLOCK, a new gas schedule applies. MakeSSTORE_SET_GAS, the price when a slot is set from zero to non-zero, equalNEW_STORAGE_PRICE. All other costs remain the same.", "Backwards compatibility": "Contracts that depend on hardcoded gas costs will break if they create state.", "Implementation": "https://github.com/ethereum/go-ethereum/pull/24725", "Security considerations": "TODO", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5027, "url": "https://eips.ethereum.org/EIPS/eip-5027", "title": "Remove the limit on contract code size", "authors": ["Qi Zhou\u00a0(", "@qizhou", ")"], "sections": {"EIP-5027: Remove the limit on contract code size": "Remove the limit on the contract code size, i.e., only limit the contract code size by block gas limit, with minimal changes to existing code and proper gas metering adjustment to avoid possible attacks.", "Change the limit on contract size from 24576 to infinity": "Remove the limit on the contract code size, i.e., only limit the contract code size by block gas limit, with minimal changes to existing code and proper gas metering adjustment to avoid possible attacks.", "Abstract": "Remove the limit on the contract code size, i.e., only limit the contract code size by block gas limit, with minimal changes to existing code and proper gas metering adjustment to avoid possible attacks.", "Motivation": "The motivation is to remove the limit on the code size so that users can deploy a large-code contract without worrying about splitting the contract into several sub-contracts.", "Specification": "Ifblock.number >= FORK_BLKNUM, the contract creation initialization can return data with any length, but the contract-related opcodes will take extra gas as defined below:", "Parameters": "Ifblock.number >= FORK_BLKNUM, the contract creation initialization can return data with any length, but the contract-related opcodes will take extra gas as defined below:", "Rationale": "The goal is to measure the CPU/IO cost of the contract read/write operations reusing existing gas metering so that the resources will not be abused.", "Gas Metering": "The goal is to measure the CPU/IO cost of the contract read/write operations reusing existing gas metering so that the resources will not be abused.", "Backwards Compatibility": "All existing contracts will not be impacted by the proposal.", "Reference Implementation": "The reference implementation on Geth is available at0001-unlimit-code-size.patch.", "Security Considerations": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5065, "url": "https://eips.ethereum.org/EIPS/eip-5065", "title": "Instruction for transferring ether", "authors": ["Mudit Gupta\u00a0(", "@maxsam4", ")"], "sections": {"EIP-5065: Instruction for transferring ether": "Add a new instruction that transfers ether to a destination address without handing over the flow of execution to it. It should work similarly to howSELFDESTRUCT (0xFF)transfers ether to the destination without making a call to it.", "Instruction for just transferring ether without transferring the flow of execution": "Add a new instruction that transfers ether to a destination address without handing over the flow of execution to it. It should work similarly to howSELFDESTRUCT (0xFF)transfers ether to the destination without making a call to it.", "Abstract": "Add a new instruction that transfers ether to a destination address without handing over the flow of execution to it. It should work similarly to howSELFDESTRUCT (0xFF)transfers ether to the destination without making a call to it.", "Motivation": "From an architectural point of view, execution flow should never be handed over to an untrusted contract. Ethereum currently does not have any ideal way to transfer ether without transferring the flow of execution. People have come up with reentrancy guards and similar solutions to prevent some types of attacks but it\u2019s not an ideal solution. The only way to transfer ether from smart contracts without triggering a call is to create a dummy contract, send the precise amount of ether to it and then callSELFDESTRUCT (0xFF)from it.", "Specification": "Introduce a new instruction,AIRDROP(0xFG) that transfers ether to the destination without making a call to it.", "Stack input": "address: the account to send ether to.\nvalue: value in wei to send to the account.", "Gas": "The total gas cost should be the sum of a static cost + address_access_cost + value_to_empty_account_cost.", "Rationale": "This behavior is already possible by deploying a new contract that doesSELFDESTRUCT (0xFF)but it is prohibitively expensive. In most scenarios, the contract author only wants to transfer ether rather than transferring control of the execution. ERC20 can be used as a case study for this where most users transfer funds without a post-transfer hook.", "Backwards Compatibility": "No known issues as this is a new instruction that does not affect any old instructions and does not break any valid assumptions since it make not anything impossible possible.", "Test Cases": "TODO", "Security Considerations": "No known security risks.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- empty_account_cost: A constant gas cost set as 25000 for executing the CREATE_DELEGATE instruction.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5081, "url": "https://eips.ethereum.org/EIPS/eip-5081", "title": "Expirable Transaction", "authors": ["Zainan Victor Zhou\u00a0(", "@xinbenlv", ")", "Nick Johnson\u00a0(", "@Arachnid", ")", "Konrad Feldmeier\u00a0<", "konrad@brainbot.com", ">"], "sections": {"EIP-5081: Expirable Transaction": "This EIP adds a new transaction type of that includes expiration with a blocknum.", "This EIP adds a new transaction type of that includes expiration with a blocknum": "This EIP adds a new transaction type of that includes expiration with a blocknum.", "Abstract": "This EIP adds a new transaction type of that includes expiration with a blocknum.", "Motivation": "When a user sends a transactiontx0with a low gas price, sometimes it might not be high enough to be executed.\nA common resolution is for the user to submit the transaction again with the same nonce and higher gas price.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Parameters": "As ofFORK_BLOCK_NUMBER, a newEIP-2718transaction is introduced withTransactionType=TX_TYPE(TBD).", "Rationale": "TODO", "Backwards Compatibility": "TODO", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- expirable transaction: Adds a transaction type with an expiration defined by a block number, allowing transactions to automatically expire after a certain block height.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5283, "url": "https://eips.ethereum.org/EIPS/eip-5283", "title": "Semaphore for Reentrancy Protection", "authors": ["Sergio D. Lerner\u00a0(", "@SergioDemianLerner", ")"], "sections": {"EIP-5283: Semaphore for Reentrancy Protection": "This EIP proposes adding a precompiled contract that provides a semaphore function for creating a new type of reentrancy protection guard (RPG). This function aims to replace the typical RPG based on modifying a contract storage cell. The benefit is that the precompile-based RPG does not write to storage, and therefore it enables contracts to be forward-compatible with all designs that provide fine-grained (i.e. cell level) parallelization for the multi-threaded execution of EVM transactions.", "A Precompile-based parallelizable reentrancy protection using the call stack": "This EIP proposes adding a precompiled contract that provides a semaphore function for creating a new type of reentrancy protection guard (RPG). This function aims to replace the typical RPG based on modifying a contract storage cell. The benefit is that the precompile-based RPG does not write to storage, and therefore it enables contracts to be forward-compatible with all designs that provide fine-grained (i.e. cell level) parallelization for the multi-threaded execution of EVM transactions.", "Abstract": "This EIP proposes adding a precompiled contract that provides a semaphore function for creating a new type of reentrancy protection guard (RPG). This function aims to replace the typical RPG based on modifying a contract storage cell. The benefit is that the precompile-based RPG does not write to storage, and therefore it enables contracts to be forward-compatible with all designs that provide fine-grained (i.e. cell level) parallelization for the multi-threaded execution of EVM transactions.", "Motivation": "The typical smart contract RPG uses a contract storage cell. The algorithm is simple: the code checks that a storage cell is 0 (or any other predefined constant) on entry, aborting if not, and then sets it to 1. After executing the required code, it resets the cell back to 0 before exiting. This is the algorithm implemented in OpenZeppelin\u2019s ReentrancyGuard. The algorithm results in a read-write pattern on the RPG\u2019s storage cell. This pattern prevents the parallelization of the execution of the smart contract for all known designs that try to provide fine-grained parallelization (detecting conflicts at the storage cell level).", "Specification": "Starting from an activation block (TBD) a new precompiled contractSemaphoreis created at address0x0A. WhenSemaphoreis called, if the caller address is present more than once in the call stack, the contract behaves as if the first instruction had been aREVERT, therefore the CALL returns 0. Otherwise, it executes no code and returns 1. The gas cost of the contract execution is set to 100, which is consumed independently of the call result.", "Rationale": "The address0x0Ais the next one available within the range defined byEIP-1352.", "Sample usage": "The only way to parallelize preexistent contracts that are using the storage RPG construction is that the VM automatically detects that a storage variable is used for the RPG, and proves that it works as required. This requires static code analysis. This is difficult to implement in consensus for two reasons. First, the CPU cost of detection and/or proving may be high. Second, some contract functions may not be protected by the RPG, meaning that some execution paths do not alter the RPG, which may complicate proving. Therefore this proposal aims to protect future contracts and let them be parallelizable, rather than to parallelize already deployed ones.", "Parallelizable storage-based RPGs": "The only way to parallelize preexistent contracts that are using the storage RPG construction is that the VM automatically detects that a storage variable is used for the RPG, and proves that it works as required. This requires static code analysis. This is difficult to implement in consensus for two reasons. First, the CPU cost of detection and/or proving may be high. Second, some contract functions may not be protected by the RPG, meaning that some execution paths do not alter the RPG, which may complicate proving. Therefore this proposal aims to protect future contracts and let them be parallelizable, rather than to parallelize already deployed ones.", "Alternatives": "There are alternative designs to implement RPGs on the EVM:", "Gas cost": "A gas cost of 100 represents a worst-case resource consumption, which occurs when the stack is almost full (approximately 400 addresses) and it is fully scanned. As the stack is always present in RAM, the scanning is fast.", "Backwards Compatibility": "This change requires a hard fork and therefore all full nodes must be updated.", "Test Cases": "A call tosecond()directly from a transaction does not revert, but a call tofirst()does revert.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- semaphore for reentrancy protection: Introduces a precompiled contract at 0x0A to provide reentrancy protection by checking if an address is already present in the call stack, preventing reentrancy attacks without modifying storage.\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5478, "url": "https://eips.ethereum.org/EIPS/eip-5478", "title": "CREATE2COPY Opcode", "authors": ["Qi Zhou\u00a0(", "@qizhou", ")"], "sections": {"EIP-5478: CREATE2COPY Opcode": "Adding a new opcode,CREATE2COPY, that is identical toCREATE2but with potentially much lower gas cost by accepting an additional argumentexisting_contract_addressthat already stored the code of the new contract.", "Reducing the gas cost of contract creation with existing code": "Adding a new opcode,CREATE2COPY, that is identical toCREATE2but with potentially much lower gas cost by accepting an additional argumentexisting_contract_addressthat already stored the code of the new contract.", "Abstract": "Adding a new opcode,CREATE2COPY, that is identical toCREATE2but with potentially much lower gas cost by accepting an additional argumentexisting_contract_addressthat already stored the code of the new contract.", "Motivation": "This EIP aims to reduce the smart contract creation cost of account abstraction (AA) contracts that have identical code.", "Specification": "Ifblock.number >= FORK_BLKNUM, a new opcode is added (CREATE2COPY) at0xf6, which takes 5 stack arguments:endowment,memory_start,memory_length,salt,existing_contract_address.CREATE2COPYbehaves identically toCREATE2(0xf5as defined inEIP-1014), except that the code hash of the creating contract MUST be the same as that ofexisting_contract_address.", "Parameters": "Ifblock.number >= FORK_BLKNUM, a new opcode is added (CREATE2COPY) at0xf6, which takes 5 stack arguments:endowment,memory_start,memory_length,salt,existing_contract_address.CREATE2COPYbehaves identically toCREATE2(0xf5as defined inEIP-1014), except that the code hash of the creating contract MUST be the same as that ofexisting_contract_address.", "Rationale": "TBD", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures."}
{"eip": 5806, "url": "https://eips.ethereum.org/EIPS/eip-5806", "title": "Delegate transaction", "authors": ["Hadrien Croubois\u00a0(", "@Amxx", ")"], "sections": {"EIP-5806: Delegate transaction": "This EIP adds a new transaction type that allows EOAs to execute arbitrary code using a delegate-call-like mechanism.", "Adds a new transaction type that allows EOAs to execute arbitrary code through delegation": "This EIP adds a new transaction type that allows EOAs to execute arbitrary code using a delegate-call-like mechanism.", "Abstract": "This EIP adds a new transaction type that allows EOAs to execute arbitrary code using a delegate-call-like mechanism.", "Motivation": "EOA are the most widely used type of account, yet their ability to perform operations is limited to deploying contracts and sending \u201ccall\u201d transactions. It is currently not possible for an EOA to execute arbitrary code, which greatly limits the interactions users can have with the blockchain. Account abstraction has been extensively discussed but the path toward mainstream adoption is still unclear. Some approaches, such asERC-4337hope to improve the usability of smart wallets, without addressing the issue of smart wallet support by applications.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Parameters": "As ofFORK_BLOCK_NUMBER, a newEIP-2718transaction is introduced withTransactionType=TX_TYPE(TBD).", "Opcode restriction": "For security reasons, some opcodes should not be executed in the context of an EOA:", "Rationale": "EOAs are the most widely used type of wallet.", "Backwards Compatibility": "No known backward compatibility issues thanks to the transaction envelope (EIP-2718).", "Security Considerations": "The nonce mechanism, already used in other transaction types, prevents replay attacks. Similar to existing transaction types, a delegate transaction can be cancelled by replacing it with a dummy transaction that pays more fees.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- delegate transaction: Introduces a new transaction type allowing externally owned accounts (EOAs) to execute arbitrary code using a delegate call, expanding EOA capabilities without migrating to contract wallets.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5988, "url": "https://eips.ethereum.org/EIPS/eip-5988", "title": "Add Poseidon hash function precompile", "authors": ["Abdelhamid Bakhta\u00a0(", "@abdelhamidbakhta", ")", "Eli Ben Sasson\u00a0(", "@Elistark", ")", "Avihu Levy\u00a0(", "@avihu28", ")", "David Levit Gurevich\u00a0(", "@DavidLevitGurevich", ")"], "sections": {"EIP-5988: Add Poseidon hash function precompile": "This EIP introduces a new precompiled contract which implements the hash function used in the Poseidon cryptographic hashing algorithm, for the purpose of allowing interoperability between the EVM and ZK / Validity rollups, as well as introducing more flexible cryptographic hash primitives to the EVM.", "Add a precompiled contract which implements the hash function used in the Poseidon cryptographic hashing algorithm": "This EIP introduces a new precompiled contract which implements the hash function used in the Poseidon cryptographic hashing algorithm, for the purpose of allowing interoperability between the EVM and ZK / Validity rollups, as well as introducing more flexible cryptographic hash primitives to the EVM.", "Abstract": "This EIP introduces a new precompiled contract which implements the hash function used in the Poseidon cryptographic hashing algorithm, for the purpose of allowing interoperability between the EVM and ZK / Validity rollups, as well as introducing more flexible cryptographic hash primitives to the EVM.", "Motivation": "Poseidonis an arithmetic hash function that is designed to be efficient for Zero-Knowledge Proof Systems.\nEthereum adopts a rollup centric roadmap and hence must adopt facilities for L2s to be able to communicate with the EVM in an optimal manner.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Parameters": "Here are the Poseidon parameters that the precompile will support:", "Rationale": "TODO: Add rationale", "Backwards Compatibility": "There is very little risk of breaking backwards-compatibility with this EIP, the sole issue being if someone were to build a contract relying on the address at0xPOSEIDON_PRECOMPILE_ADDRESSbeing empty. The likelihood of this is low, and should specific instances arise, the address could be chosen to be any arbitrary value with negligible risk of collision.", "Test Cases": "The Poseidon reference implementation contains test vectors that can be used to test the precompile.\nThose tests are availablehere.", "Security Considerations": "Quoting Vitalik Buterin fromArithmetic hash based alternatives to KZG for proto-dankshardingthread on EthResearch:", "Security of the Poseidon parameters": "The MDS matrix is a square matrix of sizet*tthat is used to mix the state.", "Papers and research related to Poseidon security": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- poseidon hash function precompile: Adds a precompiled contract for the Poseidon cryptographic hash function, enabling efficient interoperability with ZK-rollups and zero-knowledge proofs on Ethereum.\n- precompile_address: The address of the new precompiled contract for deactivating or reactivating a delegated EOA's private key.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6046, "url": "https://eips.ethereum.org/EIPS/eip-6046", "title": "Replace SELFDESTRUCT with DEACTIVATE", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-6046: Replace SELFDESTRUCT with DEACTIVATE": "ChangeSELFDESTRUCTto not delete all storage keys, and to use a special value in the account nonce to signaldeactivatedaccounts. Because the semantics of revival change (storage keys may exists), we also rename the instruction toDEACTIVATE.", "Change SELFDESTRUCT to not delete storage keys and use a special value in the account nonce to signal deactivation": "ChangeSELFDESTRUCTto not delete all storage keys, and to use a special value in the account nonce to signaldeactivatedaccounts. Because the semantics of revival change (storage keys may exists), we also rename the instruction toDEACTIVATE.", "Abstract": "ChangeSELFDESTRUCTto not delete all storage keys, and to use a special value in the account nonce to signaldeactivatedaccounts. Because the semantics of revival change (storage keys may exists), we also rename the instruction toDEACTIVATE.", "Motivation": "TheSELFDESTRUCTinstruction currently has a fixed price, but is unbounded in terms of how many storage/account changes it performs (it needs to delete all keys). This has been an outstanding concern for some time.", "Specification": "There have been various proposals of removingSELFDESTRUCTand many would just outright remove the deletion capability. This breaks certain usage patterns, which thedeactivationoption leaves intact, albeit with minor changes. This only affectsnewlydeployed code, and not existing one.", "Rationale": "There have been various proposals of removingSELFDESTRUCTand many would just outright remove the deletion capability. This breaks certain usage patterns, which thedeactivationoption leaves intact, albeit with minor changes. This only affectsnewlydeployed code, and not existing one.", "Backwards Compatibility": "This EIP requires a protocol upgrade, since it modifies consensus rules. The further restriction of nonce should not have an effect on accounts, as2^64-2is an unfeasibly high limit.", "Security Considerations": "The new behaviour of preserving storage has a potential effect on security. Contract authors must be aware and design contracts accordingly. There may be an effect on existing deployed code performing autonomous destruction and revival.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- deactivate: Replaces SELFDESTRUCT, keeping the account\u2019s storage and marking the account as deactivated by setting its nonce to 2^64-1, while transferring the balance and leaving the option to reuse the account via CREATE2.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6188, "url": "https://eips.ethereum.org/EIPS/eip-6188", "title": "Nonce Cap", "authors": ["Gavin John\u00a0(", "@Pandapip1", ")"], "sections": {"EIP-6188: Nonce Cap": "This EIP caps the nonce at2^64-2, reserving it for contracts with unusual behavior, as defined in other EIPs.", "Caps the nonce at 2^64-2": "This EIP caps the nonce at2^64-2, reserving it for contracts with unusual behavior, as defined in other EIPs.", "Abstract": "This EIP caps the nonce at2^64-2, reserving it for contracts with unusual behavior, as defined in other EIPs.", "Motivation": "This EIP is not terribly useful on its own, as it adds additional computation without any useful side effects. However, it can be used by other EIPs.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "EOA Transactions": "The nonce of a transaction originating from an EOA MUST be less than2^64-2. If the nonce is either2^64-1or2^64-2, the transaction MUST be invalid.", "CREATEandCREATE2": "If a nonce would be incremented to2^64-1byCREATEorCREATE2, it is instead set to2^64-2.2^64-1is reserved for alias or other special contracts.", "Rationale": "Capping a nonce allows for contracts with special properties to be created, with their functionality based on their contract code. As such, only one nonce needs to be reserved.", "Backwards Compatibility": "This EIP requires a protocol upgrade, since it modifies consensus rules. The further restriction of nonce should not have an effect on accounts, as reaching a nonce of2^64-2is difficult.", "Security Considerations": "As it is not feasible for contract accounts to get to the nonce limit, any potential problems with opcodes that depend on the value of an account\u2019s nonce can be safely ignored.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- nonce cap: Caps account nonce values at 2^64-2, reserving higher values for special contract functionality defined in other EIPs.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6189, "url": "https://eips.ethereum.org/EIPS/eip-6189", "title": "Alias Contracts", "authors": ["Gavin John\u00a0(", "@Pandapip1", ")"], "sections": {"EIP-6189: Alias Contracts": "This EIP allows contracts to be turned into \u201calias contracts\u201d using a magic nonce. Alias contracts automatically forward calls to other contracts.", "Allows the creation of contracts that forward calls to other contracts": "This EIP allows contracts to be turned into \u201calias contracts\u201d using a magic nonce. Alias contracts automatically forward calls to other contracts.", "Abstract": "This EIP allows contracts to be turned into \u201calias contracts\u201d using a magic nonce. Alias contracts automatically forward calls to other contracts.", "Motivation": "This EIP is not terribly useful on its own, as it adds additional computation and gas costs without any useful side effects. However, in conjunction withEIP-6190, it can be used to make SELFDESTRUCT compatible with Verkle trees.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Definitions": "A contract is an alias contract if its nonce is2^64-1, and its contract code is equal to0x1.", "Prerequisites": "EIP-6188MUST be used to protect the magic nonce value of2^64-1.", "Opcode Changes": "The \u201ccallee\u201d refers to the account that is being called or being paid.", "Transfers to the zero address": "Transfers to the zero address continue to have the same effect as theCREATEopcode, and will cost extra gas as discussed in theCREATEandCREATE2section.", "Transaction Validity": "The \u201corigin\u201d refers to the account that sent the transaction to be validated.", "RPC Endpoint Changes": "Theeth_getStorageAtRPC endpoint must error if the target contract has a contract code of0x1and a nonce of2^64-1.", "Rationale": "The additional gas cost of25represents the cost of fetching the nonce and comparing it to the given value.", "Backwards Compatibility": "This EIP requires a protocol upgrade, since it modifies consensus rules. No existing contracts should be affected, as they will not have a nonce of2^64-1, nor will they have the contract code0x1.", "Security Considerations": "The additional gas costs may cause potential DoS attacks if they access an arbitrary contract\u2019s data or make frequent contract deactivations. Contract authors must be aware and design contracts accordingly. There may be an effect on existing deployed code performing autonomous destruction and revival.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- alias contracts: Introduces alias contracts, where a contract with nonce 2^64-1 forwards all calls to another contract, simplifying contract forwarding mechanisms."}
{"eip": 6190, "url": "https://eips.ethereum.org/EIPS/eip-6190", "title": "Verkle-compatible SELFDESTRUCT", "authors": ["Gavin John\u00a0(", "@Pandapip1", ")"], "sections": {"EIP-6190: Verkle-compatible SELFDESTRUCT": "ChangesSELFDESTRUCTto only cause a finite number of state changes.", "Changes SELFDESTRUCT to only cause a finite number of state changes": "ChangesSELFDESTRUCTto only cause a finite number of state changes.", "Abstract": "ChangesSELFDESTRUCTto only cause a finite number of state changes.", "Motivation": "TheSELFDESTRUCTinstruction has a fixed price, but is unbounded in storage/account changes (it needs to delete all keys). This has been an outstanding concern for some time.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Prerequisites": "EIP-6188andEIP-6189must be used for this EIP to function correctly.", "SELFDESTRUCTBehaviour": "Instead of destroying the contract at the end of the transaction, instead, the following will occur at the end of the transaction in which it is invoked:", "Gas Cost ofSELFDESTRUCT": "The base gas cost ofSELFDESTRUCTis set to5000. The gas cost ofSELFDESTRUCTis increased by5000for each alias contract that forwarded to the contract being self-destructed. Finally, theEIP-2929gas cost increase is applied.", "Rationale": "This EIP is designed to be a step towards supportingSELFDESTRUCTin Verkle trees while making the minimum amount of changes.", "Backwards Compatibility": "This EIP requires a protocol upgrade, since it modifies consensus rules.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- verkle-compatible selfdestruct: Modifies SELFDESTRUCT to make it compatible with Verkle trees by setting the contract to an alias contract instead of deleting all its state.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6475, "url": "https://eips.ethereum.org/EIPS/eip-6475", "title": "SSZ Optional", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Zahary Karadjov\u00a0(", "@zah", ")"], "sections": {"EIP-6475: SSZ Optional": "This EIP introduces a newSimple Serialize (SSZ) typeto representOptional[T]values.", "New SSZ type to represent optional values": "This EIP introduces a newSimple Serialize (SSZ) typeto representOptional[T]values.", "Abstract": "This EIP introduces a newSimple Serialize (SSZ) typeto representOptional[T]values.", "Motivation": "Optional values are currently only representable in SSZ using workarounds. Adding proper support provides these benefits:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Type definition": "Optional[T]is defined as a type that can represent:", "Default value": "The default value ofOptional[T]isNone.", "Serialization": "The deserialization of anOptional[T]depends on the input length:", "Deserialization": "The deserialization of anOptional[T]depends on the input length:", "Merkleization": "AnOptional[T]is merkleized as aList[T, 1].", "Rationale": "Union[None, T]leaves ambiguity about the intention whether the type may be extended in the future, i.e.,Union[None, T, U].", "Why notUnion[None, T]?": "Union[None, T]leaves ambiguity about the intention whether the type may be extended in the future, i.e.,Union[None, T, U].", "Why notList[T, 1]?": "The serialization is less compact for variable-lengthT, due to the extra offset table at the beginning of the list to indicate the list length.", "Backwards Compatibility": "Union[None, T]andList[T, 1]workarounds are not used at this time to representOptional[T].", "Test Cases": "SeeEIP assets.", "Reference Implementation": "None", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- ssz optional: Introduces the Optional[T] type in SSZ, allowing compact serialization for optional values without using workaround types like Union.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6810, "url": "https://eips.ethereum.org/EIPS/eip-6810", "title": "Ex Post Facto Cascading Revert", "authors": ["William Morriss\u00a0(", "@wjmelements", ")"], "sections": {"EIP-6810: Ex Post Facto Cascading Revert": "A new transaction type reverts one of a sender\u2019s prior transactions, and other transactions dependent on that state, recursively.", "Allow transactions to be reversed after confirmation": "A new transaction type reverts one of a sender\u2019s prior transactions, and other transactions dependent on that state, recursively.", "Abstract": "A new transaction type reverts one of a sender\u2019s prior transactions, and other transactions dependent on that state, recursively.", "Motivation": "While Ethereum has the capability of reversible transactions through smart contracts, instant settlement is the default.\nBut sometimes users make mistakes.\nMost mistakes are discovered quickly.\nHowever, once the transaction is confirmed, it is settled.\nThere are many use cases for reverting settled transactions.\nSome of the most-common mistakes are listed below.", "Specification": "A newEIP-2718transaction is introduced withTransactionType0x5a.\nTheEIP-2718TransactionPayloadfor this transaction isrlp([chainId, nonce, revertNonce, budget, signatureYParity, signatureR, signatureS]).\nThesignatureYParity, signatureR, signatureSelements of this transaction represent a secp256k1 signature overkeccak256(0x5a || rlp([chainId, nonce, revertNonce, budget])).\nTheEIP-2718ReceiptPayloadfor this transaction isrlp([status, budgetUsed, removedLogsBloom, [newReceiptPayloads]]), wherenewReceiptPayloadsis a sequential array of the updated receipts of all reverted transactions.", "Parameters": "A newEIP-2718transaction is introduced withTransactionType0x5a.\nTheEIP-2718TransactionPayloadfor this transaction isrlp([chainId, nonce, revertNonce, budget, signatureYParity, signatureR, signatureS]).\nThesignatureYParity, signatureR, signatureSelements of this transaction represent a secp256k1 signature overkeccak256(0x5a || rlp([chainId, nonce, revertNonce, budget])).\nTheEIP-2718ReceiptPayloadfor this transaction isrlp([status, budgetUsed, removedLogsBloom, [newReceiptPayloads]]), wherenewReceiptPayloadsis a sequential array of the updated receipts of all reverted transactions.", "Block gas limit": "A transaction of type0x5ashall be the only transaction in its block.", "Cascading revert operation": "A transaction fee budget is initialized to the value specified bybudget, denominated in ether.\nThis budget is the transaction fee for this type of transaction.\nReverted transaction fees are refunded from this budget.\nShould the budget be insufficient, the Ex Post Facto Cascading Revert transaction fails and the entire budget is paid to theCOINBASEspecified in the block header.\nOtherwise, the remainder of the budget after all transactions are reverted is paid to theCOINBASEaccount.", "Snap sync": "Due to the large amount of state that may be modified by such a transaction, slower clients should use snap sync to load the new state.", "Rationale": "The transaction must fill the entire block to prevent MEV attacks.", "Backwards Compatibility": "If we find any backwards compatibility issue we can maybe reverse those transactions.\nIf that doesn\u2019t work idk maybe need another hard fork.", "Test Cases": "Seems simple enough.\nTODO this later; should only take a few hours, tops.", "Reference Implementation": "Seems simple enough.\nTODO this later; should only take a few hours, tops.", "Security Considerations": "This specification has been audited by Illinois Senator Robert Peters.\nNo exploits were found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- ex post facto cascading revert: Introduces a transaction type that can revert a sender\u2019s previous transactions, along with any subsequent dependent transactions, by cascading state reversion.\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6811, "url": "https://eips.ethereum.org/EIPS/eip-6811", "title": "To The Moon\u201410 Minute Blocks", "authors": ["Pandapip1\u00a0(", "@Pandapip1", ")"], "sections": {"EIP-6811: To The Moon\u201410 Minute Blocks": "This EIP makes a minimal number of changes to allow Ethereum to be used on the moon and other potentially habitable bodies in Earth\u2019s solar system. It changes the time between blocks, the per-block validator reward, and the number of blocks per epoch.", "Increases the block time to facilitate finality over cosmic distances": "This EIP makes a minimal number of changes to allow Ethereum to be used on the moon and other potentially habitable bodies in Earth\u2019s solar system. It changes the time between blocks, the per-block validator reward, and the number of blocks per epoch.", "Abstract": "This EIP makes a minimal number of changes to allow Ethereum to be used on the moon and other potentially habitable bodies in Earth\u2019s solar system. It changes the time between blocks, the per-block validator reward, and the number of blocks per epoch.", "Motivation": "It is impossible for today\u2019s Ethereum to literally \u201cgo to the moon\u201d due to a limitation in the protocol: the block length. Should validators attempt to validate on the surface of the moon, they would find that the ~1.25 second communication delay (caused by the speed of light) might cause issues with synchronization, considering the 12-second timer between blocks. The validators would eventually be ejected on the terrestrial chain after leaking. If however a substantial number of validators are displaced (think 1/3), they might follow their own fork and would eventually eject the terrestrial to finalize their own chain.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "Many applications expect mainnet transactions to be included in a short amount of time. This would clearly no longer be the case. Such applications should switch to planetary rollups. Syncing rollups across heavenly bodies is outside the scope of this proposal.", "Backwards Compatibility": "Many applications expect mainnet transactions to be included in a short amount of time. This would clearly no longer be the case. Such applications should switch to planetary rollups. Syncing rollups across heavenly bodies is outside the scope of this proposal.", "Test Cases": "TODO.", "Security Considerations": "Definitely needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6873, "url": "https://eips.ethereum.org/EIPS/eip-6873", "title": "Preimage retention", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")"], "sections": {"EIP-6873: Preimage retention": "Enforce preimage collection by every node on the network from the fork preceding the verge, up to the fork. This is needed in case each node is responsible for their own conversion.", "Execution clients must retain the preimages of addresses and slots accessed between the fork preceding the verge, and the verge itself.": "Enforce preimage collection by every node on the network from the fork preceding the verge, up to the fork. This is needed in case each node is responsible for their own conversion.", "Abstract": "Enforce preimage collection by every node on the network from the fork preceding the verge, up to the fork. This is needed in case each node is responsible for their own conversion.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "Switching to verkle trees require a complete rehashing of all tree keys. Most execution clients store all keys hashed, without their preimages, which as the time of print take up 70GB on mainnet. In order to make these preimages available to everyone, the following course of action are available to each user:", "Backwards Compatibility": "No backward compatibility issues found.", "Reference Implementation": "All clients already implement preimage retention, at least as an option.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- preimage retention: Requires execution layer (EL) clients to store the preimages of addresses and slot hashes produced between a fork preceding the verge and the verge itself, ensuring preimage availability for the transition to Verkle trees.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6914, "url": "https://eips.ethereum.org/EIPS/eip-6914", "title": "Reuse Withdrawn Validator Indices", "authors": ["Lion\u00a0(", "@dapplion", ")", "Danny Ryan\u00a0(", "@djrtwo", ")"], "sections": {"EIP-6914: Reuse Withdrawn Validator Indices": "Reuse fully withdrawn validator indices after a sufficient safe-to-reuse period has passed to eliminate the unbounded growth of the beacon chain validator list as the validator set churns.", "Reuse fully withdrawn and safe to reuse validator indices for new beacon chain deposits.": "Reuse fully withdrawn validator indices after a sufficient safe-to-reuse period has passed to eliminate the unbounded growth of the beacon chain validator list as the validator set churns.", "Abstract": "Reuse fully withdrawn validator indices after a sufficient safe-to-reuse period has passed to eliminate the unbounded growth of the beacon chain validator list as the validator set churns.", "Motivation": "The beacon chain maintains a list of validators and a separate list of balances associated with each validator. When a new deposit for a new validator occurs, the current mechanism only appends, rather than reusing previously fully withdrawn validator indices. As validators fully withdraw and new validators enter, this means the two lists will grow unbounded.", "Specification": "The configuration values and mechanics of the specification can be found in theConsensus Layer specs.", "Consensus Layer": "The configuration values and mechanics of the specification can be found in theConsensus Layer specs.", "Execution Layer": "This specification does not require any changes to the Execution Layer.", "Rationale": "Thevalidatorsandbalanceslists are currently appended to each time a new Deposit for a new pubkey comes into the beacon chain. Due to the natural mechanics of stakers entering and leaving consensus over long time spans, these lists, thus the state size, will grow unbounded.", "Backwards Compatibility": "This is a backwards incompatible change to the Consensus Layer of Ethereum and must be scheduled with a hard fork.", "Test Cases": "Test cases are work-in-progress within the standard Consensus Layer tests.", "Security Considerations": "Validator indices cannot be immediately reused but instead must waitSAFE_EPOCHS_TO_REUSE_INDEXepochs to ensure that attestations cannot be \u201cpoisoned\u201d with withdrawn validator signatures \u2013 thus non-slashable \u2013 for at least the weak subjectivity period.", "Details of attack": "Assume a 1/3 attacker. Attacker exits N validators on the honest chain, where N is a small fraction of the validator set. These validators leave the exit queue and are withdrawable within a few days. Now N new deposits come in and overwrite the validators and most importantly their pubkeys.", "Mitigation": "Not overwriting withdrawn validators forSAFE_EPOCHS_TO_REUSE_INDEXepochs (3x the max weak subjectivity period) ensures that attestations cannot be poisoned within the accountable safety security window.", "Alternative": "Note that ifAttesterSlashings included a list of pubkeys instead of validator indices, then this would not be an issue. However this would require more breaking changes and would increase the data requirement of anAttesterSlashing, the largest Consensus Layer data type by a factor of 6.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- reuse withdrawn validator indices: Reuses fully withdrawn validator indices after a safe-to-reuse period to prevent unbounded growth of the beacon chain validator list.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6968, "url": "https://eips.ethereum.org/EIPS/eip-6968", "title": "Contract Secured Revenue on an EVM based L2", "authors": ["Zak Cole\u00a0<", "zak@numbergroup.xyz", ">", "Zak Cole\u00a0(", "@zscole", ")", "Kevin Owocki\u00a0<", "kevin@supermodular.xyz", ">", "lightclient\u00a0(", "@lightclient", ")"], "sections": {"EIP-6968: Contract Secured Revenue on an EVM based L2": "Contract Secured Revenue (CSR) allows smart contract developers to claim a percentage of all transaction fees paid by users when interacting with their smart contracts.", "Contract Secured Revenue on an EVM based L2": "Contract Secured Revenue (CSR) allows smart contract developers to claim a percentage of all transaction fees paid by users when interacting with their smart contracts.", "Abstract": "Contract Secured Revenue (CSR) allows smart contract developers to claim a percentage of all transaction fees paid by users when interacting with their smart contracts.", "Motivation": "Using protocol rewards of an L1 to fund smart contract development would be a big change to the way the current market works.  This EIPdoes notadvocate for any changes to the existing Ethereum L1.", "Specification": "The currentEIP-1559fee behavior is modified so thatheader.base_fee_per_gas * REVENUE_SHARE_QUOTIENTper gas is reallocated proportionally, based on gas used, to each contract executed during the transaction.", "Parameters": "The currentEIP-1559fee behavior is modified so thatheader.base_fee_per_gas * REVENUE_SHARE_QUOTIENTper gas is reallocated proportionally, based on gas used, to each contract executed during the transaction.", "Fee Mechanism": "The currentEIP-1559fee behavior is modified so thatheader.base_fee_per_gas * REVENUE_SHARE_QUOTIENTper gas is reallocated proportionally, based on gas used, to each contract executed during the transaction.", "Rationale": "A simpler mechanism would be to send the full transaction revenue to thetovalue of the transaction. This, however, does not accurately reward the composition of many different smart contracts and applications. Additionally, it is not compatible with smart contract wallets which, by definition, are often the first destination of a transaction.", "Tracking Gas Proportionally": "A simpler mechanism would be to send the full transaction revenue to thetovalue of the transaction. This, however, does not accurately reward the composition of many different smart contracts and applications. Additionally, it is not compatible with smart contract wallets which, by definition, are often the first destination of a transaction.", "Ephemeral Revenue Recipient Mapping": "Constructing the revenue recipient mapping ephemerally during each transaction appears inefficient on the surface. This value is expected to be relatively static and even if it did need to change, the change could be facilitated by the recipient contract.", "Security Considerations": "Similar to EIP-1559, we must consider the effects this will have on block size. Depending on the method by which this is implemented, it could increase maximum block size in the event that a significant number of contracts opt-in to CSR.", "Increased Max Block Size/Complexity": "Similar to EIP-1559, we must consider the effects this will have on block size. Depending on the method by which this is implemented, it could increase maximum block size in the event that a significant number of contracts opt-in to CSR.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- contract secured revenue: Introduces Contract Secured Revenue (CSR) on EVM-based L2s, allowing smart contracts to claim a portion of transaction fees paid when users interact with them.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6988, "url": "https://eips.ethereum.org/EIPS/eip-6988", "title": "Elected block proposer has not been slashed", "authors": ["Mikhail Kalinin\u00a0(", "@mkalinin", ")"], "sections": {"EIP-6988: Elected block proposer has not been slashed": "Introduces a modification to the consensus layer specification which ensures that slashed validator cannot be elected as block proposer.", "Prevents a slashed validator from being elected as a block proposer": "Introduces a modification to the consensus layer specification which ensures that slashed validator cannot be elected as block proposer.", "Abstract": "Introduces a modification to the consensus layer specification which ensures that slashed validator cannot be elected as block proposer.", "Motivation": "A block proposed by a slashed validator is rejected by the corresponding validity check in thephase0/process_block_headerfunction as defined in the consensus layer specification.", "Specification": "Specification of the proposed change can be found in/_features/eip6988/beacon-chain.md.", "Rationale": "This function is modified to read a proposer index from a beacon state if a slot of a latest block header is the same as thestate.slot.", "Modifyingget_beacon_proposer_index": "This function is modified to read a proposer index from a beacon state if a slot of a latest block header is the same as thestate.slot.", "Backwards Compatibility": "This fix changes proposer election mechanism in a backwards incompatible way and requires a hard fork to be deployed.", "Test Cases": "The following test cases were added to cover this change:", "Reference Implementation": "Reference implementation is in the same place asSpecification.", "Security Considerations": "There are no observed security issues introduced by the proposed change.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7266, "url": "https://eips.ethereum.org/EIPS/eip-7266", "title": "Remove BLAKE2 compression precompile", "authors": ["Pascal Caversaccio\u00a0(", "@pcaversaccio", ")"], "sections": {"EIP-7266: Remove BLAKE2 compression precompile": "This EIP removes theblake2f(0x09) precompile by changing the precompile behaviour to result in an exceptional abort.", "Remove the blake2f (0x09) precompile by changing the precompile behaviour to result in an exceptional abort": "This EIP removes theblake2f(0x09) precompile by changing the precompile behaviour to result in an exceptional abort.", "Abstract": "This EIP removes theblake2f(0x09) precompile by changing the precompile behaviour to result in an exceptional abort.", "Motivation": "EIP-152has never capitalised on a real-world use case. This fact is clearly reflected in the number of times the address0x09has been invoked (numbers from the date this EIP was created):", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "The EVM should be optimised for simplicity and future-proofness. The original Yellow Paper states:these are so-called \u2018precompiled\u2019 contracts, meant as a preliminary piece of architecture that may later become native extensions. Considering that no use cases have been realised in the last 3.5 years, we can conclude that the precompileblake2f(0x09) will never transition into a native opcode. In that sense, the precompileblake2f(0x09) is an obsolete carry-along with no real-world traction and thus should be removed. This removal will simplify the EVM to the extent that it only consists of clear instructions with real-world use cases. Eventually, the precompileblake2f(0x09) can be safely used as a test run for the phase-out and removal of EVM functions.", "Backwards Compatibility": "This EIP requires a hard fork as it modifies the consensus rules. Note that very few applications are affected by this change and a lead time of 6-12 months can be considered sufficient.", "Security Considerations": "There are no known additional security considerations introduced by this change.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- remove blake2 compression precompile: Deprecates the blake2f (0x09) precompile by making calls to it result in an exceptional abort, as it has not seen significant use since its introduction.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7377, "url": "https://eips.ethereum.org/EIPS/eip-7377", "title": "Migration Transaction", "authors": ["lightclient\u00a0(", "@lightclient", ")", "Sam Wilson\u00a0(", "@samwilsn", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")"], "sections": {"EIP-7377: Migration Transaction": "Introduce a newEIP-2718transaction type with the format0x04 || rlp([chainId, nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit, codeAddr, storage, data, value, accessList, yParity, r, s])which sets the sending account\u2019scodefield in the state trie to thecodevalue atcodeAddrand applies the storage tuples to the sender\u2019s storage trie.", "Allow EOAs to send a one-time transaction which deploys code at their account.": "Introduce a newEIP-2718transaction type with the format0x04 || rlp([chainId, nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit, codeAddr, storage, data, value, accessList, yParity, r, s])which sets the sending account\u2019scodefield in the state trie to thecodevalue atcodeAddrand applies the storage tuples to the sender\u2019s storage trie.", "Abstract": "Introduce a newEIP-2718transaction type with the format0x04 || rlp([chainId, nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit, codeAddr, storage, data, value, accessList, yParity, r, s])which sets the sending account\u2019scodefield in the state trie to thecodevalue atcodeAddrand applies the storage tuples to the sender\u2019s storage trie.", "Motivation": "Smart contract wallets have long been touted as the solution to Ethereum\u2019s user experience woes. As early as 2015, there were proposals for allowing smart contracts to originate transactions in hopes that new users would flock to smart contract wallets to store their assets. So far, only a fraction of users have elected to do so.", "Specification": "At the fork blockX, introduce the migration transaction type.", "Migration Transaction": "The EIP-2718TransactionTypeis0x04and theTransactionPayloadisrlp([chainId, nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit, codeAddr, storage, data, value, accessList, yParity, r, s]).", "Rationale": "This transaction is only good for one-time use to migrate an EOA to a smart contract. It is designed to immediately call the deployed contract, which is at the sender\u2019s address, after deployment to allow the sender to do any kind of further processing.", "Notoaddress field": "This transaction is only good for one-time use to migrate an EOA to a smart contract. It is designed to immediately call the deployed contract, which is at the sender\u2019s address, after deployment to allow the sender to do any kind of further processing.", "Code pointer for deployment": "Naively, one could design the migration transaction to have a fieldcodeof typebytes. However, there would be substantial duplication of code calldata, since many users will want to deploy the exact same thing (often a wallet). Using a pointer instead acknowledges this overwhelming use case for the transaction type, and exploits it as an optimization.", "Cheaper storage": "Since the storage is guaranteed to be empty, there is no need to read before write. This means only 20,000 gas is needed to pay for theEIP-2200SSTORE_SET_GASvalue. This is a small discount to the normal cost of22,100, which isSSTORE_SET_GASplus theEIP-2929COLD_SLOAD_COSTof2100, because no load occurs.", "Intrinsic does not account for contract deployment": "This takes advantage of the fact that clients tend to store a single, unique copy of code; no matter the number of deployments. Therefore, the only operation here is changing a pointer in the state trie to the desired code.", "Manipulating transaction origin": "Many applications have a security checkcaller == originto verify the caller is an EOA. This is done to \u201cprotect\u201d assets. While it is usually more of a bandage than an actual fix, we attempt to placate these projects by modifying the origin of the transaction so the check will continue performing its duty.", "One-time migration": "There is no technical reason we couldn\u2019t allow EOAs to change their code at any time with this transaction type. The only inhibitor at the moment isEIP-3607which will cause migration transactions to be considered invalid if they come from an account with code already deployed. A functional reason for retaining this behavior though is that it makes it simpler to reason about contracts and their upgradability.", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "As with all sufficiently sophisticated account designs, if a user can be convinced to sign an arbitrary message, that message could be a migration transaction which is owned by a malicious actor instead of the user. This can generally be avoided if wallets treat these transactions withextremecare and create as much friction and verification as possible before completing the signature.", "Blind Signing": "As with all sufficiently sophisticated account designs, if a user can be convinced to sign an arbitrary message, that message could be a migration transaction which is owned by a malicious actor instead of the user. This can generally be avoided if wallets treat these transactions withextremecare and create as much friction and verification as possible before completing the signature.", "Onecrecover": "Applications standards such asERC-2612: Permit Extensionhave exploited the cryptographic relationship between EOA addresses and their private keys. Many tokens today support this extension, allowing EOAs to approve the transfer of fund from their account using only a signature. Although collisions between EOAs and contract accounts are considered unlikely andmaybe impossiblegiven today\u2019s computing power, this EIP would make it common place for private keys to exist for contract accounts. There are some considerations here regarding security:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- migration transaction: Introduces a transaction type allowing EOAs to migrate to smart contracts by deploying code at their own address and setting their storage, facilitating smart contract wallet adoption.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7378, "url": "https://eips.ethereum.org/EIPS/eip-7378", "title": "Add time-weighted averaging to the base fee", "authors": ["Guy Goren (@guy-goren)\u00a0<", "guy.nahsholim@gmail.com", ">"], "sections": {"EIP-7378: Add time-weighted averaging to the base fee": "This EIP proposes a new formula to update the base fee, derived fromEIP-1559. The existing base fee update formula,", "Using geometric weights to average past block sizes into consideration": "This EIP proposes a new formula to update the base fee, derived fromEIP-1559. The existing base fee update formula,", "Abstract": "This EIP proposes a new formula to update the base fee, derived fromEIP-1559. The existing base fee update formula,", "Motivation": "To reduce bribe motivation when the demand for blockspace is high (see Incentive Considerations section) and to reduce oscillations, thus, having a more stable fee setting mechanism.", "Specification": "$s[i]$ is replaced by $s_{\\textit{avg}}[i]$, where:", "Rationale": "An intuitive option for the Transaction Fee Mechanism (TFM) that adjusts supply and demand economically isFirst price auction, which is well known and studied. Nevertheless, the Ethereum network choice was to use EIP-1559 for the TFM (one stated reason was to try and simplify the fee estimation for users, and reduce the advantage of sophisticated users). In this proposal, our design goal is to improve the TFM (of EIP-1559) by mitigating known problems that it raises. It is important to note that these problems severity are in direct relation to the demand for block space, and currently only mildly impact the Ethereum network. If demand to use Ethereum increases, however, these problems are expected to exacerbate. We may want to prepare for this beforehand.", "Incentive Considerations": "The proposal is designed to improve the incentive compatibility of the TFM. Agame theoretic analysisshows that the current TFM, which is based on EIP-1559, encourages bribes.", "Backwards Compatibility": "This change requires a hard fork since the base fee is enforced (for blocks to be considered valid).", "Test Cases": "TBD", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7441, "url": "https://eips.ethereum.org/EIPS/eip-7441", "title": "Upgrade block proposer election to Whisk", "authors": ["George Kadianakis\u00a0(", "@asn-d6", ")", "Justin Drake\u00a0(", "@JustinDrake", ")", "dapplion\u00a0(", "@dapplion", ")"], "sections": {"EIP-7441: Upgrade block proposer election to Whisk": "Upgrades the block proposer election mechanism to Whisk, a single secret leader election (SSLE) protocol. Currently, block proposers are publicly known in advance, sufficiently to allow sequential DoS attacks that could disable Ethereum. This upgrade allows the next block proposer to remain secret until its block is published.", "Allow elected block proposers to remain private until block publishing, to prevent DoS attacks": "Upgrades the block proposer election mechanism to Whisk, a single secret leader election (SSLE) protocol. Currently, block proposers are publicly known in advance, sufficiently to allow sequential DoS attacks that could disable Ethereum. This upgrade allows the next block proposer to remain secret until its block is published.", "Abstract": "Upgrades the block proposer election mechanism to Whisk, a single secret leader election (SSLE) protocol. Currently, block proposers are publicly known in advance, sufficiently to allow sequential DoS attacks that could disable Ethereum. This upgrade allows the next block proposer to remain secret until its block is published.", "Motivation": "The beacon chain currently elects the next 32 block proposers at the beginning of each epoch. The results of this election are public and everyone gets to learn the identity of those future block proposers.", "Specification": "This requires no changes to the Execution Layer.", "Execution layer": "This requires no changes to the Execution Layer.", "Consensus layer": "The protocol can be summarized in the following concurrent steps:", "Rationale": "Whisk requires having one tracker(rG,krG)and one unique commitmentkGper validator. Both are updated only once on a validator\u2019s first proposal after the fork.", "Fields per validator": "Whisk requires having one tracker(rG,krG)and one unique commitmentkGper validator. Both are updated only once on a validator\u2019s first proposal after the fork.", "Identity binding": "Each tracker must be bound to a validator\u2019s identity to prevent multiple parties to claim the same proposer slot. Otherwise, it would allow proposers to sell their proposer slot, and cause fork-choice issues if two competing blocks appear.", "Alternative: non-single secret election": "Secret non-single leader election could be based on protocol engineering rather than cryptography, thus much simpler and cheaper than Whisk. However, it complicates the fork-choice and opens it up to potential MEV time-buying attacks, making it an unsuitable option at the time of writing.", "Alternative: network anonymity": "Privacy-preserving networking protocols like Dandelion or Dandelion++ increase the privacy of network participants but not sufficiently for Ethereum\u2019s use case.", "Backwards Compatibility": "This EIP introduces backward incompatible changes to the block validation rule set on the consensus layer and must be accompanied by a hard fork.", "Security Considerations": "The shuffling strategy is analyzed in a companion paper and considered sufficiently safe for Whisk\u2019s use case. The data and computational complexity of this EIP are significant but constant, thus does not open new DoS vectors.", "Anonymity set": "The anonymity set in Whisk is the set of 8,192 candidates that did not get selected as proposers. That count of validators corresponds to a smaller number of p2p nodes. Assuming a Pareto principle where \u201c20% of the nodes run 80% of the validators\u201d the anonymity corresponds to 2,108 nodes on average. A bigger candidate pool could make the shuffling strategy unsafe while shuffling more trackers per round would increase the cost of the ZK proofs.", "RANDAO biasing": "Whisk uses RANDAO in the candidate selection and proposer selection events, and is susceptible to potential RANDAO biasing attacks by malicious proposers. Whisk security could be made identical to the status quo by spreading the selection events over an entire shuffling period. However, status quo security is not ideal either and it would complicate the protocol further.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7543, "url": "https://eips.ethereum.org/EIPS/eip-7543", "title": "EVM arbitrary precision decimal math", "authors": ["1m1\u00a0(", "@1m1-github", ")"], "sections": {"EIP-7543: EVM arbitrary precision decimal math": "This EIP addsarbitrary precision decimal floatOPCODEs for arithmetic via DECADD, DECNEG, DECMUL, DECINV and expression of all elementary functions via DECEXP, DECLN, DECSIN. All decimal values upto the maximal precision allowed by a int256 coefficient and exponent are represented exactly, as c*10^q. All implemented algorithms converge for all inputs given enough precision, as chosen by the user. All calculations are deterministic and gas is precisely embedded bottom-up. Allowing arbitrary precision decimal elementary functions invites the worlds of mathematical finance, machine learning, science, digital art, games and others to Ethereum. The implementation is functional.", "This EIP adds OPCODEs to allow arbitrary precision decimal float calculation of all elementary functions with precise gas enumeration.": "This EIP addsarbitrary precision decimal floatOPCODEs for arithmetic via DECADD, DECNEG, DECMUL, DECINV and expression of all elementary functions via DECEXP, DECLN, DECSIN. All decimal values upto the maximal precision allowed by a int256 coefficient and exponent are represented exactly, as c*10^q. All implemented algorithms converge for all inputs given enough precision, as chosen by the user. All calculations are deterministic and gas is precisely embedded bottom-up. Allowing arbitrary precision decimal elementary functions invites the worlds of mathematical finance, machine learning, science, digital art, games and others to Ethereum. The implementation is functional.", "Abstract": "This EIP addsarbitrary precision decimal floatOPCODEs for arithmetic via DECADD, DECNEG, DECMUL, DECINV and expression of all elementary functions via DECEXP, DECLN, DECSIN. All decimal values upto the maximal precision allowed by a int256 coefficient and exponent are represented exactly, as c*10^q. All implemented algorithms converge for all inputs given enough precision, as chosen by the user. All calculations are deterministic and gas is precisely embedded bottom-up. Allowing arbitrary precision decimal elementary functions invites the worlds of mathematical finance, machine learning, science, digital art, games and others to Ethereum. The implementation is functional.", "Motivation": "Currently, to take a power, a^b, of non integer values, requires vast amounts of Solidity code.\nThe simplest task in trading e.g. is to convert volatilities from yearly to daily, which involves taking the 16th root.", "Why decimal?": "To represent a simple value like 0.1 in binary requires infinite many digits and is therefore not exactly represently in a finite binary machine. Decimal types are much closer to the vast majority of numerical calculations run by humans.", "eVm": "The EVM is a virtual machine and thereby not restricted by hardware. Usually, assembly languages provide OPCODES that are mimic the ability of hardware. In a virtual machine, we have no such limitations and nothing stops us from adding more complex OPCODEs, as long as fair gas is provided. At the same time, we do not want to clutter the OPCODEs library. EXP, LN and SIN are universal functions that open the path to: powers, trigonometry, integrals, differential equations, machine learning, digital art, etc.", "Specification": "A decimal is defined as", "Decimal": "A decimal is defined as", "OPCODE defs": "0xd0 DECADD a+b -> c    : (ac, aq, bc, bq, precision) -> (cc, cq)\n0xd1 DECNEG  -a -> b    : (ac, aq) -> (bc, bq)\n0xd2 DECMUL a*b -> c    : (ac, aq, bc, bq, precision) -> (cc, cq)\n0xd3 DECINV 1/a -> b    : (ac, aq, precision) -> (bc, bq)\n0xd4 DECEXP exp(a) -> b : (ac, aq, precision, steps) -> (bc, bq)\n0xd5 DECLN   ln(a) -> b : (ac, aq, precision, steps) -> (bc, bq)\n0xd6 DECSIN sin(a) -> b : (ac, aq, precision, steps) -> (bc, bq)", "Why these functions?": "The proposed functions (+,-,*,/,exp,ln,sin) form a small set that combined enable all calculation of all elementary functions, which includes the sets of sums, products, roots and compositions of finitely many polynomial, rational, trigonometric, hyperbolic, and exponential functions, including their inverse functions.", "DECNEG instead of DECSUB": "Negation is a more general operation vs subtraction. OPCODEs should be as fundamental as possible and as complex as desirable.\nFor the same reason, we have DECINV instead of DECDIV.", "DECEXP, DECSIN via Taylor series": "The Taylor series of exp and sin converge everywhere and fast. The error falls as fast as the factorial of steps.", "DECLN via continued fractions": "Ln converges fast using continued fractions within the interval ]0,2]. The implementation scales the input into this interval and scales the result back correctly.", "Rationale": "All the above OPCODEs are deterministic, hence the gas cost can be determined. At the same time, the calculations are complex and depend on the input.", "gas": "All the above OPCODEs are deterministic, hence the gas cost can be determined. At the same time, the calculations are complex and depend on the input.", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "../assets/eip-EVM+/decimal_float_test.go", "Reference Implementation": "The reference implementation is found in ../assets/eip-EVM+/decimal_float.go", "Security Considerations": "There are no security considerations, as long as numerical correctness is guaranteed and gas is collected fairly.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7545, "url": "https://eips.ethereum.org/EIPS/eip-7545", "title": "Verkle proof verification precompile", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")", "Diederik Loerakker\u00a0(", "@protolambda", ")"], "sections": {"EIP-7545: Verkle proof verification precompile": "This EIP proposes the addition of a precompiled contract to provide up-to-date state proof verification capabilities to smart contracts in a stateless Ethereum context.", "Add a precompile to help dapps verify verkle proofs": "This EIP proposes the addition of a precompiled contract to provide up-to-date state proof verification capabilities to smart contracts in a stateless Ethereum context.", "Abstract": "This EIP proposes the addition of a precompiled contract to provide up-to-date state proof verification capabilities to smart contracts in a stateless Ethereum context.", "Motivation": "The proposed proof systems for stateless Ethereum require an upgrade to many tools and applications, that need a simple path to keep their proving systems up-to-date, without having to develop and deploy new proving libraries each time another proof format must be supported.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Gas costs": "The precompile cost is:", "Rationale": "Stateless Ethereum relies on proofs using advanced mathematical concepts and tools from a fast-moving area of cryptography. As a result, a soft-fork approach is currently favored in the choice of the proof format: proofs are going to be distributed outside of consensus, and in the future, stateless clients will be able to chose their favorite proof format.", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "TODO", "Reference Implementation": "WIP", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- verkle proof verification precompile: Adds a precompiled contract for verifying verkle proofs in a stateless Ethereum context, supporting multiple proof formats.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7547, "url": "https://eips.ethereum.org/EIPS/eip-7547", "title": "Inclusion lists", "authors": ["mike\u00a0(", "@michaelneuder", ")", "Vitalik\u00a0(", "@vbuterin", ")", "Francesco\u00a0(", "@fradamt", ")", "Terence\u00a0(", "@terencechain", ")", "potuz\u00a0(", "@potuz", ")", "Manav\u00a0(", "@manav2401", ")"], "sections": {"EIP-7547: Inclusion lists": "Censorship resistance is a core value proposition of blockchains. Inclusion lists aim to provide a mechanism to improve the censorship resistance of Ethereum by allowing proposers to specify a set of transactions that must be promptly included for subsequent blocks to be considered valid.", "Add an inclusion list mechanism to allow forced transaction inclusion.": "Censorship resistance is a core value proposition of blockchains. Inclusion lists aim to provide a mechanism to improve the censorship resistance of Ethereum by allowing proposers to specify a set of transactions that must be promptly included for subsequent blocks to be considered valid.", "Abstract": "Censorship resistance is a core value proposition of blockchains. Inclusion lists aim to provide a mechanism to improve the censorship resistance of Ethereum by allowing proposers to specify a set of transactions that must be promptly included for subsequent blocks to be considered valid.", "Motivation": "Since the merge, validators have started outsourcing almost all block production to a specialized set of builders who compete to extract the most MEV (this is commonly referred to as Proposer-Builder Separation). As of October 2023, nearly 95% of blocks are built by builders rather than the proposer. While it is great that all proposers have access to competitive blocks through themev-boostecosystem, a major downside of externally built blocks is the fact that the builders ultimately decide what transactions to include or exclude. Without any forced transaction inclusion mechanism, the proposer is faced with a difficult choice: they either have no say on the transactions that get included, or they build the block locally (thus have the final say on transactions) and sacrifice some MEV rewards.", "Specification": "slot Nproposal:", "Constants": "slot Nproposal:", "Consensus layer": "slot Nproposal:", "Execution layer": "We consider a few design decisions present in this EIP.", "Rationale": "We consider a few design decisions present in this EIP.", "Backwards Compatibility": "This EIP introduces backward incompatible changes to the block validation rule set on the consensus layer and must be accompanied by a hard fork. These changes do not break anything related to current user activity and experience.", "Security Considerations": "The main potential issue is around the incentivization of the inclusion lists. If theslot Nproposer constructs an inclusion list that negatively impacts the rewards of theslot N+1proposer, theslot N+1proposer may attempt to bribe theslot Nproposer to publish an empty list. This isn\u2019t a direct attack on the protocol, but rather a profit-sharing mechanism by which the inclusion list would go unutilized. It seems likely these commitment games could be played no matter the censorship resistance scheme in place, but this remains an active area of research.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- inclusion lists: Introduces a mechanism allowing proposers to specify transactions that must be included in subsequent blocks, improving censorship resistance.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding."}
{"eip": 7591, "url": "https://eips.ethereum.org/EIPS/eip-7591", "title": "BLS signed transactions", "authors": ["Marius van der Wijden\u00a0(", "@MariusVanDerWijden", ")"], "sections": {"EIP-7591: BLS signed transactions": "This EIP introduces a newEIP-2718transaction type that is signed with BLS signatures.", "Introduces a new transaction type signed with BLS signatures": "This EIP introduces a newEIP-2718transaction type that is signed with BLS signatures.", "Abstract": "This EIP introduces a newEIP-2718transaction type that is signed with BLS signatures.", "Motivation": "The BLS signature scheme allows for easy aggregation and verification of aggregated signatures.\nIf a substantial number of transactions on mainnet were BLS signed transactions, we can aggregate signatures in a block and batch-verify them.\nThis will reduce growth of the chain history.", "Specification": "BLS_TX_TYPE = Bytes1(0x04)", "Transaction Type": "The transaction type will have the following format:", "Header changes": "The block header will be amended with theaggregated_sigfield, containing an aggregated signature of all BLS transactions in the block.", "Block changes": "The block building algorithm needs to be changed in order to built the aggregated signature of all BLS signed transactions in the block. \nAll transactions in the block will be added without the signature field set.", "Rationale": "Removing the ECDSA signature from a transaction saves 65 bytes. The BLS public key is 48 bytes, the aggregated signature is 96 bytes.\nThus we save-96 + (65-48)* #transactionsbytes per block. With ~7000 blocks per day, 1.000.000 transactions per day, the average block contains roughly 150 transactions.", "Backwards Compatibility": "This EIP introduces backward incompatible changes to the block validation rule set on the execution layer and introduces a new transaction type and a new header field. Thus a hardfork is needed.", "Security Considerations": "The messages signed via BLS are distinct (no hash collisions on the txhash), thus the aggregation is secure even without a proof-of-possession.\nThe public keys are not distinct which is not a problem in BLS.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- bls signed transactions: Introduces a new transaction type signed with BLS signatures, allowing for the aggregation of signatures and reducing chain history growth.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7609, "url": "https://eips.ethereum.org/EIPS/eip-7609", "title": "Decrease base cost of TLOAD/TSTORE", "authors": ["Charles Cooper\u00a0(", "@charles-cooper", ")", "James Prestwich\u00a0(", "@prestwich", ")", "brockelmore\u00a0(", "@brockelmore", ")"], "sections": {"EIP-7609: Decrease base cost of TLOAD/TSTORE": "Decrease the base cost of TLOAD/TSTORE while introducing a superlinear pricing model. This increases the efficiency of TLOAD/TSTORE for common use cases, while providing a pricing model to prevent DoS vectors.", "Improve the efficiency of TLOAD/TSTORE by decreasing the base cost and introducing a superlinear pricing model.": "Decrease the base cost of TLOAD/TSTORE while introducing a superlinear pricing model. This increases the efficiency of TLOAD/TSTORE for common use cases, while providing a pricing model to prevent DoS vectors.", "Abstract": "Decrease the base cost of TLOAD/TSTORE while introducing a superlinear pricing model. This increases the efficiency of TLOAD/TSTORE for common use cases, while providing a pricing model to prevent DoS vectors.", "Motivation": "EIP-1153introduces a new storage region, termed \u201ctransient storage\u201d. It behaves like storage (word-addressed and persists between call frames), but unlike storage it is wiped at the end of each transaction. During development of EIP-1153, the pricing was set to be the same as warm storage loads and stores. This was for two reasons: conceptual simplicity of the EIP, and it also addressed concerns about two related DoS vectors: being able to allocate too much transient storage, and the cost of rolling back state in the case of reverts.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "In benchmarking,TLOADwas found to cost a similar amount of CPU time asMUL, whileTSTOREwas found to cost about 1.5x that. The valuesG_lowandG_midwere therefore chosen forTLOADandTSTORE, respectively.", "Gas": "In benchmarking,TLOADwas found to cost a similar amount of CPU time asMUL, whileTSTOREwas found to cost about 1.5x that. The valuesG_lowandG_midwere therefore chosen forTLOADandTSTORE, respectively.", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "The maximum number of transient slots which can be allocated on a single contract given 30m gas is approximately 7,739 (solution tox(x-1)/2*1 + 8*x = 30_000_000), which totals 248KB.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- decrease base cost of tload/tstore: Reduces the base gas cost for TLOAD and TSTORE and introduces a superlinear pricing model, improving the efficiency of transient storage.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- revert: All calls to this opcode must emit a log with revert data."}
{"eip": 7637, "url": "https://eips.ethereum.org/EIPS/eip-7637", "title": "Optimize EOA EXTCODEHASH", "authors": ["Jame\u00a0(", "@ZWJKFLC", ")"], "sections": {"EIP-7637: Optimize EOA EXTCODEHASH": "This proposal is an optimization forEIP-1052,\nFor addresses with a balance, but without code, the codehash should still be0x.", "Modify the output value of EXTCODEHASH for EOA accounts to `0x`": "This proposal is an optimization forEIP-1052,\nFor addresses with a balance, but without code, the codehash should still be0x.", "Abstract": "This proposal is an optimization forEIP-1052,\nFor addresses with a balance, but without code, the codehash should still be0x.", "Motivation": "EIP-1052 was proposed to save gas fees. However, due to some flaws in the set specifications, in actual applications, due to safety concerns, they will not actually be used. In order for EIP-1052 to be truly useful, it should be optimized.", "Specification": "The behaviour ofEXTCODEHASHis changed in the following way:", "Rationale": "EIP-1052 In order to include the function ofBALANCE, let theEXTCODEHASHof the address without balance be0x, and theEXTCODEHASHof the address with balance bekeccak256(\"\").", "Backwards Compatibility": "Using codehash to determine whether a non-contract address has a balance will not be available", "Reference Implementation": "Code reference for execution-specs", "Security Considerations": "Using codehash to determine whether a non-contract address has a balance will not be available", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- optimize eoa extcodehash: Optimizes the output of EXTCODEHASH for EOAs by returning 0x when an address has no code but has a balance, improving gas efficiency.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7643, "url": "https://eips.ethereum.org/EIPS/eip-7643", "title": "History accumulator for pre-PoS data", "authors": ["lightclient\u00a0(", "@lightclient", ")", "kdeme\u00a0(", "@kdeme", ")"], "sections": {"EIP-7643: History accumulator for pre-PoS data": "Defines an SSZ object for accumulating all pre-PoS data and commit to the\nhistorical hashes accumulator\u2019s root0xec8e040fd6c557b41ca8ddd38f7e9d58a9281918dc92bdb72342a38fb085e701.", "Commit to a single root for all block data before the merge.": "Defines an SSZ object for accumulating all pre-PoS data and commit to the\nhistorical hashes accumulator\u2019s root0xec8e040fd6c557b41ca8ddd38f7e9d58a9281918dc92bdb72342a38fb085e701.", "Abstract": "Defines an SSZ object for accumulating all pre-PoS data and commit to the\nhistorical hashes accumulator\u2019s root0xec8e040fd6c557b41ca8ddd38f7e9d58a9281918dc92bdb72342a38fb085e701.", "Motivation": "There are two main uses we consider for the historical hashes accumulator:", "Specification": "The historical hashes accumulator commits to the set of pre-merge headers and their\nassociated total difficulty. The format for this data is defined as:", "Historical Hashes Accumulator": "The historical hashes accumulator commits to the set of pre-merge headers and their\nassociated total difficulty. The format for this data is defined as:", "Pre-PoS Root": "The hash tree root ofHistoricalHashesAccumulatorfor data before block 15537394 is0xec8e040fd6c557b41ca8ddd38f7e9d58a9281918dc92bdb72342a38fb085e701.", "Rationale": "The total difficulty allowed so that clients may return the value for specific\nJSON-RPC methods which support it. It is also useful for verifying the TTD of\nthe final proof-of-work block.", "Inclusion of total difficulty": "The total difficulty allowed so that clients may return the value for specific\nJSON-RPC methods which support it. It is also useful for verifying the TTD of\nthe final proof-of-work block.", "Backwards Compatibility": "n/a", "Test Cases": "The accumulator root should be verified by community members before being\naccepted. Although the accumulator root can be verified at anytime by anyone in\nthe future, it is likely clients and other tooling will begin relying on proofs\nagainst the aforementioned root in the near term.", "Security Considerations": "The accumulator root should be verified by community members before being\naccepted. Although the accumulator root can be verified at anytime by anyone in\nthe future, it is likely clients and other tooling will begin relying on proofs\nagainst the aforementioned root in the near term.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- historical hashes accumulator: A structure committing to all pre-merge headers and their associated total difficulty, facilitating light client verification of historical block data.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7645, "url": "https://eips.ethereum.org/EIPS/eip-7645", "title": "Alias ORIGIN to SENDER", "authors": ["Cyrus Adkisson\u00a0(", "@cyrusadkisson", ")", "Eirik Ulvers\u00f8y\u00a0(", "@EirikUlversoy", ")"], "sections": {"EIP-7645: Alias ORIGIN to SENDER": "This EIP proposes aliasing the ORIGIN opcode to the SENDER opcode within the Ethereum Virtual Machine (EVM). The purpose of this change is to move Ethereum closer to enabling account abstraction by harmonizing the treatment of externally owned accounts (EOAs) and smart contracts and to address the security concerns associated with the use of ORIGIN that have and will continue to surface in all or most account abstraction proposals.", "Eliminate ORIGIN tech debt to lay groundwork for account abstraction and close security holes": "This EIP proposes aliasing the ORIGIN opcode to the SENDER opcode within the Ethereum Virtual Machine (EVM). The purpose of this change is to move Ethereum closer to enabling account abstraction by harmonizing the treatment of externally owned accounts (EOAs) and smart contracts and to address the security concerns associated with the use of ORIGIN that have and will continue to surface in all or most account abstraction proposals.", "Abstract": "This EIP proposes aliasing the ORIGIN opcode to the SENDER opcode within the Ethereum Virtual Machine (EVM). The purpose of this change is to move Ethereum closer to enabling account abstraction by harmonizing the treatment of externally owned accounts (EOAs) and smart contracts and to address the security concerns associated with the use of ORIGIN that have and will continue to surface in all or most account abstraction proposals.", "Motivation": "The ORIGIN opcode in Ethereum returns the address of the account that started the transaction chain, differing from the SENDER (or CALLER) opcode, which returns the address of the direct caller. The use of ORIGIN has been discouraged and deemed deprecated since mid-2016 due to the security problems it introduces, such as susceptibility to phishing attacks and other vulnerabilities where the distinction between the original sender and the immediate sender can be exploited.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "The rationale behind aliasing ORIGIN to SENDER is to:", "Backwards Compatibility": "This change is not fully backwards compatible. Contracts relying on the distinction between ORIGIN and SENDER for logic or security will be affected. However, given the longstanding discouragement of ORIGIN\u2019s use, the minimal impact of the change, the widespread desire for a future account abstraction solution in the EVM, and the reality that any AA solution will ultimately have to deal with ORIGIN one way or the other, this incompatibility is considered a necessary step forward for Ethereum\u2019s development.", "Test Cases": "For each CALL, STATICCALL, DELEGATECALL, CALLCODE:", "Security Considerations": "By aliasing ORIGIN to SENDER, the specific security vulnerabilities associated with the ORIGIN opcode are addressed and eliminated. Outside the scope of this EIP, it may be wise to ban all use of ORIGIN to eliminate further misunderstanding or misuse. This can be done via tooling changes outside the EVM or, inside the EVM, reverting smart contract deployments that use ORIGIN.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- alias origin to sender: Aliases the ORIGIN opcode to the SENDER opcode, eliminating distinctions between the original transaction initiator and the immediate sender."}
{"eip": 7650, "url": "https://eips.ethereum.org/EIPS/eip-7650", "title": "Programmable access lists", "authors": ["Qi Zhou\u00a0(", "@qizhou", ")", "Zhiqiang Xu\u00a0(", "@zhiqiangxu", ")"], "sections": {"EIP-7650: Programmable access lists": "We introduce a new precompiled contract namedprefetch, which accepts anaccessList.", "Add a precompiled contract that add access lists programmatically": "We introduce a new precompiled contract namedprefetch, which accepts anaccessList.", "Abstract": "We introduce a new precompiled contract namedprefetch, which accepts anaccessList.", "Motivation": "The primary goal of this EIP is to enhance EIP-2930 by enabling contracts to add access lists programmatically. The advantage of implementing this precompile within a contract is the sustained reduction in gas costs for data access operations, leveraging the concurrent computing and IOs that most nodes have.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Parameters": "As ofFORK_BLOCK_NUMBER, a new precompile is deployed atPREFETCH_PRECOMPILE_ADDRESS.  The encoding of the precompile input is the following:", "Examples": "Using UniswapV2swap()function as an example:", "Rationale": "Similar to EIP-2930, we encourage contract developers to use theprefetchprecompile as much as possible, especially assuming the nodes have some decent concurrent capabilities (e.g., some cores and IO bandwidth).", "Charging less for accesses in the access list": "Similar to EIP-2930, we encourage contract developers to use theprefetchprecompile as much as possible, especially assuming the nodes have some decent concurrent capabilities (e.g., some cores and IO bandwidth).", "Allowing duplicates": "Similar to EIP-2930, we allow duplicates in the list to maximize simplicity.", "No storage keys for external contract": "Unlike EIP-2930, theprefetchprecompile only accepts local storage keys and addresses. Prefetching the data of the storage keys of external contracts assumes that the contract knows the storage layout of an external contract, which may not be a good practice. To better employ the concurrency of a node, the precompile may accept a list of static calls of external contracts together with the calldata.  This work may be done in the future EIP.", "Backwards Compatibility": "If the EIP is not yet implemented, a contract calling the precompile should result in no operation.", "Security Considerations": "No security considerations were found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- precompile_address: The address of the new precompiled contract for deactivating or reactivating a delegated EOA's private key.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7657, "url": "https://eips.ethereum.org/EIPS/eip-7657", "title": "Sync committee slashings", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")"], "sections": {"EIP-7657: Sync committee slashings": "This EIP defines a slashing condition for malicioussync committee messages.", "Slashing condition for malicious sync committee messages": "This EIP defines a slashing condition for malicioussync committee messages.", "Abstract": "This EIP defines a slashing condition for malicioussync committee messages.", "Motivation": "A dishonest supermajority of sync committee members is able to convince applications relying on Ethereum\u2019slight client sync protocolto assume a non-canonical finalized header, and to potentially take over the sync authority for futureSyncCommitteePeriod. By signing a malicious beacon block root, a malicious (but valid!)LightClientUpdatemessage can be formed and subsequently used to, for example, exploit a trust-minimized bridge contract based on the light client sync protocol.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "State transition checks": "Note: This still allows having contradictions between attestations/proposals and sync committee messages. This also, by design, allows a validator to not participate at all in honest sync committee messages but solely participate in dishonest sync committee messages.", "Rationale": "Without a slashing, the light client sync protocol is somewhat limited. While wallet applications may benefit from it (the risk being, that incorrect data is displayed) and new beacon nodes may use it for accelerating chain synchronization, other interesting use cases such as bridges, token distributions or other systems requiring proofs depend on the mechanism providing higher security guarantees.", "What\u2019s the use case?": "Without a slashing, the light client sync protocol is somewhat limited. While wallet applications may benefit from it (the risk being, that incorrect data is displayed) and new beacon nodes may use it for accelerating chain synchronization, other interesting use cases such as bridges, token distributions or other systems requiring proofs depend on the mechanism providing higher security guarantees.", "Backwards Compatibility": "This EIP requires a hard fork as it introduces new consensus validation rules.", "Test Cases": "TBD", "Reference Implementation": "TBD", "Security Considerations": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- sync committee slashings: Adds a slashing condition for malicious sync committee messages, deterring sync committee members from signing non-canonical beacon block roots.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7658, "url": "https://eips.ethereum.org/EIPS/eip-7658", "title": "Light client data backfill", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")"], "sections": {"EIP-7658: Light client data backfill": "This EIP defines a mechanism for syncinglight client databetween beacon nodes.", "Mechanism for beacon nodes for syncing historical light client data": "This EIP defines a mechanism for syncinglight client databetween beacon nodes.", "Abstract": "This EIP defines a mechanism for syncinglight client databetween beacon nodes.", "Motivation": "Light client datais collected by beacon nodes to assistlight clientsto sync with the network. Thesync protocoldefines a mechanism to sync forward in time. However, it cannot be used to sync backward.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Containers": "New fields are added to the end ofBeaconStatefrom the activating fork onward to track the current and previous sync committee period\u2019s best sync data.", "Helper functions": "On sync committee boundaries, current period data is moved to previous period. This allows proving that light client data for the previous period is canonical.", "Beacon chain state transition function": "On sync committee boundaries, current period data is moved to previous period. This allows proving that light client data for the previous period is canonical.", "Rationale": "The EIP reuses theis_better_updatefunction from existing specs.", "How to rankSyncAggregate?": "The EIP reuses theis_better_updatefunction from existing specs.", "How could a backfill protocol use this?": "Once the data is available in theBeaconState, a light client data backfill protocol could be defined that serves, for past periods:", "Backwards Compatibility": "This EIP requires a hard fork as it introduces new consensus validation rules.", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- light client data backfill: Defines a mechanism for syncing historical light client data between beacon nodes, facilitating backward synchronization of light client data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7666, "url": "https://eips.ethereum.org/EIPS/eip-7666", "title": "EVM-ify the identity precompile", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-7666: EVM-ify the identity precompile": "Remove the identity precompile at 0x04. At the start of executing the block in which this change activates, put into that contract a short piece of EVM code that has the same functionality.", "Remove the identity precompile, and put into place a piece of EVM code that has equivalent functionality": "Remove the identity precompile at 0x04. At the start of executing the block in which this change activates, put into that contract a short piece of EVM code that has the same functionality.", "Abstract": "Remove the identity precompile at 0x04. At the start of executing the block in which this change activates, put into that contract a short piece of EVM code that has the same functionality.", "Motivation": "Ethereum today has a large number of precompiles. Nearly half of these precompiles are not seeing significant use, and are contributing to ongoing maintenance cost and risk of consensus bugs, as well as increased development effort for new Ethereum client implementations, including ZK-EVMs and implementations in formal-verification-friendly languages.", "Specification": "At the start of the block in which this fork activates, set the code ofIDENTITY_PRECOMPILE_ADDRESStoEVM_CODE. Starting from and including that block,IDENTITY_PRECOMPILE_ADDRESSshould no longer be treated as a precompile.", "Rationale": "The givenEVM_CODEcorresponds to", "Backwards Compatibility": "The functionality of the givenEVM_CODEis the same as the identity precompile. Gas costs are slightly different, though gas repricings have been done in the Ethereum ecosystem several times before and their effects are well understood.", "Security Considerations": "As no new functionality is introduced or made cheaper, no security concerns are raised.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- precompile_address: The address of the new precompiled contract for deactivating or reactivating a delegated EOA's private key.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7667, "url": "https://eips.ethereum.org/EIPS/eip-7667", "title": "Raise gas costs of hash functions", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-7667: Raise gas costs of hash functions": "Raise the gas costs of opcodes and precompiles that involve hash functions.", "Raise the gas costs of hash function opcodes and precompiles, to match prover expenses in ZK-EVMs": "Raise the gas costs of opcodes and precompiles that involve hash functions.", "Abstract": "Raise the gas costs of opcodes and precompiles that involve hash functions.", "Motivation": "Gas costs for hash function opcodes and precompiles were originally set based on the time that it takes to execute them on a regular CPU. Since then, however, there has emerged another equally important execution substrate that the EVM is executed on: zero knowledge proof (ZK-SNARK) systems. By that standard, these opcodes and precompiles areveryunderpriced relative to other operations.", "Specification": "Change the above parameters to their new values.", "Rationale": "The above increases the gas costs of all opcodes and precompiles that can be used to require large amounts of hashing in the EVM. All hashing costs are increased to 300 per hash plus 60 per word (or kept the same if they are already higher than this).\n\u2018\u201d\nA possible alternative to this approach is to implement either multidimensional gas pricing (ie. a separate floating basefee and per-block target and limit for hashes) or a \u201ctotal gas cost floor\u201d similar to whatEIP-7623does for calldata. However, this approach is much harder to implement for in-EVM gas costs such as hashes than it is for calldata and blobs, because EVM gas limits are set not just by users, for whom new transaction types that specify newly required limits, max-basefees and priority fees can easily be added, but also by contracts making sub-calls to other contracts.", "Backwards Compatibility": "For most applications, a reasonable upper bound is that data that is getting hashed in the EVM is getting brought in as calldata. If the hashing being done is binary Merkle proof verification, every 32 bytes of data corresponds to a 64-byte (2-word) hash. A word of costs 512 gas. Under the new costs, the hashing per word in that situation would be300 + 60 * 2 = 420gas. Hence, this will increase gas consumption for that component of the application by less than 2x.", "Security Considerations": "As no new operations are introduced or made cheaper, no security concerns were raised.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7668, "url": "https://eips.ethereum.org/EIPS/eip-7668", "title": "Remove bloom filters", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-7668: Remove bloom filters": "Require the bloom filters in an execution block, including at the top level and in the receipt object, to be empty.", "Remove bloom filters from the execution block": "Require the bloom filters in an execution block, including at the top level and in the receipt object, to be empty.", "Abstract": "Require the bloom filters in an execution block, including at the top level and in the receipt object, to be empty.", "Motivation": "Logs were originally introduced to give applications a way to record information about onchain events, which decentralized applications (dapps) would be able to easily query. Using bloom filters, dapps would be able to quickly go through the history, identify the few blocks that contained logs relative to their application, and then quickly identify which individual transactions have the logs that they need.", "Specification": "The logs bloom of an execution block is now required to be empty (ie. 0 bytes long). The logs bloom of a transaction receipt is now required to be empty (ie. 0 bytes long).", "Rationale": "This is a minimally disruptive way to remove the need to handle blooms from clients. A future EIP can later clean up by removing this field entirely, along with other fields that have been deprecated.", "Backwards Compatibility": "Applications that depend on bloom filters to read events will cease to work. Very few applications depend on this feature today, because at current gas limits the false positive rate is so high and processing the logs in a long history query is so slow, especially for light clients (whom this feature was primarily intended to benefit).", "Security Considerations": "As no new features are introduced or made cheaper, no security concerns are raised.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- remove bloom filters: Eliminates bloom filters from the execution block and receipt objects, acknowledging their limited utility in practical dapp usage.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7676, "url": "https://eips.ethereum.org/EIPS/eip-7676", "title": "EOF - Prepare for Address Space Extension", "authors": ["Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-7676: EOF - Prepare for Address Space Extension": "Operations in the Legacy EVM trim off the top 12 bytes of an address operand before evaluation. This\nEIP changes the handling of those opcodes within EOF so that no trimming occurs and the top twelve\nbytes need to be zero or an exceptional halt is raised.", "Update EOF opcodes so addresses are not trimmed during execution": "Operations in the Legacy EVM trim off the top 12 bytes of an address operand before evaluation. This\nEIP changes the handling of those opcodes within EOF so that no trimming occurs and the top twelve\nbytes need to be zero or an exceptional halt is raised.", "Abstract": "Operations in the Legacy EVM trim off the top 12 bytes of an address operand before evaluation. This\nEIP changes the handling of those opcodes within EOF so that no trimming occurs and the top twelve\nbytes need to be zero or an exceptional halt is raised.", "Motivation": "There have been proposals to extend Ethereum Addresses from 160 bits to 256, such as one that would\nuse the extra bits for state expiry (such as the ethereum magicians forum topic \u201cIncreasing the\naddress size from 20 to 32 bytes\u201d). One issue ground the work to a halt: EVM opcodes that accept\naddresses trim all but the lowest 20 bytes out from the operand before processing. EVM Reference\ntests verify this behavior in the \u2018stBadOpcode/invalidAddr.json\u2019 tests.", "Specification": "We introduce one new instruction:", "Rationale": "There is no need to ban theBALANCEopcode as it does not cause any problems that would require\nbanning it within an EOF container. Adding a new opcode also allows the existing opcode to behave\nthe same in EOF and legacy code, reducing potential friction points for end user confusion and bugs.", "New Opcode": "There is no need to ban theBALANCEopcode as it does not cause any problems that would require\nbanning it within an EOF container. Adding a new opcode also allows the existing opcode to behave\nthe same in EOF and legacy code, reducing potential friction points for end user confusion and bugs.", "Revert on invalid address": "There are two alternative ways to handle accounts with high bits set. The specification calls for\nan exceptional halt, but the alternative was to treat the account as empty. The reason the \u201cempty\naccount\u201d approach was rejected is twofold:", "No change in gas costing": "Because the BALANCE operation already needs to checkaccessed_addressesthere is already a good\namount of processing that must go into the operation. Hence, no changes to the gas schedule are\nneeded to prevent abuse of the failures. Such incremental costs will be dominated by costs related\nto reverts and address checking for valid accounts.", "Backwards Compatibility": "Preparing for Address Space Expansion is explicitly done inside the scope of EOF with the intent\nthat it will not require changes in old contracts, but with the caveat that old contracts may not be\nable to use addresses in the expanded space.", "Test Cases": "Test cases similar toinvalidAddr.jsontests in the standard reference tests will need to be\nwritten for the EOF tests, except they would check for halts on invalid addresses.", "Reference Implementation": "TBD", "Security Considerations": "This EIP only defines a revert behavior for previously stripped addresses. Compilers will need to be\naware of the need to mask addresses coming in from call data. Some of this is already present in\nexisting Solidity ABI standards, but more care should be taken in examining the flow\naroundEXTBALANCEand code forEXTCALLoperations to ensure that compiled code strips the high\nbytes.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- extbalance: Renames the BALANCE opcode to EXTBALANCE for clarity, aligning with other EXTCODE opcodes.\n- prepare for address space extension: Modifies EOF operations to avoid trimming addresses during execution, preparing for future extensions to 256-bit addresses.\n- magic: A constant value set as 0xef0100 used in the CREATE_DELEGATE instruction."}
{"eip": 7684, "url": "https://eips.ethereum.org/EIPS/eip-7684", "title": "Return deposits for distinct credentials", "authors": ["Lion\u00a0(", "@dapplion", ")"], "sections": {"EIP-7684: Return deposits for distinct credentials": "Automatically withdraw deposits for existing validator records, but where the deposit includes a distinct execution withdrawal credential.", "Automatically withdraw deposits for existing validator records but with distinct execution withdrawal credentials": "Automatically withdraw deposits for existing validator records, but where the deposit includes a distinct execution withdrawal credential.", "Abstract": "Automatically withdraw deposits for existing validator records, but where the deposit includes a distinct execution withdrawal credential.", "Motivation": "Some staking operations feature two distinct entities, one operating the validating key, and one funding the deposit. The funding entity delegates control of the stake operation but must retain ultimate control of funds. If the funding entity naively submits a single deposit with the full stake amount and the other entity\u2019s validating key, it is subject to a front-run attack. The validating entity can front-run the bigger deposit with a second deposit with its own set of withdrawal credentials. The full stake amount deposit becomes a top-up, in control of the validating entity.", "Specification": "The configuration values and mechanics of the specification can be found in theConsensus Layer specs.", "Consensus Layer": "The configuration values and mechanics of the specification can be found in theConsensus Layer specs.", "Execution Layer": "This specification does not require any changes to the Execution Layer.", "Rationale": "Rejected deposits from block at slot N can not be withdrawn in block N due to a cyclic dependency. An execution client must know the full list of withdrawals before constructing a payload for slot N. AfterEIP-6110, a consensus client must know the full execution payload for slot N before constructing the beacon block for slot N. Therefore, rejected deposits must be withdrawn in some future slot. All pending withdrawals are processed at once in the very next slot for simplicity but could be queued and processed progressively if there are DOS concerns.", "Persist pending withdrawals": "Rejected deposits from block at slot N can not be withdrawn in block N due to a cyclic dependency. An execution client must know the full list of withdrawals before constructing a payload for slot N. AfterEIP-6110, a consensus client must know the full execution payload for slot N before constructing the beacon block for slot N. Therefore, rejected deposits must be withdrawn in some future slot. All pending withdrawals are processed at once in the very next slot for simplicity but could be queued and processed progressively if there are DOS concerns.", "Backwards Compatibility": "This is a backward incompatible change to the Consensus Layer of Ethereum and must be scheduled with a hard fork.", "Test Cases": "Test cases are work-in-progress within the standard Consensus Layer tests.", "Security Considerations": "The worst-case number of withdrawals is raised from a fixed 16 to 1,271 under current gas rules and a 30M gas block. CitingEIP-6110, future gas efficiencies can increase the number to 1,916 withdrawals in a 30M gas block. Each withdrawal results in a single address balance change. There is no explicit pricing for such an operation, but under the worst case, it results in a notable increase in the total block gas (30% assuming 6,900 gas per withdrawal and current gas rules).", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- return deposits for distinct credentials: Automatically queues withdrawals for validator deposits where distinct execution withdrawal credentials exist, reducing potential front-running risks in staking.\n- withdrawal: Log entry in system_logs for tracking withdrawals under EIP-4895 ."}
{"eip": 7686, "url": "https://eips.ethereum.org/EIPS/eip-7686", "title": "Linear EVM memory limits", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-7686: Linear EVM memory limits": "Add a hard memory limit equal to the gas limit of the current context. Make the maximum gas cost of a sub-call depend on the memory used in the current context. The two rules together ensure that a transaction with N gas can use at most N bytes of memory.", "Adjust memory limits and gas limits of sub-calls to create a clear linear bound on how much total memory an EVM execution can consume": "Add a hard memory limit equal to the gas limit of the current context. Make the maximum gas cost of a sub-call depend on the memory used in the current context. The two rules together ensure that a transaction with N gas can use at most N bytes of memory.", "Abstract": "Add a hard memory limit equal to the gas limit of the current context. Make the maximum gas cost of a sub-call depend on the memory used in the current context. The two rules together ensure that a transaction with N gas can use at most N bytes of memory.", "Motivation": "Today, memory pricing rules are complicated: we have the quadratic cost for expanding memory as well as the 63/64 rule for how much gas can go into a child call. This also makes it extremely hard to calculate a maximum possible amount of memory required to process a given EVM execution.", "Specification": "Changememory_costfrom:", "Rationale": "With this EIP, there is a simple EVM implementation that can process an N-gas call using an N-byte bytearray as memory: allocate all bytes to the current context, when doing a child call use the remaining memory starting from the positionmemory_byte_sizefor the child call\u2019s memory, and so on recursively.", "Backwards Compatibility": "It is theoretically possible for EVM code that works today to fail to work under this new EIP, if that code accesses a high index in memory but is called with a low gas limit. However, almost all EVM execution consumes far more code than it uses bytes of memory. For example, for a call to cause even a single state change, it must have at least 5000 gas. This would allow it 5000 bytes of memory, which is greater than that used by almost all applications. More complex applications would have even higher limits.", "Security Considerations": "No security concerns were raised.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- linear evm memory limits: Adds a hard memory limit in EVM, ensuring that a transaction with N gas can use at most N bytes of memory.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7705, "url": "https://eips.ethereum.org/EIPS/eip-7705", "title": "NONREENTRANT and REENTRANT opcodes", "authors": ["Charles Cooper\u00a0(", "@charles-cooper", ")"], "sections": {"EIP-7705: NONREENTRANT and REENTRANT opcodes": "Add two opcodes,NONREENTRANTandREENTRANT, which set and clear a contract\u2019s reentrancy status. After invokingNONREENTRANT, a contract cannot beCALLed (orSTATICCALLed, orDELEGATECALLed) untilREENTRANTis invoked.", "Opcodes to mark a contract as nonreentrant": "Add two opcodes,NONREENTRANTandREENTRANT, which set and clear a contract\u2019s reentrancy status. After invokingNONREENTRANT, a contract cannot beCALLed (orSTATICCALLed, orDELEGATECALLed) untilREENTRANTis invoked.", "Abstract": "Add two opcodes,NONREENTRANTandREENTRANT, which set and clear a contract\u2019s reentrancy status. After invokingNONREENTRANT, a contract cannot beCALLed (orSTATICCALLed, orDELEGATECALLed) untilREENTRANTis invoked.", "Motivation": "Reentrancy attacks account for a substantial portion of user funds stolen on EVM chains, including the famous \u201cDAO hack\u201d. However, due to the cost of preventing against reentrancy attacks in application code, developers often opt-out of reentrancy protection. This cost has come down with the advent of transient storage (EIP-1153), but it is still not cheap enough where it is a \u201cno-brainer\u201d to use it by default. This EIP proposes opcodes which make it cheaper to protect against reentrancy in application code.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "The computational cost of pushing the current value to the call stack (for handling reverts) is accounted for in the overhead cost of the*CALLopcodes.", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "TBD", "Reference Implementation": "TBD", "Security Considerations": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- nonreentrant and reentrant opcodes: Introduces two new opcodes, NONREENTRANT and REENTRANT, to control a contract\u2019s reentrancy status, preventing reentrancy attacks.\n- revert: All calls to this opcode must emit a log with revert data."}
{"eip": 7706, "url": "https://eips.ethereum.org/EIPS/eip-7706", "title": "Separate gas type for calldata", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-7706: Separate gas type for calldata": "Add a new type of gas for transaction calldata. Add a new transaction type that providesmax_basefeeandpriority_feeas a vector, providing values for execution gas, blob gas and calldata gas. Modify the basefee adjustment to use the same mechanism for the three types of gas.", "Create a separate basefee and gaslimit for calldata": "Add a new type of gas for transaction calldata. Add a new transaction type that providesmax_basefeeandpriority_feeas a vector, providing values for execution gas, blob gas and calldata gas. Modify the basefee adjustment to use the same mechanism for the three types of gas.", "Abstract": "Add a new type of gas for transaction calldata. Add a new transaction type that providesmax_basefeeandpriority_feeas a vector, providing values for execution gas, blob gas and calldata gas. Modify the basefee adjustment to use the same mechanism for the three types of gas.", "Motivation": "A major argument against raising the Ethereum gas limit, making calldata cheaper, or increasing theEIP-4844blob count before technologies like PeerDAS become available, is that the theoretical maximum size of an Ethereum block is already too large, and we cannot afford to increase it further. However, there is an inefficiency here: the current average size of a block (not including blobs) is ~100 kB, and the theoretical max is30,000,000 / 16 = 1,875,000bytes (one could make larger blocks using zero bytes, but in practice zero-byte-heavy blocks would be compressed to less than 1.87 million bytes due to snappy compression). Ideally, we would have a way to bound the maximum, without making calldata more scarceon average.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Parameters": "As ofFORK_BLOCK_NUMBER, a newEIP-2718transaction is introduced withTransactionType=TX_TYPE(NEW_TX_TYPE).", "New transaction type": "As ofFORK_BLOCK_NUMBER, a newEIP-2718transaction is introduced withTransactionType=TX_TYPE(NEW_TX_TYPE).", "Block processing and transaction fees": "We add the functionsget_max_feesandget_priority_fees, to compute these length-3 vectors for previous transaction types:", "Block structure:": "We updateBlockHeaderfield, to remove theblob_gas_used,gas_used,base_fee_per_gas,gas_limitandexcess_blob_gasfields, and we add new fields, all of the[int, int, int]type:gas_limits,gas_used,excess_gas. The resulting RLP encoding becomes:", "Rationale": "This allows the same logic that is used for handling gas to handle all three types of gas. As a result, it\u2019s arguably a net simplification of protocol gas handling logic, despite the fact that the total number of gas types increases from 2 to 3", "Conversion of all gas-related mechanics into vectors": "This allows the same logic that is used for handling gas to handle all three types of gas. As a result, it\u2019s arguably a net simplification of protocol gas handling logic, despite the fact that the total number of gas types increases from 2 to 3", "Target ratios": "The target ratios for execution gas and blobs are set to 2; the target ratio for calldata is set to 4. This greatly decreases the number of scenarios in which calldata actually hits the limit, which mitigates economic impact of the EIP, because analysis of EIP-1559-style fee markets is much simpler in \u201cunder-the-limit\u201d conditions than in \u201cat-the-limit\u201d conditions. Additionally, it reduces the risk that applications requiring large calldata will outright stop working.", "Backwards Compatibility": "Previous transaction types set the calldata basefee and priority fee to equal each other. The calldata gas costs were intentionally set to be identical to today, and the gas target similar to present-day usage, so that setting the two fees to be equal each other is a reasonable approximation to optimal behavior. In practice, the new transaction type would be superior, so we expect users to switch to it over time. However, the loss suffered by old-style transaction users would not be that high, because priority fees are generally small compared to basefees, and the amount that a user pays is proportional to the basefee.", "Security Considerations": "Optimal block building behavior becomes more complex as a result of this EIP, particularly under the boundary conditions when blocks are full of one or both types of gas. We argue that the effects of this are not too large, because in practice over 90% of blocks are under-full, and naive \u201cgreedy algorithms\u201d can get a close-enough-to-optimal outcome. The centralization risks of proprietary block-building algorithms are thus likely to be much smaller than other existing risks with eg. MEV extraction.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- separate gas type for calldata: Creates a separate gas market for calldata, with its own base fee and gas limit, to better manage block size without making calldata more scarce.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7707, "url": "https://eips.ethereum.org/EIPS/eip-7707", "title": "Incentivize Access List Provisioning", "authors": ["Ben Adams\u00a0(", "@benaadams", ")", "Oleg Iakushkin\u00a0(", "@OlegJakushkin", ")"], "sections": {"EIP-7707: Incentivize Access List Provisioning": "This EIP reduces the gas cost of access list data, incentivizing the inclusion of complete and valid access lists in transactions to improve data load efficiency for execution layer clients.", "This EIP proposes updating gas cost parameters for access lists to incentivise their use and improve transaction execution efficiency.": "This EIP reduces the gas cost of access list data, incentivizing the inclusion of complete and valid access lists in transactions to improve data load efficiency for execution layer clients.", "Abstract": "This EIP reduces the gas cost of access list data, incentivizing the inclusion of complete and valid access lists in transactions to improve data load efficiency for execution layer clients.", "Motivation": "WhileEIP-2930introducedaccessListsas a mechanism forSLOADpre-warming  to reduce gas costs by informing the EVM upfront about which storage slots a transaction will access,\nthe practical use is limited and uncommon due to the savings versus penalties involved. In order to break even for\neach address included24 storage keysare required per address, and there is a100 gassaving per key at25+; \nin contrast the penalty for including an unused key is1900 gas, so break-even where one key is unused is43 keys.This situation makes the break-even and risk-reward ratio ofaccessListsrarely appealing in practice for regular\ntransactions, where a prior transaction could lead to a different branch being taken and a slightly different set of\nstorage slots being accessed. Furthermore, a very high number of SLOADs is required to start breaking even.For some clients, data loading takes>70%of block execution time. This\nhappens in part due to sequential transaction execution and iterative\nsearch of effectively random access data.While NVMe drives have massive throughput and IOPS; this is their\nconcurrent throughput operated through multiple queues and they do not\nhave this performance if data is accessed completely sequentially with\none request waiting for the prior to complete i.e. stacking individual\nIOPS latency end to end will not give anything close to maximal\nthroughput that these drives can deliver (which is different from the\nHDD world where heads needed to seek to different physical locations for\neach read). This is a similar situation with network attached storage or\ncloud data disks; however the latency here is even more amplified than a\nlocal direct CPU attached NVMe drive (i.e. via network card).If nodes had a somewhat clearer picture of what data to pre-load for the\nblock\u2019s execution; that can be done in parallel, hiding much of the\nlatency from accessing that data when discovered from executing the\ntransaction. Very much in a similar way to instruction pipelining on a\nCPU hiding memory access latencies; the data access for transactions\ncould be pipelined. This can lead to faster/cheaper block execution and\nwould facilitate data dependency hints for parallel Tx execution in the\nfuture, like on other emerging chains that were developed with more\nmodern hardware in mind.", "Specification": "We shall updateEIP-2930parameters:", "Rationale": "As stated in the introduction the gas cost benefit analysis does not\nencourage the users of the chain to provide accessList hints, even\nthough the mechanism is already in protocol (and a call toeth_createAccessListwill give them, or a wallet the correct list\nto include). So we propose a reduction in the pricing of those data\naccess lists to make them more inline with calldata.Levelling the playing field between smallcall_dataandaccess_listscosts, (and incentiviseaccess_listsprovisioning from transaction\nsenders as they are needed for transaction execution in a faster\nmanner), the price model updates would look as follows:", "Examples": "Current", "Backwards Compatibility": "This EIP makes a minor update toEIP-2930with\nrespect to modern execution challenges and capabilities.", "Security Considerations": "Same as perEIP-2930", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- incentivize access list provisioning: Reduces the gas cost of access lists, encouraging their use and improving the data load efficiency for execution layer clients.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170."}
{"eip": 7708, "url": "https://eips.ethereum.org/EIPS/eip-7708", "title": "ETH transfers emit a log", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Peter Davies\u00a0(", "@petertdavies", ")"], "sections": {"EIP-7708: ETH transfers emit a log": "All ETH-transfers, including transactions,CALLandSELFDESTRUCTemit a log.", "All ETH transfers emit a log": "All ETH-transfers, including transactions,CALLandSELFDESTRUCTemit a log.", "Abstract": "All ETH-transfers, including transactions,CALLandSELFDESTRUCTemit a log.", "Motivation": "Logs are often used to track when balance changes of assets on Ethereum. Logs work forERC-20tokens, but they do not work for ETH. ETH transfers from EOAs can be read from the transaction list in the block, but ETH transfers from smart contract wallets are not automatically logged anywhere. This has already led to problems in the past, eg. early exchanges would often not properly support deposits from smart contract wallets, or only support them with a much longer delay. This EIP proposes that we automatically generate a log every time a value-transferringCALLorSELFDESTRUCThappens. We also add a similar log for transfers in transactions, so that all ETH transfers can be tracked using one mechanism.", "Specification": "Whenever (i) a nonzero-valueCALL, (ii) a nonzero-value-transferringSELFDESTRUCT, or (iii) a nonzero-value-transferring transaction takes place, issue a log, identical to a LOG3, with three topics: (i)MAGIC, (ii) the sender address, (iii) the recipient address. The log data is a big-endian 32-byte encoding of the transfer value.", "Parameters": "Whenever (i) a nonzero-valueCALL, (ii) a nonzero-value-transferringSELFDESTRUCT, or (iii) a nonzero-value-transferring transaction takes place, issue a log, identical to a LOG3, with three topics: (i)MAGIC, (ii) the sender address, (iii) the recipient address. The log data is a big-endian 32-byte encoding of the transfer value.", "Functionality": "Whenever (i) a nonzero-valueCALL, (ii) a nonzero-value-transferringSELFDESTRUCT, or (iii) a nonzero-value-transferring transaction takes place, issue a log, identical to a LOG3, with three topics: (i)MAGIC, (ii) the sender address, (iii) the recipient address. The log data is a big-endian 32-byte encoding of the transfer value.", "Rationale": "This is the simplest possible implementation that ensures that all ETH transfers are implemented in some kind of record that can be easily accessed through making RPC calls into a node, or through asking for a Merkle branch that is hashed into the block root. The log type is compatible with the ERC-20 token standard, but does not introduce any overly-specific ERC-20 features (eg. ABI encodings) into the specification.", "Open questions": "No backward compatibility issues found.", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "TODO", "Security Considerations": "ETH transfers already cost a minimum of 6700 gas, which is much more expensive than the LOG3 opcode (1500 gas). Hence, this EIP does not increase the worst-case number of logs that can be put into a block. It will somewhat increase the average number of logs.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- eth transfers emit a log: Automatically generates a log for every ETH transfer, including via transactions, CALL, and SELFDESTRUCT, enabling easier tracking of ETH movement.\n- magic: A constant value set as 0xef0100 used in the CREATE_DELEGATE instruction."}
{"eip": 7716, "url": "https://eips.ethereum.org/EIPS/eip-7716", "title": "Anti-correlation attestation penalties", "authors": ["dapplion\u00a0(", "@dapplion", ")", "Toni Wahrst\u00e4tter\u00a0(", "@nerolation", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-7716: Anti-correlation attestation penalties": "The decentralization of the validator set is one of the most important properties of Ethereum for credible neutrality and censorship resistance. By adjusting penalties to foster decentralization, diversification and fault-tolerance, this EIP proposes to adjust penalties in a way that more diversified entities get lower penalties while entities with high correlations in their setup face more severe ones.", "Adjust penalties for missed attestations based on in-slot correlation of missed attestation": "The decentralization of the validator set is one of the most important properties of Ethereum for credible neutrality and censorship resistance. By adjusting penalties to foster decentralization, diversification and fault-tolerance, this EIP proposes to adjust penalties in a way that more diversified entities get lower penalties while entities with high correlations in their setup face more severe ones.", "Abstract": "The decentralization of the validator set is one of the most important properties of Ethereum for credible neutrality and censorship resistance. By adjusting penalties to foster decentralization, diversification and fault-tolerance, this EIP proposes to adjust penalties in a way that more diversified entities get lower penalties while entities with high correlations in their setup face more severe ones.", "Motivation": "As of now, during times of usual network operation, there are no economic incentives to diversify node operations through using multiple different nodes, geographical locations, clients, ISP providers, etc., except for reducing the risk of penalties affecting all validators simultaneously, thereby limiting the impact to only a fraction of them.", "Specification": "Add a variableNET_EXCESS_PENALTIESto the beacon state.", "Rationale": "This variable impacts the sensitivity of theNET_EXCESS_PENALTIES.", "PENALTY_ADJUSTMENT_FACTOR": "This variable impacts the sensitivity of theNET_EXCESS_PENALTIES.", "MAX_PENALTY_FACTOR": "TheMAX_PENALTY_FACTORputs a ceiling onto the maximum factor with which the penalty for missed attestations is scaled to prevent overly harsh punishments.", "Backwards Compatibility": "This is a backwards incompatible adjustment of attestations rewards and penalties that requires a scheduled network upgrade.", "Security Considerations": "We acknowledge that splitting validator views can be leveraged as an attack to increase thepenalty_factorfor validators of consecutive slots with little risk for the proposer. \nTBD.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- anti-correlation attestation penalties: Adjusts penalties for missed attestations based on their correlation with other missed attestations, encouraging validator diversification.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7727, "url": "https://eips.ethereum.org/EIPS/eip-7727", "title": "EVM Transaction Bundles", "authors": ["Lily Johnson\u00a0(", "@lilyjjo", ")"], "sections": {"EIP-7727: EVM Transaction Bundles": "This EIP introduces two newEIP-2718transaction types and one new opcode, enabling smart contracts and transactions to delegate their local sequencing rights to an off-chain entity. These new transaction types work together to create EVM-native \u2018bundles\u2019, which are similar to but weaker than the Proposer-Builder Separation (PBS) bundles offered by builders to searchers.", "Enable meta transactions to order other transactions without revert protections.": "This EIP introduces two newEIP-2718transaction types and one new opcode, enabling smart contracts and transactions to delegate their local sequencing rights to an off-chain entity. These new transaction types work together to create EVM-native \u2018bundles\u2019, which are similar to but weaker than the Proposer-Builder Separation (PBS) bundles offered by builders to searchers.", "Abstract": "This EIP introduces two newEIP-2718transaction types and one new opcode, enabling smart contracts and transactions to delegate their local sequencing rights to an off-chain entity. These new transaction types work together to create EVM-native \u2018bundles\u2019, which are similar to but weaker than the Proposer-Builder Separation (PBS) bundles offered by builders to searchers.", "Motivation": "Currently, a single block builder has unrestricted control over the final sequencing of a block\u2019s transactions. This poses a problem, as sequencing\u2014the choice of who gets to interact with specific pieces of state and in what order\u2014significantly influences value flow. The objective of this EIP is to allow more parties to participate in the construction of single blocks by exposing sequencing concepts inside of the EVM. This change would enable EVM applications to reclaim some of the sequencing value that is currently monopolized by block builders, redirecting it back to the applications themselves.", "Specification": "Two newEIP-2718transactions with typesDELEGATED_TX_TYPEandBUNDLE_TX_TYPE.", "Constants": "Two newEIP-2718transactions with typesDELEGATED_TX_TYPEandBUNDLE_TX_TYPE.", "New Transaction Payload Types": "Two newEIP-2718transactions with typesDELEGATED_TX_TYPEandBUNDLE_TX_TYPE.", "BUNDLE_SIGNEROpcode": "TheBUNDLE_SIGNERis a new opcode identified byBUNDLE_SIGNER_OPCODE_NUMBERthat requires zero stack arguments.", "Transaction Validity Rules": "For aDELEGATED_TX_TYPEto be valid, the following must be true:", "Gas Costs": "TheBUNDLE_TX_TYPEhas a new gas cost formula that changes based on whether the transactions in thetransactionListare valid at the time of execution.", "Execution": "DELEGATED_TX_TYPEexecute normally with theBUNDLE_SIGNERopcode returning thebundleSignerpayload variable.", "ReceiptPayload Definitions": "ForDELEGATED_TX_TYPEtransaction that are able to begin execution, theirEIP-2718receipt payload should be interpreted as:", "Rationale": "Knowing how a transaction will execute is challenging without knowing the state root to which the transaction is applied. Creators ofBUNDLE_TX_TYPEtransactions can only access the previous block\u2019s state root and cannot predict which transactions will precede theBUNDLE_TX_TYPEtransaction in the upcoming block\u2019s total order. If only valid transactions were permitted,BUNDLE_TX_TYPEtransaction lists could be easily invalidated by a single inner transaction attempting to grief the bundle through nonce or gas invalidations.", "Allowing invalid transactions to be included in aBUNDLE_TX_TYPE\u2019stransactionList": "Knowing how a transaction will execute is challenging without knowing the state root to which the transaction is applied. Creators ofBUNDLE_TX_TYPEtransactions can only access the previous block\u2019s state root and cannot predict which transactions will precede theBUNDLE_TX_TYPEtransaction in the upcoming block\u2019s total order. If only valid transactions were permitted,BUNDLE_TX_TYPEtransaction lists could be easily invalidated by a single inner transaction attempting to grief the bundle through nonce or gas invalidations.", "Charging theBUNDLE_TX_TYPE\u2019s signerCALLDATAgas costs for invalid transactions": "Blockchains must charge for the work that nodes perform to prevent DoS attacks. Even though invalid transactions inBUNDLE_TX_TYPEtransaction lists do not execute, they still occupy block space as bytes and must be paid for by some entity. It is assumed thatBUNDLE_TX_TYPEcreators will be sophisticated entities capable of simulating the previous block\u2019s state with relative accuracy and able to generate enough profit to offset any invalidation costs incurred.", "RequiringDELEGATED_TX_TYPEtyped transactions to be included in aBUNDLE_TX_TYPE\u2019stransactionList": "IfDELEGATED_TX_TYPEtransactions were able to be executed outside of aBUNDLE_TX_TYPEtransaction list, then there would be competition between theBUNDLE_TX_TYPEsigner and the total block builder for the right to choose how to locally sequence the transaction. If theDELEGATED_TX_TYPEtransaction signer wished to allow the total block builder to choose the local ordering, then theDELEGATED_TX_TYPEtransaction type should not be used.", "Not allowing other transactions types to be included in aBUNDLE_TX_TYPE\u2019stransactionList": "This restriction was implemented as a precautionary measure and could be reconsidered in the future. Allowing the inclusion of other transaction types that do not specify abundleSignerinto thetransactionListcould result in multiple searchers attempting to include the same transaction in a bundle. This could potentially create spam within a block.", "Differences from PBS Searcher Bundles": "PBS block builders currently offer \u2018bundles\u2019 as a service to searchers in the form of transaction lists that either all execute without reversion or are not included in a block. Searchers typically use these bundles to bid for the right to be the first to interact with a piece of state or to place logic before or after transactions created by non-searcher entities, with back-running and sandwiching being examples. PBS block builders provide this service as a way to gain order flow and increase their block\u2019s value.", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "Block builders are problematic today partly due to their ability to perform censorship and enforce malicious orderings. These concerns persist even when sequencing rights are delegated to a specific entity. The code that generates the off-chain ordering should be public and executed in a trust-minimized manner, such as in a TEE (Trusted Execution Environment) or on a blockchain with faster block times.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- evm transaction bundles: Introduces two new transaction types and an opcode, enabling EVM-native transaction bundles that delegate local sequencing rights to off-chain entities.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7736, "url": "https://eips.ethereum.org/EIPS/eip-7736", "title": "Leaf-level state expiry in verkle trees", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")", "Wei Han Ng\u00a0(", "@weiihann", ")"], "sections": {"EIP-7736: Leaf-level state expiry in verkle trees": "Adds an \u201cupdate epoch\u201d to the verkle tree extension node. When it is time for an epoch to expire, the extension node and its suffix nodes can be deleted.", "Simple state expiry scheme in which only \"extension-and-suffix trees\" are expired.": "Adds an \u201cupdate epoch\u201d to the verkle tree extension node. When it is time for an epoch to expire, the extension node and its suffix nodes can be deleted.", "Abstract": "Adds an \u201cupdate epoch\u201d to the verkle tree extension node. When it is time for an epoch to expire, the extension node and its suffix nodes can be deleted.", "Motivation": "Previous attempts at implementing state expiry have been stalled by the quickly-increasing complexity, require heavy change in the structure of ethereum (address space extension, oil, multiple trees, \u2026). This proposal is offering a simpler albeit non-exhaustive approach to state expiry: only removing the leaf nodes and leaving the rest of the tree intact. This removes the need for methods that would be detrimental to the user and developer experience.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Constants": "Add an integral variable calledcurrent_epoch. It is initialized toINITIAL_EPOCH_COUNTERbefore the fork, and contains the current epoch number.", "Change to the verkle tree": "Add an integral variable calledcurrent_epoch. It is initialized toINITIAL_EPOCH_COUNTERbefore the fork, and contains the current epoch number.", "Expiry": "At the start of block processing, before transactions are executed, runcheck_epoch_end:", "Resurrection": "The resurrection transaction is defined as follows:", "Rationale": "This approach has the benefit of simplicity, over previous proposals for state expiry:", "Backwards Compatibility": "This proposal is backwards-compatible with verkle, as by default the value for the 4th (index starting at 0) evaluation point is set to0inEIP-6800, which is the value ofINITIAL_EPOCH_COUNTER.", "Test Cases": "TODO", "Reference Implementation": "TODO", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- leaf-level state expiry in verkle trees: Introduces state expiry at the leaf level in Verkle trees by adding an \"update epoch\" to extension nodes, allowing inactive data to be expired and reactivated via new transactions.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3, "url": "https://eips.ethereum.org/EIPS/eip-3", "title": "Addition of CALLDEPTH opcode", "authors": ["Martin Holst Swende\u00a0<", "martin@swende.se", ">"], "sections": {"EIP-3: Addition of CALLDEPTH opcode": "This is a proposal to add a new opcode,CALLDEPTH. TheCALLDEPTHopcode would return the remaining available call stack depth.", "": "This is a proposal to add a new opcode,CALLDEPTH. TheCALLDEPTHopcode would return the remaining available call stack depth.", "Abstract": "This is a proposal to add a new opcode,CALLDEPTH. TheCALLDEPTHopcode would return the remaining available call stack depth.", "Motivation": "There is a limit specifying how deep contracts can call other contracts; the call stack. The limit is currently256. If a contract invokes another contract (either viaCALLorCALLCODE), the operation will fail if the call stack depth limit has been reached.", "Specification": "The opcodeCALLDEPTHshould return the remaining call stack depth. A value of0means that the call stack is exhausted, and no further calls can be made.", "Rationale": "The actual call stack depth, as well as the call stack depth limit, are present in the EVM during execution, but just not available within the EVM. The implementation should be fairly simple and would provide a cheap and way to protect against call stack attacks.", "Implementation": "Not implemented.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- calldepth: A proposed opcode to return the remaining available call stack depth during contract execution, introduced in .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 908, "url": "https://eips.ethereum.org/EIPS/eip-908", "title": "Reward clients for a sustainable network", "authors": ["James Ray\u00a0(", "@jamesray1", ")", "Micah Zoltu\u00a0(", "@MicahZoltu", ")"], "sections": {"EIP-908: Reward clients for a sustainable network": "While Casper validators are incentivized to validate transactions, there are still no incentives for relaying blocks and storing data (which includes state). This paper is more a high-level analysis and discussion rather than attempting to provide a concrete solution.Pocket Networkis a separate blockchain being designed as of Sept 2018 that incentivises relaying transactions, that is intended to be compatible with other blockchains. Note also thatRocket Poolis under development and is planned to be a pool for Casper, which will help to incentivise running a full node. Another alternative isVIPnodewhich charges fees to light clients for full nodes that serve them. In light of these solutions being developed, perhaps a more appropriate approach to generally rewarding clients would be to incentivize bandwidth (relaying and downloading), storage and I/O (while computation is already incentivized with gas for miners and will be for proposers under sharding and Casper). Note also that notaries will be incentivized to download collations under sharding. Outdated (Casper FFG will be implemented with Ethereum 2.0 with sharding:shasper): given that it looks like Casper FFG will be implemented soon, to minimize undue complexity to the protocol, incentivizing validation in the mean time may be considered not worthwhile. For a previous version of the proposal containing a proposal for rewarding a full node, refer tohere.", "": "While Casper validators are incentivized to validate transactions, there are still no incentives for relaying blocks and storing data (which includes state). This paper is more a high-level analysis and discussion rather than attempting to provide a concrete solution.Pocket Networkis a separate blockchain being designed as of Sept 2018 that incentivises relaying transactions, that is intended to be compatible with other blockchains. Note also thatRocket Poolis under development and is planned to be a pool for Casper, which will help to incentivise running a full node. Another alternative isVIPnodewhich charges fees to light clients for full nodes that serve them. In light of these solutions being developed, perhaps a more appropriate approach to generally rewarding clients would be to incentivize bandwidth (relaying and downloading), storage and I/O (while computation is already incentivized with gas for miners and will be for proposers under sharding and Casper). Note also that notaries will be incentivized to download collations under sharding. Outdated (Casper FFG will be implemented with Ethereum 2.0 with sharding:shasper): given that it looks like Casper FFG will be implemented soon, to minimize undue complexity to the protocol, incentivizing validation in the mean time may be considered not worthwhile. For a previous version of the proposal containing a proposal for rewarding a full node, refer tohere.", "A reward for running a full node is deprecated, but the proposal for a reward for clients remains": "While Casper validators are incentivized to validate transactions, there are still no incentives for relaying blocks and storing data (which includes state). This paper is more a high-level analysis and discussion rather than attempting to provide a concrete solution.Pocket Networkis a separate blockchain being designed as of Sept 2018 that incentivises relaying transactions, that is intended to be compatible with other blockchains. Note also thatRocket Poolis under development and is planned to be a pool for Casper, which will help to incentivise running a full node. Another alternative isVIPnodewhich charges fees to light clients for full nodes that serve them. In light of these solutions being developed, perhaps a more appropriate approach to generally rewarding clients would be to incentivize bandwidth (relaying and downloading), storage and I/O (while computation is already incentivized with gas for miners and will be for proposers under sharding and Casper). Note also that notaries will be incentivized to download collations under sharding. Outdated (Casper FFG will be implemented with Ethereum 2.0 with sharding:shasper): given that it looks like Casper FFG will be implemented soon, to minimize undue complexity to the protocol, incentivizing validation in the mean time may be considered not worthwhile. For a previous version of the proposal containing a proposal for rewarding a full node, refer tohere.", "Simple Summary": "When each transaction is validated, give a reward to clients for developing the client.", "Abstract": "The tragedy of the commons is a phenomenon that is well known in many sectors, most notably in regard to sustainability. It involves the over-utilization of shared finite resources, which detriments all participants and stakeholders involved (which in the case of a global public good can be everyone, including future generations). Without proper management of public resources, a tragedy of the commons can occur. Internalizing externalities (where externalities can be broadly defined as effects that are not accounted for in the intrinsic price of a good, service or resource) is one way of incentivizing the proper management of resources, although other methods that actually properly manage them are necessary. This EIP proposes to make a change to the protocol to providea reward to clients for providing the software that enables Ethereum to function, where the reward can include a proportion of transaction fees (reducing the full proportion that the miner currently receives), and some newly minted ETH. Thus, clients are incentivized to maintain and improve the security and health of the Ethereum protocol and ecosystem. To summarize the mechanism in the proposal, a user agent is attached to a transaction, where this user agent contains a vector with the index of a client address in an access list. The client address could be inserted by the client and verified that it is the same as a read-only constant in the client\u2019s storage.", "Motivation": "Currently there is a lack of incentives for anyone to run a full node, while joining a mining pool is not really economical if one has to purchase a mining rig (several GPUs) now, since there is unlikely to be a return on investment by the time that Ethereum transitions to hybrid Proof-of-Work/Proof-of-Stake withCasper FFG, then full PoS withCBC Casper.", "Specification": "Add a new field to each block calledPrevBlockVerifications, which is an arbitrary, unlimited size byte array. When a client verifies that a previous block isvalid, the client appends a user agent to PrevBlockVerifications via an opcode in a transaction, PREV_BLOCK_VERIF. The user agent is a vector with the  immutable fields: the blockhash of the block that is validated, and the index of a client address in an access list (details are below). A miner validates a transaction before including it in a block, however they are not able to change these fields of the vector because they\u2019re immutable.", "Attacks and added specifications to prevent them": "A miner could create a client and fill their block with transactions that only contain the PREV_BLOCK_VERIF opcode (or alternatively, arbitrarily complex transactions, still with the opcode), with previous blockhashes that they have validated and the address of their client. To prevent this, state would have to store a list containing lists, with each sublist listing the blockhashes up to 400 blocks ago that correspond to a miner, then a miner (or a proposer under Casper CBC) could have to put down a deposit, and be slashed if the proposer inserts such a transaction (that contains a blockhash which they have already proposed, not just in a block but at any time previously). Updating the state to remove blockhashes more than 400 blocks ago would add additional overhead, although you could add an extra window for older blocks, say 120,000 blocks (roughly every 3 weeks), still ignore blocks that are older than 400 blocks ago, and remove these older 120,000 blocks every 120,000 blocks. An attacker could bribe a miner/proposer to include transactions like above that contain an address of a client in the access list which they own. However, the above slashing condition should disincentivize this.", "More details on the access list": "The access list prevents anyone inserting any address to the first element of the vector, where there may be a way to prevent censorship and centralization of authority of who decides to register new addresses in the list, e.g. on-chain governance with signalling (possibly similar toEIP-1015, which also specifies an alternative way of sending funds) or a layer 2 proof of authority network where new addresses can be added via a smart contract. Note that there may be serious drawbacks to implementing either of these listed examples. There is a refutation ofon-chain governanceas well as ofplutocracy.Proof of Authorityisn\u2019t suitable for a public network since it doesn\u2019t distribute trust well. However, using signalling in layer 2 contracts is more acceptable, but Vlad Zamfir argues that using that to influence outcomes in the protocol can disenfranchise miners from being necessary participants in the governance process. Thus, in light of these counterpoints, having an access list may not be suitable until a decentralized, trustless way of maintaining it is implemented and ideally accepted by the majority of a random sample that represents the population of Ethereum users.", "Rationale": "As of May 4 2018, there are16428 nodes. Assume that an annual cost for an average client developer organisation is $1 million per annum. Projecting forward (and noting that the number of nodes should increase substantially if this EIP was implemented, thus aiding Ethereum\u2019s goal of decentralizing everything) assume that there are 10 clients. Thus let us assume that the number of nodes doubles to 30000 nodes within 5 years (this assumption is probably conservative, even if it is forward looking). Assume for simplicity that the costs of a client are entirely covered by this block reward.", "A rough qualitative analysis of fees": "As of May 4 2018, there are16428 nodes. Assume that an annual cost for an average client developer organisation is $1 million per annum. Projecting forward (and noting that the number of nodes should increase substantially if this EIP was implemented, thus aiding Ethereum\u2019s goal of decentralizing everything) assume that there are 10 clients. Thus let us assume that the number of nodes doubles to 30000 nodes within 5 years (this assumption is probably conservative, even if it is forward looking). Assume for simplicity that the costs of a client are entirely covered by this block reward.", "More rationale (outdated by above)": "The amount of computation to validate a transaction will be the same as a miner, since the transaction will need to be executed. Thus, if there would be transaction fees for validating full nodes and clients, and transactions need to be executed by validators just like miners have to, it makes sense to have them calculated in the same way as gas fees for miners. This would controversially increase the amount of transaction fees a lot, since there can be many validators for a transaction. In other words, it is controversial whether to provide the same amount of transaction fee for a full node validator as for a miner (which in one respect is fair, since the validator has to do the same amount of computation), or prevent transaction fees from rising much higher, and have a transaction fee for a full node as, say, the transaction fee for a miner, divided by the average number of full nodes validating a transaction. The latter option seems even more controversial (but is still better than the status quo), since while there would be more of an incentive to run a full node than there is now with no incentive, validators would be paid less for performing the same amount of computation.", "Security": "All of the below struck out information should be prevented via using an access list and verifying that the read-only address provided by the client matches with an address in the access list, as well as using a layer 2 solution such as a PoA network for censhorship resistance and minimization of centralization in the access list.", "Backwards Compatibility": "Introducing in-protocol fees is a backwards-incompatible change, so would be introduced in a hard-fork.", "Test Cases": "TODO", "Implementation": "TODO", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- reward clients for a sustainable network: Proposes rewarding client developers with transaction fees and newly minted ETH to incentivize client development, aiming for a sustainable Ethereum network.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 999, "url": "https://eips.ethereum.org/EIPS/eip-999", "title": "Restore Contract Code at 0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4", "authors": ["Afri Schoedon\u00a0(", "@5chdn", ")"], "sections": {"EIP-999: Restore Contract Code at 0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4": "This document proposes to restore the contract code of theWalletLibrarycontract at0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4with a patched version.\nThe contract was accidentally self-destructed and renders a significant amount\nof Ether inaccessible.", "": "This document proposes to restore the contract code of theWalletLibrarycontract at0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4with a patched version.\nThe contract was accidentally self-destructed and renders a significant amount\nof Ether inaccessible.", "Simple Summary": "This document proposes to restore the contract code of theWalletLibrarycontract at0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4with a patched version.\nThe contract was accidentally self-destructed and renders a significant amount\nof Ether inaccessible.", "Abstract": "TheWalletLibrarycontract was used by theParity Walletto reduce gas costs for users deploying\nmulti-signature wallets on the Ethereum blockchain. It contained basic\nfunctionality such as confirming or revoking multi-signature transactions for\nany wallet deployed that depends on this library. Theaccidental self-destructionof the library contract caused significant amounts of Ether and other assets\nowned by many different parties to be inaccessible. This proposal suggests\nrestoring theWalletLibraryby apatchedversion to allow the\nowners of the dependent multi-signature wallets regain access to their assets.", "Motivation": "This proposal is necessary because the Ethereum protocol does not allow the\nrestoration of self-destructed contracts and there is no other simple way to\nenable the affected users and companies regaining access to their tokens and\nEther. In opposite to previously discussed proposals, this will not change any\nEVM semantics and tries to achieve the goal of unfreezing the funds by a single\nstate transition as specified in the next section.", "Specification": "The self-destructed contract code at0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4shall be replaced with a patched version of thewalletLibrary.solas reviewed, tested, and approved inparity-contracts/0x863df6bfa4:", "Direct State Transition via Bytecode (999a)": "AtCNSTNTNPL_FORK_BLKNUM, directly recreate the account0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4with the following parameters:", "Alternate Specification via Codehash (999b)": "AtCNSTNTNPL_FORK_BLKNUM, directly recreate the account0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4with the following parameters:", "Rationale": "The design decision to restore theWalletLibrarycontract code in a single\nstate transition was made after lengthy discussions ofalternate proposalsthat explored different ways to improve the Ethereum protocol to allow contract\nrevivals by adding different built-in contracts. It was eventually concluded\nthat all of these proposals changing the EVM semantics around self-destructed\ncontracts were introducing unwanted side-effects andpotential risksto the existing smart-contract ecosystem on the Ethereum platform.", "Backwards Compatibility": "This proposal introduces backwards incompatibilities in the state of the\ncontract at0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4. The Ethereum protocol\ndoes not allow the restoration of self-destructed contracts. To implement this\non the Ethereum blockchain, it is recommended to add the necessary state\ntransition in a future hard-fork at a well-defined block number, e.g.,CNSTNTNPL_FORK_BLKNUMfor the Constantinople milestone which is supposed to be\nthe next scheduled hard-fork on the Ethereum road-map.", "Implementation": "A proof-of-concept implementation is available for the Parity client on brancha5-eip999-poc(#8406). A sample chain\nconfiguration for Parity can be found at the same branch inmultisig_test.jsondescribing the state change as specified above.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- fork_blknum: A parameter specifying the block number at which a particular fork, such as the Homestead Hard Fork, becomes active .\n- restore contract code at 0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4: Proposes restoring the Parity Wallet's WalletLibrary contract, which was accidentally self-destructed, to unfreeze funds locked in multi-signature wallets.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785."}
{"eip": 1240, "url": "https://eips.ethereum.org/EIPS/eip-1240", "title": "Remove Difficulty Bomb", "authors": ["Micah Zoltu\u00a0(", "@MicahZoltu", ")"], "sections": {"EIP-1240: Remove Difficulty Bomb": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) slowly accelerating. This EIP proposes to remove the difficulty increase over time and replace it with a fixed difficulty targeting 15 second blocks.", "": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) slowly accelerating. This EIP proposes to remove the difficulty increase over time and replace it with a fixed difficulty targeting 15 second blocks.", "Simple Summary": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) slowly accelerating. This EIP proposes to remove the difficulty increase over time and replace it with a fixed difficulty targeting 15 second blocks.", "Abstract": "Starting withFORK_BLOCK_NUMBERthe client will calculate the difficulty without considering the current block number.", "Motivation": "The difficulty bomb operates under the assumption that miners decide what code economic participants are running, rather than economic participants deciding for themselves.  In reality, miners will mine whatever chain is most profitable and the most profitable chain is the one that economic participants use.  If 99% of miners mine a chain that no economic participants use then that chain will have no value and the miners will cease mining of it in favor of some other chain that does have economic participants.  Another way to put this is that miners will follow economic participants, not the other way around.", "Specification": "For the purposes ofcalc_difficulty, ifblock.number >= FORK_BLOCK_NUMBERthen change the epsilon component to0rather than having it be a function of block number.", "Rationale": "With the difficulty bomb removed, when Casper is released it will be up to economic participants to decide whether they want the features that Casper enables or not.  If they do not want Casper, they are free to continue running unpatched clients and participating in the Ethereum network as it exists today.  This freedom of choice is the cornerstone of DLTs and making it hard for people to make that choice (by creating an artificial pressure) does not work towards that goal of freedom of choice.  If the development team is not confident that economic participants will want Casper, then they should re-evaluate their priorities rather than trying to force Casper onto users.", "Backwards Compatibility": "This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation. Therefore, it should be included in a scheduled hardfork at a certain block number.", "Test Cases": "Test cases shall be created once the specification is to be accepted by the developers or implemented by the clients.", "Implementations": "The yellow paper implements this change in https://github.com/ethereum/yellowpaper/pull/710", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- remove difficulty bomb: Suggests removing the difficulty bomb and setting a fixed difficulty targeting 15-second block times, providing economic participants with more control over network upgrades.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1355, "url": "https://eips.ethereum.org/EIPS/eip-1355", "title": "Ethash 1a", "authors": ["Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Jean M. Cyr\u00a0(", "@jean-m-cyr", ")"], "sections": {"EIP-1355: Ethash 1a": "Provide minimal set of changes to Ethash algorithm to hinder and delay the adoption of ASIC based mining.", "": "Provide minimal set of changes to Ethash algorithm to hinder and delay the adoption of ASIC based mining.", "Motivation": "Provide minimal set of changes to Ethash algorithm to hinder and delay the adoption of ASIC based mining.", "Specification": "The usual argument for decentralization and network security.", "Rationale": "The usual argument for decentralization and network security.", "FNV Primes": "The 16777639 satisfies all requirements fromWikipedia.", "Copyright": "This work is licensed under aCreative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- ethash 1a: Modifies the Ethash algorithm to hinder and delay ASIC-based mining by changing the hash function from fnv() to fnv1a().\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1682, "url": "https://eips.ethereum.org/EIPS/eip-1682", "title": "Storage Rent", "authors": ["Felix J Lange\u00a0(", "@fjl", ")", "Martin Holst Swende\u00a0(", "@holiman", ")"], "sections": {"EIP-1682: Storage Rent": "This EIP describes a scheme to charge for data in state, and \u2018archive\u2019 data which is no longer being paid for. It also describes how resurrection of \u2018archived\u2019 data happens.", "": "This EIP describes a scheme to charge for data in state, and \u2018archive\u2019 data which is no longer being paid for. It also describes how resurrection of \u2018archived\u2019 data happens.", "Abstract": "This EIP describes a scheme to charge for data in state, and \u2018archive\u2019 data which is no longer being paid for. It also describes how resurrection of \u2018archived\u2019 data happens.", "Motivation": "The Ethereum blockchain in its current form is not sustainable because it grows\nindefinitely. This is true of any blockchain, but Ethereum grows faster than most chains.\nMany implementation strategies to slow down growth exist. A common strategy is \u2018state\npruning\u2019 which discards historical state, keeping only the active copy of contract data\nand a few recent versions to deal with short-range chain reorganizations. Several\nimplementations also employ compression techniques to keep the active copy of the state as\nsmall as possible.", "Specification": "The cost of storing an account over time is calledrent. The amount ofrentdue depends\non the size of the account. Theetherthat is paid forrentis destroyed. Therentis deducted whenever an account is touched.", "Changes To State": "At the top level, a new keysizeis added to the accounts trie. This key tracks the\ntotal number of trie nodes across all accounts, including storage trie nodes. To track\nrent, the structure of account entries is changed as well.", "Charging Rent": "There is a new protocol constantMAX_STORAGE_SIZEthat specifies the upper bound on the\nnumber of state tree nodes:", "New EVM Opcodes": "At any time, therent balanceof an account may be topped up by thePAYRENTopcode.PAYRENTdeducts the given amount ofetherfrom the account executing the opcode and adds\nit to therent balanceof the address specified as beneficiary.", "Rationale": "Accounts need a separate rent balance because some contracts are non-payable, i.e. they\nreject regular value transfers. Such contracts might not be able to keep themselves alive,\nbut users of those contracts can keep them alive by paying rent for them.", "Why do we need a separate rent balance?": "Accounts need a separate rent balance because some contracts are non-payable, i.e. they\nreject regular value transfers. Such contracts might not be able to keep themselves alive,\nbut users of those contracts can keep them alive by paying rent for them.", "Why restoration?": "One of the fundamental guarantees provided by Ethereum is that changes to contract storage\ncan only be made by the contract itself and storage will persist forever. If you hold a\ntoken balance in a contract, you\u2019ll have those tokens forever. By adding restoration, we\ncan maintain this guarantee to a certain extent.", "Implementation Impact": "The proposed changes tries to fit within the existing state transition model. Note that\nthere is no mechanism for deactivating accounts the moment they can\u2019t pay rent. Users must\ntouch accounts to ensure their storage is removed because we\u2019d need to track all accounts\nand their rent requirements in an auxlilary data structure otherwise.", "Backwards Compatibility": "TBA", "Test Cases": "TBA", "Implementation": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- storage rent: Proposes a system where users must pay rent for storing data on the Ethereum blockchain, with accounts becoming inactive if they cannot pay. Inactive accounts can be restored by re-uploading their storage.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1706, "url": "https://eips.ethereum.org/EIPS/eip-1706", "title": "Disable SSTORE with gasleft lower than call stipend", "authors": ["Alex Forshtat\u00a0<", "alex@tabookey.com", ">", "Yoav Weiss\u00a0<", "yoav@tabookey.com", ">"], "sections": {"EIP-1706: Disable SSTORE with gasleft lower than call stipend": "The proposal that had been accepted changes security properties of a large portion of an existing contract code base that may be infeasible to update and validate. This proposal will make the old assumptions hold even after a network upgrade.", "": "The proposal that had been accepted changes security properties of a large portion of an existing contract code base that may be infeasible to update and validate. This proposal will make the old assumptions hold even after a network upgrade.", "Simple Summary": "The proposal that had been accepted changes security properties of a large portion of an existing contract code base that may be infeasible to update and validate. This proposal will make the old assumptions hold even after a network upgrade.", "Abstract": "EIP-1283significantly lowers the gas costs of writing to contract\u2019s storage. This created a danger of a new kind of reentrancy attacks on existing contracts as Solidity by default grants a \u2018stipend\u2019 of 2300 gas to simple transfer calls.\nThis danger is easily mitigated if SSTORE is not allowed in low gasleft state, without breaking the backward compatibility and the original intention of this EIP.", "Motivation": "An attack that is described inthis article.\nExplicitly specifying the call stipend as an invariant will have a positive effect on Ethereum protocol security: \nhttps://www.reddit.com/r/ethereum/comments/agdqsm/security_alert_ethereum_constantinople/ee5uvjt", "Specification": "Add the following condition to the SSTORE opcode gas cost calculation:", "Rationale": "In order to keep in place the implicit reentrancy protection of existing contracts, transactions should not be allowed to modify state if the remaining gas is lower then the 2300 stipend given to \u2018transfer\u2019/\u2019send\u2019 in Solidity.\nThese are other proposed remediations and objections to implementing them:", "Backwards Compatibility": "Performing SSTORE has never been possible with less than 5000 gas, so it does not introduce incompatibility to the Ethereum mainnet. Gas estimation should account for this requirement.", "Test Cases": "Test cases for an implementation are mandatory for EIPs that are affecting consensus changes. Other EIPs can choose to include links to test cases if applicable.\nTODO", "Implementation": "TODO", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1890, "url": "https://eips.ethereum.org/EIPS/eip-1890", "title": "Commitment to Sustainable Ecosystem Funding", "authors": ["Gregory Markou\u00a0<", "greg@chainsafe.io", ">", "Kevin Owocki\u00a0<", "kevin@gitcoin.co", ">", "Lane Rettig\u00a0<", "lane@ethereum.org", ">"], "sections": {"EIP-1890: Commitment to Sustainable Ecosystem Funding": "Ethereum currently provides a block reward to proof of work miners every block, but it does not capture any block rewards for ecosystem funding. This EIP adds a simple mechanism for capturing a portion of block rewards for ecosystem funding as a credible commitment to doing so in future, but it does not actually capture any such rewards.", "": "Ethereum currently provides a block reward to proof of work miners every block, but it does not capture any block rewards for ecosystem funding. This EIP adds a simple mechanism for capturing a portion of block rewards for ecosystem funding as a credible commitment to doing so in future, but it does not actually capture any such rewards.", "Commitment to Sustainable Ecosystem Funding": "Ethereum currently provides a block reward to proof of work miners every block, but it does not capture any block rewards for ecosystem funding. This EIP adds a simple mechanism for capturing a portion of block rewards for ecosystem funding as a credible commitment to doing so in future, but it does not actually capture any such rewards.", "Simple Summary": "Ethereum currently provides a block reward to proof of work miners every block, but it does not capture any block rewards for ecosystem funding. This EIP adds a simple mechanism for capturing a portion of block rewards for ecosystem funding as a credible commitment to doing so in future, but it does not actually capture any such rewards.", "Abstract": "A mechanism that allows specification of two parameters, a beneficiary address and a per-block reward denominated in wei, that allows a portion of block rewards to be captured for the purpose of ecosystem funding. Both values are set to zero.", "Motivation": "In order for Ethereum to succeed, it needs talented, motivated researchers and developers to continue to develop and maintain the platform. Those talented researchers and developers deserve to be paid fairly for their work. At present there is no mechanism in the Ethereum ecosystem that rewards R&D teams fairly for their work on the platform.", "Specification": "Two new constants are introduced: BENEFICIARY_ADDRESS, an Address, and DEVFUND_BLOCK_REWARD, an amount denominated in wei. Both are set to zero.", "Rationale": "We believe that the technical design of this EIP is straightforward. The social rationale is explained inthis article.", "Backwards Compatibility": "This EIP has no impact on backwards compatibility.", "Test Cases": "This EIP makes no changes to existing state transitions. Existing consensus tests should be sufficient.", "Implementation": "Reference implementations are included for the Trinity, go-ethereum, and parity clients.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- devfund_block_reward: Proposes adding a temporary block reward of 0.0055 ETH per block for 18 months to fund Eth1.x development and repay a community loan.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2025, "url": "https://eips.ethereum.org/EIPS/eip-2025", "title": "Block Rewards Proposal for funding Eth1.x", "authors": ["James Hancock\u00a0(", "@madeoftin", ")"], "sections": {"EIP-2025: Block Rewards Proposal for funding Eth1.x": "Add0.0055 ETHper block for 18 months (A total of 17050 ETH) as a developer block reward reserved for funding specific Ethereum1.X working groups. The working groups are State rent (750k), Better sync (360k), Finality gadget (360k), Fee market (360k), Testing infrastructure (360k). Governance of the funds will be through a multisig of trusted individuals from the ecosystem including client teams, the foundation, and the community.", "": "Add0.0055 ETHper block for 18 months (A total of 17050 ETH) as a developer block reward reserved for funding specific Ethereum1.X working groups. The working groups are State rent (750k), Better sync (360k), Finality gadget (360k), Fee market (360k), Testing infrastructure (360k). Governance of the funds will be through a multisig of trusted individuals from the ecosystem including client teams, the foundation, and the community.", "Simple Summary": "Add0.0055 ETHper block for 18 months (A total of 17050 ETH) as a developer block reward reserved for funding specific Ethereum1.X working groups. The working groups are State rent (750k), Better sync (360k), Finality gadget (360k), Fee market (360k), Testing infrastructure (360k). Governance of the funds will be through a multisig of trusted individuals from the ecosystem including client teams, the foundation, and the community.", "Abstract": "This EIP extends the mechanism established in EIP-1890 to add0.0055 ETHto the block reward for a specific distribution period of3,100,000 BLOCKS(\u2248 18 months). TheRECIPIENT_ADDRESSis set to a smart contract with hardcoded denominations that distributes incoming ETH to a set of addresses for the purpose of Eth1.X development. The emission schedule would start at the hard fork block number and continue for3,100,000 BLOCKS(\u2248 18 months) at which point the address and amount would again return to 0. Any further distribution would require a future hard fork.", "Motivation": "The context for this proposal came from attending theCore Dev Eth1.X Meetingin Berlin. Development is needed to move Eth1.X forward, and I observed that a lack of funding is the primary barrier to this work. This work can only be effectively conducted by working groups forming around these issues, and these working groups need funding in order to pay dedicated contractors and project managers. This proposal is a plan for funding these groups and supporting their operation.", "Specification": "Two constants will be introduced:", "Rewards Distribution Rationale": "With a price of Etheruem at $150.00 this will raise approx USD $2,325,000.00 for developing Eth1.X over the next 18 months.", "Rationale": "There has been great public debate concerning EIP-1890, and one of the primary concerns is that it is difficult to evaluate the proposal without more complete information on how funds would be raised, how they would be administered, and how they would be used. There is a need for funding Eth1.x development and it is currently unclear where those funds will come from. This proposal is intended to give a more comprehensive proposal for its funding. In the case that ETH1.x is fully funded before the Istanbul upgrade I will withdraw this EIP. Until that point I intend to continue championing this proposal as a valid funding mechanism for this work.", "Why a loan?": "The Eth1x initiative needs funding now, not in 18 months. A loan is necessary to complete certain stages of work before the funding mechanism begins to provide funds. A loan would provide this necessary funding today, and the investors willing to front this cost can recoup their contribution + a reward ofa fixed interest ratefor the risk on their loan. This arrangement will make it easier to find investors willing to participate who have sufficient funds.", "Loan Repayment": "", "Development Loan": "Development Loan: 0.005over 3.1 Million blocks = 15500 ETH", "Accountability": "The funds will be transferred into DAI and secured in a multi-sig comprised of members of the community. Representatives from the following groups will receive a key.", "Personal Notes and Disclosure": "I want to address any concerns about conflicts of interests directly. My participation with Eth1.X currently has been as a volunteer. I am in talks about a possible funded role helping with testing and coordination. If my work for with Eth1.x is funded, I will accept no additional funding collected by the mechanism proposed in this EIP.", "COI": "Previously I was PM for Tennagraph, a signalling solution for Ethereum. An Aragon grant funded this project and was distributed through Giveth and an AragonDAO. I have not received any funding from the project beyond this grant. All of this is verifiable on-chain. I am stepping down from any paid role on the project to continue as an advisor. I am also stepping down as a moderator for stances as there is a COI moderating stances for EIPs I am working with directly.", "Disclaimer": "I do not claim to represent the community with my views; any members who wish to join supporting me with this proposal are free to do so. This is as fair of a proposal as I can personally conceive.", "Backwards Compatibility": "This EIP has no impact on backwards compatibility.", "Test Cases": "Not Implemented", "Implementation": "Not Implemented", "FAQ": "Why not us a smart contract with some governance mechanism to allow changing the distribution of funds? Wouldn\u2019t that be more flexible and effective?", "Why Hardcoded Values?": "Why not us a smart contract with some governance mechanism to allow changing the distribution of funds? Wouldn\u2019t that be more flexible and effective?", "Why not allow current client implementors fund this work? (EF, Consensys, Parity, etc\u2026)": "Historically there has been a precedent that the Ethereum Foundation is solely responsible for funding the development of Ethereum. This process has evolved as the development has become more distributed. Aya Miyaguchi observed in a recentCoindesk article, \u201cit really is not only Ethereum Foundation people who are building [Ethereum]\u201d. Yes, we could rely on the Ethereum Foundation to fund Eth1.X. But, why should we? This is a call for the network to come together and fund its own development. Ethereumthe networkis not owned by any one organization or group of people. We are lucky to have the EF and I consider this EIP in support of their coordination efforts.", "How Will Funding the Devs be Organized": "I do not profess to know the best way to organize these funds. There is work already in progress to organize these efforts championed by Alexey Akhunov. The following is a quote from arecent medium article:", "Isn\u2019t a loan considered a security, or is it?": "I am not a lawyer and will seek further guidance from lawyers in the field on this point in particular. From the research I have done and conversations I have had there is a very good argument that a loan of this nature will not be considered a security by the US Supreme Court.\nAs the result ofREVES ET AL. v . ERNST YOUNG 1990, the court stated that a home loan, consumer financing, a loan secured by a lien on a small business or some assets of a small business, short term notes, or notes that formalize a debt incurred in the ordinary course of business are not securities. If the note resembles the items listed above (home loans, etc.) then the note will not be deemed a security. The Supreme Court provided four factors to determine if a note sufficiently resembles the types of notes that are not classified as securities. (source)", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2315, "url": "https://eips.ethereum.org/EIPS/eip-2315", "title": "Simple Subroutines for the EVM", "authors": ["Greg Colvin\u00a0(", "@gcolvin", ")", "Martin Holst Swende\u00a0(", "@holiman", ")", "Brooklyn Zelenka\u00a0(", "@expede", ")", "John Max Skaller\u00a0<", "skaller@internode.on.net", ">"], "sections": {"EIP-2315: Simple Subroutines for the EVM": "This proposal provides acomplete,efficient,safeandstaticcontrol-flow facility.", "Two opcodes for efficient, safe, and static subroutines.": "This proposal provides acomplete,efficient,safeandstaticcontrol-flow facility.", "Abstract": "This proposal provides acomplete,efficient,safeandstaticcontrol-flow facility.", "Motivation": "Jumps, conditional jumps and subroutines were proposed by Alan Turing in 1945 as a means of organizing the logic of the code and the design of the memory crystals for his Automatic Computing Engine:", "A complete control-flow facility.": "Jumps, conditional jumps and subroutines were proposed by Alan Turing in 1945 as a means of organizing the logic of the code and the design of the memory crystals for his Automatic Computing Engine:", "Efficient control-flow.": "Efficient to write by hand, compile from high level labguages, validate at deploy time, interpret by VMs, and compile to machine code.", "Safe control-flow.": "The EVM has unusually high requirements for safety.  Not only do many smart contracts control inordinately large amounts of valuable Ether, but once placed on the blockchain any defects are visible to attackers and cannot be repaired.  We propose to statically validate important safety constraints on code at initialization time.", "Static control-flow.": "The EVM\u2019s dynamic jumps cause two major problems. First, the need to synthesize static jumps and subroutines with dynamic jumps wastes space and gas with needlessly complex code, as we will show below.", "Specification": "Transfers control to a subroutine.", "Opcodes": "Transfers control to a subroutine.", "Validity": "Executionis defined in the Yellow Paper as a sequence of changes in the EVM state.  The conditions on valid code are preserved by state changes.  At runtime, if execution of an instruction would violate a condition the execution is in an exceptional halting state.  The Yellow Paper defines six such states.", "Rationale": "This is a purely semantic specification, placing no constraints on the syntax of code sections beyond being a sequence of opcodes and immediate data \u2013 a subroutine is not a contiguous sequence of bytecode, it is a subgraph of the bytecode\u2019s control-flow graph.  The EVM is a simple state machine.  We only promise that valid code will not, as it were, jam up the gears of the machine.", "Validation": "Rather than enforce constraints via syntax, we enforce them via validation.", "Alternative Designs": "There are a few major designs for a subroutine facility, two of which are considered here.  The others are mostly not appropriate for the EVM, such as the Wheeler Jump \u2013 self-modifying code that writes return addresses into called subroutines.", "Efficiency": "We illustrate here how subroutine instructions can be used to reduce the complexity and gas costs of both ordinary and optimized subroutine calls compared to usingJUMP.", "Costs": "Thelowcost ofRJUMPSUBversus themidcost ofJUMPis justified by needing only to decode the immediate two byte destination to thePCand push the return address on thereturn stack, all using native arithmetic, versus using the data stack with emulated 256-bit instructions.", "Backwards Compatibility": "These changes affect the semantics of existing EVM code: bytes that would have been interpreted as valid jump destinations may now be interpreted as immediate data.  Since this proposal depends on the Ethereum Object Format to signal the change this is not a practical issue.", "Test Cases": "This should jump into a subroutine, back out and stop.", "Simple routine": "This should jump into a subroutine, back out and stop.", "Two levels of subroutines": "This should execute fine, going into one two depths of subroutines", "Failure 1: invalid jump": "This should fail, since the given location is outside of the code-range.", "Failure 2: shallowreturn stack": "This should fail at first opcode, due to shallowreturn_stack", "Subroutine at end of code": "In this example the RJUMPSUB is on the last byte of code. When the subroutine returns, it should hit the \u2018virtual stop\u2019afterthe bytecode, and not exit with error", "Reference Implementation": "The following is a pseudo-Python implementation of an algorithm for predicating code validity.  An equivalent algorithm must be run at initialization time.", "Validation Function": "** Note: this function is known to be incomplete and incorrect. **", "Security Considerations": "These changes introduce new flow control instructions.  They do not introduce any new security considerations. This EIP is intended to improve security by validating a higher level of safety for EVM code deployed on the blockchain.  The validation algorithm must be quasi-linear in time and space to not be a denial of service vulnerability.  The algorithm here makes one linear-time pass of the bytecode, and uses a stack of continuations that cannot exceed the number ofRJUMPIinstructions in the code.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2677, "url": "https://eips.ethereum.org/EIPS/eip-2677", "title": "Limit size of `initcode`", "authors": ["Martin Holst Swende\u00a0(", "@holiman", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-2677: Limit size of `initcode`": "Enforce a maximum size limit (max_initcode_size) of49152(0xc000) forinitcode.", "": "Enforce a maximum size limit (max_initcode_size) of49152(0xc000) forinitcode.", "Simple Summary": "Enforce a maximum size limit (max_initcode_size) of49152(0xc000) forinitcode.", "Abstract": "Enforce a maximum size limit (max_initcode_size) forinitcode. If the size ofinitcodeexceedsmax_initcode_size, then contract creation fails with an out of gas error.", "Motivation": "When a client executesinitcode, the client has to perform a jumpdest analysis. In some cases, the client also performs ahashof the code:", "Specification": "There are three situations where this is applicable:", "Rationale": "TBA", "Backwards Compatibility": "This EIP requires a \u201cnetwork upgrade\u201d, since it modifies consenus-rules.", "Security Considerations": "For client implementations, this EIP makes attacks based on jumpdest-analysis or hashing of code less problematic, so should increase the robustness of clients.", "Test Cases": "Test cases should include the following cases,", "Implementation": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- max_initcode_size: The maximum size for EOF contract initialization code is set to 128 KiB, reflecting the updated MAX_CODE_SIZE.\n- initcode: The code executed by a contract at its initialization, which must be within 49152 bytes in size before EIP-3860.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2711, "url": "https://eips.ethereum.org/EIPS/eip-2711", "title": "Sponsored, expiring and batch transactions.", "authors": ["Micah Zoltu\u00a0(", "@MicahZoltu", ")"], "sections": {"EIP-2711: Sponsored, expiring and batch transactions.": "Creates a new transaction type that supports sponsored transactions (separate gas payer from sender), batch transactions (multiple transactions executed in sequence), and expiring transactions (transactions which are not valid after a certain timestamp).", "": "Creates a new transaction type that supports sponsored transactions (separate gas payer from sender), batch transactions (multiple transactions executed in sequence), and expiring transactions (transactions which are not valid after a certain timestamp).", "Simple Summary": "Creates a new transaction type that supports sponsored transactions (separate gas payer from sender), batch transactions (multiple transactions executed in sequence), and expiring transactions (transactions which are not valid after a certain timestamp).", "Abstract": "An EIP-2718 transaction with the type number2is a new type of transaction that includes support for:", "Motivation": "With the advent of tokens and especially stable coins, it has become common for users to not hold ETH in an account while they may have other assets of value in that account.  Some users don\u2019t want to be exposed to the perceived volatility of ETH and instead would prefer to transact using other assets.  Unfortunately, since gasMUSTbe paid for with ETH, this prevents the user from transacting with their assets without first acquiring some ETH using some other means, and then using that ETH to pay fees.", "Sponsored Transactions": "With the advent of tokens and especially stable coins, it has become common for users to not hold ETH in an account while they may have other assets of value in that account.  Some users don\u2019t want to be exposed to the perceived volatility of ETH and instead would prefer to transact using other assets.  Unfortunately, since gasMUSTbe paid for with ETH, this prevents the user from transacting with their assets without first acquiring some ETH using some other means, and then using that ETH to pay fees.", "Batch Transactions": "Often times an EOA may want to execute a series of transactions with a strong guarantee that they happen in order with nothing occurring between them.  For example, one may want to send some tokens to a contract and then follow that up with another transaction that makes a contract call on the destination address that causes those tokens to be registered to them.  By supporting transaction batching at layer 1, we can ensure that the user can get strong guarantees at signing time of cross-transaction atomicity.", "Expiring Transactions": "TransactionType2.  SeeEIP-2718", "Specification": "TransactionType2.  SeeEIP-2718", "Definitions": "TransactionType2.  SeeEIP-2718", "New Transaction Type": "As ofFORK_BLOCK_NUMBERanEIP-2718transaction with aTransactionTypeof2will have itsPayloadinterpreted as an RLP encoded tuple of:", "New Transaction Receipt": "As ofFORK_BLOCK_NUMBERanEIP-2718transaction receipt with aTransactionTypeof2will have itsPayloadinterpreted as arlp([status, cumulativeGasUsed, logsBloom, logs][])where each item of the array corresponds to the child-transaction at matching offset in the transaction type 2Payload.", "Rationale": "This EIP could be split up into multiple EIPs, one for each of the subtypes and one for the meta-type.  Alternatively, each of the subtypes could be a unique TransactionType.  The reason we chose to go with a single EIP with subtypes is because these 4 transactions all have alotin common and each separate EIP would be almost identical to the previous.  We felt that in this case, splitting into multiple EIPs wasn\u2019t worth the duplication of EIP content.", "One Monolithic EIP": "This EIP could be split up into multiple EIPs, one for each of the subtypes and one for the meta-type.  Alternatively, each of the subtypes could be a unique TransactionType.  The reason we chose to go with a single EIP with subtypes is because these 4 transactions all have alotin common and each separate EIP would be almost identical to the previous.  We felt that in this case, splitting into multiple EIPs wasn\u2019t worth the duplication of EIP content.", "ChainID not encoded withv": "While we could save one byte in the common case by bundling the y-parity bit of the signature with the Chain ID like in EIP-155, this adds complexity to signing tools that the authors deem not worth it given the size of the transaction overall.", "Optionality of ChainID": "Sometimes it is useful to have a transaction thatcanbe replayed on multiple chains.  An example of this is when you construct a vanity signature for a transaction and have thefrombe whatever address that signature recovers to.  With the ability to have someone else be a gas payer (setting both the gas limit and the gas price), one can have transactions that deploy contracts which live at the same address on every chain.  While this can be accomplished with CREATE2 using legacy transactions, we have the opportunity here to simplify the process and enable potentially other future uses of deterministic transactions by making ChainID optional.", "Optionality of ValidUntil": "A user can setValidUntilto a very large number which effectively makes it non-expiring.  By makingValidUntiloptional, we can save some bytes on the wire by allowing such transactions to simply have a0(1 byte in RLP) value for this field.", "SENDERsetsgasLimitandgasPrice": "This type of transaction is useful when the transaction may execute differently depending on what these values are set to.  By having theSENDERset both, we ensure that theSENDERhas full control over the transaction details.", "SENDERsetsgasLimit,GAS_PAYERsetsgasPrice": "This type of transaction is useful when the transaction may execute differently depending on how much gas it is allowed (e.g., number of loops) but where theSENDERwould like to give theGAS_PAYERthe ability to price the transaction to maximize chances of inclusion.", "GAS_PAYERsetsgasLimitandgasPrice": "This type of transaction allows theSENDERto define what they want to do, and leaves all worry about gas to theGAS_PAYER.  This is useful for transactions where the sender doesn\u2019t care how much gas is used or the price that is paid and also either trusts theGAS_PAYERto be non-malicious or doesn\u2019t care if theSENDER\u2019s nonce is increased.  Such situations are useful when you have extra-protocol trust between theSENDERandGAS_PAYERand you want to separate concerns (what to do vs how to get included) for security or complexity reasons.", "Nonces": "The inner transaction needs a nonce to protect themselves from replay attacks.  Since the inner transaction has a nonce, we get replay protection on the outer transaction as well, so it is not critical for security to have multiple parties provide a nonce.", "ValidUntil": "For the dust-account clearing usecase,", "ValidUntil as timestamp instead of block number": "No known issues.", "Backwards Compatibility": "No known issues.", "Test Cases": "Copyright and related rights waived viaCC0.", "Implementation": "Copyright and related rights waived viaCC0.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2733, "url": "https://eips.ethereum.org/EIPS/eip-2733", "title": "Transaction Package", "authors": ["Matt Garnett\u00a0(", "@lightclient", ")"], "sections": {"EIP-2733: Transaction Package": "Creates a new transaction type which executes a package of one or more\ntransactions, while passing status information to subsequent transactions.", "": "Creates a new transaction type which executes a package of one or more\ntransactions, while passing status information to subsequent transactions.", "Simple Summary": "Creates a new transaction type which executes a package of one or more\ntransactions, while passing status information to subsequent transactions.", "Abstract": "Introduce a new transaction type which includes a list of transactions that\nmust be executed serially by clients. Execution information (e.g. success,\ngas_used, etc.) will be propagated forward to the next transaction.", "Motivation": "Onboarding new users to Ethereum has been notoriously difficult due to the need\nfor new users to acquire enough ether to pay for their transactions. This\nhurdle has seen a significant allocation of resources over the years to solve.\nToday, that solution is meta-transactions. This is, unfortunately, a brittle\nsolution that requires signatures to be recovered within a smart contract to\nauthenticate the message. This EIP aims to provide a flexible framework for\nrelayers to \u201csponsor\u201d many transactions at once, trustlessly.", "Specification": "Introduce a newEIP-2718transaction type whereid = 2.", "Validity": "ATransactionPackagecan be deemed valid or invalid as follows.", "Results": "SubsequentChildTransactions will be able to receive the result of the\npreviousChildTransactionviaRETURNDATACOPY (0x3E)in first frame of\nexecution, before making any subcalls. Each element, except the last, will be0-padded left to 32 bytes.", "Intrinsic Cost": "Let the intrinsic cost of the transaction package be defined as follows:", "Execution": "Transaction packages should be executed as follows:", "Rationale": "For simplicity, the author has chosen to require each child package to specify\nits own signature, even if the signer is the same as the package signer. This\nchoice is made to allow for maximum flexibility, with minimal client changes.\nThis transaction can still be used by a single user at the cost of only one\nadditional signature recovery.", "EachChildhas its own signature": "For simplicity, the author has chosen to require each child package to specify\nits own signature, even if the signer is the same as the package signer. This\nchoice is made to allow for maximum flexibility, with minimal client changes.\nThis transaction can still be used by a single user at the cost of only one\nadditional signature recovery.", "ChildPackagespecifiesmax_gas_priceinstead ofgas_price": "Allowing child packages to specify a range of acceptable gas prices is\nstrictly more versatile than a static price. It gives relayers more flexibility\nin terms of building transaction bundles, and it makes it possible for relayers\nto try and achieve the best price for the transaction sender. With a fixed\nprice, the relayer may require the user to sign multiple different\ntransactions, with varying prices. This can be avoided by specifying a max\nprice, and communicating out-of-band how the urgency of the transaction (e.g.\nthe relayer should package it with the max price immediately vs. slowly\nincreasing the gas price).\nA future transaction type can be specified with only a single\nsignature, if such an optimization is desired.", "ChildPackageis also typed": "The type element serves a modest role in the transaction type, denoting whether\nthe transaction signer wishes to delegate control of the gas price and gas\nlimit to the outer signer. This is a useful UX improvement when interacting\nwith a trusted relayer, as once the user decides to make a transaction the\nrelayer can ensure it is included on chain by choosing the best gas price and\nlimit.", "Theflagsandextrafields aren\u2019t used": "These fields are included to better support future changes to the transaction\ntype. This would likely be used in conjunction with theflagsandtypefields. A benefit of explicitly defining them is that specialized serialization\nof RLP can be avoided, simplifying clients and downstream infrastructure. The\nauthor believe the cost of 2 bytes per transaction is acceptable for smoother\nintegration of future features.", "Backwards Compatibility": "Contracts which rely onORIGIN (0x32) == CALLER (0x33) && RETURNDATASIZE\n(0x3D) == 0x00will now always fail in transaction packages, unless they are\nthe first executed transaction. It\u2019s unknown if any contracts conduct this\ncheck.", "Test Cases": "TBD", "Implementation": "TBD", "Security Considerations": "The introduction of a new transaction type brings along new concerns regarding\nthe mempool. Done naively, it could turn into a DDoS vector for clients. This\nEIP has been written to reduce as much validation complexity as possible.", "Managing packages efficiently in the mempool": "The introduction of a new transaction type brings along new concerns regarding\nthe mempool. Done naively, it could turn into a DDoS vector for clients. This\nEIP has been written to reduce as much validation complexity as possible.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- transaction package: Introduces a transaction type that allows a package of transactions to be executed serially, with information passed from one transaction to the next.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2780, "url": "https://eips.ethereum.org/EIPS/eip-2780", "title": "Reduce intrinsic transaction gas", "authors": ["Matt Garnett\u00a0(", "@lightclient", ")", "Uri Klarman\u00a0(", "@uriklarman", ")"], "sections": {"EIP-2780: Reduce intrinsic transaction gas": "Reduce the intrinsic cost of a transaction from21,000to7,000gas.", "": "Reduce the intrinsic cost of a transaction from21,000to7,000gas.", "Abstract": "Reduce the intrinsic cost of a transaction from21,000to7,000gas.", "Motivation": "The current21,000gas intrinsic cost of a transaction makes sending ETH very costly, often times prohibitively costly for small amounts (tens of USD).\nWhile broad changes to the gas price and first price auction are being considerted in other EIPs (like EIP-1559),\nsubstantially reducing the cost of sending ETH and enabling higher volumes of such transactions would be a net positive if done in a safe manner,\nand without imposing negative externalities, as outlined below.", "Specification": "Afterblock.number >= FORK_BLOCK, enforce an intrinsic gas cost of7,000.", "Rationale": "The proliferation of calls to DeFi smart-contracts had substantially increased the cost of making transactions,\nsince such calls are usually both time sensitive and involve large sums of money.\nWhile the utilization of the chain\u2019s capacity by the most valuable transactions is by design,\nthe high cost of sending transactionsz is limiting Ethereum\u2019s the use-cases,\ncreate a terribel user experience,\ndecreases the actual value created (and captured) by ETH,\nand pushes users to seek alternatives in other, less-congested chains.", "Backwards Compatibility": "This EIP is backward compatible as well as compatible with other approaches pursued in other EIPs.", "Test Cases": "While the benefits of reducing transactions\u2019 intrinsic cost are appearant,\nsuch a change should be applied if it impose no negative externalities,\nor if such effects are negligible.", "Implementation": "TBD", "Security Considerations": "The growth of Ethereum\u2019s state size continues to raise concerns among members of the community.\nHowever, an analysis of Ethereum accounts shows that their effect on stat size is negligible.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- reduce intrinsic transaction gas: Proposes lowering the intrinsic gas cost of a transaction from 21,000 to 7,000 gas, making ETH transactions more affordable.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2972, "url": "https://eips.ethereum.org/EIPS/eip-2972", "title": "Wrapped Legacy Transactions", "authors": ["Micah Zoltu\u00a0(", "@MicahZoltu", ")"], "sections": {"EIP-2972: Wrapped Legacy Transactions": "Two new transaction types for wrapping legacy transactions with and without a chain ID.", "": "Two new transaction types for wrapping legacy transactions with and without a chain ID.", "Simple Summary": "Two new transaction types for wrapping legacy transactions with and without a chain ID.", "Abstract": "Introduces two newEIP-2718transactions that are signature compatible with legacy transactions and can be automatically upgraded by any client.", "Motivation": "We would like to eventually deprecate legacy transactions so we no longer have to retain code in the networking and signer layer that deals with them.\nHowever, we also want to ensure that signatures for transactions that were generated prior to that deprecation are still valid and funds don\u2019t end up stuck because of an inability to sign a new style transaction.\nThis EIP provides a mechanism for transmitting/including transactions in a way that isEIP-2718compatible while still being signature compatible with legacy transactions.", "Specification": "As ofFORK_BLOCK_NUMBER,0x00 || ssz.serialize(yParity, r, s, rlp([nonce, gasPrice, gasLimit, to, value, data]))will be a valid transaction where:", "Definitions": "As ofFORK_BLOCK_NUMBER,0x00 || ssz.serialize(yParity, r, s, rlp([nonce, gasPrice, gasLimit, to, value, data]))will be a valid transaction where:", "Transactions": "As ofFORK_BLOCK_NUMBER,0x00 || ssz.serialize(yParity, r, s, rlp([nonce, gasPrice, gasLimit, to, value, data]))will be a valid transaction where:", "Receipts": "As ofFORK_BLOCK_NUMBER,0 || ssz.serialize(status, cumulativeGasUsed, logsBloom, logs)will be a valid receipt where:", "Rationale": "These transaction types are explicitly designed to be signature compatible with legacy transactions, which means we cannot change the data being signed.\nSee Security Considerations section for more details.", "Signature doesn\u2019t include transaction type as first signature byte": "These transaction types are explicitly designed to be signature compatible with legacy transactions, which means we cannot change the data being signed.\nSee Security Considerations section for more details.", "Two transaction types instead of one": "With the introduction of typed transactions, we no longer need to do bit packing to avoid changing the shape of the signature.\nLegacy transactions introduced chain ID inEIP-155and wanted to avoid changing the transaction array length, so it bitpacked the chainID into the signature\u2019svvalue.\nSince we no longer need to guarantee consistent payload lengths between transaction types, we have opted to have two transaction types with clear fields.", "Signature separate from signed data": "When validating a signature, one must first separate out the signed data from the signature and then validate the signature against the signed data.\nIn the case of legacy transactions, this was a bit of a burden since you had to first RLP decode the transaction, then extract out the signature, then RLP encode a subset of the transaction.\nEIP-155 made this process even worse by requiring the validator to further decode thevsignature value to extract the chain ID (if present) and include that in the signed data payload.\nBy having the signed data encoded exactly as it is signed, we make it so one can verify the transaction\u2019s signature without having to do any decoding before hand.\nBy having the signature SSZ encoded up front, we can easily extract the signature without even having to use a decoder.", "SSZ for serialization": "There is a weak consensus that RLP is not a particularly good encoding scheme for hashed data partially due to its inability to be streamed.\nSSZ is almost certainly going to be included in Ethereum at some point in the future, so clients likely have access to an SSZ decoder.\nFor this particular case, manual decoding without a full SSZ decoder isn\u2019t too complicated, though it does require doing a bit of \u201cpointer math\u201d sincelogsis an array of variable length items.", "Deprecating legacy transactions": "By deprecating legacy transactions, we make it easier for clients as they can always deal with typed transactions in blocks.", "Max length of logs and logs data": "EIP-706limits devp2p messages to 24 bit length, which gives us a pragmatic cap at that for any single transaction at the moment.\nThis number seems to far exceed what is reasonable anytime in the near future, so feels like as reasonable of a cap as any.", "Backwards Compatibility": "The new transactions are signature compatible with legacy transactions.\nLegacy transactions can be decoded and then encoded as type 0 or type 1 transactions.\nThis EIP does not introduce any deprecation process for legacy encoded transactions, though the authors do encourage client developers to upgrade legacy encoded transactions to typed transactions as soon as it is reasonable.", "Test Cases": "TBD", "Implementation": "TBD", "Security Considerations": "WhileEIP-2718strongly recommends including the transaction type as the first byte of the signed data, we cannot accomplish that in this case because we need to remain signature compatible with legacy transactions.\nLuckily,EIP-2718also excludes transaction types0xc0to0xfefrom valid transaction types, and the first byte of the signature in this case is in that range so we can be sure this will not conflict with any future transaction types.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- devp2p: A networking protocol for Ethereum. EIP-8 introduces forward compatibility requirements for devp2p implementations .\n- wrapped legacy transactions: Defines two new transaction types that wrap legacy transactions with and without a chain ID, maintaining signature compatibility with older transactions.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3332, "url": "https://eips.ethereum.org/EIPS/eip-3332", "title": "MEDGASPRICE Opcode", "authors": ["Justice Hudson\u00a0(", "@jchancehud", ")"], "sections": {"EIP-3332: MEDGASPRICE Opcode": "An opcode for getting the median gas price of the parent block.", "": "An opcode for getting the median gas price of the parent block.", "Simple Summary": "An opcode for getting the median gas price of the parent block.", "Abstract": "AddsMEDGASPRICE (0x46)opcode that returns the median gas price for the parent block.", "Motivation": "With the emergence of rollups as core mechanisms in scaling Ethereum there are a number of common transactions that can be front-run. Optimistic rollups rely on the submission of fraud proofs to maintain the integrity of their systems. As a result actors submitting fraud proofs typically receive a financial reward for doing so. This opens a trivial front-running strategy of watching the mempool for fraud proof submissions and copying such transactions with a much higher gas price to reap the reward. Such front-runners do not perform validation independently and de-incentivize others from performing validation. Adding a mechanism enforcing an upper bound on gas prices for a transaction could be an effective defense against such front-running attacks.", "Forwards Compatibility": "EIP-1559plans to change the fee market in a number of ways. Most notably is the creation of a base fee that is burned. In this context an \u201cinclusion fee\u201d still exists as a part of the total fee. Consider the following two cases:", "Specification": "Ifblock.number >= TBD, add a new opcodeMEDGASPRICE (0x46):", "Rationale": "Having access to the current gas price economy allows contracts to implement more robust and automated logic surrounding acceptable transaction gas prices.", "Naming note": "The nameMEDGASPRICEwas chosen because the median gas price of the network can only be calculated from the latest complete block. Thus transactions being executed should expect the median gas price to be calculated from the previous block.", "Backwards Compatibility": "There are no known backwards incompabitility issues.", "Security Considerations": "The strategy described for preventing front-running by setting an upper bound on the gas price of transactions has a few caveats:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- medgasprice opcode: Introduces the MEDGASPRICE opcode, allowing contracts to access the median gas price of the parent block, useful for setting maximum gas prices and mitigating front-running attacks.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3338, "url": "https://eips.ethereum.org/EIPS/eip-3338", "title": "Limit account nonce to 2^52", "authors": ["Micah Zoltu\u00a0(", "@MicahZoltu", ")", "Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-3338: Limit account nonce to 2^52": "Limit account nonce to be between0and2^52.", "": "Limit account nonce to be between0and2^52.", "Abstract": "Limit account nonce to be between0and2^52.", "Motivation": "Account nonces are currently specified to be arbitrarily long unsigned integers. Dealing with arbitrary length data in the state witnesses is not optimal, therefore this EIP will allow proofs to represent the nonce in a more optimized way.", "Specification": "Ifblock.number >= FORK_BLOCKintroduce two new restrictions:", "Rationale": "While this is a breaking change, no actual effect should be visible:", "Backwards Compatibility": "While this is a breaking change, no actual effect should be visible:", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- limit account nonce: Limits the account nonce to a maximum value of 2^64-1, improving proof representation and optimizing client storage.\n- limit account nonce to 2^52: Proposes limiting Ethereum account nonces to a maximum of 2^52 to simplify state witness handling and optimize transaction processing.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3374, "url": "https://eips.ethereum.org/EIPS/eip-3374", "title": "Predictable Proof-of-Work (POW) Sunsetting", "authors": ["Query0x\u00a0(", "@Query0x", ")"], "sections": {"EIP-3374: Predictable Proof-of-Work (POW) Sunsetting": "Sets block reward to 3 and reduces it to 1 linearly over the course of about 1 year.", "": "Sets block reward to 3 and reduces it to 1 linearly over the course of about 1 year.", "Simple Summary": "Sets block reward to 3 and reduces it to 1 linearly over the course of about 1 year.", "Abstract": "Sets the block reward to 3 ETH and then incrementally decreases it every block for 2,362,000 blocks (approximately 1 year) until it reaches 1 ETH.", "Motivation": "Unnecessarily abrupt changes to the Ethereum ecosystem cause disruption and disharmony resulting in the disenfranchisement of community members while undermining stability and confidence.  While moves from Proof-of-Work to Proof-of-Stake will undoubtedly cause friction between those community members vested in either, all benefit from a measured, predictable transition.", "Specification": "Picking starting and ending block reward values that are equidistant from the current block reward rate of 2 ensures the impact of this EIP will be issuance neutral over the one year time frame.  Temporarily raising the block reward to 3 blunts the initial impact of a sudden miner revenue decrease and the continual reductions thereafter codify Ethereum\u2019s move to POS by increasingly disincentivizing POW.  Importantly, this approach moderates the rate of change so impacts and threats can be measured and monitored.", "Constants": "Picking starting and ending block reward values that are equidistant from the current block reward rate of 2 ensures the impact of this EIP will be issuance neutral over the one year time frame.  Temporarily raising the block reward to 3 blunts the initial impact of a sudden miner revenue decrease and the continual reductions thereafter codify Ethereum\u2019s move to POS by increasingly disincentivizing POW.  Importantly, this approach moderates the rate of change so impacts and threats can be measured and monitored.", "Rationale": "Picking starting and ending block reward values that are equidistant from the current block reward rate of 2 ensures the impact of this EIP will be issuance neutral over the one year time frame.  Temporarily raising the block reward to 3 blunts the initial impact of a sudden miner revenue decrease and the continual reductions thereafter codify Ethereum\u2019s move to POS by increasingly disincentivizing POW.  Importantly, this approach moderates the rate of change so impacts and threats can be measured and monitored.", "Backwards Compatibility": "There are no known backward compatibility issues with the introduction of this EIP.", "Security Considerations": "There are no known security issues with the introduction of this EIP.", "Copyright": "Copyright and related rights waived via CC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3382, "url": "https://eips.ethereum.org/EIPS/eip-3382", "title": "Hardcoded Block Gas Limit", "authors": ["Philippe Castonguay\u00a0(", "@PhABC", ")"], "sections": {"EIP-3382: Hardcoded Block Gas Limit": "Hardcode the block gas limit to12,500,000gas per block.", "": "Hardcode the block gas limit to12,500,000gas per block.", "Simple Summary": "Hardcode the block gas limit to12,500,000gas per block.", "Abstract": "Updates the block validation rules such that a block is invalid if thegas_limitheader field is not equal to12,500,000.", "Motivation": "Both Ethereum\u2019s Proof of Work and Proof of Stake designs assume that block producers are financially rational, but does not assume block producers to be benevolent. There is one exception however, and it is when block producers choose the gas limit of a block where it is assumed that block producers care about the long term health and decentralisation of the chain. Indeed, the block gas limit is one of the only parameters in Ethereum that is not dictated by node consensus, but instead is chosen by block producers. This decision was initially made to allow urgent changes in the block gas limit if necessary. Both drastically increasing or decreasing this parameter could have serious consequences that may not be desired. It is therefore a critical parameter that should require node consensus to avoid any sudden harmful change imposed by a small number of actors on the rest of the network.", "Specification": "Refer togasLimitasgasTargetpost EIP-1559.", "Added Consensus Constraint": "As ofFORK_BLOCK_NUMBER, theheader.gasLimitMUSTbe equal toBLOCK_GAS_LIMIT, whereBLOCK_GAS_LIMITis a hardcoded constant set to12,500,000.", "Rationale": "While it would be possible to remove thegasLimitfield from block headers, it would change the data structure to be hashed, which could lead to unintended consequences. It is therefore easier to leave the gasLimit as part of block headers.", "Keeping gasLimit in Block Headers": "While it would be possible to remove thegasLimitfield from block headers, it would change the data structure to be hashed, which could lead to unintended consequences. It is therefore easier to leave the gasLimit as part of block headers.", "Chosen Gas Limit": "The12,500,000value is being proposed as it\u2019s the current block gas limit as of time of writing this EIP. The actual amount could be altered with a subsequent EIP to avoid deviating from the core intent of this EIP.", "Backwards Compatibility": "This EIP is backward compatible.", "Security Considerations": "Rapid changes to the gas limit will likely be more difficult to execute, which could be problematic if an urgent situation arise that required changing the gas limit.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- hardcoded block gas limit: Hardcodes the block gas limit to 12.5 million gas, preventing miners from adjusting the gas limit and ensuring consistency across blocks.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3779, "url": "https://eips.ethereum.org/EIPS/eip-3779", "title": "Safer Control Flow for the EVM", "authors": ["Greg Colvin\u00a0(", "@gcolvin", ")", "Greg Colvin\u00a0<", "greg@colvin.org", ">", "Brooklyn Zelenka\u00a0(", "@expede", ")"], "sections": {"EIP-3779: Safer Control Flow for the EVM": "We define a safe EVM contract as one that cannot encounter an exceptional halting state.  In general, we cannot prove safety for Turing-complete programs. But we can prove a useful subset.", "Ensure an essential level of safety for EVM code.": "We define a safe EVM contract as one that cannot encounter an exceptional halting state.  In general, we cannot prove safety for Turing-complete programs. But we can prove a useful subset.", "Abstract": "We define a safe EVM contract as one that cannot encounter an exceptional halting state.  In general, we cannot prove safety for Turing-complete programs. But we can prove a useful subset.", "Motivation": "For our purposes we define a safe EVM contract as one that cannot encounter an exceptional halting state.  From the standpoint of security it would be best if unsafe contracts were never placed on the blockchain.  Unsafe code can attempt to overflow stack, underflow stack, execute invalid instructions, and jump to invalid locations.", "Safety": "For our purposes we define a safe EVM contract as one that cannot encounter an exceptional halting state.  From the standpoint of security it would be best if unsafe contracts were never placed on the blockchain.  Unsafe code can attempt to overflow stack, underflow stack, execute invalid instructions, and jump to invalid locations.", "Performance": "Validating safe control flow at initialization time has potential performance advantages.", "Specification": "We define asafeEVM contract as one that cannot encounter an exceptional halting state.  We validatesafetyat initialization time to the extent practical.", "Validity": "We define asafeEVM contract as one that cannot encounter an exceptional halting state.  We validatesafetyat initialization time to the extent practical.", "Rationale": "Demandingstaticdestinations for all jumps means that all jump destinations can be validated at initialization time, not runtime.", "Backwards Compatibility": "These changes affect the semantics of EVM code \u2013 the use ofJUMP,JUMPI, and the stack are restricted, such that somecodethat would otherwise run correctly will nonetheless be invalid EVMcode.", "Reference Implementation": "The following is a pseudo-Go implementation of an algorithm for predicating code validity.  An equivalent algorithm must be run at initialization time.", "Validation Function": "Note:This function is a work in progress, and the version below is known to be incorrect.", "Security Considerations": "This EIP is intended to ensure an essential level of safety for EVM code deployed on the blockchain.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- safer control flow for the evm: Defines safety rules for EVM control flow, ensuring that contracts cannot halt due to invalid jumps or stack underflows.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6913, "url": "https://eips.ethereum.org/EIPS/eip-6913", "title": "SETCODE instruction", "authors": ["William Morriss\u00a0(", "@wjmelements", ")"], "sections": {"EIP-6913: SETCODE instruction": "Introduce theSETCODE(0xfc) instruction, which replaces the code of the executing account from memory.", "new instruction to replace code in-place": "Introduce theSETCODE(0xfc) instruction, which replaces the code of the executing account from memory.", "Abstract": "Introduce theSETCODE(0xfc) instruction, which replaces the code of the executing account from memory.", "Motivation": "Many contracts are upgradeable in order to facilitate improvement or defer decisions without migrating to a new address.\nContracts presently do this in several ways:", "Specification": "When within a read-only execution scope like the recursive kind created bySTATICCALL,SETCODEcauses an exceptional abort.", "Gas": "The gas cost of this operation is the sum ofGselfdestructand the product ofGcodedepositand the number of bytes in the new code.", "Rationale": "The behavior ofCODECOPY,CODESIZE,EXTCODESIZE, andEXTCODECOPYmatch the behavior ofDELEGATECALLandCREATE, where it is also possible for executing code to differ from the code of the executing account.", "Backwards Compatibility": "The only prior operation changing code isSELFDESTRUCT.\nAs code modification viaSELFDESTRUCTis deferred until the end of the transaction, its interactions withSETCODEare well-defined.", "Test Cases": "Risks related toSETCODEsimilarly apply to other upgrade patterns.", "Security Considerations": "Risks related toSETCODEsimilarly apply to other upgrade patterns.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- setcode: Introduces the SETCODE opcode (0xfc) that allows contracts to replace their code in place, avoiding the need for SELFDESTRUCT and preserving internal state."}
{"eip": 7664, "url": "https://eips.ethereum.org/EIPS/eip-7664", "title": "Access-Key opcode", "authors": ["Diederik Loerakker\u00a0(", "@protolambda", ")"], "sections": {"EIP-7664: Access-Key opcode": "This EIP introduces a new opcode to inspect the access-list keys of the executing address.", "The access-key opcode enables contracts to read inputs that are statically declared in access-lists.": "This EIP introduces a new opcode to inspect the access-list keys of the executing address.", "Abstract": "This EIP introduces a new opcode to inspect the access-list keys of the executing address.", "Motivation": "This EIP serves as a substitute of top-level-call detection to enable a smart-contract to \nenforce static declaration of attributes.", "Specification": "We add an instructionACCESS_KEY(with opcodeACCESS_KEY_OPCODE_BYTE) which popsindexfrom the top\nof the stack as big-endianuint256, and pushestx.access_list[address][index]back on the stack,\nifaddressis present in thetx.access_listandindex < len(tx.access_list[address]),\nand otherwise pushes a zeroedbytes32value.", "Parameters": "We add an instructionACCESS_KEY(with opcodeACCESS_KEY_OPCODE_BYTE) which popsindexfrom the top\nof the stack as big-endianuint256, and pushestx.access_list[address][index]back on the stack,\nifaddressis present in thetx.access_listandindex < len(tx.access_list[address]),\nand otherwise pushes a zeroedbytes32value.", "Opcode": "We add an instructionACCESS_KEY(with opcodeACCESS_KEY_OPCODE_BYTE) which popsindexfrom the top\nof the stack as big-endianuint256, and pushestx.access_list[address][index]back on the stack,\nifaddressis present in thetx.access_listandindex < len(tx.access_list[address]),\nand otherwise pushes a zeroedbytes32value.", "Gas costs": "The gas cost ofACCESS_KEY_OPCODE_GASgas matches that of similar operations,\nspecifically theBLOBHASHopcode ofEIP-4844:\nthis opcode also pop an index-like EVM word from the stack,\nand pushes a full 32 byte EVM word back on the stack, based on a list of hashes embedded in the transaction.", "Rationale": "Static declaration of contract-inputs enables advanced layer-two constructions and block-building techniques:\ndata is available without EVM introspection, and contracts can reliably tell if the executing transaction\ndeclared critical properties to the block builder and verifying nodes.", "Static analysis of transactions": "Static declaration of contract-inputs enables advanced layer-two constructions and block-building techniques:\ndata is available without EVM introspection, and contracts can reliably tell if the executing transaction\ndeclared critical properties to the block builder and verifying nodes.", "Global read-only values": "Akin toTLOAD, as described inEIP-1153,\ntheACCESS_KEYopcode provides contracts with a view that is global\nto the message-execution of the transaction in the EVM.", "Access-list utility": "Access-lists are under-utilized today:\nvery few users utilize this to warm-up storage interactions for reduced gas costs.\nGenerally the gas cost savings achieved with EIP-2930 are not applicable in as many use-cases.", "Witness data": "This EIP supports the transformation of applications to reduce statefulness,\nby supporting read-only application state to be provided to contracts without\nrequiring the contract caller to support forwarding of data.", "Naming ofACCESS_KEY": "Access-lists currently only support a list of access-keys.\nThe list is not enforced to be sorted, and thus supports indexed lookups.", "Backwards Compatibility": "This enhancement of access-lists utility does not affect the access-list encoding,\nor the existing transaction types that support access-lists.", "No transaction-type changes": "This enhancement of access-lists utility does not affect the access-list encoding,\nor the existing transaction types that support access-lists.", "Minimal impact on EVM transaction-context": "With EIP-2930, the access-list contents are already readily available in the transaction-context during EVM execution,\nand the RPC methods that trigger said execution.", "Test Cases": "The block fee-recipient, and any other warmed-up attributes not declared statically in the transaction access-list,\nmust not be considered to be part of the access-list.", "Security Considerations": "The access-list attributes are already gas-metered in EIP-2930,\nand readily accessible in the EVM to determine storage gas-costs. In terms of denial-of-service risks,\nthis EIP introduces no new significant data or data-processing costs.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 8, "url": "https://eips.ethereum.org/EIPS/eip-8", "title": "devp2p Forward Compatibility Requirements for Homestead", "authors": ["Felix Lange\u00a0<", "felix@ethdev.com", ">"], "sections": {"EIP-8: devp2p Forward Compatibility Requirements for Homestead": "This EIP introduces new forward-compatibility requirements for implementations of the\ndevp2p Wire Protocol, the RLPx Discovery Protocol and the RLPx TCP Transport Protocol.\nClients which implement EIP-8 behave according to Postel\u2019s Law:", "": "This EIP introduces new forward-compatibility requirements for implementations of the\ndevp2p Wire Protocol, the RLPx Discovery Protocol and the RLPx TCP Transport Protocol.\nClients which implement EIP-8 behave according to Postel\u2019s Law:", "Abstract": "This EIP introduces new forward-compatibility requirements for implementations of the\ndevp2p Wire Protocol, the RLPx Discovery Protocol and the RLPx TCP Transport Protocol.\nClients which implement EIP-8 behave according to Postel\u2019s Law:", "Specification": "Implementations ofthe devp2p Wire Protocolshould ignore the version number of hello\npackets. When sending the hello packet, the version element should be set to the highest\ndevp2p version supported. Implementations should also ignore any additional list elements\nat the end of the hello packet.", "Motivation": "Changes to the devp2p protocols are hard to deploy because clients running an older\nversion will refuse communication if the version number or structure of the hello\n(discovery ping, RLPx handshake) packet does not match local expectations.", "Rationale": "The proposed changes address forward compatibility by applying Postel\u2019s Law (also known as\nthe Robustness Principle) throughout the protocol stack. The merit and applicability of\nthis approach has been studied repeatedly since its original application in RFC 761. For a\nrecent perspective, see\u201cThe Robustness Principle Reconsidered\u201d (Eric Allman, 2011).", "Backwards Compatibility": "This EIP is backwards-compatible, all valid version 4 packets are still accepted.", "Implementation": "go-ethereumlibweb3corepydevp2p", "Test Vectors": "devp2p hello packet advertising version 22 and containing a few additional list elements:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- devp2p: A networking protocol for Ethereum. EIP-8 introduces forward compatibility requirements for devp2p implementations .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 627, "url": "https://eips.ethereum.org/EIPS/eip-627", "title": "Whisper Specification", "authors": ["Vlad Gluhovsky\u00a0<", "gluk256@gmail.com", ">"], "sections": {"EIP-627: Whisper Specification": "This EIP describes the format of Whisper messages within the \u00d0\u039eVp2p Wire Protocol.\nThis EIP should substitute theexisting specification.\nMore detailed documentation on Whisper could be foundhere.", "": "This EIP describes the format of Whisper messages within the \u00d0\u039eVp2p Wire Protocol.\nThis EIP should substitute theexisting specification.\nMore detailed documentation on Whisper could be foundhere.", "Abstract": "This EIP describes the format of Whisper messages within the \u00d0\u039eVp2p Wire Protocol.\nThis EIP should substitute theexisting specification.\nMore detailed documentation on Whisper could be foundhere.", "Motivation": "It is necessary to specify the standard for Whisper messages in order to ensure forward compatibility of different Whisper clients.", "Specification": "All Whisper messages sent as \u00d0\u039eVp2p Wire Protocol packets should be RLP-encoded arrays of data containing two objects: integer packet code followed by another object (whose type depends on the packet code).", "Packet Codes": "The message codes reserved for Whisper protocol: 0 - 127.\nMessages with unknown codes must be ignored, for forward compatibility of future versions.", "Packet Format and Usage": "Status[0]", "Whisper Envelope": "Envelopes are RLP-encoded structures of the following format:", "Contents of Data Field of the Message (Optional)": "This section outlines the optional description of Data Field to set up an example. Later it may be moved to a separate EIP.", "Payload Encryption": "Asymmetric encryption uses the standard Elliptic Curve Integrated Encryption Scheme with SECP-256k1 public key.", "Rationale": "Packet codes 0x00 and 0x01 are already used in all Whisper versions.", "Backwards Compatibility": "This EIP is compatible with Whisper version 6. Any client which does not implement certain packet codes should gracefully ignore the packets with those codes. This will ensure the forward compatibility.", "Implementation": "The golang implementation of Whisper (v.6) already uses packet codes 0x00 - 0x03. Parity\u2019s implementation of v.6 will also use codes 0x00 - 0x03. Codes 0x7E and 0x7F are reserved, but still unused and left for custom implementation of Whisper Mail Server.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- whisper specification: Defines the Whisper protocol's message format and packet structure used within the \u00d0\u039eVp2p Wire Protocol, ensuring compatibility across Whisper clients.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 706, "url": "https://eips.ethereum.org/EIPS/eip-706", "title": "DEVp2p snappy compression", "authors": ["P\u00e9ter Szil\u00e1gyi\u00a0<", "peter@ethereum.org", ">"], "sections": {"EIP-706: DEVp2p snappy compression": "The base networking protocol (DEVp2p) used by Ethereum currently does not employ any form of compression. This results in a massive amount of bandwidth wasted in the entire network, making both initial sync as well as normal operation slower and laggier.", "": "The base networking protocol (DEVp2p) used by Ethereum currently does not employ any form of compression. This results in a massive amount of bandwidth wasted in the entire network, making both initial sync as well as normal operation slower and laggier.", "Abstract": "The base networking protocol (DEVp2p) used by Ethereum currently does not employ any form of compression. This results in a massive amount of bandwidth wasted in the entire network, making both initial sync as well as normal operation slower and laggier.", "Motivation": "Synchronizing the Ethereum main network (block 4,248,000) in Geth using fast sync currently consumes 1.01GB upload and 33.59GB download bandwidth. On the Rinkeby test network (block 852,000) it\u2019s 55.89MB upload and 2.51GB download.", "Specification": "Bump the advertised DEVp2p version number from4to5. If during handshake, the remote side advertises support only for version4, run the exact same protocol as until now.", "Avoiding DOS attacks": "Currently a DEVp2p message length is limited to 24 bits, amounting to a maximum size of 16MB. With the introduction of Snappy compression, care must be taken not to blindly decompress messages, since they may get significantly larger than 16MB.", "Alternatives (discarded)": "Alternative solutions to data compression that have been brought up and discarded are:", "Backwards Compatibility": "This proposal is fully backward compatible. Clients upgrading to the proposed DEVp2p protocol version5should still support skipping the compression step for connections that only advertise version4of the DEVp2p protocol.", "Implementation": "You can find a reference implementation of this EIP in https://github.com/ethereum/go-ethereum/pull/15106.", "Test vectors": "There is more than one valid encoding of any given input, and there is more than one good internal compression algorithm within Snappy when trading off throughput for output size. As such, different implementations might produce slight variations in the compressed form, but all should be cross compatible between each other.", "Go": "Copyright and related rights waived viaCC0.", "Python": "Copyright and related rights waived viaCC0.", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- devp2p: A networking protocol for Ethereum. EIP-8 introduces forward compatibility requirements for devp2p implementations .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 778, "url": "https://eips.ethereum.org/EIPS/eip-778", "title": "Ethereum Node Records (ENR)", "authors": ["Felix Lange\u00a0<", "fjl@ethereum.org", ">"], "sections": {"EIP-778: Ethereum Node Records (ENR)": "This EIP defines Ethereum Node Records, an open format for p2p connectivity information.", "": "This EIP defines Ethereum Node Records, an open format for p2p connectivity information.", "Abstract": "This EIP defines Ethereum Node Records, an open format for p2p connectivity information.", "Motivation": "Ethereum nodes discover each other through the node discovery protocol. The purpose of\nthat protocol is relaying node identity public keys (on the secp256k1 curve), their IP\naddress and two port numbers. No other information can be relayed.", "Specification": "The components of a node record are:", "RLP Encoding": "The canonical encoding of a node record is an RLP list of[signature, seq, k, v, ...].\nThe maximum encoded size of a node record is 300 bytes. Implementations should reject\nrecords larger than this size.", "Text Encoding": "The textual form of a node record is the base64 encoding of its RLP representation,\nprefixed byenr:. Implementations should use theURL-safe base64 alphabetand omit padding characters.", "\u201cv4\u201d Identity Scheme": "This specification defines a single identity scheme to be used as the default until other\nschemes are defined by further EIPs. The \u201cv4\u201d scheme is backwards-compatible with the\ncryptosystem used by Node Discovery v4.", "Rationale": "The format is meant to suit future needs in two ways:", "Test Vectors": "This is an example record containing the IPv4 address127.0.0.1and UDP port30303.\nThe node ID isa448f24c6d18e575453db13171562b71999873db5b286df957af199ec94617f7.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- ethereum node records (enr): Defines an open format for Ethereum node connectivity information, enabling the exchange of data such as IP addresses, ports, and public keys through various methods like node discovery, DNS, or ENS.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 868, "url": "https://eips.ethereum.org/EIPS/eip-868", "title": "Node Discovery v4 ENR Extension", "authors": ["Felix Lange\u00a0<", "fjl@ethereum.org", ">"], "sections": {"EIP-868: Node Discovery v4 ENR Extension": "This EIP defines an extension to Node Discovery Protocol v4 to enable authoritative\nresolution ofEthereum Node Records (ENR).", "": "This EIP defines an extension to Node Discovery Protocol v4 to enable authoritative\nresolution ofEthereum Node Records (ENR).", "Abstract": "This EIP defines an extension to Node Discovery Protocol v4 to enable authoritative\nresolution ofEthereum Node Records (ENR).", "Motivation": "To bridge current and future discovery networks and to aid the implementation of other\nrelay mechanisms for ENR such as DNS, we need a way to request the most up-to-date version\nof a node record. This EIP provides a way to request it using the existing discovery\nprotocol.", "Specification": "Implementations of Node Discovery Protocol v4 should support two new packet types, a\nrequest and reply of the node record. The existing ping and pong packets are extended with\na new field containing the sequence number of the ENR.", "Ping Packet (0x01)": "enr-seqis the current sequence number of the sending node\u2019s record. All other fields\nretain their existing meaning.", "Pong Packet (0x02)": "enr-seqis the current sequence number of the sending node\u2019s record. All other fields\nretain their existing meaning.", "ENRRequest Packet (0x05)": "When a packet of this type is received, the node should reply with an ENRResponse packet\ncontaining the current version of its record.", "ENRResponse Packet (0x06)": "This packet is the response to ENRRequest.", "Resolving Records": "To resolve the current record of a node public key, perform a recursive Kademlia lookup\nusing the FindNode, Neighbors packets. When the node is found, send ENRRequest to it and\nreturn the record from the response.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- ethereum node records (enr): Defines an open format for Ethereum node connectivity information, enabling the exchange of data such as IP addresses, ports, and public keys through various methods like node discovery, DNS, or ENS.\n- node discovery v4 enr extension: Extends Node Discovery Protocol v4 to support Ethereum Node Records (ENR), enabling authoritative retrieval of updated node records through existing discovery protocols.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2124, "url": "https://eips.ethereum.org/EIPS/eip-2124", "title": "Fork identifier for chain compatibility checks", "authors": ["P\u00e9ter Szil\u00e1gyi\u00a0<", "peterke@gmail.com", ">", "Felix Lange\u00a0<", "fjl@ethereum.org", ">"], "sections": {"EIP-2124: Fork identifier for chain compatibility checks": "Currently nodes in the Ethereum network try to find each other by establishing random connections to remote machines \u201clooking\u201d like an Ethereum node (public networks, private networks, test networks, etc), hoping that they found a useful peer (same genesis, same forks). This wastes time and resources, especially for smaller networks.", "": "Currently nodes in the Ethereum network try to find each other by establishing random connections to remote machines \u201clooking\u201d like an Ethereum node (public networks, private networks, test networks, etc), hoping that they found a useful peer (same genesis, same forks). This wastes time and resources, especially for smaller networks.", "Simple Summary": "Currently nodes in the Ethereum network try to find each other by establishing random connections to remote machines \u201clooking\u201d like an Ethereum node (public networks, private networks, test networks, etc), hoping that they found a useful peer (same genesis, same forks). This wastes time and resources, especially for smaller networks.", "Abstract": "There are many public and private Ethereum networks, but the discovery protocol doesn\u2019t differentiate between them. The only way to check if a peer is good or bad (same chain or not), is to establish a TCP/IP connection, wrap it with RLPx cryptography, then execute anethhandshake. This is an extreme cost to bear if it turns out that the remote peer is on a different network and it\u2019s not even precise enough to differentiate Ethereum and Ethereum Classic. This cost is magnified for small networks, where a lot more trial and errors are needed to find good nodes.", "Motivation": "Peer-to-peer networking is messy and hard due to firewalls and network address translation (NAT). Generally only a small fraction of nodes have publicly routed addresses and P2P networks rely mainly on these for forwarding data for everyone else. The best way to maximize the utility of the public nodes is to ensure their resources aren\u2019t wasted on tasks that are worthless to the network.", "Specification": "Each node maintains the following values:", "Rationale": "Whilst theethdevp2p protocol permits arbitrarily much data to be transmitted, the discovery protocol\u2019s total space allowance for all ENR entries is 300 bytes.", "Backwards Compatibility": "This EIP only defines an identity scheme, it does not define functional changes.", "Test Cases": "Here\u2019s a full suite of tests for all possible fork IDs that Mainnet, Ropsten, Rinkeby and G\u00f6rli can advertise given the Petersburg fork cap (time of writing).", "Implementation": "Geth: https://github.com/ethereum/go-ethereum/tree/master/core/forkid", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- devp2p: A networking protocol for Ethereum. EIP-8 introduces forward compatibility requirements for devp2p implementations .\n- fork identifier: Introduces a mechanism to summarize chain configurations using a FORK_HASH and FORK_NEXT for chain compatibility checks.\n- genesis: Log entry in system_logs for initial balances at network genesis ."}
{"eip": 2364, "url": "https://eips.ethereum.org/EIPS/eip-2364", "title": "eth/64: forkid-extended protocol handshake", "authors": ["P\u00e9ter Szil\u00e1gyi\u00a0<", "peterke@gmail.com", ">", "P\u00e9ter Szil\u00e1gyi\u00a0(", "@karalabe", ")", "Tim Beiko\u00a0(", "@timbeiko", ")"], "sections": {"EIP-2364: eth/64: forkid-extended protocol handshake": "This EIP specifies the inclusion of theforkid, originally defined in(EIP-2124), as a new field in the Ethereum wire protocol (eth) handshake. This change is implemented as a new version of the wire protocol,eth/64.", "Introduces validation of the `forkid` when handshaking with peers.": "This EIP specifies the inclusion of theforkid, originally defined in(EIP-2124), as a new field in the Ethereum wire protocol (eth) handshake. This change is implemented as a new version of the wire protocol,eth/64.", "Abstract": "This EIP specifies the inclusion of theforkid, originally defined in(EIP-2124), as a new field in the Ethereum wire protocol (eth) handshake. This change is implemented as a new version of the wire protocol,eth/64.", "Motivation": "Theforkid(EIP-2124)was designed to permit two Ethereum nodes to quickly and cheaply decide if they are compatible or not, not only at a genesis/networking level, but also from the perspective of the currently passed network updates (i.e. forks).", "Specification": "Whenever two peers connect using theeth/64protocol, the updatedStatusmessage must be sent as the protocol handshake, and each peer must validate the remoteforkid, disconnecting at a detected incompatibility.", "Rationale": "The specification is tiny since most parts are already specified in EIP-2124.eth/63is not specified as an EIP, but is maintained in theethereum/devp2pGithub repository.", "EIP-2124 mentions advertising theforkidin the discovery protocol too. How does that compare to advertising in theethprotocol? Why is the redundancy needed?": "Advertising and validating theforkidin the discovery protocol is a more optimal solution, as it can help avoid the cost of setting up the TCP connection and cryptographic RLPx stream, only to be torn down ifeth/64rejects it.", "Theforkidimplicitly contains the genesis hash checksummed into theFORK_HASHfield. Why doesn\u2019t this proposal remove thegenesisHashfield from theethhandshake?": "Originally this EIP did remove it as redundant data, since filtering based on theforkidis a superset of filtering based on genesis hash. The reason for backing out of that decision was that the genesis hash may be useful for other things too, not just connection filtering (network crawlers use it currently to split nodes across networks).", "Backwards Compatibility": "This EIP extends theethprotocol handshake in a backwards incompatible way and requires rolling out a new version,eth/64. However,devp2psupports running multiple versions of the same wire protocol side-by-side, so rolling outeth/64does not require client coordination, since non-updated clients can keep usingeth/63.", "Test Cases": "For calculating and validating fork IDs, see test cases inEIP-2124.", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- devp2p: A networking protocol for Ethereum. EIP-8 introduces forward compatibility requirements for devp2p implementations .\n- genesis: Log entry in system_logs for initial balances at network genesis .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2464, "url": "https://eips.ethereum.org/EIPS/eip-2464", "title": "eth/65: transaction announcements and retrievals", "authors": ["P\u00e9ter Szil\u00e1gyi\u00a0<", "peterke@gmail.com", ">", "P\u00e9ter Szil\u00e1gyi\u00a0(", "@karalabe", ")", "Gary Rong\u00a0<", "garyrong0905@gmail.com", ">", "Tim Beiko\u00a0(", "@timbeiko", ")"], "sections": {"EIP-2464: eth/65: transaction announcements and retrievals": "This EIP introduces three additional message types into theethprotocol (releasing a new version,eth/65):NewPooledTransactionHashes (0x08)to announce a set of transactions without their content;GetPooledTransactions (0x09)to request a batch of transactions by their announced hash; andPooledTransactions (0x0a)to reply to a transaction request. This permits reducing the bandwidth used for transaction propagation from linear complexity in the number of peers to square root; and also reducing the initial transaction exchange from 10s-100s MB tolen(pool) * 32B ~= 128KB.", "Introduces `NewPooledTransactionHashes`, `GetPooledTransactions`, and `PooledTransactions`.": "This EIP introduces three additional message types into theethprotocol (releasing a new version,eth/65):NewPooledTransactionHashes (0x08)to announce a set of transactions without their content;GetPooledTransactions (0x09)to request a batch of transactions by their announced hash; andPooledTransactions (0x0a)to reply to a transaction request. This permits reducing the bandwidth used for transaction propagation from linear complexity in the number of peers to square root; and also reducing the initial transaction exchange from 10s-100s MB tolen(pool) * 32B ~= 128KB.", "Abstract": "This EIP introduces three additional message types into theethprotocol (releasing a new version,eth/65):NewPooledTransactionHashes (0x08)to announce a set of transactions without their content;GetPooledTransactions (0x09)to request a batch of transactions by their announced hash; andPooledTransactions (0x0a)to reply to a transaction request. This permits reducing the bandwidth used for transaction propagation from linear complexity in the number of peers to square root; and also reducing the initial transaction exchange from 10s-100s MB tolen(pool) * 32B ~= 128KB.", "Motivation": "Theethnetwork protocol has two ways to propagate a newly mined block: it can be broadcast to a peer in its entirety (viaNewBlock (0x07)ineth/64and prior or it can be announced only (viaNewBlockHashes (0x01)). This duality allows nodes to do the high-bandwidth broadcasting (10s-100s KB) for a square root number of peers; and the low-bandwidth announcing (10s-100s B) for the remaining linear number of peers. The square root broadcast is enough to reach all well connected nodes, but the linear announce is needed to get across degenerate topologies. This works well.", "Specification": "Add three new message types to theethprotocol:", "Rationale": "Q: Why limitGetPooledTransactions (0x09)to retrieving items from the pool?", "Backwards Compatibility": "This EIP extends theethprotocol in a backwards incompatible way and requires rolling out a new version,eth/65. However,devp2psupports running multiple versions of the same wire protocol side-by-side, so rolling outeth/65does not require client coordination, since non-updated clients can keep usingeth/64.", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- devp2p: A networking protocol for Ethereum. EIP-8 introduces forward compatibility requirements for devp2p implementations .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2481, "url": "https://eips.ethereum.org/EIPS/eip-2481", "title": "eth/66 request identifier", "authors": ["Christoph Burgdorf\u00a0(", "@cburgdorf", ")"], "sections": {"EIP-2481: eth/66 request identifier": "Theethprotocol defines various request and response commands that are used to exchange data between Ethereum nodes. For example, to ask a peer node for a specific set of headers, a node sends it theGetBlockHeaderscommand.", "Introduces a request id for all requests of the eth protocol": "Theethprotocol defines various request and response commands that are used to exchange data between Ethereum nodes. For example, to ask a peer node for a specific set of headers, a node sends it theGetBlockHeaderscommand.", "Abstract": "Theethprotocol defines various request and response commands that are used to exchange data between Ethereum nodes. For example, to ask a peer node for a specific set of headers, a node sends it theGetBlockHeaderscommand.", "Motivation": "The lack of request identifiers in the request / response paris of theethprotocol puts unnecessary burden of code complexity into every Ethereum client. It also makes the communication slightly less efficient. Another argument can be made that the addition of request identifiers makes the protocol more aligned with thelesprotocol whichdoesalready defines request identifiers for each request / response pair.", "Specification": "Change the following message types in theethprotocol:", "Rationale": "Q: The efficiency gains might encourage clients to flood their peers with too many simultaneous requests", "Backwards Compatibility": "This EIP extends theethprotocol in a backwards incompatible way and requires rolling out a new version,eth/66. However,devp2psupports running multiple versions of the same wire protocol side-by-side, so rolling outeth/66does not require client coordination, since non-updated clients can keep usingeth/65.", "Test Cases": "These testcases cover RLP-encoding of all the redefined messages types, where therlpportion is the rlp-encoding of the message defined in thedataportion.", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- devp2p: A networking protocol for Ethereum. EIP-8 introduces forward compatibility requirements for devp2p implementations .\n- eth/66 request identifier: Adds a request ID to all request/response pairs in the eth protocol, improving efficiency and reducing the complexity of matching responses to requests.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2976, "url": "https://eips.ethereum.org/EIPS/eip-2976", "title": "Typed Transactions over Gossip", "authors": ["Micah Zoltu\u00a0(", "@MicahZoltu", ")"], "sections": {"EIP-2976: Typed Transactions over Gossip": "Typed Transactionscan be sent over devp2p asTransactionType || TransactionPayload.\nThe exact contents of theTransactionPayloadare defined by theTransactionTypein future EIPs, and clients may start supporting their gossip without incrementing the devp2p version.\nIf a client receives aTransactionTypethat it doesn\u2019t recognize, itSHOULDdisconnect from the peer who sent it.\nClientsMUST NOTsend new transaction types before they believe the fork block is reached.", "Adds support for transmission of typed transactions over devp2p.": "Typed Transactionscan be sent over devp2p asTransactionType || TransactionPayload.\nThe exact contents of theTransactionPayloadare defined by theTransactionTypein future EIPs, and clients may start supporting their gossip without incrementing the devp2p version.\nIf a client receives aTransactionTypethat it doesn\u2019t recognize, itSHOULDdisconnect from the peer who sent it.\nClientsMUST NOTsend new transaction types before they believe the fork block is reached.", "Abstract": "Typed Transactionscan be sent over devp2p asTransactionType || TransactionPayload.\nThe exact contents of theTransactionPayloadare defined by theTransactionTypein future EIPs, and clients may start supporting their gossip without incrementing the devp2p version.\nIf a client receives aTransactionTypethat it doesn\u2019t recognize, itSHOULDdisconnect from the peer who sent it.\nClientsMUST NOTsend new transaction types before they believe the fork block is reached.", "Motivation": "EIP-2718introduced new transaction types for blocks (which presents itself in the makeup of a block header\u2019s transaction root and receipts root).\nHowever, without a mechanism for gossiping these transactions, no one can actually include them in a block.\nBy updating devp2p to support the gossip of Typed Transactions, we can benefit from these new transaction types.", "Specification": "All changes specified below apply to all protocol/versions retroactively.", "Definitions": "If a client receives aTransactionTypeit doesn\u2019t recognize via any message, itSHOULDdisconnect the peer that sent it.", "Protocol Behavior": "If a client receives aTransactionTypeit doesn\u2019t recognize via any message, itSHOULDdisconnect the peer that sent it.", "Protocol Messages": "Transactions (0x02):[Transaction_0, Transaction_1, ..., Transaction_n]", "Rationale": "We could have chosen to make the protocol aware of the shape of the transaction payloads.\nThe authors felt that it would be too much maintenance burden long term to have every new transaction type require an update to devp2p, so instead we merely define that typed transactions are supported.", "Why not specify each transaction type at the protocol layer?": "We could have chosen to make the protocol aware of the shape of the transaction payloads.\nThe authors felt that it would be too much maintenance burden long term to have every new transaction type require an update to devp2p, so instead we merely define that typed transactions are supported.", "Why have peers disconnect if they receive an unknown transaction type?": "We could encourage peers to remain connected to peers that submit an unknown transaction type, in case the transaction is some new transaction type that the receiver isn\u2019t aware of it.\nHowever, doing so may open clients up to DoS attacks where someone would send them transactions of an undefinedTransactionTypein order to avoid being disconnected for spamming.\nAlso, in most cases we expect that by the time new transaction types are being sent over devp2p, a hard fork that requires all connected clients to be aware of the new transaction type is almost certainly imminent.", "Backwards Compatibility": "Legacy transactions are still supported.", "Security Considerations": "If a client chooses to ignore theSHOULDrecommendation for disconnecting peers that send unknown transaction types they may be susceptible to DoS attacks.\nIgnoring this recommendation should be limited to trusted peers only, or other situations where the risk of DoS is extremely low.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- devp2p: A networking protocol for Ethereum. EIP-8 introduces forward compatibility requirements for devp2p implementations .\n- typed transactions over gossip: Enables the transmission of typed transactions via devp2p, allowing clients to gossip new transaction types without upgrading the devp2p version.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4938, "url": "https://eips.ethereum.org/EIPS/eip-4938", "title": "eth/67 - Removal of GetNodeData", "authors": ["Marius van der Wijden\u00a0(", "@MariusVanDerWijden", ")", "Felix Lange\u00a0<", "fjl@ethereum.org", ">", "Gary Rong\u00a0<", "garyrong@ethereum.org", ">"], "sections": {"EIP-4938: eth/67 - Removal of GetNodeData": "TheEthereum Wire Protocoldefines request and response messages for exchanging data between clients. TheGetNodeDatarequest retrieves a set of trie nodes or contract code from the state trie by hash. We propose to remove theGetNodeDataandNodeDatamessages from the wire protocol.", "Remove GetNodeData and NodeData messages from the wire protocol": "TheEthereum Wire Protocoldefines request and response messages for exchanging data between clients. TheGetNodeDatarequest retrieves a set of trie nodes or contract code from the state trie by hash. We propose to remove theGetNodeDataandNodeDatamessages from the wire protocol.", "Abstract": "TheEthereum Wire Protocoldefines request and response messages for exchanging data between clients. TheGetNodeDatarequest retrieves a set of trie nodes or contract code from the state trie by hash. We propose to remove theGetNodeDataandNodeDatamessages from the wire protocol.", "Motivation": "GetNodeDataandNodeDatawere introduced in protocol versioneth/63to allow for a sync mode called \u201cfast sync\u201d, which downloads the Ethereum state without executing all blocks. The sync algorithm works by requesting all state trie nodes and contract codes by their hash.", "Specification": "Remove the following message types from theethprotocol:", "Rationale": "A replacement forGetNodeDatais available in thesnap protocol. Specifically, clients can use theGetByteCodesandGetTrieNodesmessages instead ofGetNodeData. The snap protocol can be used to implement the \u201cfast sync\u201d algorithm, though it is recommended to use it for \u201csnap sync\u201d.", "Backwards Compatibility": "This EIP changes theethprotocol and requires rolling out a new version,eth/67. Supporting multiple versions of a wire protocol is possible. Rolling out a new version does not break older clients immediately, since they can keep using protocol versioneth/66.", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- eth/67 - removal of getnodedata: Removes the GetNodeData and NodeData messages from the Ethereum wire protocol, reflecting changes in how state data is accessed and promoting the use of the snap protocol.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5793, "url": "https://eips.ethereum.org/EIPS/eip-5793", "title": "eth/68 - Add tx type to tx announcement", "authors": ["Marius van der Wijden\u00a0(", "@MariusVanDerWijden", ")"], "sections": {"EIP-5793: eth/68 - Add tx type to tx announcement": "The Ethereum Wire Protocol defines request and response messages for exchanging data between clients. TheNewPooledTransactionHashesmessage announces transactions available in the node. This EIP extends this announcement message such that beside the transaction hashes, the node sends the transaction types and their sizes (as defined inEIP-2718) as well.", "Adds the transaction type and transaction size to tx announcement messages in the wire protocol": "The Ethereum Wire Protocol defines request and response messages for exchanging data between clients. TheNewPooledTransactionHashesmessage announces transactions available in the node. This EIP extends this announcement message such that beside the transaction hashes, the node sends the transaction types and their sizes (as defined inEIP-2718) as well.", "Abstract": "The Ethereum Wire Protocol defines request and response messages for exchanging data between clients. TheNewPooledTransactionHashesmessage announces transactions available in the node. This EIP extends this announcement message such that beside the transaction hashes, the node sends the transaction types and their sizes (as defined inEIP-2718) as well.", "Motivation": "TheNewPooledTransactionHashesmessage announces transaction hashes, allowing the peer to selectively fetch transactions it does not yet have.", "Specification": "Modify theNewPooledTransactionHashes (0x08)message:", "Rationale": "This change will make theethprotocol future-proof for new transaction types that might not be relevant for all nodes. It gives the receiving node better control over the data it fetches from the peer as well as allow throttling the download of specific types.", "Backwards Compatibility": "This EIP changes theethprotocol and requires rolling out a new version,eth/68. Supporting multiple versions of a wire protocol is possible. Rolling out a new version does not break older clients immediately, since they can keep using protocol versioneth/67.", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6122, "url": "https://eips.ethereum.org/EIPS/eip-6122", "title": "Forkid checks based on timestamps", "authors": ["Marius van der Wijden\u00a0(", "@MariusVanDerWijden", ")"], "sections": {"EIP-6122: Forkid checks based on timestamps": "EIP-2124proposed a way of identifying nodes on the p2p network based on their chain configuration via the forkid parameter. \nIt allows nodes to cut incompatible nodes off quickly which makes the P2P network more reliable.\nAfter the merge, forks are scheduled by block time instead of block number. This EIP updates the forkid calculation with block time.", "Modifies the forkid checks to work with timestamps and block numbers": "EIP-2124proposed a way of identifying nodes on the p2p network based on their chain configuration via the forkid parameter. \nIt allows nodes to cut incompatible nodes off quickly which makes the P2P network more reliable.\nAfter the merge, forks are scheduled by block time instead of block number. This EIP updates the forkid calculation with block time.", "Abstract": "EIP-2124proposed a way of identifying nodes on the p2p network based on their chain configuration via the forkid parameter. \nIt allows nodes to cut incompatible nodes off quickly which makes the P2P network more reliable.\nAfter the merge, forks are scheduled by block time instead of block number. This EIP updates the forkid calculation with block time.", "Motivation": "While in proof-of-work forks were scheduled by block number, the proof-of-stake consensus layer schedules forks by slot number. The slot number is a time based measurement. In order to schedule forks at the same time on the consensus and execution layer, the execution layer is forced to also schedule forks by timestamp after the merge.", "Specification": "Each node maintains the following values:", "Additional rules": "The following additional rules are applied:", "Rationale": "Shanghai will be scheduled by timestamp thus the forkid calculations need to be updated to work with timestamps and blocks.\nSince all block number based forks are before time based forks, nodes need to check the block based forks before the time based forks.", "Backwards Compatibility": "This change modifies the forkid calculation slightly. \nAs a consequence nodes applying this change will drop peers who are not applying this change as soon as timestamp-scheduled fork occurs.\nThis is not only expected, but actually the purpose of the forkid in the first place.", "Test Cases": "Here\u2019s a suite of tests with mainnet config and withdrawals enabled at time1668000000and merge netsplit block at block18000000", "Security Considerations": "No known security risks", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- forkid checks based on timestamps: Modifies the forkid checks to consider timestamps, aligning with the Proof-of-Stake fork scheduling mechanism that is based on time instead of block numbers.\n- withdrawal: Log entry in system_logs for tracking withdrawals under EIP-4895 ."}
{"eip": 7636, "url": "https://eips.ethereum.org/EIPS/eip-7636", "title": "Extension of EIP-778 for \"client\" ENR Entry", "authors": ["James Kempton\u00a0(", "@JKincorperated", ")"], "sections": {"EIP-7636: Extension of EIP-778 for \"client\" ENR Entry": "The Ethereum network consists of nodes running various client implementations. Each client has its own set of features, optimizations, and unique behaviors. Introducing a standardized way to identify client software and its version in the ENR allows for more effective network analysis, compatibility checks, and troubleshooting. This EIP proposes the addition of a \u201cclient\u201d field to the ENR.", "Add additional ENR entry to specify client information such as name and version number.": "The Ethereum network consists of nodes running various client implementations. Each client has its own set of features, optimizations, and unique behaviors. Introducing a standardized way to identify client software and its version in the ENR allows for more effective network analysis, compatibility checks, and troubleshooting. This EIP proposes the addition of a \u201cclient\u201d field to the ENR.", "Abstract": "The Ethereum network consists of nodes running various client implementations. Each client has its own set of features, optimizations, and unique behaviors. Introducing a standardized way to identify client software and its version in the ENR allows for more effective network analysis, compatibility checks, and troubleshooting. This EIP proposes the addition of a \u201cclient\u201d field to the ENR.", "Motivation": "Understanding the landscape of client software in the Ethereum network is crucial for developers, nodes, and network health assessment. Currently, there is no standardized method for nodes to announce their software identity and version, which can lead to compatibility issues or difficulty in diagnosing network-wide problems. Adding this to the ENR allows clients to audit network health only using discv5, and additionally track discv5 adoption across different services.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "One key was chosen over using many keys to make efficient use of space. The use of one string, however, does not align with other EIPs of similar purpose and as such the RLP list was decided as the best encoding.", "Backwards Compatibility": "This EIP is fully backwards compatible as it extends the ENR specification by adding an optional entry. Existing implementations that do not recognize the \u201cclient\u201d entry will ignore it without any adverse effects on ENR processing or network behavior.", "Test Cases": "A node running Geth version 1.10.0 on the mainnet might have an ENRcliententry like:", "Security Considerations": "Introducing identifiable client information could potentially be used for targeted attacks against specific versions or builds known to have vulnerabilities. It is crucial for clients implementing this EIP to consider the implications of disclosing their identity and version. Users or operators should have the ability to opt-out or anonymize this information if desired.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7642, "url": "https://eips.ethereum.org/EIPS/eip-7642", "title": "2025-05-07", "authors": ["eth/69 - history expiry and simpler receipts"], "sections": {"EIP-7642: eth/69 - history expiry and simpler receipts": "This EIP modifies the \u2018eth\u2019 p2p protocol to announce the historical block range served by\nthe node. We also simplify the handshake to remove total difficulty information, which\nisn\u2019t used anymore after the merge. Additionally we propose to remove theBloomfield\nfrom receipts transfered over the protocol.", "Adds history serving window and removes bloom filter in receipt": "This EIP modifies the \u2018eth\u2019 p2p protocol to announce the historical block range served by\nthe node. We also simplify the handshake to remove total difficulty information, which\nisn\u2019t used anymore after the merge. Additionally we propose to remove theBloomfield\nfrom receipts transfered over the protocol.", "Abstract": "This EIP modifies the \u2018eth\u2019 p2p protocol to announce the historical block range served by\nthe node. We also simplify the handshake to remove total difficulty information, which\nisn\u2019t used anymore after the merge. Additionally we propose to remove theBloomfield\nfrom receipts transfered over the protocol.", "Motivation": "In the history expiry working group, it was decided that clients may drop pre-merge\nhistory from their storage after May 1, 2025. For clients that want to sync history\nthrough the \u2018eth\u2019 protocol, it is essential to know whether a peer still serves old\nhistory. A similar idea was proposed inEIP-7542but was later withdrawn\nbecause a political decision on history expiry had not been reached at the time.", "Block range in Status message": "In the history expiry working group, it was decided that clients may drop pre-merge\nhistory from their storage after May 1, 2025. For clients that want to sync history\nthrough the \u2018eth\u2019 protocol, it is essential to know whether a peer still serves old\nhistory. A similar idea was proposed inEIP-7542but was later withdrawn\nbecause a political decision on history expiry had not been reached at the time.", "Removing Bloom in Receipts": "We recently discovered that none of the clients store theBloomfield of the receipts as\nit can be recomputed on demand. However the networking spec requires theBloomfield to\nbe sent over the network. Thus a syncing node will ask for the Bloom filters for all\nreceipts. The serving node will regenerate roughly 530GB of bloom filters (2.3B txs * 256\nbyte). These 530GBs are send over the network to the syncing peer, the syncing peer will\nverify them and not store them either. This adds an additional 530GB of unnecessary\nbandwidth to every sync.", "BlockRangeUpdate message": "Add a newBlockRangeUpdate (0x11)message, with the following encoding", "Specification": "Modify theStatus (0x00)message as follows:", "Status message changes": "Modify theStatus (0x00)message as follows:", "Receipts message changes": "Modify the encoding for receipts in theReceipts (0x10)message as follows:", "Rationale": "After the merge, theTDfield of theStatusmessage became meaningless since the\ndifficulty of post-merge blocks are 0. It could in theory be used to distinguish synced\nwith unsynced nodes, but the same thing can be accomplished with the forkid as well.", "Status changes": "After the merge, theTDfield of theStatusmessage became meaningless since the\ndifficulty of post-merge blocks are 0. It could in theory be used to distinguish synced\nwith unsynced nodes, but the same thing can be accomplished with the forkid as well.", "Receipts changes": "Removing the bloom filters from theReceiptmessage reduces the CPU load of serving\nnodes as well as the bandwidth significantly. The receiving nodes will need to recompute\nthe bloom filter in order to fully verify the receipt hash. The recomputation is not very\nCPU intensive. The bandwidth gains amount to roughly 530GiB per syncing node or (at least)\n95GiB snappy compressed.", "Backwards Compatibility": "This EIP changes the eth protocol and requires rolling out a new version,eth/69.\nSupporting multiple versions of a wire protocol is possible. Rolling out a new version\ndoes not break older clients immediately, since they can keep using protocol versioneth/68.", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation.\n- eth/69: over DevP2P protocol"}
{"eip": 7594, "url": "https://eips.ethereum.org/EIPS/eip-7594", "title": "PeerDAS - Peer Data Availability Sampling", "authors": ["Danny Ryan\u00a0(", "@djrtwo", ")", "Dankrad Feist\u00a0(", "@dankrad", ")", "Francesco D'Amato\u00a0(", "@fradamt", ")", "Hsiao-Wei Wang\u00a0(", "@hwwhww", ")"], "sections": {"EIP-7594: PeerDAS - Peer Data Availability Sampling": "PeerDAS (Peer Data Availability Sampling) is a networking protocol that allows beacon nodes to perform data availability sampling (DAS) to ensure that blob data has been made available while downloading only a subset of the data. PeerDAS utilizes gossip for distribution, discovery for finding peers of particular data custody, and peer requests for sampling.", "Introducing simple DAS utilizing gossip distribution and peer requests": "PeerDAS (Peer Data Availability Sampling) is a networking protocol that allows beacon nodes to perform data availability sampling (DAS) to ensure that blob data has been made available while downloading only a subset of the data. PeerDAS utilizes gossip for distribution, discovery for finding peers of particular data custody, and peer requests for sampling.", "Abstract": "PeerDAS (Peer Data Availability Sampling) is a networking protocol that allows beacon nodes to perform data availability sampling (DAS) to ensure that blob data has been made available while downloading only a subset of the data. PeerDAS utilizes gossip for distribution, discovery for finding peers of particular data custody, and peer requests for sampling.", "Motivation": "DAS is a method of scaling data availability beyond the levels ofEIP-4844by not requiring all nodes to download all data while still ensuring that all of the data has been made available.", "Specification": "We extend the blobs introduced in EIP-4844 using a one-dimensional erasure coding extension. Each row consists of the blob data combined with its erasure code. It is subdivided into cells, which are the smallest units that can be authenticated with their respective blob\u2019s KZG commitments. Each column, associated with a specific gossip subnet, consists of the cells from all rows for a specific index. Each node is responsible for maintaining and custodying a deterministic set of column subnets and data as a function of their node ID.", "Networking": "This EIP introduces cell KZG proofs, which are used to prove that a KZG commitment opens to a cell at the given index. This allows downloading only specific cells from a blob, while still ensuring data integrity with respect to the corresponding KZG commitment, and is therefore a key component of data availability sampling. However, computing the cell proofs for a blob is an expensive operation, which a block producer would have to repeat for many blobs. Since proof verification is much cheaper than proof computation, and the proof size is negligible compared to cell size, we instead require blob transaction senders to compute the proofs themselves and include them in the EIP-4844 transaction pool wrapper for blob transactions.", "Rationale": "TBD", "Backwards Compatibility": "Needs discussion.", "Test Cases": "Needs discussion.", "Reference Implementation": "Needs discussion.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- peerdas - peer data availability sampling: Introduces a networking protocol that allows nodes to perform data availability sampling (DAS) to ensure that blob data is available without downloading all data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7639, "url": "https://eips.ethereum.org/EIPS/eip-7639", "title": "eth/70 - Cease serving history before PoS", "authors": ["lightclient\u00a0(", "@lightclient", ")"], "sections": {"EIP-7639: eth/70 - Cease serving history before PoS": "Execution layer clients will no longer request or respond to p2p queries about\nblock data before the Paris upgrade.", "Execution layer clients will no longer serve block data before Paris over p2p.": "Execution layer clients will no longer request or respond to p2p queries about\nblock data before the Paris upgrade.", "Abstract": "Execution layer clients will no longer request or respond to p2p queries about\nblock data before the Paris upgrade.", "Motivation": "As of 2024, historical data in clients has grown to around 500 GB. Nearly 400 GB\nof that is from block data before PoS was activated in the Paris upgrade. Long\nterm, Ethereum plans to bound the amount of data nodes must store. This EIP\nproposes the first steps to achieve such goal.", "Specification": "Add a newethprotocol capability with version70.", "Rationale": "One might ask why the distinction between pre and post PoS data is made in this\nEIP. The simple answer is that the at the moment of the merge, the block\nstructure changed substantially. Although execution layer client software today\ncontinues on with block data on disk which remains similar to per-PoS data, the\nbeacon chain is now the canonical chain definition. Therefore, a beacon block\ncan be used to both record historical data for execution layer and beacon layer.", "Only Pre-PoS data": "One might ask why the distinction between pre and post PoS data is made in this\nEIP. The simple answer is that the at the moment of the merge, the block\nstructure changed substantially. Although execution layer client software today\ncontinues on with block data on disk which remains similar to per-PoS data, the\nbeacon chain is now the canonical chain definition. Therefore, a beacon block\ncan be used to both record historical data for execution layer and beacon layer.", "Backwards Compatibility": "After this EIP is activated, nodes will no longer be able to full sync from the\ndevp2p network. To continue doing so, they must retrieve the data out-of-band.", "Security Considerations": "TODO", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- devp2p: A networking protocol for Ethereum. EIP-8 introduces forward compatibility requirements for devp2p implementations .\n- cease serving history before pos: Execution layer clients will stop serving block data from before the Paris (PoS) upgrade over the p2p network, reducing the data burden.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7801, "url": "https://eips.ethereum.org/EIPS/eip-7801", "title": "etha - Sharded Blocks Subprotocol", "authors": ["Ahmad Bitar (@smartprogrammer93)\u00a0<", "smartprogrammer@windowslive.com", ">", "Giulio Rebuffo\u00a0(", "@Giulio2002", ")", "Gary Schulte (@garyschulte)\u00a0<", "garyschulte@gmail.com", ">"], "sections": {"EIP-7801: etha - Sharded Blocks Subprotocol": "This EIP proposes the creation of a new subprotocol,etha, enabling Ethereum nodes to communicate available block spans via a bitmask. Each bit represents a 106_496-block span within each 1_064_960 block range of chain history. Nodes use this bitmask to signal stored spans and commit to storing future spans as they are created. This allows peers to make informed decisions about data availability without first connecting and querying for it. The bitmask repeats every 1_064_960 blocks for straightforward reasoning about data availability probabilities.", "Introduces the etha subprotocol for serving historical blocks data.": "This EIP proposes the creation of a new subprotocol,etha, enabling Ethereum nodes to communicate available block spans via a bitmask. Each bit represents a 106_496-block span within each 1_064_960 block range of chain history. Nodes use this bitmask to signal stored spans and commit to storing future spans as they are created. This allows peers to make informed decisions about data availability without first connecting and querying for it. The bitmask repeats every 1_064_960 blocks for straightforward reasoning about data availability probabilities.", "Abstract": "This EIP proposes the creation of a new subprotocol,etha, enabling Ethereum nodes to communicate available block spans via a bitmask. Each bit represents a 106_496-block span within each 1_064_960 block range of chain history. Nodes use this bitmask to signal stored spans and commit to storing future spans as they are created. This allows peers to make informed decisions about data availability without first connecting and querying for it. The bitmask repeats every 1_064_960 blocks for straightforward reasoning about data availability probabilities.", "Motivation": "WithEIP-4444, nodes may prune historical data while others continue serving it. Determining data availability by connecting and requesting blocks is inefficient consuming unnexessary bandwidth. This EIP addresses this inefficiency by enabling nodes to shard chain history into 106_496 block segments and signal availability via a bitmask.", "Specification": "TheethasubprotocolMUSTinclude support for the following messages from theeth/69protocol to facilitate historical data serving:", "Subprotocol Handshake": "TheethasubprotocolMUSTinclude support for the following messages from theeth/69protocol to facilitate historical data serving:", "Supported Messages": "TheethasubprotocolMUSTinclude support for the following messages from theeth/69protocol to facilitate historical data serving:", "Node Behavior": "Upon connection usingetha, nodes exchange the handshake message with theblockBitmask. This single handshake eliminates the need for additional message types.", "ENR Extension": "Alternatively, theblockBitmaskcould be derived or encoded into the Ethereum Node Record (ENR), enabling nodes to advertise block spans without a handshake. As an example, theblockBitmaskcan be derived from thesecp256k1field of the ENR.  However, this method lacks the authentication and reliability of the handshake approach. Additionally, there is not guarantee that the node you are connecting to supports theethasubprotocol.", "Rationale": "The bitmask approach provides a flexible means to represent and retain block data while committing to future spans. This mechanism aligns with the pruning proposed in EIP-4444, while ensuring that historical and future data spans remain available across the network.", "Backwards Compatibility": "Theethasubprotocol is independent of theethprotocol. This EIP does not affect the consensus engine or require a hard fork.", "Security Considerations": "There are some considerations:", "Copyright": "This document is CC0-licensed; rights are waived throughCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation.\n- eth/69: over DevP2P protocol"}
{"eip": 1459, "url": "https://eips.ethereum.org/EIPS/eip-1459", "title": "Node Discovery via DNS", "authors": ["Felix Lange\u00a0(", "@fjl", ")", "P\u00e9ter Szil\u00e1gyi\u00a0(", "@karalabe", ")"], "sections": {"EIP-1459: Node Discovery via DNS": "This document describes a scheme for authenticated, updateable Ethereum node\nlists retrievable via DNS.", "Scheme for authenticated updateable Ethereum node lists via DNS.": "This document describes a scheme for authenticated, updateable Ethereum node\nlists retrievable via DNS.", "Abstract": "This document describes a scheme for authenticated, updateable Ethereum node\nlists retrievable via DNS.", "Motivation": "Many Ethereum clients contain hard-coded bootstrap node lists. Updating those\nlists requires a software update. The current lists are small, giving the client\nlittle choice of initial entry point into the Ethereum network. We would like to\nmaintain larger node lists containing hundreds of nodes, and update them\nregularly.", "Specification": "A \u2018node list\u2019 is a list of \u2018node records\u2019as defined by EIP-778of arbitrary length. Lists\nmay refer to other lists using links. The entire list is signed using a\nsecp256k1 private key. The corresponding public key must be known to the client\nin order to verify the list.", "DNS Record Structure": "The nodes in a list are encoded as a merkle tree for distribution via the DNS\nprotocol. Entries of the merkle tree are contained in DNS TXT records. The root\nof the tree is a TXT record with the following content:", "Client Protocol": "To find nodes at a given DNS name, say \u201cmynodes.org\u201d:", "Rationale": "We have chosen DNS as the distribution medium because it is always available,\neven under restrictive network conditions. The protocol provides low latency and\nanswers to DNS queries can be cached by intermediate resolvers. No custom server\nsoftware is needed. Node lists can be deployed to any DNS provider such as\nCloudFlare DNS, dnsimple, Amazon Route 53 using their respective client\nlibraries.", "Why DNS?": "We have chosen DNS as the distribution medium because it is always available,\neven under restrictive network conditions. The protocol provides low latency and\nanswers to DNS queries can be cached by intermediate resolvers. No custom server\nsoftware is needed. Node lists can be deployed to any DNS provider such as\nCloudFlare DNS, dnsimple, Amazon Route 53 using their respective client\nlibraries.", "Why is this a merkle tree?": "Being a merkle tree, any node list can be authenticated by a single signature on\nthe root. Hash subdomains protect the integrity of the list. At worst\nintermediate resolvers can block access to the list or disallow updates to it,\nbut cannot corrupt its content. The sequence number prevents replacing the root\nwith an older version.", "Why does the link subtree exist?": "Links between lists enable federation and web-of-trust functionality. The\noperator of a large list can delegate maintenance to other list providers. If\ntwo node lists link to each other, users can use either list and get nodes from\nboth.", "Security Considerations": "Discovery via DNS is less secure than via DHT, because it relies on a trusted\nparty to publish the records regularly. The actor could easily eclipse\nbootstrapping nodes by only publishing node records that it controls.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- node discovery via dns: Proposes a scheme for authenticated, updateable Ethereum node lists retrievable via DNS, providing an alternative to hard-coded bootstrap node lists.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4444, "url": "https://eips.ethereum.org/EIPS/eip-4444", "title": "Bound Historical Data in Execution Clients", "authors": ["George Kadianakis\u00a0(", "@asn-d6", ")", "lightclient\u00a0(", "@lightclient", ")", "Alex Stokes\u00a0(", "@ralexstokes", ")"], "sections": {"EIP-4444: Bound Historical Data in Execution Clients": "Clients must stop serving historical headers, bodies, and receipts older than one year on the p2p layer. Clients may locally prune this historical data.", "Prune historical data in clients older than one year": "Clients must stop serving historical headers, bodies, and receipts older than one year on the p2p layer. Clients may locally prune this historical data.", "Abstract": "Clients must stop serving historical headers, bodies, and receipts older than one year on the p2p layer. Clients may locally prune this historical data.", "Motivation": "Historical blocks and receipts currently occupy more than 400GB of disk space (and growing!). Therefore, to validate the chain, users must typically have a 1TB disk.", "Specification": "Clients SHOULD NOT serve headers, block bodies, and receipts that are older thanHISTORY_PRUNE_EPOCHSepochs on the p2p network.", "Rationale": "This proposal forces clients to stop serving old historical data over p2p. We make this explicit to force clients to seek historical data from other sources, instead of relying on the optional behavior of some clients which would result in quality degradation.", "Why a year?": "This proposal setsHISTORY_PRUNE_EPOCHSto 82125 epochs (one earth year). This constant is large enough to provide sufficient room for the Weak Subjectivity Period to grow, and it\u2019s also small enough so as to not occupy too much disk space.", "Backwards Compatibility": "This proposal impacts nodes that make use of historical data (e.g. web3 applications that display history of blocks, transactions or accounts). Preserving the history of Ethereum is fundamental and we believe there are various out-of-band ways to achieve this.", "Preserving historical data": "This proposal impacts nodes that make use of historical data (e.g. web3 applications that display history of blocks, transactions or accounts). Preserving the history of Ethereum is fundamental and we believe there are various out-of-band ways to achieve this.", "Full syncing from genesis": "Full syncing will no longer be possible over the p2p network. However, we do want to allow interested parties to do so on their own.", "User experience": "This proposal impacts the UX for setting up applications that use historical data. Hence we suggest that clients introduce this change in two phases:", "JSON-RPC changes": "After this proposal is implemented, certain JSON-RPC endpoints (e.g. likegetBlockByHash) won\u2019t be able to tell whether a given hash is invalid or just outdated. Other endpoints likegetLogswill simply no longer have the data the user is requesting. The way this regression should be handled by applications or clients is out-of-scope for this proposal.", "Security Considerations": "With the move to PoS, it\u2019s essential for security to use valid weak subjectivity checkpoints because of long-range attacks.", "Relying on weak subjectivity": "With the move to PoS, it\u2019s essential for security to use valid weak subjectivity checkpoints because of long-range attacks.", "Centralization/censorship risk": "There are censorship/availability risks if there is a lack of incentives to keep historical data.", "Confusion with other proposals": "Because there are a number of alternative proposals for reducing the execution client\u2019s footprint on disk, we\u2019ve decided to enforce a specific pronunciation of the EIP. When pronouncing the EIP number, itMUSTbe pronounced EIP \u201cfour fours\u201d. All other pronounciations are incorrect.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- bound historical data in execution clients: Clients must stop serving and may prune historical headers, bodies, and receipts older than one year, relying on weak subjectivity checkpoints for syncing.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7542, "url": "https://eips.ethereum.org/EIPS/eip-7542", "title": "eth/70 - available-blocks-extended protocol", "authors": ["Ahmad Bitar (@smartprogrammer93)\u00a0<", "smartprogrammer@windowslive.com", ">"], "sections": {"EIP-7542: eth/70 - available-blocks-extended protocol": "The purpose of this EIP is to introduce a method that allows an Ethereum node to communicate the range of blocks it has available. By knowing the block range a node can serve, peers can make more informed decisions when choosing whom to request blocks from or whom to connect to, especially when looking for specific block ranges. This can lead to more efficient network behavior.", "Adds more info in the handshake about available block range and adds message types to request block ranges and the send them": "The purpose of this EIP is to introduce a method that allows an Ethereum node to communicate the range of blocks it has available. By knowing the block range a node can serve, peers can make more informed decisions when choosing whom to request blocks from or whom to connect to, especially when looking for specific block ranges. This can lead to more efficient network behavior.", "Abstract": "The purpose of this EIP is to introduce a method that allows an Ethereum node to communicate the range of blocks it has available. By knowing the block range a node can serve, peers can make more informed decisions when choosing whom to request blocks from or whom to connect to, especially when looking for specific block ranges. This can lead to more efficient network behavior.", "Motivation": "In a first stage ofEIP-4444, some nodes will still need to serve the historical data of the chain and others might be interested in starting to prune it. Currently, nodes need to connect to peers and request specific blocks to determine if a peer has the requested data. This can be inefficient, leading to unnecessary data requests and wasting both bandwidth and time. Consequently, this change empowers nodes that still want to retrieve historical data from the network to do so efficiently.", "Specification": "Upon connecting usingeth/70, nodes should exchange theStatusmessage. Afterwards, they can use theRequestBlockRangeandSendBlockRangemessages to keep informed about peer block range changes.", "Rationale": "Including the available block range in theethhandshake allows for immediate understanding of peer capabilities. This can lead to more efficient networking as nodes can prioritize connections based on the data they need.\nThe new message types are introduced to allow nodes to request updated available block range from other nodes since the range can change by the node syncing or pruning blocks.\nMaintaining connections with peers that don\u2019t have the desired range ensures network resilience, while the exception facilitates efficient block sync under full peer capacity.", "Backwards Compatibility": "This EIP extends theethprotocol handshake in a backwards incompatible manner and proposes the introduction of a new version,eth/70. However,devp2pallows for multiple versions of the same wire protocol to run concurrently. Hence, nodes that have not been updated can continue using older versions likeeth/69,eth/68oreth/67.", "Test Cases": "Testing will involve ensuring that nodes can correctly communicate and understand the block range information during the handshake. Additionally, it will involve ensuring nodes can correctly request and share updated block range when requested.", "Security Considerations": "This change is not a standardization of not storing and serving historical blocks before the implementation of alternative historical blocks storage solutions.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- devp2p: A networking protocol for Ethereum. EIP-8 introduces forward compatibility requirements for devp2p implementations .\n- eth/70 - available-blocks-extended protocol: Introduces eth/70, which extends the Ethereum protocol with block range information and adds messages for requesting and sending block ranges.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6, "url": "https://eips.ethereum.org/EIPS/eip-6", "title": "Renaming SUICIDE opcode", "authors": ["Hudson Jameson\u00a0<", "hudson@hudsonjameson.com", ">"], "sections": {"EIP-6: Renaming SUICIDE opcode": "The solution proposed in this EIP is to change the name of theSUICIDEopcode in Ethereum programming languages withSELFDESTRUCT.", "": "The solution proposed in this EIP is to change the name of theSUICIDEopcode in Ethereum programming languages withSELFDESTRUCT.", "Abstract": "The solution proposed in this EIP is to change the name of theSUICIDEopcode in Ethereum programming languages withSELFDESTRUCT.", "Motivation": "Mental health is a very real issue for many people and small notions can make a difference. Those dealing with loss or depression would benefit from not seeing the word suicide in our programming languages. By some estimates, 350 million people worldwide suffer from depression. The semantics of Ethereum\u2019s programming languages need to be reviewed often if we wish to grow our ecosystem to all types of developers.", "Implementation": "SELFDESTRUCTis added as an alias ofSUICIDEopcode (rather than replacing it).\nhttps://github.com/ethereum/solidity/commit/a8736b7b271dac117f15164cf4d2dfabcdd2c6fd\nhttps://github.com/ethereum/serpent/commit/1106c3bdc8f1bd9ded58a452681788ff2e03ee7c", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 234, "url": "https://eips.ethereum.org/EIPS/eip-234", "title": "Add `blockHash` to JSON-RPC filter options.", "authors": ["Micah Zoltu\u00a0(", "@MicahZoltu", ")"], "sections": {"EIP-234: Add `blockHash` to JSON-RPC filter options.": "Add an option to JSON-RPC filter options (used byeth_newFilterandeth_getLogs) that allows specifying the block hash that should be included in the results.  This option would be an alternative tofromBlock/toBlockoptions.", "": "Add an option to JSON-RPC filter options (used byeth_newFilterandeth_getLogs) that allows specifying the block hash that should be included in the results.  This option would be an alternative tofromBlock/toBlockoptions.", "Simple Summary": "Add an option to JSON-RPC filter options (used byeth_newFilterandeth_getLogs) that allows specifying the block hash that should be included in the results.  This option would be an alternative tofromBlock/toBlockoptions.", "Abstract": "This addition would allow clients to fetch logs for specific blocks, whether those blocks were in the current main chain or not.  This resolves some issues that make it difficult/expensive to author robust clients due to the nature of chain reorgs, unreliable network connections and the result set not containing enough details in the empty case.", "Specification": "The filter options used byeth_newFilterwould have an additional optional parameter namedblockHashwhose value is a single block hash.  The Ethereum node responding to the request would either send back an error if the block hash was not found or it would return the results matching the filter (per normal operation) constrained to the block provided.  Internally, this would function (presumably) similar to thefromBlockandtoBlockfilter options.", "Rationale": "A client (dApp) who needs reliable notification of both log additions (on new blocks) and log removals (on chain reorgs) cannot achieve this while relying solely on subscriptions and filters.  This is because a combination of a network or remote node failure during a reorg can result in the client getting out of sync with reality.  An example of where this can happen with Websockets is when the client opens a web socket connection, sets up a log filter subscription, gets notified of some new logs, then loses the web socket connection, then (while disconnected) a re-org occurs, then the client connects back and establishes a new log filter.  In this scenario they will not receive notification of the log removals from the node because they were disconnected when the removals were broadcast and the loss of their connection resulted in the node forgetting about their existence.  A similar scenario can be concocted for HTTP clients where between polls for updates, the node goes down and comes back (resulting in loss of filter state) and a re-org also occurs between the same two polls.", "Backwards Compatibility": "The only potential issue here is thefromBlockandtoBlockfields.  It wouldn\u2019t make sense to include both the hash and the number so it seems likefromBlock/toBlockshould be mutually exclusive withblockHash.", "Test Cases": "{ \"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"eth_getLogs\", params: [{\"blockHash\": \"0xbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0c\"}] }should return all of the logs for the block with hash0xbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0c.  If atopicsfield is added to the filter options then a filtered set of logs for that block should be returned.  If no block exists with that hash then an error should be returned with acodeof-32000, amessageof\"Block not found.\"and adataof\"0xbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0c\".", "Implementation": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 695, "url": "https://eips.ethereum.org/EIPS/eip-695", "title": "Create `eth_chainId` method for JSON-RPC", "authors": ["Isaac Ardis\u00a0<", "isaac.ardis@gmail.com", ">", "Wei Tang\u00a0(", "@sorpaas", ")", "Fan Torchz\u00a0(", "@tcz001", ")", "Erik Marks\u00a0(", "@rekmarks", ")"], "sections": {"EIP-695: Create `eth_chainId` method for JSON-RPC": "Includeeth_chainIdmethod ineth_-namespaced JSON-RPC methods.", "": "Includeeth_chainIdmethod ineth_-namespaced JSON-RPC methods.", "Simple Summary": "Includeeth_chainIdmethod ineth_-namespaced JSON-RPC methods.", "Abstract": "Theeth_chainIdmethod should return a single STRING result\nfor an integer value in hexadecimal format, describing the\ncurrently configuredCHAIN_IDvalue used for signing replay-protected transactions,\nintroduced byEIP-155.", "Motivation": "Currently although we can usenet_versionRPC call to get the\ncurrent network ID, there\u2019s no RPC for querying the chain ID. This\nmakes it impossible to determine the current actual blockchain using\nthe RPC.", "Specification": "Returns the currently configured chain ID, a value used in replay-protected transaction\nsigning as introduced byEIP-155.", "eth_chainId": "Returns the currently configured chain ID, a value used in replay-protected transaction\nsigning as introduced byEIP-155.", "Rationale": "An ETH/ETC client can accidentally connect to an ETC/ETH RPC\nendpoint without knowing it unless it tries to sign a transaction or\nit fetch a transaction that is known to have signed with a chain\nID. This has since caused trouble for application developers, such as\nMetaMask, to add multi-chain support.", "Backwards Compatibility": "Not relevant.", "Security Considerations": "Consumers should prefereth_chainIdovernet_version, so that they can reliably identify chain they are communicating with.", "Implementation": "Return valueQUANTITYadheres to standard JSON RPC hex value encoding, as documented in theEthereum Wiki.", "Reference": "Return valueQUANTITYadheres to standard JSON RPC hex value encoding, as documented in theEthereum Wiki.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 712, "url": "https://eips.ethereum.org/EIPS/eip-712", "title": "Typed structured data hashing and signing", "authors": ["Remco Bloemen\u00a0(", "@Recmo", ")", "Leonid Logvinov\u00a0(", "@LogvinovLeon", ")", "Jacob Evans\u00a0(", "@dekz", ")"], "sections": {"EIP-712: Typed structured data hashing and signing": "This is a standard for hashing and signing of typed structured data as opposed to just bytestrings. It includes a", "A procedure for hashing and signing of typed structured data as opposed to just bytestrings.": "This is a standard for hashing and signing of typed structured data as opposed to just bytestrings. It includes a", "Abstract": "This is a standard for hashing and signing of typed structured data as opposed to just bytestrings. It includes a", "Motivation": "Signing data is a solved problem if all we care about are bytestrings. Unfortunately in the real world we care about complex meaningful messages. Hashing structured data is non-trivial and errors result in loss of the security properties of the system.", "Specification": "The set of signable messages is extended from transactions and bytestrings\ud835\udd4b \u222a \ud835\udd39\u2078\u207fto also include structured data\ud835\udd4a. The new set of signable messages is thus\ud835\udd4b \u222a \ud835\udd39\u2078\u207f \u222a \ud835\udd4a. They are encoded to bytestrings suitable for hashing and signing as follows:", "Definition of typed structured data\ud835\udd4a": "To define the set of all structured data, we start with defining acceptable types. Like ABIv2 these are closely related to Solidity types. It is illustrative to adopt Solidity notation to explain the definitions. The standard is specific to the Ethereum Virtual Machine, but aims to be agnostic to higher level languages. Example:", "Definition ofhashStruct": "ThehashStructfunction is defined as", "Definition ofencodeType": "The type of a struct is encoded asname \u2016 \"(\" \u2016 member\u2081 \u2016 \",\" \u2016 member\u2082 \u2016 \",\" \u2016 \u2026 \u2016 member\u2099 \")\"where each member is written astype \u2016 \" \" \u2016 name. For example, the aboveMailstruct is encoded asMail(address from,address to,string contents).", "Definition ofencodeData": "The encoding of a struct instance isenc(value\u2081) \u2016 enc(value\u2082) \u2016 \u2026 \u2016 enc(value\u2099), i.e. the concatenation of the encoded member values in the order that they appear in the type. Each encoded member value is exactly 32-byte long.", "Definition ofdomainSeparator": "where the type ofeip712Domainis a struct namedEIP712Domainwith one or more of the below fields. Protocol designers only need to include the fields that make sense for their signing domain. Unused fields are left out of the struct type.", "Specification of theeth_signTypedDataJSON RPC": "The methodeth_signTypedDatais added to the Ethereum JSON-RPC. The method parallelseth_sign.", "Specification of the Web3 API": "Two methods are added to Web3.js version 1 that parallel theweb3.eth.signandweb3.eth.personal.signmethods.", "Rationale": "Theencodefunction is extended with a new case for the new types. The first byte of the encoding distinguishes the cases. For the same reason it is not safe to start immediately with the domain separator or atypeHash. While hard, it may be possible to construct atypeHashthat also happens to be a prefix of a valid RLP encoded transaction.", "Rationale fortypeHash": "ThetypeHashis designed to turn into a compile time constant in Solidity. For example:", "Rationale forencodeData": "TheencodeDatais designed to allow easy implementation ofhashStructin Solidity:", "Rationale fordomainSeparator": "Since different domains have different needs, an extensible scheme is used where the DApp specifies aEIP712Domainstruct type and an instanceeip712Domainwhich it passes to the user-agent. The user-agent can then apply different verification measures depending on the fields that are there.", "Backwards Compatibility": "The RPC calls, web3 methods andSomeStruct.typeHashparameter are currently undefined. Defining them should not affect the behaviour of existing DApps.", "Test Cases": "An example contract can be found inExample.soland an example implementation of signing in JavaScript inExample.js", "Security Considerations": "This standard is only about signing messages and verifying signatures. In many practical applications, signed messages are used to authorize an action, for example an exchange of tokens. It isvery importantthat implementers make sure the application behaves correctly when it sees the same signed message twice. For example, the repeated message should be rejected or the authorized action should be idempotent. How this is implemented is specific to the application and out of scope for this standard.", "Replay attacks": "This standard is only about signing messages and verifying signatures. In many practical applications, signed messages are used to authorize an action, for example an exchange of tokens. It isvery importantthat implementers make sure the application behaves correctly when it sees the same signed message twice. For example, the repeated message should be rejected or the authorized action should be idempotent. How this is implemented is specific to the application and out of scope for this standard.", "Frontrunning attacks": "The mechanism for reliably broadcasting a signature is application-specific and out of scope for this standard. When the signature is broadcast to a blockchain for use in a contract, the application has to be secure against frontrunning attacks. In this kind of attack, an attacker intercepts the signature and submits it to the contract before the original intended use takes place. The application should behave correctly when the signature is submitted first by an attacker, for example by rejecting it or simply producing exactly the same effect as intended by the signer.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- typed structured data hashing and signing: Standardizes the process for signing typed structured data, allowing users to review human-readable messages before signing, improving security and usability in off-chain message signing.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 747, "url": "https://eips.ethereum.org/EIPS/eip-747", "title": "wallet_watchAsset RPC Method", "authors": ["Dan Finlay\u00a0(", "@danfinlay", ")", "Esteban Mino\u00a0(", "@estebanmino", ")", "Gavin John\u00a0(", "@Pandapip1", ")"], "sections": {"EIP-747: wallet_watchAsset RPC Method": "This EIP standardizes a new wallet-scoped RPC method,wallet_watchAsset, to allow a client to suggest a token for the user\u2019s wallet to track.", "Adds a new RPC method that allows websites to prompt users to watch an asset": "This EIP standardizes a new wallet-scoped RPC method,wallet_watchAsset, to allow a client to suggest a token for the user\u2019s wallet to track.", "Abstract": "This EIP standardizes a new wallet-scoped RPC method,wallet_watchAsset, to allow a client to suggest a token for the user\u2019s wallet to track.", "Motivation": "Today, one of the major uses of Ethereum wallets is to track users\u2019 assets.\nWithout this EIP, each wallet either needs to pre-load a list of approved assets, or users must manually add assets to their wallet.\nIn the first case, wallets are burdened with both the security of managing this list, as well as the bandwidth of mass polling for known assets on their wallet.\nIn the second case, the user experience is terrible.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "wallet_watchAssetParameters": "Thewallet_watchAssetmethod takes a single parameter, aWatchAssetParametersobject, which is defined as follows:", "wallet_watchAssetReturns": "wallet_watchAssetimmediately (i.e. without waiting for user interaction) returns the boolean valuetrueto indicate that the request was recognized (regardless of whether the user was prompted), or errors if the request is invalid. An error might occur in the following circumstances (not comprehensive):", "ERC1046type": "The format of the options field is:", "LegacyERC20type": "The format of the options field is:", "Rationale": "Displaying a user\u2019s assets is a basic feature that every modern DApp user expects. Most wallets currently either manage their own asset lists, which they store client-side, or they query a centralized API for balances, which reduces decentralization and allows correlating account holders with IP addresses. Additionally, refreshing/polling an asset list from the network can be costly, especially on bandwidth-constrained devices. Also, maintaining an asset list becomes a political act, provoking harassment and inducing pressure to list obscure assets.", "Security Considerations": "Wallets should be careful about making arbitrary requests to URLs. As such, it is recommended for wallets to sanitize the URI by whitelisting specific schemes and ports. A vulnerable wallet could be tricked into, for example, modifying data on a locally-hosted redis database.", "Server-Side Request Forgery": "Wallets should be careful about making arbitrary requests to URLs. As such, it is recommended for wallets to sanitize the URI by whitelisting specific schemes and ports. A vulnerable wallet could be tricked into, for example, modifying data on a locally-hosted redis database.", "Validation": "Wallets should warn users if the symbol or name matches or is similar to another token, to avoid phishing scams.", "Fingerprinting": "To avoid fingerprinting based on wallet behavior and/or listed assets, the RPC call must return as soon as the user is prompted or an error occurs, without waiting for the user to accept or deny the prompt.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- wallet_watchasset rpc method: Introduces the wallet_watchAsset RPC method to allow websites to suggest tokens for users' wallets to track, improving user experience by making it easier to manage assets.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1193, "url": "https://eips.ethereum.org/EIPS/eip-1193", "title": "Ethereum Provider JavaScript API", "authors": ["Fabian Vogelsteller\u00a0(", "@frozeman", ")", "Ryan Ghods\u00a0(", "@ryanio", ")", "Victor Maia\u00a0(", "@MaiaVictor", ")", "Marc Garreau\u00a0(", "@wolovim", ")", "Erik Marks\u00a0(", "@rekmarks", ")"], "sections": {"EIP-1193: Ethereum Provider JavaScript API": "A JavaScript Ethereum Provider API for consistency across clients and applications.", "": "A JavaScript Ethereum Provider API for consistency across clients and applications.", "Summary": "A JavaScript Ethereum Provider API for consistency across clients and applications.", "Abstract": "A common convention in the Ethereum web application (\u201cdapp\u201d) ecosystem is for key management software (\u201cwallets\u201d) to expose their API via a JavaScript object in the web page.\nThis object is called \u201cthe Provider\u201d.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described inRFC-2119.", "Definitions": "This section is non-normative.", "Connectivity": "The Provider is said to be \u201cconnected\u201d when it can service RPC requests to at least one chain.", "API": "The ProviderMUSTimplement and expose the API defined in this section.\nAll API entitiesMUSTadhere to the types and interfaces defined in this section.", "Supported RPC Methods": "A \u201csupported RPC method\u201d is any RPC method that may be called via the Provider.", "Events": "Events follow the conventions of the Node.jsEventEmitterAPI.", "Rationale": "The purpose of a Provider is toprovidea consumer with access to Ethereum.\nIn general, a Provider must enable an Ethereum web application to do two things:", "Backwards Compatibility": "Many Providers adopted a draft version of this specification before it was finalized.\nThe current API is designed to be a strict superset of the legacy version, and this specification is in that sense fully backwards compatible.\nSeeAppendix IIIfor the legacy API.", "Implementations": "At the time of writing, the following projects have working implementations:", "Security Considerations": "The Provider is intended to pass messages between an Ethereum Client and an Ethereum application.\nIt isnotresponsible for private key or account management; it merely processes RPC messages and emits events.\nConsequently, account security and user privacy need to be implemented in middlewares between the Provider and its Ethereum Client.\nIn practice, we call these middleware applications \u201cWallets,\u201d and they usually manage the user\u2019s private keys and accounts.\nThe Provider can be thought of as an extension of the Wallet, exposed in an untrusted environment, under the control of some third party (e.g. a website).", "Handling Adversarial Behavior": "Since it is a JavaScript object, consumers can generally perform arbitrary operations on the Provider, and all its properties can be read or overwritten.\nTherefore, it is best to treat the Provider object as though it is controlled by an adversary.\nIt is paramount that the Provider implementer protects the user, Wallet, and Client by ensuring that:", "Chain Changes": "Since all Ethereum operations are directed at a particular chain, it\u2019s important that the Provider accurately reflects the Client\u2019s configured chain, per theeth_chainIdEthereum RPC method (seeEIP-695).", "User Account Exposure and Account Changes": "Many Ethereum write operations (e.g.eth_sendTransaction) require a user account to be specified.\nProvider consumers access these accounts via theeth_accountsRPC method, and by listening for theaccountsChangedevent.", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Appendix I: Consumer-Facing API Documentation": "Makes an Ethereum RPC method call.", "request": "Makes an Ethereum RPC method call.", "Errors": "These examples assume a web browser environment.", "Appendix II: Examples": "These examples assume a web browser environment.", "Appendix III: Legacy Provider API": "This section documents the legacy Provider API, which is extensively used in production at the time of writing.\nAs it was never fully standardized, significant deviations occur in practice.\nThe authors recommend against implementing it except to support legacy Ethereum applications.", "sendAsync (DEPRECATED)": "This method is superseded byrequest.", "send (DEPRECATED)": "This method is superseded byrequest.", "Legacy Events": "This event is superseded bydisconnect.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- ethereum provider javascript api: Formalizes a JavaScript API for Ethereum providers to standardize how web applications interact with wallets and clients, enhancing consistency across implementations.\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1898, "url": "https://eips.ethereum.org/EIPS/eip-1898", "title": "Add `blockHash` to defaultBlock methods", "authors": ["Charles Cooper\u00a0(", "@charles-cooper", ")"], "sections": {"EIP-1898: Add `blockHash` to defaultBlock methods": "For JSON-RPC methods which currently accept a default block parameter, additionally allow the parameter to be a block hash.", "Add `blockHash` option to JSON-RPC methods that currently support defaultBlock parameter.": "For JSON-RPC methods which currently accept a default block parameter, additionally allow the parameter to be a block hash.", "Abstract": "For JSON-RPC methods which currently accept a default block parameter, additionally allow the parameter to be a block hash.", "Specification": "The following JSON-RPC methods are affected:", "Rationale": "Currently, the state-querying JSON-RPC methods specified above have no option to unambiguously specify which block to query the state for. This can cause issues for applications which need to make multiple calls to the RPC. For instance, a wallet which just executed a transfer may want to display the balances of both the sender and recipient. If there is a re-org in between when the balance of the sender is queried viaeth_getBalanceand when the balance of the recipient is queried, the balances may not reconcile. As a slightly more complicated example, the UI for a decentralized exchange (which hosts orders on-chain) may walk a list of orders by callingeth_callfor each of them to get the order data. Another type of use case is where an application needs to make a decision based on multiple pieces of state, e.g. a payout predicated on simultaneous ownership of two NFTs.", "Backwards Compatibility": "Backwards compatible.", "Test Cases": "None", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2159, "url": "https://eips.ethereum.org/EIPS/eip-2159", "title": "Common Prometheus Metrics Names for Clients", "authors": ["Adrian Sutton\u00a0(", "@ajsutton", ")"], "sections": {"EIP-2159: Common Prometheus Metrics Names for Clients": "Standardized names of common metrics for Ethereum clients to use with Prometheus, a widely used monitoring and alerting solution.", "": "Standardized names of common metrics for Ethereum clients to use with Prometheus, a widely used monitoring and alerting solution.", "Simple Summary": "Standardized names of common metrics for Ethereum clients to use with Prometheus, a widely used monitoring and alerting solution.", "Abstract": "Many Ethereum clients expose a range of metrics in a format compatible with Prometheus to allow operators to monitor the client\u2019s behaviour and performance and raise alerts if the chain isn\u2019t progressing or there are other indications of errors.\nWhile the majority of these metrics are highly client-specific, reporting on internal implementation details of the client, some are applicable to all clients.\nBy standardizing the naming and format of these common metrics, operators are able to monitor the operation of multiple clients in a single dashboard or alerting configuration.", "Motivation": "Using common names and meanings for metrics which apply to all clients allows node operators to monitor clusters of nodes using heterogeneous clients using a single dashboard and alerting configuration.\nCurrently there are no agreed names or meanings, leaving client developers to invent their own making it difficult to monitor a heterogeneous cluster.", "Specification": "The table below defines metrics which may be captured by Ethereum clients which expose metrics to Prometheus. Clients may expose additional metrics however these should not use theethereum_prefix.", "Rationale": "The defined metrics are independent of Ethereum client implementation but provide sufficient information to create an overview dashboard to support monitoring a group of Ethereum nodes.", "Backwards Compatibility": "This isnota consensus affecting change.", "Implementation": "Pantheon switched to using these standard metric names in its 1.2 release: https://github.com/PegaSysEng/pantheon/pull/1634.", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- common prometheus metrics: Standardizes names and formats for common metrics across Ethereum clients to ensure compatibility with Prometheus monitoring.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2255, "url": "https://eips.ethereum.org/EIPS/eip-2255", "title": "Wallet Permissions System", "authors": ["Dan Finlay\u00a0(", "@danfinlay", ")", "Erik Marks\u00a0(", "@rekmarks", ")", "Gavin John\u00a0(", "@Pandapip1", ")"], "sections": {"EIP-2255: Wallet Permissions System": "This EIP adds two new wallet-namespaced RPC endpoints,wallet_getPermissionsandwallet_requestPermissions, providing a standard interface for requesting and checking permissions.", "An interface to restrict access to sensitive methods": "This EIP adds two new wallet-namespaced RPC endpoints,wallet_getPermissionsandwallet_requestPermissions, providing a standard interface for requesting and checking permissions.", "Abstract": "This EIP adds two new wallet-namespaced RPC endpoints,wallet_getPermissionsandwallet_requestPermissions, providing a standard interface for requesting and checking permissions.", "Motivation": "Wallets are responsible for mediating interactions between untrusted applications and users\u2019 keys through appropriate user consent. Today, wallets always prompt the user for every action. This provides security at the cost of substantial user friction. We believe that a single permissions request can achieve the same level of security with vastly improved UX.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "wallet_getPermissions": "Thewallet_getPermissionsmethod is used for getting an array of current permissions (empty by default). It takes no parameters and returns an array ofPermissionobjects.", "wallet_requestPermissions": "Thewallet_requestPermissionsmethod is used for an application to request additional permissions. It MUST take a single parameter, aPermissionRequestobject, and MUST return an array ofRequestedPermissionobjects.", "Rationale": "While the current model of getting user consent on a per-action basis has high security, there are huge usability gains to be had bo getting more general user consent which can cover broad categories of usage, which can be expressed in a more human-readable way. This pattern has a variety of benefits to offer different functions within a web3 wallet.", "Test Cases": "The following example should prompt the user to approve theeth_accountspermission, and return the permission object if approved.", "Requesting permissions": "The following example should prompt the user to approve theeth_accountspermission, and return the permission object if approved.", "Getting permissions": "The following example should return the current permissions object.", "Security Considerations": "This consideration is applicable if the favicon of a website is to be displayed.", "Server-Side Request Forgery (SSRF)": "This consideration is applicable if the favicon of a website is to be displayed.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- wallet_getpermissions: Adds a JSON-RPC method for dApps to retrieve the permissions granted by a wallet for specific actions.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2696, "url": "https://eips.ethereum.org/EIPS/eip-2696", "title": "JavaScript `request` method RPC transport", "authors": ["Micah Zoltu\u00a0(", "@MicahZoltu", ")", "Erik Marks\u00a0(", "@rekmarks", ")"], "sections": {"EIP-2696: JavaScript `request` method RPC transport": "A standard for remote procedure calls between an Ethereum Provider and an Ethereum Client when both are able to interface with each other via a shared JavaScript object.", "": "A standard for remote procedure calls between an Ethereum Provider and an Ethereum Client when both are able to interface with each other via a shared JavaScript object.", "Simple Summary": "A standard for remote procedure calls between an Ethereum Provider and an Ethereum Client when both are able to interface with each other via a shared JavaScript object.", "Abstract": "This standard provides the description of an object that is made available to JavaScript applications which they can use to communicate with the Ethereum blockchain through.  This standard only describes the transport mechanism, it does not specify the payloads that are valid nor does it specify how the client or the provider will discover or agree on payload content.", "Motivation": "When working within a JavaScript runtime (such as NodeJS, Electron, Browser, etc.) it may be possible for the runtime or a runtime plugin to inject objects into the runtime.  Someone authoring a runtime or a runtime plugin may choose to expose an Ethereum Provider to any JavaScript apps or scripts running within that runtime in order to provide indirect access to an Ethereum-like blockchain and potentially signing tools.  In order to achieve maximum compatibility between the provider and the client, a standard is necessary for what the shape of that object is.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d,  \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described inRFC-2119.", "RFC-2119": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d,  \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described inRFC-2119.", "Interface": "TypeScript interface definition:", "Results": "If the Provider supports a JSON-RPC request as specified elsewhere, then itMUSTreturn an object that matches the expectedresultdefinition for the associated JSON-RPC request.", "Errors": "If the Provider is unable to fulfill a request for any reason, itMUSTresolve the promise as an error.  The resolved errorMUSTbe shaped as aProviderRpcErrordefined above whenever possible.While it is impossible to guaranteed that a JavaScript application will never throw an out of memory or stack overflow error, care should be taken to ensure that promise rejections conform to the above shape whenever possible.", "Rationale": "While this standard is perhaps not the greatest mechanism for communicating between an application and a blockchain, it is closely aligned with established practices within the community so migration from existing systems to this one should be relatively easy.  Most communication is currently done via JSON-RPC, so aligning with the JSON-RPC standard was desired to enable quick integration with existing systems.", "Security Considerations": "The relationship between Ethereum Provider and client is a trusted one, where it is assumed that the user implicitly trusts the Ethereum Provider which is how it managed to get injected into the client, or the client expressly pulled in a connection to it.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- treturn: A new opcode that allows returning data directly from transient storage without first copying it to memory.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2700, "url": "https://eips.ethereum.org/EIPS/eip-2700", "title": "JavaScript Provider Event Emitter", "authors": ["Micah Zoltu\u00a0(", "@MicahZoltu", ")", "Erik Marks\u00a0(", "@rekmarks", ")"], "sections": {"EIP-2700: JavaScript Provider Event Emitter": "A standard mechanism for JavaScript Ethereum Providers to notify clients about chain state changes when both are able to interface with each other via a shared JavaScript object.", "": "A standard mechanism for JavaScript Ethereum Providers to notify clients about chain state changes when both are able to interface with each other via a shared JavaScript object.", "Simple Summary": "A standard mechanism for JavaScript Ethereum Providers to notify clients about chain state changes when both are able to interface with each other via a shared JavaScript object.", "Abstract": "This standard provides the description of an object that is made available to JavaScript applications which they can use to receive notifications from an Ethereum Provider.  This standard only describes the notification mechanism, it does not specify the payloads that are valid nor does it specify how the client or the provider will discover or agree on payload content.", "Motivation": "When working within a JavaScript runtime (such as NodeJS, Electron, Browser, etc.) it may be possible for the runtime or a runtime plugin to inject objects into the runtime.  Someone authoring a runtime or a runtime plugin may choose to expose an Ethereum Provider to any JavaScript apps or scripts running within that runtime in order to provide notifications of blockchain state changes.  In order to achieve maximum compatibility between the provider and the client, a standard is necessary for what the shape of that object is.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d,  \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described inRFC-2119.", "RFC-2119": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d,  \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described inRFC-2119.", "Interface": "The specific events that can be listened to and the shape of their listener callback functions is left to be defined in separate standards.", "Rationale": "This EIP is mostly a retrospective EIP meaning it codifies an already existing specification so there isn\u2019t a lot of room for improving things such as by using a discriminated union object for listener parameters or having a tighter definition ofon.  The specific events are intentionally left out of this specification as that set will be an ever-evolving collection and having the first few listed here doesn\u2019t add value to this specification (especially if, over time, the first few end up deprecated or unused).", "Security Considerations": "The relationship between Ethereum Provider and client is a trusted one, where it is assumed that the user implicitly trusts the Ethereum Provider which is how it managed to get injected into the client, or the client expressly pulled in a connection to it.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- javascript provider event emitter: Introduces standard event handling methods (on and removeListener) for JavaScript Ethereum Providers to notify clients about blockchain state changes.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4736, "url": "https://eips.ethereum.org/EIPS/eip-4736", "title": "Consensus Layer Withdrawal Protection", "authors": ["Benjamin Chodroff\u00a0(", "@benjaminchodroff", ")", "Jim McDonald\u00a0(", "@mcdee", ")"], "sections": {"EIP-4736: Consensus Layer Withdrawal Protection": "If a consensus layer mnemonic phrase is compromised, it is impossible for the consensus layer network to differentiate the legitimate holder of the key from an illegitimate holder. However, there are signals that can be considered in a wider sense without changing core Ethereum consensus. This proposal outlines ways in which on chain evidence such as the execution layer deposit address and list of signed messages could create a social consensus that would significantly favor but not guarantee legitimate mnemonic holders would win a race condition against an attacker.", "Additional security for BLSToExecutionChange operation when a consensus layer mnemonic may be compromised, without changing consensus": "If a consensus layer mnemonic phrase is compromised, it is impossible for the consensus layer network to differentiate the legitimate holder of the key from an illegitimate holder. However, there are signals that can be considered in a wider sense without changing core Ethereum consensus. This proposal outlines ways in which on chain evidence such as the execution layer deposit address and list of signed messages could create a social consensus that would significantly favor but not guarantee legitimate mnemonic holders would win a race condition against an attacker.", "Abstract": "If a consensus layer mnemonic phrase is compromised, it is impossible for the consensus layer network to differentiate the legitimate holder of the key from an illegitimate holder. However, there are signals that can be considered in a wider sense without changing core Ethereum consensus. This proposal outlines ways in which on chain evidence such as the execution layer deposit address and list of signed messages could create a social consensus that would significantly favor but not guarantee legitimate mnemonic holders would win a race condition against an attacker.", "Motivation": "The consensus layerBLSToExecutionChangemessage is secure for a single user who has certainty their keys and mnemonic have not been compromised. However, as validator withdrawals on the consensus layer are not possible until the Capella hard fork, no user can have absolute certainty that their keys are not compromised until theBLSToExecutionChangeis on chain, and by then too late to change. All legitimate mnemonic phrase holders were originally in control of the execution layer deposit address. Beacon node clients and node operators may optionally load a list of verifiableBLSToExecutionChangemessages to broadcasts that may create a social consensus for legitimate holders to successfully win a race condition against an attacker. If attackers compromise a significant number of consensus layer nodes, it would pose risks to the entire Ethereum community.", "Specification": "The Consensus LayerBLSToExecutionChangeoperation has the following fields:", "BLSToExecutionChangeBroadcast File": "A \u201cchange-operations.json\u201d file intended to be preloaded with all consensus layer withdrawal credential signatures and verifiable execution layer deposit addresses. This file may be generated by a script and able to be independently verified by community members using the consensus layer node, and intended to be included by all clients, enabled by default. Client nodes are encouraged to enable packaging this independently verifiable list with the client software, and enable it by default to help further protect the community from unsuspected attacks.", "BLSToExecutionChangeHandling": "Beacon node clients are RECOMMENDED to allow accepting \u201cBLSToExecutionChangeBroadcast\u201d file of verifiable signatures, and then MAY fallback to accept a \u201cfirst request\u201d via P2P. All of this proposal is OPTIONAL for beacon nodes to implement or use, but all client teams are RECOMMENDED to allow a \u201cBLSToExecutionChangeBroadcast File\u201d to be loaded locally before the Capella hard fork. This OPTIONAL protection will allow a user to attempt to set a withdrawal address message as soon as the network supports it without any change to consensus.", "Rationale": "This proposal is intended to protect legitimate validator mnemonic holders where it was knowingly or unknowingly compromised. As there is no safe way to transfer ownership of a validator without exiting, it can safely be assumed that all validator holders intend to set to a withdrawal address they specify. Using the deposit address in the execution layer to determine the legitimate holder is not possible to consider in consensus as it may be far back in history and place an overwhelming burden to maintain such a list. As such, this proposal outlines optional mechanism which protect legitimate original mnemonic holders and does so in a way that does not place any mandatory burden on client node software or operators.", "Backwards Compatibility": "As there is no existingBLSToExecutionChangeoperation prior to Capella, there is no documented backwards compatibility. As all of the proposal is OPTIONAL in both implementation and operation, it is expected that client beacon nodes that do not implement this functionality would still remain fully backwards compatible with any or all clients that do implement part or all of the functionality described in this proposal. Additionally, while users are RECOMMENDED to enable these OPTIONAL features, if they decide to either disable or ignore some or all of the features, or even purposefully load content contrary to the intended purpose, the beacon node client will continue to execute fully compatible with the rest of the network as none of the proposal will change core Ethereum consensus.", "Reference Implementation": "A \u201cchange-operations.json\u201d file intended to be preloaded with all consensus layer withdrawal credential signatures and verifiable execution layer deposit addresses. This file may be generated by a script and able to be independently verified by community members using the consensus layer node, and intended to be included by all clients, enabled by default. Client nodes are encouraged to enable packaging this independently verifiable list with the client software, and enable it by default to help further protect the community from unsuspected attacks.", "BLSToExecutionChangeBroadcast File - Claim": "A community collected and independently verifiable list of \u201cBLSToExecutionChangeBroadcasts\u201d containing verifiable claims will be collected. Node operators may verify these claims independently and are suggested to load claims in compatible beacon node clients.", "Security Considerations": "User A signs and submits a claim to the CLWP repository, clients load User A message into the \u201cBLSToExecutionChangeBroadcast\u201d file. At the time of the first epoch supportBLSToExecutionChange, many (not all) nodes begin to broadcast the message. User B also tries to submit a different but validBLSToExecutionChangeto an address that does not match the signature in the claim. This message is successfully received via REST API, but some (not all) nodes begin to silently drop this message as the signature does not match the signature in the \u201cBLSToExecutionChangeBroadcast\u201d file. As such, these nodes do not replicate this message via P2P.", "1: Attacker lacks EL deposit key, uncontested claim": "User A signs and submits a claim to the CLWP repository, clients load User A message into the \u201cBLSToExecutionChangeBroadcast\u201d file. At the time of the first epoch supportBLSToExecutionChange, many (not all) nodes begin to broadcast the message. User B also tries to submit a different but validBLSToExecutionChangeto an address that does not match the signature in the claim. This message is successfully received via REST API, but some (not all) nodes begin to silently drop this message as the signature does not match the signature in the \u201cBLSToExecutionChangeBroadcast\u201d file. As such, these nodes do not replicate this message via P2P.", "2: Attacker has both EL deposit key and CL keys, uncontested claim": "It is possible/likely that User A would notice that all their funds in the EL deposit address had been stolen. This may signal that their CL key is compromised as well, so they decide to pick a new address for the withdrawal. The story will play out the same as Scenario 1 as the claim is uncontested.", "3: Same as #2, but the attacker submits a contested claim": "This is a contested claim and as such there is no way to prove who is in control using on chain data. Instead, either user may try to persuade the community they are the rightful owner (identity verification, social media, etc.) in an attempt to get node operators to load their contested claim into their \u201cBLSToExecutionChangeBroadcast\u201d file. However, there is no way to fully prove it.", "4: A user has lost either their CL key and/or mnemonic (no withdrawal key)": "There is no way to recover this scenario with this proposal as we cannot prove a user has lost their keys, and the mnemonic is required to generate the withdrawal key.", "5: End game - attacker": "Upon noticing User A has submitted a successful set address withdrawal, User B may run a validator and attempt to get User A slashed. Users who suspect their validator key or seed phrase is compromised should take action to exit their validator as early as possible.", "6: Compromised key, but not vulnerable to withdrawal": "User A may generate the withdrawal key (requires the mnemonic). User B can attack User A by getting them slashed, but will be unable to generate the withdrawal key.", "7: Attacker loads a maliciousBLSToExecutionChangeBroadcast file into one or multiple nodes, User A submits claim": "User B\u2019s claim will make it into many nodes, but when it hits nodes that have adopted User A\u2019s signature they will be dropped and not rebroadcast. Statistically, User B will have a harder time achieving consensus among the entire community, but it will be down to chance.", "8: Same as #7, but User A submits no claim": "The attacker will statistically likely win as they will be first to have their message broadcast to many nodes and, unless User A submits a request exactly at the time of support, it is unlikely to be heard by enough nodes to gain consensus. All users are encouraged to submit claims for this reason because nobody can be certain their mnemonic has not been compromised until it is too late.", "Second Order Effects": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- consensus layer withdrawal protection: Proposes additional protection for the BLSToExecutionChange operation to mitigate the risk of compromised consensus layer keys, providing a social consensus mechanism to favor legitimate holders.\n- withdrawal: Log entry in system_logs for tracking withdrawals under EIP-4895 ."}
{"eip": 4881, "url": "https://eips.ethereum.org/EIPS/eip-4881", "title": "Deposit Contract Snapshot Interface", "authors": ["Mark Mackey\u00a0(", "@ethDreamer", ")"], "sections": {"EIP-4881: Deposit Contract Snapshot Interface": "This EIP defines a standard format for transmitting the deposit contract Merkle tree in a compressed form during weak subjectivity sync. This allows newly syncing consensus clients to reconstruct the deposit tree much faster than downloading all historical deposits. The format proposed also allows clients to prune deposits that are no longer needed to participate fully in consensus (seeDeposit Finalization Flow).", "Establishing the format and endpoint for transmitting a snapshot of the deposit Merkle tree": "This EIP defines a standard format for transmitting the deposit contract Merkle tree in a compressed form during weak subjectivity sync. This allows newly syncing consensus clients to reconstruct the deposit tree much faster than downloading all historical deposits. The format proposed also allows clients to prune deposits that are no longer needed to participate fully in consensus (seeDeposit Finalization Flow).", "Abstract": "This EIP defines a standard format for transmitting the deposit contract Merkle tree in a compressed form during weak subjectivity sync. This allows newly syncing consensus clients to reconstruct the deposit tree much faster than downloading all historical deposits. The format proposed also allows clients to prune deposits that are no longer needed to participate fully in consensus (seeDeposit Finalization Flow).", "Motivation": "To reconstruct the deposit Merkle tree, most client implementations require beacon nodes to download and store every deposit log since the launch of the deposit contract. However, this approach requires beacon nodes to store far more deposits than necessary to participate in consensus. Additionally, this leads to increased sync times for new nodes, which is particularly evident during weak subjectivity sync. This simplistic approach also prevents historical contract logs from being pruned from full nodes, a prospect frequently discussed in the context of limiting state growth.", "Specification": "Consensus clients MAY continue to implement the deposit Merkle tree however they choose. However, when transmitting the tree to newly syncing nodes, clients MUST use the following format:", "Deposit Finalization Flow": "During deposit processing, the beacon chain requires deposits to be submitted along with a Merkle path to the deposit root. This is required exactly once for each deposit. When a deposit has been processed by the beacon chain and thedeposit finalization conditionshave been met, many of the hashes along the path to the deposit root will never be required again to construct Merkle proofs on chain. These unnecessary hashes MAY be pruned to save space. The image below illustrates the evolution of the deposit Merkle tree under this process alongside the correspondingDepositTreeSnapshotas new deposits are added and older deposits become finalized:", "Rationale": "The format in this specification was chosen to achieve several goals simultaneously:", "Why not Reconstruct the Tree Directly from the Deposit Contract?": "The deposit contract can only provide the tree at the head of the chain. Because the beacon chain\u2019s view of the deposit contract lags behind the execution chain byETH1_FOLLOW_DISTANCE, there are almost always deposits which haven\u2019t yet been included in the chain that need proofs constructed from an earlier version of the tree than exists at the head.", "Why not Reconstruct the Tree from a Deposit in the Beacon Chain?": "In principle, a node could scan backwards through the chain starting from the weak subjectivity checkpoint to locate a suitableDeposit, and then extract the rightmost branch of the tree from that. The node would also need to extract theexecution_block_hashfrom which to start syncing new deposits from theEth1Datain the correspondingBeaconState. This approach is less desirable for a few reasons:", "Backwards Compatibility": "This proposal is fully backwards compatible.", "Test Cases": "Test cases are included intest_cases.yaml. Each case is structured as follows:", "Reference Implementation": "This implementation lacks full error checking and is optimized for readability over efficiency. Iftreeis aDepositTree, then theDepositTreeSnapshotcan be obtained by callingtree.get_snapshot()and a new instance of the tree can be recovered from the snapshot by callingDepositTree.from_snapshot(). See theDeposit Finalization Conditionssection for discussion on when the tree can be pruned by callingtree.finalize().", "Security Considerations": "The upcoming switch to PoS will require newly synced nodes to rely on valid weak subjectivity checkpoints because of long-range attacks. This proposal relies on the weak subjectivity assumption that clients will not bootstrap with an invalid WS checkpoint.", "Relying on Weak Subjectivity Sync": "The upcoming switch to PoS will require newly synced nodes to rely on valid weak subjectivity checkpoints because of long-range attacks. This proposal relies on the weak subjectivity assumption that clients will not bootstrap with an invalid WS checkpoint.", "Deposit Finalization Conditions": "Care must be taken not to send a snapshot which includes deposits that haven\u2019t been fully included in the finalized checkpoint. Letstatebe theBeaconStateat a given block in the chain. Under normal operation, theEth1Datastored instate.eth1_datais replaced everyEPOCHS_PER_ETH1_VOTING_PERIODepochs. Thus, finalization of the deposit tree proceeds with increments ofstate.eth1_data. Leteth1databe someEth1Data. Both of the following conditions MUST be met to considereth1datafinalized:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- deposit contract snapshot interface: Defines a format for transmitting the deposit contract Merkle tree in a compressed form, improving weak subjectivity sync times and reducing storage requirements for consensus clients.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5749, "url": "https://eips.ethereum.org/EIPS/eip-5749", "title": "The 'window.evmproviders' object", "authors": ["Kosala Hemachandra\u00a0(", "@kvhnuke", ")"], "sections": {"EIP-5749: The 'window.evmproviders' object": "A Javascript Ethereum Provider interface injection that will allow for the interoperability of multiple browser wallets at the same time. Replacingwindow.ethereumwithwindow.evmprovidersis a simple solution that will provide multiple benefits including: improving user experience, encouraging innovation in the space, removing race conditions and a \u2018winner-takes-most\u2019 environment as well as lowering barriers for user adoption.", "Add 'window.evmproviders' and suggest the eventual removal of 'window.ethereum'": "A Javascript Ethereum Provider interface injection that will allow for the interoperability of multiple browser wallets at the same time. Replacingwindow.ethereumwithwindow.evmprovidersis a simple solution that will provide multiple benefits including: improving user experience, encouraging innovation in the space, removing race conditions and a \u2018winner-takes-most\u2019 environment as well as lowering barriers for user adoption.", "Abstract": "A Javascript Ethereum Provider interface injection that will allow for the interoperability of multiple browser wallets at the same time. Replacingwindow.ethereumwithwindow.evmprovidersis a simple solution that will provide multiple benefits including: improving user experience, encouraging innovation in the space, removing race conditions and a \u2018winner-takes-most\u2019 environment as well as lowering barriers for user adoption.", "Motivation": "At present,window.ethereumis the prevailing method by which Ethereum-compatible applications interact with injected wallets. This originated with Mist Wallet in 2015 to interact with other applications. With the proliferation of both applications and wallets,window.ethereumhas unintended negative consequences:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "window.evmproviders={}": "TypeEIP1193Provideris documented atEIP-1193", "Rationale": "Standardizing aProviderInfotype allows determining the necessary information to populate a wallet selection popup. This is particularly useful for web3 onboarding libraries such as Web3Modal, Web3React, and Web3Onboard.", "Backwards Compatibility": "This EIP doesn\u2019t require supplantingwindow.ethereum, so it doesn\u2019t directly break existing applications. However, the recommended behavior of eventually supplantingwindow.ethereumwould break existing applications that rely on it.", "Reference Implementation": "The security considerations of EIP-1193 apply to this EIP.", "Injection": "The security considerations of EIP-1193 apply to this EIP.", "Retrieving all EVM providers": "The security considerations of EIP-1193 apply to this EIP.", "Security Considerations": "The security considerations of EIP-1193 apply to this EIP.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6963, "url": "https://eips.ethereum.org/EIPS/eip-6963", "title": "Multi Injected Provider Discovery", "authors": ["Pedro Gomes\u00a0(", "@pedrouid", ")", "Kosala Hemachandra\u00a0(", "@kvhnuke", ")", "Richard Moore\u00a0(", "@ricmoo", ")", "Gregory Markou\u00a0(", "@GregTheGreek", ")", "Kyle Den Hartog\u00a0(", "@kdenhartog", ")", "Glitch\u00a0(", "@glitch-txs", ")", "Jake Moxey\u00a0(", "@jxom", ")", "Pierre Bertet\u00a0(", "@bpierre", ")", "Darryl Yeo\u00a0(", "@darrylyeo", ")", "Yaroslav Sergievsky\u00a0(", "@everdimension", ")"], "sections": {"EIP-6963: Multi Injected Provider Discovery": "An alternative discovery mechanism towindow.ethereumforEIP-1193providers which supports discovering multiple injected Wallet Providers in a web page using Javascript\u2019swindowevents.", "Using window events to announce injected Wallet Providers": "An alternative discovery mechanism towindow.ethereumforEIP-1193providers which supports discovering multiple injected Wallet Providers in a web page using Javascript\u2019swindowevents.", "Abstract": "An alternative discovery mechanism towindow.ethereumforEIP-1193providers which supports discovering multiple injected Wallet Providers in a web page using Javascript\u2019swindowevents.", "Motivation": "Currently, Wallet Provider that offer browser extensions must inject their Ethereum providers (EIP-1193) into the same window objectwindow.ethereum; however, this creates conflicts for users that may install more than one browser extension.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described inRFC-2119.", "Definitions": "Wallet Provider: A user agent that manages keys and facilitates transactions with Ethereum.", "Provider Info": "Each Wallet Provider will be announced with the following interfaceEIP6963ProviderInfo. The values in theEIP6963ProviderInfoMUST be included within theEIP6963ProviderInfoobject. TheEIP6963ProviderInfoMAY also include extra extensible properties within the object. If a DApp does not recognize the additional properties, it SHOULD ignore them.", "Provider Detail": "TheEIP6963ProviderDetailis used as a composition interface to announce a Wallet Provider and related metadata about the Wallet Provider. TheEIP6963ProviderDetailMUST contain aninfoproperty of typeEIP6963ProviderInfoand aproviderproperty of typeEIP1193Providerdefined byEIP-1193.", "Window Events": "In order to prevent provider collisions, the DApp and the Wallet are expected to emit an event and instantiate an eventListener to discover the various Wallets. This forms an Event concurrency loop.", "Rationale": "The previous proposal introduced mechanisms that relied on a single, mutable window object that could be overwritten by multiple parties. We opted for an event-based approach to avoid the race conditions, the namespace collisions, and the potential for \u201cpollution\u201d attacks on a shared mutable object; the event-based orchestration creates a bidirectional communication channel between wallet and dapp that can be re-orchestrated over time.", "Interfaces": "Standardizing an interface for provider information (EIP6963ProviderInfo) allows a DApp to determine all information necessary to populate a user-friendly wallet selection modal. This is particularly useful for DApps that rely on libraries such as Web3Modal, RainbowKit, Web3-Onboard, or ConnectKit to programmatically generate such selection modals.", "Backwards Compatibility": "This EIP doesn\u2019t require supplantingwindow.ethereum, so it doesn\u2019t directly break existing applications that cannot update to this method of Wallet discovery. However, it is RECOMMENDED DApps implement this EIP to ensure discovery of multiple Wallet Providers and SHOULD disablewindow.ethereumusage except as a fail-over when discovery fails. Similarly, Wallets SHOULD keep compatibility ofwindow.ethereumto ensure backwards compatibility for DApps that have not implemented this EIP. In order to prevent the previous issues of namespace collisions, it\u2019s also RECOMMENDED that wallets inject their provider object under a wallet specific namespace then proxy the object into thewindow.ethereumnamespace.", "Reference Implementation": "Here is a reference implementation for an injected script by a Wallet Provider to support this new interface in parallel with the existing pattern.", "Wallet Provider": "Here is a reference implementation for an injected script by a Wallet Provider to support this new interface in parallel with the existing pattern.", "DApp implementation": "Here is a reference implementation for a DApp to display and track multiple Wallet Providers that are injected by browser extensions.", "Security Considerations": "The security considerations ofEIP-1193apply to this EIP. Implementers are expected to consider and follow the guidance of the providers they\u2019re utilizing as well.", "EIP-1193 Security considerations": "The security considerations ofEIP-1193apply to this EIP. Implementers are expected to consider and follow the guidance of the providers they\u2019re utilizing as well.", "Prototype Pollution of Wallet Provider objects": "Browser extensions, and therefore Wallet extensions, are able to modify the contents of the page and the Provider object by design. The provider objects of various Wallets are considered a highly trusted interface to communicate transaction data. In order to prevent the page or various other extensions from modifying the interaction between the DApp and the Wallet in an unexpected way, the best practice is to \u201cfreeze\u201d the provider discovery object by utilizingobject.freeze()on theEIP1193Providerobject before the wallet dispatches it in theeip6963:announceProviderEvent. However, there are difficulties that can occur around web compatibility where pages need to monkey patch the object. In scenarios like this there\u2019s a tradeoff that needs to be made between security and web compatibility that Wallet implementers are expected to consider.", "Wallet Imitation and Manipulation": "Similarly so, DApps are expected to actively detect for misbehavior of properties or functions being modified in order to tamper with or modify other wallets. One way this can be easily achieved is to look for when theuuidproperty within twoEIP6963ProviderInfoobjects match. DApps and DApp discovery libraries are expected to consider other potential methods that theEIP6963ProviderInfoobjects are being tampered with and consider additional mitigation techniques to prevent this as well in order to protect the user.", "Prevent SVG Javascript Execution": "The use of SVG images introduces a cross-site scripting risk as they can include JavaScript code. This Javascript executes within the context of the page and can therefore modify the page or the contents of the page. So when considering the experience of rendering the icons, DApps need to take into consideration how they\u2019ll approach handling these concerns in order to prevent an image being used as an obfuscation technique to hide malicious modifications to the page or to other wallets.", "Prevent Wallet Fingerprinting": "One advantage to the concurrency Event loop utilized by this design is that it operates in a manner where either the DApp or the Wallet can initiate the flow to announce a provider. For this reason, Wallet implementers can now consider whether or not they wish to announce themselves to all pages or attempt alternative means in order to reduce the ability for a user to be fingerprinted by the injection of thewindow.ethereumobject. Some examples, of alternative flows to consider would be to wait to inject the provider object until the DApp has announced theeip6963:requestProvider. At that point, the wallet can initiate a UI consent flow to ask the user if they would like to share their wallet address. This allows for the Wallet to enable the option of a \u201cprivate connect\u201d feature. However, if this approach is taken, Wallets must also consider how they intend to support backwards compatibility with a DApp that does not support this EIP.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- multi injected provider discovery: Proposes a new mechanism for discovering multiple wallet providers in a web page using window events, resolving conflicts caused by window.ethereum injection.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3076, "url": "https://eips.ethereum.org/EIPS/eip-3076", "title": "2021-11-03", "authors": ["Slashing Protection Interchange Format"], "sections": {"EIP-3076: Slashing Protection Interchange Format": "A standard format for transferring a key\u2019s signing history allows validators to easily switch between clients without the risk of signing conflicting messages. While a common keystore format provides part of the solution, it does not contain any information about a key\u2019s signing history. For a validator moving their keys from client A to client B, this could lead to scenarios in which client B inadvertently signs a message that conflicts with an earlier message signed with client A. The interchange format described here provides a solution to this problem.", "A JSON interchange format for proof of stake validators to migrate slashing protection data between clients.": "A standard format for transferring a key\u2019s signing history allows validators to easily switch between clients without the risk of signing conflicting messages. While a common keystore format provides part of the solution, it does not contain any information about a key\u2019s signing history. For a validator moving their keys from client A to client B, this could lead to scenarios in which client B inadvertently signs a message that conflicts with an earlier message signed with client A. The interchange format described here provides a solution to this problem.", "Abstract": "A standard format for transferring a key\u2019s signing history allows validators to easily switch between clients without the risk of signing conflicting messages. While a common keystore format provides part of the solution, it does not contain any information about a key\u2019s signing history. For a validator moving their keys from client A to client B, this could lead to scenarios in which client B inadvertently signs a message that conflicts with an earlier message signed with client A. The interchange format described here provides a solution to this problem.", "Motivation": "The proof of stake (PoS) protocol penalises validators for voting in ways that could result in two different versions of the chain being finalised. These types of penalties are called slashings.", "Specification": "A valid interchange file is one that adheres to the following JSON schema, and is interpreted according to theConditions.", "JSON Schema": "A valid interchange file is one that adheres to the following JSON schema, and is interpreted according to theConditions.", "Example JSON Instance": "After importing an interchange file with data fielddata, a signer must respect the following conditions:", "Conditions": "After importing an interchange file with data fielddata, a signer must respect the following conditions:", "Additional Information": "The interchange format is designed to be flexible enough to support the full variety of slashing protection strategies that clients may implement, which may be categorised into two main types:", "Rationale": "The interchange format is designed to be flexible enough to support the full variety of slashing protection strategies that clients may implement, which may be categorised into two main types:", "Supporting Different Strategies": "The interchange format is designed to be flexible enough to support the full variety of slashing protection strategies that clients may implement, which may be categorised into two main types:", "Integer Representation": "Most fields in the JSON schema are strings. For fields in which it is possible to encode the value as either a string or an integer, strings were chosen. This choice was made in order to avoid issues with different languages supporting different ranges of integers (specifically JavaScript, where thenumbertype is a 64-bit float). If a validator is yet to sign a block or attestation, the relevant list is simply left empty.", "Versioning": "Theinterchange_format_versionis set to 5 because the specification went through several breaking changes during its design, incorporating feedback from implementers.", "Backwards Compatibility": "This specification is not backwards-compatible with previous draft versions that used version numbers less than 5.", "Security Considerations": "In order to minimise risk and complexity, the format has been designed to map cleanly onto the internal database formats used by implementers. Nevertheless, there are a few pitfalls worth illuminating.", "Advice for Complete Databases": "For implementers who use a complete record of signed messages to implement their slashing protection database, we make the following recommendations:", "Advice for Minimal Databases": "For implementers who wish to implement their slashing protection database by storing only the latest block and attestation for each validator, we make the following recommendations:", "General Recommendations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3155, "url": "https://eips.ethereum.org/EIPS/eip-3155", "title": "2025-03-01", "authors": ["EVM trace specification"], "sections": {"EIP-3155: EVM trace specification": "Introduce a new JSON standard for EVM traces during execution of state tests.", "A JSON format for EVM traces": "Introduce a new JSON standard for EVM traces during execution of state tests.", "Abstract": "Introduce a new JSON standard for EVM traces during execution of state tests.", "Motivation": "The Ethereum Virtual Machine executes all smart contract code on ethereum.\nIn order to debug smart contracts and state tests better, a common format was introduced to log every execution step of the EVM.\nThis format was implemented by Go-Ethereum, Parity-Ethereum, Nethermind and Besu.\nSince the common format was not well-defined, the implementations differed slightly, making it hard to develop adequate tooling which reduces the usefulness of tracing significantly.", "Specification": "Clients should be able to execute simple transactions as well as code and return traces. In the following, we will call this client CUT (client under test) and use go-ethereum\u2019sevmbinary for code examples.", "Datatypes": "The CUT MUST output ajsonobject for EACH operation.", "Output": "The CUT MUST output ajsonobject for EACH operation.", "Summary and Error Handling": "At the end of execution, the CUT MUST print summary info; this info SHOULD have the following fields.\nThe summary should be a singlejsonlobject.", "Rationale": "This EIP is largely based on the previous non-official documentation for EVM tracing.\nIt tries to cover as many corner cases as possible to enable true client compatibility.\nThe datatypes and if a field is optional is chosen to be as compatible with current implementations as possible.", "Backwards Compatibility": "This EIP is fully backward compatible with ethereum as it only introduces a better tracing infrastructure that is optional for clients to implement.", "Clients": "This EIP is fully backward compatible with go-ethereum. OpenEthereum, Besu and Nethermind clients would have to change their JSON output ofopenethereum-evmevmtoolandnethtestslightly do adhere to the new and stricter specs. New clients would need to implement this change if they want to be part of the differential fuzzing group.", "Test Cases": "Tracing is expensive.", "Security Considerations": "Tracing is expensive.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5792, "url": "https://eips.ethereum.org/EIPS/eip-5792", "title": "Wallet Call API", "authors": ["Moody Salem\u00a0(", "@moodysalem", ")", "Lukas Rosario\u00a0(", "@lukasrosario", ")", "Wilson Cusack\u00a0(", "@wilsoncusack", ")", "Dror Tirosh\u00a0(", "@drortirosh", ")", "Jake Moxey\u00a0(", "@jxom", ")", "Derek Rein\u00a0(", "@arein", ")", "Alex Forshtat\u00a0(", "@forshtat", ")", "Sam Wilson (@SamWilsn)\u00a0<", "sam@binarycake.ca", ">", "Borislav Itskov\u00a0(", "@Oxbobby", ")", "Joao Tavares\u00a0(", "@cryptotavares", ")", "Adam Fuller\u00a0(", "@azf20", ")", "Philip Liao\u00a0(", "@phil-ociraptor", ")"], "sections": {"EIP-5792: Wallet Call API": "Defines new JSON-RPC methods which enable apps to ask a wallet to process a batch of onchain write calls and to check on the status of those calls.\nApplications can specify that these onchain calls be executed taking advantage of specific capabilities previously expressed by the wallet; an additional, a novel wallet RPC is defined to enable apps to query the wallet for those capabilities.", "Adds JSON-RPC methods for sending multiple calls from the user's wallet, and checking their status": "Defines new JSON-RPC methods which enable apps to ask a wallet to process a batch of onchain write calls and to check on the status of those calls.\nApplications can specify that these onchain calls be executed taking advantage of specific capabilities previously expressed by the wallet; an additional, a novel wallet RPC is defined to enable apps to query the wallet for those capabilities.", "Abstract": "Defines new JSON-RPC methods which enable apps to ask a wallet to process a batch of onchain write calls and to check on the status of those calls.\nApplications can specify that these onchain calls be executed taking advantage of specific capabilities previously expressed by the wallet; an additional, a novel wallet RPC is defined to enable apps to query the wallet for those capabilities.", "Motivation": "The current methods used to send transactions from the user wallet and check their status areeth_sendTransactionandeth_getTransactionReceipt.", "Specification": "Four new JSON-RPC methods are added: three are for handling batches of onchain calls, and one is for querying support for wallet capabilities, such as to make better use of the three batching methods.\nApps may begin using these first three methods immediately, falling back toeth_sendTransactionandeth_getTransactionReceiptwhen they are not available.", "wallet_sendCalls": "Requests that a wallet submits a batch of calls.fromandchainIdare identified byEIP-155integers expressed in hexadecimal notation,\nwith0xprefix and no leading zeroes for thechainIdvalue.\nThe items in thecallsfield are simple{to, data, value}tuples.", "wallet_getCallsStatus": "Returns the status of a call batch that was sent viawallet_sendCalls.\nThe identifier of the batch is the value returned from thewallet_sendCallsRPC.\nNote that thereceiptsobjects of this method\u2019s response is a strict subset of the object returned byeth_getTransactionReceipt.", "wallet_showCallsStatus": "Requests that a wallet shows information about a given call bundle that was sent withwallet_sendCalls. Note that this method does not return anything for a knownidbatch identifier. If the identifier is not known, or in case of any other failure to executewallet_showCallsStatusreturns an RPC call error.", "wallet_getCapabilities": "This RPC allows an application to request capabilities from a wallet (e.g. batch transactions, paymaster communication), without distinct discovery and permission requests. For more on the difference between requesting capabilities and discovering features, see the\u201cPrivacy Considerations\u201d section.", "atomicCapability": "Like the illustrative examples given above and other capabilities to be defined in future EIPs, theatomiccapability specifies how the wallet will execute the batches of transactions requested throughwallet_sendCallsmethod.", "Error Codes": "The following error codes are defined for the methods specified in this EIP. These errors follow the JSON-RPC 2.0 specification for error objects, which require acodeandmessagefield.", "Rationale": "We considered modifyingeth_sendTransactionto add support for these new capabilities, but the method is ultimately an artifact of when nodes were used to sign transactions. We decided it is better to move forward withwallet_-namespaced methods that better describe what they are used for.", "On Naming": "We considered modifyingeth_sendTransactionto add support for these new capabilities, but the method is ultimately an artifact of when nodes were used to sign transactions. We decided it is better to move forward withwallet_-namespaced methods that better describe what they are used for.", "Call Execution Atomicity": "Thewallet_sendCallsmethod accepts an array ofcalls. However, this proposal does not require that these calls be executed as part of a single transaction. It enables EOA wallets to express their ability to execute calls as part of a single transaction or as part of multiple transactions. It also enables Apps to express their minimum atomicity requirements for how calls must be executed.", "Call Gas Limit": "Our initial proposal included an optionalgasfield for each call in thecallsfield accepted by thewalletSendCallsmethod. However, we realized this could be misleading because in the case ofERC-4337wallets you cannot specify a gas limit per call, only a single gas limit for all calls in the user operation. We then proposed a singlegasvalue that would apply to all of the calls. This works forERC-4337wallets, but not for EOA wallets. When we decided that EOA wallets should be able to handle multiple calls, the commongasfield became untenable across use cases and we removed it altogether.", "Backwards Compatibility": "Wallets that do not support the methods defined here SHOULD return error responses when these new JSON-RPC methods are called. Apps MAY attempt to send the same batch of calls serially viaeth_sendTransactionwhen a call to these methods fails for lack of wallet support, or they MAY indicate to the user that their wallet is not supported and the request was not processed.", "Security Considerations": "Regardless of theatomicvalue specified, App developers MUST NOT assume that all calls will be sent in a single transaction. An example could be an L2 resistant to reorgs that implements a sendBundle or similar functionality.", "Privacy Considerations": "Progressive authorization and progressive consent paradigms are important to modern user experience, as well as to preserving the anonymity of user agents. To protect these patterns from the cross-incentives of feature-discovery that enables better user experiences, capability semantics are used and the difference between lack of feature support and lack of feature permission explicitly occluded in the design of thewallet_RPC for querying capabilities.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- wallet call api: Introduces new JSON-RPC methods for wallets to process batches of on-chain calls, enabling features like atomic execution of multiple transactions.\n- sreturn: A new opcode that allows returning data directly from storage without first copying it to memory.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785."}
{"eip": 7749, "url": "https://eips.ethereum.org/EIPS/eip-7749", "title": "Add wallet_signIntendedValidatorData method", "authors": ["Yamen Merhi\u00a0(", "@YamenMerhi", ")", "Patronum Labs\u00a0(", "@Patronum-Labs", ")"], "sections": {"EIP-7749: Add wallet_signIntendedValidatorData method": "This EIP introduces a new JSON-RPC method,wallet_signIntendedValidatorData, which allows signing data with an intended validator address usingERC-191version 0x00 with this format:", "A new RPC method to sign data with an intended validator address according to ERC-191 version 0x00.": "This EIP introduces a new JSON-RPC method,wallet_signIntendedValidatorData, which allows signing data with an intended validator address usingERC-191version 0x00 with this format:", "Abstract": "This EIP introduces a new JSON-RPC method,wallet_signIntendedValidatorData, which allows signing data with an intended validator address usingERC-191version 0x00 with this format:", "Motivation": "Currently, signing messages relies heavily on ERC-191 version 0x45 (eth_sign) andEIP-712(eth_signTypedData). While EIP-712 provides a more structured approach, it is often seen as complex. On the other hand, ERC-191 version 0x45 is widely used but poses significant phishing risks due to the lack of data parsing.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "wallet_signIntendedValidatorData": "MUST calculate an Ethereum signature usingsign(keccak256(\"\\x19\\x00<signature validator address><data to sign>\")).", "Rationale": "Thewallet_signIntendedValidatorDatamethod aims to bridge the gap between the simplicity of ERC-191 version 0x45 and the structured approach of EIP-712. By specifying the intended validator address, it reduces phishing risks and provides a more secure signing method for smart contract accounts and other use cases requiring a specific validator address.", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "Request:", "Example": "Request:", "Security Considerations": "Users should exercise caution when signing messages. Double-check the address of the verifier and ensure trust in the dApp triggering the sign request.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- wallet_signintendedvalidatordata method: Adds a new RPC method for signing data with an intended validator address using ERC-191 version 0x00, providing a simpler, more secure alternative to EIP-712 for smart contract accounts.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7756, "url": "https://eips.ethereum.org/EIPS/eip-7756", "title": "EOF/EVM Trace Specification", "authors": ["Martin Holst Swende\u00a0(", "@holiman", ")", "Marius van der Wijden\u00a0(", "@MariusVanDerWijden", ")", "Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-7756: EOF/EVM Trace Specification": "Updates theEIP-3155JSON tracing specification to support EOF features.", "Updates EIP-3155 tracing to add EOF support": "Updates theEIP-3155JSON tracing specification to support EOF features.", "Abstract": "Updates theEIP-3155JSON tracing specification to support EOF features.", "Motivation": "EIP-3155 defined a tracing standard for Legacy EVM operations. However, the EVM Object\nFormat (EIP-7692) adds a number of features that need to be reflected in debugging\ntraces.", "Specification": "To promote clarity and provide a cohesive specification, the entire tracing specification will be\npresented with alterations in-line rather than as a set of diffs on top of EIP-3155. Differences\nwill be highlighted in the Backwards Compatibility section.", "Datatypes": "Each trace line MUST have these fields.", "Output": "Each trace line MUST have these fields.", "Summary Line": "At the end of execution, the client SHOULD print summary info. This summary MUST be a single JSON\nobject.", "Rationale": "This EIP is an extension of the EIP-3155 tracing features that has been in use for years. Rather\nthan dramatically re-boot the feature, the information was added to the existing traces.", "Backwards Compatibility": "Clients emitting tracing JSON for uncontained \u201clegacy\u201d contracts will produce a compatible trace,\nexcept as outlined below", "Changes from EIP-3155": "Besu, evmone, EthereumJS, Geth, Nethermind, and Reth already produce these standard traces in\nvarious tools. Adding the new fields will align with work needed to support the EOF EIPs enumerated\nin EIP-7692.", "Additions to EIP-3155": "Besu, evmone, EthereumJS, Geth, Nethermind, and Reth already produce these standard traces in\nvarious tools. Adding the new fields will align with work needed to support the EOF EIPs enumerated\nin EIP-7692.", "Clients": "Besu, evmone, EthereumJS, Geth, Nethermind, and Reth already produce these standard traces in\nvarious tools. Adding the new fields will align with work needed to support the EOF EIPs enumerated\nin EIP-7692.", "Test Cases": "This is the trace output from the Ethereum Execution Specification Test from one of the\nparameterized executions oftest_eof_functions_contract_call_succeed.\nMemory and return data is disabled.", "Security Considerations": "Clients should be aware that tracing can be expensive both in terms of CPU overhead and network\nbandwidth. Tracing endpoints should not be enabled by default, and when they are enabled should have \naccess restrictions on the network level. Failure to do so could result in a client being \noverwhelmed with requests and, if operating as a validator, cause the client to fail to provide \nexecution attestations in a timely manner.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- evm trace specification: Introduces a JSON format for tracing EVM execution during state tests, enabling consistent debugging and differential fuzzing across Ethereum clients.\n- eof/evm trace specification: Updates the EIP-3155 JSON tracing specification to add support for EOF (EVM Object Format), enhancing the traceability of EOF contracts with new fields for sections and function depth.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785."}
{"eip": 7867, "url": "https://eips.ethereum.org/EIPS/eip-7867", "title": "Flow Control Wallet Call Capability", "authors": ["Sam Wilson (@SamWilsn)\u00a0<", "sam@binarycake.ca", ">"], "sections": {"EIP-7867: Flow Control Wallet Call Capability": "This proposal extendsEIP-5792to allow dapps to downgrade their required atomicity guarantees and control the behaviour after a failed/reverted call. It introduces the batch-scope concept ofstrictvs.looseatomicity, where astrictbatch remains atomic in the face of chain reorgs and aloosebatch does not; and the per-call ability to continue after a failed/reverted call (continue) or stop processing (halt).", "An EIP-5792 capability providing atomicity and flow control configuration.": "This proposal extendsEIP-5792to allow dapps to downgrade their required atomicity guarantees and control the behaviour after a failed/reverted call. It introduces the batch-scope concept ofstrictvs.looseatomicity, where astrictbatch remains atomic in the face of chain reorgs and aloosebatch does not; and the per-call ability to continue after a failed/reverted call (continue) or stop processing (halt).", "Abstract": "This proposal extendsEIP-5792to allow dapps to downgrade their required atomicity guarantees and control the behaviour after a failed/reverted call. It introduces the batch-scope concept ofstrictvs.looseatomicity, where astrictbatch remains atomic in the face of chain reorgs and aloosebatch does not; and the per-call ability to continue after a failed/reverted call (continue) or stop processing (halt).", "Motivation": "While the base EIP-5792 specification works extremely well for smart contract wallets, it does not allow the expression of the full range of flow control options that wallets can implement. For example, a dapp may only be submitting a batch for gas savings and not care about whether all calls are reverted on failure. A wallet may only be able to offer a limited form of atomicity through block builder backchannels, but that may be sufficient for a trading platform.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "RPC Interface": "The following subsections are modifications to the API endpoints from EIP-5792.", "Concepts": "A rollback is informally defined as \u201ccausing no meaningful changes on chain.\u201d A\nrolled back batch only makes gas accounting and bookkeeping (eg. nonce)\nchanges. In other words, a rollback is the default behaviour of EIP-5792 when\na call fails.", "Behaviour": "The wallet MUST rejectwallet_sendCallsrequests with error codeMISSING_CAPwhere both:", "Error Codes": "TBD", "Rationale": "TBD", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "App developers cannot treat each call in a batch as an independent transaction\nunless the atomicity level is strict. In other words, there may be additional\nuntrusted transactions between any of the calls in a batch. Calls that failed\nmay eventually flip to succeeding, and vice versa. Even strictly atomic batches\ncan flip between succeeding/failing in the face of a block reorg. The calls in\nloosely atomic batches can be included in separate, non-contiguous blocks. There\nis no constraint over how long it will take all the calls in a batch to be\nincluded. Apps should encode deadlines and timeout behaviors in the smart\ncontract calls, just as they do today for transactions, including ones otherwise\nbundled.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7896, "url": "https://eips.ethereum.org/EIPS/eip-7896", "title": "ABI attachment in `wallet_sendCalls`", "authors": ["Francisco Giordano\u00a0(", "@frangio", ")"], "sections": {"EIP-7896: ABI attachment in `wallet_sendCalls`": "This EIP extendsEIP-5792with a newinterfacescapability, whereby an application can attach the contract interface specifications (aka. ABIs) that the wallet needs to reliably decode the calldata in the request.", "A capability to enable calldata decoding in wallets.": "This EIP extendsEIP-5792with a newinterfacescapability, whereby an application can attach the contract interface specifications (aka. ABIs) that the wallet needs to reliably decode the calldata in the request.", "Abstract": "This EIP extendsEIP-5792with a newinterfacescapability, whereby an application can attach the contract interface specifications (aka. ABIs) that the wallet needs to reliably decode the calldata in the request.", "Motivation": "The security model of Ethereum accounts relies on a separation of concerns between applications and wallets, the latter being responsible for securing private key material and providing restricted access to it. When an application requests a transaction or a signature, the wallet prompts the user to accept it or reject it. The user is expected to make an assessment about the desirability of the operation, given that it can potentially operate on all account assets, in the extreme case \u201cdraining\u201d them all for the benefit of an attacker. The wallet is tasked with providing information about the request to lead to an accurate assessment, in particular to help detect unintended effects and attacks.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "wallet_sendCalls": "When this capability is supported,wallet_sendCallsrequests MAY include a globalinterfacesfield.", "wallet_getCapabilities": "Under theinterfacescapability, wallets MUST include aversionsarray field listing the supported interface spec versions.", "Rationale": "No backward compatibility issues found.", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- abi attachment: capability to enable calldata decoding in wallets.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170."}
{"eip": 7910, "url": "https://eips.ethereum.org/EIPS/eip-7910", "title": "eth_config JSON-RPC Method", "authors": ["Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-7910: eth_config JSON-RPC Method": "This document describes an RPC method that provides node-relevant configuration data for the current and next fork.", "A JSON-RPC method that describes the configuration of the current and next fork": "This document describes an RPC method that provides node-relevant configuration data for the current and next fork.", "Abstract": "This document describes an RPC method that provides node-relevant configuration data for the current and next fork.", "Motivation": "Throughout Ethereum\u2019s history, there have been multiple instances where a client was not correctly configured for an upcoming hard fork, causing it to fall out of consensus when the fork boundary was crossed. Most incidents have been minor, such as a single client forking the chain in proof-of-work or having its blocks orphaned in proof-of-stake.", "Target Audience and Use Cases": "This method is intended for node operators, validator teams, and network monitoring tools to verify client readiness for upcoming forks. Use cases include:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Configuration RPC": "A new JSON-RPC API,eth_config, is introduced. It takes no parameters and returns the result object specified in the next section.", "Result Object Structure": "The RPC response contains four members of two types:", "Converting a Fork Configuration to a Hash": "To generate a fork hash, the JSON object representing the fork configuration is converted into canonical form as perRFC-8785(in short no whitespace, sorted keys, and numeric values in their simplest form). The result is then hashed using CRC-32.", "Fields in the Configuration Object": "Each configuration object MUST contain the following fields, presented in canonical order. This RPC assumes the network is post-merge, and no accommodations are specified for proof-of-work-related issues.", "Rationale": "The purpose of this specification is to enable nodes to advertise, prior to a fork, that they have the correct configurations loaded and ready. Past testnet and mainnet forks have revealed clients with incorrect precompile sets, chain IDs, deposit contract addresses, and other configuration errors.", "Why Enumerate Precompiles? (And in General, Why Track a Particular Config Item?)": "The purpose of this specification is to enable nodes to advertise, prior to a fork, that they have the correct configurations loaded and ready. Past testnet and mainnet forks have revealed clients with incorrect precompile sets, chain IDs, deposit contract addresses, and other configuration errors.", "Full Configs Instead of Deltas": "An initial design considered using a partial configuration for the \u201cnext\u201d fork instead of a complete one. However, analysis of past events showed that some parameters causing divergence (e.g., the deposit contract) were introduced in earlier forks, with consensus failures occurring in later forks due to unrelated EIPs relying on those configurations. A partial \u201cnext\u201d configuration hash would not have detected such errors.", "Nested vs. Flat Variables": "Nested structures are easier to read, while flat structures are easier to merge. Since this specification uses full configurations for the current and next forks, merging is unnecessary, making readability the priority.", "Serving Data Not Specified in genesis.json": "Some reported values are specification-level constants, which many clients do not include in their configuration files. However, certain EIP constants (e.g., the deposit contract) have become variables in testnets, necessitating their inclusion.", "JSON as Config Format": "JSON was chosen for its ubiquity, machine and human readability, and the existence of a standardized canonical form viaRFC-8785. YAML lacks a standard canonical form. No Ethereum software uses XML for configuration, and adopting it would increase every client\u2019s library size. An invented format is possible but would require definition and standardization within this specification.", "CRC-32 as Hash Format": "The reasons for using CRC-32 instead of a cryptographic hash are the same as those inEIP-2124, incorporated by reference. In brief, nodes can lie, the 4-byte reduction is for convenience rather than security, and CRC-32 is widely implemented.", "Backwards Compatibility": "This EIP does not alter previous behavior. Configurations prior to Cancun are non-standard, and clients sharing pre-Cancun configurations will produce non-standard results.", "Test Cases": "Hoodi Prague Config", "Sample Configs": "Hoodi Prague Config", "Reference Implementation": "See Besu Pull #8417", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- eth_config json-rpc method: \n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- crc-32: A hash function used instead of cryptographic hashes due to reasons including node lying, convenience reduction, and widespread implementation."}
{"eip": 107, "url": "https://eips.ethereum.org/EIPS/eip-107", "title": "safe \"eth_sendTransaction\" authorization via html popup", "authors": ["Ronan Sandford\u00a0(", "@wighawag", ")"], "sections": {"EIP-107: safe \"eth_sendTransaction\" authorization via html popup": "This draft EIP describes the details of an authorization method that if provided by rpc enabled ethereum nodes would allow regular websites to send transactions (viaeth_sendTransaction) without the need to enable CORS. Instead, user would be asked to confirm the transaction via an html popup.", "": "This draft EIP describes the details of an authorization method that if provided by rpc enabled ethereum nodes would allow regular websites to send transactions (viaeth_sendTransaction) without the need to enable CORS. Instead, user would be asked to confirm the transaction via an html popup.", "Abstract": "This draft EIP describes the details of an authorization method that if provided by rpc enabled ethereum nodes would allow regular websites to send transactions (viaeth_sendTransaction) without the need to enable CORS. Instead, user would be asked to confirm the transaction via an html popup.", "Motivation": "Currently, if a user navigates to a dapp running on a website using her/his everyday browser, the dapp will by default have no access to the rpc api for security reasons. The user will have to enable CORS for the website\u2019s domain in order for the dapp to work. Unfortunately if the user does so, the dapp will be able to send transactions from any unlocked account without the need for any user consent. In other words, not only does the user need to change the node\u2019s default setting, but the user is also forced to trust the dapp in order to use it. This is of course not acceptable and forces existing dapps to rely on the use of workarounds like:", "Account unlocked": "When the account is already unlocked, the user is presented with the following popup for every transaction that the dapp attempts to make:", "Account locked and no \u201cpersonal\u201d api exposed via rpc:": "When the account is locked, and the node does not provide access to account unlocking via its rpc interface, the following popup will be presented. This is not ideal since this requires the user to know how to unlock an account:", "Account locked but node exposing the \u201cpersonal\u201d api via rpc :": "A better option is to ask the user for their password, but this is only possible if the node allows access to the \u201cpersonal\u201d api via rpc. In such case, the following dialog will be presented to the user so he/she can accept the transaction by providing the password required to unlock the account:", "Specification": "In order for the mechanism to work, the node needs to serve an html file via http at the url <node url>/authorization.html", "Rationale": "The design for that proposal was chosen for its simplicity and security. A previous idea was to use an oauth-like protocol in order for the user to accept or deny a transaction request. It would have required deeper code change in the node and some geth contributors argues that such change did not fit into geth code base as it would have required dapp aware code.\nThe current design, instead has a very simple implementation (self contained html file that can be shared across node\u2019s implementation) and its safeness is guaranteed by browsers\u2019 cross domain policies.", "Implementations": "In order to implement this design, the following html file or an equivalent one needs to be served at the url <node url>/authorization.html", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 758, "url": "https://eips.ethereum.org/EIPS/eip-758", "title": "Subscriptions and filters for completed transactions", "authors": ["Jack Peterson\u00a0<", "jack@tinybike.net", ">"], "sections": {"EIP-758: Subscriptions and filters for completed transactions": "Provide a way for external callers to be notified of completed transactions, and access the return data of functions executed when a transaction is mined.", "": "Provide a way for external callers to be notified of completed transactions, and access the return data of functions executed when a transaction is mined.", "Simple Summary": "Provide a way for external callers to be notified of completed transactions, and access the return data of functions executed when a transaction is mined.", "Abstract": "When a new transaction is submitted successfully to an Ethereum node, the node responds with the transaction\u2019s hash.  If the transaction involved the execution of a contract function that returns data, the data is discarded.  If the return data is state-dependent, which is common, there is no straightforward way for the caller to access or compute the return data.  This EIP proposes that callers should be able to subscribe to (or poll for) completed transactions.  The Ethereum node sends the return data to the caller when the transactions are sealed.", "Motivation": "External callers presently have no way of accessing return data from Ethereum, if the function was executed viaeth_sendTransactionoreth_sendRawTransactionRPC request.  Access to function return data is in many cases a desirable feature.  Making return data available to external callers also addresses the inconsistency between internal callers, which have access to return data within the context of the transaction, and external callers, which do not.  Presently, a common workaround is to log the return data, which is bad for several reasons: it contributes to chain bloat, imposes additional gas costs on the caller, and can result in unused logs being written if the externally called function involves other (internal) function calls that log their return data.  While implementing the original version of this EIP, it was decided to expand this functionality slightly to allow for external callers to be notified of their completed transactions even in the case where there isnoreturn data.  This could be either because the method called doesn\u2019t return a value, or because the transaction is a simple transfer of value.", "Specification": "A caller who wants to be notified when transactions of theirs complete sends aneth_subscribeRPC request with the first parameter\"completedTransaction\":", "Subscription": "A caller who wants to be notified when transactions of theirs complete sends aneth_subscribeRPC request with the first parameter\"completedTransaction\":", "Polling": "Push notifications require full duplex connections (i.e., websocket or IPC).  Instead of subscribing, callers using HTTP send aneth_newCompletedTransactionFilterrequest:", "Rationale": "EIP-658originally proposed adding return data to transaction receipts.  However, return data is not charged for (as it is not stored on the blockchain), so adding it to transaction receipts could result in DoS and spam opportunities.  Instead, a simple Booleanstatusfield was added to transaction receipts.  This modified version of EIP 658 was included in the Byzantium hard fork.  While thestatusfield is useful, applications often need the return data as well.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- byzantium hard fork: Specifies the Byzantium hard fork, part of the Metropolis upgrade, introducing features like the REVERT opcode, elliptic curve precompiles, and transaction status codes.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1102, "url": "https://eips.ethereum.org/EIPS/eip-1102", "title": "Opt-in account exposure", "authors": ["Paul Bouchon\u00a0<", "mail@bitpshr.net", ">", "Erik Marks\u00a0(", "@rekmarks", ")"], "sections": {"EIP-1102: Opt-in account exposure": "This proposal describes a communication protocol between dapps and Ethereum-enabled DOM environments that allows the Ethereum-enabled DOM environment to choose what information to supply the dapp with and when.", "": "This proposal describes a communication protocol between dapps and Ethereum-enabled DOM environments that allows the Ethereum-enabled DOM environment to choose what information to supply the dapp with and when.", "Simple summary": "This proposal describes a communication protocol between dapps and Ethereum-enabled DOM environments that allows the Ethereum-enabled DOM environment to choose what information to supply the dapp with and when.", "Abstract": "The previous generation of Ethereum-enabled DOM environments follows a pattern of injecting a provider populated with accounts without user consent. This puts users of such environments at risk because malicious websites can use these accounts to view detailed account information and to arbitrarily initiate unwanted transactions on a user\u2019s behalf.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d,  \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described inRFC-2119.", "Concepts": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d,  \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described inRFC-2119.", "Protocol": "DappsMUSTrequest accounts by calling theeth_requestAccountsRPC method on the provider exposed atwindow.ethereum. Calling this methodMAYtrigger a user interface that allows the user to approve or reject account access for a given dapp. This methodMUSTreturn aPromisethat is resolved with an array of one or more user accounts or rejected if no accounts are available (e.g., the user rejected account access).", "Example initialization": "The pattern of automatic account exposure followed by the previous generation of Ethereum-enabled DOM environments fails to protect user privacy and fails to maintain safe user experience: untrusted websites can both view detailed account information and arbitrarily initiate transactions on a user\u2019s behalf. Even though most users may reject unsolicited transactions on untrusted websites, a protocol for account access should make such unsolicited requests impossible.", "Constraints": "The pattern of automatic account exposure followed by the previous generation of Ethereum-enabled DOM environments fails to protect user privacy and fails to maintain safe user experience: untrusted websites can both view detailed account information and arbitrarily initiate transactions on a user\u2019s behalf. Even though most users may reject unsolicited transactions on untrusted websites, a protocol for account access should make such unsolicited requests impossible.", "Rationale": "The pattern of automatic account exposure followed by the previous generation of Ethereum-enabled DOM environments fails to protect user privacy and fails to maintain safe user experience: untrusted websites can both view detailed account information and arbitrarily initiate transactions on a user\u2019s behalf. Even though most users may reject unsolicited transactions on untrusted websites, a protocol for account access should make such unsolicited requests impossible.", "Immediate value-add": "This proposal impacts dapp developers and requires that they request access to user accounts following the protocol outlined above. Similarly, this proposal impacts dapp browser developers and requires that they only expose user accounts following the protocol defined above.", "Long-term value-add": "This proposal impacts dapp developers and requires that they request access to user accounts following the protocol outlined above. Similarly, this proposal impacts dapp browser developers and requires that they only expose user accounts following the protocol defined above.", "Backwards compatibility": "This proposal impacts dapp developers and requires that they request access to user accounts following the protocol outlined above. Similarly, this proposal impacts dapp browser developers and requires that they only expose user accounts following the protocol defined above.", "Implementation": "The MetaMask teamhas implementedthe strategy described above.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- opt-in account exposure: Describes a protocol where dapps must request account access from the user, enhancing privacy and security by allowing users to approve or deny access to their Ethereum accounts.\n- treturn: A new opcode that allows returning data directly from transient storage without first copying it to memory.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1186, "url": "https://eips.ethereum.org/EIPS/eip-1186", "title": "RPC-Method to get Merkle Proofs - eth_getProof", "authors": ["Simon Jentzsch\u00a0<", "simon.jentzsch@slock.it", ">", "Christoph Jentzsch\u00a0<", "christoph.jentzsch@slock.it", ">"], "sections": {"EIP-1186: RPC-Method to get Merkle Proofs - eth_getProof": "One of the great features of Ethereum is the fact, that you can verify all data of the state. But in order to allow verification of accounts outside the client, we need an additional function delivering us the required proof. These proofs are important to secure Layer2-Technologies.", "": "One of the great features of Ethereum is the fact, that you can verify all data of the state. But in order to allow verification of accounts outside the client, we need an additional function delivering us the required proof. These proofs are important to secure Layer2-Technologies.", "Simple Summary": "One of the great features of Ethereum is the fact, that you can verify all data of the state. But in order to allow verification of accounts outside the client, we need an additional function delivering us the required proof. These proofs are important to secure Layer2-Technologies.", "Abstract": "Ethereum uses aMerkle Treeto store the state of accounts and their storage. This allows verification of each value by simply creating a Merkle Proof. But currently, the standard RPC-Interface does not give you access to these proofs. This EIP suggests an additional RPC-Method, which creates Merkle Proofs for Accounts and Storage Values.", "Motivation": "In order to create a MerkleProof access to the full state db is required. The current RPC-Methods allow an application to access single values (eth_getBalance,eth_getTransactionCount,eth_getStorageAt,eth_getCode), but it is impossible to read the data needed for a  MerkleProof through the standard RPC-Interface. (There are implementations using leveldb and accessing the data via filesystems, but this can not be used for production systems since it requires the client to be stopped first - See https://github.com/zmitton/eth-proof)", "Specification": "As Part of the eth-Module, an additional Method calledeth_getProofshould be defined as follows:", "Rationale": "This one Method actually returns 3 different important data points:", "Proofs for non existent values": "In case an address or storage-value does not exist, the proof needs to provide enough data to verify this fact. This means the client needs to follow the path from the root node and deliver until the last matching node. If the last matching node is a branch, the proof value in the node must be an empty one. In case of leaf-type, it must be pointing to a different relative-path in order to proof that the requested path does not exist.", "possible Changes to be discussed:": "Since this only adds a new Method there are no issues with Backwards Compatibility.", "Backwards Compatibility": "Since this only adds a new Method there are no issues with Backwards Compatibility.", "Test Cases": "TODO: Tests still need to be implemented, but the core function creating the proof already exists inside the clients and are well tested.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- eth_getproof: Adds a new RPC method to return account and storage values along with Merkle proofs, allowing offline verification of account and storage data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1474, "url": "https://eips.ethereum.org/EIPS/eip-1474", "title": "Remote procedure call specification", "authors": ["Paul Bouchon\u00a0<", "mail@bitpshr.net", ">", "Erik Marks\u00a0(", "@rekmarks", ")"], "sections": {"EIP-1474: Remote procedure call specification": "This proposal defines a standard set of remote procedure call methods that an Ethereum node should implement.", "": "This proposal defines a standard set of remote procedure call methods that an Ethereum node should implement.", "Simple Summary": "This proposal defines a standard set of remote procedure call methods that an Ethereum node should implement.", "Abstract": "Nodes created by the current generation of Ethereum clients expose inconsistent and incompatible remote procedure call (RPC) methods because no formal Ethereum RPC specification exists. This proposal standardizes such a specification to provide developers with a predictable Ethereum RPC interface regardless of underlying node implementation.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d,  \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described inRFC-2119.", "Concepts": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d,  \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described inRFC-2119.", "Methods": "Returns the version of the current client", "Rationale": "Much of Ethereum\u2019s effectiveness as an enterprise-grade application platform depends on its ability to provide a reliable and predictable developer experience. Nodes created by the current generation of Ethereum clients expose RPC endpoints with differing method signatures; this forces applications to work around method inconsistencies to maintain compatibility with various Ethereum RPC implementations.", "Backwards compatibility": "This proposal impacts Ethereum client developers by requiring that any exposed RPC interface adheres to this specification. This proposal impacts dapp developers by requiring that any RPC calls currently used in applications are made according to this specification.", "Implementation": "The current generation of Ethereum clients includes several implementations that attempt to expose this RPC specification:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- remote procedure call specification: Defines a standard set of RPC methods that an Ethereum node should implement, ensuring consistency and predictability across different client implementations.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1571, "url": "https://eips.ethereum.org/EIPS/eip-1571", "title": "EthereumStratum/2.0.0", "authors": ["Andrea Lanfranchi\u00a0(", "@AndreaLanfranchi", ")", "Pawel Bylica\u00a0(", "@chfast", ")", "Marius Van Der Wijden\u00a0(", "@MariusVanDerWijden", ")"], "sections": {"EIP-1571: EthereumStratum/2.0.0": "This draft contains the guidelines to define a new standard for the Stratum protocol used by Ethereum miners to communicate with mining pool servers.", "": "This draft contains the guidelines to define a new standard for the Stratum protocol used by Ethereum miners to communicate with mining pool servers.", "Abstract": "This draft contains the guidelines to define a new standard for the Stratum protocol used by Ethereum miners to communicate with mining pool servers.", "Conventions": "The JSON representation ofrequestobject is made of these parts:", "Rationale": "Ethereum does not have an official Stratum implementation yet. It officially supports only getWork which requires miners to constantly pool the work provider. Only recently go-ethereum have implemented apush mechanismto notify clients for mining work, but whereas the vast majority of miners do not run a node, it\u2019s main purpose is to facilitate mining pools rather than miners.\nThe Stratum protocol on the other hand relies on a standard stateful TCP connection which allows two-way exchange of line-based messages. Each line contains the string representation of a JSON object following the rules of eitherJSON-RPC 1.0orJSON-RPC 2.0.\nUnfortunately, in absence of a well defined standard, various flavours of Stratum have bloomed for Ethereum mining as a derivative work for different mining pools implementations. The only attempt to define a standard was made by NiceHash with theirEthereumStratum/1.0.0implementation which is the main source this work inspires from.\nMining activity, thus the interaction among pools and miners, is at it\u2019s basics very simple, and can be summarized with \u201cplease find a number (nonce) which coupled to this data as input for a given hashing algorithm produces, as output, a result which is below a certain target\u201d. Other messages which may or have to be exchanged among parties during a session are needed to support this basic concept.\nDue to the simplicity of the subject, the proponent, means to stick with JSON formatted objects rather than investigating more verbose solutions, like for exampleGoogle\u2019s Protocol Bufferswhich carry the load of strict object definition.", "Stratum design flaws": "The main Stratum design flaw is the absence of a well defined standard. This implies that miners (and mining software developers) have to struggle with different flavours which make their life hard when switching from one pool to another or even when trying to \u201cguess\u201d which is the flavour implemented by a single pool. Moreover all implementations still suffer from an excessive verbosity for a chain with a very small block time like Ethereum. A few numbers may help understand. A normalmining.notifymessage weigh roughly 240 bytes: assuming the dispatch of 1 work per block to an audience of 50k connected TCP sockets means the transmission of roughly 1.88TB of data a month. And this can be an issue for large pools. But if we see the same figures the other way round, from a miner\u2019s perspective, we totally understand how mining decentralization is heavily affected by the quality of internet connections.", "Sources of inspiration": "The Stratum protocol is an instance ofJSON-RPC-2.0. The miner is a JSON-RPC client, and the server is a JSON-RPC server. All communications exist within the scope of asession. A session starts at the moment a client opens a TCP connection to the server till the moment either party do voluntary close the very same connection or it gets broken. ServersMAYsupport session resuming if this is initially negotiated (on first session handshaking) between the client and the server. During a session all messages exchanged among server and client are line-based which means all messages are JSON strings terminated by ASCII LF character (which may also be denoted as\\nin this document). The LF characterMUST NOTappear elsewhere in a message. Client and server implementationsMUSTassume that once they read a LF character, the current message has been completely received and can be processed.\nLine messages are of three types :", "Specification": "The Stratum protocol is an instance ofJSON-RPC-2.0. The miner is a JSON-RPC client, and the server is a JSON-RPC server. All communications exist within the scope of asession. A session starts at the moment a client opens a TCP connection to the server till the moment either party do voluntary close the very same connection or it gets broken. ServersMAYsupport session resuming if this is initially negotiated (on first session handshaking) between the client and the server. During a session all messages exchanged among server and client are line-based which means all messages are JSON strings terminated by ASCII LF character (which may also be denoted as\\nin this document). The LF characterMUST NOTappear elsewhere in a message. Client and server implementationsMUSTassume that once they read a LF character, the current message has been completely received and can be processed.\nLine messages are of three types :", "JSON-RPC-2.0 Compliances": "As perJSON-RPC-2.0specification requests and responses differ from notifications by the identifier (id) member in the JSON object:", "JSON-RPC-2.0 Defiances": "In order to get the most concise messages among parties of a session/conversation this implementation enforces the following defiances :", "Requests": "The JSON representation ofrequestobject is made of these parts:", "Responses": "The JSON representation ofresponseobject is made of these parts:", "Notifications": "A notification message has the very same representation of arequestwith the only difference theidmemberMUST NOTbe present. This means the issuer is not interested nor expects any response to this message. It\u2019s up to the receiver to take actions accordingly. For instance the receiverMAYdecide to execute the method, or, in case of errors or methods not allowed, drop the connection thus closing the session.", "Protocol Flow": "One of the worst annoyances until now is that server, at the very moment of socket connection, does not provide any useful information about the stratum flavour implemented. This means the client has to start a conversation by iteratively trying to connect via different protocol flavours. This proposal amends the situation making mandatory for the server to advertise itself to the client. \nWhen a new client connects to the server, the serverMUSTsend amining.hellonotification :", "Session Handling - Hello": "One of the worst annoyances until now is that server, at the very moment of socket connection, does not provide any useful information about the stratum flavour implemented. This means the client has to start a conversation by iteratively trying to connect via different protocol flavours. This proposal amends the situation making mandatory for the server to advertise itself to the client. \nWhen a new client connects to the server, the serverMUSTsend amining.hellonotification :", "Session Handling - Bye": "Disconnection are not gracefully handled in Stratum. Client disconnections from pool may be due to several errors and this leads to waste of TCP sockets on server\u2019s side which wait for keepalive timeouts to trigger. A useful notification ismining.byewhich, once processed, allows both parties of the session to stop receiving and gracefully close TCP connections", "Session Handling - Session Subscription": "After receiving the response tomining.hellofrom server, the client, in case the server does support session resumingMAYrequest to resume a previously interrupted session withmining.subscriberequest:", "Session Handling - Response to Subscription": "A server receiving a client session subscriptionMUSTreply back with", "Session Handling - Noop": "There are cases when a miner struggles to find a solution in a reasonable time so it may trigger the timeout imposed by the server in case of no communications (the server, in fact, may think the client got disconnected). To mitigate the problem a new methodmining.noop(with no additional parameters) may be requested by the client.", "Session Handling - Reconnect": "Under certain circumstances the server may need to free some resources and or to relocate miners to another machine. Until now the only option for servers was to abruptly close the connection. On the miner\u2019s side this action is interpreted as a server malfunction and they, more often than not, switch to a failover pool. \nThe implementation of the notificationmining.reconnecthelps client to better merge with logic of handling of large mining pools.", "Workers Authorization": "The minerMUSTauthorize at least one worker in order to begin receiving jobs and submit solutions or hashrates. The minerMAYauthorize multiple workers in the same session. The serverMUSTallow authorization for multiple workers within a session andMUSTvalidate at least one authorization from the client before starting to send jobs. Aworkeris a tuple of the address where rewards must be credited coupled with identifier of the machine actually doing the work. For Ethereum the most common form is<account>.<MachineName>. The same account can be bound to multiple machines. For pool\u2019s allowing anonymous mining the account is the address where rewards must be credited, while, for pools requiring registration, the account is the login name. Each time a solution is submitted by the client it must be labelled with the Worker identifier. It\u2019s up to server to keep the correct accounting for different addresses.", "Prepare for mining": "A lot of data is sent over the wire multiple times with useless redundancy. For instance the seed hash is meant to change only every 30000 blocks (roughly 5 days) while fixed-diff pools rarely change the work target. Moreover pools must optimize the search segments among miners trying to assign to every session a different \u201cstartNonce\u201d (AKA extraNonce).\nFor this purpose thenotificationmethodmining.setallows to set (on miner\u2019s side) only those params which change less frequently. The server will keep track of seed, target and extraNonce at session level and will push a notificationmining.setwhenever any (or all) of those values change to the connected miner.", "A detail of \u201cextranonce\u201d": "Miners connected to a pool might likely process the very same nonces thus wasting a lot of duplicate jobs. Anonceis any valid number which, applied to algorithm and job specifications, produces a result which is below a certain target. For every job pushed by server to client(s) there are 2^64 possible nonces to test.", "Jobs notification": "When available server will dispatch jobs to connected miners issuing amining.notifynotification.", "Solution submission": "When a miner finds a solution for a job he is mining on it sends amining.submitrequest to server.", "Hashrate": "Most pools offer statistic information, in form of graphs or by API calls, about the calculated hashrate expressed by the miner while miners like to compare this data with the hashrate they read on their devices. Communication about parties of these information have never been coded in Stratum and most pools adopt the method from getWork namedeth_submitHashrate.\nIn this document we propose an official implementation of themining.hashraterequest.\nThis method behaves differently when issued from client or from server.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- ethereumstratum/2.0.0: Defines a new standard for the Stratum protocol used by Ethereum miners to communicate with mining pool servers, providing an efficient two-way communication mechanism over a TCP connection.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1767, "url": "https://eips.ethereum.org/EIPS/eip-1767", "title": "GraphQL interface to Ethereum node data", "authors": ["Nick Johnson\u00a0(", "@arachnid", ")", "Ra\u00fal Kripalani\u00a0(", "@raulk", ")", "Kris Shinn\u00a0(", "@kshinn", ")"], "sections": {"EIP-1767: GraphQL interface to Ethereum node data": "This EIP specifies a GraphQL schema for accessing data stored on an Ethereum node. It aims to provide a complete replacement to the read-only information exposed via the present JSON-RPC interface, while improving on usability, consistency, efficiency, and future-proofing.", "": "This EIP specifies a GraphQL schema for accessing data stored on an Ethereum node. It aims to provide a complete replacement to the read-only information exposed via the present JSON-RPC interface, while improving on usability, consistency, efficiency, and future-proofing.", "Abstract": "This EIP specifies a GraphQL schema for accessing data stored on an Ethereum node. It aims to provide a complete replacement to the read-only information exposed via the present JSON-RPC interface, while improving on usability, consistency, efficiency, and future-proofing.", "Motivation": "The current JSON-RPC interface for Ethereum nodes has a number of shortcomings. It\u2019s informally and incompletely specified in areas, which has led to incompatibilities around issues such as representation of empty byte strings (\u201c\u201d vs \u201c0x\u201d vs \u201c0x0\u201d), and it has to make educated guesses about the data a user will request, which often leads to unnecessary work.", "Prior Art": "Nick Johnson andEthQLindependently developed a GraphQL schema for node data. Once the parties were made aware of the shared effort, they made efforts to bring their schemas into alignment. The current schema proposed in this EIP is derived primarily from the EthQL schema.", "Specification": "Compatible nodes MUST provide a GraphQL endpoint available over HTTP. This SHOULD be offered on port 8547 by default. The path to the GraphQL endpoint SHOULD be \u2018/graphql\u2019.", "Node API": "Compatible nodes MUST provide a GraphQL endpoint available over HTTP. This SHOULD be offered on port 8547 by default. The path to the GraphQL endpoint SHOULD be \u2018/graphql\u2019.", "Schema": "The GraphQL schema for this service is defined as follows:", "Rationale": "Ethereum nodes have been moving away from providing read-write functionality such as transaction and message signing, and from other services such as code compilation, in favor of a more \u2018unix-like\u2019 approach where each task is performed by a dedicated process. We have thus specified a core set of types and fields that reflects this trend, leaving out functionality that is presently, or intended to be, deprecated:", "Backwards Compatibility": "This schema implements the bulk of the current read-only functionality provided by the JSON-RPC node interface. Existing RPC calls can be mapped to GraphQL queries as follows:", "Test Cases": "TBD.", "Implementation": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- graphql interface to ethereum node data: Proposes a GraphQL schema for accessing Ethereum node data, replacing the current JSON-RPC interface to improve usability, efficiency, and future-proofing.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1803, "url": "https://eips.ethereum.org/EIPS/eip-1803", "title": "Rename opcodes for clarity", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-1803: Rename opcodes for clarity": "Rename theBALANCE,SHA3,NUMBER,GASLIMIT,GASandINVALIDopcodes to reflect their true meaning.", "": "Rename theBALANCE,SHA3,NUMBER,GASLIMIT,GASandINVALIDopcodes to reflect their true meaning.", "Abstract": "Rename theBALANCE,SHA3,NUMBER,GASLIMIT,GASandINVALIDopcodes to reflect their true meaning.", "Specification": "Rename the opcodes as follows:", "Backwards Compatibility": "This has no effect on any code. It can influence what mnemonics assemblers will use.", "Implementation": "Not applicable.", "References": "EIP-6previously renamedSUICIDE(0xff) toSELFDESTRUCT.\nRenamingSHA3was previously proposed byEIP-59.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1901, "url": "https://eips.ethereum.org/EIPS/eip-1901", "title": "Add OpenRPC Service Discovery To JSON-RPC Services", "authors": ["Shane Jonas\u00a0(", "@shanejonas", ")", "Zachary Belford\u00a0(", "@belfordz", ")"], "sections": {"EIP-1901: Add OpenRPC Service Discovery To JSON-RPC Services": "This is a proposal to addOpenRPCsupport to existing and future JSON-RPC services by adding the methodrpc.discoverto the projectsJSON-RPCAPIs, enabling automation and tooling.", "": "This is a proposal to addOpenRPCsupport to existing and future JSON-RPC services by adding the methodrpc.discoverto the projectsJSON-RPCAPIs, enabling automation and tooling.", "Abstract": "This is a proposal to addOpenRPCsupport to existing and future JSON-RPC services by adding the methodrpc.discoverto the projectsJSON-RPCAPIs, enabling automation and tooling.", "What is this?": "This is a proposal to addOpenRPCsupport to existing and future JSON-RPC services by adding the methodrpc.discoverto the projectsJSON-RPCAPIs, enabling automation and tooling.", "Motivation": "AlthoughEIP-1474outlines a JSON-RPC specification. Ethereum still lacks a machine-readable JSON-RPC Specification that can be used as the industry standard for tooling. This proposal attempts to standardize such a specification in a way that is versionable, and both human and machine readable.", "Specification": "TheOpenRPCSpecification defines a standard, programming language-agnostic interface description forJSON-RPC 2.0APIs, which allows both humans and computers to discover and understand the capabilities of a service without requiring access to source code, additional documentation, or inspection of network traffic. When properly defined via OpenRPC, a consumer can understand and interact with the remote service with a minimal amount of implementation logic, and share these logic patterns across use cases. Similar to what interface descriptions have done for lower-level programming, the OpenRPC Specification removes guesswork in calling a service.", "What is OpenRPC?": "TheOpenRPCSpecification defines a standard, programming language-agnostic interface description forJSON-RPC 2.0APIs, which allows both humans and computers to discover and understand the capabilities of a service without requiring access to source code, additional documentation, or inspection of network traffic. When properly defined via OpenRPC, a consumer can understand and interact with the remote service with a minimal amount of implementation logic, and share these logic patterns across use cases. Similar to what interface descriptions have done for lower-level programming, the OpenRPC Specification removes guesswork in calling a service.", "Use Case": "This is the vision for the use case of OpenRPC and how it would relate to a client implementation like multi-geth:", "Rationale": "Services need to figure out how to talk to each other. If we really want to build the next generation of automation, then having up to date libraries, documented APIs, and modern tools are going to provide easy discovery, on-boarding, and enable end user and developer interaction.", "Why would we do this?": "Services need to figure out how to talk to each other. If we really want to build the next generation of automation, then having up to date libraries, documented APIs, and modern tools are going to provide easy discovery, on-boarding, and enable end user and developer interaction.", "Alternative": "OpenRPCdocuments just describeJSON-RPCAPIs services, and are represented in JSON format. These documents may be produced and served statically OR generated dynamically from an application and returned via therpc.discovermethod. This gives projects and communities the opportunity to adopt tools, documentation, and clients outlined in theetclabscore/ethereum-json-rpc-specificationbefore therpc.discovermethod is implemented for a particular client.", "Implementation": "You can view the interactive documentationhere.", "Tooling": "You can view the interactive documentationhere.", "Resources": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- rpc.discover: Adds OpenRPC service discovery to Ethereum\u2019s JSON-RPC services, enabling machine-readable API specifications.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2003, "url": "https://eips.ethereum.org/EIPS/eip-2003", "title": "EVMC modules for implementations of precompiled contracts", "authors": ["Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-2003: EVMC modules for implementations of precompiled contracts": "EVMCspecifies a generic API for Ethereum execution engines.\nThis EIP specifies a way of providing implementations of Ethereum precompiled contracts\nusing theEVMC VM API.", "": "EVMCspecifies a generic API for Ethereum execution engines.\nThis EIP specifies a way of providing implementations of Ethereum precompiled contracts\nusing theEVMC VM API.", "Abstract": "EVMCspecifies a generic API for Ethereum execution engines.\nThis EIP specifies a way of providing implementations of Ethereum precompiled contracts\nusing theEVMC VM API.", "Specification": "For the completeEVMCspecification visit theEVMC documentationfirst.\nThis EIP is based on and is compatible with EVMC ABI version 6.", "Rationale": "It is very unlikely that any precompile will need to access or modify a contract state.\nNot requiring the Client to implement the EVMC Host interface removes the big portion of work\nneeded for full EVMC integration.", "Test Cases": "EVMC provides theevmc-vmtestertool for checking compatibility with the EVMC specification.", "Implementations": "Copyright and related rights waived viaCC0.", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2015, "url": "https://eips.ethereum.org/EIPS/eip-2015", "title": "wallet_updateEthereumChain RPC Method", "authors": ["Pedro Gomes\u00a0(", "@pedrouid", ")", "Erik Marks\u00a0(", "@rekmarks", ")", "Pandapip1\u00a0(", "@Pandapip1", ")"], "sections": {"EIP-2015: wallet_updateEthereumChain RPC Method": "This EIP adds a wallet-namespaced RPC endpoint,wallet_updateEthereumChain, providing a standard interface for switching chains. The method takes the minimal parameters ofchainId,chainName,rpcUrl,nativeCurrencyandblockExplorerUrl.", "Adds an RPC method to switch between EVM-compatible chains": "This EIP adds a wallet-namespaced RPC endpoint,wallet_updateEthereumChain, providing a standard interface for switching chains. The method takes the minimal parameters ofchainId,chainName,rpcUrl,nativeCurrencyandblockExplorerUrl.", "Abstract": "This EIP adds a wallet-namespaced RPC endpoint,wallet_updateEthereumChain, providing a standard interface for switching chains. The method takes the minimal parameters ofchainId,chainName,rpcUrl,nativeCurrencyandblockExplorerUrl.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "wallet_updateEthereumChain": "Thewallet_updateEthereumChainmethod is used to switch to a network, and registering it with the wallet if it isn\u2019t already recognized.", "Rationale": "Thewallet_updateEthereumChainmethod is designed to be as simple as possible, while still providing the necessary information for a wallet to switch to a new chain. ThechainIdis the only required parameter, as it is the only parameter that is guaranteed to be unique. ThechainNameis included to provide a human-readable name for the chain, and therpcUrlsarray is included to provide a list of RPC endpoints for the chain. ThenativeCurrencyobject is included to provide a suggestion for how the native currency should be displayed. Finally, theblockExplorerUrlis included to provide a link to a block explorer for the chain.", "Backwards Compatibility": "This EIP is fully backwards compatible.", "Security Considerations": "TherpcUrlsparameter is a list of RPC endpoints for the chain. Wallets should sanitize each RPC url before using it to send other requests, including ensuring that it responds correctly to thenet_versionandeth_chainIdmethods.", "Server-Side Request Forgery (SSRF)": "TherpcUrlsparameter is a list of RPC endpoints for the chain. Wallets should sanitize each RPC url before using it to send other requests, including ensuring that it responds correctly to thenet_versionandeth_chainIdmethods.", "Phishing": "Wallets should store a default list of data for commonly-used chains, in order to avoid phishing attacks.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- wallet_updateethereumchain: A wallet-namespaced RPC method that allows switching between EVM-compatible chains and registering new chains with wallets.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2256, "url": "https://eips.ethereum.org/EIPS/eip-2256", "title": "wallet_getOwnedAssets JSON-RPC Method", "authors": ["Loredana Cirstea\u00a0(", "@loredanacirstea", ")"], "sections": {"EIP-2256: wallet_getOwnedAssets JSON-RPC Method": "This is a proposal for a new JSON-RPC call for retrieving from a wallet a selection of owned assets by an Ethereum address, with the user\u2019s permission.", "": "This is a proposal for a new JSON-RPC call for retrieving from a wallet a selection of owned assets by an Ethereum address, with the user\u2019s permission.", "Simple Summary": "This is a proposal for a new JSON-RPC call for retrieving from a wallet a selection of owned assets by an Ethereum address, with the user\u2019s permission.", "Abstract": "There is no standardized way for a dApp to request a list of owned assets from a user. Now, each dApp needs to keep a list of all the popular or existing assets and check the user\u2019s balance against the blockchain, for each of these assets. This leads to duplicated effort across dApps. It also leads to the user being presented with asset options that the user does not care about, from various, unwanted airdrops.", "Motivation": "There are financial dApps that require a list of owned assets from a user, for various purposes - calculating taxes, selecting customized payment options, etc. Each of these dApps are now forced to keep a list of popular assets (smart contract addresses, ABIs) and retrieve the user\u2019s data from the blockchain, for each asset. This leads to effort duplication and nonoptimal UX where the user is presented with either more or less asset options than the user would like - various airdrops, incomplete list of assets kept by the dApp.", "Specification": "New JSON-RPC method to be added to web3 browsers:wallet_getOwnedAssets. This method is for dApp-wallet communication and only targets the assets that have already been whitelisted by the wallet, for the user account.", "Examples": "1) A request to return all of the user\u2019s owned assets:", "UI Best Practices": "The wallet should display a UI to the user, showing the request.\nThe user can:", "Rationale": "In order to avoid duplication of effort for dApps that require keeping a list of all or popular assets and to provide optimal UX, thewallet_getOwnedAssetsJSON-RPC method is proposed.", "Backwards Compatibility": "Not relevant, as this is a new method.", "Test Cases": "To be done.", "Implementation": "To be done.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- wallet_getownedassets: Introduces a JSON-RPC method to retrieve a list of assets owned by an Ethereum address, as curated by the user's wallet.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2566, "url": "https://eips.ethereum.org/EIPS/eip-2566", "title": "Human Readable Parameters for Contract Function Execution", "authors": ["Joseph Stockermans\u00a0(", "@jstoxrocky", ")"], "sections": {"EIP-2566: Human Readable Parameters for Contract Function Execution": "New Ethereum RPC methodeth_sendTransactionToContractFunctionthat parallelseth_sendTransactionbut allows for human-readable contract function execution data to be displayed to users.", "": "New Ethereum RPC methodeth_sendTransactionToContractFunctionthat parallelseth_sendTransactionbut allows for human-readable contract function execution data to be displayed to users.", "Simple Summary": "New Ethereum RPC methodeth_sendTransactionToContractFunctionthat parallelseth_sendTransactionbut allows for human-readable contract function execution data to be displayed to users.", "Abstract": "When a dapp prompts a user to execute a smart contract function via a ProviderWallet, confirmation screens displayed in the ProviderWallet layer cannot display the human readable details of the function to be called and the arguments to be passed. This is because the Ethereum RPC method used for contract function execution (eth_sendTransaction) accepts information about what function to call in a non-human readable (and non-recoverable) format. As such, when a ProviderWallet receives this non-human readable information from a dapp, they are unable to display a human readable version since they never received one and cannot recover one from the data.", "Motivation": "ProviderWallets like Metamask and Geth are hybrid software that combine an Ethereum API provider with an Ethereum wallet. This allows them to sign transactions on behalf of their users and also broadcast those signed transactions to the Ethereum network. ProviderWallets are used for both convenience and for the protection they give users through human readable confirmation prompts.", "ProviderWallet Definition": "ProviderWallets like Metamask and Geth are hybrid software that combine an Ethereum API provider with an Ethereum wallet. This allows them to sign transactions on behalf of their users and also broadcast those signed transactions to the Ethereum network. ProviderWallets are used for both convenience and for the protection they give users through human readable confirmation prompts.", "Existing Solutions": "Much discussion has been made in the past few years on the topic of human readable Ethereum transaction data. Aragon\u2019sRadspecaddresses this issue by requiring contract developers to amend their contract functions with human readable comments. ProviderWallets can then use Aragon\u2019s Radspec software to parse these comments from the contract code and display them to the end user - substituting in argument values where necessary. Unfortunately, this approach cannot work with contracts that do not have Radspec comments (and may require integration with IPFS).", "Background": "At one point or another, a dapp will ask a user to interact with a contract. The interaction between dapps and contracts is a large part of the Ethereum ecosystem and is most commonly brokered by a ProviderWallet. When a dapp asks a user to interact with a contract, it will do so by sending theeth_sendTransactionmethod name to the Ethereum API exposed by a ProviderWallet along with the relevant transaction data. Thedatafield of the transaction data contains the information necessary for the Ethereum virtual machine to identify and execute the contract\u2019s function. This field has a specific formatting that is both non-human readable and non-recoverable to its human readable state.", "Specification": "This EIP proposes increasing the set of Ethereum RPC methods to include a new method -eth_sendTransactionToContractFunction. This method parallelseth_sendTransactionwith the only difference being the inclusion of the contract function\u2019sabifield.", "Rationale": "This EIP\u2019s proposedeth_sendTransactionToContractFunctionmethod is intended to paralleleth_sendTransactionas much as possible since both methods result in the same behaviour when executing a contract function. The newly introducedabifield is an element of the contract\u2019s ABI that corresponds to the intended function. Thedatafield is the samedatafield frometh_sendTransaction. Theabifield can be combined with values parsed from thedatafield to recreate human readable contract function execution information.", "Implementation": "Thedatafield ineth_sendTransactionToContractFunctionis the same as that required foreth_sendTransactionallowing the transaction to be completed via the existing mechanisms used foreth_sendTransaction. The input argument values can be parsed from thedatafield and since we know their types from theabifield, the provider wallet can use this info to encode and display the values in an appropriate human readable format. Furthermore, the hashed and truncated function signature in thedatafield can be reconstructed using the information provided in theabifield providing an additional check to ensure that the supplied ABI matches thedatafield.", "Backwards Compatibility": "With backwards compatibility in mind, this EIP proposes augmenting the set of Ethereum RPC methods with an additional method instead of mutating the existing method. Precedent for adding a new RPC method comes fromEIP 712in which adding the methodeth_signTypedDatais proposed for confirmation prompt security. As an alternate approach, theeth_sendTransactionmethod could be changed to accept an additionalabiargument, but this would break all existing code attempting to execute a contract function.", "Security Considerations": "Displaying the contract address, function name, and argument values can provide additional security to users, but it is not a guarantee that a function will execute as the user expects. A poorly implemented contract can still name its functiontransferand acceptaddressanduint256arguments - but there is nothing short of contract examination that will let a user know that this contract is indeed a valid ERC20 contract. This EIP does not intend to solve the larger problem around trust in a contract\u2019s code, but instead intends to give users better tools to understand exactly what is contained within the data they are broadcasting to the Ethereum network.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- human readable parameters: Proposes a new Ethereum RPC method, eth_sendTransactionToContractFunction, allowing users to see human-readable contract function details when executing transactions.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2831, "url": "https://eips.ethereum.org/EIPS/eip-2831", "title": "Transaction Replacement Message Type", "authors": ["Gregory Markou\u00a0(", "@GregTheGreek", ")"], "sections": {"EIP-2831: Transaction Replacement Message Type": "An extension to the JavaScript Ethereum Provider API (EIP-1193) this creates a new message type in the event a transaction replacement occurs.", "": "An extension to the JavaScript Ethereum Provider API (EIP-1193) this creates a new message type in the event a transaction replacement occurs.", "Summary": "An extension to the JavaScript Ethereum Provider API (EIP-1193) this creates a new message type in the event a transaction replacement occurs.", "Abstract": "The current communication between providers and consumers of providers are fundamentally broken in the event that a transaction in the mempool has been superseded by a newer transactions. Providers currently have no way of communicating a transaction replacement, and consumers are required to poll block by block for the resulting transaction.", "Motivation": "Exert from EIP-1193", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described inRFC-2119.", "Definitions": "This section is non-normative.", "Events": "These methodsMUSTbe implemented per the Node.jsEventEmitterAPI.", "Rationale": "The implementation was chosen to help the ease of implementation for both providers and dapp developers. SinceProviderMessageis widely used by dapp developers already it means that the implementation path would be as trivial as adding and additionalifclause to their existing message listener. This also provides a benefit to dapps in the event that a provider has not yet implemented the events, it will not cause the dapp panic withundefinedshould it be implemented natively (eg:ethereum.txCancel(...)which would error withethereum.txReplacement()is not a function).", "Backwards Compatibility": "Many Providers adopted EIP-1193, as this EIP extends the same event logic, there should be no breaking changes. All providers that do not support the new events should either I) Ignore the subscription or II) Provide some error to the user.", "Implementations": "None at the current time.", "Security Considerations": "None at the current time.", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Appendix I: Examples": "These examples assume a web browser environment.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- transaction replacement message: Adds a new message type to the Ethereum Provider API for notifying clients when a transaction in the mempool is replaced or canceled.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2844, "url": "https://eips.ethereum.org/EIPS/eip-2844", "title": "Add DID related methods to the JSON-RPC", "authors": ["Joel Thorstensson\u00a0(", "@oed", ")"], "sections": {"EIP-2844: Add DID related methods to the JSON-RPC": "Add new methods to the JSON-RPC for signing and decrypting JOSE objects under a newdid_*prefix.", "": "Add new methods to the JSON-RPC for signing and decrypting JOSE objects under a newdid_*prefix.", "Simple Summary": "Add new methods to the JSON-RPC for signing and decrypting JOSE objects under a newdid_*prefix.", "Abstract": "This EIP describes three new methods to add to the JSON-RPC that enables wallets to supportDecentralized Identifiers(DIDs) as well asJSON Object Signing and Encryption(JOSE). These standards enables wallets to support data decryption as well as authenticated data, both in standard formats using JOSE. With these new methods apps can request the DID from a users wallet, from which a DID document can be resolved. The DID document contains public keys that can be used for encryption and signature verification. This enables Alice to discover Bobs public keys by only knowing Bobs DID. This EIP does not enforce the user of any particular DID method or JOSE algorithms, wallets are free to implement these however they wish.", "Motivation": "There has been one main previous effort (#130,#1098) to add decryption to Ethereum wallets in a standard way. This previous approach used a non standard way to encode and represent data encrypted usingx25519-xsalsa20-poly1305. While this approach does provide a functional way to add encryption support to wallets, it does not take into account similar work that has gone into standardizing the way encrypted data is represented, namely usingJOSE. This is a standard from IETF for representing signed and encrypted objects. Another shortcoming of the previous approach is that it\u2019s impossible to retrieve thex25519public key from another user if only an Ethereum address is known. Public key discoverability is at the core of the work that is happening with theW3C DID standard, where given a DID a document which contains public keys can always be discovered. Implementations of this standard already exist and are adopted within the Ethereum community, e.g.did:ethranddid:3. Interoperability between JOSE and DIDsalready exists, and work is being done tostrengthen it. Adding support for JOSE and DIDs will enable Ethereum wallets to support a wide range of new use cases such as more traditional authentication using JWTs, as well as new emerging technologies such asSecure Data Storesandencrypted data in IPFS.", "Specification": "Three new JSON-RPC methods are specified under the newdid_*prefix.", "Auth": "Authenticate the current rpc connection to the DID methods.", "Rationale": "This EIP chooses to rely on DIDs and JOSE since there is already support for these standards in many places, by current systems and new systems. By using DIDs and JOSE wallet implementers can also choose which signing and encryption algorithms that they want to support, since these formats are fairly agnostic to specific crypto implementations.", "Permission system": "A simple permission system is proposed where clients can request permissions though path prefixes, e.g./some/permission. When decryption of a JWE is requested the wallet should check if the decrypted payload contains apathsproperty. If this property doesn\u2019t exist the user may be prompted to confirm that the given rpc connection (app) is allowed to read the decrypted data. If thepathsproperty is present in the decrypted data it should contain an array of string paths. If one of the these path prefixes matches with one of the path prefixes the user has already granted permission for then decryption should happen automatically without any user confirmation.", "Implementation": "IdentityWallet: An implementation of the wallet sidedid_*methods using the 3ID DID.", "Security Considerations": "Both JOSE and DIDs are standards that have gone though a lot of scrutiny. Their security will not be considered in this document. In the specification section, recommendations are given for which algorithms to use. For signaturessecp256k1is already used by ethereum and for decryptionxchacha20poly1305is widely available, very performant, and already used in TLS.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3014, "url": "https://eips.ethereum.org/EIPS/eip-3014", "title": "eth_symbol JSON-RPC method", "authors": ["Peter Grassberger\u00a0(", "@PeterTheOne", ")"], "sections": {"EIP-3014: eth_symbol JSON-RPC method": "Addeth_symbolmethod to the JSON-RPC that returns the symbol of the native coin of the network.", "": "Addeth_symbolmethod to the JSON-RPC that returns the symbol of the native coin of the network.", "Simple Summary": "Addeth_symbolmethod to the JSON-RPC that returns the symbol of the native coin of the network.", "Abstract": "The new methodeth_symbol(eth_-namespaced) has no parameters and returns a string of the native coin of the network. For the Ethereum mainnet this will beETH, other networks will have other symbols.", "Motivation": "Wallets that deal with multiple networks need some basic information for every blockchain that they connect to. One of those things is the symbol of the native coin of the network. Instead of requiring the user to research and manually add the symbol it could be provided to the wallet via this proposed JSON-RPC endpoint and used automatically. There are lists of networks with symbols like https://github.com/ethereum-lists/chains where a user can manually look up the correct values. But this information could easily come from the network itself.", "Specification": "Method:eth_symbol.", "Rationale": "This endpoint is similar toEIP-695but it provides the symbol instead ofchainId. It provides functionality that is already there forERC-20tokens, but not yet for the native coin of the network. Alternative naming ofeth_nativeCurrencySymbolwas considered, but the context and the fact that it just returns one value makes it clear that that it returns the symbol for the native coin of the network.", "Security Considerations": "It is a read only endpoint. The information is only as trusted as the JSON-RPC node itself, it could supply wrong information and thereby trick the user in believing he/she is dealing with another native coin.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- eth_symbol: Adds the eth_symbol JSON-RPC method, which returns the symbol of the native coin of the connected network (e.g., \"ETH\" for Ethereum mainnet).\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3030, "url": "https://eips.ethereum.org/EIPS/eip-3030", "title": "BLS Remote Signer HTTP API", "authors": ["Herman Junge\u00a0(", "@hermanjunge", ")"], "sections": {"EIP-3030: BLS Remote Signer HTTP API": "This EIP defines a HTTP API standard for a BLS remote signer, consumed by validator clients to sign block proposals and attestations in the context of Ethereum 2.0 (eth2).", "": "This EIP defines a HTTP API standard for a BLS remote signer, consumed by validator clients to sign block proposals and attestations in the context of Ethereum 2.0 (eth2).", "Simple Summary": "This EIP defines a HTTP API standard for a BLS remote signer, consumed by validator clients to sign block proposals and attestations in the context of Ethereum 2.0 (eth2).", "Abstract": "Avalidatorclient contributes to the consensus of the Eth2 blockchain by signing proposals and attestations of blocks, using a BLS private key which must be available to this client at all times.", "Motivation": "Eth2 utilizesBLS12-381signatures.", "Specification": "Responses", "GET /upcheck": "Let\u2019s consider the following threats and their mitigations:", "GET /keys": "Let\u2019s consider the following threats and their mitigations:", "POST /sign/:identifier": "Let\u2019s consider the following threats and their mitigations:", "Rationale": "This API specification contains only three methods: one forstatus, one forlisting the available keys, and one toproduce a signature. There are no methods for authentication, key management, nor transport encryption.", "UNIX philosophy: Simple API": "This API specification contains only three methods: one forstatus, one forlisting the available keys, and one toproduce a signature. There are no methods for authentication, key management, nor transport encryption.", "Test Cases": "Let\u2019s consider the following threats and their mitigations:", "Test Data": "Let\u2019s consider the following threats and their mitigations:", "Implementation": "Let\u2019s consider the following threats and their mitigations:", "Security Considerations": "Let\u2019s consider the following threats and their mitigations:", "Threat model": "Let\u2019s consider the following threats and their mitigations:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- bls remote signer http api: Defines an API for a BLS remote signer, allowing validator clients to sign block proposals and attestations using remote keys stored securely.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3041, "url": "https://eips.ethereum.org/EIPS/eip-3041", "title": "Adds `baseFee` to `eth_getBlockByHash`", "authors": ["Abdelhamid Bakhta\u00a0(", "@abdelhamidbakhta", ")"], "sections": {"EIP-3041: Adds `baseFee` to `eth_getBlockByHash`": "Add basefee field toeth_getBlockByHashRPC endpoint response.", "": "Add basefee field toeth_getBlockByHashRPC endpoint response.", "Simple Summary": "Add basefee field toeth_getBlockByHashRPC endpoint response.", "Abstract": "AddsbaseFeeproperty to theeth_getBlockByHashJSON-RPC requestresultobject.  This property will contain the value of the base fee for any block after the EIP-1559 fork.", "Motivation": "EIP-1559introduces a base fee per gas in protocol.\nThis value is maintained under consensus as a new field in the block header structure.\nUsers may need value of the base fee at a given block. Base fee value is important to make gas price predictions more accurate.", "Specification": "Returns information about a block specified by hash.\nEvery block returned by this endpoint whose block number is before theEIP-1559fork blockMUST NOTinclude abaseFeefield.\nEvery block returned by this endpoint whose block number is on or after theEIP-1559fork blockMUSTinclude abaseFeefield.", "eth_getBlockByHash": "Returns information about a block specified by hash.\nEvery block returned by this endpoint whose block number is before theEIP-1559fork blockMUST NOTinclude abaseFeefield.\nEvery block returned by this endpoint whose block number is on or after theEIP-1559fork blockMUSTinclude abaseFeefield.", "Rationale": "The addition of a single parameter instead of introducing a whole new endpoint was the simplest change that would be easiest to get integrated.\nFor backward compatibility we decided to not include the base fee in the response for pre-1559 blocks.", "Backwards Compatibility": "Backwards compatible. Calls related to block prior toEIP-1559fork block will omit the base fee field in the response.", "Security Considerations": "The added field (baseFee) is informational and does not introduce technical security issues.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3044, "url": "https://eips.ethereum.org/EIPS/eip-3044", "title": "Adds `baseFee` to `eth_getBlockByNumber`", "authors": ["Abdelhamid Bakhta\u00a0(", "@abdelhamidbakhta", ")"], "sections": {"EIP-3044: Adds `baseFee` to `eth_getBlockByNumber`": "Add basefee field toeth_getBlockByNumberRPC endpoint response.", "": "Add basefee field toeth_getBlockByNumberRPC endpoint response.", "Simple Summary": "Add basefee field toeth_getBlockByNumberRPC endpoint response.", "Abstract": "AddsbaseFeeproperty to theeth_getBlockByNumberJSON-RPC requestresultobject.  This property will contain the value of the base fee for any block after the EIP-1559 fork.", "Motivation": "EIP-1559introduces a base fee per gas in protocol.\nThis value is maintained under consensus as a new field in the block header structure.\nUsers may need value of the base fee at a given block. Base fee value is important to make gas price predictions more accurate.", "Specification": "Returns information about a block specified by number.\nEvery block returned by this endpoint whose block number is before theEIP-1559fork blockMUST NOTinclude abaseFeefield.\nEvery block returned by this endpoint whose block number is on or after theEIP-1559fork blockMUSTinclude abaseFeefield.", "eth_getBlockByNumber": "Returns information about a block specified by number.\nEvery block returned by this endpoint whose block number is before theEIP-1559fork blockMUST NOTinclude abaseFeefield.\nEvery block returned by this endpoint whose block number is on or after theEIP-1559fork blockMUSTinclude abaseFeefield.", "Rationale": "The addition of a single parameter instead of introducing a whole new endpoint was the simplest change that would be easiest to get integrated.\nFor backward compatibility we decided to not include the base fee in the response for pre-1559 blocks.", "Backwards Compatibility": "Backwards compatible. Calls related to block prior toEIP-1559fork block will omit the base fee field in the response.", "Security Considerations": "The added field (baseFee) is informational and does not introduce technical security issues.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3045, "url": "https://eips.ethereum.org/EIPS/eip-3045", "title": "Adds `baseFee` to `eth_getUncleByBlockHashAndIndex`", "authors": ["Abdelhamid Bakhta\u00a0(", "@abdelhamidbakhta", ")"], "sections": {"EIP-3045: Adds `baseFee` to `eth_getUncleByBlockHashAndIndex`": "Add basefee field toeth_getUncleByBlockHashAndIndexRPC endpoint response.", "": "Add basefee field toeth_getUncleByBlockHashAndIndexRPC endpoint response.", "Simple Summary": "Add basefee field toeth_getUncleByBlockHashAndIndexRPC endpoint response.", "Abstract": "AddsbaseFeeproperty to theeth_getUncleByBlockHashAndIndexJSON-RPC requestresultobject.  This property will contain the value of the base fee for any block after the EIP-1559 fork.", "Motivation": "EIP-1559introduces a base fee per gas in protocol.\nThis value is maintained under consensus as a new field in the block header structure.\nUsers may need value of the base fee at a given block. Base fee value is important to make gas price predictions more accurate.", "Specification": "Returns information about an uncle specified by block hash and uncle index position\nEvery block returned by this endpoint whose block number is before theEIP-1559fork blockMUST NOTinclude abaseFeefield.\nEvery block returned by this endpoint whose block number is on or after theEIP-1559fork blockMUSTinclude abaseFeefield.", "eth_getUncleByBlockHashAndIndex": "Returns information about an uncle specified by block hash and uncle index position\nEvery block returned by this endpoint whose block number is before theEIP-1559fork blockMUST NOTinclude abaseFeefield.\nEvery block returned by this endpoint whose block number is on or after theEIP-1559fork blockMUSTinclude abaseFeefield.", "Rationale": "The addition of a single parameter instead of introducing a whole new endpoint was the simplest change that would be easiest to get integrated.\nFor backward compatibility we decided to not include the base fee in the response for pre-1559 blocks.", "Backwards Compatibility": "Backwards compatible. Calls related to block prior toEIP-1559fork block will omit the base fee field in the response.", "Security Considerations": "The added field (baseFee) is informational and does not introduce technical security issues.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3046, "url": "https://eips.ethereum.org/EIPS/eip-3046", "title": "Adds `baseFee` to `eth_getUncleByBlockNumberAndIndex`", "authors": ["Abdelhamid Bakhta\u00a0(", "@abdelhamidbakhta", ")"], "sections": {"EIP-3046: Adds `baseFee` to `eth_getUncleByBlockNumberAndIndex`": "Add basefee field toeth_getUncleByBlockNumberAndIndexRPC endpoint response.", "": "Add basefee field toeth_getUncleByBlockNumberAndIndexRPC endpoint response.", "Simple Summary": "Add basefee field toeth_getUncleByBlockNumberAndIndexRPC endpoint response.", "Abstract": "AddsbaseFeeproperty to theeth_getUncleByBlockNumberAndIndexJSON-RPC requestresultobject.  This property will contain the value of the base fee for any block after the EIP-1559 fork.", "Motivation": "EIP-1559introduces a base fee per gas in protocol.\nThis value is maintained under consensus as a new field in the block header structure.\nUsers may need value of the base fee at a given block. Base fee value is important to make gas price predictions more accurate.", "Specification": "Returns information about an uncle specified by block number and uncle index position\nEvery block returned by this endpoint whose block number is before theEIP-1559fork blockMUST NOTinclude abaseFeefield.\nEvery block returned by this endpoint whose block number is on or after theEIP-1559fork blockMUSTinclude abaseFeefield.", "eth_getUncleByBlockNumberAndIndex": "Returns information about an uncle specified by block number and uncle index position\nEvery block returned by this endpoint whose block number is before theEIP-1559fork blockMUST NOTinclude abaseFeefield.\nEvery block returned by this endpoint whose block number is on or after theEIP-1559fork blockMUSTinclude abaseFeefield.", "Rationale": "The addition of a single parameter instead of introducing a whole new endpoint was the simplest change that would be easiest to get integrated.\nFor backward compatibility we decided to not include the base fee in the response for pre-1559 blocks.", "Backwards Compatibility": "Backwards compatible. Calls related to block prior toEIP-1559fork block will omit the base fee field in the response.", "Security Considerations": "The added field (baseFee) is informational and does not introduce technical security issues.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3085, "url": "https://eips.ethereum.org/EIPS/eip-3085", "title": "wallet_addEthereumChain RPC Method", "authors": ["Erik Marks\u00a0(", "@rekmarks", ")", "Pedro Gomes\u00a0(", "@pedrouid", ")", "Pandapip1\u00a0(", "@Pandapip1", ")"], "sections": {"EIP-3085: wallet_addEthereumChain RPC Method": "This EIP adds a wallet-namespaced RPC method:wallet_addEtherereumChain, providing a standard interface for adding chains to Ethereum wallets.", "Adds an RPC method to add EVM-compatible chains": "This EIP adds a wallet-namespaced RPC method:wallet_addEtherereumChain, providing a standard interface for adding chains to Ethereum wallets.", "Abstract": "This EIP adds a wallet-namespaced RPC method:wallet_addEtherereumChain, providing a standard interface for adding chains to Ethereum wallets.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "wallet_addEthereumChain": "Thewallet_addEthereumChainmethod is used to suggest to the wallet that a new chain be added to the wallet\u2019s list of chains. It takes a single parameter and returnsnullif the chain was added successfully, or an error if the chain was not added.", "Rationale": "The design ofwallet_addEthereumChainis deliberately ignorant of what it means to \u201cadd\u201d a chain to a wallet.\nThe meaning of \u201cadding\u201d a chain to a wallet depends on the wallet implementation.", "Security Considerations": "wallet_addEthereumChainis a powerful method that exposes the end user to serious risks if implemented incorrectly.\nMany of these risks can be avoided by validating the request data in the wallet, and clearly disambiguating different chains in the wallet UI.", "Chain IDs": "Since the chain ID used for transaction signing determines which chain the transaction is valid for, handling the chain ID correctly is of utmost importance.\nThe wallet should:", "RPC Endpoints and RPC URLs": "Wallets generally interact with chains via an RPC endpoint, identified by some URL.\nMost wallets ship with a set of chains and corresponding trusted RPC endpoints.\nThe endpoints identified by therpcUrlsparameter cannot be assumed to be honest, correct, or even pointing to the same chain.\nMoreover, even trusted endpoints can expose users to privacy risks depending on their data collection practices.", "Validating Chain Data": "A wallet that implementswallet_addEthereumChainshould expect to encounter requests for chains completely unknown to the wallet maintainers.\nThat said, community resources exist that can be leveraged to verify requests for many Ethereum chains.\nThe wallet should maintain a list of known chains, and verify requests to add chains against that list.\nIndeed, a wallet may even prefer its own chain metadata over anything submitted with awallet_addEthereumChainrequest.", "UX": "Adding a new chain to the wallet can have significant implications for the wallet\u2019s functionality and the experience of the user.\nA chain should never be added without the explicit consent of the user, and different chains should be clearly differentiated in the wallet UI.\nIn service of these goals, the wallet should:", "Preserving User Privacy": "Although a request to add a chain that was already added should generally be considered a success, treating such requests asautomaticsuccesses leaks information to requesters about the chains a user has added to their wallet.\nIn the interest of preserving user privacy, implementers ofwallet_addEthereumChainshould consider displaying user confirmations even in these cases.\nIf the user denies the request, the wallet should return the same user rejection error as normal so that requesters cannot learn which chains are supported by the wallet without explicit permission to do so.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- wallet_addethereumchain: Adds an RPC method that allows dApps to suggest adding new EVM-compatible chains to wallets, improving multi-chain user experiences.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3091, "url": "https://eips.ethereum.org/EIPS/eip-3091", "title": "Block Explorer API Routes", "authors": ["Pedro Gomes\u00a0(", "@pedrouid", ")", "ligi\u00a0(", "@ligi", ")"], "sections": {"EIP-3091: Block Explorer API Routes": "This proposal brings standardization between block explorers API routes when linking transactions, blocks, accounts and tokens.", "API Routes for Blockchain explorers": "This proposal brings standardization between block explorers API routes when linking transactions, blocks, accounts and tokens.", "Abstract": "This proposal brings standardization between block explorers API routes when linking transactions, blocks, accounts and tokens.", "Motivation": "Currently wallets and dapps link transactions and accounts to block explorer web pages but as chain diversity and layer two solutions grow it becomes harder to maintain a consistent user experience. Adding new chains or layer two solutions becomes harder given these endpoints are inconsistent. Standardizing the API routes to these links improves interoperability between wallets and block explorers.", "Specification": "Block explorers will route their webpages accordingly for the following data:", "Blocks": "<BLOCK_EXPLORER_URL>/block/<BLOCK_HASH_OR_HEIGHT>", "Transactions": "<BLOCK_EXPLORER_URL>/tx/<TX_HASH>", "Accounts": "<BLOCK_EXPLORER_URL>/address/<ACCOUNT_ADDRESS>", "Tokens": "<BLOCK_EXPLORER_URL>/token/<TOKEN_ADDRESS>", "Rationale": "The particular paths used in this proposal are chosen to be compatible with the majority of existing block explorers.", "Backwards Compatibility": "Incompatible block explorers can use redirects to their existing API routes in order to conform to this EIP.", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- block explorer api routes: Standardizes API routes for blockchain explorers, such as paths for transactions, blocks, accounts, and tokens, improving consistency across platforms.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3326, "url": "https://eips.ethereum.org/EIPS/eip-3326", "title": "Wallet Switch Ethereum Chain RPC Method (`wallet_switchEthereumChain`)", "authors": ["Erik Marks\u00a0(", "@rekmarks", ")"], "sections": {"EIP-3326: Wallet Switch Ethereum Chain RPC Method (`wallet_switchEthereumChain`)": "An RPC method for switching the wallet\u2019s active Ethereum chain.", "": "An RPC method for switching the wallet\u2019s active Ethereum chain.", "Simple Summary": "An RPC method for switching the wallet\u2019s active Ethereum chain.", "Abstract": "Thewallet_switchEthereumChainRPC method allows Ethereum applications (\u201cdapps\u201d) to request that the wallet switches its active Ethereum chain, if the wallet has a concept thereof.\nThe caller must specify a chain ID.\nThe wallet application may arbitrarily refuse or accept the request.nullis returned if the active chain was switched, and an error otherwise.", "Motivation": "All dapps require the user to interact with one or more Ethereum chains in order to function.\nSome wallets only supports interacting with one chain at a time.\nWe call this the wallet\u2019s \u201cactive chain\u201d.wallet_switchEthereumChainenables dapps to request that the wallet switches its active chain to whichever one is required by the dapp.\nThis enables UX improvements for both dapps and wallets.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described inRFC-2119.", "wallet_switchEthereumChain": "The method accepts a single object parameter with achainIdfield.\nThe method returnsnullif the wallet switched its active chain, and an error otherwise.", "Examples": "These examples use JSON-RPC, but the method could be implemented using other RPC protocols.", "Rationale": "The purposewallet_switchEthereumChainis to provide dapps with a way of requesting to switch the wallet\u2019s active chain, which they would otherwise have to ask the user to do manually.", "Security Considerations": "For wallets with a concept of an active chain, switching the active chain has significant implications for pending RPC requests and the user\u2019s experience.\nIf the active chain switches without the user\u2019s awareness, a dapp could induce the user to take actions for unintended chains.", "Preserving User Privacy": "Automatically rejecting requests for chains that aren\u2019t supported or have yet to be added by the wallet allows requesters to infer which chains are supported by the wallet.\nWallet implementers should consider whether this communication channel violates any security properties of the wallet, and if so, take appropriate steps to mitigate it.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- wallet_switchethereumchain: Adds an RPC method that allows dApps to request that the wallet switches its active Ethereum chain, improving multi-chain dApp interactions.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3709, "url": "https://eips.ethereum.org/EIPS/eip-3709", "title": "Remove Support for Type 1 Transactions", "authors": ["Gregory Markou\u00a0(", "@GregTheGreek", ")"], "sections": {"EIP-3709: Remove Support for Type 1 Transactions": "Deprecates usage ofEIP-2718TransactionType1 in wallets and providers, upgrading all type 1 transactions to a type 2 transaction.", "": "Deprecates usage ofEIP-2718TransactionType1 in wallets and providers, upgrading all type 1 transactions to a type 2 transaction.", "Simple Summary": "Deprecates usage ofEIP-2718TransactionType1 in wallets and providers, upgrading all type 1 transactions to a type 2 transaction.", "Abstract": "Since bothTransactionType1 and 2 containaccess_list, we propose the removal of offeringTransactionType1 from wallets and providers, instead the transaction will be converted toTransactionType2 to make use of the new gas properties introduced byEIP-1559.", "Motivation": "EIP-2930was introduced as the firstTransactionType, type 1, with the intention of addingaccess_listto theTransactionPayload.EIP-1559introduced the secondTransactionType2, which is represented asrlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s]). The intention behind EIP-1559 was to enhance the user experience surrounding gas fees, and as we move forward we expect that the majority of the network will begin to usingTransactionType2 instead of the legacy style transactions.TransactionType1 is a legacy transaction with the addition ofaccess_listmeaning that users will not benefit from enhancements made by EIP-1559.TransactionType2 containsaccess_list, thus there is no reason to further supportTransactionType1 if the end goal is to push users towards usingTransactionType2 anyway.", "Specification": "For wallets and providers, if a user submits a transaction for signing with whereTransactionType == 0x1, the developer should upgrade the transaction to meet the criteria of transaction of type 2.", "Rationale": "Improve the user experience for submitting transactions, and move away from legacy style transactions.", "Security Considerations": "There are no known security considerations at this time.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- remove support for type 1 transactions: Deprecates the use of TransactionType 1 by upgrading all transactions to TransactionType 2, enhancing gas fee functionality via EIP-1559.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5345, "url": "https://eips.ethereum.org/EIPS/eip-5345", "title": "Silent Signing Extension for JSON-RPC", "authors": ["Stanley Wu\u00a0(", "@fruit37", ")", "M\u00fccahit B\u00fcy\u00fcky\u0131lmaz\u00a0(", "@anndro", ")", "Muhammed Emin Ayd\u0131n\u00a0(", "@muhammedea", ")"], "sections": {"EIP-5345: Silent Signing Extension for JSON-RPC": "Mobile applications supporting lots of transactions might become a source of bad user experience due to uncontrolled switching between the wallet\u2019s and application\u2019s UI. By this proposal, we would like to introduce the means to sign and send wallet transactions without the need for user participation. This feature can be implemented by providing user consent for a specific time duration. We call the feature Silent Signing.", "Temporary transaction signing without user interaction": "Mobile applications supporting lots of transactions might become a source of bad user experience due to uncontrolled switching between the wallet\u2019s and application\u2019s UI. By this proposal, we would like to introduce the means to sign and send wallet transactions without the need for user participation. This feature can be implemented by providing user consent for a specific time duration. We call the feature Silent Signing.", "Abstract": "Mobile applications supporting lots of transactions might become a source of bad user experience due to uncontrolled switching between the wallet\u2019s and application\u2019s UI. By this proposal, we would like to introduce the means to sign and send wallet transactions without the need for user participation. This feature can be implemented by providing user consent for a specific time duration. We call the feature Silent Signing.", "Motivation": "Some blockchain applications interact with a blockchain much more frequently than others. It is especially true for gaming applications having their own sidechains. Interrupting the gaming process and switching to the wallet to perform a transaction drastically affect the user experience.", "Specification": "To remedy the situation, we\u2019d like to introduce new RPC methods for the ethereum JSON-RPC. Those methods help enable wallets to implement the Silent Signing feature.", "Silent Signing User Flow": "The Silent Signing process has the following structure:", "Implementation": "The implementation introduces new RPC methods and flow for application and wallet side.", "New RPC Methods": "This RPC method opens the wallet and prompts the user to enable automatic signing for a specific time duration. This function grants the application to call the following methods until the timestamp expires. Standard methods likeeth_signTrancactionremain untouched.", "Application and Wallet Communication": "Sending RPC requests between application and wallet can be as usual. For example browser extension wallets can use these new methods easily. Even hardware wallets can implement this too. But for mobile wallets extra communication techniques should be considered. Because mobile wallets can be inactive when it is not in use.", "Rationale": "Games and Metaverse applications imply lots of cases when the user interacts with the wallet, switching to it and approving transactions. This switching aspect might interfere with gaming per se and create a bad user experience. That is why such applications can benefit if the wallets can support the Silent Signing functionality allowing transactions to be signed with no user interaction.", "Backwards Compatibility": "These new RPC methods don\u2019t interfere with the current ones, and for mobile wallets the push notifications API is currently a part of theWalletConnectspecification. Implementing the proposal\u2019s functionality changes nothing for other applications and wallets.", "Security Considerations": "The proposed feature aims to improve the user experience and can only be enabled with user consent. Users might freely choose to use the application as usual.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- silent signing extension: Adds JSON-RPC methods to enable silent signing of transactions without user interaction for a specified period, improving user experience for high-transaction applications like gaming.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5593, "url": "https://eips.ethereum.org/EIPS/eip-5593", "title": "Restrict Ethereum Provider API Injection", "authors": ["Yan Zhu\u00a0(", "@diracdeltas", ")", "Brian R. Bondy\u00a0(", "@bbondy", ")", "Andrea  Brancaleoni\u00a0(", "@thypon", ")", "Kyle Den Hartog\u00a0(", "@kdenhartog", ")"], "sections": {"EIP-5593: Restrict Ethereum Provider API Injection": "Historically the web platform has had a notion of \u201cpowerful\u201d APIs like those defined in W3C\u2019s Geolocation specification and W3C\u2019s Mediastreams specification, which are subject to additional security restrictions such as those defined by W3C\u2019s secure contexts specification. Since the Ethereum Provider APIs allow dApp websites to request access to sensitive user data and to request use of user funds, new Ethereum Provider APIs generally should align to the security considerations defined by W3C\u2019s Secure Context specification in order to better protect the users data and users funds managed via the web.", "Wallet guidance for restricting Ethereum Provider API access to secure contexts for improved privacy and security for wallet users.": "Historically the web platform has had a notion of \u201cpowerful\u201d APIs like those defined in W3C\u2019s Geolocation specification and W3C\u2019s Mediastreams specification, which are subject to additional security restrictions such as those defined by W3C\u2019s secure contexts specification. Since the Ethereum Provider APIs allow dApp websites to request access to sensitive user data and to request use of user funds, new Ethereum Provider APIs generally should align to the security considerations defined by W3C\u2019s Secure Context specification in order to better protect the users data and users funds managed via the web.", "Abstract": "Historically the web platform has had a notion of \u201cpowerful\u201d APIs like those defined in W3C\u2019s Geolocation specification and W3C\u2019s Mediastreams specification, which are subject to additional security restrictions such as those defined by W3C\u2019s secure contexts specification. Since the Ethereum Provider APIs allow dApp websites to request access to sensitive user data and to request use of user funds, new Ethereum Provider APIs generally should align to the security considerations defined by W3C\u2019s Secure Context specification in order to better protect the users data and users funds managed via the web.", "Author\u2019s Note": "Unfortunately, because of a difference in interpretations by EIP editors of RFC 2119 terminology around linking inEIP-1, the authors cannot directly link to other W3C specifications which this EIP builds upon. The author\u2019s attempted to provide as much context as possible within the text while complying with the editor bot in order to get this merged. If this policy is updated or further clarified before this EIP reaches final call in the future this EIP will be updated with links.", "Motivation": "Wallets are oftentimes maintaining security and safety of users\u2019 funds that can be equivalent to large portions of money. For this reason, it\u2019s a good idea to restrict access to the Ethereum Provider APIs to align it with other powerful APIs on the web platform. This will assist in reducing the surface area that attacks can be conducted to access users funds or data. Additionally, by adding in restrictions we\u2019re reducing the surface area that malicious web pages could fingerprint the user via the Ethereum Provider APIs providing some additional privacy benefits. An example of a specific attack that\u2019s avoided by this is one where a malicious advertisement is loaded on a legitimate dApp that attempts to interact with a users wallet to maliciously request the user to access funds. With this EIP implemented the advertisement frame would be considered a third-party iframe and therefore would not have the Ethereum Provider API injected into it\u2019s sub frame because it\u2019s not a secure context.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Restrictions for providers": "The provider objects, e.g.window.ethereum, are expected to only inject the Ethereum Provider APIs in secure context when conforming with this specification. The following restrictions are REQUIRED for conformant wallets:", "Rationale": "By limiting the capabilities of where the Ethereum Provider APIs are being injected we can reduce the surface area of where attacks can be executed. Given the sensitivity of data that\u2019s passed to the Ethereum Provider APIs some basic levels of authentication and confidentiality should be met in order to ensure that request data is not being intercepted or tampered with. While there have been attempts tolimit request access via the walletinterface itself, there have not been limitations that have been set to where these Ethereum Provider APIs are expected to be or not be injected. Since the secure contexts web platform API is a well developed boundary that\u2019s been recommended by W3C and the fact that the Ethereum Provider APIs are extending the traditional web platform APIs, no other alternative solutions have been considered in order to extend current established prior art.", "Backwards Compatibility": "Wallet extensions SHOULD consider adding a \u201cdeveloper mode\u201d toggle via a UX so that dApp developers have the capability to disable the insecure context (http) check for thehttp://localhost:<any-port>origin only in the event that localhost does not returntruefor secure context. See section 5.2 of W3C\u2019s Secure Context specification for more details. This will allow dApp developers to be able to continue to host dApps on the localhost origin if a User Agent has chosen to not already consider localhost a secure context. All major User Agent implementations tested do consider localhost a secure context already. This toggle MUST be set to disabled by default.", "Test Cases": "Oftentimes developers require the ability to develop dApps locally in order to test their website and develop while hosting their dApp onhttp://localhost. In this case localhost would be blocked and compatibility issues would arise when developing a dApp locally. In order to increase compatibility for dApp developers a toggle to disable the check for the localhost can be considered. If this were to be extended beyond the localhost origin it could be used as a means to convince users to enable developer mode in order to subvert the guards put in place by this EIP. Therefore, implementations should be cautious when extending this developer toggle beyond the scope of the localhost origin.", "Required Test Cases": "Oftentimes developers require the ability to develop dApps locally in order to test their website and develop while hosting their dApp onhttp://localhost. In this case localhost would be blocked and compatibility issues would arise when developing a dApp locally. In order to increase compatibility for dApp developers a toggle to disable the check for the localhost can be considered. If this were to be extended beyond the localhost origin it could be used as a means to convince users to enable developer mode in order to subvert the guards put in place by this EIP. Therefore, implementations should be cautious when extending this developer toggle beyond the scope of the localhost origin.", "Security Considerations": "Oftentimes developers require the ability to develop dApps locally in order to test their website and develop while hosting their dApp onhttp://localhost. In this case localhost would be blocked and compatibility issues would arise when developing a dApp locally. In order to increase compatibility for dApp developers a toggle to disable the check for the localhost can be considered. If this were to be extended beyond the localhost origin it could be used as a means to convince users to enable developer mode in order to subvert the guards put in place by this EIP. Therefore, implementations should be cautious when extending this developer toggle beyond the scope of the localhost origin.", "User Enables Developer Mode": "Oftentimes developers require the ability to develop dApps locally in order to test their website and develop while hosting their dApp onhttp://localhost. In this case localhost would be blocked and compatibility issues would arise when developing a dApp locally. In order to increase compatibility for dApp developers a toggle to disable the check for the localhost can be considered. If this were to be extended beyond the localhost origin it could be used as a means to convince users to enable developer mode in order to subvert the guards put in place by this EIP. Therefore, implementations should be cautious when extending this developer toggle beyond the scope of the localhost origin.", "Privacy Considerations": "Due to the nature of how the provider object is injected by default into most webpages, there\u2019s a risk that a malicious web page could utilize the provider object to fingerprint the user more precisely as a Web3 user. Implementers of this EIP are expected to consider the risks of injecting the Ethereum provider APIs into pages by default in order to consider what privacy characteristics they wish to enable for their users.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- restrict ethereum provider api injection: Provides guidance for wallets to restrict the injection of Ethereum Provider APIs (like window.ethereum) to secure contexts, improving user privacy and security.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6051, "url": "https://eips.ethereum.org/EIPS/eip-6051", "title": "Private Key Encapsulation", "authors": ["Base Labs\u00a0(", "@Base-Labs", ")", "Weiji Guo\u00a0(", "@weiji-cryptonatty", ")"], "sections": {"EIP-6051: Private Key Encapsulation": "This EIP proposes a mechanism to encapsulate a private key so that it could be securely relocated to another application without providing the seed. This EIP combinesECIES(Elliptic Curve Integrated Encryption Scheme) and optional signature verification under various choices to ensure that the private key is encapsulated for a known or trusted party.", "defines a specification for encapsulating private keys.": "This EIP proposes a mechanism to encapsulate a private key so that it could be securely relocated to another application without providing the seed. This EIP combinesECIES(Elliptic Curve Integrated Encryption Scheme) and optional signature verification under various choices to ensure that the private key is encapsulated for a known or trusted party.", "Abstract": "This EIP proposes a mechanism to encapsulate a private key so that it could be securely relocated to another application without providing the seed. This EIP combinesECIES(Elliptic Curve Integrated Encryption Scheme) and optional signature verification under various choices to ensure that the private key is encapsulated for a known or trusted party.", "Motivation": "There are various cases in which we might want to export one of many private keys from a much more secure but less convenient wallet, which is controlled with a seed or passphrase.", "Specification": "We hereby define:", "Sender and Recipient": "We hereby define:", "Core Algorithms": "The basic idea is to encapsulate the private key with ECIES. To ensure that the ephemeral public key to encapsulate the private key is indeed generated from a trusted party and has not been tampered with, we also provided an option to sign that ephemeral public key in this standard.", "Requests": "signerPubKeyis optional. If provided, it is assumed that the implementation has the corresponding private key and the implementation MUST sign the ephemeral public key (in the form of what is to be returned). The signature algorithm is determined by the curve part of theversionparameter, that is, ECDSA for secp256k1, and Ed25519 for Curve25519. And in this situation, it should be the case thatSendertrustssignerPubKey, no matter how this trust is maintained. If not, the next request WILL be rejected bySender Application. Also, seeSecurity Considerations.", "Options and Parameters": "Available elliptic curves are:", "Rationale": "A critical difference between thisEIP-6051withEIP-5630is that, as the purpose of key encapsulation is to transport a private key securely, the public key from the key recipient should be ephemeral, and mostly used only one-time. While in EIP-5630 settings, the public key of the message recipient shall be stable for a while so that message senders can encrypt messages without key discovery every time.", "Backwards Compatibility": "No backward compatibility issues for this new proposal.", "Interoperability": "To minimize potential compatibility issues among applications (including hardware wallets), this EIP requires that version secp256k1-AES-128-GCM MUST be supported.", "UX Recommendations": "saltand/oroobdata: both are inputs to the HKDF function (oobas \u201cinfo\u201d parameter). For better user experiences we suggest to require from users only one of them but this is up to the implementation.", "Test Cases": "For review purposes, the program to generate the test vectors is open-sourced and provided in the corresponding discussion thread.", "Data Fixation": "Throughout the test cases, we fix values for the below data:", "Case 1": "Useversionassecp256k1-AES-128-GCM.R1is provided as:", "Case 2": "Useversionassecp256k1-AES-256-GCM. The calculated symmetric keyskey,IV, andcipherwill be different.R1is provided as:", "Case 3": "Useversionas:Curve-25519-Chacha20-Poly1305.R1is provided as:", "Security Considerations": "PFS is achieved by using ephemeral key pairs on both sides.", "Perfect Forward Secrecy": "PFS is achieved by using ephemeral key pairs on both sides.", "Optional Signature and Trusted Public Keys": "Rcould be signed so thatSender Applicationcan verify ifRcould be trusted or not. This involves both signature verification and if the signer could be trusted or not. While signature verification is quite straightforward in itself, the latter should be managed with care. To facilitate this trust management issue,signerPubKeycould be further signed, creating a dual-layer trust structure:", "Security Level": "AES-128, AES-256, and ChaCha20 are provided.", "Randomness": "randsmust be generated with a cryptographic secure random number generator (CSRNG).", "Out of Band Data": "oobdata is optional. When non-empty, its content is digits or an alpha-numeric string from the user.Sender Applicationmay mandateoobfrom the user.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- private key encapsulation: Defines a method to securely transfer private keys using ECIES encryption, allowing private keys to be moved between applications without exposing the seed.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6789, "url": "https://eips.ethereum.org/EIPS/eip-6789", "title": "Rename gas to mana", "authors": ["Pascal Caversaccio\u00a0(", "@pcaversaccio", ")"], "sections": {"EIP-6789: Rename gas to mana": "This EIP suggests renaminggastomana, as proposed by Vitalik Buterin in 2015.", "This EIP suggests renaming gas to mana, as proposed by Vitalik Buterin in 2015": "This EIP suggests renaminggastomana, as proposed by Vitalik Buterin in 2015.", "Abstract": "This EIP suggests renaminggastomana, as proposed by Vitalik Buterin in 2015.", "Motivation": "The underlying motivation for reviving Vitalik\u2019s original proposal from 2015 is that we have finally arrived at the age of Proof-of-Stake, and given the roadmap ahead (i.e. \u201cThe Surge\u201d, \u201cThe Scourge\u201d, \u201cThe Verge\u201d, \u201cThe Purge\u201d, and \u201cThe Splurge\u201d), I consider this moment as the last opportunity to make such a far-reaching semantic change.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "This proposal is not backward compatible as it renames the core termgas.", "Backwards Compatibility": "This proposal is not backward compatible as it renames the core termgas.", "Test Cases": "If a transaction requires moremanathan allowed by themanaLimit, it is reverted as anout-of-manatransaction.", "Example 1": "If a transaction requires moremanathan allowed by themanaLimit, it is reverted as anout-of-manatransaction.", "Example 2": "A Solidity contract to estimate the usedmanavia the newmanaleft()syntax (replacinggasleft()) for dedicated function calls.", "Example 3": "An example of how to set themanaLimitin MetaMask:", "Security Considerations": "There are no security considerations directly related to the renaming ofgastomana.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- rename gas to mana: Renames \"gas\" to \"mana\" across the Ethereum ecosystem to reflect the environmental friendliness of Proof-of-Stake and better represent the concept of resource use.\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7039, "url": "https://eips.ethereum.org/EIPS/eip-7039", "title": "Scheme-Handler Discovery Option for Wallets", "authors": ["Sam Wilson\u00a0(", "@SamWilsn", ")"], "sections": {"EIP-7039: Scheme-Handler Discovery Option for Wallets": "This proposal (affectionately known as SHADOW) is an alternative toEIP-1193for wallet discovery in web browsers that requires no special permissions. Web pages intending to open a connection to a wallet inject aniframetag pointing at a well-known scheme. Communication between the page and the wallet uses thepostMessageAPI.", "Using custom protocol handlers to initiate connections between web pages and wallets.": "This proposal (affectionately known as SHADOW) is an alternative toEIP-1193for wallet discovery in web browsers that requires no special permissions. Web pages intending to open a connection to a wallet inject aniframetag pointing at a well-known scheme. Communication between the page and the wallet uses thepostMessageAPI.", "Abstract": "This proposal (affectionately known as SHADOW) is an alternative toEIP-1193for wallet discovery in web browsers that requires no special permissions. Web pages intending to open a connection to a wallet inject aniframetag pointing at a well-known scheme. Communication between the page and the wallet uses thepostMessageAPI.", "Motivation": "Current wallet discovery methods (eg.window.ethereum) only support one active wallet at a time, and require browser extensions to request broad permissions to modify web pages.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Initiating a Connection": "To initiate a connection to a provider, a web page SHOULD:", "Communicating on an Established Connection": "The web page and wallet MAY make requests of the other. The party making the request is known as the requester, and the replying party is known as the responder.", "Icon Images": "Instead of directly using theiframe.contentWindow\u2019s message port, SHADOW transfers a message port in the first message. This allows theiframe, in some specific scenarios, to completely hand off communication, so the web page and the provider communicate directly, without any proxying in theiframe.", "Rationale": "Instead of directly using theiframe.contentWindow\u2019s message port, SHADOW transfers a message port in the first message. This allows theiframe, in some specific scenarios, to completely hand off communication, so the web page and the provider communicate directly, without any proxying in theiframe.", "Backwards Compatibility": "While not backwards compatible with EIP-1193, this proposal uses extremely similar data structures to make the transition as painless as possible.", "Security Considerations": "Both providers and web pages MUST verify the origin of messages before trusting them.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7713, "url": "https://eips.ethereum.org/EIPS/eip-7713", "title": "Box type for EIP-712 messages", "authors": ["Francisco Giordano\u00a0(", "@frangio", ")"], "sections": {"EIP-7713: Box type for EIP-712 messages": "This EIP defines a new typeboxfor use inEIP-712messages. Aboxvalue is a value of an arbitrary struct type whose underlying type is encapsulated and hidden from the outer struct but transparent and type-checkable by the wallet, and thus able to be fully inspected by the user prior to signing. A verifying contract can be made agnostic to the underlying type of aboxvalue, but this type is not erased and can be verified on-chain if necessary.", "A mechanism for EIP-712 messages to contain parameters of arbitrary type": "This EIP defines a new typeboxfor use inEIP-712messages. Aboxvalue is a value of an arbitrary struct type whose underlying type is encapsulated and hidden from the outer struct but transparent and type-checkable by the wallet, and thus able to be fully inspected by the user prior to signing. A verifying contract can be made agnostic to the underlying type of aboxvalue, but this type is not erased and can be verified on-chain if necessary.", "Abstract": "This EIP defines a new typeboxfor use inEIP-712messages. Aboxvalue is a value of an arbitrary struct type whose underlying type is encapsulated and hidden from the outer struct but transparent and type-checkable by the wallet, and thus able to be fully inspected by the user prior to signing. A verifying contract can be made agnostic to the underlying type of aboxvalue, but this type is not erased and can be verified on-chain if necessary.", "Motivation": "EIP-712 signatures have become a widely used primitive for users to express and authorize intents off-chain. Wide-ranging applications are able to define parameterized messages for users to sign in their wallet through a general-purpose interface that clearly surfaces the type, parameters, and domain of authorization. This crucially applies to hardware wallets as a last line of defense.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Typed structured data": "A struct type may contain aboxed memberby declaring it with typebox. Example:", "encodeType": "A boxed member is encoded as\"box \" || name. For example, the aboveEnvelopestruct is encoded asEnvelope(address account,box contents).", "encodeData": "A boxed value is encoded as its underlyingunboxed value, i.e.,hashStruct(value) = keccak256(typeHash, encodeData(value))wheretypeHashcorresponds to the unboxed type andencodeDatais operating on a value of that type.", "signTypedDataschema": "A signature request for an EIP-712 message that involves a boxed member shall include the unboxed type as a part of the message object. A boxed value must be an object with propertiesvalue,primaryType, andtypes. Thevalueshall be type-checked and encoded according toprimaryTypeandtypes, analogously to an EIP-712 message (though without the\\x19prefix). Thetypesdefined in the message outside of the boxed value shall not be in scope for the encoding of a boxed value.", "Rationale": "TBD", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- box type for eip-712 messages: Introduces a box type for EIP-712 messages, allowing parameters of arbitrary struct types while ensuring wallets can display the underlying data to users.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2786, "url": "https://eips.ethereum.org/EIPS/eip-2786", "title": "Ethereum Provider Connect/Disconnect Events", "authors": ["Micah Zoltu\u00a0(", "@MicahZoltu", ")", "Erik Marks\u00a0(", "@rekmarks", ")"], "sections": {"EIP-2786: Ethereum Provider Connect/Disconnect Events": "When an Ethereum Provider becomes connected or disconnected, it will emit aconnect/disconnectevent.", "": "When an Ethereum Provider becomes connected or disconnected, it will emit aconnect/disconnectevent.", "Simple Summary": "When an Ethereum Provider becomes connected or disconnected, it will emit aconnect/disconnectevent.", "Abstract": "The Provider is said to be \u201cconnected\u201d when it can service RPC requests to at least one chain.\nThe Provider is said to be \u201cdisconnected\u201d when it cannot service RPC requests to any chain at all.\nWhen the Provider switches from a \u201cconnected\u201d state to a \u201cdisconnected\u201d state, it will emit aconnectevent.\nWhen the Provider switches from a \u201cdisconnected\u201d state to a \u201cconnected\u201d state, it will emit adisconnectevent.", "Motivation": "When an application is hooked up to an Ethereum provider, there is value in having the application be alerted of connect/disconnect events that may occur so the application can appropriately inform the user of the situation.\nIt is left up to the application to decide whether to listen in on these events, and how to handle them.", "Specification": "The Provider is consideredconnectedwhen it is able to service RPC requests to at least one chain.", "Definitions": "The Provider is consideredconnectedwhen it is able to service RPC requests to at least one chain.", "Events": "The ProviderMUSTemit aconnectevent to all attachedEIP-2700listeners if it transitions from adisconnectedstate to aconnectedstate.\nAll attached listenersMUSTbe called with the parameter{ chainId }.chainIdMUSTspecify the integer ID of the connected chain encoded as a hexadecimal string.\nIf the Provider supports theeth_chainIdJSON-RPC method or a derivation of it, then thechainIdMUSTmatch the return value ofeth_chainId.\nThe ProviderMAYcall the attached listeners in any order.", "Rationale": "This EIP is mostly a retrospective EIP meaning it codifies an already existing specification so there isn\u2019t a lot of room for improving things such as by having a connect/disconnect event per chain.", "Security Considerations": "The relationship between Ethereum Provider and client is a trusted one, where it is assumed that the user implicitly trusts the Ethereum Provider which is how it managed to get injected into the client, or the client expressly pulled in a connection to it.", "Copyright": "Copyright and related rights waived viaCC0.", "Appendix I: Examples": "Please cite this document as:", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- ethereum provider connect/disconnect events: Specifies connect and disconnect events for JavaScript Ethereum Providers to notify clients when the provider connects or disconnects from the network.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 20, "url": "https://eips.ethereum.org/EIPS/eip-20", "title": "Token Standard", "authors": ["Fabian Vogelsteller\u00a0<", "fabian@ethereum.org", ">", "Vitalik Buterin\u00a0<", "vitalik.buterin@ethereum.org", ">"], "sections": {"ERC-20: Token Standard": "A standard interface for tokens.", "": "A standard interface for tokens.", "Simple Summary": "A standard interface for tokens.", "Abstract": "The following standard allows for the implementation of a standard API for tokens within smart contracts.\nThis standard provides basic functionality to transfer tokens, as well as allow tokens to be approved so they can be spent by another on-chain third party.", "Motivation": "A standard interface allows any tokens on Ethereum to be re-used by other applications: from wallets to decentralized exchanges.", "Specification": "NOTES:", "Token": "NOTES:", "Methods": "NOTES:", "Events": "MUST trigger when tokens are transferred, including zero value transfers.", "Implementation": "There are already plenty of ERC20-compliant tokens deployed on the Ethereum network.\nDifferent implementations have been written by various teams that have different trade-offs: from gas saving to improved security.", "History": "Historical links related to this standard:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 55, "url": "https://eips.ethereum.org/EIPS/eip-55", "title": "Mixed-case checksum address encoding", "authors": ["Vitalik Buterin\u00a0<", "vitalik.buterin@ethereum.org", ">", "Alex Van de Sande\u00a0<", "avsa@ethereum.org", ">"], "sections": {"ERC-55: Mixed-case checksum address encoding": "Code:", "": "Code:", "Specification": "Code:", "Rationale": "Benefits:", "Implementation": "In javascript:", "Test Cases": "Please cite this document as:", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 137, "url": "https://eips.ethereum.org/EIPS/eip-137", "title": "Ethereum Domain Name Service - Specification", "authors": ["Nick Johnson\u00a0<", "arachnid@notdot.net", ">"], "sections": {"ERC-137: Ethereum Domain Name Service - Specification": "This draft EIP describes the details of the Ethereum Name Service, a proposed protocol and ABI definition that provides flexible resolution of short, human-readable names to service and resource identifiers. This permits users and developers to refer to human-readable and easy to remember names, and permits those names to be updated as necessary when the underlying resource (contract, content-addressed data, etc) changes.", "": "This draft EIP describes the details of the Ethereum Name Service, a proposed protocol and ABI definition that provides flexible resolution of short, human-readable names to service and resource identifiers. This permits users and developers to refer to human-readable and easy to remember names, and permits those names to be updated as necessary when the underlying resource (contract, content-addressed data, etc) changes.", "Abstract": "This draft EIP describes the details of the Ethereum Name Service, a proposed protocol and ABI definition that provides flexible resolution of short, human-readable names to service and resource identifiers. This permits users and developers to refer to human-readable and easy to remember names, and permits those names to be updated as necessary when the underlying resource (contract, content-addressed data, etc) changes.", "Motivation": "Existingspecificationsandimplementationsfor name resolution in Ethereum provide basic functionality, but suffer several shortcomings that will significantly limit their long-term usefulness:", "Specification": "The ENS system comprises three main parts:", "Overview": "The ENS system comprises three main parts:", "Name Syntax": "ENS names must conform to the following syntax:", "namehash algorithm": "Before being used in ENS, names are hashed using the \u2018namehash\u2019 algorithm. This algorithm recursively hashes components of the name, producing a unique, fixed-length string for any valid input domain. The output of namehash is referred to as a \u2018node\u2019.", "Registry specification": "The ENS registry contract exposes the following functions:", "Resolver specification": "Resolvers may implement any subset of the record types specified here. Where a record types specification requires a resolver to provide multiple functions, the resolver MUST implement either all or none of them. Resolvers MUST specify a fallback function that throws.", "Contract Address Interface": "Resolvers wishing to support contract address resources must provide the following function:", "Appendix A: Registry Implementation": "The simplest possible resolver is a contract that acts as its own name resolver by implementing the contract address resource profile:", "Appendix B: Sample Resolver Implementations": "The simplest possible resolver is a contract that acts as its own name resolver by implementing the contract address resource profile:", "Built-in resolver": "The simplest possible resolver is a contract that acts as its own name resolver by implementing the contract address resource profile:", "Standalone resolver": "A basic resolver that implements the contract address profile, and allows only its owner to update records:", "Public resolver": "Similar to the resolver above, this contract only supports the contract address profile, but uses the ENS registry to determine who should be allowed to update entries:", "Appendix C: Sample Registrar Implementation": "This registrar allows users to register names at no cost if they are the first to request them.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 162, "url": "https://eips.ethereum.org/EIPS/eip-162", "title": "Initial ENS Hash Registrar", "authors": ["Maurelian", "Nick Johnson\u00a0<", "nick@ethereum.org", ">", "Alex Van de Sande\u00a0<", "avsa@ethereum.org", ">"], "sections": {"ERC-162: Initial ENS Hash Registrar": "This ERC describes the implementation, as deployed to the main ethereum network on 2017-05-04, of a registrar contract to govern the allocation of names in the Ethereum Name Service (ENS). The corresponding source code ishere.", "": "This ERC describes the implementation, as deployed to the main ethereum network on 2017-05-04, of a registrar contract to govern the allocation of names in the Ethereum Name Service (ENS). The corresponding source code ishere.", "Contents": "This ERC describes the implementation, as deployed to the main ethereum network on 2017-05-04, of a registrar contract to govern the allocation of names in the Ethereum Name Service (ENS). The corresponding source code ishere.", "Abstract": "This ERC describes the implementation, as deployed to the main ethereum network on 2017-05-04, of a registrar contract to govern the allocation of names in the Ethereum Name Service (ENS). The corresponding source code ishere.", "Motivations": "The following factors should be considered in order to optimize for adoption of the ENS, and good governance of the Initial Registrar\u2019s namespace.", "Specification": "The Initial Registrar is expected to be in service for approximately two years, prior to upgrading. This should be sufficient time to learn, observe, and design an updated system.", "Initial restrictions": "The Initial Registrar is expected to be in service for approximately two years, prior to upgrading. This should be sufficient time to learn, observe, and design an updated system.", "Name format for hash registration": "Names submitted to the initial registrar must be hashed using Ethereum\u2019s sha3 function. Note that the hashes submitted to the registrar are the hash of the subdomain label being registered, not the namehash as defined in EIP 137.", "Auctioning names": "The registrar will allocate the available names through a Vickrey auction:", "Deeds": "The Initial Registrar contract does not hold a balance itself. All ether sent to the Registrar will be held in a separateDeedcontracts. A deed contract is first created and funded when a sealed bid is submitted. After an auction is completed and a hash is registered, the deed for the winning bid is held in exchange for ownership of the hash. Non-winning bids are refunded.", "Deployment and Upgrade process": "The Initial Registrar requires the ENS\u2019s address as a constructor, and should be deployed after the ENS. The multisig account owning the root node in the ENS should then set the Initial Registrar\u2019s address as owner of theethnode.", "Planned deactivation": "In order to limit dependence on the Initial Registrar, new auctions will stop after 4 years, and all ether held in deeds after 8 years will become unreachable.", "Registrar Interface": "function state(bytes32 _hash) constant returns (Mode)", "Rationale": "Anticipating and designing for all the potential issues of name allocation names is unlikely to succeed. This approach chooses not to be concerned with getting it perfect, but allows us to observe and learn with training wheels on, and implement improvements before expanding the available namespace to shorter names or another TLD.", "Starting with a temporary registrar": "Anticipating and designing for all the potential issues of name allocation names is unlikely to succeed. This approach chooses not to be concerned with getting it perfect, but allows us to observe and learn with training wheels on, and implement improvements before expanding the available namespace to shorter names or another TLD.", "Valid names >= 7 characters": "Preserving the shortest, and often most valuable, domain names for the upgraded registrar provides the opportunity to implement processes for dispute resolution (assuming they are found to be necessary).", "Delayed release of names": "A slower release allows for extra time to identify, and address any issues which may arise after launch.", "Restricting TLD to.eth": "Choosing a single TLD helps to maximize network effects by focusing on one namespace.", "Holding ether as collateral": "This approach is simpler than the familiar model of requiring owners to make recurring payments to retain ownership of a domain name. It also makes the initial registrar a revenue neutral service.", "Prior work": "This document borrows heavily from several sources:", "Edits:": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 165, "url": "https://eips.ethereum.org/EIPS/eip-165", "title": "Standard Interface Detection", "authors": ["Christian Reitwie\u00dfner\u00a0<", "chris@ethereum.org", ">", "Nick Johnson\u00a0<", "nick@ethereum.org", ">", "Fabian Vogelsteller\u00a0<", "fabian@lukso.network", ">", "Jordi Baylina\u00a0<", "jordi@baylina.cat", ">", "Konrad Feldmeier\u00a0<", "konrad.feldmeier@brainbot.com", ">", "William Entriken\u00a0<", "github.com@phor.net", ">"], "sections": {"ERC-165: Standard Interface Detection": "Creates a standard method to publish and detect what interfaces a smart contract implements.", "": "Creates a standard method to publish and detect what interfaces a smart contract implements.", "Simple Summary": "Creates a standard method to publish and detect what interfaces a smart contract implements.", "Abstract": "Herein, we standardize the following:", "Motivation": "For some \u201cstandard interfaces\u201d likethe ERC-20 token interface, it is sometimes useful to query whether a contract supports the interface and if yes, which version of the interface, in order to adapt the way in which the contract is to be interacted with. Specifically for ERC-20, a version identifier has already been proposed. This proposal standardizes the concept of interfaces and standardizes the identification (naming) of interfaces.", "Specification": "For this standard, aninterfaceis a set offunction selectors as defined by the Ethereum ABI. This a subset ofSolidity\u2019s concept of interfacesand theinterfacekeyword definition which also defines return types, mutability and events.", "How Interfaces are Identified": "For this standard, aninterfaceis a set offunction selectors as defined by the Ethereum ABI. This a subset ofSolidity\u2019s concept of interfacesand theinterfacekeyword definition which also defines return types, mutability and events.", "How a Contract will Publish the Interfaces it Implements": "A contract that is compliant with ERC-165 shall implement the following interface (referred asERC165.sol):", "How to Detect if a Contract Implements ERC-165": "We tried to keep this specification as simple as possible. This implementation is also compatible with the current Solidity version.", "How to Detect if a Contract Implements any Given Interface": "We tried to keep this specification as simple as possible. This implementation is also compatible with the current Solidity version.", "Rationale": "We tried to keep this specification as simple as possible. This implementation is also compatible with the current Solidity version.", "Backwards Compatibility": "The mechanism described above (with0xffffffff) should work with most of the contracts previous to this standard to determine that they do not implement ERC-165.", "Test Cases": "Following is a contract that detects which interfaces other contracts implement. From @fulldecent and @jbaylina.", "Implementation": "This approach uses aviewfunction implementation ofsupportsInterface. The execution cost is 586 gas for any input. But contract initialization requires storing each interface (SSTOREis 20,000 gas). TheERC165MappingImplementationcontract is generic and reusable.", "Version history": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 173, "url": "https://eips.ethereum.org/EIPS/eip-173", "title": "Contract Ownership Standard", "authors": ["Nick Mudge\u00a0(", "@mudgen", ")", "Dan Finlay\u00a0<", "dan@danfinlay.com", ">"], "sections": {"ERC-173: Contract Ownership Standard": "This specification defines standard functions for owning or controlling a contract.", "A standard interface for ownership of contracts": "This specification defines standard functions for owning or controlling a contract.", "Abstract": "This specification defines standard functions for owning or controlling a contract.", "Motivation": "Many smart contracts require that they be owned or controlled in some way. For example to withdraw funds or perform administrative actions. It is so common that the contract interface used to handle contract ownership should be standardized to allow compatibility with user interfaces and contracts that manage contracts.", "Specification": "Every ERC-173 compliant contract must implement theERC173interface. Contracts should also implementERC165for the ERC-173 interface.", "Rationale": "Key factors influencing the standard:", "Security Considerations": "If the address returned byowner()is an externally owned account then its private key must not be lost or compromised.", "Backwards Compatibility": "Many existing contracts already implement this standard.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 181, "url": "https://eips.ethereum.org/EIPS/eip-181", "title": "ENS support for reverse resolution of Ethereum addresses", "authors": ["Nick Johnson\u00a0<", "arachnid@notdot.net", ">"], "sections": {"ERC-181: ENS support for reverse resolution of Ethereum addresses": "This EIP specifies a TLD, registrar, and resolver interface for reverse resolution of Ethereum addresses using ENS. This permits associating a human-readable name with any Ethereum blockchain address. Resolvers can be certain that the reverse record was published by the owner of the Ethereum address in question.", "": "This EIP specifies a TLD, registrar, and resolver interface for reverse resolution of Ethereum addresses using ENS. This permits associating a human-readable name with any Ethereum blockchain address. Resolvers can be certain that the reverse record was published by the owner of the Ethereum address in question.", "Abstract": "This EIP specifies a TLD, registrar, and resolver interface for reverse resolution of Ethereum addresses using ENS. This permits associating a human-readable name with any Ethereum blockchain address. Resolvers can be certain that the reverse record was published by the owner of the Ethereum address in question.", "Motivation": "While name services are mostly used for forward resolution - going from human-readable identifiers to machine-readable ones - there are many use-cases in which reverse resolution is useful as well:", "Specification": "Reverse ENS records are stored in the ENS hierarchy in the same fashion as regular records, under a reserved domain,addr.reverse. To generate the ENS name for a given account\u2019s reverse records, convert the account to hexadecimal representation in lower-case, and appendaddr.reverse. For instance, the ENS registry\u2019s address at0x112234455c3a32fd11230c42e7bccd4a84e02010has any reverse records stored at112234455c3a32fd11230c42e7bccd4a84e02010.addr.reverse.", "Registrar": "The owner of theaddr.reversedomain will be a registrar that permits the caller to take ownership of \nthe reverse record for their own address. It provides the following methods:", "function claim(address owner) returns (bytes32 node)": "When called by accountx, instructs the ENS registry to transfer ownership of the namehex(x) + '.addr.reverse'to the provided address, and return the namehash of the ENS record thus transferred.", "function claimWithResolver(address owner, address resolver) returns (bytes32 node)": "When called by accountx, instructs the ENS registry to set the resolver of the namehex(x) + '.addr.reverse'to the specified resolver, then transfer ownership of the name to the provided address, and return the namehash of the ENS record thus transferred. This method facilitates setting up a custom resolver and owner in fewer transactions than would be required if callingclaim.", "function setName(string name) returns (bytes32 node)": "When called by accountx, sets the resolver for the namehex(x) + '.addr.reverse'to a default resolver, and sets the name record on that name to the specified name. This method facilitates setting up simple reverse records for users in a single transaction.", "Resolver interface": "A new resolver interface is defined, consisting of the following method:", "Appendix 1: Registrar implementation": "This registrar, written in Solidity, implements the specifications outlined above.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 190, "url": "https://eips.ethereum.org/EIPS/eip-190", "title": "Ethereum Smart Contract Packaging Standard", "authors": ["Piper Merriam\u00a0(", "@pipermerriam", ")", "Tim Coulter\u00a0(", "@tcoulter", ")", "Denis Erfurt\u00a0(", "@mhhf", ")", "RJ Catalano\u00a0(", "@VoR0220", ")", "Iuri Matias\u00a0(", "@iurimatias", ")"], "sections": {"ERC-190: Ethereum Smart Contract Packaging Standard": "This ERC proposes a specification for Ethereum smart contract packages.", "": "This ERC proposes a specification for Ethereum smart contract packages.", "Abstract": "This ERC proposes a specification for Ethereum smart contract packages.", "Motivation": "Packaging is a core piece of modern software development which is missing from the Ethereum ecosystem.  The lack of packaging limits the ability for developers to reuse code which negatively affects productivity and security.", "Specification": "The full specification for this standard is maintained separately in the repositoryepm/epm-spec.", "Use Cases": "This specification covers the following types of smart contract packages.", "Package Managers": "TheRelease Lockfileis intended for consumption by package management software.  Specific care was made to ensure that all of the following functionality can be implemented by package managers.", "Deterministic builds": "Ensures that a package will always resolve to the same set of dependencies and source files.  Both source files and dependencies are content addressed to ensure that the referenced resources cannot change.", "Bytecode verification": "Contains the appropriate information for a package manager to inspect a deployed contract and verify that its bytecode matches the bytecode that results from compilation and linking of the package source code.", "Multi-chain deploys": "Supports deployments across multiple chains, allowing a package to define addresses on both the public mainnet and testnet.", "Trusted packages": "Allows for packages which exclude source code or other elements which would be needed for verification of the contract bytecode.  This allows for minimalistic packages to be created for special situations where the package manager will not be performing verification.", "Framework support and integration": "Support for ERC190 is either implemented or in progress for the following:", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 191, "url": "https://eips.ethereum.org/EIPS/eip-191", "title": "Signed Data Standard", "authors": ["Martin Holst Swende\u00a0(", "@holiman", ")", "Nick Johnson\u00a0<", "arachnid@notdot.net", ">"], "sections": {"ERC-191: Signed Data Standard": "This ERC proposes a specification about how to handle signed data in Ethereum contracts.", "": "This ERC proposes a specification about how to handle signed data in Ethereum contracts.", "Abstract": "This ERC proposes a specification about how to handle signed data in Ethereum contracts.", "Motivation": "Several multisignature wallet implementations have been created which acceptspresignedtransactions. Apresignedtransaction is a chunk of binarysigned_data, along with signature (r,sandv). The interpretation of thesigned_datahas not been specified, leading to several problems:", "Specification": "We propose the following format forsigned_data", "Registry of version bytes": "The version0x00has<intended validator address>for the version specific data. In the case of a Multisig wallet that perform an execution based on a passed signature, the validator address is the address of the Multisig itself. The data to sign could be any arbitrary data.", "Example": "The following snippets has been written in Solidity 0.8.0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 223, "url": "https://eips.ethereum.org/EIPS/eip-223", "title": "Token with transaction handling model", "authors": ["Dexaran (@Dexaran)\u00a0<", "dexaran@ethereumclassic.org", ">"], "sections": {"ERC-223: Token with transaction handling model": "The following describes an interface and logic for fungible tokens that supports atokenReceivedcallback to notify contract recipients when tokens are received. This makes tokens behave identical to ether.", "Token with transaction handling model designed to behave identical to native currency (ether)": "The following describes an interface and logic for fungible tokens that supports atokenReceivedcallback to notify contract recipients when tokens are received. This makes tokens behave identical to ether.", "Abstract": "The following describes an interface and logic for fungible tokens that supports atokenReceivedcallback to notify contract recipients when tokens are received. This makes tokens behave identical to ether.", "Motivation": "This token introduces a communication model for contracts that can be utilized to straighten the behavior of contracts that interact with such tokens. Specifically, this proposal:", "Specification": "Contracts intending to receive these tokens MUST implementtokenReceived.", "Token contract": "Returns the total supply of the token. The functionality of this method is identical to that of ERC-20.", "ERC-223Token Receiver": "A function for handling token transfers, which is called from the token contract, when a token holder sends tokens._fromis the address of the sender of the token,_valueis the amount of incoming tokens, and_datais attached data similar tomsg.dataof ether transactions. It works by analogy with the fallback function of Ether transactions and returns nothing.", "Rationale": "This standard introduces a communication model by enforcing thetransferto execute a handler function in the destination address. This is an important security consideration as it is required that the receiver explicitly implements the token handling function. In cases where the receiver does not implements such function the transfer MUST be reverted.", "Backwards Compatibility": "The interface of this token is similar to that of ERC-20 and most functions serve the same purpose as their analogues in ERC-20.transfer(address, uint256, bytes calldata)function is not backwards compatible with ERC-20 interface.", "Security Considerations": "This token utilizes the model similar to plain ether behavior. Therefore replay issues must be taken into account.", "Reference Implementation": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 600, "url": "https://eips.ethereum.org/EIPS/eip-600", "title": "Ethereum purpose allocation for Deterministic Wallets", "authors": ["Nick Johnson\u00a0(", "@arachnid", ")", "Micah Zoltu\u00a0(", "@micahzoltu", ")"], "sections": {"ERC-600: Ethereum purpose allocation for Deterministic Wallets": "This EIP defines a logical hierarchy for deterministic wallets based onBIP32, the purpose scheme defined inBIP43andthis proposed change to BIP43.", "": "This EIP defines a logical hierarchy for deterministic wallets based onBIP32, the purpose scheme defined inBIP43andthis proposed change to BIP43.", "Abstract": "This EIP defines a logical hierarchy for deterministic wallets based onBIP32, the purpose scheme defined inBIP43andthis proposed change to BIP43.", "Motivation": "Because Ethereum is based on account balances rather than UTXO, the hierarchy defined by BIP44 is poorly suited. As a result, several competing derivation path strategies have sprung up for deterministic wallets, resulting in inter-client incompatibility. This BIP seeks to provide a path to standardise this in a fashion better suited to Ethereum\u2019s unique requirements.", "Specification": "We define the following 2 levels in BIP32 path:", "Purpose": "Purpose is set to 43, as documented inthis proposed change to BIP43.", "Subpurpose": "Subpurpose is set to 60, the SLIP-44 code for Ethereum.", "EIP": "EIP is set to the EIP number specifying the remainder of the BIP32 derivation path. This permits new Ethereum-focused applications of deterministic wallets without needing to interface with the BIP process.", "Rationale": "The existing convention is to use the \u2018Ethereum\u2019 coin type, leading to paths starting withm/44'/60'/*. Because this still assumes a UTXO-based coin, we contend that this is a poor fit, resulting in standardisation, usability, and security compromises. As a result, we are making the above proposal to define an entirely new hierarchy for Ethereum-based chains.", "Backwards Compatibility": "The introduction of another derivation path requires existing software to add support for this scheme in addition to any existing schemes. Given the already confused nature of wallet derivation paths in Ethereum, we anticipate this will cause relatively little additional disruption, and has the potential to improve matters significantly in the long run.", "Test Cases": "TBD", "Implementation": "None yet.", "References": "This discussion on derivation paths", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 601, "url": "https://eips.ethereum.org/EIPS/eip-601", "title": "Ethereum hierarchy for deterministic wallets", "authors": ["Nick Johnson\u00a0(", "@arachnid", ")", "Micah Zoltu\u00a0(", "@micahzoltu", ")"], "sections": {"ERC-601: Ethereum hierarchy for deterministic wallets": "This EIP defines a logical hierarchy for deterministic wallets based onBIP32, the purpose scheme defined inBIP43and eip-draft-ethereum-purpose.", "": "This EIP defines a logical hierarchy for deterministic wallets based onBIP32, the purpose scheme defined inBIP43and eip-draft-ethereum-purpose.", "Abstract": "This EIP defines a logical hierarchy for deterministic wallets based onBIP32, the purpose scheme defined inBIP43and eip-draft-ethereum-purpose.", "Motivation": "At present, different Ethereum clients and wallets use different derivation paths; a summary of them can be foundhere. Some of these paths violate BIP44, the standard defining derivation paths starting withm/44'/. This creates confusion and incompatibility between wallet implementations, in some cases making funds from one wallet inaccessible on another, and in others requiring prompting users manually for a derivation path, which hinders usability.", "Specification": "We define the following 4 levels in BIP32 path:", "Purpose": "Purpose is a constant set to 43, indicating the key derivation is for a non-bitcoin cryptocurrency.", "Subpurpose": "Subpurpose is set to 60, the SLIP-44 code for Ethereum.", "EIP": "EIP is set to the EIP number specifying the remainder of the BIP32 derivation path. For paths following this EIP specification, the number assigned to this EIP is used.", "Wallet": "This component of the path splits the wallet into different user identities, allowing a single wallet to have multiple public identities.", "Rationale": "The existing convention is to use the \u2018Ethereum\u2019 coin type, leading to paths starting withm/44'/60'/*. Because this still assumes a UTXO-based coin, we contend that this is a poor fit, resulting in standardisation, usability, and security compromises. As a result, we are making the above proposal to define an entirely new hierarchy for Ethereum-based chains.", "Backwards Compatibility": "The introduction of another derivation path requires existing software to add support for this scheme in addition to any existing schemes. Given the already confused nature of wallet derivation paths in Ethereum, we anticipate this will cause relatively little additional disruption, and has the potential to improve matters significantly in the long run.", "Test Cases": "TBD", "Implementation": "None yet.", "References": "This discussion on derivation paths", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 681, "url": "https://eips.ethereum.org/EIPS/eip-681", "title": "URL Format for Transaction Requests", "authors": ["Daniel A. Nagy\u00a0(", "@nagydani", ")"], "sections": {"ERC-681: URL Format for Transaction Requests": "A standard way of representing various transactions, especially payment requests in ether andERC-20tokens as URLs.", "": "A standard way of representing various transactions, especially payment requests in ether andERC-20tokens as URLs.", "Simple Summary": "A standard way of representing various transactions, especially payment requests in ether andERC-20tokens as URLs.", "Abstract": "URLs embedded in QR-codes, hyperlinks in web-pages, emails or chat messages provide for robust cross-application signaling between very loosely coupled applications. A standardized URL format for payment requests allows for instant invocation of the user\u2019s preferred wallet application (even if it is a webapp or a swarm \u0111app), with the correct parameterization of the payment transaction only to be confirmed by the (authenticated) user.", "Motivation": "The convenience of representing payment requests by standard URLs has been a major factor in the wide adoption of Bitcoin. Bringing a similarly convenient mechanism to Ethereum would speed up its acceptance as a payment platform among end-users. In particular, URLs embedded in broadcast Intents are the preferred way of launching applications on the Android operating system and work across practically all applications. Desktop web browsers have a standardized way of defining protocol handlers for URLs with specific protocol specifications. Other desktop applications typically launch the web browser upon encountering a URL. Thus, payment request URLs could be delivered through a very broad, ever growing selection of channels.", "Specification": "Payment request URLs contain \u201cethereum\u201d in their schema (protocol) part and are constructed as follows:", "Syntax": "Payment request URLs contain \u201cethereum\u201d in their schema (protocol) part and are constructed as follows:", "Semantics": "target_addressis mandatory and denotes either the beneficiary of native token payment (see below) or the contract address with which the user is asked to interact.", "Rationale": "The proposed format is chosen to resemblebitcoin:URLs as closely as possible, as both users and application programmers are already familiar with that format. In particular, this motivated the omission of the unit, which is often used in Ethereum ecosystem. Handling different orders of magnitude is facilitated by the exponent so that amount values can be expressed in their nominal units, just like in the case ofbitcoin:. The use of scientific notation is strongly encouraged when expressing monetary value in ether orERC-20tokens. For better human readability, the exponent should be the decimal value of the nominal unit: 18 for ether or the value returned bydecimals()of the token contract forERC-20tokens. Additional parameters may be added, if popular use cases requiring them emerge in practice.", "Backwards Compatibility": "In the fairly common case of only indicating the recipient address in a request for payment in ether, this specification is compatible with the superseded ERC-67.", "Security Considerations": "Since irreversible transactions can be initiated with parameters from such URLs, the integrity and authenticity of these URLs are of great importance.\nIn particular, changing either the recipient address or the amount transferred can be a profitable attack. Users should only use URLs received from authenticated sources with adequate integrity protection.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 721, "url": "https://eips.ethereum.org/EIPS/eip-721", "title": "Non-Fungible Token Standard", "authors": ["William Entriken\u00a0(", "@fulldecent", ")", "Dieter Shirley\u00a0<", "dete@axiomzen.co", ">", "Jacob Evans\u00a0<", "jacob@dekz.net", ">", "Nastassia Sachs\u00a0<", "nastassia.sachs@protonmail.com", ">"], "sections": {"ERC-721: Non-Fungible Token Standard": "A standard interface for non-fungible tokens, also known as deeds.", "": "A standard interface for non-fungible tokens, also known as deeds.", "Simple Summary": "A standard interface for non-fungible tokens, also known as deeds.", "Abstract": "The following standard allows for the implementation of a standard API for NFTs within smart contracts. This standard provides basic functionality to track and transfer NFTs.", "Motivation": "A standard interface allows wallet/broker/auction applications to work with any NFT on Ethereum. We provide for simple ERC-721 smart contracts as well as contracts that track anarbitrarily largenumber of NFTs. Additional applications are discussed below.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Caveats": "The 0.4.20 Solidity interface grammar is not expressive enough to document the ERC-721 standard. A contract which complies with ERC-721 MUST also abide by the following:", "Rationale": "There are many proposed uses of Ethereum smart contracts that depend on tracking distinguishable assets. Examples of existing or planned NFTs are LAND in Decentraland, the eponymous punks in CryptoPunks, and in-game items using systems like DMarket or EnjinCoin. Future uses include tracking real-world assets, like real-estate (as envisioned by companies like Ubitquity or Propy). It is critical in each of these cases that these items are not \u201clumped together\u201d as numbers in a ledger, but instead each asset must have its ownership individually and atomically tracked. Regardless of the nature of these assets, the ecosystem will be stronger if we have a standardized interface that allows for cross-functional asset management and sales platforms.", "Backwards Compatibility": "We have adoptedbalanceOf,totalSupply,nameandsymbolsemantics from the ERC-20 specification. An implementation may also include a functiondecimalsthat returnsuint8(0)if its goal is to be more compatible with ERC-20 while supporting this standard. However, we find it contrived to require all ERC-721 implementations to support thedecimalsfunction.", "Test Cases": "0xcert ERC-721 Token includes test cases written using Truffle.", "Implementations": "0xcert ERC721 \u2013 a reference implementation", "References": "Standards", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 777, "url": "https://eips.ethereum.org/EIPS/eip-777", "title": "Token Standard", "authors": ["Jacques Dafflon\u00a0<", "mail@0xjac.com", ">", "Jordi Baylina\u00a0<", "jordi@baylina.cat", ">", "Thomas Shababi\u00a0<", "tom@truelevel.io", ">"], "sections": {"ERC-777: Token Standard": "This EIP defines standard interfaces and behaviors for token contracts.", "": "This EIP defines standard interfaces and behaviors for token contracts.", "Simple Summary": "This EIP defines standard interfaces and behaviors for token contracts.", "Abstract": "This standard defines a new way to interact with a token contract while remaining backward compatible withERC-20.", "Motivation": "This standard tries to improve upon the widely usedERC-20token standard.\nThe main advantages of this standard are:", "Specification": "The token contract MUST implement the above interface.\nThe implementation MUST follow the specifications described below.", "ERC777Token (Token Contract)": "The token contract MUST implement the above interface.\nThe implementation MUST follow the specifications described below.", "Logo": "The logo MAY be used, modified and adapted to promote validERC-777token implementations\nandERC-777compliant technologies such as wallets and dapps.", "Rationale": "The principal intent for this standard is\nto solve some of the shortcomings ofERC-20while maintaining backward compatibility withERC-20,\nand avoiding the problems and vulnerabilities ofEIP-223.", "Lifecycle": "More than just sending tokens,ERC-777defines the entire lifecycle of a token,\nstarting with the minting process, followed by the sending process and terminating with the burn process.", "Data": "The mint, send and burn processes can all make use of adataandoperatorDatafields\nwhich are passed to any movement (mint, send or burn).\nThose fields may be empty for simple use cases,\nor they may contain valuable information related to the movement of tokens,\nsimilar to information attached to a bank transfer by the sender or the bank itself.", "Hooks": "In most cases,ERC-20requires two calls to safely transfer tokens to a contract without locking them.\nA call from the sender, using theapprovefunction\nand a call from the recipient usingtransferFrom.\nFurthermore, this requires extra communication between the parties which is not clearly defined.\nFinally, holders can get confused betweentransferandapprove/transferFrom.\nUsing the former to transfer tokens to a contract will most likely result in locked tokens.", "Operators": "The standard defines the concept of operators as any address which moves tokens.\nWhile intuitively every address moves its own tokens,\nseparating the concepts of holder and operator allows for greater flexibility.\nPrimarily, this originates from the fact that the standard defines a mechanism for holders\nto let other addresses become their operators.\nMoreover, unlike the approve calls inERC-20where the role of an approved address is not clearly defined,ERC-777details the intent of and interactions with operators,\nincluding an obligation for operators to be approved,\nand an irrevocable right for any holder to revoke operators.", "Backward Compatibility": "This EIP does not introduce backward incompatibilities and is backward compatible with the olderERC-20token standard.", "Test Cases": "Therepository with the reference implementationcontains all thetests.", "Implementation": "The GitHub repository0xjac/ERC777contains thereference implementation.\nThe reference implementation is also available vianpmand can be installed withnpm install erc777.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 820, "url": "https://eips.ethereum.org/EIPS/eip-820", "title": "Pseudo-introspection Registry Contract", "authors": ["Jordi Baylina\u00a0<", "jordi@baylina.cat", ">", "Jacques Dafflon\u00a0<", "jacques@dafflon.tech", ">"], "sections": {"ERC-820: Pseudo-introspection Registry Contract": "This standard defines a universal registry smart contract where any address (contract or regular account) can register which interface it supports and which smart contract is responsible for its implementation.", "": "This standard defines a universal registry smart contract where any address (contract or regular account) can register which interface it supports and which smart contract is responsible for its implementation.", "Simple Summary": "This standard defines a universal registry smart contract where any address (contract or regular account) can register which interface it supports and which smart contract is responsible for its implementation.", "Abstract": "This standard defines a registry where smart contracts and regular accounts can publish which functionalities they implement\u2014either directly or through a proxy contract.", "Motivation": "There have been different approaches to define pseudo-introspection in Ethereum. The first isERC-165which has the limitation that it cannot be used by regular accounts. The second attempt isERC-672which uses reverseENS. Using reverseENShas two issues. First, it is unnecessarily complicated, and second,ENSis still a centralized contract controlled by a multisig. This multisig theoretically would be able to modify the system.", "Specification": "Below is the raw transaction which MUST be used to deploy the smart contract on any chain.", "ERC-820Registry Smart Contract": "Below is the raw transaction which MUST be used to deploy the smart contract on any chain.", "Deployment Transaction": "Below is the raw transaction which MUST be used to deploy the smart contract on any chain.", "Deployment Method": "This contract is going to be deployed using the keyless deployment method\u2014also known asNick\u2019s method\u2014which relies on a single-use address. (SeeNick\u2019s articlefor more details). This method works as follows:", "Single-use Registry Deployment Account": "This account is generated by reverse engineering it from its signature for the transaction. This way no one knows the private key, but it is known that it is the valid signer of the deployment transaction.", "Registry Contract Address": "The contract has the address above for every chain on which it is deployed.", "Interface Name": "Any interface name is hashed usingkeccak256and sent togetInterfaceImplementer().", "Set An Interface For An Address": "For any address to set a contract as the interface implementation, it must call the following function of theERC-820registry:", "Get An Implementation Of An Interface For An Address": "Anyone MAY query theERC-820Registry to obtain the address of a contract implementing an interface on behalf of some address using thegetInterfaceImplementerfunction.", "Interface Implementation (ERC820ImplementerInterface)": "Any contract being registered as the implementation of an interface for a given address MUST implement said interface. In addition if it implements an interface on behalf of a different address, the contract MUST implement theERC820ImplementerInterfaceshown above.", "Manager": "The manager of an address (regular account or a contract) is the only entity allowed to register implementations of interfaces for the address. By default, any address is its own manager.", "Rationale": "This standards offers a way for any type of address (externally owned and contracts) to implement an interface and potentially delegate the implementation of the interface to a proxy contract. This delegation to a proxy contract is necessary for externally owned accounts and useful to avoid redeploying existing contracts such as multisigs and DAOs.", "Backward Compatibility": "This standard is backward compatible withERC-165, as both methods MAY be implemented without conflicting with each other.", "Test Cases": "Please check thejbaylina/ERC820repository for the full test suite.", "Implementation": "The implementation is available in the repo:jbaylina/ERC820.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1046, "url": "https://eips.ethereum.org/EIPS/eip-1046", "title": "tokenURI Interoperability", "authors": ["Tommy Nicholas\u00a0(", "@tomasienrbc", ")", "Matt Russo\u00a0(", "@mateosu", ")", "John Zettler\u00a0(", "@JohnZettler", ")", "Matt Condon\u00a0(", "@shrugs", ")", "Gavin John\u00a0(", "@Pandapip1", ")"], "sections": {"ERC-1046: tokenURI Interoperability": "ERC-721introduced atokenURIfunction for non-fungible tokens to handle miscellaneous metadata such as:", "Extends ERC-20 with an ERC-721-like tokenURI, and extends ERC-721 and ERC-1155 with interoperability": "ERC-721introduced atokenURIfunction for non-fungible tokens to handle miscellaneous metadata such as:", "Abstract": "ERC-721introduced atokenURIfunction for non-fungible tokens to handle miscellaneous metadata such as:", "Motivation": "See the note about the metadata extension inERC-721. The same arguments apply to ERC-20.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Interoperability Metadata": "The following TypeScript interface is used in later sections:", "ERC-20 Extension": "Compliant contracts MUST implement the following Solidity interface:", "ERC-721 Extension": "Contracts that implement ERC-721 and use its token metadata URI SHOULD to use the following TypeScript extension to the metadata URI:", "ERC-1155 Extension": "ERC-1155-compliant contracts using the metadata extension SHOULD implement the following Solidity interface:", "Miscellaneous Recommendations": "To save gas, it is RECOMMENDED for compliant contracts not to implement thename(),symbol(), ordecimals()functions, and instead to only include them in the metadata URI. Additionally, for ERC-20 tokens, if the decimals is18, then it is NOT RECOMMENDED to include thedecimalsfield in the metadata.", "Rationale": "This ERC makes adding metadata to ERC-20 tokens more straightforward for developers, with minimal to no disruption to the overall ecosystem. Using the same parameter name makes it easier to reuse code.", "Backwards Compatibility": "This EIP is fully backwards compatible as its implementation simply extends the functionality of ERC-20 tokens and is optional. Additionally, it makes backward compatible recommendations for ERC-721 and ERC-1155 tokens.", "Security Considerations": "Wallets should be careful about making arbitrary requests to URLs. As such, it is recommended for wallets to sanitize the URI by whitelisting specific schemes and ports. A vulnerable wallet could be tricked into, for example, modifying data on a locally-hosted redis database.", "Server-Side Request Forgery (SSRF)": "Wallets should be careful about making arbitrary requests to URLs. As such, it is recommended for wallets to sanitize the URI by whitelisting specific schemes and ports. A vulnerable wallet could be tricked into, for example, modifying data on a locally-hosted redis database.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1155, "url": "https://eips.ethereum.org/EIPS/eip-1155", "title": "Multi Token Standard", "authors": ["Witek Radomski\u00a0<", "witek@enjin.io", ">", "Andrew Cooke\u00a0<", "ac0dem0nk3y@gmail.com", ">", "Philippe Castonguay (@phabc)\u00a0<", "pc@horizongames.net", ">", "James Therien\u00a0<", "james@turing-complete.com", ">", "Eric Binet\u00a0<", "eric@enjin.io", ">", "Ronan Sandford (@wighawag)\u00a0<", "wighawag@gmail.com", ">"], "sections": {"ERC-1155: Multi Token Standard": "A standard interface for contracts that manage multiple token types. A single deployed contract may include any combination of fungible tokens, non-fungible tokens or other configurations (e.g. semi-fungible tokens).", "": "A standard interface for contracts that manage multiple token types. A single deployed contract may include any combination of fungible tokens, non-fungible tokens or other configurations (e.g. semi-fungible tokens).", "Simple Summary": "A standard interface for contracts that manage multiple token types. A single deployed contract may include any combination of fungible tokens, non-fungible tokens or other configurations (e.g. semi-fungible tokens).", "Abstract": "This standard outlines a smart contract interface that can represent any number of fungible and non-fungible token types. Existing standards such as ERC-20 require deployment of separate contracts per token type. The ERC-721 standard\u2019s token ID is a single non-fungible index and the group of these non-fungibles is deployed as a single contract with settings for the entire collection. In contrast, the ERC-1155 Multi Token Standard allows for each token ID to represent a new configurable token type, which may have its own metadata, supply and other attributes.", "Motivation": "Tokens standards like ERC-20 and ERC-721 require a separate contract to be deployed for each token type or collection. This places a lot of redundant bytecode on the Ethereum blockchain and limits certain functionality by the nature of separating each token contract into its own permissioned address. With the rise of blockchain games and platforms like Enjin Coin, game developers may be creating thousands of token types, and a new type of token standard is needed to support them. However, ERC-1155 is not specific to games and many other applications can benefit from this flexibility.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "ERC-1155 Token Receiver": "Smart contracts MUST implement all of the functions in theERC1155TokenReceiverinterface to accept transfers. See \u201cSafe Transfer Rules\u201d for further detail.", "Safe Transfer Rules": "To be more explicit about how the standardsafeTransferFromandsafeBatchTransferFromfunctions MUST operate with respect to theERC1155TokenReceiverhook functions, a list of scenarios and rules follows.", "Metadata": "The URI value allows for ID substitution by clients. If the string{id}exists in any URI, clients MUST replace this with the actual token ID in hexadecimal form. This allows for a large number of tokens to use the same on-chain string by defining a URI once, for that large number of tokens.", "Approval": "The functionsetApprovalForAllallows an operator to manage one\u2019s entire set of tokens on behalf of the approver. It enables frictionless interaction with exchange and trade contracts.", "Rationale": "Thesymbolfunction (found in the ERC-20 and ERC-721 standards) was not included as we do not believe this is a globally useful piece of data to identify a generic virtual item / asset and are also prone to collisions. Short-hand symbols are used in tickers and currency trading, but they aren\u2019t as useful outside of that space.", "Metadata Choices": "Thesymbolfunction (found in the ERC-20 and ERC-721 standards) was not included as we do not believe this is a globally useful piece of data to identify a generic virtual item / asset and are also prone to collisions. Short-hand symbols are used in tickers and currency trading, but they aren\u2019t as useful outside of that space.", "Upgrades": "The requirement to emitTransferSingleorTransferBatchon balance change implies that a valid implementation of ERC-1155 redeploying to a new contract address MUST emit events from the new contract address to replicate the deprecated contract final state. It is valid to only emit a minimal number of events to reflect only the final balance and omit all the transactions that led to that state. The event emit requirement is to ensure that the current state of the contract can always be traced only through events. To alleviate the need to emit events when changing contract address, consider using the proxy pattern, such as described inEIP-2535. This will also have the added benefit of providing a stable contract address for users.", "Design decision: Supporting non-batch": "The standard supportssafeTransferFromandonERC1155Receivedfunctions because they are significantly cheaper for single token-type transfers, which is arguably a common use case.", "Design decision: Safe transfers only": "The standard only supports safe-style transfers, making it possible for receiver contracts to depend ononERC1155ReceivedoronERC1155BatchReceivedfunction to be always called at the end of a transfer.", "Guaranteed log trace": "As the Ethereum ecosystem continues to grow, many dapps are relying on traditional databases and explorer API services to retrieve and categorize data. The ERC-1155 standard guarantees that event logs emitted by the smart contract will provide enough data to create an accurate record of all current token balances. A database or explorer may listen to events and be able to provide indexed and categorized searches of every ERC-1155 token in the contract.", "Backwards Compatibility": "There have been requirements during the design discussions to have this standard be compatible with existing standards when sending to contract addresses, specifically ERC-721 at time of writing.\nTo cater for this scenario, there is some leeway with the revert logic should a contract not implement theERC1155TokenReceiveras per \u201cSafe Transfer Rules\u201d section above, specifically \u201cScenario#3 : The receiver does not implement the necessaryERC1155TokenReceiverinterface function(s)\u201d.", "Usage": "This standard can be used to represent multiple token types for an entire domain. Both fungible and non-fungible tokens can be stored in the same smart-contract.", "Batch Transfers": "ThesafeBatchTransferFromfunction allows for batch transfers of multiple token IDs and values. The design of ERC-1155 makes batch transfers possible without the need for a wrapper contract, as with existing token standards. This reduces gas costs when more than one token type is included in a batch transfer, as compared to single transfers with multiple transactions.", "Batch Balance": "ThebalanceOfBatchfunction allows clients to retrieve balances of multiple owners and token IDs with a single call.", "Enumerating from events": "In order to keep storage requirements light for contracts implementing ERC-1155, enumeration (discovering the IDs and values of tokens) must be done using event logs. It is RECOMMENDED that clients such as exchanges and blockchain explorers maintain a local database containing the token ID, Supply, and URI at the minimum. This can be built from each TransferSingle, TransferBatch, and URI event, starting from the block the smart contract was deployed until the latest block.", "Non-Fungible Tokens": "The following strategies are examples of how you MAY mix fungible and non-fungible tokens together in the same contract. The standard does NOT mandate how an implementation must do this.", "References": "Standards", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1167, "url": "https://eips.ethereum.org/EIPS/eip-1167", "title": "Minimal Proxy Contract", "authors": ["Peter Murray\u00a0(", "@yarrumretep", ")", "Nate Welch\u00a0(", "@flygoing", ")", "Joe Messerman\u00a0(", "@JAMesserman", ")"], "sections": {"ERC-1167: Minimal Proxy Contract": "To simply and cheaply clone contract functionality in an immutable way, this standard specifies a minimal bytecode implementation that delegates all calls to a known, fixed address.", "": "To simply and cheaply clone contract functionality in an immutable way, this standard specifies a minimal bytecode implementation that delegates all calls to a known, fixed address.", "Simple Summary": "To simply and cheaply clone contract functionality in an immutable way, this standard specifies a minimal bytecode implementation that delegates all calls to a known, fixed address.", "Abstract": "By standardizing on a known minimal bytecode redirect implementation, this standard allows users and third party tools (e.g. Etherscan) to (a) simply discover that a contract will always redirect in a known manner and (b) depend on the behavior of the code at the destination contract as the behavior of the redirecting contract.  Specifically, tooling can interrogate the bytecode at a redirecting address to determine the location of the code that will run - and can depend on representations about that code (verified source, third-party audits, etc).  This implementation forwards all calls and 100% of the gas to the implementation contract and then relays the return value back to the caller.  In the case where the implementation reverts, the revert is passed back along with the payload data (for revert with message).", "Motivation": "This standard supports use-cases wherein it is desirable to clone exact contract functionality with a minimum of side effects (e.g. memory slot stomping) and with low gas cost deployment of duplicate proxies.", "Specification": "The exact bytecode of the standard clone contract is this:363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3wherein the bytes at indices 10 - 29 (inclusive) are replaced with the 20 byte address of the master functionality contract.", "Rationale": "The goals of this effort have been the following:", "Backwards Compatibility": "There are no backwards compatibility issues.  There may be some systems that are using earlier versions of the proxy contract bytecode.  They will not be compliant with this standard.", "Test Cases": "Test cases include:", "Implementation": "Deployment bytecode is not included in this specification.  One approach is defined in the proxy-contract reference implementation.", "Standard Proxy": "The disassembly of the standard deployed proxy contract code (from r2 and edited to include stack visualization)", "Vanity Address Optimization": "Proxy deployment can be further optimized by installing the master contract at a vanity contract deployment address with leading zero-bytes.  By generating a master contract vanity address that includes Z leading 0 bytes in its address, you can shorten the proxy bytecode by replacing thepush20opcode withpushN(where N is 20 - Z) followed by the N non-zero address bytes.  The revert jump address is decremented by Z in this case.  Here is an example where Z = 4:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1271, "url": "https://eips.ethereum.org/EIPS/eip-1271", "title": "Standard Signature Validation Method for Contracts", "authors": ["Francisco Giordano\u00a0(", "@frangio", ")", "Matt Condon\u00a0(", "@shrugs", ")", "Philippe Castonguay\u00a0(", "@PhABC", ")", "Amir Bandeali\u00a0(", "@abandeali1", ")", "Jorge Izquierdo\u00a0(", "@izqui", ")", "Bertrand Masius\u00a0(", "@catageek", ")"], "sections": {"ERC-1271: Standard Signature Validation Method for Contracts": "Externally Owned Accounts (EOA) can sign messages with their associated private keys, but currently contracts cannot. We propose a standard way for any contracts to verify whether a signature on a behalf of a given contract is valid. This is possible via the implementation of aisValidSignature(hash, signature)function on the signing contract, which can be called to validate a signature.", "Standard way to verify a signature when the account is a smart contract": "Externally Owned Accounts (EOA) can sign messages with their associated private keys, but currently contracts cannot. We propose a standard way for any contracts to verify whether a signature on a behalf of a given contract is valid. This is possible via the implementation of aisValidSignature(hash, signature)function on the signing contract, which can be called to validate a signature.", "Abstract": "Externally Owned Accounts (EOA) can sign messages with their associated private keys, but currently contracts cannot. We propose a standard way for any contracts to verify whether a signature on a behalf of a given contract is valid. This is possible via the implementation of aisValidSignature(hash, signature)function on the signing contract, which can be called to validate a signature.", "Motivation": "There are and will be many contracts that want to utilize signed messages for validation of rights-to-move assets or other purposes. In order for these contracts to be able to support non Externally Owned Accounts (i.e., contract owners), we need a standard mechanism by which a contract can indicate whether a given signature is valid or not on its behalf.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described inRFC 2119.", "Rationale": "We believe the name of the proposed function to be appropriate considering that anauthorizedsigners providing proper signatures for a given data would see their signature as \u201cvalid\u201d by the signing contract. Hence, a signed action message is only valid when the signer is authorized to perform a given action on the behalf of a smart wallet.", "Backwards Compatibility": "This EIP is backward compatible with previous work on signature validation since this method is specific to contract based signatures and not EOA signatures.", "Reference Implementation": "Example implementation of a signing contract:", "Security Considerations": "Since there are no gas-limit expected for calling the isValidSignature() function, it is possible that some implementation will consume a large amount of gas. It is therefore important to not hardcode an amount of gas sent when calling this method on an external contract as it could prevent the validation of certain signatures.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1328, "url": "https://eips.ethereum.org/EIPS/eip-1328", "title": "WalletConnect URI Format", "authors": ["ligi\u00a0(", "@ligi", ")", "Pedro Gomes\u00a0(", "@pedrouid", ")"], "sections": {"ERC-1328: WalletConnect URI Format": "This standard defines how the data to connect some application and a wallet can be encoded with a URI. This URI can then be shown either as a QR code or as a link.", "Define URI format for initiating connections between applications and wallets": "This standard defines how the data to connect some application and a wallet can be encoded with a URI. This URI can then be shown either as a QR code or as a link.", "Abstract": "This standard defines how the data to connect some application and a wallet can be encoded with a URI. This URI can then be shown either as a QR code or as a link.", "Specification": "WalletConnect request URI with the following parameters:", "Syntax": "WalletConnect request URI with the following parameters:", "Semantics": "Required parameters are dependent on the WalletConnect protocol version:", "Example": "This proposal moves away from the JSON format used in the alpha version of the WalletConnect protocol because it suffered from very inefficient parsing of the intent of the QR code, thereby making it easier to create better QR code parsers APIs for wallets to implement. Also by using a URI instead of JSON inside the QR-Code the Android Intent system can be leveraged.", "Rationale": "This proposal moves away from the JSON format used in the alpha version of the WalletConnect protocol because it suffered from very inefficient parsing of the intent of the QR code, thereby making it easier to create better QR code parsers APIs for wallets to implement. Also by using a URI instead of JSON inside the QR-Code the Android Intent system can be leveraged.", "Backwards Compatibility": "Versioning is required as part of the syntax for this URI specification to allow the WalletConnect protocol to evolve and allow backwards-compatibility whenever a new version is introduced.", "Security Considerations": "URIs should be shared between user devices or applications and no sensitive data is shared within the URI that could compromise the communication or would allow control of the user\u2019s private keys.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1363, "url": "https://eips.ethereum.org/EIPS/eip-1363", "title": "Payable Token", "authors": ["Vittorio Minacori\u00a0(", "@vittominacori", ")"], "sections": {"ERC-1363: Payable Token": "Defines a token interface forERC-20tokens that supports executing recipient code aftertransferortransferFrom, or spender code afterapprove.", "": "Defines a token interface forERC-20tokens that supports executing recipient code aftertransferortransferFrom, or spender code afterapprove.", "Simple Summary": "Defines a token interface forERC-20tokens that supports executing recipient code aftertransferortransferFrom, or spender code afterapprove.", "Abstract": "Standard functions a token contract and contracts working with tokens can implement to make a token Payable.", "Motivation": "There is no way to execute code after aERC-20transfer or approval (i.e. making a payment), so to make an action it is required to send another transaction and pay GAS twice.", "Specification": "Implementing contractsMUSTimplement theERC-1363interface as well as theERC-20andERC-165interfaces.", "Rationale": "The choice to usetransferAndCall,transferFromAndCallandapproveAndCallderives from theERC-20naming. They want to highlight that they have the same behaviours oftransfer,transferFromandapprovewith the addition of a callback on receiver or spender.", "Backwards Compatibility": "This proposal has been inspired also byERC-223andERC-677but it uses theERC-721approach, so it doesn\u2019t override theERC-20transferandtransferFrommethods and defines the interfaces IDs to be implemented maintaining theERC-20backwards compatibility.", "Security Considerations": "TheapproveAndCallandtransferFromAndCallmethods can be affected by the same issue of the standardERC-20approveandtransferFrommethod.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1820, "url": "https://eips.ethereum.org/EIPS/eip-1820", "title": "Pseudo-introspection Registry Contract", "authors": ["Jordi Baylina\u00a0<", "jordi@baylina.cat", ">", "Jacques Dafflon\u00a0<", "mail@0xjac.com", ">"], "sections": {"ERC-1820: Pseudo-introspection Registry Contract": "This standard defines a universal registry smart contract where any address (contract or regular account) can register which interface it supports and which smart contract is responsible for its implementation.", "": "This standard defines a universal registry smart contract where any address (contract or regular account) can register which interface it supports and which smart contract is responsible for its implementation.", "Simple Summary": "This standard defines a universal registry smart contract where any address (contract or regular account) can register which interface it supports and which smart contract is responsible for its implementation.", "Abstract": "This standard defines a registry where smart contracts and regular accounts can publish which functionality they implement\u2014either directly or through a proxy contract.", "Motivation": "There have been different approaches to define pseudo-introspection in Ethereum.\nThe first isERC-165which has the limitation that it cannot be used by regular accounts.\nThe second attempt isERC-672which uses reverseENS. Using reverseENShas two issues. \nFirst, it is unnecessarily complicated, and second,ENSis still a centralized contract controlled by a multisig.\nThis multisig theoretically would be able to modify the system.", "Specification": "Below is the raw transaction which MUST be used to deploy the smart contract on any chain.", "ERC-1820Registry Smart Contract": "Below is the raw transaction which MUST be used to deploy the smart contract on any chain.", "Deployment Transaction": "Below is the raw transaction which MUST be used to deploy the smart contract on any chain.", "Deployment Method": "This contract is going to be deployed using the keyless deployment method\u2014also known asNick\u2019s method\u2014which relies on a single-use address.\n(SeeNick\u2019s articlefor more details). This method works as follows:", "Single-use Registry Deployment Account": "This account is generated by reverse engineering it from its signature for the transaction. \nThis way no one knows the private key, but it is known that it is the valid signer of the deployment transaction.", "Registry Contract Address": "The contract has the address above for every chain on which it is deployed.", "Interface Name": "Any interface name is hashed usingkeccak256and sent togetInterfaceImplementer().", "Set An Interface For An Address": "For any address to set a contract as the interface implementation, it must call the following function of theERC-1820registry:", "Get An Implementation Of An Interface For An Address": "Anyone MAY query theERC-1820Registry to obtain the address of a contract implementing an interface on behalf of some address using thegetInterfaceImplementerfunction.", "Interface Implementation (ERC1820ImplementerInterface)": "Any contract being registered as the implementation of an interface for a given address MUST implement said interface. \nIn addition if it implements an interface on behalf of a different address, the contract MUST implement theERC1820ImplementerInterfaceshown above.", "Manager": "The manager of an address (regular account or a contract) is the only entity allowed to register implementations of interfaces for the address. \nBy default, any address is its own manager.", "Rationale": "This standards offers a way for any type of address (externally owned and contracts) to implement an interface and potentially delegate the implementation of the interface to a proxy contract. \nThis delegation to a proxy contract is necessary for externally owned accounts and useful to avoid redeploying existing contracts such as multisigs and DAOs.", "Backward Compatibility": "This standard is backward compatible withERC-165, as both methods MAY be implemented without conflicting with each other.", "Test Cases": "Please check the0xjac/ERC1820repository for the full test suite.", "Implementation": "The implementation is available in the repo:0xjac/ERC1820.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1967, "url": "https://eips.ethereum.org/EIPS/eip-1967", "title": "Proxy Storage Slots", "authors": ["Santiago Palladino\u00a0(", "@spalladino", ")", "Francisco Giordano\u00a0(", "@frangio", ")", "Hadrien Croubois\u00a0(", "@Amxx", ")"], "sections": {"ERC-1967: Proxy Storage Slots": "Delegatingproxy contractsare widely used for both upgradeability and gas savings. These proxies rely on alogic contract(also known as implementation contract or master copy) that is called usingdelegatecall. This allows proxies to keep a persistent state (storage and balance) while the code is delegated to the logic contract.", "A consistent location where proxies store the address of the logic contract they delegate to, as well as other proxy-specific information.": "Delegatingproxy contractsare widely used for both upgradeability and gas savings. These proxies rely on alogic contract(also known as implementation contract or master copy) that is called usingdelegatecall. This allows proxies to keep a persistent state (storage and balance) while the code is delegated to the logic contract.", "Abstract": "Delegatingproxy contractsare widely used for both upgradeability and gas savings. These proxies rely on alogic contract(also known as implementation contract or master copy) that is called usingdelegatecall. This allows proxies to keep a persistent state (storage and balance) while the code is delegated to the logic contract.", "Motivation": "Delegating proxies are widely in use, as a means to both support upgrades and reduce gas costs of deployments. Examples of these proxies are found in OpenZeppelin Contracts, Gnosis, AragonOS, Melonport, Limechain, WindingTree, Decentraland, and many others.", "Specification": "Monitoring of proxies is essential to the security of many applications. It is thus essential to have the ability to track changes to the implementation and admin slots. Unfortunately, tracking changes to storage slots is not easy. Consequently, it is recommended that any function that changes any of these slots SHOULD also emit the corresponding event. This includes initialization, from0x0to the first non-zero value.", "Logic contract address": "Storage slot0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc(obtained asbytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)).", "Beacon contract address": "Storage slot0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50(obtained asbytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)).", "Admin address": "Storage slot0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103(obtained asbytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)).", "Rationale": "This EIP standardises thestorage slotfor the logic contract address, instead of a public method on the proxy contract. The rationale for this is that proxies should never expose functions to end users that could potentially clash with those of the logic contract.", "Reference Implementation": "This ERC relies on the fact that the chosen storage slots arenotto be allocated by the solidity compiler. This guarantees that an implementation contract will not accidentally overwrite any of the information required for the proxy to operate. As such, locations with a high slot number were chosen to avoid clashes with the slots allocated by the compiler. Also, locations with no known preimage were picked, to ensure that a write to mapping with a maliciously crafted key could not overwrite it.", "Security Considerations": "This ERC relies on the fact that the chosen storage slots arenotto be allocated by the solidity compiler. This guarantees that an implementation contract will not accidentally overwrite any of the information required for the proxy to operate. As such, locations with a high slot number were chosen to avoid clashes with the slots allocated by the compiler. Also, locations with no known preimage were picked, to ensure that a write to mapping with a maliciously crafted key could not overwrite it.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2098, "url": "https://eips.ethereum.org/EIPS/eip-2098", "title": "Compact Signature Representation", "authors": ["Richard Moore\u00a0(", "@ricmoo", ")", "Nick Johnson\u00a0<", "nick@ethereum.org", ">"], "sections": {"ERC-2098: Compact Signature Representation": "The secp256k1 curve permits the computation of the public key of signed\ndigest when coupled with a signature, which is used implicitly to\nestablish the origin of a transaction from an Externally Owned Account\nas well as on-chain in EVM contracts for example, in meta-transactions and\nmulti-sig contracts.", "A compact representation of an Ethereum Signature.": "The secp256k1 curve permits the computation of the public key of signed\ndigest when coupled with a signature, which is used implicitly to\nestablish the origin of a transaction from an Externally Owned Account\nas well as on-chain in EVM contracts for example, in meta-transactions and\nmulti-sig contracts.", "Abstract": "The secp256k1 curve permits the computation of the public key of signed\ndigest when coupled with a signature, which is used implicitly to\nestablish the origin of a transaction from an Externally Owned Account\nas well as on-chain in EVM contracts for example, in meta-transactions and\nmulti-sig contracts.", "Motivation": "The motivations for a compact representation are to simplify handling\ntransactions in client code, reduce gas costs and reduce transaction sizes.", "Specification": "A secp256k1 signature is made up of 3 parameters,r,sandyParity.\nTherrepresents thexcomponent on the curve (from which theycan be\ncomputed), and thesrepresents the challenge solution for signing by a\nprivate key. Due to the symmetric nature of an elliptic curve, ayParityis required, which indicates which of the 2 possible solutions was intended,\nby indicating its parity (odd-ness).", "Example Implementation In Python": "The compact representation proposed is simple to both compose and decompose\nin clients and in Solidity, so that it can be easily (and intuitively) supported,\nwhile reducing transaction sizes and gas costs.", "Rationale": "The compact representation proposed is simple to both compose and decompose\nin clients and in Solidity, so that it can be easily (and intuitively) supported,\nwhile reducing transaction sizes and gas costs.", "Backwards Compatibility": "The Compact Representation does not collide with canonical signature as\nit uses 2 parameters (r, yParityAndS) and is 64 bytes long while canonical\nsignatures involve 3 separate parameters (r, s, yParity) and are 65 bytes long.", "Test Cases": "The ethers.js librarysupports this in v5as an unofficial property of split signatures (i.e.sig._vs), but should be\nconsidered an internal property that may change at discretion of the community\nand any changes to this EIP.", "Reference Implementation": "The ethers.js librarysupports this in v5as an unofficial property of split signatures (i.e.sig._vs), but should be\nconsidered an internal property that may change at discretion of the community\nand any changes to this EIP.", "Security Considerations": "There are no additional security concerns introduced by this EIP.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2135, "url": "https://eips.ethereum.org/EIPS/eip-2135", "title": "Consumable Interface (Tickets, etc)", "authors": ["Zainan Victor Zhou\u00a0(", "@xinbenlv", ")"], "sections": {"ERC-2135: Consumable Interface (Tickets, etc)": "This EIP defines an interface to mark a digital asset as \u201cconsumable\u201d and to react to its \u201cconsumption.\u201d", "An interface extending ERC-721 and ERC-1155 for consumability, supporting use case such as an event ticket.": "This EIP defines an interface to mark a digital asset as \u201cconsumable\u201d and to react to its \u201cconsumption.\u201d", "Abstract": "This EIP defines an interface to mark a digital asset as \u201cconsumable\u201d and to react to its \u201cconsumption.\u201d", "Motivation": "Digital assets sometimes need to be consumed. One of the most common examples is a concert ticket.\nIt is \u201cconsumed\u201d when the ticket-holder enters the concert hall.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "It does, however, assume the asset can be identified in auint256asset id as in the parameter. A design convention and compatibility consideration is put in place to follow the ERC-721 pattern.", "Backwards Compatibility": "This interface is designed to be compatible with ERC-721 and NFT of ERC-1155. It can be tweaked to used forERC-20,ERC-777and Fungible Token of ERC-1155.", "Test Cases": "A deployment of version 0x1002 has been deployed ontogoerlitestnet at address0x3682bcD67b8A5c0257Ab163a226fBe07BF46379B.", "Reference Implementation": "A deployment of version 0x1002 has been deployed ontogoerlitestnet at address0x3682bcD67b8A5c0257Ab163a226fBe07BF46379B.", "Security Considerations": "Compliant contracts should pay attention to the balance change when a token is consumed.\nWhen the contract is being paused, or the user is being restricted from transferring a token,\nthe consumeability should be consistent with the transferral restriction.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2309, "url": "https://eips.ethereum.org/EIPS/eip-2309", "title": "ERC-721 Consecutive Transfer Extension", "authors": ["Sean Papanikolas\u00a0(", "@pizzarob", ")"], "sections": {"ERC-2309: ERC-721 Consecutive Transfer Extension": "A standardized event emitted when creating/transferring one, or many non-fungible tokens using consecutive token identifiers.", "": "A standardized event emitted when creating/transferring one, or many non-fungible tokens using consecutive token identifiers.", "Simple Summary": "A standardized event emitted when creating/transferring one, or many non-fungible tokens using consecutive token identifiers.", "Abstract": "The optional ERC-721 Consecutive Transfer Extension provides a standardized event which could be emitted during the creation/transfer of one, or many non-fungible tokens. This standard does not set the expectation of how you might create/transfer many tokens it is only concerned with the event emitted after the creation, or transfer of ownership of these tokens. This extension assumes that token identifiers are in consecutive order.", "Motivation": "This extension provides even more scalibility of theERC-721 specification. It is possible to create, transfer, and burn 2^256 non-fungible tokens in one transaction. However, it is not possible to emit that manyTransferevents in one transaction. TheTransferevent is part of the original specification which states:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL\nNOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and\n\u201cOPTIONAL\u201d in this document are to be interpreted as described in\nRFC 2119.", "Examples": "TheConsecutiveTransferevent can be used for a single token as well as many tokens:", "Rationale": "Standardizing theConsecutiveTransferevent gives decentralized platforms a standard way of determining ownership of large quantities of non-fungible tokens without the need to support a new token standard. There are many ways in which the batch creation and transfer of NFTs can be implemented. The Consecutive Transfer Extension allows contract creators to implement batch creation, transfer, and burn methods however they see fit, but provides a standardized event in which all implementations can use. By specifying a range of consecutive token identifiers we can easily cover the transfer, or creation of 2^(256) tokens and decentralized platforms can react accordingly.", "Backwards Compatibility": "This extension was written to allow for the smallest change possible to the original ERC-721 spec while still providing a mechanism to track the creation, transfer, and deletion of a massive amount of tokens. While it is a minimal change the effects on platforms that only use the originalTransferevent to index token ownership would be severe. They would not be properly recording token ownership information that could be known by listening for theConsecutiveTransferevent. For platforms that wish to support theConsecutiveTransferevent it would be best to support both the originalTransferevent and theConsecutiveTransferevent to track token ownership.", "Security Considerations": "There are no security considerations related directly to the implementation of this standard.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2535, "url": "https://eips.ethereum.org/EIPS/eip-2535", "title": "Diamonds, Multi-Facet Proxy", "authors": ["Nick Mudge\u00a0(", "@mudgen", ")"], "sections": {"ERC-2535: Diamonds, Multi-Facet Proxy": "", "Create modular smart contract systems that can be extended after deployment.": "", "Abstract": "", "Motivation": "There are a number of different reasons to use diamonds. Here are some of them:", "Upgradeable Diamond vs. Centralized Private Database": "Why have an upgradeable diamond instead of a centralized, private, mutable database?", "Some Diamond Benefits": "The termcontractis used loosely to mean a smart contract or deployed Solidity library.", "Specification": "The termcontractis used loosely to mean a smart contract or deployed Solidity library.", "Terms": "The termcontractis used loosely to mean a smart contract or deployed Solidity library.", "Overview": "A diamond calls functions from its facets usingdelegatecall.", "A Note on Implementing Interfaces": "Because of the nature of diamonds, a diamond can implement an interface in one of two ways: directly (contract Contract is Interface), or by adding functions to it from one or more facets. For the purposes of this proposal, when a diamond is said to implement an interface, either method of implementation is permitted.", "Fallback Function": "When an external function is called on a diamond its fallback function is executed. The fallback function determines which facet to call based on the first four bytes of the call data (known as the function selector) and executes that function from the facet usingdelegatecall.", "Storage": "A state variable or storage layout organizational pattern is needed because Solidity\u2019s builtin storage layout system doesn\u2019t support proxy contracts or diamonds. The particular layout of storage is not defined in this EIP, but may be defined by later proposals. Examples of storage layout patterns that work with diamonds areDiamond StorageandAppStorage.", "Solidity Libraries as Facets": "Smart contracts or deployed Solidity libraries can be facets of diamonds.", "Adding/Replacing/Removing Functions": "All diamonds must implement theIDiamondinterface.", "Inspecting Facets & Functions": "Diamonds must support inspecting facets and functions by implementing theIDiamondLoupeinterface.", "Implementation Points": "A diamond must implement the following:", "Rationale": "User interface software can be used to retrieve function selectors and facet addresses from a diamond in order show what functions a diamond has.", "Using Function Selectors": "User interface software can be used to retrieve function selectors and facet addresses from a diamond in order show what functions a diamond has.", "Gas Considerations": "Delegating function calls does have some gas overhead. This is mitigated in several ways:", "Versions of Functions": "Software or a user can verify what version of a function is called by getting the facet address of the function. This can be done by calling thefacetAddressfunction from theIDiamondLoupeinterface. This function takes a function selector as an argument and returns the facet address where it is implemented.", "Default Function": "Solidity provides thefallbackfunction so that specific functionality can be executed when a function is called on a contract that does not exist in the contract. This same behavior can optionally be implemented in a diamond by implementing and using a default function, which is a function that is executed when a function is called on a diamond that does not exist in the diamond.", "Loupe Functions &DiamondCutEvent": "To find out what functions a regular contract has it is only necessary to look at its verified source code.", "Sharing Functions Between Facets": "In some cases it might be necessary to call a function defined in a different facet. Here are ways to do this:", "Facets can be Reusable and Composable": "A deployed facet can be used by any number of diamonds.", "Backwards Compatibility": "This standard makes upgradeable diamonds compatible with future standards and functionality because new functions can be added and existing functions can be replaced or removed.", "Reference Implementation": "All the Solidity code for a complete reference implementation has been put in a single file here:Diamond.sol", "Security Considerations": "It is possible to create many different authentication or ownership schemes with this proposal. Authentication schemes can be very simple or complex, fine grained or coarse. This proposal does not limit it in any way. For example ownership/authentication could be as simple as a single account address having the authority to add/replace/remove functions. Or a decentralized autonomous organization could have the authority to only add/replace/remove certain functions.", "Ownership and Authentication": "It is possible to create many different authentication or ownership schemes with this proposal. Authentication schemes can be very simple or complex, fine grained or coarse. This proposal does not limit it in any way. For example ownership/authentication could be as simple as a single account address having the authority to add/replace/remove functions. Or a decentralized autonomous organization could have the authority to only add/replace/remove certain functions.", "Arbitrary Execution withdiamondCut": "ThediamondCutfunction allows arbitrary execution with access to the diamond\u2019s storage (throughdelegatecall). Access to this function must be restricted carefully.", "Do Not Self Destruct": "Use ofselfdestructin a facet is heavily discouraged. Misuse of it can delete a diamond or a facet.", "Function Selector Clash": "A function selector clash occurs when two different function signatures hash to the same four-byte hash. This has the unintended consequence of replacing an existing function in a diamond when the intention was to add a new function. This scenario is not possible with a properly implementeddiamondCutfunction because it prevents adding function selectors that already exist.", "Transparency": "Diamonds emit an event every time one or more functions are added, replaced or removed. All source code can be verified. This enables people and software to monitor changes to a contract. If any bad acting function is added to a diamond then it can be seen.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2612, "url": "https://eips.ethereum.org/EIPS/eip-2612", "title": "Permit Extension for EIP-20 Signed Approvals", "authors": ["Martin Lundfall\u00a0(", "@Mrchico", ")"], "sections": {"ERC-2612: Permit Extension for EIP-20 Signed Approvals": "Arguably one of the main reasons for the success ofEIP-20tokens lies in the interplay betweenapproveandtransferFrom, which allows for tokens to not only be transferred between externally owned accounts (EOA), but to be used in other contracts under application specific conditions by abstracting awaymsg.senderas the defining mechanism for token access control.", "EIP-20 approvals via EIP-712 secp256k1 signatures": "Arguably one of the main reasons for the success ofEIP-20tokens lies in the interplay betweenapproveandtransferFrom, which allows for tokens to not only be transferred between externally owned accounts (EOA), but to be used in other contracts under application specific conditions by abstracting awaymsg.senderas the defining mechanism for token access control.", "Abstract": "Arguably one of the main reasons for the success ofEIP-20tokens lies in the interplay betweenapproveandtransferFrom, which allows for tokens to not only be transferred between externally owned accounts (EOA), but to be used in other contracts under application specific conditions by abstracting awaymsg.senderas the defining mechanism for token access control.", "Motivation": "While EIP-20 tokens have become ubiquitous in the Ethereum ecosystem, their status remains that of second class tokens from the perspective of the protocol. The ability for users to interact with Ethereum without holding any ETH has been a long outstanding goal and the subject of many EIPs.", "Specification": "Compliant contracts must implement 3 new functions in addition to EIP-20:", "Rationale": "Thepermitfunction is sufficient for enabling any operation involving EIP-20 tokens to be paid for using the token itself, rather than using ETH.", "Backwards Compatibility": "There are already a couple ofpermitfunctions in token contracts implemented in contracts in the wild, most notably the one introduced in thedai.sol.", "Security Considerations": "Though the signer of aPermitmay have a certain party in mind to submit their transaction, another party can always front run this transaction and callpermitbefore the intended party. The end result is the same for thePermitsigner, however.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2678, "url": "https://eips.ethereum.org/EIPS/eip-2678", "title": "Revised Ethereum Smart Contract Packaging Standard (EthPM v3)", "authors": ["g. nicholas d\u2019andrea\u00a0(", "@gnidan", ")", "Piper Merriam\u00a0(", "@pipermerriam", ")", "Nick Gheorghita\u00a0(", "@njgheorghita", ")", "Christian Reitwiessner\u00a0(", "@chriseth", ")", "Ben Hauser\u00a0(", "@iamdefinitelyahuman", ")", "Bryant Eisenbach\u00a0(", "@fubuloubu", ")"], "sections": {"ERC-2678: Revised Ethereum Smart Contract Packaging Standard (EthPM v3)": "A data format describing a smart contract software package.", "": "A data format describing a smart contract software package.", "Simple Summary": "A data format describing a smart contract software package.", "Abstract": "This EIP defines a data format forpackage manifestdocuments,\nrepresenting a package of one or more smart contracts, optionally\nincluding source code and any/all deployed instances across multiple\nnetworks. Package manifests are minified JSON objects, to be distributed\nvia content addressable storage networks, such as IPFS. Packages\nare then published to on-chain EthPM registries, defined inEIP-1319, from where they can be freely accessed.", "Motivation": "This standard aims to encourage the Ethereum development ecosystem\ntowards software best practices around code reuse. By defining an open,\ncommunity-driven package data format standard, this effort seeks to\nprovide support for package management tools development by offering a\ngeneral-purpose solution that has been designed with observed common\npractices in mind.", "Guiding Principles": "This specification makes the following assumptions about the document\nlifecycle.", "Use Cases": "The following use cases were considered during the creation of this\nspecification.", "Package Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d,\n\u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this\ndocument are to be interpreted as described in RFC 2119.", "Conventions": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d,\n\u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this\ndocument are to be interpreted as described in RFC 2119.", "Document Format": "The canonical format is a single JSON object. Packagesmustconform\nto the following serialization rules.", "Document Specification": "The following fields are defined for the package. Custom fieldsmaybe included. Custom fieldsshouldbe prefixed withx-to prevent\nname collisions with future versions of the specification.", "EthPM Manifest Version": "Themanifestfield defines the specification version that this\ndocument conforms to.", "Package Name": "Thenamefield defines a human readable name for this package.", "Package Version": "Theversionfield declares the version number of this release.", "Package Metadata": "Themetafield defines a location for metadata about the package which\nis not integral in nature for package installation, but may be important\nor convenient to have on-hand for other reasons.", "Sources": "Thesourcesfield defines a source tree thatshouldcomprise the\nfull source tree necessary to recompile the contracts contained in this\nrelease.", "Contract Types": "ThecontractTypesfield hosts theContract\nTypeswhich have been included in this release.", "Compilers": "Compilers are now defined in a top-level array, simplifying the task for tooling to identify the compiler types\nneeded to interact with or validate the contract assets. This also removes unnecessarily duplicated\ninformation, should multiplecontractTypesshare the same compiler type.", "Deployments": "Thedeploymentsfield holds the information for the chains on which\nthis release hasContract Instancesas well\nas theContract Typesand other deployment\ndetails for those deployed contract instances. The set of chains defined\nby theBIP122 URIkeys for this objectmustbe\nunique. There cannot be two different URI keys in a deployments field\nrepresenting the same blockchain.", "Build Dependencies": "ThebuildDependenciesfield defines a key/value mapping of EthPM\npackages that this project depends on.", "Object Definitions": "Definitions for different objects used within the Package. All objects\nallow custom fields to be included. Custom fieldsshouldbe prefixed\nwithx-to prevent name collisions with future versions of the\nspecification.", "TheLink ReferenceObject": "ALink Referenceobject has the following\nkey/value pairs. All link references are assumed to be associated with\nsome correspondingBytecode.", "TheLink ValueObject": "Describes a singleLink Value.", "TheBytecodeObject": "A bytecode object has the following key/value pairs.", "ThePackage MetaObject": "ThePackage Metaobject is defined to have the following key/value\npairs.", "TheSourcesObject": "ASourcesobject is defined to have the following fields.", "TheSourceObject": "Hash of the source file.", "TheChecksumObject": "AChecksumobject is defined to have the following key/value pairs.", "TheContract TypeObject": "AContract Typeobject is defined to have the following key/value\npairs.", "TheContract InstanceObject": "AContract Instance Objectrepresents a single deployedContract\nInstanceand is defined to have the following\nkey/value pairs.", "TheCompiler InformationObject": "Thecompilersfield defines the various compilers and settings used\nduring compilation of anyContract TypesorContract Instanceincluded in this package.", "BIP122 URI": "BIP122 URIs are used to define a blockchain via a subset of theBIP-122spec.", "Glossary": "The terms in this glossary have been updated to reflect the changes made\nin V3.", "Rationale": "EthPM packages are distributed as alphabetically-ordered & minified JSON to ensure consistency.\nSince packages are published on content-addressable filesystems (eg. IPFS), this restriction\nguarantees that any given set of contract assets will always resolve to the same content-addressed URI.", "Minification": "EthPM packages are distributed as alphabetically-ordered & minified JSON to ensure consistency.\nSince packages are published on content-addressable filesystems (eg. IPFS), this restriction\nguarantees that any given set of contract assets will always resolve to the same content-addressed URI.", "Package Names": "Package names are restricted to lower-case characters, numbers, and-to improve the readability\nof the package name, in turn improving the security properties for a package. A user is more likely\nto accurately identify their target package with this restricted set of characters, and not confuse\na malicious package that disguises itself as a trusted package with similar but different \ncharacters (e.g.Oand0).", "BIP122": "The BIP-122 standard has been used since EthPM v1 since it is an industry standard URI scheme for\nidentifying different blockchains and distinguishing between forks.", "Backwards Compatibility": "To improve understanding and readability of the EthPM spec, themanifest_versionfield was updated tomanifestin v3. To ensure \nbackwards compatibility, v3 packagesmustdefine a top-level\"manifest\"with a value of\"ethpm/3\". Additionally,\"manifest_version\"is a forbidden top-level key in v3 packages.", "Security Considerations": "Using EthPM packages implicitly requires importing &/or executing code written by others. The EthPM spec\nguarantees that when using a properly constructed and released EthPM package, the user will have the exact same\ncode that was included in the package by the package author. However, it is impossible to guarantee that this code\nis safe to interact with. Therefore, it is critical that end users only interact with EthPM packages authored and\nreleased by individuals or organizations that they trust to include non-malicious code.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2771, "url": "https://eips.ethereum.org/EIPS/eip-2771", "title": "Secure Protocol for Native Meta Transactions", "authors": ["Ronan Sandford\u00a0(", "@wighawag", ")", "Liraz Siri\u00a0(", "@lirazsiri", ")", "Dror Tirosh\u00a0(", "@drortirosh", ")", "Yoav Weiss\u00a0(", "@yoavw", ")", "Alex Forshtat\u00a0(", "@forshtat", ")", "Hadrien Croubois\u00a0(", "@Amxx", ")", "Sachin Tomar\u00a0(", "@tomarsachin2271", ")", "Patrick McCorry\u00a0(", "@stonecoldpat", ")", "Nicolas Venturo\u00a0(", "@nventuro", ")", "Fabian Vogelsteller\u00a0(", "@frozeman", ")", "Gavin John\u00a0(", "@Pandapip1", ")"], "sections": {"ERC-2771: Secure Protocol for Native Meta Transactions": "This EIP defines a contract-level protocol forRecipientcontracts to accept meta-transactions through trustedForwardercontracts. No protocol changes are made.Recipientcontracts are sent the effectivemsg.sender(referred to as_msgSender()) andmsg.data(referred to as_msgData()) by appending additional calldata.", "A contract interface for receiving meta transactions through a trusted forwarder": "This EIP defines a contract-level protocol forRecipientcontracts to accept meta-transactions through trustedForwardercontracts. No protocol changes are made.Recipientcontracts are sent the effectivemsg.sender(referred to as_msgSender()) andmsg.data(referred to as_msgData()) by appending additional calldata.", "Abstract": "This EIP defines a contract-level protocol forRecipientcontracts to accept meta-transactions through trustedForwardercontracts. No protocol changes are made.Recipientcontracts are sent the effectivemsg.sender(referred to as_msgSender()) andmsg.data(referred to as_msgData()) by appending additional calldata.", "Motivation": "There is a growing interest in making it possible for Ethereum contracts to accept calls from externally owned accounts that do not have ETH to pay for gas. Solutions that allow for third parties to pay for gas costs are called meta transactions. For the purposes of this EIP, meta transactions are transactions that have been authorized by aTransaction Signerand relayed by an untrusted third party that pays for the gas (theGas Relay).", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Definitions": "Transaction Signer: Signs & sends transactions to a Gas Relay", "Example Flow": "", "Extracting The Transaction Signer address": "TheTrusted Forwarderis responsible for calling theRecipientcontract and MUST append the address of theTransaction Signer(20 bytes of data) to the end of the call data.", "Protocol Support Discovery Mechanism": "Unless aRecipientcontract is being used by a particular frontend that knows that this contract has support for native meta transactions, it would not be possible to offer the user the choice of using meta-transaction to interact with the contract. We thus need a mechanism by which theRecipientcan let the world know that it supports meta transactions.", "Rationale": "A malicious forwarder may forge the value of_msgSender()and effectively send transactions from any address. Therefore,Recipientcontracts must be very careful in trusting forwarders. If a forwarder is upgradeable, then one must also trust that the contract won\u2019t perform a malicious upgrade.", "Reference Implementation": "A malicious forwarder may forge the value of_msgSender()and effectively send transactions from any address. Therefore,Recipientcontracts must be very careful in trusting forwarders. If a forwarder is upgradeable, then one must also trust that the contract won\u2019t perform a malicious upgrade.", "Recipient Example": "A malicious forwarder may forge the value of_msgSender()and effectively send transactions from any address. Therefore,Recipientcontracts must be very careful in trusting forwarders. If a forwarder is upgradeable, then one must also trust that the contract won\u2019t perform a malicious upgrade.", "Security Considerations": "A malicious forwarder may forge the value of_msgSender()and effectively send transactions from any address. Therefore,Recipientcontracts must be very careful in trusting forwarders. If a forwarder is upgradeable, then one must also trust that the contract won\u2019t perform a malicious upgrade.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2981, "url": "https://eips.ethereum.org/EIPS/eip-2981", "title": "NFT Royalty Standard", "authors": ["Zach Burks\u00a0(", "@vexycats", ")", "James Morgan\u00a0(", "@jamesmorgan", ")", "Blaine Malone\u00a0(", "@blmalone", ")", "James Seibel\u00a0(", "@seibelj", ")"], "sections": {"ERC-2981: NFT Royalty Standard": "A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal support for royalty payments across all NFT marketplaces and ecosystem participants.", "": "A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal support for royalty payments across all NFT marketplaces and ecosystem participants.", "Simple Summary": "A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal support for royalty payments across all NFT marketplaces and ecosystem participants.", "Abstract": "This standard allows contracts, such as NFTs that supportERC-721andERC-1155interfaces, to signal a royalty amount to be paid to the NFT creator or rights holder every time the NFT is sold or re-sold. This is intended for NFT marketplaces that want to support the ongoing funding of artists and other NFT creators. The royalty payment must be voluntary, as transfer mechanisms such astransferFrom()include NFT transfers between wallets, and executing them does not always imply a sale occurred. Marketplaces and individuals implement this standard by retrieving the royalty payment information withroyaltyInfo(), which specifies how much to pay to which address for a given sale price. The exact mechanism for paying and notifying the recipient will be defined in future EIPs. This ERC should be considered a minimal, gas-efficient building block for further innovation in NFT royalty payments.", "Motivation": "There are many marketplaces for NFTs with multiple unique royalty payment implementations that are not easily compatible or usable by other marketplaces. Just like the early days of ERC-20 tokens, NFT marketplace smart contracts are varied by ecosystem and not standardized. This EIP enables all marketplaces to retrieve royalty payment information for a given NFT. This enables accurate royalty payments regardless of which marketplace the NFT is sold or re-sold at.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL\nNOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and\n\u201cOPTIONAL\u201d in this document are to be interpreted as described in\nRFC 2119.", "Examples": "This standard being used on an ERC-721 during deployment:", "Rationale": "It is impossible to know which NFT transfers are the result of sales, and which are merely wallets moving or consolidating their NFTs. Therefore, we cannot force every transfer function, such astransferFrom()in ERC-721, to involve a royalty payment as not every transfer is a sale that would require such payment. We believe the NFT marketplace ecosystem will voluntarily implement this royalty payment standard to provide ongoing funding for artists/creators. NFT buyers will assess the royalty payment as a factor when making NFT purchasing decisions.", "Optional royalty payments": "It is impossible to know which NFT transfers are the result of sales, and which are merely wallets moving or consolidating their NFTs. Therefore, we cannot force every transfer function, such astransferFrom()in ERC-721, to involve a royalty payment as not every transfer is a sale that would require such payment. We believe the NFT marketplace ecosystem will voluntarily implement this royalty payment standard to provide ongoing funding for artists/creators. NFT buyers will assess the royalty payment as a factor when making NFT purchasing decisions.", "Simple royalty payments to a single address": "This EIP does not specify the manner of payment to the royalty recipient. Furthermore, it is impossible to fully know and efficiently implement all possible types of royalty payments logic. With that said, it is on the royalty payment receiver to implement all additional complexity and logic for fee splitting, multiple receivers, taxes, accounting, etc. in their own receiving contract or off-chain processes. Attempting to do this as part of this standard, it would dramatically increase the implementation complexity, increase gas costs, and could not possibly cover every potential use-case. This ERC should be considered a minimal, gas-efficient building block for further innovation in NFT royalty payments. Future EIPs can specify more details regarding payment transfer and notification.", "Royalty payment percentage calculation": "This EIP mandates a percentage-based royalty fee model. It is likely that the most common case of percentage calculation will be where theroyaltyAmountis always calculated from the_salePriceusing a fixed percent i.e. if the royalty fee is 10%, then a 10% royalty fee must apply whether_salePriceis 10, 10000 or 1234567890.", "Unit-less royalty payment across all marketplaces, both on-chain and off-chain": "This EIP does not specify a currency or token used for sales and royalty payments. The same percentage-based royalty fee must be paid regardless of what currency, or token was used in the sale, paid in the same currency or token. This applies to sales in any location including on-chain sales, over-the-counter (OTC) sales, and off-chain sales using fiat currency such as at auction houses. As royalty payments are voluntary, entities that respect this EIP must pay no matter where the sale occurred - a sale outside of the blockchain is still a sale. The exact mechanism for paying and notifying the recipient will be defined in future EIPs.", "Universal Royalty Payments": "Although designed specifically with NFTs in mind, this standard does not require that a contract implementing EIP-2981 is compatible with either ERC-721 or ERC-1155 standards. Any other contract could use this interface to return royalty payment information, provided that it is able to uniquely identify assets within the constraints of the interface. ERC-2981 is, therefore, a universal royalty standard for many other asset types.", "Backwards Compatibility": "This standard is compatible with current ERC-721 and ERC-1155 standards.", "Security Considerations": "There are no security considerations related directly to the implementation of this standard.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3156, "url": "https://eips.ethereum.org/EIPS/eip-3156", "title": "Flash Loans", "authors": ["Alberto Cuesta Ca\u00f1ada\u00a0(", "@alcueca", ")", "Fiona Kobayashi\u00a0(", "@fifikobayashi", ")", "fubuloubu\u00a0(", "@fubuloubu", ")", "Austin Williams\u00a0(", "@onewayfunction", ")"], "sections": {"ERC-3156: Flash Loans": "This ERC provides standard interfaces and processes for single-asset flash loans.", "": "This ERC provides standard interfaces and processes for single-asset flash loans.", "Simple Summary": "This ERC provides standard interfaces and processes for single-asset flash loans.", "Abstract": "A flash loan is a smart contract transaction in which a lender smart contract lends assets to a borrower smart contract with the condition that the assets are returned, plus an optional fee, before the end of the transaction. This ERC specifies interfaces for lenders to accept flash loan requests, and for borrowers to take temporary control of the transaction within the lender execution. The process for the safe execution of flash loans is also specified.", "Motivation": "Flash loans allow smart contracts to lend an amount of tokens without a requirement for collateral, with the condition that they must be returned within the same transaction.", "Specification": "A flash lending feature integrates two smart contracts using a callback pattern. These are called the LENDER and the RECEIVER in this EIP.", "Lender Specification": "AlenderMUST implement the IERC3156FlashLender interface.", "Receiver Specification": "Areceiverof flash loans MUST implement the IERC3156FlashBorrower interface:", "Rationale": "The interfaces described in this ERC have been chosen as to cover the known flash lending use cases, while allowing for safe and gas efficient implementations.", "Backwards Compatibility": "No backwards compatibility issues identified.", "Implementation": "The arguments ofonFlashLoanare expected to reflect the conditions of the flash loan, but cannot be trusted unconditionally. They can be divided in two groups, that require different checks before they can be trusted to be genuine.", "Flash Borrower Reference Implementation": "The arguments ofonFlashLoanare expected to reflect the conditions of the flash loan, but cannot be trusted unconditionally. They can be divided in two groups, that require different checks before they can be trusted to be genuine.", "Flash Mint Reference Implementation": "The arguments ofonFlashLoanare expected to reflect the conditions of the flash loan, but cannot be trusted unconditionally. They can be divided in two groups, that require different checks before they can be trusted to be genuine.", "Flash Loan Reference Implementation": "The arguments ofonFlashLoanare expected to reflect the conditions of the flash loan, but cannot be trusted unconditionally. They can be divided in two groups, that require different checks before they can be trusted to be genuine.", "Security Considerations": "The arguments ofonFlashLoanare expected to reflect the conditions of the flash loan, but cannot be trusted unconditionally. They can be divided in two groups, that require different checks before they can be trusted to be genuine.", "Verification of callback arguments": "The arguments ofonFlashLoanare expected to reflect the conditions of the flash loan, but cannot be trusted unconditionally. They can be divided in two groups, that require different checks before they can be trusted to be genuine.", "Flash lending security considerations": "The safest approach is to implement an approval foramount+feebefore theflashLoanis executed.", "Flash minting external security considerations": "The typical quantum of tokens involved in flash mint transactions will give rise to new innovative attack vectors.", "Flash minting internal security considerations": "The coupling of flash minting with business specific features in the same platform can easily lead to unintended consequences.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3448, "url": "https://eips.ethereum.org/EIPS/eip-3448", "title": "MetaProxy Standard", "authors": ["pinkiebell\u00a0(", "@pinkiebell", ")"], "sections": {"ERC-3448: MetaProxy Standard": "By standardizing on a known minimal bytecode proxy implementation with support for immutable metadata, this standard allows users and third party tools (e.g. Etherscan) to:\n(a) simply discover that a contract will always redirect in a known manner and\n(b) depend on the behavior of the code at the destination contract as the behavior of the redirecting contract and\n(c) verify/view the attached metadata.", "A minimal bytecode implementation for creating proxy contracts with immutable metadata attached to the bytecode": "By standardizing on a known minimal bytecode proxy implementation with support for immutable metadata, this standard allows users and third party tools (e.g. Etherscan) to:\n(a) simply discover that a contract will always redirect in a known manner and\n(b) depend on the behavior of the code at the destination contract as the behavior of the redirecting contract and\n(c) verify/view the attached metadata.", "Abstract": "By standardizing on a known minimal bytecode proxy implementation with support for immutable metadata, this standard allows users and third party tools (e.g. Etherscan) to:\n(a) simply discover that a contract will always redirect in a known manner and\n(b) depend on the behavior of the code at the destination contract as the behavior of the redirecting contract and\n(c) verify/view the attached metadata.", "Motivation": "This standard supports use-cases wherein it is desirable to clone exact contract functionality with different parameters at another address.", "Specification": "The exact bytecode of the MetaProxy contract is:", "Rationale": "The goals of this effort have been the following:", "Backwards Compatibility": "There are no backwards compatibility issues.", "Test Cases": "Tested with:", "Reference Implementation": "A reference implementation can be foundin the EIP asset directory.", "Deployment bytecode": "A annotated version of the deploy bytecode:", "MetaProxy": "A annotated version of the MetaProxy bytecode:", "Examples": "The following code snippets serve only as suggestions and are not a discrete part of this standard.", "Security Considerations": "This standard only covers the bytecode implementation and does not include any serious side effects of itself.\nThe reference implementation only serves as a example. It is highly recommended to research side effects depending on how the functionality is used and implemented in any project.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3475, "url": "https://eips.ethereum.org/EIPS/eip-3475", "title": "Abstract Storage Bonds", "authors": ["Yu Liu\u00a0(", "@yuliu-debond", ")", "Varun Deshpande\u00a0(", "@dr-chain", ")", "Cedric Ngakam\u00a0(", "@drikssy", ")", "Dhruv Malik\u00a0(", "@dhruvmalik007", ")", "Samuel Gwlanold Edoumou\u00a0(", "@Edoumou", ")", "Toufic Batrice\u00a0(", "@toufic0710", ")"], "sections": {"ERC-3475: Abstract Storage Bonds": "Current LP (Liquidity Provider) tokens are simpleEIP-20tokens with no complex data structure. To allow more complex reward and redemption logic to be stored on-chain, we need a new token standard that:", "Interface for creating tokenized obligations with abstract on-chain metadata storage": "Current LP (Liquidity Provider) tokens are simpleEIP-20tokens with no complex data structure. To allow more complex reward and redemption logic to be stored on-chain, we need a new token standard that:", "Abstract": "Current LP (Liquidity Provider) tokens are simpleEIP-20tokens with no complex data structure. To allow more complex reward and redemption logic to be stored on-chain, we need a new token standard that:", "Motivation": "Current LP (Liquidity Provider) tokens are simpleEIP-20tokens with no complex data structure. To allow more complex reward and redemption logic to be stored on-chain, we need a new token standard that:", "Specification": "Definition", "Events": "Metadata:\nThe metadata of a bond class or nonce is stored as an array of JSON objects, represented by the following types.", "1. Description:": "This defines the additional information about the nature of data being stored in the nonce/class metadata structures. They are defined using the structured explainedhere. this will then be used by the frontend of the respective entities participating in the bond markets to interpret the data which is compliant with their jurisdiction.", "2. Nonce:": "The key value for indexing the information is the \u2018class\u2019 field. Following are the rules:", "3. Class metadata:": "This structure defines the details of the class information (symbol, risk information, etc.). the example is explainedherein the class metadata section.", "4. Decoding data": "First, the functions for analyzing the metadata (i.eClassMetadataandNonceMetadata) are to be used by the corresponding frontend to decode the information of the bond.", "Rationale": "Instead of storing the details about the class and their issuances to the user (ie nonce) externally, we store the details in the respective structures. Classes represent the different bond types, and nonces represent the various period of issuances. Nonces under the same class share the same metadata. Meanwhile, nonces are non-fungible. Each nonce can store a different set of metadata. Thus, upon transfer of a bond, all the metadata will be transferred to the new owner of the bond.", "Metadata structure": "Instead of storing the details about the class and their issuances to the user (ie nonce) externally, we store the details in the respective structures. Classes represent the different bond types, and nonces represent the various period of issuances. Nonces under the same class share the same metadata. Meanwhile, nonces are non-fungible. Each nonce can store a different set of metadata. Thus, upon transfer of a bond, all the metadata will be transferred to the new owner of the bond.", "Batch function": "This EIP supports batch operations. It allows the user to transfer different bonds along with their metadata to a new address instantaneously in a single transaction. After execution, the new owner holds the right to reclaim the face value of each of the bonds. This mechanism helps with the \u201cpackaging\u201d of bonds\u2013helpful in use cases like trades on a secondary market.", "AMM optimization": "One of the most obvious use cases of this EIP is the multilayered pool. The early version of AMM uses a separate smart contract and anEIP-20LP token to manage a pair. By doing so, the overall liquidity inside of one pool is significantly reduced and thus generates unnecessary gas spent and slippage. Using this EIP standard, one can build a big liquidity pool with all the pairs inside (thanks to the presence of the data structures consisting of the liquidity corresponding to the given class and nonce of bonds). Thus by knowing the class and nonce of the bonds, the liquidity can be represented as the percentage of a given token pair for the owner of the bond in the given pool. Effectively, theEIP-20LP token (defined by a unique smart contract in the pool factory contract) is aggregated into a single bond and consolidated into a single pool.", "Backwards Compatibility": "Any contract that inherits the interface of this EIP is compatible. This compatibility exists for issuer and receiver of the bonds. Also any client EOA wallet can be compatible with the standard if they are able to signissue()andredeem()commands.", "Test Cases": "Test-case for the minimal reference implementation ishere. Use the Truffle box to compile and test the contracts.", "Reference Implementation": "Copyright and related rights waived viaCC0.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3525, "url": "https://eips.ethereum.org/EIPS/eip-3525", "title": "Semi-Fungible Token", "authors": ["Will Wang\u00a0(", "@will42w", ")", "Mike Meng\u00a0<", "myan@solv.finance", ">", "Yi Cai (@YeeTsai)\u00a0<", "yee.tsai@gmail.com", ">", "Ryan Chow\u00a0<", "ryanchow@solv.finance", ">", "Zhongxin Wu\u00a0(", "@Nerverwind", ")", "AlvisDu\u00a0(", "@AlvisDu", ")"], "sections": {"ERC-3525: Semi-Fungible Token": "This is a standard for semi-fungible tokens. The set of smart contract interfaces described in this document defines anERC-721compatible token standard. This standard introduces an<ID, SLOT, VALUE>triple scalar model that represents the semi-fungible structure of a token. It also introduces new transfer models as well as approval models that reflect the semi-fungible nature of the tokens.", "Defines a specification where ERC-721 compatible tokens with the same SLOT and different IDs are fungible.": "This is a standard for semi-fungible tokens. The set of smart contract interfaces described in this document defines anERC-721compatible token standard. This standard introduces an<ID, SLOT, VALUE>triple scalar model that represents the semi-fungible structure of a token. It also introduces new transfer models as well as approval models that reflect the semi-fungible nature of the tokens.", "Abstract": "This is a standard for semi-fungible tokens. The set of smart contract interfaces described in this document defines anERC-721compatible token standard. This standard introduces an<ID, SLOT, VALUE>triple scalar model that represents the semi-fungible structure of a token. It also introduces new transfer models as well as approval models that reflect the semi-fungible nature of the tokens.", "Motivation": "Tokenization is one of the most important trends by which to use and control digital assets in crypto. Traditionally, there have been two approaches to do so: fungible and non-fungible tokens. Fungible tokens generally use the ERC-20 standard, where every unit of an asset is identical to each other. ERC-20 is a flexible and efficient way to manipulate fungible tokens. Non-fungible tokens are predominantly ERC-721 tokens, a standard capable of distinguishing digital assets from one another based on identity.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "ERC-3525 Token Receiver": "If a smart contract wants to be informed when they receive values from other addresses, it should implement all of the functions in theIERC3525Receiverinterface, in the implementation it can decide whether to accept or reject the transfer. See \u201cTransfer Rules\u201d for further detail.", "Token Manipulation": "Transfer:", "Metadata": "ERC-3525 metadata extensions are compatible ERC-721 metadata extensions.", "Rationale": "This token standard is designed to represent semi-fungible assets, which are most suited for financial instruments rather than collectibles or in-game items. For maximum transparency and safety of digital assets, we strongly recommend that all implementations should generate metadata directly from contract code rather than giving out an off-chain server URL.", "Metadata generation": "This token standard is designed to represent semi-fungible assets, which are most suited for financial instruments rather than collectibles or in-game items. For maximum transparency and safety of digital assets, we strongly recommend that all implementations should generate metadata directly from contract code rather than giving out an off-chain server URL.", "Design decision: Value transfer from token to address": "The \u2018value\u2019 of a token is a property of the token and is not linked to an address, so to transfer the value to an address would be actually transferring it to a token owned by that address, not the address itself.", "Design decision: Notification/acceptance mechanism instead of \u2018Safe Transfer\u2019": "ERC-721 and some later token standards introduced \u2018Safe Transfer\u2019 model, for better control of the \u2018safety\u2019 when transferring tokens, this mechanism leaves the choice of different transfer modes (safe/unsafe) to the sender, and may cause some potential problems:", "Design decision: Relationship between different approval models": "For semantic compatibility with ERC-721 as well as the flexibility of value manipulation of tokens, we decided to define the relationships between some of the levels of approval like that:", "Backwards Compatibility": "As mentioned in the beginning, this EIP is backward compatible with ERC-721.", "Reference Implementation": "The value level approval and slot level approval (optional) is isolated from ERC-721 approval models, so that approving value should not affect ERC-721 level approvals. Implementations of this EIP must obey this principle.", "Security Considerations": "The value level approval and slot level approval (optional) is isolated from ERC-721 approval models, so that approving value should not affect ERC-721 level approvals. Implementations of this EIP must obey this principle.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3643, "url": "https://eips.ethereum.org/EIPS/eip-3643", "title": "T-REX - Token for Regulated EXchanges", "authors": ["Joachim Lebrun\u00a0(", "@Joachim-Lebrun", ")", "Tony Malghem\u00a0(", "@TonyMalghem", ")", "Kevin Thizy\u00a0(", "@Nakasar", ")", "Luc Falempin\u00a0(", "@lfalempin", ")", "Adam Boudjemaa\u00a0(", "@Aboudjem", ")"], "sections": {"ERC-3643: T-REX - Token for Regulated EXchanges": "The T-REX token is an institutional grade security token standard. This standard provides a library of interfaces for the management and compliant transfer of security tokens, using an automated onchain validator system leveraging onchain identities for eligibility checks.", "An institutional grade security token contract that provides interfaces for the management and compliant transfer of security tokens.": "The T-REX token is an institutional grade security token standard. This standard provides a library of interfaces for the management and compliant transfer of security tokens, using an automated onchain validator system leveraging onchain identities for eligibility checks.", "Abstract": "The T-REX token is an institutional grade security token standard. This standard provides a library of interfaces for the management and compliant transfer of security tokens, using an automated onchain validator system leveraging onchain identities for eligibility checks.", "Motivation": "The advent of blockchain technology has brought about a new era of efficiency, accessibility, and liquidity in the world of asset transfer. This is particularly evident in the realm of cryptocurrencies, where users can transfer token ownership peer-to-peer without intermediaries. However, when it comes to tokenized securities or security tokens, the situation is more complex due to the need for compliance with securities laws. These tokens cannot be permissionless like utility tokens; they must be permissioned to track ownership and ensure that only eligible investors can hold tokens.", "Specification": "The proposed standard has the following requirements:", "Agent Role Interface": "The standard defines an Agent role, which is crucial for managing access to various functions of the smart contracts. The interface for the Agent role is as follows:", "Main functions": "To be able to perform a transfer on T-REX you need to fulfill several conditions :", "Token interface": "ERC-3643 permissioned tokens build upon the standard ERC-20 structure, but with additional functions to ensure compliance in the transactions of the security tokens. The functionstransferandtransferFromare implemented in a conditional way, allowing them to proceed with a transfer only if the transaction is valid. The permissioned tokens are allowed to be transferred only to validated counterparties, in order to avoid tokens being held in wallets/Identity contracts of ineligible/unauthorized investors. The ERC-3643 standard also supports the recovery of security tokens in case an investor loses access to their wallet private key. A history of recovered tokens is maintained on the blockchain for transparency reasons.", "Identity Registry Interface": "The Identity Registry is linked to storage that contains a dynamic whitelist of identities. It establishes the link between a wallet address, an Identity smart contract, and a country code corresponding to the investor\u2019s country of residence. This country code is set in accordance with the ISO-3166 standard. The Identity Registry also includes a function calledisVerified(), which returns a status based on the validity of claims (as per the security token requirements) in the user\u2019s Identity contract.", "Identity Registry Storage Interface": "The Identity Registry Storage stores the identity addresses of all the authorized investors in the security token(s) linked to the storage contract. These are all identities of investors who have been authorized to hold the token(s) after having gone through the appropriate KYC and eligibility checks. The Identity Registry Storage can be bound to one or several Identity Registry contract(s). The goal of the Identity Registry storage is to separate the Identity Registry functions and specifications from its storage. This way, it is possible to keep one single Identity Registry contract per token, with its own Trusted Issuers Registry and Claim Topics Registry, but with a shared whitelist of investors used by theisVerifed()function implemented in the Identity Registries to check the eligibility of the receiver in a transfer transaction.", "Compliance Interface": "The Compliance contract is used to set the rules of the offering itself and ensures these rules are respected during the whole lifecycle of the token. For example, the Compliance contract will define the maximum amount of investors per country, the maximum amount of tokens per investor, and the accepted countries for the circulation of the token (using the country code corresponding to each investor in the Identity Registry). The Compliance smart contract can be either \u201ctailor-made\u201d, following the legal requirements of the token issuer, or can be deployed under a generic modular form, which can then add and remove external complianceModulesto fit the legal requirements of the token in the same way as a custom \u201ctailor-made\u201d contract would.", "Trusted Issuer\u2019s Registry Interface": "The Trusted Issuer\u2019s Registry stores the contract addresses (IClaimIssuer) of all the trusted claim issuers for a specific security token. The Identity contract (IIdentity) of token owners (the investors) must have claims signed by the claim issuers stored in this smart contract in order to be able to hold the token.", "Claim Topics Registry Interface": "The Claim Topics Registry stores all the trusted claim topics for the security token. The Identity contract (IIdentity) of token owners must contain claims of the claim topics stored in this smart contract.", "Rationale": "Transfers of securities can fail for a variety of reasons. This is in direct contrast to utility tokens, which generally only require the sender to have a sufficient balance. These conditions can be related to the status of an investor\u2019s wallet, the identity of the sender and receiver of the securities (i.e., whether they have been through a KYC process, whether they are accredited or an affiliate of the issuer) or for reasons unrelated to the specific transfer but instead set at the token level (i.e., the token contract enforces a maximum number of investors or a cap on the percentage held by any single investor). For ERC-20 tokens, thebalanceOfandallowancefunctions provide a way to check that a transfer is likely to succeed before executing the transfer, which can be executed both on-chain and off-chain. For tokens representing securities, the T-REX standard introduces a functioncanTransferwhich provides a more general-purpose way to achieve this. I.e., when the reasons for failure are related to the compliance rules of the token and a functionisVerifiedwhich allows checking the eligibility status of the identity of the investor. Transfers can also fail if the address of the sender and/or receiver is frozen, or if the free balance of the sender (total balance - frozen tokens) is lower than the amount to transfer. Ultimately, the transfer could be blocked if the token ispaused.", "Transfer Restrictions": "Transfers of securities can fail for a variety of reasons. This is in direct contrast to utility tokens, which generally only require the sender to have a sufficient balance. These conditions can be related to the status of an investor\u2019s wallet, the identity of the sender and receiver of the securities (i.e., whether they have been through a KYC process, whether they are accredited or an affiliate of the issuer) or for reasons unrelated to the specific transfer but instead set at the token level (i.e., the token contract enforces a maximum number of investors or a cap on the percentage held by any single investor). For ERC-20 tokens, thebalanceOfandallowancefunctions provide a way to check that a transfer is likely to succeed before executing the transfer, which can be executed both on-chain and off-chain. For tokens representing securities, the T-REX standard introduces a functioncanTransferwhich provides a more general-purpose way to achieve this. I.e., when the reasons for failure are related to the compliance rules of the token and a functionisVerifiedwhich allows checking the eligibility status of the identity of the investor. Transfers can also fail if the address of the sender and/or receiver is frozen, or if the free balance of the sender (total balance - frozen tokens) is lower than the amount to transfer. Ultimately, the transfer could be blocked if the token ispaused.", "Identity Management": "Security and compliance of transfers are enforced through the management of on-chain identities. These include:", "Token Lifecycle Management": "The T-REX standard provides a comprehensive framework for managing the lifecycle of security tokens. This includes the issuance of tokens, transfers between eligible investors, and the enforcement of compliance rules at every stage of the token\u2019s lifecycle. The standard also supports additional features such as token pausing and freezing, which can be used to manage the token in response to regulatory requirements or changes in the status of the token or its holders.", "Additional Compliance Rules": "The T-REX standard supports the implementation of additional compliance rules through modular compliance. These modules can be used to enforce a wide range of rules and restrictions, such as caps on the number of investors or the percentage of tokens held by a single investor, restrictions on transfers between certain types of investors, and more. This flexibility allows issuers to tailor the compliance rules of their tokens to their specific needs and regulatory environment.", "Inclusion of Agent-Related Functions": "The inclusion of Agent-scoped functions within the standard interfaces is deliberate. The intent is to accommodate secure and adaptable token management practices that surpass the capabilities of EOA management. We envision scenarios where the agent role is fulfilled by automated systems or smart contracts, capable of programmatically executing operational functions like minting, burning, and freezing in response to specified criteria or regulatory triggers. For example, a smart contract might automatically burn tokens to align with redemption requests in an open-ended fund, or freeze tokens associated with wallets engaged in fraudulent activities.", "Backwards Compatibility": "T-REX tokens should be backwards compatible with ERC-20 and ERC-173\nand should be able to interact with aClaim Holder contractto validate \nthe claims linked to anIdentity contract.", "Security Considerations": "This specification has been audited by Kapersky and Hacken, and no notable security considerations were found. \nWhile the audits were primarily focused on the specific implementation by Tokeny, they also challenged and validated the core principles of the T-REX standard. The auditing teams approval of these principles provides assurance that the standard itself is robust and does not present any significant security concerns.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3668, "url": "https://eips.ethereum.org/EIPS/eip-3668", "title": "CCIP Read\u2014Secure offchain data retrieval", "authors": ["Nick Johnson\u00a0(", "@arachnid", ")"], "sections": {"ERC-3668: CCIP Read\u2014Secure offchain data retrieval": "Contracts wishing to support lookup of data from external sources may, instead of returning the data directly, revert usingOffchainLookup(address sender, string[] urls, bytes callData, bytes4 callbackFunction, bytes extraData). Clients supporting this specification then make an RPC call to a URL fromurls, supplyingcallData, and getting back an opaque byte stringresponse. Finally, clients call the function specified bycallbackFunctionon the contract, providingresponseandextraData. The contract can then decode and verify the returned data using an implementation-specific method.", "CCIP Read provides a mechanism to allow a contract to fetch external data.": "Contracts wishing to support lookup of data from external sources may, instead of returning the data directly, revert usingOffchainLookup(address sender, string[] urls, bytes callData, bytes4 callbackFunction, bytes extraData). Clients supporting this specification then make an RPC call to a URL fromurls, supplyingcallData, and getting back an opaque byte stringresponse. Finally, clients call the function specified bycallbackFunctionon the contract, providingresponseandextraData. The contract can then decode and verify the returned data using an implementation-specific method.", "Abstract": "Contracts wishing to support lookup of data from external sources may, instead of returning the data directly, revert usingOffchainLookup(address sender, string[] urls, bytes callData, bytes4 callbackFunction, bytes extraData). Clients supporting this specification then make an RPC call to a URL fromurls, supplyingcallData, and getting back an opaque byte stringresponse. Finally, clients call the function specified bycallbackFunctionon the contract, providingresponseandextraData. The contract can then decode and verify the returned data using an implementation-specific method.", "Motivation": "Minimising storage and transaction costs on Ethereum has driven contract authors to adopt a variety of techniques for moving data offchain, including hashing, recursive hashing (eg Merkle Trees/Tries) and L2 solutions. While each solution has unique constraints and parameters, they all share in common the fact that enough information is stored onchain to validate the externally stored data when required.", "Specification": "Answering a query via CCIP read takes place in three steps:", "Overview": "Answering a query via CCIP read takes place in three steps:", "Contract interface": "A CCIP read enabled contract MUST revert with the following error whenever a function that requires offchain data is called:", "Gateway Interface": "The URLs returned by a contract may be of any schema, but this specification only defines how clients should handle HTTPS URLs.", "Client Lookup Protocol": "A client that supports CCIP read MUST make contract calls using the following process:", "Use of CCIP read for transactions": "While the specification above is for read-only contract calls (eg,eth_call), it is simple to use this method for sending transactions (eg,eth_sendTransactionoreth_sendRawTransaction) that require offchain data. While \u2018preflighting\u2019 a transaction usingeth_estimateGasoreth_call, a client that receives anOffchainLookuprevert can follow the procedure described above inClient lookup protocol, substituting a transaction for the call in the last step. This functionality is ideal for applications such as making onchain claims supported by offchain proof data.", "Glossary": "For offchain data lookup to function as desired, clients must either have some way to know that a function depends on this specification for functionality - such as a specifier in the ABI for the function - or else there must be a way for the contract to signal to the client that data needs to be fetched from elsewhere.", "Rationale": "For offchain data lookup to function as desired, clients must either have some way to know that a function depends on this specification for functionality - such as a specifier in the ABI for the function - or else there must be a way for the contract to signal to the client that data needs to be fetched from elsewhere.", "Use ofrevertto convey call information": "For offchain data lookup to function as desired, clients must either have some way to know that a function depends on this specification for functionality - such as a specifier in the ABI for the function - or else there must be a way for the contract to signal to the client that data needs to be fetched from elsewhere.", "Passing contract address to the gateway service": "addressis passed to the gateway in order to facilitate the writing of generic gateways, thus reducing the burden on contract authors to provide their own gateway implementations. Supplyingaddressallows the gateway to perform lookups to the original contract for information needed to assist with resolution, making it possible to operate one gateway for any number of contracts implementing the same interface.", "Existence ofextraDataargument": "extraDataallows the original contract function to pass information to a subsequent invocation. Since contracts are not persistent, without this data a contract has no state from the previous invocation. Aside from allowing arbitrary contextual information to be propagated between the two calls, this also allows the contract to verify that the query the gateway answered is in fact the one the contract originally requested.", "Use of GET and POST requests for the gateway interface": "Using a GET request, with query data encoded in the URL, minimises complexity and enables entirely static implementations of gateways - in some applications a gateway can simply be an HTTP server or IPFS instance with a static set of responses in text files.", "Backwards Compatibility": "Existing contracts that do not wish to use this specification are unaffected. Clients can add support for CCIP read to all contract calls without introducing any new overhead or incompatibilities.", "Security Considerations": "In order to prevent a malicious gateway from causing unintended side-effects or faulty results, contracts MUST include sufficient information in theextraDataargument to allow them to verify the relevance and validity of the gateway\u2019s response. For example, if the contract is requesting information based on anaddresssupplied to the original call, it MUST include that address in theextraDataso that the callback can verify the gateway is not providing the answer to a different query.", "Gateway Response Data Validation": "In order to prevent a malicious gateway from causing unintended side-effects or faulty results, contracts MUST include sufficient information in theextraDataargument to allow them to verify the relevance and validity of the gateway\u2019s response. For example, if the contract is requesting information based on anaddresssupplied to the original call, it MUST include that address in theextraDataso that the callback can verify the gateway is not providing the answer to a different query.", "Client Extra Data Validation": "In order to prevent a malicious client from causing unintended effects when making transactions using CCIP read, contracts MUST implement appropriate checks on theextraDatareturned to them in the callback. Any sanity/permission checks performed on input data for the initial call MUST be repeated on the data passed through theextraDatafield in the callback. For example, if a transaction should only be executable by an authorised account, that authorisation check MUST be done in the callback; it is not sufficient to perform it with the initial call and embed the authorised address in theextraData.", "HTTP requests and fingerprinting attacks": "Because CCIP read can cause a user\u2019s browser to make HTTP requests to an address controlled by the contract, there is the potential for this to be used to identify users - for example, to associate their wallet address with their IP address.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4400, "url": "https://eips.ethereum.org/EIPS/eip-4400", "title": "EIP-721 Consumable Extension", "authors": ["Daniel Ivanov\u00a0(", "@Daniel-K-Ivanov", ")", "George Spasov\u00a0(", "@Perseverance", ")"], "sections": {"ERC-4400: EIP-721 Consumable Extension": "This specification defines standard functions outlining aconsumerrole for instance(s) ofEIP-721. An implementation allows reading the currentconsumerfor a given NFT (tokenId) along with a standardized event for when anconsumerhas changed. The proposal depends on and extends the existingEIP-721.", "Interface extension for EIP-721 consumer role": "This specification defines standard functions outlining aconsumerrole for instance(s) ofEIP-721. An implementation allows reading the currentconsumerfor a given NFT (tokenId) along with a standardized event for when anconsumerhas changed. The proposal depends on and extends the existingEIP-721.", "Abstract": "This specification defines standard functions outlining aconsumerrole for instance(s) ofEIP-721. An implementation allows reading the currentconsumerfor a given NFT (tokenId) along with a standardized event for when anconsumerhas changed. The proposal depends on and extends the existingEIP-721.", "Motivation": "ManyEIP-721contracts introduce their own custom role that grants permissions for utilising/consuming a given NFT instance. The need for that role stems from the fact that other than owning the NFT instance, there are other actions that can be performed on an NFT. For example, various metaverses useoperator/contributorroles for Land (EIP-721), so that owners of the land can authorise other addresses to deploy scenes to them (f.e. commissioning a service company to develop a scene).", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "Key factors influencing the standard:", "Name": "The chosen name resonates with the purpose of its existence. Consumers can be considered entities that utilise the token instances, without necessarily having ownership rights to it.", "Restriction on the Permissions": "There are numerous use-cases where a distinct role for NFTs is required that MUST NOT have owner permissions. A contract that implements the consumer role and grants ownership permissions to the consumer renders this standard pointless.", "Backwards Compatibility": "This standard is compatible with current EIP-721 standards. There are no other standards that define a similar role for NFTs and the name (consumer) is not used by other EIP-721 related standards.", "Test Cases": "Test cases are available in the reference implementationhere.", "Reference Implementation": "The reference implementation can be foundhere.", "Security Considerations": "Implementors of theEIP721Consumablestandard must consider thoroughly the permissions they give toconsumers. Even if they implement the standard correctly and do not allow transfer/burning of NFTs, they might still provide permissions to theconsumersthat they might not want to provide otherwise and should be restricted toownersonly.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4519, "url": "https://eips.ethereum.org/EIPS/eip-4519", "title": "Non-Fungible Tokens Tied to Physical Assets", "authors": ["Javier Arcenegui\u00a0(", "@Hardblock-IMSE-CNM", ")", "Rosario Arjona\u00a0(", "@RosarioArjona", ")", "Roberto Rom\u00e1n\u00a0<", "roman@imse-cnm.csic.es", ">", "Iluminada Baturone\u00a0(", "@lumi2018", ")"], "sections": {"ERC-4519: Non-Fungible Tokens Tied to Physical Assets": "This EIP standardizes an interface for non-fungible tokens representing physical assets, such as Internet of Things (IoT) devices. These NFTs are tied to physical assets and can verify the authenticity of the tie. They can include an Ethereum address of the physical asset, permitting physical assets to sign messages and transactions. Physical assets can operate with an operating mode defined by its corresponding NFT.", "Interface for non-fungible tokens representing physical assets that can generate or recover their own accounts and obey users.": "This EIP standardizes an interface for non-fungible tokens representing physical assets, such as Internet of Things (IoT) devices. These NFTs are tied to physical assets and can verify the authenticity of the tie. They can include an Ethereum address of the physical asset, permitting physical assets to sign messages and transactions. Physical assets can operate with an operating mode defined by its corresponding NFT.", "Abstract": "This EIP standardizes an interface for non-fungible tokens representing physical assets, such as Internet of Things (IoT) devices. These NFTs are tied to physical assets and can verify the authenticity of the tie. They can include an Ethereum address of the physical asset, permitting physical assets to sign messages and transactions. Physical assets can operate with an operating mode defined by its corresponding NFT.", "Motivation": "This standard was developed becauseEIP-721only tracks ownership (not usage rights) and does not track the Ethereum addresses of the asset. The popularity of smart assets, such as IoT devices, is increasing. To permit secure and traceable management, these NFTs can be used to establish secure communication channels between the physical asset, its owner, and its user.", "Specification": "The attributesaddressAssetandaddressUserare, respectively, the Ethereum addresses of the physical asset and the user. They are optional attributes but at least one of them should be used in an NFT. In the case of using only the attributeaddressUser, two states define if the token is assigned or not to a user.Figure 1shows these states in a flow chart. When a token is created, transferred or unassigned, the token state is set tonotAssigned. If the token is assigned to a valid user, the state is set touserAssigned.", "Rationale": "This EIP uses smart contracts to verify the mutual authentication process since smart contracts are trustless.", "Authentication": "This EIP uses smart contracts to verify the mutual authentication process since smart contracts are trustless.", "Tie Time": "This EIP proposes including the attribute timestamp (to register in Ethereum the last time that the physical asset checked the tie with its token) and the attribute timeout (to register the maximum delay time established for the physical asset to prove again the tie). These attributes avoid that a malicious owner or user could use the asset endlessly.", "EIP-721-based": "EIP-721is the most commonly-used standard for generic NFTs. This EIP extends EIP-721 for backwards compatibility.", "Backwards Compatibility": "This standard is an extension of EIP-721. It is fully compatible with both of the commonly used optional extensions (IERC721MetadataandIERC721Enumerable) mentioned in the EIP-721 standard.", "Test Cases": "The test cases presented in the paper shown below are availablehere.", "Reference Implementation": "A first version was presented in a paper of the Special IssueSecurity, Trust and Privacy in New Computing EnvironmentsofSensorsjournal ofMDPIeditorial. The paper, entitledSecure Combination of IoT and Blockchain by Physically Binding IoT Devices to Smart Non-Fungible Tokens Using PUFs, was written by the same authors of this EIP.", "Security Considerations": "In this EIP, a generic system has been proposed for the creation of non-fungible tokens tied to physical assets. A generic point of view based on the improvements of the current EIP-721 NFT is provided, such as the implementation of the user management mechanism, which does not affect the token\u2019s ownership. The physical asset should have the ability to generate an Ethereum address from itself in a totally random way so that only the asset is able to know the secret from which the Ethereum address is generated. In this way, identity theft is avoided and the asset can be proven to be completely genuine. In order to ensure this, it is recommended that only the manufacturer of the asset has the ability to create its associated token. In the case of an IoT device, the device firmware will be unable to share and modify the secret. Instead of storing the secrets, it is recommended that assets reconstruct their secrets from non-sensitive information such as the helper data associated with Physical Unclonable Functions (PUFs). Although a secure key exchange protocol based on elliptic curves has been proposed, the token is open to coexist with other types of key exchange.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4626, "url": "https://eips.ethereum.org/EIPS/eip-4626", "title": "Tokenized Vaults", "authors": ["Joey Santoro\u00a0(", "@joeysantoro", ")", "t11s\u00a0(", "@transmissions11", ")", "Jet Jadeja\u00a0(", "@JetJadeja", ")", "Alberto Cuesta Ca\u00f1ada\u00a0(", "@alcueca", ")", "Se\u00f1or Doggo\u00a0(", "@fubuloubu", ")"], "sections": {"ERC-4626: Tokenized Vaults": "The following standard allows for the implementation of a standard API for tokenized Vaults\nrepresenting shares of a single underlyingEIP-20token.\nThis standard is an extension on the EIP-20 token that provides basic functionality for depositing\nand withdrawing tokens and reading balances.", "Tokenized Vaults with a single underlying EIP-20 token.": "The following standard allows for the implementation of a standard API for tokenized Vaults\nrepresenting shares of a single underlyingEIP-20token.\nThis standard is an extension on the EIP-20 token that provides basic functionality for depositing\nand withdrawing tokens and reading balances.", "Abstract": "The following standard allows for the implementation of a standard API for tokenized Vaults\nrepresenting shares of a single underlyingEIP-20token.\nThis standard is an extension on the EIP-20 token that provides basic functionality for depositing\nand withdrawing tokens and reading balances.", "Motivation": "Tokenized Vaults have a lack of standardization leading to diverse implementation details.\nSome various examples include lending markets, aggregators, and intrinsically interest bearing tokens.\nThis makes integration difficult at the aggregator or plugin layer for protocols which need to conform to many standards, and forces each protocol to implement their own adapters which are error prone and waste development resources.", "Specification": "AllEIP-4626tokenized Vaults MUST implement EIP-20 to represent shares.\nIf a Vault is to be non-transferrable, it MAY revert on calls totransferortransferFrom.\nThe EIP-20 operationsbalanceOf,transfer,totalSupply, etc. operate on the Vault \u201cshares\u201d\nwhich represent a claim to ownership on a fraction of the Vault\u2019s underlying holdings.", "Definitions:": "The address of the underlying token used for the Vault for accounting, depositing, and withdrawing.", "Methods": "The address of the underlying token used for the Vault for accounting, depositing, and withdrawing.", "Events": "senderhas exchangedassetsforshares, and transferred thosesharestoowner.", "Rationale": "The Vault interface is designed to be optimized for integrators with a feature complete yet minimal interface.\nDetails such as accounting and allocation of deposited tokens are intentionally not specified,\nas Vaults are expected to be treated as black boxes on-chain and inspected off-chain before use.", "Backwards Compatibility": "EIP-4626 is fully backward compatible with the EIP-20 standard and has no known compatibility issues with other standards.\nFor production implementations of Vaults which do not use EIP-4626, wrapper adapters can be developed and used.", "Reference Implementation": "SeeSolmate EIP-4626:\na minimal and opinionated implementation of the standard with hooks for developers to easily insert custom logic into deposits and withdrawals.", "Security Considerations": "Fully permissionless use cases could fall prey to malicious implementations which only conform to the interface but not the specification.\nIt is recommended that all integrators review the implementation for potential ways of losing user deposits before integrating.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- withdrawal: Log entry in system_logs for tracking withdrawals under EIP-4895 .\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4804, "url": "https://eips.ethereum.org/EIPS/eip-4804", "title": "Web3 URL to EVM Call Message Translation", "authors": ["Qi Zhou\u00a0(", "@qizhou", ")", "Chao Pi\u00a0(", "@pichaoqkc", ")", "Sam Wilson\u00a0(", "@SamWilsn", ")"], "sections": {"ERC-4804: Web3 URL to EVM Call Message Translation": "This standard translates an RFC 2396 URI likeweb3://uniswap.eth/to an EVM message such as:", "A translation of an HTTP-style Web3 URL to an EVM call message": "This standard translates an RFC 2396 URI likeweb3://uniswap.eth/to an EVM message such as:", "Abstract": "This standard translates an RFC 2396 URI likeweb3://uniswap.eth/to an EVM message such as:", "Motivation": "Currently, reading data from Web3 generally relies on a translation done by a Web2 proxy to Web3 blockchain. The translation is mostly done by the proxies such as dApp websites/node service provider/etherscan, which are out of the control of users. The standard here aims to provide a simple way for Web2 users to directly access the content of Web3, especially on-chain Web contents such as SVG/HTML.  Moreover, this standard enables interoperability with other standards already compatible with URIs, like SVG/HTML.", "Specification": "This specification only defines read-only (i.e. Solidity\u2019sviewfunctions) semantics. State modifying functions may be defined as a future extension.", "Resolve Mode": "Once the \u201cTo\u201d address and chainid are determined, the protocol will check the resolver mode of contract by calling \u201cresolveMode\u201d method. The protocol currently supports two resolve modes:", "Examples": "The protocol will find the address ofw3url.ethfrom ENS in chainid 1 (Mainnet), and then the protocol will call the address with \u201cFrom\u201d = \u201c0x\u2026\u201d and \u201cCalldata\u201d = \u201c0x2F\u201d.", "Rationale": "The purpose of the proposal is to add a decentralized presentation layer for Ethereum.  With the layer, we are able to render any web content (including HTML/CSS/JPG/PNG/SVG, etc) on-chain using human-readable URLs, and thus EVM can be served as decentralized Backend.  The design of the standard is based on the following principles:", "Security Considerations": "No security considerations were found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4834, "url": "https://eips.ethereum.org/EIPS/eip-4834", "title": "Hierarchical Domains", "authors": ["Gavin John\u00a0(", "@Pandapip1", ")"], "sections": {"ERC-4834: Hierarchical Domains": "This is a standard for generic name resolution with arbitrarily complex access control and resolution. It permits a contract that implements this EIP (referred to as a \u201cdomain\u201d hereafter) to be addressable with a more human-friendly name, with a similar purpose toERC-137(also known as \u201cENS\u201d).", "Extremely generic name resolution": "This is a standard for generic name resolution with arbitrarily complex access control and resolution. It permits a contract that implements this EIP (referred to as a \u201cdomain\u201d hereafter) to be addressable with a more human-friendly name, with a similar purpose toERC-137(also known as \u201cENS\u201d).", "Abstract": "This is a standard for generic name resolution with arbitrarily complex access control and resolution. It permits a contract that implements this EIP (referred to as a \u201cdomain\u201d hereafter) to be addressable with a more human-friendly name, with a similar purpose toERC-137(also known as \u201cENS\u201d).", "Motivation": "The advantage of this EIP over existing standards is that it provides a minimal interface that supports name resolution, adds standardized access control, and has a simple architecture. ENS, although useful, has a comparatively complex architecture and does not have standard access control.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Contract Interface": "To resolve a name (like\"a.b.c\"), split it by the delimiter (resulting in something like[\"a\", \"b\", \"c\"]). Setdomaininitially to the root domain, andpathto be an empty list.", "Name Resolution": "To resolve a name (like\"a.b.c\"), split it by the delimiter (resulting in something like[\"a\", \"b\", \"c\"]). Setdomaininitially to the root domain, andpathto be an empty list.", "Optional Extension: Registerable": "This EIP\u2019s goal, as mentioned in the abstract, is to have a simple interface for resolving names. Here are a few design decisions and why they were made:", "Optional Extension: Enumerable": "This EIP\u2019s goal, as mentioned in the abstract, is to have a simple interface for resolving names. Here are a few design decisions and why they were made:", "Optional Extension: Access Control": "This EIP\u2019s goal, as mentioned in the abstract, is to have a simple interface for resolving names. Here are a few design decisions and why they were made:", "Rationale": "This EIP\u2019s goal, as mentioned in the abstract, is to have a simple interface for resolving names. Here are a few design decisions and why they were made:", "Backwards Compatibility": "This EIP is general enough to support ENS, but ENS is not general enough to support this EIP.", "Security Considerations": "Moving a subdomain usingsetDomainis a potentially dangerous operation.", "Malicious canMoveSubdomain (Black Hole)": "Moving a subdomain usingsetDomainis a potentially dangerous operation.", "Parent Domain Resolution": "Parent domains have full control of name resolution for their subdomains. If a particular domain is linked toa.b.c, thenb.ccan, depending on its code, seta.b.cto any domain, andccan setb.citself to any domain.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4906, "url": "https://eips.ethereum.org/EIPS/eip-4906", "title": "EIP-721 Metadata Update Extension", "authors": ["Anders\u00a0(", "@0xanders", ")", "Lance\u00a0(", "@LanceSnow", ")", "Shrug\u00a0<", "shrug@emojidao.org", ">", "Nathan\u00a0<", "nathan.gang@gemini.com", ">"], "sections": {"ERC-4906: EIP-721 Metadata Update Extension": "This standard is an extension ofEIP-721. It adds aMetadataUpdateevent to EIP-721 tokens.", "Add a MetadataUpdate event to EIP-721.": "This standard is an extension ofEIP-721. It adds aMetadataUpdateevent to EIP-721 tokens.", "Abstract": "This standard is an extension ofEIP-721. It adds aMetadataUpdateevent to EIP-721 tokens.", "Motivation": "ManyEIP-721contracts emit an event when one of its tokens\u2019 metadata are changed. While tracking changes based on these different events is possible, it is an extra effort for third-party platforms, such as an NFT marketplace, to build individualized solutions for each NFT collection.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "Different NFTs have different metadata, and metadata generally has multiple fields.bytes datacould be used to represents the modified value of metadata.  It is difficult for third-party platforms to identify various types ofbytes data, so as to avoid unnecessary complexity, arbitrary metadata is not included in theMetadataUpdateevent.", "Backwards Compatibility": "No backwards compatibility issues were found", "Reference Implementation": "If there is an off-chain modification of metadata, a method that triggersMetadataUpdatecan be added, but ensure that the function\u2019s permission controls are correct.", "Security Considerations": "If there is an off-chain modification of metadata, a method that triggersMetadataUpdatecan be added, but ensure that the function\u2019s permission controls are correct.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4907, "url": "https://eips.ethereum.org/EIPS/eip-4907", "title": "Rental NFT, an Extension of EIP-721", "authors": ["Anders\u00a0(", "@0xanders", ")", "Lance\u00a0(", "@LanceSnow", ")", "Shrug\u00a0<", "shrug@emojidao.org", ">"], "sections": {"ERC-4907: Rental NFT, an Extension of EIP-721": "This standard is an extension ofEIP-721. It proposes an additional role (user) which can be granted to addresses, and a time where the role is automatically revoked (expires). Theuserrole represents permission to \u201cuse\u201d the NFT, but not the ability to transfer it or set users.", "Add a time-limited role with restricted permissions to EIP-721 tokens.": "This standard is an extension ofEIP-721. It proposes an additional role (user) which can be granted to addresses, and a time where the role is automatically revoked (expires). Theuserrole represents permission to \u201cuse\u201d the NFT, but not the ability to transfer it or set users.", "Abstract": "This standard is an extension ofEIP-721. It proposes an additional role (user) which can be granted to addresses, and a time where the role is automatically revoked (expires). Theuserrole represents permission to \u201cuse\u201d the NFT, but not the ability to transfer it or set users.", "Motivation": "Some NFTs have certain utilities. For example, virtual land can be \u201cused\u201d to build scenes, and NFTs representing game assets can be \u201cused\u201d in-game. In some cases, the owner and user may not always be the same. There may be an owner of the NFT that rents it out to a \u201cuser\u201d. The actions that a \u201cuser\u201d should be able to take with an NFT would be different from the \u201cowner\u201d (for instance, \u201cusers\u201d usually shouldn\u2019t be able to sell ownership of the NFT).\u00a0 In these situations, it makes sense to have separate roles that identify whether an address represents an \u201cowner\u201d or a \u201cuser\u201d and manage permissions to perform actions accordingly.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Contract Interface": "Solidity Interface with NatSpec & OpenZeppelin v4 Interfaces (also available atIERC4907.sol):", "Rationale": "This model is intended to facilitate easy implementation. Here are some of the problems that are solved by this standard:", "Clear Rights Assignment": "With Dual \u201cowner\u201d and \u201cuser\u201d roles, it becomes significantly easier to manage what lenders and borrowers can and cannot do with the NFT (in other words, their rights).\u00a0Additionally, owners can control who the user is and it\u2019s easy for other projects to assign their own rights to either the owners or the users.", "Simple On-chain Time Management": "Once a rental period is over, the user role needs to be reset and the \u201cuser\u201d has to lose access to the right to use the NFT. This is usually accomplished with a second on-chain transaction but that is gas inefficient and can lead to complications because it\u2019s imprecise. With theexpiresfunction, there is no need for another transaction because the \u201cuser\u201d is invalidated automatically after the duration is over.", "Easy Third-Party Integration": "In the spirit of permission less interoperability, this standard makes it easier for third-party protocols to manage NFT usage rights without permission from the NFT issuer or the NFT application. Once a project has adopted the additionaluserrole andexpires, any other project can directly interact with these features and implement their own type of transaction. For example, a PFP NFT using this standard can be integrated into both a rental platform where users can rent the NFT for 30 days AND, at the same time, a mortgage platform where users can use the NFT while eventually buying ownership of the NFT with installment payments. This would all be done without needing the permission of the original PFP project.", "Backwards Compatibility": "As mentioned in the specifications section, this standard can be fully EIP-721 compatible by adding an extension function set.", "Test Cases": "ERC4907DemoImplementation:ERC4907Demo.sol", "Test Contract": "ERC4907DemoImplementation:ERC4907Demo.sol", "Test Code": "test.js", "Reference Implementation": "Implementation:ERC4907.sol", "Security Considerations": "This EIP standard can completely protect the rights of the owner, the owner can change the NFT user and expires at any time.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4910, "url": "https://eips.ethereum.org/EIPS/eip-4910", "title": "Royalty Bearing NFTs", "authors": ["Andreas Freund\u00a0(", "@Therecanbeonlyone1969", ")"], "sections": {"ERC-4910: Royalty Bearing NFTs": "The proposal directly connects NFTs and royalties in a smart contract architecture extending theERC-721standard, with the aim of precluding central authorities from manipulating or circumventing payments to those who are legally entitled to them.", "Extension of ERC-721 to correctly define, process, and pay (hierarchical) onchain NFT royalties.": "The proposal directly connects NFTs and royalties in a smart contract architecture extending theERC-721standard, with the aim of precluding central authorities from manipulating or circumventing payments to those who are legally entitled to them.", "Abstract": "The proposal directly connects NFTs and royalties in a smart contract architecture extending theERC-721standard, with the aim of precluding central authorities from manipulating or circumventing payments to those who are legally entitled to them.", "Motivation": "The management of royalties is an age-old problem characterized by complex contracts, opaque management, plenty of cheating and fraud.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Outline": "This proposal introduces several new concepts as extensions to the ERC-721 standard that warrant explanation:", "Data Structures": "In order to create an interconnected data structure linking NFTs to RAs that is search optimized requires to make the following additions to the global data structures of an ERC-721.", "Royalty Account Management": "Below are the definitions and interfaces for the Royalty Account RUD (Read-Update-Delete) functions. Since a Royalty Account is created in the NFT minting function, there is no need to have a separate function to create a royalty account.", "NFT Minting": "In extension to the ERC-721 minting capability, a Royalty Account with Royalty Sub Accounts are required to be added during the minting, besides establishing the NFT token specific data structures supporting constraints such as the maximum number of children an NFT can have.", "Listing and De-Listing of NFTs for Direct Sales": "In the sales process, we need to minimally distinguish two types of transactions", "Payments for NFT Sales": "As noted before, a buyer will always pay the NFT contract directly and not the seller. The seller is paid through the royalty distribution and can later request a payout to their wallet.", "Modified NFT Transfer function": "This document adheres to the ERC-721 interface format for thesafeTransferFromfunction as given below:", "Distributing Royalties in the Transfer Function": "The approach to distributing royalties is to break down the hierarchical structure of interconnected Royalty Accounts into layers, and then process one layer at time, where each relationship between a NFT and its ancestor is utilized to traverse the Royalty Account chain until the root ancestor and its associated Royalty Account.", "Update Royalty Sub Account Ownership with Payout to approved Address (from)": "In order to simplify the ownership transfer, first the approved address \u2013 the non-contract NFT owner \u2013,from, is paid out its share of the royalties. And then the Royalty Sub Account is updated with the new owner,to. This step repeats for each token to be transferred.", "Removing the Payment Entry after successful Transfer": "Only after the real ownership of the NFT, the approved address, has been updated, the payment registry entry can be removed to allow the transferred NFTs to be sold again.", "Paying out Royalties to thefromAddress insafeTransferFromFunction": "There are two versions of the payout function \u2013 apublicand aninternalfunction \u2013 depending on whether there is a payout during a purchase, or a payout is requested by a Royalty Sub Account owner.", "Rationale": "Royalties for NFTs is at its core a distribution licensing problem. A buyer obtains the right to an asset/content which might or might not be reproducible, alterable etc. by the buyer or agents of the buyer. Therefore, a comprehensive specification must address a hierarchy of royalties, where one or more assets are derived from an original asset as described in the Motivation section in detail. Consequently, a design must solve for a multi-level inheritance, and thus, recursion problem.", "Backwards Compatibility": "This EIP is backwards compatible to the ERC-721 standard introducing new interfaces and functionality but retaining the core interfaces and functionality of the ERC-721 standard.", "Test Cases": "A full test suite is part of the reference implementation.", "Reference Implementation": "The Treetrunk reference implementation of the standard can be found in the public treetrunkio Github repo under treetrunk-nft-reference-implementation.", "Security Considerations": "Given that this EIP introduces royalty collection, distribution, and payouts to the ERC-721 standard, the number of attack vectors increases. The most important attack vector categories and their mitigation are discussed below:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4955, "url": "https://eips.ethereum.org/EIPS/eip-4955", "title": "Vendor Metadata Extension for NFTs", "authors": ["Ignacio Mazzara\u00a0(", "@nachomazzara", ")"], "sections": {"ERC-4955: Vendor Metadata Extension for NFTs": "This EIP standardizes a schema for NFTs metadata to add new field namespaces to the JSON schema forEIP-721andEIP-1155NFTs.", "Add a new field to NFT metadata to store vendor specific data": "This EIP standardizes a schema for NFTs metadata to add new field namespaces to the JSON schema forEIP-721andEIP-1155NFTs.", "Abstract": "This EIP standardizes a schema for NFTs metadata to add new field namespaces to the JSON schema forEIP-721andEIP-1155NFTs.", "Motivation": "A standardized NFT metadata schema allows wallets, marketplaces, metaverses, and similar applications to interoperate with any NFT. Applications such as NFT marketplaces and metaverses could usefully leverage NFTs by rendering them using custom 3D representations or any other new attributes.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Schema": "(subject to \u201ccaveats\u201d below)", "Example": "There are many projects which need custom properties in order to display a current NFT. Each project may have its own way to render the NFTs and therefore they need different values. An example of this is the metaverses like Decentraland or TheSandbox where they need different 3d models to render the NFT based on the visual/engine of each. NFTs projects like Cryptopunks, Bored Apes, etc. can create the 3d models needed for each project and therefore be supported out of the box.", "Rationale": "There are many projects which need custom properties in order to display a current NFT. Each project may have its own way to render the NFTs and therefore they need different values. An example of this is the metaverses like Decentraland or TheSandbox where they need different 3d models to render the NFT based on the visual/engine of each. NFTs projects like Cryptopunks, Bored Apes, etc. can create the 3d models needed for each project and therefore be supported out of the box.", "Armatures": "Every metaverse uses its own armature. There is a standard for humanoids but it is not being used for every metaverse and not all the metaverses use humanoids. For example, Decentraland has a different aesthetic than Cryptovoxels and TheSandbox. It means that every metaverse will need a different model and they may have the same extension (GLB, GLTF)", "Metadata (Representations Files)": "For example, every metaverse uses its own metadata representation files to make it work inside the engine depending on its game needs.", "Backwards Compatibility": "Existing projects that can\u2019t modify the metadata response (schema), may be able to create a new smart contract that based on thetokenIdreturns the updated metadata schema. Of course, the projects may need to accept these linked smart contracts as valid in order to fetch the metadata by thetokenURIfunction.", "Security Considerations": "The same security considerations as withEIP-721apply related to using http gateways or IPFS for the tokenURI method.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5006, "url": "https://eips.ethereum.org/EIPS/eip-5006", "title": "Rental NFT, NFT User Extension", "authors": ["Lance\u00a0(", "@LanceSnow", ")", "Anders\u00a0(", "@0xanders", ")", "Shrug\u00a0<", "shrug@emojidao.org", ">"], "sections": {"ERC-5006: Rental NFT, NFT User Extension": "This standard is an extension ofERC-1155. It proposes an additional role (user) which can be granted to addresses that represent auserof the assets rather than anowner.", "Add a user role with restricted permissions to ERC-1155 tokens": "This standard is an extension ofERC-1155. It proposes an additional role (user) which can be granted to addresses that represent auserof the assets rather than anowner.", "Abstract": "This standard is an extension ofERC-1155. It proposes an additional role (user) which can be granted to addresses that represent auserof the assets rather than anowner.", "Motivation": "LikeERC-721,ERC-1155tokens may have utility of some kind. The people who \u201cuse\u201d the token may be different than the people who own it (such as in a rental). Thus, it would be useful to have separate roles for the \u201cowner\u201d and the \u201cuser\u201d so that the \u201cuser\u201d would not be able to take actions that the owner could (for example, transferring ownership).", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "This model is intended to facilitate easy implementation. The following are some problems that are solved by this standard:", "Clear Rights Assignment": "With Dual \u201cowner\u201d and \u201cuser\u201d roles, it becomes significantly easier to manage what lenders and borrowers can and cannot do with the NFT (in other words, their rights).\u00a0 For example, for the right to transfer ownership,\u00a0the project simply needs to check whether the address taking the action represents the owner or the user and prevent the transaction if it is the user.\u00a0 Additionally, owners can control who the user is and it is easy for other projects to assign their own rights to either the owners or the users.", "Easy Third-Party Integration": "In the spirit of permissionless interoperability, this standard makes it easier for third-party protocols to manage NFT usage rights without permission from the NFT issuer or the NFT application. Once a project has adopted the additionaluserrole, any other project can directly interact with these features and implement their own type of transaction. For example, a PFP NFT using this standard can be integrated into both a rental platform where users can rent the NFT for 30 days AND, at the same time, a mortgage platform where users can use the NFT while eventually buying ownership of the NFT with installment payments. This would all be done without needing the permission of the original PFP project.", "Backwards Compatibility": "As mentioned in the specifications section, this standard can be fully ERC compatible by adding an extension function set, and there are no conflicts betweenERC-5006and ERC-1155.", "Test Cases": "Test cases are included intest.js.", "Reference Implementation": "SeeERC5006.sol.", "Security Considerations": "This EIP standard can completely protect the rights of the owner, the owner can change the NFT user, the user can not transfer the NFT.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5007, "url": "https://eips.ethereum.org/EIPS/eip-5007", "title": "Time NFT, ERC-721 Time Extension", "authors": ["Anders\u00a0(", "@0xanders", ")", "Lance\u00a0(", "@LanceSnow", ")", "Shrug\u00a0<", "shrug@emojidao.org", ">"], "sections": {"ERC-5007: Time NFT, ERC-721 Time Extension": "This standard is an extension ofERC-721. It proposes some additional functions (startTime,endTime) to help with on-chain time management.", "Add start time and end time to ERC-721 tokens.": "This standard is an extension ofERC-721. It proposes some additional functions (startTime,endTime) to help with on-chain time management.", "Abstract": "This standard is an extension ofERC-721. It proposes some additional functions (startTime,endTime) to help with on-chain time management.", "Motivation": "Some NFTs have a defined usage period and cannot be used outside of that period. With traditional NFTs that do not include time information, if you want to mark a token as invalid or enable it at a specific time, you need to actively submit a transaction\u2014a process both cumbersome and expensive.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "The max value ofuint64is 18,446,744,073,709,551,615. As a timestamp, 18,446,744,073,709,551,615 is about year 584,942,419,325.uint256is too big for C, C++, Java, Go, etc, anduint64is natively supported by mainstream programming languages.", "Time Data Type": "The max value ofuint64is 18,446,744,073,709,551,615. As a timestamp, 18,446,744,073,709,551,615 is about year 584,942,419,325.uint256is too big for C, C++, Java, Go, etc, anduint64is natively supported by mainstream programming languages.", "Backwards Compatibility": "This standard is fully ERC-721 compatible.", "Test Cases": "Test cases are included intest.js.", "Reference Implementation": "SeeERC5007.sol.", "Security Considerations": "No security issues found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5023, "url": "https://eips.ethereum.org/EIPS/eip-5023", "title": "Shareable Non-Fungible Token", "authors": ["Jarno Marttila\u00a0(", "@yaruno", ")", "Martin Moravek\u00a0(", "@mmartinmo", ")"], "sections": {"ERC-5023: Shareable Non-Fungible Token": "This EIP standardizes an interface for non-fungible value-holding shareable tokens. Shareability is accomplished by minting copies of existing tokens for new recipients. Sharing and associated events allow the construction of a graph describing who has shared what to which party.", "An interface for creating value-holding tokens shareable by multiple owners": "This EIP standardizes an interface for non-fungible value-holding shareable tokens. Shareability is accomplished by minting copies of existing tokens for new recipients. Sharing and associated events allow the construction of a graph describing who has shared what to which party.", "Abstract": "This EIP standardizes an interface for non-fungible value-holding shareable tokens. Shareability is accomplished by minting copies of existing tokens for new recipients. Sharing and associated events allow the construction of a graph describing who has shared what to which party.", "Motivation": "NFT standards such asEIP-721andEIP-1155have been developed to standardize scarce digital resources. However, many non-fungible digital resources need not be scarce.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "Current NFT standards define transferable non-fungible tokens, but not shareable non-fungible tokens. To be able to create shareable NFTs we see that existing NFT contracts could be extended with an interface which defines the basic principles of sharing, namely the Event of sharing and the function method of sharing. Definition of how transferability of tokens should be handled is left to the contract implementor. In case transferring is left enable shareable tokens behave similarly to the existing tokens, except when they are shared, a version of token is retained. In case transfering is disabled, shareable tokens become shareable non-transferable tokens, where they can be minted and given or shared to other people, but they cannot be transferred away.", "Backwards Compatibility": "This proposal is backwards compatible with EIP-721 and EIP-1155.", "Reference Implementation": "Following reference implementation demonstrates a general use case of one of our pilots. In this case a shareable non-transferable token represents a contribution done to a community that the contract owner has decided to merit with a token. Contract owner can mint a merit token and give it to a person. This token can be further shared by the receiver to other parties for example to share the received merit to others that have participated or influenced his contribution.", "Security Considerations": "Reference implementation should not be used as is in production.\nThere are no other security considerations related directly to implementation of this standard.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5169, "url": "https://eips.ethereum.org/EIPS/eip-5169", "title": "Client Script URI for Token Contracts", "authors": ["James\u00a0(", "@JamesSmartCell", ")", "Weiwu\u00a0(", "@weiwu-zhang", ")"], "sections": {"ERC-5169: Client Script URI for Token Contracts": "This EIP provides a contract interface adding ascriptURI()function for locating executable scripts associated with the token.", "Add a scriptURI to point to an executable script associated with the functionality of the token.": "This EIP provides a contract interface adding ascriptURI()function for locating executable scripts associated with the token.", "Abstract": "This EIP provides a contract interface adding ascriptURI()function for locating executable scripts associated with the token.", "Motivation": "Often, smart contract authors want to provide some user functionality to their tokens through client scripts. The idea is made popular with function-rich NFTs. It\u2019s important that a token\u2019s contract is linked to its client script, since the client script may carry out trusted tasks such as creating transactions for the user.", "Overview": "With the discussion above in mind, we outline the solution proposed by this EIP. For this purpose, we consider the following variables:", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "This method avoids the need for building secure and certified centralized hosting and allows scripts to be hosted anywhere: IPFS, GitHub or cloud storage.", "Backwards Compatibility": "This standard is backwards-compatible with most existing token standards, including the following commonly-used ones:", "Test Cases": "An intuitive implementation is the STL office door token. This NFT is minted and transferred to STL employees. The TokenScript attached to the token contract via thescriptURI()function contains instructions on how to operate the door interface. This takes the form of:", "Test Contract": "An intuitive implementation is the STL office door token. This NFT is minted and transferred to STL employees. The TokenScript attached to the token contract via thescriptURI()function contains instructions on how to operate the door interface. This takes the form of:", "Reference Implementation": "An intuitive implementation is the STL office door token. This NFT is minted and transferred to STL employees. The TokenScript attached to the token contract via thescriptURI()function contains instructions on how to operate the door interface. This takes the form of:", "Script location": "While the most straightforward solution to facilitate specific script usage associated with NFTs, is clearly to store such a script on the smart contract. However, this has several disadvantages:", "Security Considerations": "When a server is involved", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5192, "url": "https://eips.ethereum.org/EIPS/eip-5192", "title": "Minimal Soulbound NFTs", "authors": ["Tim Daubensch\u00fctz\u00a0(", "@TimDaub", ")", "Anders\u00a0(", "@0xanders", ")"], "sections": {"ERC-5192: Minimal Soulbound NFTs": "This standard is an extension ofEIP-721. It proposes a minimal interface to make tokens soulbound using the feature detection functionality ofEIP-165. A soulbound token is a non-fungible token bound to a single account.", "Minimal interface for soulbinding EIP-721 NFTs": "This standard is an extension ofEIP-721. It proposes a minimal interface to make tokens soulbound using the feature detection functionality ofEIP-165. A soulbound token is a non-fungible token bound to a single account.", "Abstract": "This standard is an extension ofEIP-721. It proposes a minimal interface to make tokens soulbound using the feature detection functionality ofEIP-165. A soulbound token is a non-fungible token bound to a single account.", "Motivation": "The Ethereum community has expressed a need for non-transferrable, non-fungible, and socially-priced tokens similar to World of Warcraft\u2019s soulbound items. But the lack of a token standard leads many developers to simply throw errors upon a user\u2019s invocation of transfer functionalities. Over the long term, this will lead to fragmentation and less composability.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Contract Interface": "A token with auint256 tokenIdmay be bound to a receiving account withfunction locked(...)returningtrue. In this case, allEIP-721functions of the contract that transfer the token from one account to another must throw.", "Rationale": "The above model is the simplest possible path towards a canonical interface for Soulbound tokens. It reflects upon the numerous Soulbound token implementations that simply revert upon transfers.", "Backwards Compatibility": "This proposal is fully backward compatible withEIP-721.", "Security Considerations": "There are no security considerations related directly to the implementation of this standard.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5202, "url": "https://eips.ethereum.org/EIPS/eip-5202", "title": "Blueprint contract format", "authors": ["Charles Cooper\u00a0(", "@charles-cooper", ")", "Edward Amor\u00a0(", "@skellet0r", ")"], "sections": {"ERC-5202: Blueprint contract format": "Define a standard for \u201cblueprint\u201d contracts, or contracts which represent initcode that is stored on-chain.", "Define a bytecode container format for indexing and utilizing blueprint contracts": "Define a standard for \u201cblueprint\u201d contracts, or contracts which represent initcode that is stored on-chain.", "Abstract": "Define a standard for \u201cblueprint\u201d contracts, or contracts which represent initcode that is stored on-chain.", "Motivation": "To decrease deployer contract size, a useful pattern is to store initcode on chain as a \u201cblueprint\u201d contract, and then useEXTCODECOPYto copy the initcode into memory, followed by a call toCREATEorCREATE2. However, this comes with the following problems:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "No known issues", "Backwards Compatibility": "No known issues", "Test Cases": "Here, 0xFE71 is the magic header,0x01means version 0 + 1 length bit,0x07encodes the length in bytes of the data section. These are followed by the data section, and then the initcode. For illustration, the above code with delimiters would be0xFE71|01|07|FFFFFFFFFFFFFF|00.", "Reference Implementation": "The following reference function takes the desired initcode for a blueprint as a parameter, and returns EVM code which will deploy a corresponding blueprint contract (with no data section):", "Security Considerations": "There could be contracts on-chain already which happen to start with the same prefix as proposed in this ERC. However, this is not considered a serious risk, because the way it is envisioned that indexers will use this is to verify source code by compiling it and prepending the preamble.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- magic: A constant value set as 0xef0100 used in the CREATE_DELEGATE instruction.\n- initcode: The code executed by a contract at its initialization, which must be within 49152 bytes in size before EIP-3860."}
{"eip": 5219, "url": "https://eips.ethereum.org/EIPS/eip-5219", "title": "Contract Resource Requests", "authors": ["Gavin John\u00a0(", "@Pandapip1", ")"], "sections": {"ERC-5219: Contract Resource Requests": "This EIP standardizes an interface to make resource requests to smart contracts and to receive HTTP-like responses.", "Allows the requesting of resources from contracts": "This EIP standardizes an interface to make resource requests to smart contracts and to receive HTTP-like responses.", "Abstract": "This EIP standardizes an interface to make resource requests to smart contracts and to receive HTTP-like responses.", "Motivation": "Ethereum is the most-established blockchain for building decentralized applications (referred to asDApps). Due to this, the Ethereum DApp ecosystem is very diverse. However, one issue that plagues DApps is the fact that they are not fully decentralized. Specifically, to interface a \u201cdecentralized\u201d application, one first needs to access acentralizedwebsite containing the DApp\u2019s front-end code, presenting a few issues. The following are some risks associated with using centralized websites to interface with decentralized applications:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Name Resolution": "EIPs that propose a name resolution mechanism MAY reference this EIP and MAY recommend that clients support their mechanism. Clients MAY also support regular DNS, as defined in RFC 1034 and RFC 1035.", "Separation of Concerns": "It is RECOMMENDED to separate the application logic from the front-end logic (the contract implementing the interface defined inContract Interface).", "Contract Interface": "DApp contracts MUST implement the interface defined in the following file:Contract Interface.", "Note to Implementers": "To save gas costs, it is recommended to use themessage/external-bodyMIME-type, which allows you to point to data that the smart contract might not have access to. For example, the following response would tell a client to fetch the data off of IPFS:", "Rationale": "Therequestmethod was chosen to be readonly because all data should be sent to the contract from the parsed DApp. Here are some reasons why:", "Backwards Compatibility": "This EIP is backwards compatible with all standards listed in theName Resolutionsection.", "Security Considerations": "The normal security considerations of accessing normal URLs apply here, such as potential privacy leakage by following3XXredirects.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5267, "url": "https://eips.ethereum.org/EIPS/eip-5267", "title": "Retrieval of EIP-712 domain", "authors": ["Francisco Giordano\u00a0(", "@frangio", ")"], "sections": {"ERC-5267: Retrieval of EIP-712 domain": "This EIP complementsEIP-712by standardizing how contracts should publish the fields and values that describe their domain. This enables applications to retrieve this description and generate appropriate domain separators in a general way, and thus integrate EIP-712 signatures securely and scalably.", "A way to describe and retrieve an EIP-712 domain to securely integrate EIP-712 signatures.": "This EIP complementsEIP-712by standardizing how contracts should publish the fields and values that describe their domain. This enables applications to retrieve this description and generate appropriate domain separators in a general way, and thus integrate EIP-712 signatures securely and scalably.", "Abstract": "This EIP complementsEIP-712by standardizing how contracts should publish the fields and values that describe their domain. This enables applications to retrieve this description and generate appropriate domain separators in a general way, and thus integrate EIP-712 signatures securely and scalably.", "Motivation": "EIP-712 is a signature scheme for complex structured messages. In order to avoid replay attacks and mitigate phishing, the scheme includes a \u201cdomain separator\u201d that makes the resulting signature unique to a specific domain (e.g., a specific contract) and allows user-agents to inform end users the details of what is being signed and how it may be used. A domain is defined by a data structure with fields from a predefined set, all of which are optional, or from extensions. Notably, EIP-712 does not specify any way for contracts to publish which of these fields they use or with what values. This has likely limited adoption of EIP-712, as it is not possible to develop general integrations, and instead applications find that they need to build custom support for each EIP-712 domain. A prime example of this isEIP-2612(permit), which has not been widely adopted by applications even though it is understood to be a valuable improvement to the user experience. The present EIP defines an interface that can be used by applications to retrieve a definition of the domain that a contract uses to verify EIP-712 signatures.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "A notable application of EIP-712 signatures is found in EIP-2612 (permit), which specifies aDOMAIN_SEPARATORfunction that returns abytes32value (the actual domain separator, i.e., the result ofhashStruct(eip712Domain)). This value does not suffice for the purposes of integrating with EIP-712, as the RPC methods defined there receive an object describing the domain and not just the separator in hash form. Note that this is not a flaw of the RPC methods, it is indeed part of the security proposition that the domain should be validated and informed to the user as part of the signing process. On its own, a hash does not allow this to be implemented, given it is opaque. The present EIP fills this gap in both EIP-712 and EIP-2612.", "Backwards Compatibility": "This is an optional extension to EIP-712 that does not introduce backwards compatibility issues.", "Reference Implementation": "This contract\u2019s domain only uses the fieldsname,chainId, andverifyingContract, therefore thefieldsvalue is01101, or0din hexadecimal.", "Solidity Example": "This contract\u2019s domain only uses the fieldsname,chainId, andverifyingContract, therefore thefieldsvalue is01101, or0din hexadecimal.", "JavaScript": "A domain object can be constructed based on the return values of aneip712Domain()invocation.", "Security Considerations": "While this EIP allows a contract to specify averifyingContractother than itself, as well as achainIdother than that of the current chain, user-agents and applications should in general validate that these do match the contract and chain before requesting any user signatures for the domain. This may not always be a valid assumption.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5313, "url": "https://eips.ethereum.org/EIPS/eip-5313", "title": "Light Contract Ownership", "authors": ["William Entriken\u00a0(", "@fulldecent", ")"], "sections": {"ERC-5313: Light Contract Ownership": "This specification defines the minimum interface required to identify an account that controls a contract.", "An interface for identifying ownership of contracts": "This specification defines the minimum interface required to identify an account that controls a contract.", "Abstract": "This specification defines the minimum interface required to identify an account that controls a contract.", "Motivation": "This is a slimmed-down alternative toEIP-173.", "Specification": "The key word \u201cMUST\u201d in this document is to be interpreted as described in RFC 2119.", "Rationale": "Key factors influencing the standard:", "Backwards Compatibility": "Every contract that implements EIP-173 already implements this specification.", "Security Considerations": "Because this specification does not extend EIP-165, calling this EIP\u2019sownerfunction cannot result in complete certainty that the result is indeed the owner. For example, another function with the same function signature may return some value that is then interpreted to be the true owner. If this EIP is used solely to identify if an account is the owner of a contract, then the impact of this risk is minimized. But if the interrogator is, for example, sending a valuable NFT to the identified owner of any contract on the network, then the risk is heightened.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5375, "url": "https://eips.ethereum.org/EIPS/eip-5375", "title": "NFT Author Information and Consent", "authors": ["Samuele Marro\u00a0(", "@samuelemarro", ")", "Luca Donno\u00a0(", "@lucadonnoh", ")"], "sections": {"ERC-5375: NFT Author Information and Consent": "This EIP standardizes a JSON format for storing off-chain information about NFT authors. Specifically, it adds a new field which provides a list of author names, addresses, and proofs ofauthorship consent: proofs that the authors have agreed to be named as authors. Note that a proof of authorshipconsentis not a proof of authorship: an address can consent without having authored the NFT.", "An extension of EIP-721 for NFT authorship and author consent.": "This EIP standardizes a JSON format for storing off-chain information about NFT authors. Specifically, it adds a new field which provides a list of author names, addresses, and proofs ofauthorship consent: proofs that the authors have agreed to be named as authors. Note that a proof of authorshipconsentis not a proof of authorship: an address can consent without having authored the NFT.", "Abstract": "This EIP standardizes a JSON format for storing off-chain information about NFT authors. Specifically, it adds a new field which provides a list of author names, addresses, and proofs ofauthorship consent: proofs that the authors have agreed to be named as authors. Note that a proof of authorshipconsentis not a proof of authorship: an address can consent without having authored the NFT.", "Motivation": "There is currently no standard to identify authors of an NFT, and existing techniques have issues:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Definitions": "The standard introduces a new JSON field, namedauthorInfo. It provides a REQUIRED interface for authorship claiming, as well as an OPTIONAL interface for author consent proofs.", "Authorship Support": "The standard introduces a new JSON field, namedauthorInfo. It provides a REQUIRED interface for authorship claiming, as well as an OPTIONAL interface for author consent proofs.", "Author Consent": "Consent is obtained by signing anEIP-712compatible message. Specifically, the structure is defined as follows:", "Author Consent Verification": "Verification is performed using EIP-712 on an author-by-author basis. Specifically, given a JSON document D1, a consent proof is valid if all of the following statements are true:", "Rationale": "Adding support for full authorship proofs (i.e. Alice is the author and no one else is the author) requires a protocol to prove that someone is the only author of an NFT.\nIn other words, we need to answer the question: \u201cGiven an NFT Y and a user X claiming to be the author, is X the original author of Y?\u201d.", "Why provide only an author consent proof?": "Adding support for full authorship proofs (i.e. Alice is the author and no one else is the author) requires a protocol to prove that someone is the only author of an NFT.\nIn other words, we need to answer the question: \u201cGiven an NFT Y and a user X claiming to be the author, is X the original author of Y?\u201d.", "Why off-chain?": "There are three reasons:", "Why repeat id, chainId and contractAddress?": "In many cases, this data can be derived from contextual information. However, requiring their inclusion in the JSON document ensures that author consent can be verified using only the JSON document.", "Why not implement a revocation system?": "Authorship is usually final: either someone created an NFT or they didn\u2019t. Moreover, a revocation system would impose additional implementation requirements on smart contracts and increase the complexity of verification. Smart contracts MAY implement a revocation system, such as the one defined in other EIPs.", "Usability Improvements for Authors": "Since the author only needs to sign an EIP-712 message, this protocol allows minters to handle the technical aspects of minting while still preserving the secrecy of the author\u2019s wallet. Specifically, the author only needs to:", "Limitations of Address-Based Consent": "The standard defines a protocol to verify that a certainaddressprovided consent. However, it does not guarantee that the address corresponds to the expected author (such as the one provided in thenamefield). Proving a link between an address and the entity behind it is beyond the scope of this document.", "Backwards Compatibility": "No backward compatibility issues were found.", "Security Considerations": "A potential attack that exploits this EIP involves tricking authors into signing authorship consent messages against their wishes. For this reason, authors MUST verify that all signature fields match the required ones.", "Attacks": "A potential attack that exploits this EIP involves tricking authors into signing authorship consent messages against their wishes. For this reason, authors MUST verify that all signature fields match the required ones.", "Deprecated Features": "ERC5375AuthorInfoSchemaalso originally included a field to specify a human-readable name for the author (without any kind of verification). This was scrapped due to the high risk of author spoofing, i.e.:", "Replay Attack Resistance": "The chain id, the contract address and the token id uniquely identify an NFT; for this reason, there is no need to implement additional replay attack countermeasures (e.g. a nonce system).", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5380, "url": "https://eips.ethereum.org/EIPS/eip-5380", "title": "ERC-721 Entitlement Extension", "authors": ["Gavin John\u00a0(", "@Pandapip1", ")", "Tim Daubensch\u00fctz\u00a0(", "@TimDaub", ")"], "sections": {"ERC-5380: ERC-721 Entitlement Extension": "This EIP proposes a new interface that allowsERC-721token owners to grant limited usage of those tokens to other addresses.", "Allows token owners to grant the ability for others to use specific properties of those tokens": "This EIP proposes a new interface that allowsERC-721token owners to grant limited usage of those tokens to other addresses.", "Abstract": "This EIP proposes a new interface that allowsERC-721token owners to grant limited usage of those tokens to other addresses.", "Motivation": "There are many scenarios in which it makes sense for the owner of a token to grant certain properties to another address. One use case is renting tokens. If the token in question represents a trading card in an on-chain TCG (trading card game), one might want to be able to use that card in the game without having to actually buy it. Therefore, the owner might grant the renter the \u201cproperty\u201d of it being able to be played in the TCG. However, this property should only be able to be assigned to one person at a time, otherwise a contract could simply \u201crent\u201d the card to everybody. If the token represents usage rights instead, the property of being allowed to use the associated media does not need such a restriction, and there is no reason that the property should be as scarce as the token.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Base": "Compliant entitlement contracts MUST implement the following Solidity interface:", "Enumerable Extension": "This OPTIONAL Solidity interface is RECOMMENDED.", "Metadata Extension": "This OPTIONAL Solidity interface is RECOMMENDED.", "Rationale": "ERC-20andERC-1155are unsupported as partial ownership is much more complex to track than boolean ownership.", "Backwards Compatibility": "No backward compatibility issues were found.", "Security Considerations": "The security considerations ofERC-721andERC-1046apply.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5484, "url": "https://eips.ethereum.org/EIPS/eip-5484", "title": "Consensual Soulbound Tokens", "authors": ["Buzz Cai\u00a0(", "@buzzcai", ")"], "sections": {"ERC-5484: Consensual Soulbound Tokens": "This EIP defines an interface extendingEIP-721to create soulbound tokens. Before issuance, both parties (the issuer and the receiver), have to agree on who has the authorization to burn this token. Burn authorization is immutable after declaration. After its issuance, a soulbound token can\u2019t be transferred, but can be burned based on a predetermined immutable burn authorization.", "Interface for special NFTs with immutable ownership and pre-determined immutable burn authorization": "This EIP defines an interface extendingEIP-721to create soulbound tokens. Before issuance, both parties (the issuer and the receiver), have to agree on who has the authorization to burn this token. Burn authorization is immutable after declaration. After its issuance, a soulbound token can\u2019t be transferred, but can be burned based on a predetermined immutable burn authorization.", "Abstract": "This EIP defines an interface extendingEIP-721to create soulbound tokens. Before issuance, both parties (the issuer and the receiver), have to agree on who has the authorization to burn this token. Burn authorization is immutable after declaration. After its issuance, a soulbound token can\u2019t be transferred, but can be burned based on a predetermined immutable burn authorization.", "Motivation": "The idea of soulbound tokens has gathered significant attention since its publishing. Without a standard interface, however, soulbound tokens are incompatible. It is hard to develop universal services targeting at soulbound tokens without minimal consensus on the implementation of the tokens.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Contract Interface": "We believe that soulbound token serves as a specialized subset of the existing EIP-721 tokens. The advantage of such design is seamless compatibility of soulbound token with existing NFT services. Service providers can treat SBTs like NFTs and do not need to make drastic changes to their existing codebase.", "Rationale": "We believe that soulbound token serves as a specialized subset of the existing EIP-721 tokens. The advantage of such design is seamless compatibility of soulbound token with existing NFT services. Service providers can treat SBTs like NFTs and do not need to make drastic changes to their existing codebase.", "Soulbound Token (SBTs) as an extension to EIP-721": "We believe that soulbound token serves as a specialized subset of the existing EIP-721 tokens. The advantage of such design is seamless compatibility of soulbound token with existing NFT services. Service providers can treat SBTs like NFTs and do not need to make drastic changes to their existing codebase.", "Non-Transferable": "One problem with current soulbound token implementations that extend fromEIP-721is that all transfer implementations throw errors. A much cleaner approach would be for transfer functions to still throw, but also enable third parties to check beforehand if the contract implements the soulbound interface to avoid calling transfer.", "Burn Authorization": "We want maximum freedom when it comes to interface usage. A flexible and predetermined rule to burn is crucial. Here are some sample scenarios for different burn authorizations:", "Issued Event": "On issuing, anIssuedevent will be emitted alongsideEIP-721\u2019sTransferevent. This design keeps backward compatibility while giving clear signals to thrid-parties that this is a soulBound token issuance event.", "Key Rotations": "A concern Ethereum users have is that soulbound tokens having immutable ownership discourage key rotations. This is a valid concern. Having a burnable soulbound token, however, makes key rotations achievable. The owner of the soulbound token, when in need of key rotations, can inform the issuer of the token. Then the party with burn authorization can burn the token while the issuer can issue a replica to the new address.", "Backwards Compatibility": "This proposal is fully backward compatible withEIP-721", "Security Considerations": "There are no security considerations related directly to the implementation of this standard.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5489, "url": "https://eips.ethereum.org/EIPS/eip-5489", "title": "NFT Hyperlink Extension", "authors": ["IronMan_CH\u00a0(", "@coderfengyun", ")"], "sections": {"ERC-5489: NFT Hyperlink Extension": "This EIP proposes a new extension for NFTs (non-fungible token, akaEIP-721): nft-hyperlink-extention (hNFT), embedding NFTs with hyperlinks, referred to as \u201chNFTs\u201d. As owners of hNFTs, users may authorize a URL slot to a specific address which can be either an externally-owned account (EOA) or a contract address and hNFT owners are entitled to revoke that authorization at any time. The address which has slot authorization can manage the URL of that slot.", "NFT Hyperlink Extension embeds hyperlinks onto NFTs, allowing users to click any hNFT and be transported to any url set by the owner.": "This EIP proposes a new extension for NFTs (non-fungible token, akaEIP-721): nft-hyperlink-extention (hNFT), embedding NFTs with hyperlinks, referred to as \u201chNFTs\u201d. As owners of hNFTs, users may authorize a URL slot to a specific address which can be either an externally-owned account (EOA) or a contract address and hNFT owners are entitled to revoke that authorization at any time. The address which has slot authorization can manage the URL of that slot.", "Abstract": "This EIP proposes a new extension for NFTs (non-fungible token, akaEIP-721): nft-hyperlink-extention (hNFT), embedding NFTs with hyperlinks, referred to as \u201chNFTs\u201d. As owners of hNFTs, users may authorize a URL slot to a specific address which can be either an externally-owned account (EOA) or a contract address and hNFT owners are entitled to revoke that authorization at any time. The address which has slot authorization can manage the URL of that slot.", "Motivation": "As NFTs attract more attention, they have the potential to become the primary medium of Web3. Currently, end users can\u2019t attach rich texts, videos, or images to NFTs, and there\u2019s no way to render these rich-content attachments. Many industries eagerly look forward to this kind of rich-content attachment ability. Attaching, editing, and displaying highly customized information can usefully be standardized.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Interface": "TheauthorizeSlotTo(uint256 tokenId, address slotManagerAddr)function MAY be implemented as public or external.", "Authentication": "TheauthorizeSlotTo,revokeAuthorization, andrevokeAllAuthorizationsfunctions are authenticated if and only if the message sender is the owner of the token.", "Metadata JSON schema": "URIs are used to represent the value of slots to ensure enough flexibility to deal with different use cases.", "Rationale": "URIs are used to represent the value of slots to ensure enough flexibility to deal with different use cases.", "Extends NFT with hyperlinks": "URIs are used to represent the value of slots to ensure enough flexibility to deal with different use cases.", "Authorize slot to address": "We use addresses to represent the key of slots to ensure enough flexibility to deal with all use cases.", "Backwards Compatibility": "As mentioned in the specifications section, this standard can be fully EIP-721 compatible by adding an extension function set.", "Reference Implementation": "You can find an implementation of this standard inERC5489.sol.", "Security Considerations": "No security considerations were found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5507, "url": "https://eips.ethereum.org/EIPS/eip-5507", "title": "Refundable Tokens", "authors": ["elie222\u00a0(", "@elie222", ")", "Gavin John\u00a0(", "@Pandapip1", ")"], "sections": {"ERC-5507: Refundable Tokens": "This ERC adds refund functionality for initial token offerings toERC-20,ERC-721, andERC-1155. Funds are held in escrow until a predetermined time before they are claimable. Until that predetermined time passes, users can receive a refund for tokens they have purchased.", "Adds refund functionality to ERC-20, ERC-721, and ERC-1155 tokens": "This ERC adds refund functionality for initial token offerings toERC-20,ERC-721, andERC-1155. Funds are held in escrow until a predetermined time before they are claimable. Until that predetermined time passes, users can receive a refund for tokens they have purchased.", "Abstract": "This ERC adds refund functionality for initial token offerings toERC-20,ERC-721, andERC-1155. Funds are held in escrow until a predetermined time before they are claimable. Until that predetermined time passes, users can receive a refund for tokens they have purchased.", "Motivation": "The NFT and token spaces lack accountability. For the health of the ecosystem as a whole, better mechanisms to prevent rugpulls from happening are needed. Offering refunds provides greater protection for buyers and increases legitimacy for creators.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "ERC-20 Refund Extension": "refundDeadlineOfuses blocks instead of timestamps, as timestamps are less reliable than block numbers.", "ERC-721 Refund Extension": "refundDeadlineOfuses blocks instead of timestamps, as timestamps are less reliable than block numbers.", "ERC-1155 Refund Extension": "refundDeadlineOfuses blocks instead of timestamps, as timestamps are less reliable than block numbers.", "Rationale": "refundDeadlineOfuses blocks instead of timestamps, as timestamps are less reliable than block numbers.", "Backwards Compatibility": "No backward compatibility issues were found.", "Security Considerations": "There is a potential re-entrancy risk with therefundfunction. Make sure to perform the ether transferafterthe tokens are destroyed (i.e. obey the checks, effects, interactions pattern).", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5521, "url": "https://eips.ethereum.org/EIPS/eip-5521", "title": "Referable NFT", "authors": ["Saber Yu\u00a0(", "@OniReimu", ")", "Qin Wang\u00a0<", "qin.wang@data61.csiro.au", ">", "Shange Fu\u00a0<", "shange.fu@monash.edu", ">", "Yilin Sai\u00a0<", "yilin.sai@data61.csiro.au", ">", "Shiping Chen\u00a0<", "shiping.chen@data61.csiro.au", ">", "Sherry Xu\u00a0<", "xiwei.xu@data61.csiro.au", ">", "Jiangshan Yu\u00a0<", "jiangshan.yu@monash.edu", ">"], "sections": {"ERC-5521: Referable NFT": "This standard is an extension ofERC-721. It proposes two referable indicators, referring and referred, and a time-based indicatorcreatedTimestamp. The relationship between each NFT forms a directed acyclic graph (DAG). The standard allows users to query, track and analyze their relationships.", "An ERC-721 extension to construct reference relationships among NFTs": "This standard is an extension ofERC-721. It proposes two referable indicators, referring and referred, and a time-based indicatorcreatedTimestamp. The relationship between each NFT forms a directed acyclic graph (DAG). The standard allows users to query, track and analyze their relationships.", "Abstract": "This standard is an extension ofERC-721. It proposes two referable indicators, referring and referred, and a time-based indicatorcreatedTimestamp. The relationship between each NFT forms a directed acyclic graph (DAG). The standard allows users to query, track and analyze their relationships.", "Motivation": "Many scenarios require the inheritance, reference, and extension of NFTs. For instance, an artist may develop his NFT work based on a previous NFT, or a DJ may remix his record by referring to two pop songs, etc. A gap in existing NFT standards is the absence of established relationships between an NFT and its original creator. This void isolates NFTs, rendering the sale of each one a one-off transaction, thereby obstructing creators from accruing the full value of their intellectual property over time.", "Key Takeaways": "This standard provides several advantages:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "UpdateNode: This event disseminates crucial information, including the rNFT ID, its owner, and lists of contract addresses/IDs with rNFTs referring to or referred by the subject rNFT. This data set enables stakeholders to efficiently manage and navigate the complex web of relationships inherent in the rNFT ecosystem.", "Is this event informative enough?": "UpdateNode: This event disseminates crucial information, including the rNFT ID, its owner, and lists of contract addresses/IDs with rNFTs referring to or referred by the subject rNFT. This data set enables stakeholders to efficiently manage and navigate the complex web of relationships inherent in the rNFT ecosystem.", "WhycreatedTimestampOf?": "createdTimestamp: A key principle of this standard is that an rNFT should reference content already accepted by the community (a time-based sequence known by participants). Global timestamps for rNFTs are thus essential, serving to prevent conflicting states (akin to concurrency issues in transaction processing and block organization). We define a block-level timestamp wherecreatedTimestamp = block.timestampNote that, given that the granularity of references is tied to the block timestamp, it is impractical to discern the order of two rNFTs within the same block.", "How is cross-contract reference performed?": "setNodeReferredExternal: This function operates conditionally, dependent on successful interface verification in external contracts. Such selective invocation ensures backward compatibility and integration with existing contracts, provided they adhere to specified interfaces.", "Backwards Compatibility": "This standard can be fullyERC-721compatible by adding an extension function set.", "Test Cases": "Test cases are included inERC_5521.test.js", "Reference Implementation": "The recommended implementation is demonstrated as follows:", "Security Considerations": "ThecreatedTimestamponly covers the block-level timestamp (based on block headers), which does not support fine-grained comparisons such as transaction-level.", "Timestamp": "ThecreatedTimestamponly covers the block-level timestamp (based on block headers), which does not support fine-grained comparisons such as transaction-level.", "Ownership and Reference": "The change of ownership has nothing to do with the reference relationship. Normally, the distribution of profits complies with the agreement when the NFT was being created regardless of the change of ownership unless specified in the agreement.", "Open Minting and Relationship Risks": "ThesafeMintfunction has been deliberately designed to allow unrestricted minting and relationship setting, akin to the open referencing system seen in platforms such as Google Scholar. This decision facilitates strong flexibility, enabling any user to create and define relationships between NFTs without centralized control. While this design aligns with the intended openness of the system, it inherently carries certain risks. Unauthorized or incorrect references can be created, mirroring the challenges faced in traditional scholarly referencing, where erroneous citations may occur. Additionally, the open nature may expose the system to potential abuse by malicious actors, who might manipulate relationships or inflate the token supply. It is important to recognize that these risks are not considered design flaws but intentional trade-offs, which balance the system\u2019s flexibility against potential reliability concerns.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5528, "url": "https://eips.ethereum.org/EIPS/eip-5528", "title": "Refundable Fungible Token", "authors": ["StartfundInc\u00a0(", "@StartfundInc", ")"], "sections": {"ERC-5528: Refundable Fungible Token": "This standard is an extension ofEIP-20. This specification defines a type of escrow service with the following flow:", "Allows refunds for EIP-20 tokens by escrow smart contract": "This standard is an extension ofEIP-20. This specification defines a type of escrow service with the following flow:", "Abstract": "This standard is an extension ofEIP-20. This specification defines a type of escrow service with the following flow:", "Motivation": "Because of the pseudonymous nature of cryptocurrencies, there is no automatic recourse to recover funds that have already been paid.", "Specification": "There are two types of contract for the escrow process:", "Methods": "TheEscrow Contractdemonstrates details of escrow policies as none-mutable matter in constructor implementation.", "Example of interface": "This example demonstrates simple exchange of one seller and one buyer in one-to-one exchange rates.", "Rationale": "The interfaces cover the escrow operation\u2019s refundable issue.", "Backwards Compatibility": "ThePayable Contractwhich implements this EIP is fully backward compatible with theEIP-20specification.", "Test Cases": "Unit test example by truffle.", "Security Considerations": "Since theEscrow Contractcontrols seller and buyer rights, flaws within theEscrow Contractwill directly lead to unexpected behavior and potential loss of funds.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5564, "url": "https://eips.ethereum.org/EIPS/eip-5564", "title": "Stealth Addresses", "authors": ["Toni Wahrst\u00e4tter\u00a0(", "@nerolation", ")", "Matt Solomon\u00a0(", "@mds1", ")", "Ben DiFrancesco\u00a0(", "@apbendi", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"ERC-5564: Stealth Addresses": "This specification establishes a standardized method for interacting with stealth addresses, which allow senders of transactions or transfers to non-interactively generate private accounts exclusively accessible by their recipients. Moreover, this specification enables developers to create stealth address protocols based on the foundational implementation outlined in this ERC, utilizing a singleton contract deployed at0x55649E01B5Df198D18D95b5cc5051630cfD45564to emit the necessary information for recipients. In addition to the base implementation, this ERC also outlines the first implementation of a cryptographic scheme, specifically the SECP256k1 curve.", "Private, non-interactive transactions": "This specification establishes a standardized method for interacting with stealth addresses, which allow senders of transactions or transfers to non-interactively generate private accounts exclusively accessible by their recipients. Moreover, this specification enables developers to create stealth address protocols based on the foundational implementation outlined in this ERC, utilizing a singleton contract deployed at0x55649E01B5Df198D18D95b5cc5051630cfD45564to emit the necessary information for recipients. In addition to the base implementation, this ERC also outlines the first implementation of a cryptographic scheme, specifically the SECP256k1 curve.", "Abstract": "This specification establishes a standardized method for interacting with stealth addresses, which allow senders of transactions or transfers to non-interactively generate private accounts exclusively accessible by their recipients. Moreover, this specification enables developers to create stealth address protocols based on the foundational implementation outlined in this ERC, utilizing a singleton contract deployed at0x55649E01B5Df198D18D95b5cc5051630cfD45564to emit the necessary information for recipients. In addition to the base implementation, this ERC also outlines the first implementation of a cryptographic scheme, specifically the SECP256k1 curve.", "Motivation": "The standardization of non-interactive stealth address generation presents the potential to significantly improve the privacy capabilities of the Ethereum network and other EVM-compatible chains by allowing recipients to remain private when receiving assets. This is accomplished through the sender generating a stealth address based on a shared secret known exclusively to the sender and recipient. The recipients alone can access the funds stored at their stealth addresses, as they are the sole possessors of the necessary private key. As a result, observers are unable to associate the recipient\u2019s stealth address with their identity, thereby preserving the recipient\u2019s privacy and leaving the sender as the only party privy to this information. By offering a foundational implementation in the form of a single contract that is compatible with multiple cryptographic schemes, recipients are granted a centralized location to monitor, ensuring they do not overlook any incoming transactions.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Stealth meta-address format": "The new address format for the stealth meta-address extends the chain specific address format by adding ast:(stealth) prefix.\nThus, a stealth meta-address on Ethereum has the following format:", "Initial Implementation of SECP256k1 with View Tags": "This ERC provides a foundation that is not tied to any specific cryptographic system through theIERC5564Announcercontract. In addition, it introduces the first implementation of a stealth address scheme that utilizes the SECP256k1 elliptic curve and view tags. The SECP256k1 elliptic curve is defined with the equation $y^2 = x^3 + 7 \\pmod{p}$, where $p = 2^{256} - 2^{32} - 977$.", "Parsing considerations": "Usually, the recipient of a stealth address transaction has to perform the following operations to check whether he was the recipient of a certain transaction:", "Rationale": "This ERC emerged from the need for privacy-preserving ways to transfer ownership without disclosing any information about the recipients\u2019 identities. Token ownership can expose sensitive personal information. While individuals may wish to donate to a specific organization or country, they might prefer not to disclose a link between themselves and the recipient simultaneously. Standardizing stealth address generation represents a significant step towards unlinkable interactions, since such privacy-enhancing solutions require standards to achieve widespread adoption. Consequently, it is crucial to focus on developing generalizable approaches for implementing related solutions.", "Backwards Compatibility": "This ERC is fully backward compatible.", "Deployment Method": "TheERC5564Announcercontract is deployed at0x55649E01B5Df198D18D95b5cc5051630cfD45564usingCREATE2via the deterministic deployer at0x4e59b44847b379578588920ca78fbf26c0b4956cwith a salt of0xd0103a290d760f027c9ca72675f5121d725397fb2f618f05b6c44958b25b4447.", "Reference Implementation": "You can find the implementation of theERC5564Announcercontracthereand the interfaceIERC5564Announcer.solhere.", "Security Considerations": "There are potential denial of service (DoS) attack vectors that are not mitigated by network transaction fees. Stealth transfer senders cause an externality for recipients, as parsing announcement events consumes computational resources that are not compensated with gas. Therefore, spamming announcement eventscanbe a detriment to the user experience, as itcanlead to longer parsing times. \nWe consider the incentives to carry out such an attack to be low becauseno monetary benefit can be obtainedHowever, to tackle potential spam, parsing providers may adopt their own anti-DoS attack methods. These may include ignoring the spamming users when serving announcements to users or, less harsh, de-prioritizing them when ordering the announcements. The indexedcallerkeyword may help parsing providers to effectively filter known spammers.", "DoS Countermeasures": "There are potential denial of service (DoS) attack vectors that are not mitigated by network transaction fees. Stealth transfer senders cause an externality for recipients, as parsing announcement events consumes computational resources that are not compensated with gas. Therefore, spamming announcement eventscanbe a detriment to the user experience, as itcanlead to longer parsing times. \nWe consider the incentives to carry out such an attack to be low becauseno monetary benefit can be obtainedHowever, to tackle potential spam, parsing providers may adopt their own anti-DoS attack methods. These may include ignoring the spamming users when serving announcements to users or, less harsh, de-prioritizing them when ordering the announcements. The indexedcallerkeyword may help parsing providers to effectively filter known spammers.", "Recipients\u2019 transaction costs": "The funding of the stealth address wallet represents a known issue that might breach privacy. The wallet that funds the stealth address MUST NOT have any physical connection to the stealth address owner in order to fully leverage the privacy improvements.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5570, "url": "https://eips.ethereum.org/EIPS/eip-5570", "title": "Digital Receipt Non-Fungible Tokens", "authors": ["Sean Darcy\u00a0(", "@darcys22", ")"], "sections": {"ERC-5570: Digital Receipt Non-Fungible Tokens": "This ERC proposes a standard schema for digital receipts of transactions. Digital Receipt Non-Fungible Tokens are issued by a vendor when a customer makes a purchase from their store and contains transaction details necessary for record keeping. Digital Receipt Non-Fungible Tokens extendERC-721which allows for the management and ownership of unique tokens.", "Non-Fungible Tokens as digital receipts for physical purchases, where the metadata represents a JSON receipt": "This ERC proposes a standard schema for digital receipts of transactions. Digital Receipt Non-Fungible Tokens are issued by a vendor when a customer makes a purchase from their store and contains transaction details necessary for record keeping. Digital Receipt Non-Fungible Tokens extendERC-721which allows for the management and ownership of unique tokens.", "Abstract": "This ERC proposes a standard schema for digital receipts of transactions. Digital Receipt Non-Fungible Tokens are issued by a vendor when a customer makes a purchase from their store and contains transaction details necessary for record keeping. Digital Receipt Non-Fungible Tokens extendERC-721which allows for the management and ownership of unique tokens.", "Motivation": "Purchases from online retailers include a receipt that is emailed and/or physically provided to the customer. These receipts are critical for many reasons but are provided in an analogue form which is difficult to parse by financial systems. Digital receipts have never gained traction dispite the fact that point of sales systems are already digital and the customers often want this information in their own digital systems. So we are left with a redundant Digital -> Analogue -> Digital process which requires unnecessary data entry or the use of clunky receipt-scanning applications.", "Specification": "Transaction Flow:", "Digital Receipt JSON Schema": "The JSON schema is composed of 2 parts. The root schema contains high level details of the receipt (for example Date and Vendor) and another schema for the optionally recurring line items contained in the receipt.", "Rationale": "The schema introduced complies with ERC-721\u2019s metadata extension, conveniently allowing previous tools for viewing NFTs to show our receipts. The new property \u201creceipt\u201d contains our newly provided receipt structure and the signature property optionally allows the vendor to digitally sign the receipt structure.", "Backwards Compatibility": "This standard is an extension of ERC-721. It is compatible with both optional extensions, Metadata and Enumerable, mentioned in ERC-721.", "Security Considerations": "The data stored in the digital receipt includes various types of personally identifying information (PII), such as the vendor\u2019s name, contact details, and the items purchased. PII is sensitive information that can be used to identify, locate, or contact an individual. Protecting the privacy of the customer is of utmost importance, as unauthorized access to PII can lead to identity theft, fraud, or other malicious activities.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5585, "url": "https://eips.ethereum.org/EIPS/eip-5585", "title": "ERC-721 NFT Authorization", "authors": ["Veega Labs\u00a0(", "@VeegaLabsOfficial", ")", "Sean NG\u00a0(", "@ngveega", ")", "Tiger\u00a0(", "@tiger0x", ")", "Fred\u00a0(", "@apan826", ")", "Fov Cao\u00a0(", "@fovcao", ")"], "sections": {"ERC-5585: ERC-721 NFT Authorization": "This EIP separates theERC-721NFT\u2019s commercial usage rights from its ownership to allow for the independent management of those rights.", "Allows NFT owners to authorize other users to use their NFTs.": "This EIP separates theERC-721NFT\u2019s commercial usage rights from its ownership to allow for the independent management of those rights.", "Abstract": "This EIP separates theERC-721NFT\u2019s commercial usage rights from its ownership to allow for the independent management of those rights.", "Motivation": "Most NFTs have a simplified ownership verification mechanism, with a sole owner of an NFT. Under this model, other rights, such as display, or creating derivative works or distribution, are not possible to grant, limiting the value and commercialization of NFTs. Therefore, the separation of an NFT\u2019s ownership and user rights can enhance its commercial value.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Contract Interface": "ThegetRights()function MAY be implemented as pure and view.", "Rationale": "First of all, NFT contract owner can set the maximum number of authorized users to each NFT and whether the NFT owner can cancel the authorization at any time to protect the interests of the parties involved.", "Backwards Compatibility": "This standard is compatible withERC-721since it is an extension of it.", "Security Considerations": "When theresetAllowedflag is false, which means the authorization can not be revoked by NFT owner during the period of authorization, users of the EIP need to make sure the authorization fee can be fairly assigned if the NFT was sold to a new holder.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5606, "url": "https://eips.ethereum.org/EIPS/eip-5606", "title": "Multiverse NFTs", "authors": ["Gaurang Torvekar\u00a0(", "@gaurangtorvekar", ")", "Khemraj Adhawade\u00a0(", "@akhemraj", ")", "Nikhil Asrani\u00a0(", "@nikhilasrani", ")"], "sections": {"ERC-5606: Multiverse NFTs": "This specification defines a minimal interface to create a multiverse NFT standard for digital assets such as wearables and in-game items that, in turn, index the delegate NFTs on each platform where this asset exists. These platforms could be metaverses, play-to-earn games or NFT marketplaces. This proposal depends on and extendsERC-721andERC-1155. The standard also allows for the \u2018bundling\u2019 and \u2018unbundling\u2019 of these delegate NFTs within the multiverse NFT so holders can trade them individually or as a bundle.", "A universal representation of multiple related NFTs as a single digital asset across various platforms": "This specification defines a minimal interface to create a multiverse NFT standard for digital assets such as wearables and in-game items that, in turn, index the delegate NFTs on each platform where this asset exists. These platforms could be metaverses, play-to-earn games or NFT marketplaces. This proposal depends on and extendsERC-721andERC-1155. The standard also allows for the \u2018bundling\u2019 and \u2018unbundling\u2019 of these delegate NFTs within the multiverse NFT so holders can trade them individually or as a bundle.", "Abstract": "This specification defines a minimal interface to create a multiverse NFT standard for digital assets such as wearables and in-game items that, in turn, index the delegate NFTs on each platform where this asset exists. These platforms could be metaverses, play-to-earn games or NFT marketplaces. This proposal depends on and extendsERC-721andERC-1155. The standard also allows for the \u2018bundling\u2019 and \u2018unbundling\u2019 of these delegate NFTs within the multiverse NFT so holders can trade them individually or as a bundle.", "Motivation": "Several metaverses and blockchain games (\u201cplatforms\u201d) exist that use NFT standards such as ERC-721 and ERC-1155 for creating in-universe assets like avatar wearables, in-game items including weapons, shields, potions and much more. The biggest shortcoming while using these standards is that there is no interoperability between these platforms. As a publisher, you must publish the same digital asset (for example, a shirt) on various platforms as separate ERC-721 or ERC-1155 tokens. Moreover, there is no relationship between these, although they represent the same digital asset in reality. Hence, it is very difficult to prove the scarcity of these items on-chain.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "ThedelegateDatastruct contains information about the delegate NFT tokens on each platform. It contains variables such ascontractAddress,tokenId,quantityto differentiate the NFTs. These NFTs could be following either the ERC-721 standard or the ERC-1155 standard.", "Backwards Compatibility": "This standard is fully compatible with ERC-721 and ERC-1155. Third-party applications that don\u2019t support this EIP will still be able to use the original NFT standards without any problems.", "Reference Implementation": "MultiverseNFT.sol", "Security Considerations": "The bundle function involves calling an external contract(s). So reentrancy prevention measures should be applied while implementing this function.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5615, "url": "https://eips.ethereum.org/EIPS/eip-5615", "title": "ERC-1155 Supply Extension", "authors": ["Gavin John\u00a0(", "@Pandapip1", ")"], "sections": {"ERC-5615: ERC-1155 Supply Extension": "This ERC standardizes an existing mechanism to fetch token supply data fromERC-1155tokens. It adds atotalSupplyfunction, which fetches the number of tokens with a givenid, and anexistsfunction, which checks for the existence of a givenid.", "A simple mechanism to fetch token supply data from ERC-1155 tokens": "This ERC standardizes an existing mechanism to fetch token supply data fromERC-1155tokens. It adds atotalSupplyfunction, which fetches the number of tokens with a givenid, and anexistsfunction, which checks for the existence of a givenid.", "Abstract": "This ERC standardizes an existing mechanism to fetch token supply data fromERC-1155tokens. It adds atotalSupplyfunction, which fetches the number of tokens with a givenid, and anexistsfunction, which checks for the existence of a givenid.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "This ERC does not implementERC-165, as this interface is simple enough that the extra complexity is unnecessary and would cause incompatibilities with pre-existing implementations.", "Backwards Compatibility": "This ERC is designed to be backward compatible with the OpenZeppelinERC1155Supply.", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5625, "url": "https://eips.ethereum.org/EIPS/eip-5625", "title": "NFT Metadata JSON Schema dStorage Extension", "authors": ["Gavin Fu\u00a0(", "@gavfu", ")", "Leo Wang\u00a0(", "@wanglie1986", ")", "Bova Chen\u00a0(", "@appoipp", ")", "Guang Han\u00a0(", "@pangwa", ")", "Brian Wu\u00a0(", "@wuhaixian1984", ")"], "sections": {"ERC-5625: NFT Metadata JSON Schema dStorage Extension": "This EIP extends the NFT metadata JSON schema defined inEIP-721andEIP-1155, adding adStoragekey that provides information about how the NFT data is stored.", "Add a dStorage property to non-fungible tokens (NFTs) metadata JSON schema to provide decentralized storage information of NFT assets": "This EIP extends the NFT metadata JSON schema defined inEIP-721andEIP-1155, adding adStoragekey that provides information about how the NFT data is stored.", "Abstract": "This EIP extends the NFT metadata JSON schema defined inEIP-721andEIP-1155, adding adStoragekey that provides information about how the NFT data is stored.", "Motivation": "As highly valuable crypto properties, NFT assets intrinsically demand guaranteed storage to assure theirimmutability,reliability, anddurability. NFT ownership is tracked byEIP-721orEIP-1155smart contracts, hence persisted in blockchain, which is not a problem. But how about the mime-type assets that NFT tokens represent? Ideally, they should also be stored in some reliable and verifiable decentralized storage system that is designed to store larger amounts of data than the blockchain itself. As an effort to promotedecentralized storageadoption in NFT world, we propose to add additionaldStorageinformation into NFT metadata JSON schema.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "An extension of the EIP-721 or EIP-1155 contract interfaces would unnecessarily require additional code to implement, and would not be available for use by NFT projects that already have their NFT smart contracts finalized and deployed. An optional JSON schema extension is noninvasive, and more easily adopted.", "Choice between Interface and JSON Schema Extension": "An extension of the EIP-721 or EIP-1155 contract interfaces would unnecessarily require additional code to implement, and would not be available for use by NFT projects that already have their NFT smart contracts finalized and deployed. An optional JSON schema extension is noninvasive, and more easily adopted.", "Backwards Compatibility": "This EIP is backward compatible withEIP-721andEIP-1155.", "Security Considerations": "This EIP does not introduce any new security risks or vulnerabilities, as thedStorageproperty is only an informational field of the Metadata JSON file returned byEIP-721andEIP-1155smart contracts. It does not affect the execution or validity of NFT transactions.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5646, "url": "https://eips.ethereum.org/EIPS/eip-5646", "title": "Token State Fingerprint", "authors": ["Naim Ashhab\u00a0(", "@ashhanai", ")"], "sections": {"ERC-5646: Token State Fingerprint": "This specification defines the minimum interface required to unambiguously identify the state of a mutable token without knowledge of implementation details.", "Unambiguous token state identifier": "This specification defines the minimum interface required to unambiguously identify the state of a mutable token without knowledge of implementation details.", "Abstract": "This specification defines the minimum interface required to unambiguously identify the state of a mutable token without knowledge of implementation details.", "Motivation": "Currently, protocols need to know about tokens\u2019 state properties to create the unambiguous identifier. Unfortunately, this leads to an obvious bottleneck in which protocols need to support every new token specifically.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, and \u201cMAY\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "Protocols can use state fingerprints as a part of a token identifier and support mutable tokens without knowing any state implementation details.", "Backwards Compatibility": "This EIP is not introducing any backward incompatibilities.", "Reference Implementation": "Token state fingerprints from two different contracts may collide. Because of that, they should be compared only in the context of one token contract.", "Security Considerations": "Token state fingerprints from two different contracts may collide. Because of that, they should be compared only in the context of one token contract.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5679, "url": "https://eips.ethereum.org/EIPS/eip-5679", "title": "Token Minting and Burning", "authors": ["Zainan Victor Zhou\u00a0(", "@xinbenlv", ")"], "sections": {"ERC-5679: Token Minting and Burning": "This EIP introduces a consistent way to extend token standards for minting and burning.", "An extension for minting and burning EIP-20, EIP-721, and EIP-1155 tokens": "This EIP introduces a consistent way to extend token standards for minting and burning.", "Abstract": "This EIP introduces a consistent way to extend token standards for minting and burning.", "Motivation": "Minting and Burning are typical actions for creating and destroying tokens.\nBy establishing a consistent way to mint and burn a token, we complete the basic lifecycle.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "This EIP is designed to be compatible for EIP-20, EIP-721 and EIP-1155 respectively.", "Backwards Compatibility": "This EIP is designed to be compatible for EIP-20, EIP-721 and EIP-1155 respectively.", "Security Considerations": "This EIP depends on the security soundness of the underlying book keeping behavior of the token implementation.\nIn particular, a token contract should carefully design the access control for which role is granted permission\nto mint a new token. Failing to safe guard such behavior can cause fraudulent issuance and an elevation of total supply.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5725, "url": "https://eips.ethereum.org/EIPS/eip-5725", "title": "Transferable Vesting NFT", "authors": ["Apeguru\u00a0(", "@Apegurus", ")", "Marco De Vries\u00a0<", "marco@paladinsec.co", ">", "Mario\u00a0<", "mario@paladinsec.co", ">", "DeFiFoFum\u00a0(", "@DeFiFoFum", ")", "Elliott Green\u00a0(", "@elliott-green", ")"], "sections": {"ERC-5725: Transferable Vesting NFT": "ANon-Fungible Token(NFT) standard used to vest tokens (ERC-20or otherwise) over a vesting release curve.", "An interface for transferable vesting NFTs which release underlying tokens over time.": "ANon-Fungible Token(NFT) standard used to vest tokens (ERC-20or otherwise) over a vesting release curve.", "Abstract": "ANon-Fungible Token(NFT) standard used to vest tokens (ERC-20or otherwise) over a vesting release curve.", "Motivation": "Vesting contracts, including timelock contracts, lack a standard and unified interface, which results in diverse implementations of such contracts. Standardizing such contracts into a single interface would allow for the creation of an ecosystem of on- and off-chain tooling around these contracts. In addition, liquid vesting in the form of non-fungible assets can prove to be a huge improvement over traditionalSimple Agreement for Future Tokens(SAFTs) orExternally Owned Account(EOA)-based vesting as it enables transferability and the ability to attach metadata similar to the existing functionality offered by with traditional NFTs.", "Use Cases": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "These are base terms used around the specification which function names and definitions are based on.", "Terms": "These are base terms used around the specification which function names and definitions are based on.", "Vesting Functions": "vestingPayout+vestedPayout", "Timestamps": "Generally in Solidity development it is advised against usingblock.timestampas a state dependant variable as the timestamp of a block can be manipulated by a miner. The choice to use atimestampover ablockis to allow the interface to work across multipleEthereum Virtual Machine(EVM) compatible networks which generally have different block times. Block proposal with a significantly fabricated timestamp will generally be dropped by all node implementations which makes the window for abuse negligible.", "Limitation of Scope": "These feature are not supported by the standard as is, but the standard could be extended to support these more advanced features.", "Extension Possibilities": "These feature are not supported by the standard as is, but the standard could be extended to support these more advanced features.", "Backwards Compatibility": "The reference vesting NFT repository includes tests written in Hardhat.", "Test Cases": "The reference vesting NFT repository includes tests written in Hardhat.", "Reference Implementation": "A reference implementation of this EIP can be found inERC-5725 assets.", "Security Considerations": "timestamps", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5732, "url": "https://eips.ethereum.org/EIPS/eip-5732", "title": "Commit Interface", "authors": ["Zainan Victor Zhou\u00a0(", "@xinbenlv", ")", "Matt Stam\u00a0(", "@mattstam", ")"], "sections": {"ERC-5732: Commit Interface": "A simple commit interface to support commit-reveal scheme which providesonlya commit\nmethod but no reveal method, allowing implementations to integrate this interface\nwith arbitrary reveal methods such asvoteortransfer.", "A simple but general commit interface to support commit-reveal scheme.": "A simple commit interface to support commit-reveal scheme which providesonlya commit\nmethod but no reveal method, allowing implementations to integrate this interface\nwith arbitrary reveal methods such asvoteortransfer.", "Abstract": "A simple commit interface to support commit-reveal scheme which providesonlya commit\nmethod but no reveal method, allowing implementations to integrate this interface\nwith arbitrary reveal methods such asvoteortransfer.", "Motivation": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "This EIP is backward compatible with all existing ERCs method signature that has extraData. New EIPs can be designed with an extra field of \u201csalt\u201d to make it easier to support this EIP, but not required.", "Backwards Compatibility": "This EIP is backward compatible with all existing ERCs method signature that has extraData. New EIPs can be designed with an extra field of \u201csalt\u201d to make it easier to support this EIP, but not required.", "Reference Implementation": "In ENS registering process, currently inside ofETHRegistrarControllercontract a commit function is being used to allow registerer fairly register a desire domain to avoid being front-run.", "Commit with ENS Register as Reveal": "In ENS registering process, currently inside ofETHRegistrarControllercontract a commit function is being used to allow registerer fairly register a desire domain to avoid being front-run.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5750, "url": "https://eips.ethereum.org/EIPS/eip-5750", "title": "General Extensibility for Method Behaviors", "authors": ["Zainan Victor Zhou\u00a0(", "@xinbenlv", ")"], "sections": {"ERC-5750: General Extensibility for Method Behaviors": "This EIP standardizes the passing of unstructured call data to functions to enable future extensibility.", "Designating last param of dynamically sized bytes to be used for behavior extensions of methods.": "This EIP standardizes the passing of unstructured call data to functions to enable future extensibility.", "Abstract": "This EIP standardizes the passing of unstructured call data to functions to enable future extensibility.", "Motivation": "The purpose of having extra data in a method is to allow further extensions to existing method interfaces.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Examples of compliant and non-compliant methods": "Many existing EIPs already have compliant methods as part of their specification. All contracts compliant with those EIPs are either fully or partially compliant with this EIP.", "Rationale": "Many existing EIPs already have compliant methods as part of their specification. All contracts compliant with those EIPs are either fully or partially compliant with this EIP.", "Backwards Compatibility": "Many existing EIPs already have compliant methods as part of their specification. All contracts compliant with those EIPs are either fully or partially compliant with this EIP.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5773, "url": "https://eips.ethereum.org/EIPS/eip-5773", "title": "Context-Dependent Multi-Asset Tokens", "authors": ["Bruno \u0160kvorc\u00a0(", "@Swader", ")", "Cicada\u00a0(", "@CicadaNCR", ")", "Steven Pineda\u00a0(", "@steven2308", ")", "Stevan Bogosavljevic\u00a0(", "@stevyhacker", ")", "Jan Turk\u00a0(", "@ThunderDeliverer", ")"], "sections": {"ERC-5773: Context-Dependent Multi-Asset Tokens": "The Multi-Asset NFT standard allows for the construction of a new primitive: context-dependent output of information per single NFT.", "An interface for Multi-Asset tokens with context dependent asset type output controlled by owner's preference.": "The Multi-Asset NFT standard allows for the construction of a new primitive: context-dependent output of information per single NFT.", "Abstract": "The Multi-Asset NFT standard allows for the construction of a new primitive: context-dependent output of information per single NFT.", "Motivation": "With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having multiple assets associated with a single NFT allows for greater utility, usability and forward compatibility.", "Cross-metaverse compatibility": "At the time of writing this proposal, the metaverse is still a fledgling, not full defined, term. No matter how the definition of metaverse evolves, the proposal can support any number of different implementations.", "Multi-media output": "An NFT of an eBook can be represented as a PDF, MP3, or some other format, depending on what software loads it. If loaded into an eBook reader, a PDF should be displayed, and if loaded into an audiobook application, the MP3 representation should be used. Other metadata could be present in the NFT (perhaps the book\u2019s cover image) for identification on various marketplaces, Search Engine Result Pages (SERPs), or portfolio trackers.", "Media redundancy": "Many NFTs are minted hastily without best practices in mind - specifically, many NFTs are minted with metadata centralized on a server somewhere or, in some cases, a hardcoded IPFS gateway which can also go down, instead of just an IPFS hash.", "NFT evolution": "Many NFTs, particularly game related ones, require evolution. This is especially the case in modern metaverses where no metaverse is actually a metaverse - it is just a multiplayer game hosted on someone\u2019s server which replaces username/password logins with reading an account\u2019s NFT balance.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "Designing the proposal, we considered the following questions:", "Multi-Asset Storage Schema": "Assets are stored within a token as an array ofuint64identifiers.", "Propose-Commit pattern for asset addition": "Adding assets to an existing token MUST be done in the form of a propose-commit pattern to allow for limited mutability by a 3rd party. When adding an asset to a token, it is first placed in the\u201cPending\u201darray, and MUST be migrated to the\u201cActive\u201darray by the token\u2019s owner. The\u201cPending\u201dassets array SHOULD be limited to 128 slots to prevent spam and griefing.", "Asset management": "Several functions for asset management are included. In addition to permissioned migration from \u201cPending\u201d to \u201cActive\u201d, the owner of a token MAY also drop assets from both the active and the pending array \u2013 an emergency function to clear all entries from the pending array MUST also be included.", "Backwards Compatibility": "The MultiAsset token standard has been made compatible withERC-721in order to take advantage of the robust tooling available for implementations of ERC-721 and to ensure compatibility with existing ERC-721 infrastructure.", "Test Cases": "Tests are included inmultiasset.ts.", "Reference Implementation": "SeeMultiAssetToken.sol.", "Security Considerations": "The same security considerations as withERC-721apply: hidden logic may be present in any of the functions, including burn, add asset, accept asset, and more.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6059, "url": "https://eips.ethereum.org/EIPS/eip-6059", "title": "Parent-Governed Nestable Non-Fungible Tokens", "authors": ["Bruno \u0160kvorc\u00a0(", "@Swader", ")", "Cicada\u00a0(", "@CicadaNCR", ")", "Steven Pineda\u00a0(", "@steven2308", ")", "Stevan Bogosavljevic\u00a0(", "@stevyhacker", ")", "Jan Turk\u00a0(", "@ThunderDeliverer", ")"], "sections": {"ERC-6059: Parent-Governed Nestable Non-Fungible Tokens": "The Parent-Governed Nestable NFT standard extendsERC-721by allowing for a new inter-NFT relationship and interaction.", "An interface for Nestable Non-Fungible Tokens with emphasis on parent token's control over the relationship.": "The Parent-Governed Nestable NFT standard extendsERC-721by allowing for a new inter-NFT relationship and interaction.", "Abstract": "The Parent-Governed Nestable NFT standard extendsERC-721by allowing for a new inter-NFT relationship and interaction.", "Motivation": "With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having the ability for tokens to own other tokens allows for greater utility, usability and forward compatibility.", "Bundling": "One of the most frequent uses ofERC-721is to disseminate the multimedia content that is tied to the tokens. In the event that someone wants to offer a bundle of NFTs from various collections, there is currently no easy way of bundling all of these together and handle their sale as a single transaction. This proposal introduces a standardized way of doing so. Nesting all of the tokens into a simple bundle and selling that bundle would transfer the control of all of the tokens to the buyer in a single transaction.", "Collecting": "A lot of NFT consumers collect them based on countless criteria. Some aim for utility of the tokens, some for the uniqueness, some for the visual appeal, etc. There is no standardized way to group the NFTs tied to a specific account. By nesting NFTs based on their owner\u2019s preference, this proposal introduces the ability to do it. The root parent token could represent a certain group of tokens and all of the children nested into it would belong to it.", "Membership": "A common utility attached to NFTs is a membership to a Decentralised Autonomous Organization (DAO) or to some other closed-access group. Some of these organizations and groups occasionally mint NFTs to the current holders of the membership NFTs. With the ability to nest mint a token into a token, such minting could be simplified, by simply minting the bonus NFT directly into the membership one.", "Delegation": "One of the core features of DAOs is voting and there are various approaches to it. One such mechanic is using fungible voting tokens where members can delegate their votes by sending these tokens to another member. Using this proposal, delegated voting could be handled by nesting your voting NFT into the one you are delegating your votes to and transferring it when the member no longer wishes to delegate their votes.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "Designing the proposal, we considered the following questions:", "Propose-Commit pattern for child token management": "Adding child tokens to a parent token MUST be done in the form of propose-commit pattern to allow for limited mutability by a 3rd party. When adding a child token to a parent token, it is first placed in a\u201cPending\u201darray, and MUST be migrated to the\u201cActive\u201darray by the parent token\u2019s root owner. The\u201cPending\u201dchild tokens array SHOULD be limited to 128 slots to prevent spam and griefing.", "Parent Governed pattern": "The parent NFT of a nested token and the parent\u2019s root owner are in all aspects the true owners of it. Once you send a token to another one you give up ownership.", "Child token management": "This proposal introduces a number of child token management functions. In addition to the permissioned migration from\u201cPending\u201dto\u201cActive\u201dchild tokens array, the main token management function from this proposal is thetranferChildfunction. The following state transitions of a child token are available with it:", "Backwards Compatibility": "The Nestable token standard has been made compatible withERC-721in order to take advantage of the robust tooling available for implementations of ERC-721 and to ensure compatibility with existing ERC-721 infrastructure.", "Test Cases": "Tests are included innestable.ts.", "Reference Implementation": "SeeNestableToken.sol.", "Security Considerations": "The same security considerations as withERC-721apply: hidden logic may be present in any of the functions, including burn, add child, accept child, and more.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6066, "url": "https://eips.ethereum.org/EIPS/eip-6066", "title": "Signature Validation Method for NFTs", "authors": ["Jack Boyuan Xu\u00a0(", "@boyuanx", ")"], "sections": {"ERC-6066: Signature Validation Method for NFTs": "WhileExternallyOwnedAccounts can validate signed messages withecrecover()and smart contracts can validate signatures using specifications outlined inERC-1271, currently there is no standard method to create or validate signatures made by NFTs. We propose a standard way for anyone to validate whether a signature made by an NFT is valid. This is possible via a modified signature validation function originally found inERC-1271:isValidSignature(tokenId, hash, data).", "A way to verify signatures when the signing entity is an ERC-721 or ERC-1155 NFT": "WhileExternallyOwnedAccounts can validate signed messages withecrecover()and smart contracts can validate signatures using specifications outlined inERC-1271, currently there is no standard method to create or validate signatures made by NFTs. We propose a standard way for anyone to validate whether a signature made by an NFT is valid. This is possible via a modified signature validation function originally found inERC-1271:isValidSignature(tokenId, hash, data).", "Abstract": "WhileExternallyOwnedAccounts can validate signed messages withecrecover()and smart contracts can validate signatures using specifications outlined inERC-1271, currently there is no standard method to create or validate signatures made by NFTs. We propose a standard way for anyone to validate whether a signature made by an NFT is valid. This is possible via a modified signature validation function originally found inERC-1271:isValidSignature(tokenId, hash, data).", "Motivation": "With billions of ETH in trading volume, theNon-FungibleToken standard has exploded into tremendous popularity in recent years. Despite the far-reaching implications of having unique tokenized items on-chain, NFTs have mainly been used to represent artwork in the form of avatars or profile pictures. While this is certainly not a trivial use case for theERC-721&ERC-1155token standards, we reckon more can be done to aid the community in discovering alternative uses for NFTs.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "We have purposefully decided to not include a signature generation standard in this proposal as it would restrict flexibility of such mechanism, just asERC-1271does not enforce a signing standard for smart contracts. We also decided to reference Gnosis Safe\u2019s contract signing approach as it is both simplistic and proven to be adequate. Thebytes calldata dataparameter is considered optional if extra data is needed for signature verification, also conforming this EIP toERC-5750for future-proofing purposes.", "Backwards Compatibility": "This EIP is incompatible with previous work on signature validation as it does not validate any cryptographically generated signatures. Instead, signature is merely a boolean flag indicating consent. This is consistent with Gnosis Safe\u2019s contract signature implementation.", "Reference Implementation": "Example implementation of anERC-721compliant contract that conforms toERC-6066with a custom signing function:", "Security Considerations": "The revokable nature of contract-based signatures carries over to this EIP. Developers and users alike should take it into consideration.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6105, "url": "https://eips.ethereum.org/EIPS/eip-6105", "title": "No Intermediary NFT Trading Protocol", "authors": ["5660-eth\u00a0(", "@5660-eth", ")", "Silvere Heraudeau\u00a0(", "@lambdalf-dev", ")", "Martin McConnell\u00a0(", "@offgridgecko", ")", "Abu\u00a0<", "team10kuni@gmail.com", ">", "Wizard Wang"], "sections": {"ERC-6105: No Intermediary NFT Trading Protocol": "This ERC adds a marketplace functionality toERC-721to enable non-fungible token trading without relying on an intermediary trading platform. At the same time, creators may implement more diverse royalty schemes.", "Adds a marketplace functionality with more diverse royalty schemes to ERC-721": "This ERC adds a marketplace functionality toERC-721to enable non-fungible token trading without relying on an intermediary trading platform. At the same time, creators may implement more diverse royalty schemes.", "Abstract": "This ERC adds a marketplace functionality toERC-721to enable non-fungible token trading without relying on an intermediary trading platform. At the same time, creators may implement more diverse royalty schemes.", "Motivation": "Most current NFT trading relies on an NFT trading platform acting as an intermediary, which has the following problems:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL\nNOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d,\nand \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119\nand RFC 8174.", "Optional collection offer extension": "ThesalePricein thelistItemfunction cannot be set to zero. Firstly, it is a rare occurrence for a caller to set the price to 0, and when it happens, it is often due to an operational error which can result in loss of assets. Secondly, a caller needs to spend gas to call this function, so if he can set the token price to 0, his income would be actually negative at this time, which does not conform to the concept of \u2018economic man\u2019 in economics. Additionally, a token price of 0 indicates that the item is not for sale, making the reference implementation more concise.", "Optional item offer extension": "ThesalePricein thelistItemfunction cannot be set to zero. Firstly, it is a rare occurrence for a caller to set the price to 0, and when it happens, it is often due to an operational error which can result in loss of assets. Secondly, a caller needs to spend gas to call this function, so if he can set the token price to 0, his income would be actually negative at this time, which does not conform to the concept of \u2018economic man\u2019 in economics. Additionally, a token price of 0 indicates that the item is not for sale, making the reference implementation more concise.", "Rationale": "ThesalePricein thelistItemfunction cannot be set to zero. Firstly, it is a rare occurrence for a caller to set the price to 0, and when it happens, it is often due to an operational error which can result in loss of assets. Secondly, a caller needs to spend gas to call this function, so if he can set the token price to 0, his income would be actually negative at this time, which does not conform to the concept of \u2018economic man\u2019 in economics. Additionally, a token price of 0 indicates that the item is not for sale, making the reference implementation more concise.", "Considerations for some local variables": "ThesalePricein thelistItemfunction cannot be set to zero. Firstly, it is a rare occurrence for a caller to set the price to 0, and when it happens, it is often due to an operational error which can result in loss of assets. Secondly, a caller needs to spend gas to call this function, so if he can set the token price to 0, his income would be actually negative at this time, which does not conform to the concept of \u2018economic man\u2019 in economics. Additionally, a token price of 0 indicates that the item is not for sale, making the reference implementation more concise.", "More diverse royalty schemes": "By introducing the parameterbenchmarkPricein thelistItem,acceptCollectionOfferandacceptItemOfferfunctions, the_salePricein theroyaltyInfo(uint256 _tokenId, uint256 _salePrice)function in theERC-2981interface can be changed totaxablePrice, making the ERC-2981 royalty scheme more diverse. Here are several examples of royalty schemes:", "Optional Blocklist": "Some viewpoints suggest that tokens should be prevented from trading on intermediary markets that do not comply with royalty schemes, but this standard only provides a functionality for non-intermediary NFT trading and does not offer a standardized interface to prevent tokens from trading on these markets. If deemed necessary to better protect the interests of the project team and community, they may consider adding a blocklist to their implementation contracts to prevent NFTs from being traded on platforms that do not comply with the project\u2019s royalty scheme.", "Backwards Compatibility": "This standard is compatible withERC-721andERC-2981.", "Reference Implementation": "ThebuyItemfunction, as well as theacceptCollectionOfferandacceptItemOfferfunctions, has a potential front-running risk.  Must check thatsalePriceandsupportedTokenmatch the expected price and token to prevent front-running attacks", "Security Considerations": "ThebuyItemfunction, as well as theacceptCollectionOfferandacceptItemOfferfunctions, has a potential front-running risk.  Must check thatsalePriceandsupportedTokenmatch the expected price and token to prevent front-running attacks", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6147, "url": "https://eips.ethereum.org/EIPS/eip-6147", "title": "Guard of NFT/SBT, an Extension of ERC-721", "authors": ["5660-eth\u00a0(", "@5660-eth", ")", "Wizard Wang"], "sections": {"ERC-6147: Guard of NFT/SBT, an Extension of ERC-721": "This standard is an extension ofERC-721. It separates the holding right and transfer right of non-fungible tokens (NFTs) and Soulbound Tokens (SBTs) and defines a new role,guardwithexpires. The flexibility of theguardsetting enables the design of NFT anti-theft, NFT lending, NFT leasing, SBT, etc.", "A new management role with an expiration date of NFT/SBT is defined, achieving the separation of transfer right and holding right.": "This standard is an extension ofERC-721. It separates the holding right and transfer right of non-fungible tokens (NFTs) and Soulbound Tokens (SBTs) and defines a new role,guardwithexpires. The flexibility of theguardsetting enables the design of NFT anti-theft, NFT lending, NFT leasing, SBT, etc.", "Abstract": "This standard is an extension ofERC-721. It separates the holding right and transfer right of non-fungible tokens (NFTs) and Soulbound Tokens (SBTs) and defines a new role,guardwithexpires. The flexibility of theguardsetting enables the design of NFT anti-theft, NFT lending, NFT leasing, SBT, etc.", "Motivation": "NFTs are assets that possess both use and financial value.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Contract Interface": "ThechangeGuard(uint256 tokenId, address newGuard, uint64 expires)function MAY be implemented aspublicorexternal.", "Rationale": "There are many application scenarios for NFT/SBT, and there is no need to propose a dedicated EIP for each one, which would make the overall number of EIPS inevitably increase and add to the burden of developers. The standard is based on the analysis of the right attached to assets in the real world, and abstracts the right attached to NFT/SBT into holding right and transfer right making the standard more universal.", "Universality": "There are many application scenarios for NFT/SBT, and there is no need to propose a dedicated EIP for each one, which would make the overall number of EIPS inevitably increase and add to the burden of developers. The standard is based on the analysis of the right attached to assets in the real world, and abstracts the right attached to NFT/SBT into holding right and transfer right making the standard more universal.", "Extensibility": "This standard only defines aguardand itsexpires. For complex functions needed by NFTs and SBTs, such as social recovery and multi-signature, theguardcan be set as a third-party protocol address. Through the third-party protocol, more flexible and diverse functions can be achieved based on specific application scenarios.", "Naming": "The alternative names areguardianandguard, both of which basically match the permissions corresponding to the role: protection of NFT or necessary management according to its application scenarios. Theguardhas fewer characters than theguardianand is more concise.", "Backwards Compatibility": "This standard can be fully ERC-721 compatible by adding an extension function set.", "Reference Implementation": "Make sure to set an appropriateexpiresfor theguard, based on the specific application scenario.", "Security Considerations": "Make sure to set an appropriateexpiresfor theguard, based on the specific application scenario.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6150, "url": "https://eips.ethereum.org/EIPS/eip-6150", "title": "Hierarchical NFTs", "authors": ["Keegan Lee\u00a0(", "@keeganlee", ")", "msfew\u00a0<", "msfew@hyperoracle.io", ">", "Kartin\u00a0<", "kartin@hyperoracle.io", ">", "qizhou\u00a0(", "@qizhou", ")"], "sections": {"ERC-6150: Hierarchical NFTs": "This standard is an extension toEIP-721. It proposes a multi-layer filesystem-like hierarchical NFTs. This standard provides interfaces to get parent NFT or children NFTs and whether NFT is a leaf node or root node, maintaining the hierarchical relationship among them.", "Hierarchical NFTs, an extension to EIP-721.": "This standard is an extension toEIP-721. It proposes a multi-layer filesystem-like hierarchical NFTs. This standard provides interfaces to get parent NFT or children NFTs and whether NFT is a leaf node or root node, maintaining the hierarchical relationship among them.", "Abstract": "This standard is an extension toEIP-721. It proposes a multi-layer filesystem-like hierarchical NFTs. This standard provides interfaces to get parent NFT or children NFTs and whether NFT is a leaf node or root node, maintaining the hierarchical relationship among them.", "Motivation": "This EIP standardizes the interface of filesystem-like hierarchical NFTs and provides a reference implementation.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "As mentioned in the abstract, this EIP\u2019s goal is to have a simple interface for supporting Hierarchical NFTs. Here are a few design decisions and why they were made:", "Relationship between NFTs": "All NFTs will make up a hierarchical relationship tree. Each NFT is a node of the tree, maybe as a root node or a leaf node, as a parent node or a child node.", "Enumerable Extension": "This proposal standardizes three functions as an extension to support enumerable queries involving children nodes. Each function all have paramparentId, for compatibility, when theparentIdspecified zero means query root nodes.", "ParentTransferable Extension": "In some cases, such as filesystem, a directory or a file could be moved from one directory to another. So this proposal adds ParentTransferable Extension to support this situation.", "Access Control": "In a hierarchical structure, usually, there is more than one account has permission to operate a node, like mint children nodes, transfer node, burn node. This proposal adds a few functions as standard to check access control permissions.", "Backwards Compatibility": "This proposal is fully backward compatible withEIP-721.", "Reference Implementation": "Implementation:EIP-6150", "Security Considerations": "No security considerations were found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6220, "url": "https://eips.ethereum.org/EIPS/eip-6220", "title": "Composable NFTs utilizing Equippable Parts", "authors": ["Bruno \u0160kvorc\u00a0(", "@Swader", ")", "Cicada\u00a0(", "@CicadaNCR", ")", "Steven Pineda\u00a0(", "@steven2308", ")", "Stevan Bogosavljevic\u00a0(", "@stevyhacker", ")", "Jan Turk\u00a0(", "@ThunderDeliverer", ")"], "sections": {"ERC-6220: Composable NFTs utilizing Equippable Parts": "The Composable NFTs utilizing equippable parts standard extendsERC-721by allowing the NFTs to selectively add parts to themselves via equipping.", "An interface for Composable non-fungible tokens through fixed and slot parts equipping.": "The Composable NFTs utilizing equippable parts standard extendsERC-721by allowing the NFTs to selectively add parts to themselves via equipping.", "Abstract": "The Composable NFTs utilizing equippable parts standard extendsERC-721by allowing the NFTs to selectively add parts to themselves via equipping.", "Motivation": "With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having the ability for tokens to equip other tokens and be composed from a set of available parts allows for greater utility, usability and forward compatibility.", "Composing": "NFTs can work together to create a greater construct. Prior to this proposal, multiple NFTs could be composed into a single construct either by checking all of the compatible NFTs associated with a given account and used indiscriminately (which could result in unexpected result if there was more than one NFT intended to be used in the same slot), or by keeping a custom ledger of parts to compose together (either in a smart contract or an off-chain database). This proposal establishes a standardized framework for composable NFTs, where a single NFT can select which parts should be a part of the whole, with the information being on chain. Composing NFTs in such a way allows for virtually unbounded customization of the base NFT. An example of this could be a movie NFT. Some parts, like credits, should be fixed. Other parts, like scenes, should be interchangeable, so that various releases (base version, extended cuts, anniversary editions,\u2026) can be replaced.", "Token progression": "As the token progresses through various stages of its existence, it can attain or be awarded various parts. This can be explained in terms of gaming. A character could be represented by an NFT utilizing this proposal and would be able to equip gear acquired through the gameplay activities and as it progresses further in the game, better items would be available. In stead of having numerous NFTs representing the items collected through its progression, equippable parts can be unlocked and the NFT owner would be able to decide which items to equip and which to keep in the inventory (not equipped) without need of a centralized party.", "Merit tracking": "An equippable NFT can also be used to track merit. An example of this is academic merit. The equippable NFT in this case would represent a sort of digital portfolio of academic achievements, where the owner would be able to equip their diplomas, published articles and awards for all to see.", "Provable Digital Scarcity": "The majority of current NFT projects are only mock-scarce. Even with a limited supply of tokens, the utility of these (if any) is uncapped. As an example, you can log into 500 different instances of the same game using the same wallet and the same NFT. You can then equip the same hat onto 500 different in-game avatars at the same time, because its visual representation is just a client-side mechanic.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Equippable tokens": "The interface of the core smart contract of the equippable tokens.", "Catalog": "The interface of the Catalog containing the equippable parts. Catalogs are collections of equippable fixed and slot parts and are not restricted to a single collection, but can support any number of NFT collections.", "Rationale": "Designing the proposal, we considered the following questions:", "Fixed parts": "Fixed parts are defined and contained in the Catalog. They have their own metadata and are not meant to change through the lifecycle of the NFT.", "Slot parts": "Slot parts are defined and contained in the Catalog. They don\u2019t have their own metadata, but rather support equipping of selected NFT collections into them. The tokens equipped into the slots however, contain their own metadata. This allows for an equippable modifialbe content of the base NFT controlled by its owner. As they can be equipped into any number of tokens of any number of collections, they allow for reliable composing of the final tokens by vetting which NFTs can be equipped by a given slot once and then reused any number of times.", "Backwards Compatibility": "The Equippable token standard has been made compatible withERC-721in order to take advantage of the robust tooling available for implementations of ERC-721 and to ensure compatibility with existing ERC-721 infrastructure.", "Test Cases": "Tests are included inequippableFixedParts.tsandequippableSlotParts.ts.", "Reference Implementation": "SeeEquippableToken.sol.", "Security Considerations": "The same security considerations as withERC-721apply: hidden logic may be present in any of the functions, including burn, add resource, accept resource, and more.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6239, "url": "https://eips.ethereum.org/EIPS/eip-6239", "title": "Semantic Soulbound Tokens", "authors": ["Jessica Chang\u00a0(", "@JessicaChg", ")"], "sections": {"ERC-6239: Semantic Soulbound Tokens": "This proposal extendsERC-721andERC-5192by introducing Resource Description Framework (RDF) triples to Soulbound Tokens\u2019 (\u2018SBTs\u2018) metadata.", "Adding RDF triples to ERC-5192 token metadata to capture social meaning": "This proposal extendsERC-721andERC-5192by introducing Resource Description Framework (RDF) triples to Soulbound Tokens\u2019 (\u2018SBTs\u2018) metadata.", "Abstract": "This proposal extendsERC-721andERC-5192by introducing Resource Description Framework (RDF) triples to Soulbound Tokens\u2019 (\u2018SBTs\u2018) metadata.", "Motivation": "A Soulbound Token represents the commitments, credentials, and affiliations of accounts. RDF is a standard data model developed by the World Wide Web Consortium (\u2018W3C\u2019) and is used to represent information in a structured format. Semantic SBTs are built on existingERC-721andERC-5192standards to include RDF triples in metadata to capture and store the meaning of social metadata as a network of accounts and attributes.", "Connectedness": "Semantic SBTs store social data as RDF triples in the Subject-Predicate-Object format, making it easy to create relationships between accounts and attributes.  RDF is a standard for data interchange used to represent highly interconnected data. Representing data in RDF triples makes it simpler for automated systems to identify, clarify, and connect information.", "Linked Data": "Semantic SBTs allow the huge amount of social data on-chain to be available in a standard format (RDF) and be reachable and manageable. The interrelated datasets on-chain can create the linked data layer that allows social data to be mixed, exposed, and shared across different applications, providing a convenient, cheap, and reliable way to retrieve data, regardless of the number of users.", "Social Identity": "Semantic SBTs allow people to publish or attest their own identity-related data in a bottom-up and decentralized way, without reliance on any centralized intermediaries while setting every party free. The data is fragmentary in each Semantic SBT and socially interrelated. RDF triples enable various community detection algorithms to be built on top.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "RDF Statement": "RDF statements come in various formats, we have selected the six most commonly used formats:nt(N-Triples),ttl(Turtle),rdf(RDF/XML),rj(RDF/JSON),nq(N-Quads)andtrig(TriG).", "Contract Interface": "ISemanticRDFSchema, an extension of ERC-721 Metadata, isOPTIONALfor this standard, it is used to get the Schema URI for the RDF data.", "Method Specification": "rdfOf (uint256 tokenId): Query the RDF data for the Semantic Soulbound Token bytokenId. The returned RDF data format conforms to the W3C RDF standard. RDF data is a collection of RDF statements that are used to represent information about resources. An RDF statement, also known as a triple, is a unit of information in the RDF data model. It consists of three parts: a subject, a predicate, and an object.", "Event Specification": "CreateRDF: When minting a Semantic Soulbound Token, this eventMUSTbe triggered to notify the listener to perform operations with the created RDF data. When calling the event, the input RDF dataMUSTbe RDF statements, which are units of information consisting of three parts: a subject, a predicate, and an object.", "Rationale": "RDF is a flexible and extensible data model based on creating subject-predicate-object relationships, often used to model graph data due to its semantic web standards, Linked Data concept, flexibility, and query capabilities. RDF allows graph data to be easily integrated with other data sources on the web, making it possible to create more comprehensive and interoperable models. The advantage of using RDF for semantic description is that it can describe richer information, including terms, categories, properties, and relationships. RDF uses standard formats and languages to describe metadata, making the expression of semantic information more standardized and unified. This helps to establish more accurate and reliable semantic networks, promoting interoperability between different systems. Additionally, RDF supports semantic reasoning, which allows the system to automatically infer additional relationships and connections between nodes in the social graph based on the existing data.", "Backwards Compatibility": "This proposal is fully backward compatible withERC-721andERC-5192.", "Security Considerations": "There are no security considerations related directly to the implementation of this standard.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6381, "url": "https://eips.ethereum.org/EIPS/eip-6381", "title": "Public Non-Fungible Token Emote Repository", "authors": ["Bruno \u0160kvorc\u00a0(", "@Swader", ")", "Steven Pineda\u00a0(", "@steven2308", ")", "Stevan Bogosavljevic\u00a0(", "@stevyhacker", ")", "Jan Turk\u00a0(", "@ThunderDeliverer", ")"], "sections": {"ERC-6381: Public Non-Fungible Token Emote Repository": "The Public Non-Fungible Token Emote Repository standard provides an enhanced interactive utility forERC-721andERC-1155by allowing NFTs to be emoted at.", "React to any Non-Fungible Tokens using Unicode emojis.": "The Public Non-Fungible Token Emote Repository standard provides an enhanced interactive utility forERC-721andERC-1155by allowing NFTs to be emoted at.", "Abstract": "The Public Non-Fungible Token Emote Repository standard provides an enhanced interactive utility forERC-721andERC-1155by allowing NFTs to be emoted at.", "Motivation": "With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having the ability for anyone to interact with an NFT introduces an interactive aspect to owning an NFT and unlocks feedback-based NFT mechanics.", "Interactivity": "The ability to emote on an NFT introduces the aspect of interactivity to owning an NFT. This can either reflect the admiration for the emoter (person emoting to an NFT) or can be a result of a certain action performed by the token\u2019s owner. Accumulating emotes on a token can increase its uniqueness and/or value.", "Feedback based evolution": "Standardized on-chain reactions to NFTs allow for feedback based evolution.", "Valuation": "Current NFT market heavily relies on previous values the token has been sold for, the lowest price of the listed token and the scarcity data provided by the marketplace. There is no real time indication of admiration or desirability of a specific token. Having the ability for users to emote to the tokens adds the possibility of potential buyers and sellers gauging the value of the token based on the impressions the token has collected.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Message format for presigned emotes": "The message to be signed by theemoterin order for the reaction to be submitted by someone else is formatted as follows:", "Pre-determined address of the Emotable repository": "The address of the Emotable repository smart contract is designed to resemble the function it serves. It starts with0x311073which is the abstract representation ofEMOTE. The address is:", "Rationale": "Designing the proposal, we considered the following questions:", "Backwards Compatibility": "The Emote repository standard is fully compatible withERC-721and with the robust tooling available for implementations of ERC-721 as well as with the existing ERC-721 infrastructure.", "Test Cases": "Tests are included inemotableRepository.ts.", "Reference Implementation": "SeeEmotableRepository.sol.", "Security Considerations": "The proposal does not envision handling any form of assets from the user, so the assets should not be at risk when interacting with an Emote repository.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6454, "url": "https://eips.ethereum.org/EIPS/eip-6454", "title": "Minimal Transferable NFT detection interface", "authors": ["Bruno \u0160kvorc\u00a0(", "@Swader", ")", "Francesco Sullo\u00a0(", "@sullof", ")", "Steven Pineda\u00a0(", "@steven2308", ")", "Stevan Bogosavljevic\u00a0(", "@stevyhacker", ")", "Jan Turk\u00a0(", "@ThunderDeliverer", ")"], "sections": {"ERC-6454: Minimal Transferable NFT detection interface": "The Minimalistic Transferable interface for Non-Fungible Tokens standard extendsERC-721by introducing the ability to identify whether an NFT can be transferred or not.", "A minimal extension to identify the transferability of Non-Fungible Tokens.": "The Minimalistic Transferable interface for Non-Fungible Tokens standard extendsERC-721by introducing the ability to identify whether an NFT can be transferred or not.", "Abstract": "The Minimalistic Transferable interface for Non-Fungible Tokens standard extendsERC-721by introducing the ability to identify whether an NFT can be transferred or not.", "Motivation": "With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having the ability to prevent the tokens from being transferred introduces new possibilities of NFT utility and evolution.", "Verifiable attribution": "Personal achievements can be represented by non-fungible tokens. These tokens can be used to represent a wide range of accomplishments, including scientific advancements, philanthropic endeavors, athletic achievements, and more. However, if these achievement-indicating NFTs can be easily transferred, their authenticity and trustworthiness can be called into question. By binding the NFT to a specific account, it can be ensured that the account owning the NFT is the one that actually achieved the corresponding accomplishment. This creates a secure and verifiable record of personal achievements that can be easily accessed and recognized by others in the network. The ability to verify attribution helps to establish the credibility and value of the achievement-indicating NFT, making it a valuable asset that can be used as a recognition of the holder\u2019s accomplishments.", "Immutable properties": "NFT properties are a critical aspect of non-fungible tokens, serving to differentiate them from one another and establish their scarcity. Centralized control of NFT properties by the issuer, however, can undermine the uniqueness of these properties.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "Designing the proposal, we considered the following questions:", "Backwards Compatibility": "The Minimalistic Non-Transferable token standard is fully compatible withERC-721and with the robust tooling available for implementations of ERC-721 as well as with the existing ERC-721 infrastructure.", "Test Cases": "Tests are included intransferable.ts.", "Reference Implementation": "SeeERC721TransferableMock.sol.", "Security Considerations": "The same security considerations as withERC-721apply: hidden logic may be present in any of the functions, including burn, add asset, accept asset, and more.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6492, "url": "https://eips.ethereum.org/EIPS/eip-6492", "title": "Signature Validation for Predeploy Contracts", "authors": ["Ivo Georgiev\u00a0(", "@Ivshti", ")", "Agustin Aguilar\u00a0(", "@Agusx1211", ")"], "sections": {"ERC-6492: Signature Validation for Predeploy Contracts": "Contracts can sign verifiable messages viaERC-1271.", "A way to verify a signature when the account is a smart contract that has not been deployed yet": "Contracts can sign verifiable messages viaERC-1271.", "Abstract": "Contracts can sign verifiable messages viaERC-1271.", "Motivation": "With the rising popularity of account abstraction, we often find that the best user experience for contract wallets is to defer contract deployment until the first user transaction, therefore not burdening the user with an additional deploy step before they can use their account. However, at the same time, many dApps expect signatures, not only for interactions, but also just for logging in.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Signer side": "The signing contract will normally be a contract wallet, but it could be any contract that implementsERC-1271and is deployed counterfactually.", "Verifier side": "Full signature verification MUST be performed in the following order:", "Rationale": "We believe that wrapping the signature in a way that allows to pass the deploy data is the only clean way to implement this, as it\u2019s completely contract agnostic, but also easy to verify.", "Backwards Compatibility": "This ERC is backward compatible with previous work on signature validation, includingERC-1271and allows for easy verification of all signature types, including EOA signatures and typed data (EIP-712).", "UsingERC-6492for regular contract signatures": "The wrapper format described in this ERC can be used for all contract signatures, instead of plainERC-1271. This provides several advantages:", "Reference Implementation": "Below you can find an implementation of a universal verification contract that can be used both on-chain and off-chain, intended to be deployed as a singleton. It can validate signatures signed with this ERC,ERC-1271and traditionalecrecover.EIP-712is also supported by extension, as we validate the final digest (_hash).", "On-chain validation": "For on-chain validation, you could use two separate methods:", "Off-chain validation": "TheValidateSigOffchainhelper allows you to perform the universal validation in oneeth_call, without any pre-deployed contracts.", "Security Considerations": "The same considerations asERC-1271apply.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6538, "url": "https://eips.ethereum.org/EIPS/eip-6538", "title": "Stealth Meta-Address Registry", "authors": ["Matt Solomon\u00a0(", "@mds1", ")", "Toni Wahrst\u00e4tter\u00a0(", "@nerolation", ")", "Ben DiFrancesco\u00a0(", "@apbendi", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")", "Gary Ghayrat\u00a0(", "@garyghayrat", ")"], "sections": {"ERC-6538: Stealth Meta-Address Registry": "This specification defines a standardized way of storing and retrieving an entity\u2019s stealth meta-address, by extendingERC-5564. An entity may register their stealth meta-address directly. A third party can also register on behalf of an entity using a validEIP-712orEIP-1271signature. Once registered, the stealth meta-address for the entity can be retrieved by any smart contract or user. One can use the stealth meta-address withgenerateStealthAddressspecified inERC-5564to send assets to the generated stealth address without revealing the entity\u2019s address.", "A canonical contract for entities to register stealth meta-addresses directly or through a third party using signatures.": "This specification defines a standardized way of storing and retrieving an entity\u2019s stealth meta-address, by extendingERC-5564. An entity may register their stealth meta-address directly. A third party can also register on behalf of an entity using a validEIP-712orEIP-1271signature. Once registered, the stealth meta-address for the entity can be retrieved by any smart contract or user. One can use the stealth meta-address withgenerateStealthAddressspecified inERC-5564to send assets to the generated stealth address without revealing the entity\u2019s address.", "Abstract": "This specification defines a standardized way of storing and retrieving an entity\u2019s stealth meta-address, by extendingERC-5564. An entity may register their stealth meta-address directly. A third party can also register on behalf of an entity using a validEIP-712orEIP-1271signature. Once registered, the stealth meta-address for the entity can be retrieved by any smart contract or user. One can use the stealth meta-address withgenerateStealthAddressspecified inERC-5564to send assets to the generated stealth address without revealing the entity\u2019s address.", "Motivation": "The standardization of stealth address generation holds the potential to greatly enhance the privacy capabilities of Ethereum by enabling the recipient of a transfer to remain anonymous when receiving an asset. By introducing a central smart contract for users to store their stealth meta-addresses, EOAs and contracts can programmatically engage in stealth interactions using a variety of stealth address schemes.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Deployment Method": "TheERC6538Registrycontract is deployed at0x6538E6bf4B0eBd30A8Ea093027Ac2422ce5d6538usingCREATE2via the deterministic deployer at0x4e59b44847b379578588920ca78fbf26c0b4956cwith a salt of0x7cac4e512b1768c627c9e711c7a013f1ad0766ef5125c59fb7161dade58da078.", "Rationale": "Having a central smart contract for registering stealth meta-addresses has several benefits:", "Backwards Compatibility": "This EIP is fully backward compatible.", "Reference Implementation": "You can find an implementation of theERC6538Registrycontracthereand the interfaceIERC6538Registry.solhere.", "Security Considerations": "In the event of a compromised private key, the registrant should promptly un-register from the stealth key registry to prevent loss of future funds sent to the compromised account.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6672, "url": "https://eips.ethereum.org/EIPS/eip-6672", "title": "Multi-redeemable NFTs", "authors": ["RE:DREAMER Lab\u00a0<", "dev@redreamer.io", ">", "Archie Chang (@ArchieR7)\u00a0<", "archie@redreamer.io", ">", "Kai Yu (@chihkaiyu)\u00a0<", "kai@redreamer.io", ">", "Yonathan Randyanto (@Randyanto)\u00a0<", "randy@redreamer.io", ">", "Boyu Chu (@chuboyu)\u00a0<", "boyu@redreamer.io", ">", "Boxi Li (@boxi79)\u00a0<", "boxi@redreamer.io", ">", "Jason Cheng (@JasonCheng0729)\u00a0<", "jason@redreamer.io", ">"], "sections": {"ERC-6672: Multi-redeemable NFTs": "This EIP proposes an extension to theERC-721standard for Non-Fungible Tokens (NFTs) to enable multi-redeemable NFTs. Redemption provides a means for NFT holders to demonstrate ownership and eligibility of their NFT, which in turn enables them to receive a physical or digital item. This extension would allow an NFT to be redeemed in multiple scenarios and maintain a record of its redemption status on the blockchain.", "An extension of ERC-721 which enables an NFT to be redeemed in multiple scenarios for either a physical or digital object": "This EIP proposes an extension to theERC-721standard for Non-Fungible Tokens (NFTs) to enable multi-redeemable NFTs. Redemption provides a means for NFT holders to demonstrate ownership and eligibility of their NFT, which in turn enables them to receive a physical or digital item. This extension would allow an NFT to be redeemed in multiple scenarios and maintain a record of its redemption status on the blockchain.", "Abstract": "This EIP proposes an extension to theERC-721standard for Non-Fungible Tokens (NFTs) to enable multi-redeemable NFTs. Redemption provides a means for NFT holders to demonstrate ownership and eligibility of their NFT, which in turn enables them to receive a physical or digital item. This extension would allow an NFT to be redeemed in multiple scenarios and maintain a record of its redemption status on the blockchain.", "Motivation": "The motivation behind our proposed NFT standard is to provide a more versatile and flexible solution compared to existing standards, allowing for multi-redeemable NFTs. Our proposed NFT standard enables multi-redeemable NFTs, allowing them to be redeemed in multiple scenarios for different campaigns or events, thus unlocking new possibilities for commerce use cases and breaking the limitation of one-time redemption per NFT.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Redeem and Cancel Functions": "An operator SHALL only make an update to the redemption created by itself. Therefore, theredeem()andcancel()functions do not have an_operatorparameter, and themsg.senderaddress MUST be used as the_operator.", "Redemption Flag Key-Value Pairs": "The combination of_operator,_tokenId, and_redemptionIdMUST be used as the key in the redemption flag key-value pairs, whose value can be accessed from theisRedeemed()function.", "Metadata Extension": "The key format for theredemptionskey-value pairs MUST be standardized asoperator-tokenId-redemptionId, whereoperatoris the operator wallet address,tokenIdis  the identifier of the token that has been redeemed, andredemptionIdis the redemption identifier. The value of the keyoperator-tokenId-redemptionIdis an object that contains thestatusanddescriptionof the redemption.", "Rationale": "The combination of_operator,_tokenId, and_redemptionIdis chosen as the key because it provides a clear and unique identifier for each redemption transaction.", "Key Choices for Redemption Flag and Status": "The combination of_operator,_tokenId, and_redemptionIdis chosen as the key because it provides a clear and unique identifier for each redemption transaction.", "Backwards Compatibility": "This standard is compatible withERC-721.", "Reference Implementation": "The reference implementation of Multi-Redeemable NFT can be foundhere.", "Security Considerations": "An incorrect implementation ofERC-6672could potentially allow an unauthorized operator to access redemption flags owned by other operators, creating a security risk. As a result, an unauthorized operator could cancel the redemption process managed by other operators. Therefore, it is crucial forERC-6672implementations to ensure that only the operator who created the redemption, identified usingmsg.sender, can update the redemption flag using theredeem()andcancel()functions. It is also recommended to isolate theredeem()andcancel()functions fromERC-721approval models.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6808, "url": "https://eips.ethereum.org/EIPS/eip-6808", "title": "Fungible Key Bound Token", "authors": ["Mihai Onila\u00a0(", "@MihaiORO", ")", "Nick Zeman\u00a0(", "@NickZCZ", ")", "Narcis Cotaie\u00a0(", "@NarcisCRO", ")"], "sections": {"ERC-6808: Fungible Key Bound Token": "A standard interface for Fungible Key Bound Tokens (FKBT/s), a subset of the more general Key Bound Tokens (KBT/s).", "An interface for Fungible Key Bound Tokens, also known as a FKBT.": "A standard interface for Fungible Key Bound Tokens (FKBT/s), a subset of the more general Key Bound Tokens (KBT/s).", "Abstract": "A standard interface for Fungible Key Bound Tokens (FKBT/s), a subset of the more general Key Bound Tokens (KBT/s).", "Motivation": "In this fast-paced technologically advancing world, people learn and mature at different speeds. The goal of global adoption must take into consideration the target demographic is of all ages and backgrounds. Unfortunately for self-custodial assets, one of the greatest pros is also one of its greatest cons. The individual is solely responsible for their actions and adequately securing their assets. If a mistake is made leading to a loss of funds, no one is able to guarantee their return.", "Specification": "NOTES:", "IKBT20(Token Contract)": "NOTES:", "Events": "Emitted when the_accountis securing his account by calling theaddBindingsfunction.", "Interface functions": "The functions detailed below MUST be implemented.", "Rationale": "The intent from individual technical decisions made during the development ofFKBTsfocused on maintaining consistency and backward compatibility with ERC-20s, all the while offering self-custodial security features to the user. It was important thatFKBT\u2019sinherited all of ERC-20s characteristics to comply with requirements found in dApps which use fungible tokens on their platform. In doing so, it allowed for flawless backward compatibility to take place and gave the user the choice to decide if they want theirFKBTsto act withDefault Behaviors4. We wanted to ensure that wide-scale implementation and adoption ofFKBTscould take place immediately, without the greater collective needing to adapt and make changes to the already flourishing decentralized ecosystem.", "Backwards Compatibility": "KBT\u2019sare designed to be backward-compatible with existing token standards and wallets. Existing tokens and wallets will continue to function as normal, and will not be affected by the implementation ofFKBT\u2019s.", "Test Cases": "Theassetsdirectory has all thetests.", "Reference Implementation": "The implementation is located in theassetsdirectory. There\u2019s also adiagramwith the contract interactions.", "Security Considerations": "FKBT\u2019swere designed with security in mind every step of the way. Below are some design decisions that were rigorously discussed and thought through during the development process.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6809, "url": "https://eips.ethereum.org/EIPS/eip-6809", "title": "Non-Fungible Key Bound Token", "authors": ["Mihai Onila\u00a0(", "@MihaiORO", ")", "Nick Zeman\u00a0(", "@NickZCZ", ")", "Narcis Cotaie\u00a0(", "@NarcisCRO", ")"], "sections": {"ERC-6809: Non-Fungible Key Bound Token": "A standard interface for Non-Fungible Key Bound Tokens (NFKBT/s), a subset of the more general Key Bound Tokens (KBT/s).", "An interface for Non-Fungible Key Bound Tokens, also known as a NFKBT.": "A standard interface for Non-Fungible Key Bound Tokens (NFKBT/s), a subset of the more general Key Bound Tokens (KBT/s).", "Abstract": "A standard interface for Non-Fungible Key Bound Tokens (NFKBT/s), a subset of the more general Key Bound Tokens (KBT/s).", "Motivation": "In this fast-paced technologically advancing world, people learn and mature at different speeds. The goal of global adoption must take into consideration the target demographic is of all ages and backgrounds. Unfortunately for self-custodial assets, one of the greatest pros is also one of its greatest cons. The individual is solely responsible for their actions and adequately securing their assets. If a mistake is made leading to a loss of funds, no one is able to guarantee their return.", "Specification": "NOTES:", "IKBT721(Token Contract)": "NOTES:", "Events": "Emitted when the_accountis securing his account by calling theaddBindingsfunction.", "Interface functions": "The functions detailed below MUST be implemented.", "Rationale": "The intent from individual technical decisions made during the development ofNFKBTsfocused on maintaining consistency and backward compatibility with ERC-721s, all the while offering self-custodial security features to the user. It was important thatNFKBT\u2019sinherited all of ERC-721s characteristics to comply with requirements found in dApps which use non-fungible tokens on their platform. In doing so, it allowed for flawless backward compatibility to take place and gave the user the choice to decide if they want theirNFKBTsto act withDefault Behaviors4. We wanted to ensure that wide-scale implementation and adoption ofNFKBTscould take place immediately, without the greater collective needing to adapt and make changes to the already flourishing decentralized ecosystem.", "Backwards Compatibility": "KBT\u2019sare designed to be backward-compatible with existing token standards and wallets. Existing tokens and wallets will continue to function as normal, and will not be affected by the implementation ofNFKBT\u2019s.", "Test Cases": "Theassetsdirectory has all thetests.", "Reference Implementation": "The implementation is located in theassetsdirectory. There\u2019s also adiagramwith the contract interactions.", "Security Considerations": "NFKBT\u2019swere designed with security in mind every step of the way. Below are some design decisions that were rigorously discussed and thought through during the development process.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6982, "url": "https://eips.ethereum.org/EIPS/eip-6982", "title": "Efficient Default Lockable Tokens", "authors": ["Francesco Sullo\u00a0(", "@sullof", ")", "Alexe Spataru\u00a0(", "@urataps", ")"], "sections": {"ERC-6982: Efficient Default Lockable Tokens": "This proposal introduces a lockable interface forERC-721tokens that optimizes gas usage by eliminating unnecessary events. This interface forms the foundation for the creation and management of lockableERC-721tokens. It provides a gas-efficient approach by emitting aDefaultLocked(bool locked)event upon deployment, setting the initial lock status for all tokens, while individualLocked(uint256 indexed tokenId, bool locked)events handle subsequent status changes for specific tokens. The interface also includes a view functionlocked(uint256 tokenId)to return the current lock status of a token, and a view functiondefaultLocked()to query the default status of a newly minted token.", "A gas-efficient approach to lockable ERC-721 tokens": "This proposal introduces a lockable interface forERC-721tokens that optimizes gas usage by eliminating unnecessary events. This interface forms the foundation for the creation and management of lockableERC-721tokens. It provides a gas-efficient approach by emitting aDefaultLocked(bool locked)event upon deployment, setting the initial lock status for all tokens, while individualLocked(uint256 indexed tokenId, bool locked)events handle subsequent status changes for specific tokens. The interface also includes a view functionlocked(uint256 tokenId)to return the current lock status of a token, and a view functiondefaultLocked()to query the default status of a newly minted token.", "Abstract": "This proposal introduces a lockable interface forERC-721tokens that optimizes gas usage by eliminating unnecessary events. This interface forms the foundation for the creation and management of lockableERC-721tokens. It provides a gas-efficient approach by emitting aDefaultLocked(bool locked)event upon deployment, setting the initial lock status for all tokens, while individualLocked(uint256 indexed tokenId, bool locked)events handle subsequent status changes for specific tokens. The interface also includes a view functionlocked(uint256 tokenId)to return the current lock status of a token, and a view functiondefaultLocked()to query the default status of a newly minted token.", "Motivation": "Existing lockable token proposals often mandate the emission of an event each time a token is minted. This results in unnecessary gas consumption, especially in cases where tokens are permanently locked from inception to destruction (e.g., soulbounds or non-transferable badges). This proposal offers a more gas-efficient solution that only emits events upon contract deployment and status changes of individual tokens.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "This standard seeks to optimize gas consumption by minimizing the frequency of event emission. TheDefaultLockedevent is designed to establish the lock status for all tokens, thereby circumventing the need to emit an event each time a new token is minted. It\u2019s crucial to note that theDefaultLockedevent can be emitted at any point in time, and is not restricted to only before theLockedevents are emitted.", "Backwards Compatibility": "This standard is fully backwards compatible with existingERC-721contracts. It can be easily integrated into existing contracts and will not cause any conflicts or disruptions.", "Reference Implementation": "An example implementation is located in theassetsdirectory.", "Security Considerations": "This EIP does not introduce any known security considerations. However, as with any smart contract standard, it is crucial to employ rigorous security measures in the implementation of this interface.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7007, "url": "https://eips.ethereum.org/EIPS/eip-7007", "title": "Verifiable AI-Generated Content Token", "authors": ["Cathie So\u00a0(", "@socathie", ")", "Xiaohang Yu\u00a0(", "@xhyumiracle", ")", "Conway\u00a0(", "@0x1cc", ")", "Lee Ting Ting\u00a0(", "@tina1998612", ")", "Kartin\u00a0<", "kartin@hyperoracle.io", ">"], "sections": {"ERC-7007: Verifiable AI-Generated Content Token": "The verifiable AI-generated content (AIGC) non-fungible token (NFT) standard is an extension of theERC-721token standard for AIGC. It proposes a set of interfaces for basic interactions and enumerable interactions for AIGC-NFTs. The standard includes anaddAigcDataandverifyfunction interface, a newAigcDataevent, optionalEnumerableandUpdatableextensions, and a JSON schema for AIGC-NFT metadata. Additionally, it incorporates Zero-Knowledge Machine Learning (zkML) and Optimistic Machine Learning (opML) capabilities to enable verification of AIGC data correctness. In this standard, thetokenIdis indexed by theprompt.", "An ERC-721 extension for verifiable AI-generated content tokens using Zero-Knowledge and Optimistic Machine Learning techniques": "The verifiable AI-generated content (AIGC) non-fungible token (NFT) standard is an extension of theERC-721token standard for AIGC. It proposes a set of interfaces for basic interactions and enumerable interactions for AIGC-NFTs. The standard includes anaddAigcDataandverifyfunction interface, a newAigcDataevent, optionalEnumerableandUpdatableextensions, and a JSON schema for AIGC-NFT metadata. Additionally, it incorporates Zero-Knowledge Machine Learning (zkML) and Optimistic Machine Learning (opML) capabilities to enable verification of AIGC data correctness. In this standard, thetokenIdis indexed by theprompt.", "Abstract": "The verifiable AI-generated content (AIGC) non-fungible token (NFT) standard is an extension of theERC-721token standard for AIGC. It proposes a set of interfaces for basic interactions and enumerable interactions for AIGC-NFTs. The standard includes anaddAigcDataandverifyfunction interface, a newAigcDataevent, optionalEnumerableandUpdatableextensions, and a JSON schema for AIGC-NFT metadata. Additionally, it incorporates Zero-Knowledge Machine Learning (zkML) and Optimistic Machine Learning (opML) capabilities to enable verification of AIGC data correctness. In this standard, thetokenIdis indexed by theprompt.", "Motivation": "The verifiable AIGC-NFT standard aims to extend the existingERC-721token standard to accommodate the unique requirements of AI-generated content NFTs representing models in a collection. This standard provides interfaces to use zkML or opML to verify whether or not the AIGC data for an NFT is generated from a certain ML model with a certain input (prompt). The proposed interfaces allow for additional functionality related to adding AIGC data, verifying, and enumerating AIGC-NFTs. Additionally, the metadata schema provides a structured format for storing information related to AIGC-NFTs, such as the prompt used to generate the content and the proof of ownership.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Optional Extension: Enumerable": "Theenumeration extensionis OPTIONAL forERC-7007smart contracts. This allows your contract to publish its full list of mapping betweentokenIdandpromptand make them discoverable.", "Optional Extension: Updatable": "Theupdatable extensionis OPTIONAL forERC-7007smart contracts. This allows your contract to update a token\u2019saigcDatain the case of opML, whereaigcDatacontent might change over the challenge period.", "ERC-7007 Metadata JSON Schema for reference": "While this standard does not describe the Machine Learning model publication stage, it is natural and recommended to publish the commitment of the Model to Ethereum separately, before any actualaddAigcDataactions. The model commitment schema choice lies on the AIGC-NFT project issuer party. The commitment should be checked inside the implementation of theverifyfunction.", "ML Model Publication": "While this standard does not describe the Machine Learning model publication stage, it is natural and recommended to publish the commitment of the Model to Ethereum separately, before any actualaddAigcDataactions. The model commitment schema choice lies on the AIGC-NFT project issuer party. The commitment should be checked inside the implementation of theverifyfunction.", "Rationale": "This specification sets thetokenIdto be the hash of its correspondingprompt, creating a deterministic and collision-resistant way to associate tokens with their unique content generation parameters. This design decision ensures that the same prompt (which corresponds to the same AI-generated content under the same model seed) cannot be minted more than once, thereby preventing duplication and preserving the uniqueness of each NFT within the ecosystem.", "Unique Token Identification": "This specification sets thetokenIdto be the hash of its correspondingprompt, creating a deterministic and collision-resistant way to associate tokens with their unique content generation parameters. This design decision ensures that the same prompt (which corresponds to the same AI-generated content under the same model seed) cannot be minted more than once, thereby preventing duplication and preserving the uniqueness of each NFT within the ecosystem.", "Generalization to Different Proof Types": "This specification accommodates two proof types: validity proofs for zkML and fraud proofs for opML. Function arguments inaddAigcDataandverifyare designed for generality, allowing for compatibility with both proof systems. Moreover, the specification includes an updatable extension that specifically serves the requirements of opML.", "verifyinterface": "We specify averifyinterface to enforce the correctness ofaigcData. It is defined as a view function to reduce gas cost.verifyshould return true if and only ifaigcDatais finalized in both zkML and opML. In zkML, it must verify the ZK proof, i.e.proof; in opML, it must make sure that the challenging period is finalized, and that theaigcDatais up-to-date, i.e. has been updated after finalization. Additionally,proofcan beemptyin opML.", "addAigcDatainterface": "We specify anaddAigcDatainterface to bind the prompt andaigcDatawithtokenId. This function provides flexibility for different minting implementations. Notably, it acts differently in zkML and opML cases. In zkML,addAigcDatashould make sureverifyreturnstrue. While in opML, it can be called before finalization. The consideration here is that, limited by the proving difficulty, zkML usually targets simple model inference tasks in practice, making it possible to provide a proof within an acceptable time frame. On the other hand, opML enables large model inference tasks, with a cost of longer confirmation time to achieve the approximate same security level. Mint until opML finalization may not be the best practice considering the existing optimistic protocols.", "Naming Choice onupdate": "We adopt \u201cupdate\u201d over \u201cfinalize\u201d because a successful challenge happens rarely in practice. Usingupdatecould avoid calling it for everytokenIdand save gas.", "Backwards Compatibility": "This standard is backward compatible with theERC-721as it extends the existing functionality with new interfaces.", "Test Cases": "The reference implementation includes sample implementations of theERC-7007interfaces undercontracts/and corresponding unit tests undertest/. This repo can be used to test the functionality of the proposed interfaces and metadata schema.", "Reference Implementation": "To address the risk of frontrunning, where an actor could potentially observe and preemptively claim a prompt during the minting process, implementers of this proposal must incorporate a secure prompt-claiming mechanism. Implementations could include time-locks, commit-reveal schemes, or other anti-frontrunning techniques to ensure equitable and secured claim processes for AIGC-NFTs.", "Security Considerations": "To address the risk of frontrunning, where an actor could potentially observe and preemptively claim a prompt during the minting process, implementers of this proposal must incorporate a secure prompt-claiming mechanism. Implementations could include time-locks, commit-reveal schemes, or other anti-frontrunning techniques to ensure equitable and secured claim processes for AIGC-NFTs.", "Frontrunning Risk": "To address the risk of frontrunning, where an actor could potentially observe and preemptively claim a prompt during the minting process, implementers of this proposal must incorporate a secure prompt-claiming mechanism. Implementations could include time-locks, commit-reveal schemes, or other anti-frontrunning techniques to ensure equitable and secured claim processes for AIGC-NFTs.", "AIGC Data Change During Challenge Period": "In the opML scenario, it is important to consider that theaigcDatamight change during the challenge period due to disputes or updates. The updatable extension defined here provides a way to handle these updates. Implementations must ensure that updates toaigcDataare treated as critical state changes that require adherence to the same security and validation protocols as the initial minting process. Indexers should always check for anyUpdateevent emission.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7053, "url": "https://eips.ethereum.org/EIPS/eip-7053", "title": "Interoperable Digital Media Indexing", "authors": ["Bofu Chen\u00a0(", "@bafu", ")", "Tammy Yang\u00a0(", "@tammyyang", ")"], "sections": {"ERC-7053: Interoperable Digital Media Indexing": "This EIP proposes an interoperable indexing strategy designed to enhance the organization and retrieval of digital media information across multiple smart contracts and EVM-compatible blockchains. This system enhances the traceability and verification of cross-contract and cross-chain data, facilitating a more efficient discovery of storage locations and crucial information related to media assets. The major purpose is to foster an integrated digital media environment on the blockchain.", "A universal indexing method to record, discover and retrieve the history of digital media on EVM-compatible blockchains.": "This EIP proposes an interoperable indexing strategy designed to enhance the organization and retrieval of digital media information across multiple smart contracts and EVM-compatible blockchains. This system enhances the traceability and verification of cross-contract and cross-chain data, facilitating a more efficient discovery of storage locations and crucial information related to media assets. The major purpose is to foster an integrated digital media environment on the blockchain.", "Abstract": "This EIP proposes an interoperable indexing strategy designed to enhance the organization and retrieval of digital media information across multiple smart contracts and EVM-compatible blockchains. This system enhances the traceability and verification of cross-contract and cross-chain data, facilitating a more efficient discovery of storage locations and crucial information related to media assets. The major purpose is to foster an integrated digital media environment on the blockchain.", "Motivation": "Given the significant role digital media files play on the Internet, it\u2019s crucial to have a robust and efficient method for indexing immutable information. Existing systems encounter challenges due to the absence of a universal, interoperable identifier for digital media content. This leads to fragmentation and complications in retrieving metadata, storage information, or the provenance of specific media assets. The issues become increasingly critical as the volume of digital media continues to expand.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Content Identifier": "Content Identifier in this EIP is the content address generated by passing the content of a digital media through a cryptographic hash function. Before the indexing process for digital media can begin, it is REQUIRED to generate unique Content Identifiers for each file. This identifier should the same as the Content Identifiers on the decentralized storage, ensuring each identifier provides access to the metadata, media information, and the content file itself.", "Commit Function": "To index digital media, we shall call the commit function and generate Commit event:", "Rationale": "The design decisions in this EIP prioritize the effectiveness and efficiency of the indexing method. To achieve this, Decentralized Content Identifiers (CIDs) are utilized to uniquely identify digital media content across all systems. This approach offers accurate and precise searching of media, along with the following benefits:", "Reference Implementation": "When implementing this EIP, it\u2019s essential to address several security aspects to ensure the safety and integrity of the digital media index:", "Security Considerations": "When implementing this EIP, it\u2019s essential to address several security aspects to ensure the safety and integrity of the digital media index:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7066, "url": "https://eips.ethereum.org/EIPS/eip-7066", "title": "Lockable Extension for ERC-721", "authors": ["Piyush Chittara\u00a0(", "@piyush-chittara", ")", "StreamNFT\u00a0(", "@streamnft-tech", ")", "Srinivas Joshi\u00a0(", "@SrinivasJoshi", ")"], "sections": {"ERC-7066: Lockable Extension for ERC-721": "An extension ofERC-721, this standard incorporateslockingfeatures into NFTs, allowing for various uses while preventing sale or transfer. The token\u2019sownercanlockit, setting up locker address (either an EOA or a contract) that exclusively holds the power to unlock the token. Owner can also provide approval fortokenId, enabling ability to lock asset while address holds the token approval. Token can also be locked byapproved, assigning locker to itself. Upon token transfer, these rights get purged.", "Interface for enabling locking of ERC-721 using locker and approved": "An extension ofERC-721, this standard incorporateslockingfeatures into NFTs, allowing for various uses while preventing sale or transfer. The token\u2019sownercanlockit, setting up locker address (either an EOA or a contract) that exclusively holds the power to unlock the token. Owner can also provide approval fortokenId, enabling ability to lock asset while address holds the token approval. Token can also be locked byapproved, assigning locker to itself. Upon token transfer, these rights get purged.", "Abstract": "An extension ofERC-721, this standard incorporateslockingfeatures into NFTs, allowing for various uses while preventing sale or transfer. The token\u2019sownercanlockit, setting up locker address (either an EOA or a contract) that exclusively holds the power to unlock the token. Owner can also provide approval fortokenId, enabling ability to lock asset while address holds the token approval. Token can also be locked byapproved, assigning locker to itself. Upon token transfer, these rights get purged.", "Motivation": "ERC-721has sparked an unprecedented surge in demand for NFTs. However, despite this tremendous success, the NFT economy suffers from secondary liquidity where it remains illiquid in owner\u2019s wallet. There are projects which aim to address the liquidity challenge, but they entail the below mentioned inconveniences and risks for owners as they necessitate transferring the participating NFTs to the projects\u2019 contracts.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Overview": "ERC-721compliant contracts MAY implement this EIP to provide standard methods of locking and unlocking the token at its current owner address.", "Interface": "This proposal setlocker[tokenId]toaddress(0)when token isunlockedbecause we delete mapping onlocker[tokenId]freeing up space. Also, this assertion helps our contract to validate if token islockedorunlockedfor internal function calls.", "Rationale": "This proposal setlocker[tokenId]toaddress(0)when token isunlockedbecause we delete mapping onlocker[tokenId]freeing up space. Also, this assertion helps our contract to validate if token islockedorunlockedfor internal function calls.", "Backwards Compatibility": "This standard is compatible withERC-721standards.", "Test Cases": "Test cases can be foundhere.", "Reference Implementation": "Reference Interface can be foundhere.", "Security Considerations": "There are no security considerations related directly to the implementation of this standard for the contract that managesERC-721.", "Considerations for the contracts that work with lockable tokens": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7092, "url": "https://eips.ethereum.org/EIPS/eip-7092", "title": "Financial Bonds", "authors": ["Samuel Gwlanold Edoumou\u00a0(", "@Edoumou", ")"], "sections": {"ERC-7092: Financial Bonds": "This proposal introduces fixed-income financial bonds with key characteristics defined to facilitate bond issuance in the primary market and enable buying or selling bonds in the secondary market. The standard also provides cross-chain functionalities for bonds operations and management accross multiple blockchains.", "Represents debt issued by entities to investors.": "This proposal introduces fixed-income financial bonds with key characteristics defined to facilitate bond issuance in the primary market and enable buying or selling bonds in the secondary market. The standard also provides cross-chain functionalities for bonds operations and management accross multiple blockchains.", "Abstract": "This proposal introduces fixed-income financial bonds with key characteristics defined to facilitate bond issuance in the primary market and enable buying or selling bonds in the secondary market. The standard also provides cross-chain functionalities for bonds operations and management accross multiple blockchains.", "Motivation": "Fixed-income instruments are a widely utilized asset class for corporations and other entities raising funds. However, transitioning to tokenized bonds is challenging due to existing standards likeERC-3475, which introduces unfamiliar concepts and leads to unnecessary gas consumption. Additionally, the lack of named variables like coupon, maturity date, and principal, makes it difficult to implement ERC-3475 since developers need to remember which metadata is assigned to each parameter.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Additional bond parameters Interface": "TheIERC7092ESGinterface is OPTIONAL for contracts implementing this proposal. This interface MAY be used to improve the standard usability.", "Cross-chain Interface": "The standard permits the implementation of theIERC7092CrossChaininterface for cross-chain management of bond tokens. This interface is OPTIONAL and may be used by applications to allow cross-chain transactions. Any function initiating a cross-chain transaction MUST explicitly define the destination chain identifierdestinationChainIDand specify the target smart contractdestinationContract.", "Rationale": "The design of this ERC aims to simplify the migration to tokenized bonds by maintaining consistency with traditional bond standards. This approach allows fixed-income instruments to be represented as on-chain tokens, manageable through wallets, and utilized by applications like decentralized exchanges, while avoiding the complexities and inefficiencies associated with other standards. This ERC facilitates the creation of new bond tokens with characteristics akin to traditional bonds, enhancing accessibility, liquidity, and cost-efficiency in bond trading and management.", "Total Supply and Account Balance": "ThetotalSupplyandbalanceOffunctions are not defined as they can be derived fromissueVolumeandprincipalOf, anddenomination. However, these functions can be be added in any contract implementing this standard, ensuring the proper relationship between these values.", "Backwards Compatibility": "This ERC is not backwards compatible with existing standards likeERC-20orERC-1155due to the absence of certain functions liketotalSupplyorbalanceOf. A pure implementation of this standard is RECOMMENDED for issuing tokenized bonds, as any hybrid solution with other mentioned standards SHOULD fail.", "Reference Implementation": "The complete Reference Implementation can be foundhere.", "CALLABLE BONDS:": "This standard is designed specifically for tokenizing bonds. It does not inherently manage information pertaining to bondholders\u2019 identities. However, to enhance compliance with regulatory requirements and improve transparency, an identity registry can be added  on top of this standard to store the identity of all authorized investors.", "PUTTABLE BONDS:": "This standard is designed specifically for tokenizing bonds. It does not inherently manage information pertaining to bondholders\u2019 identities. However, to enhance compliance with regulatory requirements and improve transparency, an identity registry can be added  on top of this standard to store the identity of all authorized investors.", "CONVERTIBLE BONDS:": "This standard is designed specifically for tokenizing bonds. It does not inherently manage information pertaining to bondholders\u2019 identities. However, to enhance compliance with regulatory requirements and improve transparency, an identity registry can be added  on top of this standard to store the identity of all authorized investors.", "Identity Registry": "This standard is designed specifically for tokenizing bonds. It does not inherently manage information pertaining to bondholders\u2019 identities. However, to enhance compliance with regulatory requirements and improve transparency, an identity registry can be added  on top of this standard to store the identity of all authorized investors.", "Security Considerations": "Implementing this ERC requires careful consideration of security risks related to functions approving operators to manage owner\u2019s bonds and functions allowing bond transfers. The use of these functions necessitates robust validation to ensure only the bond owner or approved accounts can call them.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7160, "url": "https://eips.ethereum.org/EIPS/eip-7160", "title": "ERC-721 Multi-Metadata Extension", "authors": ["0xG\u00a0(", "@0xGh", ")", "Marco Peyfuss\u00a0(", "@mpeyfuss", ")"], "sections": {"ERC-7160: ERC-721 Multi-Metadata Extension": "This EIP proposes an extension to theERC-721standard to support multiple metadata URIs per token. It introduces a new interface,IERC721MultiMetadata, which provides methods for accessing the metadata URIs associated with a token, including a pinned URI index and a list of all metadata URIs. The extension is designed to be backward compatible with existingERC721Metadataimplementations.", "Multiple metadata URIs per token, with the option to pin a primary URI.": "This EIP proposes an extension to theERC-721standard to support multiple metadata URIs per token. It introduces a new interface,IERC721MultiMetadata, which provides methods for accessing the metadata URIs associated with a token, including a pinned URI index and a list of all metadata URIs. The extension is designed to be backward compatible with existingERC721Metadataimplementations.", "Abstract": "This EIP proposes an extension to theERC-721standard to support multiple metadata URIs per token. It introduces a new interface,IERC721MultiMetadata, which provides methods for accessing the metadata URIs associated with a token, including a pinned URI index and a list of all metadata URIs. The extension is designed to be backward compatible with existingERC721Metadataimplementations.", "Motivation": "The currentERC-721standard allows for a single metadata URI per token with theERC721Metadataimplementation. However, there are use cases where multiple metadata URIs are desirable. Some example use cases are listed below:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "Similar terminology toERC-721was used in order to keep fetching metadata familiar. The concept of pinning and unpinning metadata is introduced as it is clear that NFT owners might want to choose which piece of metadata to display. At first, we considered leaving the pinning and unpinning actions up to each developer, but realized that a standard interface for pinning and unpinning allows for dApps to easily implement universal support for multi-metadata tokens.", "Backwards Compatibility": "This extension is designed to be backward compatible with existingERC-721contracts. The implementation of thetokenURImethod must either return the pinned token uri (if pinned) or some default uri (if unpinned).", "Reference Implementation": "An open-source reference implementation of theIERC721MultiMetadatainterface can be provided, demonstrating how to extend an existingERC-721contract to support multi-metadata functionality. This reference implementation can serve as a guide for developers looking to implement the extension in their own contracts.", "Security Considerations": "Care should be taken when specifying access controls for state changing events, such as those that allow uris to be added to tokens\nand those specified in this standard: thepinTokenUriandunpinTokenUrifunctions. This is up to the developers to specify\nas each application may have different requirements to allow for pinning and unpinning.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7201, "url": "https://eips.ethereum.org/EIPS/eip-7201", "title": "Namespaced Storage Layout", "authors": ["Francisco Giordano\u00a0(", "@frangio", ")", "Hadrien Croubois\u00a0(", "@Amxx", ")", "Ernesto Garc\u00eda\u00a0(", "@ernestognw", ")", "Eric Lau\u00a0(", "@ericglau", ")"], "sections": {"ERC-7201: Namespaced Storage Layout": "We define the NatSpec annotation@custom:storage-locationto document storage namespaces and their location in storage in Solidity or Vyper source code. Additionally, we define a formula to derive a location from an arbitrary identifier. The formula is chosen to be safe against collisions with the storage layouts used by Solidity and Vyper.", "Conventions for the storage location of structs in the namespaced storage pattern.": "We define the NatSpec annotation@custom:storage-locationto document storage namespaces and their location in storage in Solidity or Vyper source code. Additionally, we define a formula to derive a location from an arbitrary identifier. The formula is chosen to be safe against collisions with the storage layouts used by Solidity and Vyper.", "Abstract": "We define the NatSpec annotation@custom:storage-locationto document storage namespaces and their location in storage in Solidity or Vyper source code. Additionally, we define a formula to derive a location from an arbitrary identifier. The formula is chosen to be safe against collisions with the storage layouts used by Solidity and Vyper.", "Motivation": "Smart contract languages such as Solidity and Vyper rely on tree-shaped storage layout. This tree starts at slot 0 and is composed of sequential chunks for consecutive variables. Hashes are used to ensure the chunks containing values of mappings and dynamic arrays do not collide. This is sufficient for most contracts. However, it presents a challenge for various design patterns used in smart contract development. One example is a modular design where usingDELEGATECALLa contract executes code from multiple contracts, all of which share the same storage space, and which have to carefully coordinate on how to use it. Another example is upgradeable contracts, where it can be difficult to add state variables in an upgrade given that they may affect the assigned storage location for the preexisting variables.", "Specification": "Anamespaceconsists of a set of ordered variables, some of which may be dynamic arrays or mappings, with its values laid out following the same rules as the default storage layout but rooted in some location that is not necessarily slot 0. A contract using namespaces to organize storage is said to usenamespaced storage.", "Preliminaries": "Anamespaceconsists of a set of ordered variables, some of which may be dynamic arrays or mappings, with its values laid out following the same rules as the default storage layout but rooted in some location that is not necessarily slot 0. A contract using namespaces to organize storage is said to usenamespaced storage.", "@custom:storage-location": "A namespace in a contract should be implemented as a struct type. These structs should be annotated with the NatSpec tag@custom:storage-location <FORMULA_ID>:<NAMESPACE_ID>, where<FORMULA_ID>identifies a formula used to compute the storage location where the namespace is rooted, based on the namespace id.(Note: The Solidity compiler includes this annotation in the AST since v0.8.20, so this is recommended as the minimum compiler version when using this pattern.)Structs with this annotation found outside of contracts are not considered to be namespaces for any contract in the source code.", "Formula": "The formula identified byerc7201is defined aserc7201(id: string) = keccak256(keccak256(id) - 1) & ~0xff. In Solidity, this corresponds to the expressionkeccak256(abi.encode(uint256(keccak256(bytes(id))) - 1)) & ~bytes32(uint256(0xff)). When using this formula the annotation becomes@custom:storage-location erc7201:<NAMESPACE_ID>. For example,@custom:storage-location erc7201:foobarannotates a namespace with id\"foobar\"rooted aterc7201(\"foobar\").", "Rationale": "The tree-shaped storage layout used by Solidity and Vyper follows the following grammar (with root=0):", "Naming": "This pattern has sometimes been referred to as \u201cdiamond storage\u201d. This causes it to be conflated with the \u201cdiamond proxy pattern\u201d, even though they can be used independently of each other. This EIP has chosen to use a different name to clearly differentiate it from the proxy pattern.", "Backwards Compatibility": "No backward compatibility issues found.", "Reference Implementation": "Namespaces should avoid collisions with other namespaces or with standard Solidity or Vyper storage layout. The formula defined in this ERC guarantees this property for arbitrary namespace ids under the assumption of keccak256 collision resistance, as discussed in Rationale.", "Security Considerations": "Namespaces should avoid collisions with other namespaces or with standard Solidity or Vyper storage layout. The formula defined in this ERC guarantees this property for arbitrary namespace ids under the assumption of keccak256 collision resistance, as discussed in Rationale.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7208, "url": "https://eips.ethereum.org/EIPS/eip-7208", "title": "On-Chain Data Containers", "authors": ["Rachid Ajaja\u00a0(", "@abrajaja", ")", "Matthijs de Vries\u00a0(", "@sudomati", ")", "Alexandros Athanasopulos\u00a0(", "@Xaleee", ")", "Pavel Rubin\u00a0(", "@pash7ka", ")", "Sebastian Galimberti Romano\u00a0(", "@galimba", ")", "Daniel Berbesi\u00a0(", "@berbex", ")", "Apostolos Mavropoulos\u00a0(", "@ApostolosMavro", ")", "Barbara Marcano\u00a0(", "@Barbara-Marcano", ")", "Daniel Ortega\u00a0(", "@xdaniortega", ")"], "sections": {"ERC-7208: On-Chain Data Containers": "This ERC defines a series of interfaces for the abstraction of storage of on-chain data by implementing the logic functions that govern such data on independent smart contracts. \u201cOn-chain Data Containers\u201d (ODCs) refer to the separation and indexing of data storage away from data management. We propose that on-chain data can be abstracted and stored in smart contracts called \u201cData Objects\u201d (DO), which answer to external data indexing mechanisms named \u201cData Points\u201d (DP). This data can be accessed and modified by implementing (one or many) separate smart contracts identified as \u201cData Managers\u201d (DM). We introduce two mechanisms for access management: first, through a \u201cData Index\u201d (DI) implementation, the \u201cData Managers\u201d (DM) can be gated from accessing \u201cData Objects\u201d (DO); second, a \u201cData Point Registry\u201d (DPR) implementation manages the issuance of \u201cData Points\u201d (DP). Lastly, we introduce the concept of data portability (horizontal data mobility) between implementations of \u201cData Index\u201d (DI), enabling massive updates to the logic without affecting the underlying data storage.", "Interoperability by abstracting logic away from storage": "This ERC defines a series of interfaces for the abstraction of storage of on-chain data by implementing the logic functions that govern such data on independent smart contracts. \u201cOn-chain Data Containers\u201d (ODCs) refer to the separation and indexing of data storage away from data management. We propose that on-chain data can be abstracted and stored in smart contracts called \u201cData Objects\u201d (DO), which answer to external data indexing mechanisms named \u201cData Points\u201d (DP). This data can be accessed and modified by implementing (one or many) separate smart contracts identified as \u201cData Managers\u201d (DM). We introduce two mechanisms for access management: first, through a \u201cData Index\u201d (DI) implementation, the \u201cData Managers\u201d (DM) can be gated from accessing \u201cData Objects\u201d (DO); second, a \u201cData Point Registry\u201d (DPR) implementation manages the issuance of \u201cData Points\u201d (DP). Lastly, we introduce the concept of data portability (horizontal data mobility) between implementations of \u201cData Index\u201d (DI), enabling massive updates to the logic without affecting the underlying data storage.", "Abstract": "This ERC defines a series of interfaces for the abstraction of storage of on-chain data by implementing the logic functions that govern such data on independent smart contracts. \u201cOn-chain Data Containers\u201d (ODCs) refer to the separation and indexing of data storage away from data management. We propose that on-chain data can be abstracted and stored in smart contracts called \u201cData Objects\u201d (DO), which answer to external data indexing mechanisms named \u201cData Points\u201d (DP). This data can be accessed and modified by implementing (one or many) separate smart contracts identified as \u201cData Managers\u201d (DM). We introduce two mechanisms for access management: first, through a \u201cData Index\u201d (DI) implementation, the \u201cData Managers\u201d (DM) can be gated from accessing \u201cData Objects\u201d (DO); second, a \u201cData Point Registry\u201d (DPR) implementation manages the issuance of \u201cData Points\u201d (DP). Lastly, we introduce the concept of data portability (horizontal data mobility) between implementations of \u201cData Index\u201d (DI), enabling massive updates to the logic without affecting the underlying data storage.", "Motivation": "As the Ethereum ecosystem grows, so does the demand for on-chain functionalities. The market encourages a desire for broader adoption through more complex systems and there is a constant need for improved efficiency. We have seen times when an explosion of new standard token proposals was solely driven by market hype. While ultimately each standard serves its purpose, most of them require more flexibility to manage interoperability with other standards. A standard adapter mechanism is needed to enhance interoperability by driving the interactions between assets issued under different ERCs.", "Specification": "Data Point: A uniquely identifiable reference to an on-chain data structure stored within one or manyData Objectsand managed by one or manyData Managers.Data Pointsare issued by aData Point Registry.", "Terms": "Data Point: A uniquely identifiable reference to an on-chain data structure stored within one or manyData Objectsand managed by one or manyData Managers.Data Pointsare issued by aData Point Registry.", "Data Point Structure": "Data Pointsare a low-level structure abstracting and indexing information.Data Pointsact as pointers to information stored within data structures inData Objects.Data Pointsare allocated by aData Point Registry. TheData PointSHOULD store whichData Point Registryinitialized it within its internal structure. EachData PointSHOULD have a unique identifier provided by theData Point Registrywhen instantiated.", "Data Object Interface": "Data Objectsare entrusted with the storage and management of data.Data ObjectsSHOULD implement the logic for managing the storage of on-chain data.Data Objectinternal data structure SHOULD useData Pointsfor indexing information.", "Data Manager Contract": "Data Managersare independent smart contracts that implement the business logic or \u201chigh-level\u201d data management. They canread()from aData Objectaddress andwrite()through aData Indeximplementation managing the delegated storage of theData Points.", "Data Point Registry Interface": "TheData Point Registryis a smart contract entrusted withData Pointaccess control.Data Managersmay request the allocation ofData Pointsto theData Point Registry.", "Data Index Interface": "TheData Indexis a smart contract entrusted with access control. It is a gating mechanism forData Managersto accessData Objects. If aData Managerintends to access aData Point(either byread(),write(), or any other method), theData IndexSHOULD be used for validating access to the data.", "Rationale": "The decision to encodeData Pointsasbytes32data pointers is primarily driven by flexibility and future-proofing. The usebytes32allows for a wide range of data encodings. This provides the developer with many options to accommodate diverse use cases. Furthermore, as Ethereum and its standards continue to evolve, encoding asbytes32ensures that the Standard Adapters built with the current ERC can reference future data types or structures without requiring significant changes to the adapter itself. TheData Pointencoding should have a prefix so that theData Objectcan efficiently identify compatibility issues when accessing the data storage. Additionally, the prefix should be used to find theData Point Registryand verify admin access to theData Point. The use of a suffix for identifying theData Point Registryis also required, for theData Objectto quickly discard badly formed transactions that aim to use aData Pointfrom an unmatchingData Point Registry.", "Backwards Compatibility": "This ERC is intended to augment the functionality of existing token standards without introducing breaking changes. As such, it does not present any backward compatibility issues. Already deployed tokens under other ERCs can be wrapped and indexed asData Pointsand managed byData Objects, and later exposed through any implementation ofData Managers. All interoperability integrations will require a compatibility analysis, depending on the use case. However, the interfaces defined in this ERC define a framework for adapting one standard to another through storage abstraction.", "Reference Implementation": "We present aneducational exampleimplementation of a Standard Adapter showcasing two types of tokens (Fungible and Semi-Fungible) with shared data storage. The end user can interact with this implementation through one of two types of interfaces: The semi-fungible one (represented through a singleData Manager), and the fungible interface (represented by manyData Managers). The abstraction of the storage from the logic is achieved through the use of a singleFungible FractionsData Object. A factory is used for deploying the Fungible token interfaces that share storage with each semi-fungible collection. Note that if atransfer()is called by either interface (Fungible or Semi-Fungible), both interfaces are emitting an event.", "Security Considerations": "The access control is separated into three layers:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7231, "url": "https://eips.ethereum.org/EIPS/eip-7231", "title": "Identity-aggregated NFT", "authors": ["Chloe Gu\u00a0<", "chloe@carv.io", ">", "Navid X.\u00a0(", "@xuxinlai2002", ")", "Victor Yu\u00a0<", "victor@carv.io", ">", "Archer H."], "sections": {"ERC-7231: Identity-aggregated NFT": "This standard extendsERC-721by binding individuals\u2019 Web2 and Web3 identities to non-fungible tokens (NFTs) and soulbound tokens (SBTs). By binding multiple identities, aggregated and composible identity infomation can be verified, resulting in more beneficial onchain scenarios for individuals, such as self-authentication, social overlapping, commercial value generation from user targetting, etc. By adding a custom schema in the metadata, and updating and verifying the schema hash in the contract, the binding of NFT and identity information is completed.", "The aggregation of web2 & web3 identities to NFTs, authorized by individuals, gives attributes of ownerships, relationships, experiences.": "This standard extendsERC-721by binding individuals\u2019 Web2 and Web3 identities to non-fungible tokens (NFTs) and soulbound tokens (SBTs). By binding multiple identities, aggregated and composible identity infomation can be verified, resulting in more beneficial onchain scenarios for individuals, such as self-authentication, social overlapping, commercial value generation from user targetting, etc. By adding a custom schema in the metadata, and updating and verifying the schema hash in the contract, the binding of NFT and identity information is completed.", "Abstract": "This standard extendsERC-721by binding individuals\u2019 Web2 and Web3 identities to non-fungible tokens (NFTs) and soulbound tokens (SBTs). By binding multiple identities, aggregated and composible identity infomation can be verified, resulting in more beneficial onchain scenarios for individuals, such as self-authentication, social overlapping, commercial value generation from user targetting, etc. By adding a custom schema in the metadata, and updating and verifying the schema hash in the contract, the binding of NFT and identity information is completed.", "Motivation": "One of the most interesting aspects of Web3 is the ability to bring an individual\u2019s own identity to different applications. Even more powerful is the fact that individuals truly own their accounts without relying on centralized gatekeepers, disclosing to different apps components necessary for authentication and approved by individuals. \nExisiting solutions such as ENS, although open, decentralized, and more convenient for Ethereum-based applications, suffer from a lack of data standardization and authentication of identity due to inherent anominity. Other solutions such as SBTs rely on centralized attestors, can not prevent data tampering, and do not inscribe data into the ledger itself in a privacy enabling way.The proposed pushes the boundaries of solving identity problems with Identity Aggregated NFT, i.e., the individual-authenticated aggregation of web2 and web3 identities to NFTs (SBTs included).", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Every compliant contract must implement the Interface": "This is the \u201cMetadata JSON Schema\u201d referenced above.", "Rationale": "Designing the proposal, we considered the following problems that are solved by this standard:", "Backwards Compatibility": "As mentioned in the specifications section, this standard can be fullyERC-721compatible by adding an extension function set.\nIn addition, new functions introduced in this standard have many similarities with the existing functions inERC-721. This allows developers to easily adopt the standard quickly.", "Test Cases": "Tests are included inerc7231.ts.", "Reference Implementation": "ERC7231.solImplementation:ERC7231.sol", "Security Considerations": "This EIP standard can comprehensively empower individuals to have ownership and control of their identities, wallets, and relevant data by themselves adding or removing the NFTs and identity bound information.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7401, "url": "https://eips.ethereum.org/EIPS/eip-7401", "title": "Parent-Governed Non-Fungible Tokens Nesting", "authors": ["Bruno \u0160kvorc\u00a0(", "@Swader", ")", "Cicada\u00a0(", "@CicadaNCR", ")", "Steven Pineda\u00a0(", "@steven2308", ")", "Stevan Bogosavljevic\u00a0(", "@stevyhacker", ")", "Jan Turk\u00a0(", "@ThunderDeliverer", ")"], "sections": {"ERC-7401: Parent-Governed Non-Fungible Tokens Nesting": "\u2757\ufe0fERC-7401supersedesERC-6059.\u2757\ufe0f", "An interface for Non-Fungible Tokens Nesting with emphasis on parent token's control over the relationship.": "\u2757\ufe0fERC-7401supersedesERC-6059.\u2757\ufe0f", "Abstract": "\u2757\ufe0fERC-7401supersedesERC-6059.\u2757\ufe0f", "Motivation": "With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having the ability for tokens to own other tokens allows for greater utility, usability and forward compatibility.", "Bundling": "One of the most frequent uses ofERC-721is to disseminate the multimedia content that is tied to the tokens. In the event that someone wants to offer a bundle of NFTs from various collections, there is currently no easy way of bundling all of these together and handle their sale as a single transaction. This proposal introduces a standardized way of doing so. Nesting all of the tokens into a simple bundle and selling that bundle would transfer the control of all of the tokens to the buyer in a single transaction.", "Collecting": "A lot of NFT consumers collect them based on countless criteria. Some aim for utility of the tokens, some for the uniqueness, some for the visual appeal, etc. There is no standardized way to group the NFTs tied to a specific account. By nesting NFTs based on their owner\u2019s preference, this proposal introduces the ability to do it. The root parent token could represent a certain group of tokens and all of the children nested into it would belong to it.", "Membership": "A common utility attached to NFTs is a membership to a Decentralised Autonomous Organization (DAO) or to some other closed-access group. Some of these organizations and groups occasionally mint NFTs to the current holders of the membership NFTs. With the ability to nest mint a token into a token, such minting could be simplified, by simply minting the bonus NFT directly into the membership one.", "Delegation": "One of the core features of DAOs is voting and there are various approaches to it. One such mechanic is using fungible voting tokens where members can delegate their votes by sending these tokens to another member. Using this proposal, delegated voting could be handled by nesting your voting NFT into the one you are delegating your votes to and transferring it when the member no longer wishes to delegate their votes.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "Designing the proposal, we considered the following questions:", "Propose-Commit pattern for child token management": "Adding child tokens to a parent token MUST be done in the form of propose-commit pattern to allow for limited mutability by a 3rd party. When adding a child token to a parent token, it is first placed in a\u201cPending\u201darray, and MUST be migrated to the\u201cActive\u201darray by the parent token\u2019s root owner. The\u201cPending\u201dchild tokens array SHOULD be limited to 128 slots to prevent spam and griefing.", "Parent Governed pattern": "The parent NFT of a nested token and the parent\u2019s root owner are in all aspects the true owners of it. Once you send a token to another one you give up ownership.", "Child token management": "This proposal introduces a number of child token management functions. In addition to the permissioned migration from\u201cPending\u201dto\u201cActive\u201dchild tokens array, the main token management function from this proposal is thetransferChildfunction. The following state transitions of a child token are available with it:", "Backwards Compatibility": "The Nestable token standard has been made compatible withERC-721in order to take advantage of the robust tooling available for implementations of ERC-721 and to ensure compatibility with existing ERC-721 infrastructure.", "Test Cases": "Tests are included innestable.ts.", "Reference Implementation": "SeeNestableToken.sol.", "Security Considerations": "The same security considerations as withERC-721apply: hidden logic may be present in any of the functions, including burn, add child, accept child, and more.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7409, "url": "https://eips.ethereum.org/EIPS/eip-7409", "title": "Public Non-Fungible Tokens Emote Repository", "authors": ["Bruno \u0160kvorc\u00a0(", "@Swader", ")", "Steven Pineda\u00a0(", "@steven2308", ")", "Stevan Bogosavljevic\u00a0(", "@stevyhacker", ")", "Jan Turk\u00a0(", "@ThunderDeliverer", ")"], "sections": {"ERC-7409: Public Non-Fungible Tokens Emote Repository": "\u2757\ufe0fERC-7409supersedesERC-6381.\u2757\ufe0f", "React to any Non-Fungible Tokens using Unicode emojis.": "\u2757\ufe0fERC-7409supersedesERC-6381.\u2757\ufe0f", "Abstract": "\u2757\ufe0fERC-7409supersedesERC-6381.\u2757\ufe0f", "Motivation": "With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having the ability for anyone to interact with an NFT introduces an interactive aspect to owning an NFT and unlocks feedback-based NFT mechanics.", "Interactivity": "The ability to emote on an NFT introduces the aspect of interactivity to owning an NFT. This can either reflect the admiration for the emoter (person emoting to an NFT) or can be a result of a certain action performed by the token\u2019s owner. Accumulating emotes on a token can increase its uniqueness and/or value.", "Feedback based evolution": "Standardized on-chain reactions to NFTs allow for feedback based evolution.", "Valuation": "Current NFT market heavily relies on previous values the token has been sold for, the lowest price of the listed token and the scarcity data provided by the marketplace. There is no real time indication of admiration or desirability of a specific token. Having the ability for users to emote to the tokens adds the possibility of potential buyers and sellers gauging the value of the token based on the impressions the token has collected.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Message format for presigned emotes": "The message to be signed by theemoterin order for the reaction to be submitted by someone else is formatted as follows:", "Pre-determined address of the Emotable repository": "The address of the Emotable repository smart contract is designed to resemble the function it serves. It starts with0x3110735which is the abstract representation ofEMOTES. The address is:", "Rationale": "Designing the proposal, we considered the following questions:", "Backwards Compatibility": "The Emote repository standard is fully compatible withERC-721and with the robust tooling available for implementations of ERC-721 as well as with the existing ERC-721 infrastructure.", "Test Cases": "Tests are included inemotableRepository.ts.", "Reference Implementation": "SeeEmotableRepository.sol.", "Security Considerations": "The proposal does not envision handling any form of assets from the user, so the assets should not be at risk when interacting with an Emote repository.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7432, "url": "https://eips.ethereum.org/EIPS/eip-7432", "title": "Non-Fungible Token Roles", "authors": ["Ernani S\u00e3o Thiago\u00a0(", "@ernanirst", ")", "Daniel Lima\u00a0(", "@karacurt", ")"], "sections": {"ERC-7432: Non-Fungible Token Roles": "This standard introduces role management for NFTs. Each role assignment is associated with a single NFT and expires\nautomatically at a given timestamp. Roles are defined asbytes32and feature a customdatafield of arbitrary size\nto allow customization.", "Role Management for NFTs. Enables accounts to share the utility of NFTs via expirable role assignments.": "This standard introduces role management for NFTs. Each role assignment is associated with a single NFT and expires\nautomatically at a given timestamp. Roles are defined asbytes32and feature a customdatafield of arbitrary size\nto allow customization.", "Abstract": "This standard introduces role management for NFTs. Each role assignment is associated with a single NFT and expires\nautomatically at a given timestamp. Roles are defined asbytes32and feature a customdatafield of arbitrary size\nto allow customization.", "Motivation": "The NFT Roles interface aims to establish a standard for role management in NFTs. Tracking on-chain roles enables\ndecentralized applications (dApps) to implement access control for privileged actions, e.g., minting tokens with a role\n(airdrop claim rights).", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d,\n\u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC-2119 and RFC-8174.", "Metadata Extension": "The Roles Metadata extension extends the traditional JSON-based metadata schema of NFTs. Therefore, DApps supporting\nthis feature MUST also implement the metadata extension ofERC-721. This extension isoptionaland allows\ndevelopers to provide additional information for roles.", "Caveats": "ERC-7432IS NOT an extension ofERC-721. The main reason behind this decision is to\nenable it to be implemented externally or on the same contract as the NFT, allowing dApps to implement roles with\nimmutable assets. This standard covers many crucial features, such as automatic expiration and custom data, but perhaps\nthe most important one is its flexibility in implementation. ERC-7432 can be implemented in many ways, and for this\nreason, the neutral term \u201clock\u201d is employed. This term can refer to an NFT being frozen (preventing transfers until\nroles expire) or deposited in an escrow contract. Developers should decide which implementation to use based on their\nuse cases.", "Rationale": "ERC-7432IS NOT an extension ofERC-721. The main reason behind this decision is to\nenable it to be implemented externally or on the same contract as the NFT, allowing dApps to implement roles with\nimmutable assets. This standard covers many crucial features, such as automatic expiration and custom data, but perhaps\nthe most important one is its flexibility in implementation. ERC-7432 can be implemented in many ways, and for this\nreason, the neutral term \u201clock\u201d is employed. This term can refer to an NFT being frozen (preventing transfers until\nroles expire) or deposited in an escrow contract. Developers should decide which implementation to use based on their\nuse cases.", "Automatic Expiration": "Automatic expiration is implemented via thegrantRoleandroleExpirationDatefunctions.grantRoleis responsible\nfor setting the expiration date, androleExpirationDateallow developers to check whether the role is expired. Sinceuint256is not natively supported by most programming languages, dates are represented asuint64on this standard.\nThe maximum UNIX timestamp represented by auint64is about the year584,942,417,355, which should be enough to be\nconsidered \u201cpermanent\u201d. For this reason, it\u2019s recommended usingtype(uint64).maxto support use cases that require a\nrole never to expire.", "Revocable Roles": "In certain scenarios, the original owner of the NFT may need to revoke a role before its expiration date, while in\nothers, the recipient may require assurance that the role cannot be revoked. Therevocableparameter was introduced\nto thegrantRolefunction to specify whether a role can be revoked prematurely, enabling the standard to\nsupport both use cases.", "Custom Data": "DApps can customize roles using thedataparameter of thegrantRolefunction.datais implemented using the\ngeneric typebytesto enable dApps to encode any role-specific information when granting a role. The custom\ndata is retrievable using theroleDatafunction and is emitted with theRoleGrantedevent. With this approach, \ndevelopers can integrate this information into their applications, both on-chain and off-chain.", "Role Approval": "Similar toERC-721, this standard enable other accounts to manage roles on behalf of the NFT owner. This\nfunctionality was introduced to allow third-parties to interact with ERC-7432 without requiring NFT ownership. Compliant\ncontracts MUST implement the functionssetRoleApprovalForAllandisRoleApprovedForAllto deliver this feature.", "Backwards Compatibility": "On all functions and events, the standard requires both thetokenAddressandtokenIdto be provided. This \nrequirement enables dApps to use a standaloneERC-7432contract as the authoritative source for the\nroles of immutable NFTs.", "Reference Implementation": "SeeERC-7432.sol.", "Security Considerations": "Developers integrating the Non-Fungible Token Roles interface should consider the following on their implementations:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7439, "url": "https://eips.ethereum.org/EIPS/eip-7439", "title": "Prevent ticket touting", "authors": ["LeadBest Consulting Group\u00a0<", "service@getoken.io", ">", "Sandy Sung\u00a0(", "@sandy-sung-lb", ")", "Mars Peng\u00a0<", "mars.peng@getoken.io", ">", "Taien Wang\u00a0<", "taien.wang@getoken.io", ">"], "sections": {"ERC-7439: Prevent ticket touting": "This standard is an extension ofERC-721and defines standard functions outlining a scope for ticketing agents or event organizers to take preventative actions to stop audiences being exploited in the ticket scalping market and allow customers to resell their tickets via authorized ticket resellers.", "An interface for customers to resell their tickets via authorized ticket resellers.": "This standard is an extension ofERC-721and defines standard functions outlining a scope for ticketing agents or event organizers to take preventative actions to stop audiences being exploited in the ticket scalping market and allow customers to resell their tickets via authorized ticket resellers.", "Abstract": "This standard is an extension ofERC-721and defines standard functions outlining a scope for ticketing agents or event organizers to take preventative actions to stop audiences being exploited in the ticket scalping market and allow customers to resell their tickets via authorized ticket resellers.", "Motivation": "Industrial-scale ticket touting has been a longstanding issue, with its associated fraud and criminal problems leading to unfortunate incidents and waste of social resources. It is also hugely damaging to artists at all levels of their careers and to related businesses across the board. Although the governments of various countries have begun to legislate to restrict the behavior of scalpers, the effect is limited. They still sold tickets for events at which resale was banned or did not yet own then obtained substantial illegal profits from speculative selling. We consulted many opinions to provide a consumer-friendly resale interface, enabling buyers to resell or reallocate a ticket at the price they initially paid or less is the efficient way to rip off \u201csecondary ticketing\u201d.that enables ticketing agents to utilize", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Interface": "The interface and structure referenced here are as follows:", "Rationale": "Designing the proposal, we considered the following questions:", "Backwards Compatibility": "This standard is compatible withERC-721.", "Test Cases": "There are no security considerations related directly to the implementation of this standard.", "Reference Implementation": "There are no security considerations related directly to the implementation of this standard.", "Security Considerations": "There are no security considerations related directly to the implementation of this standard.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7528, "url": "https://eips.ethereum.org/EIPS/eip-7528", "title": "ETH (Native Asset) Address Convention", "authors": ["Joey Santoro\u00a0(", "@joeysantoro", ")"], "sections": {"ERC-7528: ETH (Native Asset) Address Convention": "The following standard proposes a convention for using the address0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeein all contexts where an address is used to represent ETH in the same capacity as anERC-20token. This would apply to both events where an address field would denote ETH or anERC-20token, as well as discriminators such as theassetfield of anERC-4626vault.", "An address placeholder for ETH when used in the same context as an ERC-20 token.": "The following standard proposes a convention for using the address0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeein all contexts where an address is used to represent ETH in the same capacity as anERC-20token. This would apply to both events where an address field would denote ETH or anERC-20token, as well as discriminators such as theassetfield of anERC-4626vault.", "Abstract": "The following standard proposes a convention for using the address0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeein all contexts where an address is used to represent ETH in the same capacity as anERC-20token. This would apply to both events where an address field would denote ETH or anERC-20token, as well as discriminators such as theassetfield of anERC-4626vault.", "Motivation": "ETH, being a fungible unit of value, often behaves similarly toERC-20tokens. Protocols tend to implement a standard interface for ERC-20 tokens, and benefit from having the ETH implementation to closely mirror theERC-20implementations.", "Specification": "This standard applies for all components of smart contract systems in which an address is used to identify anERC-20token, and where native ETH is used in certain instances in place of anERC-20token. The usage of the term Token below means ETH or anERC-20in this context.", "Rationale": "Many existing implementations of the same use case as this standard use addresses such as 0x0, 0x1, and 0xe for gas efficiency of having leading zero bytes.", "Considered alternative addresses": "Many existing implementations of the same use case as this standard use addresses such as 0x0, 0x1, and 0xe for gas efficiency of having leading zero bytes.", "Backwards Compatibility": "This standard has no known compatibility issues with other standards.", "Security Considerations": "Using ETH as a Token instead of WETH exposes smart contract systems to re-entrancy and similar classes of vulnerabilities. Implementers must take care to follow the industry standard development patterns (e.g.  checks-effects-interactions) when the Token is ETH.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7535, "url": "https://eips.ethereum.org/EIPS/eip-7535", "title": "Native Asset ERC-4626 Tokenized Vault", "authors": ["Joey Santoro\u00a0(", "@joeysantoro", ")"], "sections": {"ERC-7535: Native Asset ERC-4626 Tokenized Vault": "This standard is an extension of theERC-4626spec with an identical interface and behavioral overrides for handling Ether or any native asset as the underlying.", "ERC-4626 Tokenized Vaults with Ether (Native Asset) as the underlying asset": "This standard is an extension of theERC-4626spec with an identical interface and behavioral overrides for handling Ether or any native asset as the underlying.", "Abstract": "This standard is an extension of theERC-4626spec with an identical interface and behavioral overrides for handling Ether or any native asset as the underlying.", "Motivation": "A standard for tokenized ETH Vaults has the same benefits asERC-4626, particularly in the case of Liquid Staking Tokens, (i.e. fungibleERC-20wrappers around ETH staking).", "Specification": "AllERC-7535tokenized Vaults MUST implement ERC-4626 (and by extension ERC-20) with behavioral overrides for the methodsasset,deposit, andmintspecified below.", "ERC-4626 Breaking Changes": "MUST return0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeEperERC-7528.", "Methods": "MUST return0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeEperERC-7528.", "Events": "The event usage MUST be identical to ERC-4626.", "Wrapped ETH": "Smart contract systems which implement ERC-4626 should consider only supporting ERC-20 underlying assets, and default to using a Wrapped ETH ERC-20 instead of implementing ERC-7535 for handling ETH.", "Rationale": "This standard was designed to maximize compatibility with ERC-4626 while minimizing additional opinionated details on the interface. Examples of this decision rationale are described below:", "Allowing assets Parameter to be Ignored in a Deposit": "msg.valuemust always be passed anyway to fund adeposit, therefore it may as well be treated as the primary input number. Allowingassetsto be used either forces a strict equality and extra unnecessary gas overhead for redundancy, or allows different values which could cause footguns and undefined behavior.", "Allowing msg.value to Not Equal assets Output in a Mint": "There may be many cases where a user deposits slightly too much Ether in amintcall. In these cases, enforcingmsg.valueto equalassetswould cause unnecessary reversions. It is up to the vault implementer to decide whether to refund or absorb any excess Ether, and up to depositors to deposit as close to the exact amount as possible.", "Backwards Compatibility": "ERC-7535 is fully backward compatible with ERC-4626 at the function interface level. Certain implementation behaviors are different due to the fact that ETH is not ERC-20 compliant, such as the priority ofmsg.valueoverassets.", "Security Considerations": "In addition to all security considerations ofERC-4626, there are security implications of having ETH as the Vault asset.", "callvssend": "Contracts should take care when usingcallto transfer ETH, as this allows additional reentrancy vulnerabilities and arbitrary code execution beyond what is possible with trusted ERC-20 tokens.", "Forceful ETH transfers": "ETH can be forced into any Vault through theSELFDESTRUCTopcode. Implementers should validate that this does not disrupt Vault accounting in any way.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7540, "url": "https://eips.ethereum.org/EIPS/eip-7540", "title": "Asynchronous ERC-4626 Tokenized Vaults", "authors": ["Jeroen Offerijns\u00a0(", "@hieronx", ")", "Alina Sinelnikova\u00a0(", "@ilinzweilin", ")", "Vikram Arun\u00a0(", "@vikramarun", ")", "Joey Santoro\u00a0(", "@joeysantoro", ")", "Farhaan Ali\u00a0(", "@0xfarhaan", ")", "Jo\u00e3o Martins\u00a0(", "@0xTimepunk", ")"], "sections": {"ERC-7540: Asynchronous ERC-4626 Tokenized Vaults": "The following standard extendsERC-4626by adding support for asynchronous deposit and redemption flows. The async flows are called Requests.", "Extension of ERC-4626 with asynchronous deposit and redemption support": "The following standard extendsERC-4626by adding support for asynchronous deposit and redemption flows. The async flows are called Requests.", "Abstract": "The following standard extendsERC-4626by adding support for asynchronous deposit and redemption flows. The async flows are called Requests.", "Motivation": "The ERC-4626 Tokenized Vaults standard has helped to make yield-bearing tokens more composable across decentralized finance. The standard is optimized for atomic deposits and redemptions up to a limit. If the limit is reached, no new deposits or redemptions can be submitted.", "Specification": "The existing definitions fromERC-4626apply. In addition, this spec defines:", "Definitions:": "The existing definitions fromERC-4626apply. In addition, this spec defines:", "Request Flows": "ERC-7540 VaultsMUST implement one or both of asynchronous deposit and redemption Request flows. If either flow is not implemented in a Request pattern, it MUST use the ERC-4626 standard synchronous interaction pattern.", "Request Lifecycle": "After submission, Requests go through Pending, Claimable, and Claimed stages. An example lifecycle for a deposit Request is visualized in the table below.", "Request Ids": "The request ID (requestId) of a request is returned by the correspondingrequestDepositandrequestRedeemfunctions.", "Methods": "Transfersassetsfromownerinto the Vault and submits a Request for asynchronousdeposit. This places the Request in Pending state, with a corresponding increase inpendingDepositRequestfor the amountassets.", "Events": "ownerhas lockedassetsin the Vault to Request a deposit with request IDrequestId.controllercontrols this Request.senderis the caller of therequestDepositwhich may not be equal to theowner.", "ERC-165support": "Smart contracts implementing this Vault standard MUST implement theERC-165supportsInterfacefunction.", "ERC-7575support": "Smart contracts implementing this Vault standard MUST implement theERC-7575standard (in particular thesharemethod).", "Rationale": "Requests in an Asynchronous Vault have properties of NFTs or Semi-Fungible tokens due to their asynchronicity. However, trying to pigeonhole all ERC-7540 Vaults into supportingERC-721orERC-1155for Requests would create too much interface bloat.", "Including Request IDs but not including a Claim by ID method": "Requests in an Asynchronous Vault have properties of NFTs or Semi-Fungible tokens due to their asynchronicity. However, trying to pigeonhole all ERC-7540 Vaults into supportingERC-721orERC-1155for Requests would create too much interface bloat.", "Symmetry and Non-inclusion of requestWithdraw and requestMint": "In ERC-4626, the spec was written to be fully symmetrical with respect to convertingassetsandsharesby including deposit/withdraw and mint/redeem.", "Optionality of Flows": "Certain use cases are only asynchronous on one side of the deposit or redeem Request flow. A good example of an asynchronous redemption Vault is a liquid staking token. The unstaking period necessitates support for asynchronous withdrawals, however, deposits can be fully synchronous.", "Non-inclusion of a Request Cancelation Flow": "In many cases, canceling a Request may not be straightforward or even technically feasible. The state transition of cancelations could be synchronous or asynchronous, and the way to claim a cancelation interfaces with the remaining Vault functionality in complex ways.", "Request Implementation Flexibility": "The standard is flexible enough to support a wide range of interaction patterns for Request flows. Pending Requests can be handled via internal accounting, globally or on per-user levels, use ERC-20 orERC-721, etc.", "Not Allowing Short-circuiting for Claims": "If claims can short-circuit, this creates ambiguity for integrators and complicates the interface with overloaded behavior on Request functions.", "No Outputs for Request Functions": "requestDepositandrequestRedeemmay not have a known exchange rate that will happen when the Request becomes Claimed. Returning the correspondingassetsorsharescould not work in this case.", "No Event for Claimable State": "The state transition of a Request from Pending to Claimable happens at the Vault implementation level and is not specified in the standard. Requests may be batched into the Claimable state, or the state may transition automatically after a timestamp has passed. It is impractical to require an event to emit after a Request becomes Claimable at the user or batch level.", "Reversion of Preview Functions in Async Request Flows": "The preview functions do not take an address parameter, therefore the only way to discriminate discrepancies in the exchange rate is via themsg.sender. However, this could lead to integration/implementation complexities where support contracts cannot determine the output of a claim on behalf of acontroller.", "Mandated Support forERC-165": "Implementing support forERC-165is mandated because of theoptionality of flows. Integrations can use thesupportsInterfacemethod to check whether a vault is fully asynchronous, partially asynchronous, or fully synchronous (for which it is just following theERC-4626), and use a single contract to support all cases.", "Not Allowing Pending Claims to be Fungible": "The async pending claims represent a sort of semi-fungible intermediate share class. Vaults can elect to wrap these claims in any token standard they like, for example, ERC-20,ERC-1155, or ERC-721 depending on the use case. This is intentionally left out of the spec to provide flexibility to implementers.", "Backwards Compatibility": "The interface is fully backward compatible withERC-4626. The specification of thedeposit,mint,redeem, andwithdrawmethods is different as described inSpecification.", "Reference Implementation": "In general, asynchronicity concerns make state transitions in the Vault much more complex and vulnerable to security risks. Access control on Vault operations, clear documentation of state transitions, and invariant checks should all be performed to mitigate these risks. For example:", "Security Considerations": "In general, asynchronicity concerns make state transitions in the Vault much more complex and vulnerable to security risks. Access control on Vault operations, clear documentation of state transitions, and invariant checks should all be performed to mitigate these risks. For example:", "Operators": "An operator has the ability to transfer theassetof the vault from the approver to any address, and simultaneously grants control over theshareof the vault.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- withdrawal: Log entry in system_logs for tracking withdrawals under EIP-4895 .\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7575, "url": "https://eips.ethereum.org/EIPS/eip-7575", "title": "Multi-Asset ERC-4626 Vaults", "authors": ["Jeroen Offerijns\u00a0(", "@hieronx", ")", "Alina Sinelnikova\u00a0(", "@ilinzweilin", ")", "Vikram Arun\u00a0(", "@vikramarun", ")", "Joey Santoro\u00a0(", "@joeysantoro", ")", "Farhaan Ali\u00a0(", "@0xfarhaan", ")"], "sections": {"ERC-7575: Multi-Asset ERC-4626 Vaults": "The following standard adaptsERC-4626to support multiple assets or entry points for the same share token. This also enables Vaults which don\u2019t have a true share token but rather convert between two arbitrary external tokens.", "Extended ERC-4626 Interface enabling Multi-Asset Vaults": "The following standard adaptsERC-4626to support multiple assets or entry points for the same share token. This also enables Vaults which don\u2019t have a true share token but rather convert between two arbitrary external tokens.", "Abstract": "The following standard adaptsERC-4626to support multiple assets or entry points for the same share token. This also enables Vaults which don\u2019t have a true share token but rather convert between two arbitrary external tokens.", "Motivation": "One missing use case that is not supported byERC-4626is Vaults which have multiple assets or entry points such as liquidity provider (LP) Tokens. These are generally unwieldy or non-compliant due to the requirement of ERC-4626 to itself be anERC-20.", "Specification": "The existing definitions fromERC-4626apply. In addition, this spec defines:", "Definitions:": "The existing definitions fromERC-4626apply. In addition, this spec defines:", "Methods": "AllERC-7575Vaults MUST implementERC-4626excluding theERC-20methods and events.", "Multi-Asset Vaults": "Multi-Asset Vaults share a singlesharetoken with multiple entry points denominated in differentassettokens.", "Pipes": "Pipes convert between a singleassetandsharewhich are bothERC-20tokens outside the Vault.", "Share-to-Vault lookup": "TheERC-20implementation ofshareSHOULD implement avaultmethod, that returns the address of the Vault for a specificasset.", "ERC-165support": "Vaults implementingERC-7575MUST implement theERC-165supportsInterfacefunction. The Vault contract MUST return the constant valuetrueif0x2f0a18c5is passed through theinterfaceIDargument.", "Events": "The Vault linked to the share has been updated.", "Rationale": "This standard is intentionally flexible to support both existingERC-4626Vaults easily by the introduction of a single new method, but also flexible to support new use cases by allowing separate share tokens.", "Ability to externalizeERC-20Dependency": "By allowingshare != address(this), the Vault can have an external contract managing theERC-20functionality of the Share. In the case of Multi-Asset, this avoids the confusion that might arise if each Vault itself were required to be anERC-20, which could confuse integrators and front-ends.", "Including Share-to-Vault lookup optionally": "Thevaultmethod is included to look up a Vault for ashareby itsasset, combined with theVaultUpdateevent andERC-165support. This enables integrations to easily query Multi-Asset Vaults.", "Backwards Compatibility": "ERC-7575Vaults are not fully compatible withERC-4626because theERC-20functionality has been removed.", "Reference Implementation": "ERC-20non-compliant Vaults must take care with supporting a redeem flow whereowneris notmsg.sender, since theERC-20approval flow does not by itself work if the Vault and share are separate contracts. It can work by setting up the Vault as a Trusted Forwarder of the share token, usingERC-2771.", "Security Considerations": "ERC-20non-compliant Vaults must take care with supporting a redeem flow whereowneris notmsg.sender, since theERC-20approval flow does not by itself work if the Vault and share are separate contracts. It can work by setting up the Vault as a Trusted Forwarder of the share token, usingERC-2771.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7578, "url": "https://eips.ethereum.org/EIPS/eip-7578", "title": "Physical Asset Redemption", "authors": ["Lee Vidor\u00a0(", "@V1d0r", ")", "David Tan\u00a0<", "david@emergentx.org", ">", "Lee Smith\u00a0<", "lee@emergentx.org", ">", "Gabriel Stoica\u00a0(", "@gabrielstoica", ")"], "sections": {"ERC-7578: Physical Asset Redemption": "This proposal is an extension ofERC-721and implements additional functionality and information pertaining to the NFT\u2019s underlying physical asset by capturing information that enables the holder of physical asset backed NFTs to verify authenticity and facilitate redemption of the underlying physical assets. This proposal is primarily aimed at providing transparency by disclosing details of involved parties and provides opportunity to define and make readily available relevant legal relationship between NFT holder and the owner/holder of the respective underlying physical asset. This proposal makes the token issuer accountable to embed accurate information on a set of standardized information about the underlying physical asset and the involved key parties.", "Provides the holder of physical asset backed NFTs readily available real-world information on the underlying physical asset.": "This proposal is an extension ofERC-721and implements additional functionality and information pertaining to the NFT\u2019s underlying physical asset by capturing information that enables the holder of physical asset backed NFTs to verify authenticity and facilitate redemption of the underlying physical assets. This proposal is primarily aimed at providing transparency by disclosing details of involved parties and provides opportunity to define and make readily available relevant legal relationship between NFT holder and the owner/holder of the respective underlying physical asset. This proposal makes the token issuer accountable to embed accurate information on a set of standardized information about the underlying physical asset and the involved key parties.", "Abstract": "This proposal is an extension ofERC-721and implements additional functionality and information pertaining to the NFT\u2019s underlying physical asset by capturing information that enables the holder of physical asset backed NFTs to verify authenticity and facilitate redemption of the underlying physical assets. This proposal is primarily aimed at providing transparency by disclosing details of involved parties and provides opportunity to define and make readily available relevant legal relationship between NFT holder and the owner/holder of the respective underlying physical asset. This proposal makes the token issuer accountable to embed accurate information on a set of standardized information about the underlying physical asset and the involved key parties.", "Motivation": "The first wave of NFT use cases encompass predominately the representation of ownership of digital assets. In view of the anticipated trend to tokenize any real-world asset, it is to be expected that the use cases of NFTs will rapidly grow and expand around physical assets. The absence of an embedded standardized set of information pertaining to the underlying physical asset together with lack of transparency of involved key parties, creates an unnecessary hurdle for NFT holders and potential users which might, as a result, hinder mass adoption of NFTs that are used as ownership representation of a specific physical asset.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Contract Interface": "Whenpropertiesare set, thePropertiesSet(uint256 indexed tokenId, Properties properties)event is emitted.", "Rationale": "By not initializing a token\u2019s properties before minting, one risks that the asset\u2019s provenance represented by the token cannot be established.", "Backwards Compatibility": "This standard is compatible with ERC-721.", "Reference Implementation": "An example of anERC-721that includes this proposal using the OpenZeppelin ERC-721 v5 library:", "Security Considerations": "To ensure authenticity, token properties must be set only via a method that is restricted to a trusted Externally Owned Account (EOA) or contract. This trusted entity must verify that the properties accurately reflect the real physical attributes of the represented asset. Additionally, proper access control mechanisms should be implemented to prevent unauthorized modifications of token properties after they are set.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7588, "url": "https://eips.ethereum.org/EIPS/eip-7588", "title": "Blob Transactions Metadata JSON Schema", "authors": ["Gavin Fu\u00a0(", "@gavfu", ")", "Leo Wang\u00a0(", "@wanglie1986", ")", "Bova Chen\u00a0(", "@appoipp", ")", "Aiden X\u00a0(", "@4ever9", ")"], "sections": {"ERC-7588: Blob Transactions Metadata JSON Schema": "This EIP introduces a standard for attaching metadata to blobs carried by blob transactions, as outlined inEIP-4844. The metadata is represented as a JSON object adhering to a predefined schema, and its string representation is placed in the data field of the blob transaction.", "Attaching metadata to blobs carried by blob transactions": "This EIP introduces a standard for attaching metadata to blobs carried by blob transactions, as outlined inEIP-4844. The metadata is represented as a JSON object adhering to a predefined schema, and its string representation is placed in the data field of the blob transaction.", "Abstract": "This EIP introduces a standard for attaching metadata to blobs carried by blob transactions, as outlined inEIP-4844. The metadata is represented as a JSON object adhering to a predefined schema, and its string representation is placed in the data field of the blob transaction.", "Motivation": "EIP-4844defines a new type of transaction known as a \u201cblob transaction.\u201d These transactions contain a list of blobs along with their KZG commitments and proofs. Blob transactions serve as a mechanism for rollups to post their layer 2 transaction data to Ethereum layer 1.", "Specification": "The metadata is represented as a JSON object adhering to the following JSON Schema:", "Metadata JSON Schema": "The metadata is represented as a JSON object adhering to the following JSON Schema:", "Blob Transaction Envelope": "The blob transaction\u2019s calldata (i.e., the data field) should be set to the string representation of the metadata JSON object, encoded in UTF-8.", "Rationale": "In the Ethereum ecosystem, various types of transactions exist, each serving different purposes. The usage of the data field within these transactions varies:", "Backwards Compatibility": "This EIP is backward compatible withEIP-4844, as it does not modify the structure or functionality of blob transactions, but only adds an optional metadata field to them.", "Security Considerations": "This EIP does not introduce any new security risks or vulnerabilities, as the metadata is only an informational field that does not affect the execution or validity of blob transactions. However, users and applications should be aware of the following potential issues:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7734, "url": "https://eips.ethereum.org/EIPS/eip-7734", "title": "Decentralized Identity Verification (DID)", "authors": ["Anushka Yadav (@64anushka)\u00a0<", "64anushka@gmail.com", ">"], "sections": {"ERC-7734: Decentralized Identity Verification (DID)": "This proposal introduces a standard for decentralized identity verification (DID) on the blockchain. The standard leverages cryptographic hashes to represent identity proofs and events for transparency and traceability. By emphasizing simplicity, privacy, and user control, this proposal aims to reduce overhead for developers and users, ensuring seamless integration into decentralized applications (dApps). It offers a minimalistic solution that keeps identity structure simple and enables off-chain mechanisms for detailed identity management and verification.", "A privacy-preserving method for decentralized identity verification, enabling secure integration of identity management in dApps.": "This proposal introduces a standard for decentralized identity verification (DID) on the blockchain. The standard leverages cryptographic hashes to represent identity proofs and events for transparency and traceability. By emphasizing simplicity, privacy, and user control, this proposal aims to reduce overhead for developers and users, ensuring seamless integration into decentralized applications (dApps). It offers a minimalistic solution that keeps identity structure simple and enables off-chain mechanisms for detailed identity management and verification.", "Abstract": "This proposal introduces a standard for decentralized identity verification (DID) on the blockchain. The standard leverages cryptographic hashes to represent identity proofs and events for transparency and traceability. By emphasizing simplicity, privacy, and user control, this proposal aims to reduce overhead for developers and users, ensuring seamless integration into decentralized applications (dApps). It offers a minimalistic solution that keeps identity structure simple and enables off-chain mechanisms for detailed identity management and verification.", "Motivation": "Centralized identity verification methods are cumbersome, prone to data breaches, and fail to provide users control over their identity data. Existing DID solutions often introduce complexity, making adoption challenging for developers and users. This proposal seeks to address these issues by:", "Stakeholders": "The following stakeholders will benefit from this proposal:", "Differentiation": "This proposal stands out from other DID standards by focusing on minimalism, user control, and privacy. Unlike other solutions that encompass a wide range of identity attributes and interactions, this standard keeps the structure simple and relies on off-chain mechanisms for detailed identity management. Its simplicity fosters easier adoption, making it ideal for dApps that prioritize user-centric, secure ecosystems.", "Specification": "The Decentralized Identity Verification (DID) standard introduces a simple, secure, and privacy-preserving mechanism for verifying user identities on the  blockchain. The key components of this standard are outlined below:", "Interface": "The design leverages cryptographic hashes to represent identity information, ensuring that sensitive data is not stored directly on the blockchain. The use ofverificationHashesallows for flexible identity verification mechanisms. These hashes could be derived from various off-chain proofs, such as cryptographic challenges or attestations, depending on the implementer\u2019s needs. By leaving the interpretation of the verification hashes open, the standard enables adaptability while maintaining privacy and security. Additionally, the inclusion of events ensures transparency and traceability.", "Rationale": "The design leverages cryptographic hashes to represent identity information, ensuring that sensitive data is not stored directly on the blockchain. The use ofverificationHashesallows for flexible identity verification mechanisms. These hashes could be derived from various off-chain proofs, such as cryptographic challenges or attestations, depending on the implementer\u2019s needs. By leaving the interpretation of the verification hashes open, the standard enables adaptability while maintaining privacy and security. Additionally, the inclusion of events ensures transparency and traceability.", "Reference Implementation": "Secure Hashing: Ensure that identity and verification hashes are generated using a secure hashing algorithm to prevent collisions and ensure the integrity of the identity data.Replay Attacks: Verification hashes should incorporate nonces or timestamps to prevent replay attacks.Implementation Flexibility: Developers must ensure that hash generation and validation processes are robust and resistant to manipulation.", "Security Considerations": "Secure Hashing: Ensure that identity and verification hashes are generated using a secure hashing algorithm to prevent collisions and ensure the integrity of the identity data.Replay Attacks: Verification hashes should incorporate nonces or timestamps to prevent replay attacks.Implementation Flexibility: Developers must ensure that hash generation and validation processes are robust and resistant to manipulation.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7751, "url": "https://eips.ethereum.org/EIPS/eip-7751", "title": "Wrapping of bubbled up reverts", "authors": ["Daniel Gretzke\u00a0(", "@gretzke", ")", "Sara Reynolds\u00a0(", "@snreynolds", ")", "Alice Henshaw\u00a0(", "@hensha256", ")", "Marko Veniger\u00a0<", "marko.veniger@tenderly.co", ">", "Hadrien Croubois\u00a0(", "@Amxx", ")"], "sections": {"ERC-7751: Wrapping of bubbled up reverts": "This ERC proposes a standard for handling bubbled up reverts in Ethereum smart contracts using a dedicated custom error. This standard aims to improve the clarity and usability of revert reasons by allowing additional context to be passed alongside the raw bytes of the bubbled up revert. TheWrappedErrorcustom error should wrap reverts from called contracts and provide a consistent interface for parsing and handling reverts in tools like Etherscan or Tenderly.", "Handling bubbled up reverts using custom errors with additional context": "This ERC proposes a standard for handling bubbled up reverts in Ethereum smart contracts using a dedicated custom error. This standard aims to improve the clarity and usability of revert reasons by allowing additional context to be passed alongside the raw bytes of the bubbled up revert. TheWrappedErrorcustom error should wrap reverts from called contracts and provide a consistent interface for parsing and handling reverts in tools like Etherscan or Tenderly.", "Abstract": "This ERC proposes a standard for handling bubbled up reverts in Ethereum smart contracts using a dedicated custom error. This standard aims to improve the clarity and usability of revert reasons by allowing additional context to be passed alongside the raw bytes of the bubbled up revert. TheWrappedErrorcustom error should wrap reverts from called contracts and provide a consistent interface for parsing and handling reverts in tools like Etherscan or Tenderly.", "Motivation": "Currently, when a smart contract calls another and the called contract reverts, the revert reason is usually bubbled up and thrown as is. This can make it more difficult to tell which context the error came from. By standardizing the use of custom errors with additional context, more meaningful and informative revert reasons can be provided. This will improve the debugging experience and make it easier for developers and infrastructure providers like Etherscan to display accurate stack traces.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "By including the called contract and function, raw revert bytes and additional context, developers can provide more detailed information about the failure. Additionally, by standardizing the way reverts are bubbled up, it also enables nested bubbled up reverts where multiple reverts thrown by different contracts can be followed recursively. The reverts can also be parsed and handled by tools like Etherscan and Foundry to further enhance the readability and debuggability of smart contract interactions, as well as facilitating better error handling practices in general.", "Backwards Compatibility": "This ERC does not introduce any backwards incompatibilities. Existing contracts can adopt this standard incrementally.", "Test Cases": "When catching a revert from a called contract, the calling contract should revert with a custom error following the above conventions.", "Reference Implementation": "When catching a revert from a called contract, the calling contract should revert with a custom error following the above conventions.", "Security Considerations": "Smart contracts could either drop or purposefully suppress the bubbled up reverts along the revert chain. Additionally, smart contracts may also lie or incorrectly report the wrapped reverts, so the information is not guaranteed to be accurate.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7818, "url": "https://eips.ethereum.org/EIPS/eip-7818", "title": "Expirable ERC-20", "authors": ["sirawt\u00a0(", "@MASDXI", ")", "ADISAKBOONMARK\u00a0(", "@ADISAKBOONMARK", ")"], "sections": {"ERC-7818: Expirable ERC-20": "Introduces an extension forERC-20tokens, which facilitates the implementation of an expiration mechanism. Through this extension, tokens have a predetermined validity period, after which they become invalid and can no longer be transferred or used. This functionality proves beneficial in scenarios such as time-limited bonds, loyalty rewards, or game tokens necessitating automatic invalidation after a specific duration. The extension is crafted to seamlessly align with the existingERC-20standard, ensuring smooth integration with the prevailing token smart contract while introducing the capability to govern and enforce token expiration at the contract level.", "An ERC-20 extension for creating fungible tokens with expiration, supporting time-limited use cases.": "Introduces an extension forERC-20tokens, which facilitates the implementation of an expiration mechanism. Through this extension, tokens have a predetermined validity period, after which they become invalid and can no longer be transferred or used. This functionality proves beneficial in scenarios such as time-limited bonds, loyalty rewards, or game tokens necessitating automatic invalidation after a specific duration. The extension is crafted to seamlessly align with the existingERC-20standard, ensuring smooth integration with the prevailing token smart contract while introducing the capability to govern and enforce token expiration at the contract level.", "Abstract": "Introduces an extension forERC-20tokens, which facilitates the implementation of an expiration mechanism. Through this extension, tokens have a predetermined validity period, after which they become invalid and can no longer be transferred or used. This functionality proves beneficial in scenarios such as time-limited bonds, loyalty rewards, or game tokens necessitating automatic invalidation after a specific duration. The extension is crafted to seamlessly align with the existingERC-20standard, ensuring smooth integration with the prevailing token smart contract while introducing the capability to govern and enforce token expiration at the contract level.", "Motivation": "This extension facilitates the development ofERC-20standard compatible tokens featuring expiration dates. This capability broadens the scope of potential applications, particularly those involving time-sensitive assets. Expirable tokens are well-suited for scenarios necessitating temporary validity, including:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Epoch Mechanism": "Epochsrepresent a specific period or block range during which certain tokens are valid. They can be categorized into two types", "Balance Look Back Over Epochs": "To retrieve the usable balance, tokens are checked from thecurrent epochagainst apast epoch(which can be anynepochs back). The past epoch can be set to any valuen, allowing flexibility in tracking and summing tokens that are still valid from previous epochs, up tonepochs back.", "Behavior Specification": "TheseOPTIONALfunctions provide additional functionality that might be useful depending on the specific use case.", "Additional Potential Useful Function": "TheseOPTIONALfunctions provide additional functionality that might be useful depending on the specific use case.", "Rationale": "Although the termepochis an abstract concept, it leaves room for various implementations. For example, epochs can support more granular tracking of tokens within each epoch, allowing for greater control over when tokens are valid or expired on-chain. Alternatively, epochs can support bulk expiration, where all tokens within the same epoch expire simultaneously. This flexibility enables different methods of tracking token expiration, depending on the specific needs of the use case.epochalso introduces a \u201clazy\u201d way to simplify token expiration tracking in a flexible and gas-efficient manner. Instead of continuously updating the expiration state withwriteoperations by the user or additional services, the current epoch can be calculated using areadoperation.", "Backwards Compatibility": "This standard is fullyERC-20compatible.", "Reference Implementation": "For reference implementation can be foundhere, But in the reference implementation, we employ a sorted list to automatically select the token that nearest expires first with a First-In-First-Out (FIFO) and sliding window algorithm that operates based on theblock.numberas opposed to relying onblock.timestamp, which has been criticized for its lack of security and resilience, particularly given the increasing usage of Layer 2 (L2) networks over Layer 1 (L1) networks. Many L2 networks exhibit centralization and instability, which directly impacts asset integrity, rendering them potentially unusable during periods of network halting, as they are still reliant on the timestamp.", "Security Considerations": "Run out of gas problem due to the operation consuming higher gas if transferring multiple groups of small tokens or loop transfer.", "Denial Of Service": "Run out of gas problem due to the operation consuming higher gas if transferring multiple groups of small tokens or loop transfer.", "Gas Limit Vulnerabilities": "Exceeds block gas limit if the blockchain has a block gas limit lower than the gas used in the transaction.", "Block values as a proxy for time": "if usingblock.timestampfor calculatingepochand In rare network halts, block production stops, freezingblock.timestampand disrupting time-based logic. This risks asset integrity and inconsistent states.", "Fairness Concerns": "In a straightforward implementation, where all tokens within the same epoch share the same expiration (e.g., atepoch:x), bulk expiration occurs.", "Risks in Liquidity Pools": "When tokens with expiration dates are deposited into liquidity pools (e.g., in DEXs), they may expire while still in the pool.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7820, "url": "https://eips.ethereum.org/EIPS/eip-7820", "title": "Access Control Registry", "authors": ["Shubham Khandelwal\u00a0(", "@shubh-ta", ")", "Anushka Yadav\u00a0(", "@anushka642000", ")"], "sections": {"ERC-7820: Access Control Registry": "The Access Control Registry (ACR) standard defines a universal interface for managing role-based access control across multiple smart contracts. This standard introduces a centralized registry system allowing access control management for multiple smart contracts. The single access-control registry smart contract manages the user roles across multiple contracts, and can be queryed for contract-specific role information. Additionally, the ACR standard provides functionality to grant and revoke roles for specific accounts, either individually or in bulk, ensuring that only authorized users can perform specific actions within a specific contract.", "Registration, unregistration, role assignment, and role revocation for contracts, ensuring secure and transparent role management.": "The Access Control Registry (ACR) standard defines a universal interface for managing role-based access control across multiple smart contracts. This standard introduces a centralized registry system allowing access control management for multiple smart contracts. The single access-control registry smart contract manages the user roles across multiple contracts, and can be queryed for contract-specific role information. Additionally, the ACR standard provides functionality to grant and revoke roles for specific accounts, either individually or in bulk, ensuring that only authorized users can perform specific actions within a specific contract.", "Abstract": "The Access Control Registry (ACR) standard defines a universal interface for managing role-based access control across multiple smart contracts. This standard introduces a centralized registry system allowing access control management for multiple smart contracts. The single access-control registry smart contract manages the user roles across multiple contracts, and can be queryed for contract-specific role information. Additionally, the ACR standard provides functionality to grant and revoke roles for specific accounts, either individually or in bulk, ensuring that only authorized users can perform specific actions within a specific contract.", "Motivation": "As decentralized applications (dApps) grow in complexity, managing access control across multiple smart contracts becomes increasingly difficult.\nCurrent practices involve bespoke implementations, leading to redundancy and potential security flaws. A standardized approach for managing roles and permissions will ensure better interoperability, security, and transparency. By providing a unified interface for registering contracts and managing roles, this standard simplifies development, ensures consistency and enhances security. It facilitates easier integration and auditing, fostering a more robust and interoperable ecosystem.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "TheIAccessControlRegistryinterface aims to provide a standardized way to manage access control across multiple contracts within the ecosystem. By defining a clear structure and set of events, this interface helps streamline the process of registering, unregistering, and managing roles for contracts. The rationale for each function and event is as follows:", "Contract Registration and Unregistration": "registerContract(address _admin): This function allows the registration of a new contract along with its admin address. This is crucial for initializing the access control settings for a contract and ensuring that there is an accountable admin who can manage roles and permissions.", "Role Management": "grantRole(address[] memory targetContracts, bytes32[] memory roles, address[] memory accounts): This function allows the assignment of roles to multiple accounts for multiple contracts in a single transaction. This bulk operation is designed to reduce the gas costs and simplify the process of role assignment in large systems with numerous contracts and users.", "Role Checking": "getRoleInfo(address targetContract, address account, bytes32 role): This view function allows the verification of whether a particular account holds a specific role for a given contract. This is essential for ensuring that operations requiring specific permissions are performed only by authorized users.", "Contract Information Retrieval": "getContractInfo(address _contract): This function provides the ability to retrieve the status and admin information of a registered contract. It enhances transparency and allows administrators and users to easily query the status and management of any contract within the registry.", "Events": "ContractRegistered(address indexed _contract, address indexed _admin): Emitted when a new contract is registered, this event ensures that there is a public record of contract registrations, facilitating auditability and transparency.", "Reference Implementation": "Theregisterfunction must be invoked from the registering smart contract.\nThegrantRoleandrevokeRolefunctions must be invoked either from the registered contract or the admin of the registered contract.", "Design Decisions": "There are a few design decisions that have to be explicitly specified to ensure the functionality, security, and efficiency of theIAccessControlRegistry:", "Security Considerations": "TheAccessControlRegistryimplements several security measures to ensure the integrity and reliability of the access control system:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- getcontract: Introduces the GETCONTRACT opcode to return the address containing the bytecode by its hash, allowing contracts to identify and interact based on deterministic and tamper-proof bytecode identifiers. This opcode enhances security, auditability, and efficiency in the Ethereum ecosystem by enabling deterministic references to contract code, bypassing the mutability and opacity of contract addresses.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1191, "url": "https://eips.ethereum.org/EIPS/eip-1191", "title": "2019-11-18", "authors": ["Add chain id to mixed-case checksum address encoding"], "sections": {"ERC-1191: Add chain id to mixed-case checksum address encoding": "This EIP extendsEIP-55by optionally adding a chain id defined byEIP-155to the checksum calculation.", "": "This EIP extendsEIP-55by optionally adding a chain id defined byEIP-155to the checksum calculation.", "Simple Summary": "This EIP extendsEIP-55by optionally adding a chain id defined byEIP-155to the checksum calculation.", "Abstract": "TheEIP-55was created to prevent users from losing funds by sending them to invalid addresses. This EIP extendsEIP-55to protect users from losing funds by sending them to addresses that are valid but that where obtained from a client of another network.For example, if this EIP is implemented, a wallet can alert the user that is trying to send funds to an Ethereum Testnet address from an Ethereum Mainnet wallet.", "Motivation": "The motivation of this proposal is to provide a mechanism to allow software to distinguish addresses from different Ethereum based networks. This proposal is necessary because Ethereum addresses are hashes of public keys and do not include any metadata. By extending theEIP-55checksum algorithm it is possible to achieve this objective.", "Specification": "Convert the address using the same algorithm defined byEIP-55but if a registered chain id is provided, add it to the input of the hash function. If the chain id passed to the function belongs to a network that opted for using this checksum variant, prefix the address with the chain id and the0xseparator before calculating the hash. Then convert the address to hexadecimal, but if the ith digit is a letter (ie. it\u2019s one ofabcdef) print it in uppercase if the 4*ith bit of the calculated hash is 1 otherwise print it in lowercase.", "Rationale": "Benefits:", "Implementation": "Copyright and related rights waived viaCC0.", "Test Cases": "Copyright and related rights waived viaCC0.", "Usage": "Copyright and related rights waived viaCC0.", "Usage  Table": "Copyright and related rights waived viaCC0.", "Implementation Table": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2266, "url": "https://eips.ethereum.org/EIPS/eip-2266", "title": "2020-12-31", "authors": ["Atomic Swap-based American Call Option Contract Standard"], "sections": {"ERC-2266: Atomic Swap-based American Call Option Contract Standard": "A standard for token contracts providing Atomic Swap-based American Call Option functionalities.", "": "A standard for token contracts providing Atomic Swap-based American Call Option functionalities.", "Simple Summary": "A standard for token contracts providing Atomic Swap-based American Call Option functionalities.", "Abstract": "This standard provides functionality to make Atomic Swap-based American Call Option payment. The Atomic Swap protocol based on Hashed Time-Locked Contract (HTLC)1has optionality2, and such optionality can be utilised to construct American Call Options without trusted third party. This standard defines the common way of implementing this protocol. In particular, this EIP defines technical terms, provides interfaces, and gives reference implementations of this protocol.", "Motivation": "Atomic Swap allows users to atomically exchange their tokens without trusted third parties while the HTLC is commonly used for the implementation. However, the HTLC-based Atomic Swap has optionality. More specifically, the swap initiator can choose to proceed or abort the swap for several hours, which gives him time for speculating according to the exchange rate. A discussion2shows that the HTLC-based Atomic Swap is equivalent to an American Call Option in finance. On the other hand,thanks to such optionality, the HTLC-based Atomic Swap can be utilised to construct American Call Options without trusted third party. A paper3proposes a secure Atomic-Swap-based American Call Option protocol on smart contracts. This protocol not only eliminates the arbitrage opportunity but also prevents any party from locking the other party\u2019s money maliciously. This EIP aims at providing the standard of implementing this protocol in existing token standards.", "Specification": "The Atomic Swap-based American Call Option smart contract should follow the syntax and semantics of Ethereum smart contracts.", "Definitions": "This mapping stores the metadata of the swap contracts, including the parties and tokens involved. Each contract uses differentsecretHash, and is distinguished bysecretHash.", "Storage Variables": "This mapping stores the metadata of the swap contracts, including the parties and tokens involved. Each contract uses differentsecretHash, and is distinguished bysecretHash.", "Methods": "This function sets up the swap contract, including the both parties involved, the tokens to exchanged, and so on.", "Events": "This event indicates that one party has set up the contract using the functionsetup().", "Rationale": "This proposal is fully backward compatible. Functionalities of existing standards will not be affected by this proposal, as it only provides additional features to them.", "Security Considerations": "This proposal is fully backward compatible. Functionalities of existing standards will not be affected by this proposal, as it only provides additional features to them.", "Backwards Compatibility": "This proposal is fully backward compatible. Functionalities of existing standards will not be affected by this proposal, as it only provides additional features to them.", "Implementation": "Please visithereto find our example implementation.", "Copyright": "Copyright and related rights waived viaCC0.", "References": "Please cite this document as:", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5008, "url": "https://eips.ethereum.org/EIPS/eip-5008", "title": "2023-08-15", "authors": ["ERC-721 Nonce Extension"], "sections": {"ERC-5008: ERC-721 Nonce Extension": "This standard is an extension ofERC-721. It proposes adding anoncefunction to ERC-721 tokens.", "Add a `nonce` function to ERC-721.": "This standard is an extension ofERC-721. It proposes adding anoncefunction to ERC-721 tokens.", "Abstract": "This standard is an extension ofERC-721. It proposes adding anoncefunction to ERC-721 tokens.", "Motivation": "Some orders of NFT marketplaces have been attacked and the NFTs sold at a lower price than the current market floor price. This can happen when users transfer an NFT to another wallet and, later, back to the original wallet. This reactivates the order, which may list the token at a much lower price than the owner would have intended.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "At firsttransferCountwas considered as function name, but there may some case to change thenoncebesides transfer, such as important properties changed, then we changedtransferCounttononce.", "Backwards Compatibility": "This standard is compatible with ERC-721.", "Test Cases": "Test cases are included intest.js.", "Reference Implementation": "SeeERC5008.sol.", "Security Considerations": "No security issues found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5114, "url": "https://eips.ethereum.org/EIPS/eip-5114", "title": "2023-09-19", "authors": ["Soulbound Badge"], "sections": {"ERC-5114: Soulbound Badge": "A soulbound badge is a token that, when minted, is bound to another Non-Fungible Token (NFT), and cannot be transferred/moved after that.", "A token that is attached to a \"soul\" at mint time and cannot be transferred after that.": "A soulbound badge is a token that, when minted, is bound to another Non-Fungible Token (NFT), and cannot be transferred/moved after that.", "Abstract": "A soulbound badge is a token that, when minted, is bound to another Non-Fungible Token (NFT), and cannot be transferred/moved after that.", "Specification": "Implementers of this standardSHOULDalso depend on a standard for interface detection so callers can easily find out if a given contract implements this interface.", "Rationale": "By requiring that badges can never move, we both guarantee non-separability and non-mergeability among collections of soulbound badges that are bound to a single NFT while simultaneously allowing users to aggressively cache results.", "Immutability": "By requiring that badges can never move, we both guarantee non-separability and non-mergeability among collections of soulbound badges that are bound to a single NFT while simultaneously allowing users to aggressively cache results.", "Content Addressable URIs Required": "Soulbound badges are meant to be permanent badges/indicators attached to a persona.\nThis means that not only can the user not transfer ownership, but the minter also cannot withdraw/transfer/change ownership as well.\nThis includes mutating or removing any remote content as a means of censoring or manipulating specific users.", "No Specification forbadgeUriData Format": "The format of the data pointed to bycollectionUri()andbadgeUri(uint256), and how to merge them, is intentionally left out of this standard in favor of separate standards that can be iterated on in the future.\nThe immutability constraints are the only thing defined by this to ensure that the spirit of this badge is maintained, regardless of the specifics of the data format.\nThemetadataFormatfunction can be used to inform a caller what type/format/version of data they should expect at the URIs, so the caller can parse the data directly without first having to deduce its format via inspection.", "Backwards Compatibility": "This is a new token type and is not meant to be backward compatible with any existing tokens other than existing viable souls (any asset that can be identified by[address,id]).", "Security Considerations": "Users of badges that claim to implement this EIP must be diligent in verifying they actually do.\nA badge author can create a badge that, upon initial probing of the API surface, may appear to follow the rules when in reality it doesn\u2019t.\nFor example, the contract could allow transfers via some mechanism and simply not utilize them initially.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5164, "url": "https://eips.ethereum.org/EIPS/eip-5164", "title": "2023-11-15", "authors": ["Cross-Chain Execution"], "sections": {"ERC-5164: Cross-Chain Execution": "This specification defines a cross-chain execution interface for EVM-based blockchains. Implementations of this specification will allow contracts on one chain to call contracts on another by sending a cross-chain message.", "Defines an interface that supports execution across EVM networks.": "This specification defines a cross-chain execution interface for EVM-based blockchains. Implementations of this specification will allow contracts on one chain to call contracts on another by sending a cross-chain message.", "Abstract": "This specification defines a cross-chain execution interface for EVM-based blockchains. Implementations of this specification will allow contracts on one chain to call contracts on another by sending a cross-chain message.", "Motivation": "Many Ethereum protocols need to coordinate state changes across multiple EVM-based blockchains. These chains often have native or third-party bridges that allow Ethereum contracts to execute code. However, bridges have different APIs so bridge integrations are custom. Each one affords different properties; with varying degrees of security, speed, and control. Defining a simple, common specification will increase code re-use and allow us to use common bridge implementations.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "MessageDispatcher": "TheMessageDispatcherlives on the chain from which messages are sent. The Dispatcher\u2019s job is to broadcast messages through a transport layer to one or moreMessageExecutorcontracts.", "MessageExecutor": "TheMessageExecutorexecutes dispatched messages and message batches. Developers must implement aMessageExecutorin order to execute messages on the receiving chain.", "Rationale": "TheMessageDispatchercan be coupled to one or moreMessageExecutor. It is up to bridges to decide how to couple the two. Users can easily bridge a message by callingdispatchMessagewithout being aware of theMessageExecutoraddress. Messages can also be traced by a client using the data logged by theMessageIdExecutedevent.", "Backwards Compatibility": "This specification is compatible with existing governance systems as it offers simple cross-chain execution.", "Security Considerations": "Bridge trust profiles are variable, so users must understand that bridge security depends on the implementation.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5216, "url": "https://eips.ethereum.org/EIPS/eip-5216", "title": "2022-11-12", "authors": ["ERC-1155 Allowance Extension"], "sections": {"ERC-5216: ERC-1155 Allowance Extension": "This ERC defines standard functions for granular approval ofERC-1155tokens by bothidandamount. This ERC extendsERC-1155.", "Extension for ERC-1155 secure approvals": "This ERC defines standard functions for granular approval ofERC-1155tokens by bothidandamount. This ERC extendsERC-1155.", "Abstract": "This ERC defines standard functions for granular approval ofERC-1155tokens by bothidandamount. This ERC extendsERC-1155.", "Motivation": "ERC-1155\u2019s popularity means that multi-token management transactions occur on a daily basis. Although it can be used as a more comprehensive alternative toERC-721, ERC-1155 is most commonly used as intended: creating multipleids, each with multiple tokens. While many projects interface with these semi-fungible tokens, by far the most common interactions are with NFT marketplaces.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Interface implementation": "Theapprove(address operator, uint256 id, uint256 amount)function MUST be eitherpublicorexternal.", "Rationale": "The name \u201cERC-1155 Allowance Extension\u201d was chosen because it is a succinct description of this ERC. Users can approve their tokens byidandamounttooperators.", "Backwards Compatibility": "This standard is compatible withERC-1155.", "Reference Implementation": "The reference implementation can be foundhere.", "Security Considerations": "Users of this ERC must thoroughly consider the amount of tokens they give permission tooperators, and should revoke unused authorizations.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5453, "url": "https://eips.ethereum.org/EIPS/eip-5453", "title": "2023-09-27", "authors": ["Endorsement - Permit for Any Functions"], "sections": {"ERC-5453: Endorsement - Permit for Any Functions": "This EIP establish a general protocol for permitting approving function calls in the same transaction rely onERC-5750.\nUnlike a few prior art (ERC-2612forERC-20,ERC-4494forERC-721that\nusually only permit for a single behavior (transferfor ERC-20 andsafeTransferFromfor ERC-721) and a single approver in two transactions (first apermit(...)TX, then atransfer-like TX), this EIP provides a way to permit arbitrary behaviors and aggregating multiple approvals from arbitrary number of approvers in the same transaction, allowing for Multi-Sig or Threshold Signing behavior.", "A general protocol for approving function calls in the same transaction rely on ERC-5750.": "This EIP establish a general protocol for permitting approving function calls in the same transaction rely onERC-5750.\nUnlike a few prior art (ERC-2612forERC-20,ERC-4494forERC-721that\nusually only permit for a single behavior (transferfor ERC-20 andsafeTransferFromfor ERC-721) and a single approver in two transactions (first apermit(...)TX, then atransfer-like TX), this EIP provides a way to permit arbitrary behaviors and aggregating multiple approvals from arbitrary number of approvers in the same transaction, allowing for Multi-Sig or Threshold Signing behavior.", "Abstract": "This EIP establish a general protocol for permitting approving function calls in the same transaction rely onERC-5750.\nUnlike a few prior art (ERC-2612forERC-20,ERC-4494forERC-721that\nusually only permit for a single behavior (transferfor ERC-20 andsafeTransferFromfor ERC-721) and a single approver in two transactions (first apermit(...)TX, then atransfer-like TX), this EIP provides a way to permit arbitrary behaviors and aggregating multiple approvals from arbitrary number of approvers in the same transaction, allowing for Multi-Sig or Threshold Signing behavior.", "Motivation": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Interfaces": "The interfaces and structure referenced here are as followed", "Behavior specification": "As specified inERC-5750 General Extensibility for Method Behaviors, any compliant method that has anbytes extraDataas its\nlast method designated for extending behaviors can conform toERC-5453as the way to indicate a permit from certain user.", "Rationale": "The design assumes abytes calldata extraDatato maximize the flexibility of future extensions. This assumption is compatible withERC-721,ERC-1155and many other ERC-track EIPs. Those that aren\u2019t, such asERC-20, can also be updated to support it, such as using a wrapper contract or proxy upgrade.", "Backwards Compatibility": "The design assumes abytes calldata extraDatato maximize the flexibility of future extensions. This assumption is compatible withERC-721,ERC-1155and many other ERC-track EIPs. Those that aren\u2019t, such asERC-20, can also be updated to support it, such as using a wrapper contract or proxy upgrade.", "Reference Implementation": "In addition to the specified algorithm for validating endorser signatures, we also present the following reference implementations.", "Reference Implementation ofEndorsableERC721": "Here is a reference implementation ofEndorsableERC721that achieves similar behavior ofERC-4494.", "Reference Implementation ofThresholdMultiSigForwarder": "Here is a reference implementation of ThresholdMultiSigForwarder that achieves similar behavior of multi-sig threshold approval\nremote contract call like a Gnosis-Safe wallet.", "Security Considerations": "A replay attack is a type of attack on cryptography authentication. In a narrow sense, it usually refers to a type of attack that circumvents the cryptographically signature verification by reusing an existing signature for a message being signed again. Any implementations relying on this EIP must realize that all smart endorsements described here are cryptographic signatures that arepublicand can be obtained by anyone. They must foresee the possibility of a replay of the transactions not only at the exact deployment of the same smart contract, but also other deployments of similar smart contracts, or of a version of the same contract on anotherchainId, or any other similar attack surfaces. Thenonce,validSince, andvalidByfields are meant to restrict the surface of attack but might not fully eliminate the risk of all such attacks, e.g. see thePhishingsection.", "Replay Attacks": "A replay attack is a type of attack on cryptography authentication. In a narrow sense, it usually refers to a type of attack that circumvents the cryptographically signature verification by reusing an existing signature for a message being signed again. Any implementations relying on this EIP must realize that all smart endorsements described here are cryptographic signatures that arepublicand can be obtained by anyone. They must foresee the possibility of a replay of the transactions not only at the exact deployment of the same smart contract, but also other deployments of similar smart contracts, or of a version of the same contract on anotherchainId, or any other similar attack surfaces. Thenonce,validSince, andvalidByfields are meant to restrict the surface of attack but might not fully eliminate the risk of all such attacks, e.g. see thePhishingsection.", "Phishing": "It\u2019s worth pointing out a special form of replay attack by phishing. An adversary can design another smart contract in a way that the user be tricked into signing a smart endorsement for a seemingly legitimate purpose, but the data-to-designed matches the target application", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5496, "url": "https://eips.ethereum.org/EIPS/eip-5496", "title": "2022-11-29", "authors": ["Multi-privilege Management NFT Extension"], "sections": {"ERC-5496: Multi-privilege Management NFT Extension": "This EIP defines an interface extendingEIP-721to provide shareable multi-privileges for NFTs. Privileges may be on-chain (voting rights, permission to claim an airdrop) or off-chain (a coupon for an online store, a discount at a local restaurant, access to VIP lounges in airports). Each NFT may contain many privileges, and the holder of a privilege can verifiably transfer that privilege to others. Privileges may be non-shareable or shareable. Shareable privileges can be cloned, with the provider able to adjust the details according to the spreading path. Expiration periods can also be set for each privilege.", "Create shareable multi-privilege NFTs for EIP-721": "This EIP defines an interface extendingEIP-721to provide shareable multi-privileges for NFTs. Privileges may be on-chain (voting rights, permission to claim an airdrop) or off-chain (a coupon for an online store, a discount at a local restaurant, access to VIP lounges in airports). Each NFT may contain many privileges, and the holder of a privilege can verifiably transfer that privilege to others. Privileges may be non-shareable or shareable. Shareable privileges can be cloned, with the provider able to adjust the details according to the spreading path. Expiration periods can also be set for each privilege.", "Abstract": "This EIP defines an interface extendingEIP-721to provide shareable multi-privileges for NFTs. Privileges may be on-chain (voting rights, permission to claim an airdrop) or off-chain (a coupon for an online store, a discount at a local restaurant, access to VIP lounges in airports). Each NFT may contain many privileges, and the holder of a privilege can verifiably transfer that privilege to others. Privileges may be non-shareable or shareable. Shareable privileges can be cloned, with the provider able to adjust the details according to the spreading path. Expiration periods can also be set for each privilege.", "Motivation": "This standard aims to efficiently manage privileges attached to NFTs in real-time. Many NFTs have functions other than just being used as profile pictures or art collections, they may have real utilities in different scenarios. For example, a fashion store may give a discount for its own NFT holders; a DAO member NFT holder can vote for the proposal of how to use their treasury; a dApp may create an airdrop event to attract a certain group of people like some blue chip NFT holders to claim; the grocery store can issue its membership card on chain (as an NFT) and give certain privileges when the members shop at grocery stores, etc. There are cases when people who own NFTs do not necessarily want to use their privileges. By providing additional data recording different privileges a NFT collection has and interfaces to manage them, users can transfer or sell privileges without losing their ownership of the NFT.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "The number of privilege holders is limited by the number of NFTs if privileges are non-shareable. A shareable privilege means the original privilege holder can copy the privilege and give it to others, not transferring his/her own privilege to them. This mechanism greatly enhances the spread of privileges as well as the adoption of NFTs.", "Shareable Privileges": "The number of privilege holders is limited by the number of NFTs if privileges are non-shareable. A shareable privilege means the original privilege holder can copy the privilege and give it to others, not transferring his/her own privilege to them. This mechanism greatly enhances the spread of privileges as well as the adoption of NFTs.", "Expire Date Type": "The expiry timestamp of a privilege is a timestamp and stored inuint256typed variables.", "Beneficiary of Referrer": "For example, a local pizza shop offers a 30% off Coupon and the owner of the shop encourages their consumers to share the coupon with friends, then the friends can get the coupon. Let\u2019s say Tom gets 30% off Coupon from the shop and he shares the coupon with Alice. Alice gets the coupon too and Alice\u2019s referrer is Tom. For some certain cases, Tom may get more rewards from the shop. This will help the merchants in spreading the promotion among consumers.", "Proposal: NFT Transfer": "If the owner of the NFT transfers ownership to another user, there is no impact on \u201cprivileges\u201d. But errors may occur if the owner tries to withdraw the originalEIP-721token from the wrapped NFT throughunwrap()if any available privileges are still ongoing. We protect the rights of holders of the privileges to check the last expiration date of the privilege.", "Backwards Compatibility": "This EIP is compatible with any kind of NFTs that follow the EIP-721 standard. It only adds more functions and data structures without interfering with the originalEIP-721standard.", "Test Cases": "Test cases are implemented with the reference implementation.", "Test Code": "test.js", "Reference Implementation": "Implementations must thoroughly consider who has the permission to set or clone privileges.", "Security Considerations": "Implementations must thoroughly consider who has the permission to set or clone privileges.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6093, "url": "https://eips.ethereum.org/EIPS/eip-6093", "title": "2023-08-15", "authors": ["Custom errors for commonly-used tokens"], "sections": {"ERC-6093: Custom errors for commonly-used tokens": "This EIP defines a standard set of custom errors for commonly-used tokens, which are defined asERC-20,ERC-721, andERC-1155tokens.", "Lists custom errors for common token implementations": "This EIP defines a standard set of custom errors for commonly-used tokens, which are defined asERC-20,ERC-721, andERC-1155tokens.", "Abstract": "This EIP defines a standard set of custom errors for commonly-used tokens, which are defined asERC-20,ERC-721, andERC-1155tokens.", "Motivation": "Since the introduction of Solidity custom errors in v0.8.4, these have provided a way to show failures in a more expressive and gas efficient manner with dynamic arguments, while reducing deployment costs.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "ERC-20": "Indicates an error related to the currentbalanceof asender.\nUsed in transfers.", "ERC-721": "Indicates that an address can\u2019t be an owner.\nUsed in balance queries.", "ERC-1155": "Indicates an error related to the currentbalanceof asender.\nUsed in transfers.", "Parameter Glossary": "Any addition to this EIP or implementation-specific errors (such as extensions) SHOULD follow the guidelines presented in therationalesection to keep consistency.", "Error additions": "Any addition to this EIP or implementation-specific errors (such as extensions) SHOULD follow the guidelines presented in therationalesection to keep consistency.", "Rationale": "The chosen objectives for a standard for token errors are to provide context about the error, and to make moderate use of meaningful arguments (to maintain the code size benefits with respect to strings).", "Actions and subjects": "An error is defined based on the followingactionsthat can be performed on a token and its involvedsubjects:", "Error prefixes": "An error prefix is added to a subject to derive a concrete error condition.\nDevelopers can think about an error prefix as thewhyan error happened.", "Domain": "Each error\u2019s arguments may vary depending on the token domain. If there are errors with the same name and different arguments, the Solidity compiler currently fails with aDeclarationError.", "Arguments": "The selection of arguments depends on the subject involved, and it should follow the order presented below:", "Error grammar rules": "Given the above, we can summarize the construction of error names with a grammar that errors will follow:", "Backwards Compatibility": "Tokens already deployed rely mostly on revert strings and make use ofrequireinstead of custom errors. Even most of the newly deployed tokens since Solidity\u2019s v0.8.4 release inherit from implementations using revert strings.", "Reference Implementation": "There are no known signature hash collisions for the specified errors.", "Solidity": "There are no known signature hash collisions for the specified errors.", "Security Considerations": "There are no known signature hash collisions for the specified errors.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6357, "url": "https://eips.ethereum.org/EIPS/eip-6357", "title": "2023-11-10", "authors": ["Single-contract Multi-delegatecall"], "sections": {"ERC-6357: Single-contract Multi-delegatecall": "This EIP standardizes an interface containing a single function,multicall, allowing EOAs to call multiple functions of a smart contract in a single transaction, and revert all calls if any call fails.", "Allows an EOA to call multiple functions of a smart contract in a single transaction": "This EIP standardizes an interface containing a single function,multicall, allowing EOAs to call multiple functions of a smart contract in a single transaction, and revert all calls if any call fails.", "Abstract": "This EIP standardizes an interface containing a single function,multicall, allowing EOAs to call multiple functions of a smart contract in a single transaction, and revert all calls if any call fails.", "Motivation": "Currently, in order to transfer severalERC-721NFTs, one needs to submit a number of transactions equal to the number of NFTs being tranferred. This wastes users\u2019 funds by requiring them to pay 21000 gas fee for every NFT they transfer.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "multicallPayableis optional because it isn\u2019t always feasible to implement, due to themsg.valuesplitting.", "Backwards Compatibility": "This is compatible with most existing multicall functions.", "Test Cases": "The following JavaScript code, using the Ethers library, should atomically transferamtunits of anERC-20token to bothaddressAandaddressB.", "Reference Implementation": "multicallPayableshould only be used if the contract is able to support it. A naive attempt at implementing it could allow an attacker to call a payable function multiple times with the same ether.", "Security Considerations": "multicallPayableshould only be used if the contract is able to support it. A naive attempt at implementing it could allow an attacker to call a payable function multiple times with the same ether.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7627, "url": "https://eips.ethereum.org/EIPS/eip-7627", "title": "2025-02-18", "authors": ["Secure Messaging Protocol"], "sections": {"ERC-7627: Secure Messaging Protocol": "This proposal implements the capability to securely exchange encrypted messages on-chain. Users can register their public keys and encryption algorithms by registration and subsequently send encrypted messages to other users using their addresses. The interface also includes enumerations for public key algorithms and a structure for user information to support various encryption algorithms and user information management.", "End-to-end encryption for sending messages between users.": "This proposal implements the capability to securely exchange encrypted messages on-chain. Users can register their public keys and encryption algorithms by registration and subsequently send encrypted messages to other users using their addresses. The interface also includes enumerations for public key algorithms and a structure for user information to support various encryption algorithms and user information management.", "Abstract": "This proposal implements the capability to securely exchange encrypted messages on-chain. Users can register their public keys and encryption algorithms by registration and subsequently send encrypted messages to other users using their addresses. The interface also includes enumerations for public key algorithms and a structure for user information to support various encryption algorithms and user information management.", "Motivation": "With the emergence of Layer 2 chains featuring sub-second block times and the introduction of account abstraction, the use of end-to-end encrypted communication has facilitated the proliferation of real-time communication and online chat dApps. Providing a unified interface enables easy integration of encrypted communication into smart contracts, thereby fostering innovation. Standardization promotes interoperability, facilitating seamless communication across platforms.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Objectives": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Interface": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "By emitting events when messages are sent or public keys are updated, the implementation facilitates seamless integration with off-chain dApps. This enables these dApps to easily track and display the latest messages and updates, ensuring real-time responsiveness and enhancing user interaction.", "Event Emission for Off-Chain Integration": "By emitting events when messages are sent or public keys are updated, the implementation facilitates seamless integration with off-chain dApps. This enables these dApps to easily track and display the latest messages and updates, ensuring real-time responsiveness and enhancing user interaction.", "End-to-End Encryption Security": "The design ensures that only the owner of an address can update their public key. This restriction preserves the integrity of the end-to-end encryption, making sure that only the intended recipient can decrypt and read the messages, thereby securing communication.", "Session ID for Conversation Organization": "The use of session IDs in message transactions allows multiple messages to be grouped under specific conversations. This feature is crucial for organizing and managing discussions within a dApp, providing users with a coherent and structured messaging experience.", "Reference Implementation": "When selecting encryption algorithms, it is essential to stay informed about the latest security news and recommendations. Avoid using asymmetric encryption algorithms with known vulnerabilities or those not recommended to ensure the confidentiality and integrity of messages. Regularly update encryption algorithms to address evolving security threats.", "Security Considerations": "When selecting encryption algorithms, it is essential to stay informed about the latest security news and recommendations. Avoid using asymmetric encryption algorithms with known vulnerabilities or those not recommended to ensure the confidentiality and integrity of messages. Regularly update encryption algorithms to address evolving security threats.", "Copyright": "Copyright and related rights waived viaCC0", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1185, "url": "https://eips.ethereum.org/EIPS/eip-1185", "title": "Storage of DNS Records in ENS", "authors": ["Jim McDonald\u00a0(", "@mcdee", ")"], "sections": {"ERC-1185: Storage of DNS Records in ENS": "This EIP defines a resolver profile for ENS that provides features for storage and lookup of DNS records. This allows ENS to be used as a store of authoritative DNS information.", "A system to store and retrieve DNS records within the ENS contract.": "This EIP defines a resolver profile for ENS that provides features for storage and lookup of DNS records. This allows ENS to be used as a store of authoritative DNS information.", "Abstract": "This EIP defines a resolver profile for ENS that provides features for storage and lookup of DNS records. This allows ENS to be used as a store of authoritative DNS information.", "Motivation": "ENS is a highly desirable store for DNS information.  It provides the distributed authority of DNS without conflating ownership and authoritative serving of information.  With ENS, the owner of a domain has full control over their own DNS records.  Also, ENS has the ability (through smart contracts) for a domain\u2019s subdomains to be irrevocably assigned to another entity.", "Specification": "The resolver profile to support DNS on ENS follows the resolver specification as defined inERC-137.", "setDNSRecords(bytes32 node, bytes data)": "setDNSRecords()sets, updates or clears 1 or more DNS records for a given node.  It has function signature0x0af179d7.", "clearDNSZone(bytes32 node)": "clearDNSZone()removes all DNS records for the domain.  It has function signature0xad5780af.", "dnsRecords(bytes32 node, bytes32 name, uint16 resource) view returns (bytes)": "dnsRecords()obtains the DNS records for a given node, name and resource.  It has function signature0x2461e851.", "hasDNSRecords(bytes32 node, bytes32 name) view returns (bool)": "hasDNSRecords()reports if there are any records for the provided name in the domain.  It has function signature0x4cbf6ba4.", "Rationale": "DNS is a federated system of naming, and the higher-level entities control availability of everything beneath them (e.g..orgcontrols the availability ofethereum.org).  A decentralized version of DNS would not have this constraint, and allow lookups directly for any domain with relevant records within ENS.", "Backwards Compatibility": "Not applicable.", "Reference Implementation": "The reference implementation of the DNS resolver is as follows:", "Security Considerations": "Security of this solution would be dependent on security of the records within the ENS domain.  This degenenrates to the security of the key(s) which have authority over that domain.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4361, "url": "https://eips.ethereum.org/EIPS/eip-4361", "title": "Sign-In with Ethereum", "authors": ["Wayne Chang\u00a0(", "@wyc", ")", "Gregory Rocco\u00a0(", "@obstropolos", ")", "Brantly Millegan\u00a0(", "@brantlymillegan", ")", "Nick Johnson\u00a0(", "@Arachnid", ")", "Oliver Terbu\u00a0(", "@awoie", ")"], "sections": {"ERC-4361: Sign-In with Ethereum": "Sign-In with Ethereum describes how Ethereum accounts authenticate with off-chain services by signing a standard message format parameterized by scope, session details, and security mechanisms (e.g., a nonce). The goals of this specification are to provide a self-custodied alternative to centralized identity providers, improve interoperability across off-chain services for Ethereum-based authentication, and provide wallet vendors a consistent machine-readable message format to achieve improved user experiences and consent management.", "Off-chain authentication for Ethereum accounts to establish sessions.": "Sign-In with Ethereum describes how Ethereum accounts authenticate with off-chain services by signing a standard message format parameterized by scope, session details, and security mechanisms (e.g., a nonce). The goals of this specification are to provide a self-custodied alternative to centralized identity providers, improve interoperability across off-chain services for Ethereum-based authentication, and provide wallet vendors a consistent machine-readable message format to achieve improved user experiences and consent management.", "Abstract": "Sign-In with Ethereum describes how Ethereum accounts authenticate with off-chain services by signing a standard message format parameterized by scope, session details, and security mechanisms (e.g., a nonce). The goals of this specification are to provide a self-custodied alternative to centralized identity providers, improve interoperability across off-chain services for Ethereum-based authentication, and provide wallet vendors a consistent machine-readable message format to achieve improved user experiences and consent management.", "Motivation": "When signing in to popular non-blockchain services today, users will typically use identity providers (IdPs) that are centralized entities with ultimate control over users\u2019 identifiers, for example, large internet companies and email providers. Incentives are often misaligned between these parties. Sign-In with Ethereum offers a new self-custodial option for users who wish to assume more control and responsibility over their own digital identity.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Overview": "Sign-In with Ethereum (SIWE) works as follows:", "Message Format": "A SIWE Message MUST conform with the following Augmented Backus\u2013Naur Form (ABNF, RFC 5234) expression (note that%sdenotes case sensitivity for a string term, as per RFC 7405).", "Signing and Verifying Messages with Ethereum Accounts": "The following is a RECOMMENDED algorithm for Wallets to conform with the requirements on request origin verification defined by this specification.", "Resolving Ethereum Name Service (ENS) Data": "The following is a RECOMMENDED algorithm for Wallets to conform with the requirements on request origin verification defined by this specification.", "Relying Party Implementer Steps": "The following is a RECOMMENDED algorithm for Wallets to conform with the requirements on request origin verification defined by this specification.", "Wallet Implementer Steps": "The following is a RECOMMENDED algorithm for Wallets to conform with the requirements on request origin verification defined by this specification.", "Rationale": "Write a specification for how Sign-In with Ethereum should work. The specification should be simple and generally follow existing practices. Avoid feature bloat, particularly the inclusion of lesser-used projects who see getting into the specification as a means of gaining adoption. The core specification should be decentralized, open, non-proprietary, and have long-term viability. It should have no dependence on a centralized server except for the servers already being run by the application that the user is signing in to. The basic specification should include: Ethereum accounts used for authentication, ENS names for usernames (via reverse resolution), and data from the ENS name\u2019s text records for additional profile information (e.g. avatar, social media handles, etc).", "Requirements": "Write a specification for how Sign-In with Ethereum should work. The specification should be simple and generally follow existing practices. Avoid feature bloat, particularly the inclusion of lesser-used projects who see getting into the specification as a means of gaining adoption. The core specification should be decentralized, open, non-proprietary, and have long-term viability. It should have no dependence on a centralized server except for the servers already being run by the application that the user is signing in to. The basic specification should include: Ethereum accounts used for authentication, ENS names for usernames (via reverse resolution), and data from the ENS name\u2019s text records for additional profile information (e.g. avatar, social media handles, etc).", "Design Goals": "The following concerns are out of scope for this version of the specification to define:", "Technical Decisions": "The following concerns are out of scope for this version of the specification to define:", "Out of Scope": "The following concerns are out of scope for this version of the specification to define:", "Considerations for Forwards Compatibility": "The following items are considered for future support either through an iteration of this specification or new work items using this specification as a dependency.", "Backwards Compatibility": "A reference implementation is availablehere.", "Reference Implementation": "A reference implementation is availablehere.", "Security Considerations": "There are several cases where an implementer SHOULD check for state changes as they relate to sessions.", "Identifier Reuse": "There are several cases where an implementer SHOULD check for state changes as they relate to sessions.", "Key Management": "There are several cases where an implementer SHOULD check for state changes as they relate to sessions.", "Wallet and Relying Party combined Security": "There are several cases where an implementer SHOULD check for state changes as they relate to sessions.", "Minimizing Wallet and Server Interaction": "There are several cases where an implementer SHOULD check for state changes as they relate to sessions.", "Preventing Replay Attacks": "There are several cases where an implementer SHOULD check for state changes as they relate to sessions.", "Preventing Phishing Attacks": "There are several cases where an implementer SHOULD check for state changes as they relate to sessions.", "Channel Security": "There are several cases where an implementer SHOULD check for state changes as they relate to sessions.", "Session Invalidation": "There are several cases where an implementer SHOULD check for state changes as they relate to sessions.", "Maximum Lengths for ABNF Terms": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4824, "url": "https://eips.ethereum.org/EIPS/eip-4824", "title": "Common Interfaces for DAOs", "authors": ["Joshua Tan\u00a0(", "@thelastjosh", ")", "Isaac Patka\u00a0(", "@ipatka", ")", "Ido Gershtein\u00a0<", "ido@daostack.io", ">", "Eyal Eithcowich\u00a0<", "eyal@deepdao.io", ">", "Michael Zargham\u00a0(", "@mzargham", ")", "Sam Furter\u00a0(", "@nivida", ")"], "sections": {"ERC-4824: Common Interfaces for DAOs": "An API standard for decentralized autonomous organizations (DAOs), focused on relating on-chain and off-chain representations of membership and proposals.", "An API for decentralized autonomous organizations (DAOs).": "An API standard for decentralized autonomous organizations (DAOs), focused on relating on-chain and off-chain representations of membership and proposals.", "Abstract": "An API standard for decentralized autonomous organizations (DAOs), focused on relating on-chain and off-chain representations of membership and proposals.", "Motivation": "DAOs, since being invoked in the Ethereum whitepaper, have been vaguely defined. This has led to a wide range of patterns but little standardization or interoperability between the frameworks and tools that have emerged. Standardization and interoperability are necessary to support a variety of use-cases. In particular, a standard daoURI, similar to tokenURI inERC-721, will enhance DAO discoverability, legibility, proposal simulation, and interoperability between tools. More consistent data across the ecosystem is also a prerequisite for future DAO standards.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Indexing": "If a DAO inherits theIERC4824interface from a 4824-compliant DAO factory, then the DAO factory SHOULD incorporate a call to an indexer contract as part of the DAO\u2019s initialization to enable efficient network indexing. If the DAO isERC-165-compliant, the factory can do this without additional permissions. If the DAO isnotcompliant with ERC-165, the factory SHOULD first obtain access control rights to the indexer contract and then calllogRegistrationdirectly with the address of the new DAO and the daoURI of the new DAO. Note that any user, including the DAO itself, MAY calllogRegistrationand submit a registration for a DAO which inherits theIERC4824interface and which is also ERC-165-compliant.", "Members": "Members JSON-LD Schema. Every contract implementing this EIP SHOULD implement a membersURI pointing to a JSON object satisfying this schema. Below, DID refers toDecentralized Identifiers.", "Proposals": "Proposals JSON-LD Schema. Every contract implementing this EIP SHOULD implement a proposalsURI pointing to a JSON object satisfying this schema.", "Activity Log": "Activity Log JSON-LD Schema. Every contract implementing this EIP SHOULD implement a activityLogURI pointing to a JSON object satisfying this schema.", "Contracts": "Contracts JSON-LD Schema. Every contract implementing this EIP SHOULD implement a contractsURI pointing to a JSON object satisfying this schema.", "URI fields": "The content of subsidiary JSON files MAY be directly embedded as a JSON object directly within the top-level DAO JSON, in which case the relevant field MUST be renamed to remove the \u201cURI\u201d suffix. For example,membersURIwould be renamed tomembers,proposalsURIwould be renamed toproposals, and so on. In all cases, the embedded JSON object MUST conform to the relevant schema. A given field and a URI-suffixed field (e.g.membersURIandmembers) SHOULD NOT appear in the same JSON-LD; if they do, the field without the URI suffix MUST take precedence.", "Entities which are not DAOs": "Entities which are not DAOs or which do not wish to identify as DAOs MAY still publish daoURIs. If so, they SHOULD use a different value for thetypefield than \u201cDAO\u201d, for example \u201cOrganization\u201d, \u201cFoundation\u201d, \u201cPerson\u201d, or, most broadly, \u201cEntity\u201d.", "Rationale": "In this standard, we assume that all DAOs possess at least two primitives:membershipandbehavior.Membershipis defined by a set of addresses.Behavioris defined by a set of possible contract actions, including calls to external contracts and calls to internal functions.Proposalsrelate membership and behavior; they are objects that members can interact with and which, if and when executed, become behaviors of the DAO.", "APIs, URIs, and off-chain data": "DAOs themselves have a number of existing and emerging use-cases. But almost all DAOs need to publish data off-chain for a number of reasons: communicating to and recruiting members, coordinating activities, powering user interfaces and governance applications such as Snapshot or Tally, or enabling search and discovery via platforms like DeepDAO, Messari, and Etherscan. Having a standardized schema for this data organized across multiple URIs, i.e. an API specification, would strengthen existing use-cases for DAOs, help scale tooling and frameworks across the ecosystem, and build support for additional forms of interoperability.", "membersURI": "Approaches to membership vary widely in DAOs. Some DAOs and DAO frameworks (e.g. Gnosis Safe, Tribute), maintain an explicit, on-chain set of members, sometimes called owners or stewards. But many DAOs are structured so that membership status is based on the ownership of a token or tokens (e.g. Moloch, Compound, DAOstack, 1Hive Gardens). In these DAOs, computing the list of current members typically requires some form of off-chain indexing of events.", "proposalsURI": "Proposals have become a standard way for the members of a DAO to trigger on-chain actions, e.g. sending out tokens as part of a grant or executing arbitrary code in an external contract. In practice, however, many DAOs are governed by off-chain decision-making systems on platforms such as Discourse, Discord, or Snapshot, where off-chain proposals may function as signaling mechanisms for an administrator or as a prerequisite for a later on-chain vote. (To be clear, on-chain votes may also serve as non-binding signaling mechanisms or as \u201cbinding\u201d signals leading to some sort of off-chain execution.) The schema we propose is intended to support both on-chain and off-chain proposals, though DAOs themselves may choose to report only on-chain, only off-chain, or some custom mix of proposal types.", "activityLogURI": "The activity log JSON is intended to capture the interplay between a member of a DAO and a given proposal. Examples of activities include the creation/submission of a proposal, voting on a proposal, disputing a proposal, and so on.", "governanceURI": "Membership, to be meaningful, usually implies rights and affordances of some sort, e.g. the right to vote on proposals, the right to ragequit, the right to veto proposals, and so on. But many rights and affordances of membership are realized off-chain (e.g. right to vote on a Snapshot, gated access to a Discord). Instead of trying to standardize these wide-ranging practices or forcing DAOs to locate descriptions of those rights on-chain, we believe that a flatfile represents the easiest and most widely-acceptable mechanism for communicating what membership means and how proposals work. These flatfiles can then be consumed by services such as Etherscan, supporting DAO discoverability and legibility.", "contractsURI": "Over the course of community conversations, multiple parties raised the need to report on, audit, and index the different contracts belonging to a given DAO. Some of these contracts are deployed as part of the modular design of a single DAO framework, e.g. the core, voting, and timelock contracts within Open Zeppelin / Compound Governor. In other cases, a DAO might deploy multiple multsigs as treasuries and/or multiple subDAOs that are effectively controlled by the DAO. contractsURI offers a generic way of declaring these many instruments so that they can be efficiently aggregated by an indexer.", "Why JSON-LD": "We chose to use JSON-LD rather than the more widespread and simpler JSON standard because (1) we want to support use-cases where a DAO wants to include members using some other form of identification than their Ethereum address and (2) we want this standard to be compatible with future multi-chain standards. Either use-case would require us to implement a context and type for addresses, which is already implemented in JSON-LD.", "Community Consensus": "The initial draft standard was developed as part of the DAOstar roundtable series, which included representatives from all major EVM-based DAO frameworks (Aragon, Compound, DAOstack, Gnosis, Moloch, OpenZeppelin, and Tribute), a wide selection of DAO tooling developers, as well as several major DAOs. Thank you to all the participants of the roundtable. We would especially like to thank Fabien of Snapshot, Jake Hartnell, Auryn Macmillan, Selim Imoberdorf, Lucia Korpas, and Mehdi Salehi for their contributions.", "Backwards Compatibility": "Existing contracts that do not wish to use this specification are unaffected. DAOs that wish to adopt the standard without updating or migrating contracts can do so via an external registration contract.", "Security Considerations": "This standard defines the interfaces for the DAO URIs but does not specify the rules under which the URIs are set, or how the data is prepared. Developers implementing this standard should consider how to update this data in a way aligned with the DAO\u2019s governance model, and keep the data fresh in a way that minimizes reliance on centralized service providers.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4973, "url": "https://eips.ethereum.org/EIPS/eip-4973", "title": "Account-bound Tokens", "authors": ["Tim Daubensch\u00fctz\u00a0(", "@TimDaub", ")"], "sections": {"ERC-4973: Account-bound Tokens": "Proposes a standard API for account-bound Tokens (ABT) within smart contracts. An ABT is a non-fungible token bound to a single account. ABTs don\u2019t implement a canonical interface for transfers. This EIP defines basic functionality to mint, assign, revoke and track ABTs.", "An interface for non-transferrable NFTs binding to an Ethereum account like a legendary World of Warcraft item binds to a character.": "Proposes a standard API for account-bound Tokens (ABT) within smart contracts. An ABT is a non-fungible token bound to a single account. ABTs don\u2019t implement a canonical interface for transfers. This EIP defines basic functionality to mint, assign, revoke and track ABTs.", "Abstract": "Proposes a standard API for account-bound Tokens (ABT) within smart contracts. An ABT is a non-fungible token bound to a single account. ABTs don\u2019t implement a canonical interface for transfers. This EIP defines basic functionality to mint, assign, revoke and track ABTs.", "Motivation": "In the popular MMORPG World of Warcraft, its game designers intentionally took some items out of the world\u2019s auction house market system to prevent them from having a publicly-discovered price and limit their accessibility.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Solidity Interface": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "EIP-712Typed Structured Data Hashing and Bytearray Signature Creation": "To invokefunction give(...)andfunction take(...)a bytearray signature must be created usingEIP-712. A tested reference implementation in Node.js is attached atindex.mjs,index_test.mjsandpackage.json. In Solidity, this bytearray signature can be created as follows:", "Rationale": "ABTs shall be maximally backward-compatible but still only expose a minimal and simple to implement interface definition.", "Interface": "ABTs shall be maximally backward-compatible but still only expose a minimal and simple to implement interface definition.", "Exception handling": "Given the non-transferable between accounts property of ABTs, if a user\u2019s keys to an account or a contract get compromised or rotated, a user may lose the ability to associate themselves with the token. In some cases, this can be the desired effect. Therefore, ABT implementers should build re-issuance and revocation processes to enable recourse. We recommend implementing strictly decentralized, permissionless, and censorship-resistant re-issuance processes.", "Provenance Indexing": "ABTs can be indexed by tracking the emission ofevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId). As withERC-721, transfers between two accounts are represented byaddress fromandaddress tobeing non-zero addresses. Unequipping a token is represented through emitting a transfer withaddress tobeing set to the zero address. Mint operations whereaddress fromis set to zero don\u2019t exist. To avoid being spoofed by maliciously-implementedevent Transferemitting contracts, an indexer should ensure that the transaction\u2019s sender is equal toevent Transfer\u2019sfromvalue.", "Backwards Compatibility": "We have adopted theERC-165andERC721Metadatafunctions purposefully to create a high degree of backward compatibility withERC-721. We have deliberately usedERC-721terminology such asfunction ownerOf(...),function balanceOf(...)to minimize the effort of familiarization for ABT implementers already familiar with, e.g.,ERC-20orERC-721. For indexers, we\u2019ve re-used the widely-implementedevent Transferevent signature.", "Reference Implementation": "You can find an implementation of this standard inERC-4973-flat.sol.", "Security Considerations": "There are no security considerations related directly to the implementation of this standard.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5247, "url": "https://eips.ethereum.org/EIPS/eip-5247", "title": "Smart Contract Executable Proposal Interface", "authors": ["Zainan Victor Zhou\u00a0(", "@xinbenlv", ")"], "sections": {"ERC-5247: Smart Contract Executable Proposal Interface": "This EIP presents an interface for \u201csmart contract executable proposals\u201d: proposals that are submitted to, recorded on, and possibly executed on-chain. Such proposals include a series of information about\nfunction calls including the target contract address, ether value to be transmitted, gas limits and calldatas.", "An interface to create and execute proposals.": "This EIP presents an interface for \u201csmart contract executable proposals\u201d: proposals that are submitted to, recorded on, and possibly executed on-chain. Such proposals include a series of information about\nfunction calls including the target contract address, ether value to be transmitted, gas limits and calldatas.", "Abstract": "This EIP presents an interface for \u201csmart contract executable proposals\u201d: proposals that are submitted to, recorded on, and possibly executed on-chain. Such proposals include a series of information about\nfunction calls including the target contract address, ether value to be transmitted, gas limits and calldatas.", "Motivation": "It is oftentimes necessary to separate the code that is to be executed from the actual execution of the code.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "A simple test case can be found as", "Test Cases": "A simple test case can be found as", "Reference Implementation": "A simple reference implementation can be found.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5269, "url": "https://eips.ethereum.org/EIPS/eip-5269", "title": "ERC Detection and Discovery", "authors": ["Zainan Victor Zhou\u00a0(", "@xinbenlv", ")"], "sections": {"ERC-5269: ERC Detection and Discovery": "An interface for better identification and detection of ERC by numbers.\nIt designates a field in which it\u2019s calledmajorERCIdentifierwhich is normally known or referred to as \u201cERC number\u201d. For example,ERC-721akaERC-721has amajorERCIdentifier = 721. This ERC has amajorERCIdentifier = 5269.", "An interface to identify if major behavior or optional behavior specified in an ERC is supported for a given caller.": "An interface for better identification and detection of ERC by numbers.\nIt designates a field in which it\u2019s calledmajorERCIdentifierwhich is normally known or referred to as \u201cERC number\u201d. For example,ERC-721akaERC-721has amajorERCIdentifier = 721. This ERC has amajorERCIdentifier = 5269.", "Abstract": "An interface for better identification and detection of ERC by numbers.\nIt designates a field in which it\u2019s calledmajorERCIdentifierwhich is normally known or referred to as \u201cERC number\u201d. For example,ERC-721akaERC-721has amajorERCIdentifier = 721. This ERC has amajorERCIdentifier = 5269.", "Motivation": "This ERC is created as a competing standard forERC-165.", "Specification": "In the following description, we use ERC and ERC inter-exchangeably. This was because while most of the time the description applies to an ERC category of the Standards Track of ERC, the ERC number space is a subspace of ERC number space and we might sometimes encounter ERCs that aren\u2019t recognized as ERCs but has behavior that\u2019s worthy of a query.", "Rationale": "The pros for (1) are that it automatically supports any evolvement of future ERC numbering/naming conventions.\nBut the cons are it\u2019s not backward readable: seeing ahash(ERC-number)one usually can\u2019t easily guess what their ERC number is.", "Test Cases": "SeeTestERC5269.ts.", "Reference Implementation": "Here is a reference implementation for this ERC:", "Security Considerations": "Similar toERC-165callers of the interface MUST assume the smart contract\ndeclaring they support such ERC interfaces doesn\u2019t necessarily correctly support them.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5289, "url": "https://eips.ethereum.org/EIPS/eip-5289", "title": "Ethereum Notary Interface", "authors": ["Gavin John\u00a0(", "@Pandapip1", ")"], "sections": {"ERC-5289: Ethereum Notary Interface": "Currently, the real-world applications of smart contracts are limited by the fact that they aren\u2019t legally binding. This EIP proposes a standard that allows smart contracts to be legally binding by providing IPFS links to legal documents and ensuring that the users of the smart contract have privity with the relevant legal documents.", "Allows Smart Contracts to be Legally Binding Off-Chain": "Currently, the real-world applications of smart contracts are limited by the fact that they aren\u2019t legally binding. This EIP proposes a standard that allows smart contracts to be legally binding by providing IPFS links to legal documents and ensuring that the users of the smart contract have privity with the relevant legal documents.", "Abstract": "Currently, the real-world applications of smart contracts are limited by the fact that they aren\u2019t legally binding. This EIP proposes a standard that allows smart contracts to be legally binding by providing IPFS links to legal documents and ensuring that the users of the smart contract have privity with the relevant legal documents.", "Motivation": "NFTs have oftentimes been branded as a way to hold and prove copyright of a specific work. However, this, in practice, has almost never been the case. Most of the time, NFTs have no legally-binding meaning, and in the rare cases that do, the NFT simply provides a limited license for the initial holder to use the work (but cannot provide any license for any future holders).", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Legal Contract Library Interface": "To request that certain documents be signed, revert with anERC-5568signal. The format of theinstruction_datais an ABI-encoded(address, uint16)pair, where the address is the address of the library, and theuint16is thedocumentIdof the document:", "Requesting a Signature": "To request that certain documents be signed, revert with anERC-5568signal. The format of theinstruction_datais an ABI-encoded(address, uint16)pair, where the address is the address of the library, and theuint16is thedocumentIdof the document:", "Signing a Document": "When a signature is requested, wallets MUST calllegalDocument, display the resulting document to the user, and prompt them to either sign the document or cancel:", "Rationale": "No backwards compatibility issues found.", "Backwards Compatibility": "No backwards compatibility issues found.", "Reference Implementation": "SeeIERC5289Library,ERC5289Library.", "Legal Contract Library": "SeeIERC5289Library,ERC5289Library.", "Security Considerations": "Users can claim that their private key was stolen and used to fraudulently \u201csign\u201d contracts. As such,documents must only be permissive in nature, not restrictive.For example, a document granting a license to use the image attached to an NFT would be acceptable, as there is no reason for the signer to plausibly deny signing the document.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5568, "url": "https://eips.ethereum.org/EIPS/eip-5568", "title": "Well-Known Format for Required Actions", "authors": ["Gavin John\u00a0(", "@Pandapip1", ")"], "sections": {"ERC-5568: Well-Known Format for Required Actions": "This ERC introduces a minimalistic machine-readable (binary) format to signal to wallets that an action needs to be taken by the user using a well-known function and revert reason. It provides just enough data to be extendable by future ERCs and to take in arbitrary parameters (up to 64 kB of data). Example use cases could include approving a token for an exchange, sending an HTTP request, or requesting the user to rotate their keys after a certain period of time to enforce good hygiene.", "Signal to wallets that an action is needed through a well-known function and revert reason": "This ERC introduces a minimalistic machine-readable (binary) format to signal to wallets that an action needs to be taken by the user using a well-known function and revert reason. It provides just enough data to be extendable by future ERCs and to take in arbitrary parameters (up to 64 kB of data). Example use cases could include approving a token for an exchange, sending an HTTP request, or requesting the user to rotate their keys after a certain period of time to enforce good hygiene.", "Abstract": "This ERC introduces a minimalistic machine-readable (binary) format to signal to wallets that an action needs to be taken by the user using a well-known function and revert reason. It provides just enough data to be extendable by future ERCs and to take in arbitrary parameters (up to 64 kB of data). Example use cases could include approving a token for an exchange, sending an HTTP request, or requesting the user to rotate their keys after a certain period of time to enforce good hygiene.", "Motivation": "Oftentimes, a smart contract needs to signal to a wallet that an action needs to be taken, such as to sign a transaction or send an HTTP request to a URL. Traditionally, this has been done by hard-coding the logic into the frontend, but this ERC allows the smart contract itself to request the action.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Action Detection": "Theinstruction_idof an instruction defined by an ERC MUST be its ERC number unless there are exceptional circumstances (be reasonable). An ERC MUST define exactly zero or oneinstruction_id. The structure of the instruction data for anyinstruction_idMUST be defined by the ERC that defines theinstruction_id.", "Custom Revert Reason": "To signal an action was not taken, a compliant smart contract MUST revert with the following error:", "Responding to a Revert": "Before submitting a transaction to the mempool, thewalletSignal24function MUST be simulated locally. It MUST be treated as if it were a non-viewfunction capable of making state changes (e.g.CALLSto non-viewfunctions are allowed). If the resultinginstruction_idis nonzero, an action needs to be taken.", "Rationale": "This ERC was explicitly optimized for deployment gas cost and simplicity. It is expected that libraries will eventually be developed that makes this more developer-friendly.", "Backwards Compatibility": "SeeRevert Reason Collisions.", "Human-Readable Revert Messages": "SeeRevert Reason Collisions.", "ERC-3668": "ERC-3668 can be used alongside this ERC, but it uses a different mechanism than this ERC.", "Security Considerations": "It is unlikely that the signature of the custom error matches any custom errors in the wild. In the case that it does, no harm is caused unless the data happen to be a valid instruction, which is even more unlikely.", "Revert Reason Collisions": "It is unlikely that the signature of the custom error matches any custom errors in the wild. In the case that it does, no harm is caused unless the data happen to be a valid instruction, which is even more unlikely.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5639, "url": "https://eips.ethereum.org/EIPS/eip-5639", "title": "Delegation Registry", "authors": ["foobar\u00a0(", "@0xfoobar", ")", "Wilkins Chung (@wwhchung)\u00a0<", "wilkins@manifold.xyz", ">", "ryley-o\u00a0(", "@ryley-o", ")", "Jake Rockland\u00a0(", "@jakerockland", ")", "andy8052\u00a0(", "@andy8052", ")"], "sections": {"ERC-5639: Delegation Registry": "This EIP describes the details of the Delegation Registry, a proposed protocol and ABI definition that provides the ability to link one or more delegate wallets to a vault wallet in a manner which allows the linked delegate wallets to prove control and asset ownership of the vault wallet.", "Delegation of permissions for safer and more convenient signing operations.": "This EIP describes the details of the Delegation Registry, a proposed protocol and ABI definition that provides the ability to link one or more delegate wallets to a vault wallet in a manner which allows the linked delegate wallets to prove control and asset ownership of the vault wallet.", "Abstract": "This EIP describes the details of the Delegation Registry, a proposed protocol and ABI definition that provides the ability to link one or more delegate wallets to a vault wallet in a manner which allows the linked delegate wallets to prove control and asset ownership of the vault wallet.", "Motivation": "Proving ownership of an asset to a third party application in the Ethereum ecosystem is common. Users frequently sign payloads of data to authenticate themselves before gaining access to perform some operation. However, this method\u2013akin to giving the third party root access to one\u2019s main wallet\u2013is both insecure and inconvenient.", "Problems with existing methods and solutions": "Unfortunately, we\u2019ve seen many cases where users have accidentally signed a malicious payload. The result is almost always a significant loss of assets associated with the delegate address.", "Proposal: Use of a Delegation Registry": "This proposal aims to provide a mechanism which allows a vault wallet to grant wallet, contract or token level permissions to a delegate wallet. This would achieve a safer and more convenient way to sign and authenticate, and provide \u2018read only\u2019 access to a vault wallet via one or more secondary wallets.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Checking Delegation": "A dApp or smart contract would check whether or not a delegate is authenticated for a vault by checking the return value of checkDelegateForAll.", "Rationale": "In order to support a wide range of delegation use cases, the proposed specification allows a vault to delegate all assets it controls, assets of a specific contract, or a specific token. This ensures that a vault has fine grained control over the security of their assets, and allows for emergent behavior around granting third party wallets limited access only to assets relevant to them.", "Allowing for vault, contract or token level delegation": "In order to support a wide range of delegation use cases, the proposed specification allows a vault to delegate all assets it controls, assets of a specific contract, or a specific token. This ensures that a vault has fine grained control over the security of their assets, and allows for emergent behavior around granting third party wallets limited access only to assets relevant to them.", "On-chain enumeration": "In order to support ease of integration and adoption, this specification has chosen to include on-chain enumeration of delegations and incur the additional gas cost associated with supporting enumeration. On-chain enumeration allows for dApp frontends to identify the delegations that any connected wallet has access to, and can provide UI selectors.", "Security Considerations": "The core purpose of this EIP is to enhance security and promote a safer way to authenticate wallet control and asset ownership when the main wallet is not needed and assets held by the main wallet do not need to be moved. Consider it a way to do \u2018read only\u2019 authentication.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5982, "url": "https://eips.ethereum.org/EIPS/eip-5982", "title": "Role-based Access Control", "authors": ["Zainan Victor Zhou\u00a0(", "@xinbenlv", ")"], "sections": {"ERC-5982: Role-based Access Control": "This EIP defines an interface for role-based access control for smart contracts. Roles are defined asbyte32. The interface specifies how to read, grant, create and destroy roles. It specifies the sense of role power in the format of its ability to call a given method\nidentified bybytes4method selector. It also specifies how metadata of roles are represented.", "An interface for role-based access control for smart contracts.": "This EIP defines an interface for role-based access control for smart contracts. Roles are defined asbyte32. The interface specifies how to read, grant, create and destroy roles. It specifies the sense of role power in the format of its ability to call a given method\nidentified bybytes4method selector. It also specifies how metadata of roles are represented.", "Abstract": "This EIP defines an interface for role-based access control for smart contracts. Roles are defined asbyte32. The interface specifies how to read, grant, create and destroy roles. It specifies the sense of role power in the format of its ability to call a given method\nidentified bybytes4method selector. It also specifies how metadata of roles are represented.", "Motivation": "There are many ways to establish access control for privileged actions. One common pattern is \u201crole-based\u201d access control, where one or more users are assigned to one or more \u201croles,\u201d which grant access to privileged actions. This pattern is more secure and flexible than ownership-based access control since it allows for many people to be granted permissions according to the principle of least privilege.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "Needs discussion.", "Backwards Compatibility": "Needs discussion.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6065, "url": "https://eips.ethereum.org/EIPS/eip-6065", "title": "Real Estate Token", "authors": ["Alex\u00a0(", "@Alex-Klasma", ")", "Ben Fusek\u00a0(", "@bfusek", ")", "Daniel Fallon-Cyr\u00a0(", "@dfalloncyr", ")"], "sections": {"ERC-6065: Real Estate Token": "This proposal introduces an open structure for physical real estate and property to exist on the blockchain. This standard builds off ofERC-721, adding important functionality necessary for representing real world assets such as real estate. The three objectives this standard aims to meet are: universal transferability of the NFT, private property rights attached to the NFT, and atomic transfer of property rights with the transfer of the NFT. The token contains a hash of the operating agreement detailing the NFT holder\u2019s legal right to the property, unique identifiers for the property, a debt value and foreclosure status, and a manager address.", "An interface for real estate NFTs that extends ERC-721": "This proposal introduces an open structure for physical real estate and property to exist on the blockchain. This standard builds off ofERC-721, adding important functionality necessary for representing real world assets such as real estate. The three objectives this standard aims to meet are: universal transferability of the NFT, private property rights attached to the NFT, and atomic transfer of property rights with the transfer of the NFT. The token contains a hash of the operating agreement detailing the NFT holder\u2019s legal right to the property, unique identifiers for the property, a debt value and foreclosure status, and a manager address.", "Abstract": "This proposal introduces an open structure for physical real estate and property to exist on the blockchain. This standard builds off ofERC-721, adding important functionality necessary for representing real world assets such as real estate. The three objectives this standard aims to meet are: universal transferability of the NFT, private property rights attached to the NFT, and atomic transfer of property rights with the transfer of the NFT. The token contains a hash of the operating agreement detailing the NFT holder\u2019s legal right to the property, unique identifiers for the property, a debt value and foreclosure status, and a manager address.", "Motivation": "Real estate is the largest asset class in the world. By tokenizing real estate, barriers to entry are lowered, transaction costs are minimized, information asymmetry is reduced, ownership structures become more malleable, and a new building block for innovation is formed. However, in order to tokenize this asset class, a common standard is needed that accounts for its real world particularities while remaining flexible enough to adapt to various jurisdictions and regulatory environments.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Token Components:": "This EIP inherits the ERC-721 NFT token standard for all transfer and approval logic. All transfer and approval functions are inherited from this token standard without changes. Additionally, this EIP also inherits the ERC-721 Metadata standards for name, symbol, and metadata URI lookup. This allows an NFT under this EIP to become interoperable with preexisting NFT exchanges and services, however, some care must be taken. Please refer toBackwards CompatibilityandSecurity Considerations.", "Interfaces": "This EIP inherits the ERC-721 NFT token standard for all transfer and approval logic. All transfer and approval functions are inherited from this token standard without changes. Additionally, this EIP also inherits the ERC-721 Metadata standards for name, symbol, and metadata URI lookup. This allows an NFT under this EIP to become interoperable with preexisting NFT exchanges and services, however, some care must be taken. Please refer toBackwards CompatibilityandSecurity Considerations.", "Rationale": "Real world assets operate in messy, non-deterministic environments. Because of this, validating the true state of an asset can be murky, expensive, or time-consuming. For example, in the U.S., change of property ownership is usually recorded at the County Recorder\u2019s office, sometimes using pen and paper. It would be infeasible to continuously update this manual record every time an NFT transaction occurs on the blockchain. Additionally, since real world property rights are enforced by the court of law, it is essential that property ownership be documented in such a way that courts are able to interpret and enforce ownership if necessary.", "Introduction": "Real world assets operate in messy, non-deterministic environments. Because of this, validating the true state of an asset can be murky, expensive, or time-consuming. For example, in the U.S., change of property ownership is usually recorded at the County Recorder\u2019s office, sometimes using pen and paper. It would be infeasible to continuously update this manual record every time an NFT transaction occurs on the blockchain. Additionally, since real world property rights are enforced by the court of law, it is essential that property ownership be documented in such a way that courts are able to interpret and enforce ownership if necessary.", "Guiding Objectives": "We have designed this EIP to achieve three primary objectives necessary for creating an NFT representation of physical real estate:", "operatingAgreementHashOf": "An immutable hash of the legal document issued by the legal entity that owns the property. The agreement is unique and contains the rights, terms, and conditions for the specific property represented by the NFT. The hash of the agreement attached to the NFT must be immutable to ensure the legitimacy and enforceability of these rights in the future for integrators or transferees. Upon transfer of the NFT, these legal rights are immediately enforceable by the new owner. For changes to the legal structure or rights and conditions with regard to the property the original token must be burned and a new token with the new hash must be minted.", "Property Unique Identifiers": "The following unique identifiers of the property are contained within the NFT and are immutable:", "debtOf": "A readable value of debt and denoted currency that is accrued to the property. A positive balance signifies a debt against the property, while a negative balance signifies a credit which can be claimed by the NFT owner. This is a way for the property administrator to charge the NFT holder for any necessary payments towards the property, like property tax, or other critical repairs or maintenance in the \u201creal world\u201d. A credit might be given to the NFT holder via this same function, perhaps the administrator and the NFT holder had worked out a property management or tenancy revenue-sharing agreement.", "managerOf": "A readable Ethereum address that can be granted a right to action on the property without being the underlying owner of the NFT.", "Backwards Compatibility": "This EIP is backwards compatible with ERC-721. However, it is important to note that there are potential implementation considerations to take into account before any smart contract integration. SeeSecurity Considerationsfor more details.", "Reference Implementation": "Klasma Labs offers a work in progressreference implementation. The technical implementation includes the following additional components for reference, this implementation is not required.", "Legal Structure Implementation": "This section explains the legal structure and implementation a company may employ as an Administrator of this token. The structure detailed below is specific to property tokenization in the U.S. in the 2023 regulatory environment.", "Security Considerations": "The following are checks and recommendations for protocols integrating NFTs under this standard. These are of particular relevance to applications which lend against any asset utilizing this standard.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6120, "url": "https://eips.ethereum.org/EIPS/eip-6120", "title": "Universal Token Router", "authors": ["Derion\u00a0(", "@derion-io", ")", "Zergity\u00a0(", "@Zergity", ")", "Ngo Quang Anh\u00a0(", "@anhnq82", ")", "BerlinP\u00a0(", "@BerlinP", ")", "Khanh Pham\u00a0(", "@blackskin18", ")", "Hal Blackburn\u00a0(", "@h4l", ")"], "sections": {"ERC-6120: Universal Token Router": "ETH is designed withtransfer-and-callas the default behavior in a transaction. Unfortunately,ERC-20is not designed with that pattern in mind and newer standards cannot apply to the token contracts that have already been deployed.", "A single router contract enables tokens to be sent to application contracts in the transfer-and-call pattern instead of approve-then-call.": "ETH is designed withtransfer-and-callas the default behavior in a transaction. Unfortunately,ERC-20is not designed with that pattern in mind and newer standards cannot apply to the token contracts that have already been deployed.", "Abstract": "ETH is designed withtransfer-and-callas the default behavior in a transaction. Unfortunately,ERC-20is not designed with that pattern in mind and newer standards cannot apply to the token contracts that have already been deployed.", "Motivation": "When users approve their tokens to a contract, they trust that:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Output Verification": "Outputdefines the expected token balance change for verification.", "Action": "Actiondefines the token inputs and the contract call.", "Input": "Inputdefines the input token to transfer or prepare before the action contract is executed.", "Native Token Tranfer": "TheUTRSHOULD have areceive()function for user execution logic that requires transferring ETH in. Themsg.valuetransferred into the router can be spent in multiple inputs across different actions. While the caller takes full responsibility for the movement ofETHin and out of the router, theexecfunction SHOULD refund any remainingETHbefore the function ends.", "Usage Examples": "Legacy function:", "Rationale": "ThePermittype signature is not supported since the purpose of the Universal Token Router is to eliminate all interactiveapprovesignatures for new tokens, andmostfor old tokens.", "Backwards Compatibility": "Old token contracts (ERC-20, ERC-721 and ERC-1155) require approval for the Universal Token Router once for each account.", "Tokens": "Old token contracts (ERC-20, ERC-721 and ERC-1155) require approval for the Universal Token Router once for each account.", "Applications": "The only application contractsINCOMPATIBLEwith the UTR are contracts that usemsg.senderas the beneficiary address in their internal storage without any function for ownership transfer.", "Reference Implementation": "A reference implementation by Derion Labs and audited by Hacken.", "Security Considerations": "Token contracts mustNEVERsupport the ERC-165 interface with the ID0x61206120, as it is reserved for non-token contracts to be called with the UTR. Any token with the interface ID0x61206120approved to the UTR can be spent by anyone, without any restrictions.", "ERC-165 Tokens": "Token contracts mustNEVERsupport the ERC-165 interface with the ID0x61206120, as it is reserved for non-token contracts to be called with the UTR. Any token with the interface ID0x61206120approved to the UTR can be spent by anyone, without any restrictions.", "Reentrancy": "Tokens transferred to the UTR contract will be permanently lost, as there is no way to transfer them out. Applications that require an intermediate address to hold tokens should use their own Helper contract with a reentrancy guard for secure execution.", "Discard Payment": "The result of thepayfunction can be checked by querying the balance after the call, allowing the UTR contract to be called in a trustless manner. However, due to the inability to verify the execution of thediscardfunction, it should only be used with a trusted UTR contract.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6224, "url": "https://eips.ethereum.org/EIPS/eip-6224", "title": "Contracts Dependencies Registry", "authors": ["Artem Chystiakov\u00a0(", "@arvolear", ")"], "sections": {"ERC-6224: Contracts Dependencies Registry": "This EIP introduces an on-chain registry system that a decentralized protocol may use to manage its smart contracts.", "A registry for managing smart contracts with their dependencies.": "This EIP introduces an on-chain registry system that a decentralized protocol may use to manage its smart contracts.", "Abstract": "This EIP introduces an on-chain registry system that a decentralized protocol may use to manage its smart contracts.", "Motivation": "In the ever-growing Ethereum ecosystem, projects tend to become more and more complex. Modern protocols require portability and agility to satisfy customer needs by continuously delivering new features and staying on pace with the industry. However, the requirement is hard to achieve due to the immutable nature of blockchains and smart contracts. Moreover, the increased complexity and continuous delivery bring bugs and entangle the dependencies between the contracts, making systems less supportable.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Overview": "The system consists of two smart contracts:", "ContractsRegistry": "TheContractsRegistryis the main contract of the proposed system. It MUST store the references to every standalone contract used within a protocol. TheContractRegistryMAY be configured to deploy a proxy contract of choice on top of the registered contracts.", "Dependant": "TheContractsRegistryworks together with theDependantcontract. Every standalone contract of a protocol MUST inheritDependantin order to support the dependency injection mechanism.", "Rationale": "There are a few design decisions that have to be explicitly specified:", "ContractsRegistry Rationale": "Thestringcontracts identifier is chosen over theuint256andbytes32to maintain code readability and reduce the human error chances when interacting with theContractsRegistry. Being the topmost smart contract of a protocol, it MAY be typical for the users to interact with it via block explorers or DAOs. Clarity was prioritized over gas usage.", "Dependant Rationale": "Thedataparameter is provided to carry additional application-specific context. It MAY be used to extend the method\u2019s behavior.", "Reference Implementation": "It is crucial for the owner ofContractsRegistryto keep their keys in a safe place. The loss/leakage of credentials to theContractsRegistrywill lead to the application\u2019s point of no return. TheContractRegistryis a cornerstone of a protocol, access must be granted to the trusted parties only.", "ContractsRegistry Implementation": "It is crucial for the owner ofContractsRegistryto keep their keys in a safe place. The loss/leakage of credentials to theContractsRegistrywill lead to the application\u2019s point of no return. TheContractRegistryis a cornerstone of a protocol, access must be granted to the trusted parties only.", "Dependant Implementation": "It is crucial for the owner ofContractsRegistryto keep their keys in a safe place. The loss/leakage of credentials to theContractsRegistrywill lead to the application\u2019s point of no return. TheContractRegistryis a cornerstone of a protocol, access must be granted to the trusted parties only.", "Security Considerations": "It is crucial for the owner ofContractsRegistryto keep their keys in a safe place. The loss/leakage of credentials to theContractsRegistrywill lead to the application\u2019s point of no return. TheContractRegistryis a cornerstone of a protocol, access must be granted to the trusted parties only.", "ContractsRegistry Security": "Copyright and related rights waived viaCC0.", "Dependant Security": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6315, "url": "https://eips.ethereum.org/EIPS/eip-6315", "title": "ERC-2771 Namespaced Account Abstraction", "authors": ["Gavin John\u00a0(", "@Pandapip1", ")"], "sections": {"ERC-6315: ERC-2771 Namespaced Account Abstraction": "ERC-2771is a prevalent standard for handling meta-transactions via trusted forwarders. This EIP proposes an extension toERC-2771to introduce a namespacing mechanism, facilitating trustless account abstraction through per-forwarder namespaced addresses.", "Introducing per-forwarder namespaced addresses to facilitate meta-transactions under a namespacing framework": "ERC-2771is a prevalent standard for handling meta-transactions via trusted forwarders. This EIP proposes an extension toERC-2771to introduce a namespacing mechanism, facilitating trustless account abstraction through per-forwarder namespaced addresses.", "Abstract": "ERC-2771is a prevalent standard for handling meta-transactions via trusted forwarders. This EIP proposes an extension toERC-2771to introduce a namespacing mechanism, facilitating trustless account abstraction through per-forwarder namespaced addresses.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Namespaced Forwarder Interface": "Upon function invocation on a Recipient, the Recipient MUST execute aSTATICCALLto theisNamespacedTransaction()method of the caller. If this operation reverts or returns the boolean valuefalse, the transaction MUST proceed normally, identifying the caller as the sender, and the Forwarder as the zero address. However, if the boolean valuetrueis returned, the transaction is acknowledged as a namespaced transaction, with the sender identified using the procedure outlined inERC-2771, and the Forwarder identified as the caller.", "Determining the Sender and Forwarder": "Upon function invocation on a Recipient, the Recipient MUST execute aSTATICCALLto theisNamespacedTransaction()method of the caller. If this operation reverts or returns the boolean valuefalse, the transaction MUST proceed normally, identifying the caller as the sender, and the Forwarder as the zero address. However, if the boolean valuetrueis returned, the transaction is acknowledged as a namespaced transaction, with the sender identified using the procedure outlined inERC-2771, and the Forwarder identified as the caller.", "Recipient Extensions": "Whenever a Recipient contract has a function with one or more function parameters of type address, it MUST also provide a new function, mirroring the name of the original function but appendingNamespacedat the end, which accepts two addresses instead. The initial address denotes the Forwarder, while the latter represents the address managed by that Forwarder. If a function accepts multiple address parameters (e.g.,ERC-20\u2019stransferFrom), a version of the function accepting two addresses per original address parameter MUST be provided. The original function MUST exhibit identical behavior to the new function when Forwarder addresses are the zero address.", "Rationale": "The approach of simply augmenting existing EIP functions with newaddressparameters, rather than crafting new interfaces for the most commonly used EIPs, is employed to ensure broader applicability of this namespacing proposal.", "Backwards Compatibility": "Contracts already deployed cannot not benefit from this namespacing proposal. This limitation also extends to ERC-2771.", "Using this EIP in standards": "When using this EIP in another standard, both the original and the Namespaced interface IDs SHOULD be provided. Interfaces MUST NOT include namespaced versions of functions in their interfaces.", "Security Considerations": "This proposal alters trust dynamics: Forwarders no longer require Recipient trust, but instead require the trust of their users.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- revert: All calls to this opcode must emit a log with revert data.\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests"}
{"eip": 6358, "url": "https://eips.ethereum.org/EIPS/eip-6358", "title": "Cross-Chain Token States Synchronization", "authors": ["Shawn Zheng\u00a0(", "@xiyu1984", ")", "Jason Cheng\u00a0<", "chengjingxx@gmail.com", ">", "George Huang\u00a0(", "@virgil2019", ")", "Kay Lin\u00a0(", "@kay404", ")"], "sections": {"ERC-6358: Cross-Chain Token States Synchronization": "This ERC standardizes an interface for contract-layer consensus-agnostic verifiable cross-chain bridging, through which we can define a new global token inherited fromERC-20/ERC-721over multi-chains.", "A paradigm to synchronize token states over multiple existing public chains": "This ERC standardizes an interface for contract-layer consensus-agnostic verifiable cross-chain bridging, through which we can define a new global token inherited fromERC-20/ERC-721over multi-chains.", "Abstract": "This ERC standardizes an interface for contract-layer consensus-agnostic verifiable cross-chain bridging, through which we can define a new global token inherited fromERC-20/ERC-721over multi-chains.", "Figure.1 Architecture": "", "Motivation": "The core of this ERC is synchronization instead of transferring, even if all the other chains break down, as long as Ethereum is still running, user\u2019s assets will not be lost.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Omniverse Account": "In the simplest implementation, we can just build two mappings to get it. One is likepk based on sece256k1 => account address in the special environment, and the other is the reverse mapping.", "Data Structure": "An Omniverse Transaction (o-transactionfor short) MUST be described with the following data structure:", "Smart Contract Interface": "As shown inFigure.1, smart contracts deployed on multi-chains executeo-transactionsof ERC-6358 tokens synchronously through the trustless off-chain synchronizers.", "Rationale": "As shown inFigure.1, smart contracts deployed on multi-chains executeo-transactionsof ERC-6358 tokens synchronously through the trustless off-chain synchronizers.", "Architecture": "As shown inFigure.1, smart contracts deployed on multi-chains executeo-transactionsof ERC-6358 tokens synchronously through the trustless off-chain synchronizers.", "Principle": "In the simplest implementation, we can just build two mappings to get it. One is likepk based on sece256k1 => account address in the special environment, and the other is the reverse mapping.", "Reference Implementation": "In the simplest implementation, we can just build two mappings to get it. One is likepk based on sece256k1 => account address in the special environment, and the other is the reverse mapping.", "ERC-6358 Token": "The ERC-6358 Token could be implemented with theinterfaces mentioned above. It can also be used with the combination ofERC-20/ERC-721.", "Security Considerations": "According to the above, there are two roles:", "Attack Vector Analysis": "According to the above, there are two roles:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6366, "url": "https://eips.ethereum.org/EIPS/eip-6366", "title": "Permission Token", "authors": ["Chiro\u00a0(", "@chiro-hiro", ")", "Victor Dusart\u00a0(", "@vdusart", ")"], "sections": {"ERC-6366: Permission Token": "This EIP offers an alternative to Access Control Lists (ACLs) for granting authorization and enhancing security. Auint256is used to store permission of given address in a ecosystem. Each permission is represented by a single bit in auint256as described inERC-6617. Bitwise operators and bitmasks are used to determine the access right which is much more efficient and flexible thanstringorkeccak256comparison.", "A token that holds the permission of an address in an ecosystem": "This EIP offers an alternative to Access Control Lists (ACLs) for granting authorization and enhancing security. Auint256is used to store permission of given address in a ecosystem. Each permission is represented by a single bit in auint256as described inERC-6617. Bitwise operators and bitmasks are used to determine the access right which is much more efficient and flexible thanstringorkeccak256comparison.", "Abstract": "This EIP offers an alternative to Access Control Lists (ACLs) for granting authorization and enhancing security. Auint256is used to store permission of given address in a ecosystem. Each permission is represented by a single bit in auint256as described inERC-6617. Bitwise operators and bitmasks are used to determine the access right which is much more efficient and flexible thanstringorkeccak256comparison.", "Motivation": "Special roles likeOwner,Operator,Manager,Validatorare common for many smart contracts because permissioned addresses are used to administer and manage them. It is difficult to audit and maintain these system since these permissions are not managed in a single smart contract.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Core Interface": "Compliant contracts MUST implementIEIP6366Core.", "Metadata Interface": "It is RECOMMENDED for compliant contracts to implement the optional extensionIEIP6617Meta.", "Error Interface": "Compatible tokens MAY implementIEIP6366Erroras defined below:", "Rationale": "Needs discussion.", "Reference Implementation": "First implementation could be found here:", "Security Considerations": "Need more discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6372, "url": "https://eips.ethereum.org/EIPS/eip-6372", "title": "Contract clock", "authors": ["Hadrien Croubois\u00a0(", "@Amxx", ")", "Francisco Giordano\u00a0(", "@frangio", ")"], "sections": {"ERC-6372: Contract clock": "Many contracts rely on some clock for enforcing delays and storing historical data. While some contracts rely on block numbers, others use timestamps. There is currently no easy way to discover which time-tracking function a contract internally uses. This EIP proposes to standardize an interface for contracts to expose their internal clock and thus improve composability and interoperability.", "An interface for exposing a contract's clock value and details": "Many contracts rely on some clock for enforcing delays and storing historical data. While some contracts rely on block numbers, others use timestamps. There is currently no easy way to discover which time-tracking function a contract internally uses. This EIP proposes to standardize an interface for contracts to expose their internal clock and thus improve composability and interoperability.", "Abstract": "Many contracts rely on some clock for enforcing delays and storing historical data. While some contracts rely on block numbers, others use timestamps. There is currently no easy way to discover which time-tracking function a contract internally uses. This EIP proposes to standardize an interface for contracts to expose their internal clock and thus improve composability and interoperability.", "Motivation": "Many contracts check or store time-related information. For example, timelock contracts enforce a delay before an operation can be executed. Similarly, DAOs enforce a voting period during which stakeholders can approve or reject a proposal. Last but not least, voting tokens often store the history of voting power using timed snapshots.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Methods": "This function returns the current timepoint according to the mode the contract is operating on. It MUST be anon-decreasingfunction of the chain, such asblock.timestamporblock.number.", "Expected properties": "clockreturnsuint48as it is largely sufficient for storing realistic values. In timestamp mode,uint48will be enough until the year 8921556. Even in block number mode, with 10,000 blocks per second, it would be enough until the year 2861. Using a type smaller thanuint256allows storage packing of timepoints with other associated values, greatly reducing the cost of writing and reading from storage.", "Rationale": "clockreturnsuint48as it is largely sufficient for storing realistic values. In timestamp mode,uint48will be enough until the year 8921556. Even in block number mode, with 10,000 blocks per second, it would be enough until the year 2861. Using a type smaller thanuint256allows storage packing of timepoints with other associated values, greatly reducing the cost of writing and reading from storage.", "Security Considerations": "No known security issues.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6551, "url": "https://eips.ethereum.org/EIPS/eip-6551", "title": "Non-fungible Token Bound Accounts", "authors": ["Jayden Windle\u00a0(", "@jaydenwindle", ")", "Benny Giang\u00a0<", "bg@futureprimitive.xyz", ">", "Steve Jang", "Druzy Downs\u00a0(", "@druzydowns", ")", "Raymond Huynh\u00a0(", "@huynhr", ")", "Alanah Lam\u00a0<", "alanah@futureprimitive.xyz", ">", "Wilkins Chung (@wwhchung)\u00a0<", "wilkins@manifold.xyz", ">", "Paul Sullivan (@sullivph)\u00a0<", "paul.sullivan@manifold.xyz", ">", "Auryn Macmillan\u00a0(", "@auryn-macmillan", ")", "Jan-Felix Schwarz\u00a0(", "@jfschwarz", ")", "Anton Bukov\u00a0(", "@k06a", ")", "Mikhail Melnik\u00a0(", "@ZumZoom", ")", "Josh Weintraub (@jhweintraub)\u00a0<", "jhweintraub@gmail.com", ">", "Rob Montgomery (@RobAnon)\u00a0<", "rob@revest.finance", ">", "vectorized\u00a0(", "@vectorized", ")", "V\u00edctor Mart\u00ednez\u00a0(", "@vnmrtz", ")", "Adri\u00e1n Pajares\u00a0(", "@0xadrii", ")"], "sections": {"ERC-6551: Non-fungible Token Bound Accounts": "This proposal defines a system which assigns Ethereum accounts to all non-fungible tokens. These token bound accounts allow NFTs to own assets and interact with applications, without requiring changes to existing smart contracts or infrastructure.", "An interface and registry for smart contract accounts owned by non-fungible tokens": "This proposal defines a system which assigns Ethereum accounts to all non-fungible tokens. These token bound accounts allow NFTs to own assets and interact with applications, without requiring changes to existing smart contracts or infrastructure.", "Abstract": "This proposal defines a system which assigns Ethereum accounts to all non-fungible tokens. These token bound accounts allow NFTs to own assets and interact with applications, without requiring changes to existing smart contracts or infrastructure.", "Motivation": "TheERC-721standard enabled an explosion of non-fungible token applications. Some notable use cases have included breedable cats, generative artwork, and exchange liquidity positions.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Overview": "The system outlined in this proposal has two main components:", "Registry": "The registry is a singleton contract that serves as the entry point for all token bound account address queries. It has two functions:", "Account Interface": "All token bound accounts SHOULD be created via the singleton registry.", "Execution Interface": "All token bound accounts MUST implement an execution interface which allows valid signers to execute arbitrary operations on behalf of the account. Support for an execution interface MUST be signaled by the account using ERC-165 interface detection.", "Rationale": "This proposal specifies a single, canonical registry that can be permissionlessly deployed to any chain at a known address. It purposefully does not specify a common interface that can be implemented by multiple registry contracts. This approach enables several critical properties.", "Singleton Registry": "This proposal specifies a single, canonical registry that can be permissionlessly deployed to any chain at a known address. It purposefully does not specify a common interface that can be implemented by multiple registry contracts. This approach enables several critical properties.", "Registry vs Factory": "The term \u201cregistry\u201d was chosen instead of \u201cfactory\u201d to highlight the canonical nature of the contract and emphasize the act of querying account addresses (which occurs regularly) over the creation of accounts (which occurs only once per account).", "Variable Execution Interface": "This proposal does not require accounts to implement a specific execution interface in order to be compatible, so long as they signal support for at least one execution interface via ERC-165 interface detection. Allowing account developers to choose their own execution interface allows this proposal to support the wide variety of existing execution interfaces and maintain forward compatibility with likely future standardized interfaces.", "Account Ambiguity": "The specification proposed above allows NFTs to have multiple token bound accounts. During the development of this proposal, alternative architectures were considered which would have assigned a single token bound account to each NFT, making each token bound account address an unambiguous identifier.", "Proxy Implementation": "ERC-1167 minimal proxies are well supported by existing infrastructure and are a common smart contract pattern. This proposal deploys each token bound account using a custom ERC-1167 proxy implementation that stores the salt, chain id, token contract address, and token ID as ABI-encoded constant data appended to the contract bytecode. This allows token bound account implementations to easily query this data while ensuring it remains constant. This approach was taken to maximize compatibility with existing infrastructure while also giving smart contract developers full flexibility when creating custom token bound account implementations.", "Chain Identifier": "This proposal uses the chain ID to identify each NFT along with its contract address and token ID. Token identifiers are globally unique on a single Ethereum chain, but may not be unique across multiple Ethereum chains.", "Backwards Compatibility": "This proposal seeks to be maximally backwards compatible with existing non-fungible token contracts. As such, it does not extend the ERC-721 standard.", "Reference Implementation": "In order to enable trustless sales of token bound accounts, decentralized marketplaces will need to implement safeguards against fraudulent behavior by malicious account owners.", "Example Account Implementation": "In order to enable trustless sales of token bound accounts, decentralized marketplaces will need to implement safeguards against fraudulent behavior by malicious account owners.", "Registry Implementation": "In order to enable trustless sales of token bound accounts, decentralized marketplaces will need to implement safeguards against fraudulent behavior by malicious account owners.", "Security Considerations": "In order to enable trustless sales of token bound accounts, decentralized marketplaces will need to implement safeguards against fraudulent behavior by malicious account owners.", "Fraud Prevention": "In order to enable trustless sales of token bound accounts, decentralized marketplaces will need to implement safeguards against fraudulent behavior by malicious account owners.", "Ownership Cycles": "All assets held in a token bound account may be rendered inaccessible if an ownership cycle is created. The simplest example is the case of an ERC-721 token being transferred to its own token bound account. If this occurs, both the ERC-721 token and all of the assets stored in the token bound account would be permanently inaccessible, since the token bound account is incapable of executing a transaction which transfers the ERC-721 token.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6596, "url": "https://eips.ethereum.org/EIPS/eip-6596", "title": "Cultural and Historical Asset Token", "authors": ["Phillip Pon\u00a0<", "phillip@artifactlabs.com", ">", "Gary Liu\u00a0<", "gary@artifactlabs.com", ">", "Henry Chan\u00a0<", "henry@artifactlabs.com", ">", "Joey Liu\u00a0<", "joey@artifactlabs.com", ">", "Lauren Ho\u00a0<", "lauren@artifactlabs.com", ">", "Jeff Leung\u00a0<", "jeff@artifactlabs.com", ">", "Brian Liang\u00a0<", "brian@artifactlabs.com", ">", "Joyce Li\u00a0<", "joyce@artifactlabs.com", ">", "Avir Mahtani\u00a0<", "avir@artifactlabs.com", ">", "Antoine Cote\u00a0(", "@acote88", ")", "David Leung\u00a0(", "@dhl", ")"], "sections": {"ERC-6596: Cultural and Historical Asset Token": "This EIP proposes the establishment of a comprehensive metadata standard for Cultural and Historical Asset Tokens\n(CHATs) on the Ethereum platform. These tokens represent cultural and historical assets such as artwork, artifacts,\ncollectibles, and rare items, providing crucial context and provenance to substantiate their significance and value.", "Metadata extension to enhance the discoverability, connectivity, and collectability of culturally and historically significant NFTs.": "This EIP proposes the establishment of a comprehensive metadata standard for Cultural and Historical Asset Tokens\n(CHATs) on the Ethereum platform. These tokens represent cultural and historical assets such as artwork, artifacts,\ncollectibles, and rare items, providing crucial context and provenance to substantiate their significance and value.", "Abstract": "This EIP proposes the establishment of a comprehensive metadata standard for Cultural and Historical Asset Tokens\n(CHATs) on the Ethereum platform. These tokens represent cultural and historical assets such as artwork, artifacts,\ncollectibles, and rare items, providing crucial context and provenance to substantiate their significance and value.", "Motivation": "Preserving context and significance- Provenance and context are crucial for cultural and historical assets. The\nCHAT standard captures and preserves the provenance and history of these assets, as well as the changing contexts that\nemerge from new knowledge and information. This context and provenance substantiate the significance and value of\ncultural and historical assets.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT\nRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Cultural and Historical Asset Metadata Extension TypeScript Interface": "The following TypeScript interface defines the Metadata JSON Schema compatible tokens must conform to:", "Rationale": "Both theERC-721andERC-1155provide natural extension points in the metadata JSON\nfile associated with NFTs to supply enriched datasets about the underlying assets.", "Choosing to Extend Off-Chain Metadata JSON Schema over On-Chain Interface": "Both theERC-721andERC-1155provide natural extension points in the metadata JSON\nfile associated with NFTs to supply enriched datasets about the underlying assets.", "Capturing Attributes Extensions inattributesandattributesExtproperties": "In the design of the Cultural and Historical Asset Token (CHAT) metadata extension, we have made a deliberate choice to\ncapture the metadata attributes between two main properties:attributesandattributesExt. This division serves\ntwo distinct purposes while ensuring maximum compatibility with existing NFT galleries and marketplaces.", "Backwards Compatibility": "This EIP is fully backward compatible withERC-721andERC-1155.", "Security Considerations": "NFT platforms and systems working with Cultural and Historical Asset Metadata JSON files are recommended to treat the\nfiles as client-supplied data and follow the appropriate best practices for processing such data.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6617, "url": "https://eips.ethereum.org/EIPS/eip-6617", "title": "Bit Based Permission", "authors": ["Chiro\u00a0(", "@chiro-hiro", ")", "Victor Dusart\u00a0(", "@vdusart", ")"], "sections": {"ERC-6617: Bit Based Permission": "This EIP offers a standard for building a bit-based permission and role system. Each permission is represented by a single bit. By using anuint256, up to $256$ permissions and $2^{256}$ roles can be defined. We are able to specify the importance of each permission based on the order of the bits.", "A permission and role system based on bits": "This EIP offers a standard for building a bit-based permission and role system. Each permission is represented by a single bit. By using anuint256, up to $256$ permissions and $2^{256}$ roles can be defined. We are able to specify the importance of each permission based on the order of the bits.", "Abstract": "This EIP offers a standard for building a bit-based permission and role system. Each permission is represented by a single bit. By using anuint256, up to $256$ permissions and $2^{256}$ roles can be defined. We are able to specify the importance of each permission based on the order of the bits.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Metadata Interface": "It is RECOMMENDED for compliant contracts to implement the optional extensionIEIP6617Meta.", "Rationale": "Currently permission and access control is performed using a single owner (ERC-173) or withbytes32roles (ERC-5982).\nHowever, using bitwise and bitmask operations allows for greater gas-efficiency and flexibility.", "Gas cost efficiency": "Bitwise operations are very cheap and fast. For example, doing anANDbitwise operation on a permission bitmask is significantly cheaper than calling any number ofLOADopcodes.", "Flexibility": "With the 256 bits of theuint256, we can create up to 256 different permissions which leads to $2^{256}$ unique combinations (a.k.a. roles).(A role is a combination of multiple permissions).Not all roles have to be predefined.", "Ordering permissions by importance": "We can use the most significant bit to represent the most important permission, the comparison between permissions can then be done easily since they all areuint256s.", "Associate a meaning": "Compared with access control managed via ERC-5982, this EIP does not provide a direct and simple understanding of the meaning of a permission or role.", "Reference Implementation": "First implementation could be found here:", "Security Considerations": "No security considerations.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6734, "url": "https://eips.ethereum.org/EIPS/eip-6734", "title": "L2 Token List", "authors": ["Kelvin Fichter\u00a0(", "@smartcontracts", ")", "Andreas Freund\u00a0(", "@Therecanbeonlyone1969", ")", "Pavel Sinelnikov\u00a0(", "@psinelnikov", ")"], "sections": {"ERC-6734: L2 Token List": "The document describes a JSON token list that ensures that two or more Layer 1, Layer 2, or Sidechains can identify tokens from a different Layer 1, Layer 2, or Sidechain.", "Token List that ensures the correct identification of tokens from different Layer 1, Layer 2, or Sidechains.": "The document describes a JSON token list that ensures that two or more Layer 1, Layer 2, or Sidechains can identify tokens from a different Layer 1, Layer 2, or Sidechain.", "Abstract": "The document describes a JSON token list that ensures that two or more Layer 1, Layer 2, or Sidechains can identify tokens from a different Layer 1, Layer 2, or Sidechain.", "Motivation": "This particular work by the L2 WG of the EEA Communities Projects managed by OASIS, an open-source initiative, is motivated by a significant challenge around the definition and listing of tokens on Layer 1 (L1), Layer 2 (L2), and Sidechain systems. Note that for simplicity, this document we will collectively refer to L1, L2 and Sidechain systems as chains below since the challenge described below is valid across all such systems:", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in [RFC2119] when, and only when, they appear in all capitals, as shown here.", "Keywords:": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in [RFC2119] when, and only when, they appear in all capitals, as shown here.", "Typographical Convention: Requirement Ids": "A requirement is uniquely identified by a unique ID composed of its requirement level followed by a requirement number, as per convention[RequirementLevelRequirementNumber]. \nThere are four requirement levels that are coded in requirement ids as per below convention:", "Conformance": "This section describes the conformance clauses and tests required to achieve an implementation that is provably conformant with the requirements in this document.", "Rationale": "This specification is extending and clarifying current custom lists such as from Arbitrum and Optimism as referenced in theMotivationor the Uniswap Tokenlist Project to improve clarity, security and encourage adoption by non-Web3 native entities.", "Security Considerations": "There are no additional security requirements apart from the warnings that URIs utilized in implementations of this standard might be direct to malicious resources such as websites, and that implementers should ensure that data utilized for a canonical token list is secure and correct. Since this standard is focused on a data schema and its data properties there are no additional security considerations from for example homoglyph attacks (seeCVE-2021-42574 (2021-10-25T12:38:28)).", "Security Considerations: Data Privacy": "The standard does not set any requirements for compliance to jurisdiction legislation/regulations. It is the responsibility of the implementer to comply with applicable data privacy laws.", "Security Considerations: Production Readiness": "The standard does not set any requirements for the use of specific applications/tools/libraries etc. The implementer should perform due diligence when selecting specific applications/tools/libraries.", "Security Considerations: Internationalization and Localization": "The standard encourages implementers to follow theW3C \u201cStrings on the Web: Language and Direction Metadata\u201d best practices guidefor identifying language and base direction for strings used on the Web wherever appropriate.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6735, "url": "https://eips.ethereum.org/EIPS/eip-6735", "title": "L2 Aliasing of EVM-based Addresses", "authors": ["Kelvin Fichter\u00a0(", "@smartcontracts", ")", "Andreas Freund\u00a0(", "@Therecanbeonlyone1969", ")"], "sections": {"ERC-6735: L2 Aliasing of EVM-based Addresses": "The document describes the minimal set of business and technical prerequisites, functional and non-functional requirements for Aliasing of EVM based Addresses that when implemented ensures that two or more Layer 1, Layer 2, or Sidechains can identify and translate EVM based addresses from different Layer 1, Layer 2, or Sidechains.", "Identify and translate EVM-based addresses from different Layer 1, Layer 2, or Sidechains": "The document describes the minimal set of business and technical prerequisites, functional and non-functional requirements for Aliasing of EVM based Addresses that when implemented ensures that two or more Layer 1, Layer 2, or Sidechains can identify and translate EVM based addresses from different Layer 1, Layer 2, or Sidechains.", "Abstract": "The document describes the minimal set of business and technical prerequisites, functional and non-functional requirements for Aliasing of EVM based Addresses that when implemented ensures that two or more Layer 1, Layer 2, or Sidechains can identify and translate EVM based addresses from different Layer 1, Layer 2, or Sidechains.", "Motivation": "The members of the L2 WG of the EEA Communities Project managed by OASIS have recognized that the ability to deterministically derive addresses of a digital asset or an externally owned account (EOA) in EVM based execution frameworks for L1s, L2s, Sidechains based on an origin chain of an asset or EOA, known as address aliasing, simplifies interoperability between EVM based L1s, L2s, and Sidechains because:", "Specification": "A requirement is uniquely identified by a unique ID composed of its requirement level followed by a requirement number, as per convention[RequirementLevelRequirementNumber]. \nThere are four requirement levels that are coded in requirement ids as per below convention:", "Typographical Convention: Requirement Ids": "A requirement is uniquely identified by a unique ID composed of its requirement level followed by a requirement number, as per convention[RequirementLevelRequirementNumber]. \nThere are four requirement levels that are coded in requirement ids as per below convention:", "Conformance": "This section describes the conformance clauses and tests required to achieve an implementation that is provably conformant with the requirements in this document.", "Rationale": "The standard follows an already existing approach for address aliasing from Ethereum (L1) to EVM-based L2s such as Arbitrum and Optimism and between L2s, and extends and generalizes it to allow aliasing across any type of EVM-based network irrespective of the network type \u2013 L1, L2 or higher layer networks.", "Security Considerations": "The standard does not set any requirements for compliance to jurisdiction legislation/regulations. It is the responsibility of the implementer to comply with applicable data privacy laws.", "Data Privacy": "The standard does not set any requirements for compliance to jurisdiction legislation/regulations. It is the responsibility of the implementer to comply with applicable data privacy laws.", "Production Readiness": "The standard does not set any requirements for the use of specific applications/tools/libraries etc. The implementer should perform due diligence when selecting specific applications/tools/libraries.", "Internationalization and Localization": "Given the non-language specific features of EVM-based address aliasing, there are no internationalization/localization considerations.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6909, "url": "https://eips.ethereum.org/EIPS/eip-6909", "title": "Minimal Multi-Token Interface", "authors": ["JT Riley\u00a0(", "@jtriley-eth", ")", "Dillon\u00a0(", "@d1ll0n", ")", "Sara\u00a0(", "@snreynolds", ")", "Vectorized\u00a0(", "@Vectorized", ")", "Neodaoist\u00a0(", "@neodaoist", ")"], "sections": {"ERC-6909: Minimal Multi-Token Interface": "The following specifies a multi-token contract as a simplified alternative to theERC-1155Multi-Token Standard. In contrast to ERC-1155, callbacks and batching have been removed from the interface and the permission system is a hybrid operator-approval scheme for granular and scalable permissions. Functionally, the interface has been reduced to the bare minimum required to manage multiple tokens under the same contract.", "A minimal specification for managing multiple tokens by their id in a single contract.": "The following specifies a multi-token contract as a simplified alternative to theERC-1155Multi-Token Standard. In contrast to ERC-1155, callbacks and batching have been removed from the interface and the permission system is a hybrid operator-approval scheme for granular and scalable permissions. Functionally, the interface has been reduced to the bare minimum required to manage multiple tokens under the same contract.", "Abstract": "The following specifies a multi-token contract as a simplified alternative to theERC-1155Multi-Token Standard. In contrast to ERC-1155, callbacks and batching have been removed from the interface and the permission system is a hybrid operator-approval scheme for granular and scalable permissions. Functionally, the interface has been reduced to the bare minimum required to manage multiple tokens under the same contract.", "Motivation": "The ERC-1155 standard includes unnecessary features such as requiring recipient accounts with code to implement callbacks returning specific values and batch-calls in the specification. In addition, the single operator permission scheme grants unlimited allowance on every token ID in the contract. Backwards compatibility is deliberately removed only where necessary. Additional features such as batch calls, increase and decrease allowance methods, and other user experience improvements are deliberately omitted in the specification to minimize the required external interface.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Definitions": "The totalamountof a tokenidthat anownerowns.", "Methods": "The totalamountof a tokenidthat anownerowns.", "Events": "Thecallerinitiates a transfer of anamountof a tokenidfrom asenderto areceiver.", "Interface ID": "The interface ID is0x0f632fb3.", "Metadata Extension": "Thenamefor a tokenid.", "Content URI Extension": "TheURIfor the contract.", "Token Supply Extension": "ThetotalSupplyfor a tokenid.", "Rationale": "While the \u201coperator model\u201d from the ERC-1155 standard allows an account to set another account as an operator, giving full permissions to transfer any amount of any token id on behalf of the owner, this may not always be the desired permission scheme. The \u201callowance model\u201d fromERC-20allows an account to set an explicit amount of the token that another account can spend on the owner\u2019s behalf. This standard requires both be implemented, with the only modification being to the \u201callowance model\u201d where the token id must be specified as well. This allows an account to grant specific approvals to specific token ids, infinite approvals to specific token ids, or infinite approvals to all token ids.", "Granular Approvals": "While the \u201coperator model\u201d from the ERC-1155 standard allows an account to set another account as an operator, giving full permissions to transfer any amount of any token id on behalf of the owner, this may not always be the desired permission scheme. The \u201callowance model\u201d fromERC-20allows an account to set an explicit amount of the token that another account can spend on the owner\u2019s behalf. This standard requires both be implemented, with the only modification being to the \u201callowance model\u201d where the token id must be specified as well. This allows an account to grant specific approvals to specific token ids, infinite approvals to specific token ids, or infinite approvals to all token ids.", "Removal of Batching": "While batching operations is useful, its place should not be in the standard itself, but rather on a case-by-case basis. This allows for different tradeoffs to be made in terms of calldata layout, which may be especially useful for specific applications such as roll-ups that commit calldata to global storage.", "Removal of Required Callbacks": "Requiring callbacks unnecessarily encumbers implementors that either have no particular use case for callbacks or prefer a bespoke callback mechanism. Minimization of such requirements saves contract size, gas efficiency and complexity.", "Removal of \u201cSafe\u201d Naming": "ThesafeTransferandsafeTransferFromnaming conventions are misleading, especially in the context of the ERC-1155 and ERC-721 standards, as they require external calls to receiver accounts with code, passing the execution flow to an arbitrary contract, provided the receiver contract returns a specific value. The combination of removing mandatory callbacks and removing the word \u201csafe\u201d from all method names improves the safety of the control flow by default.", "Backwards Compatibility": "This is not backwards compatible with ERC-1155 as some methods are removed. However, wrappers can be implemented for the ERC-20, ERC-721, and ERC-1155 standards.", "Reference Implementation": "The specification includes two token transfer permission systems, the \u201callowance\u201d and \u201coperator\u201d\nmodels. There are two security considerations in regards to delegating permission to transfer.", "Security Considerations": "The specification includes two token transfer permission systems, the \u201callowance\u201d and \u201coperator\u201d\nmodels. There are two security considerations in regards to delegating permission to transfer.", "Approvals and Operators": "The specification includes two token transfer permission systems, the \u201callowance\u201d and \u201coperator\u201d\nmodels. There are two security considerations in regards to delegating permission to transfer.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6956, "url": "https://eips.ethereum.org/EIPS/eip-6956", "title": "Asset-bound Non-Fungible Tokens", "authors": ["Thomas Bergmueller\u00a0(", "@tbergmueller", ")", "Lukas Meyer\u00a0(", "@ibex-technology", ")"], "sections": {"ERC-6956: Asset-bound Non-Fungible Tokens": "This standard allows integrating physical and digital ASSETS without signing capabilities into dApps/web3 by extendingERC-721.", "Asset-bound NFTs anchor a token 1-1 to an asset and operations are authorized through oracle-attestation of control over the asset": "This standard allows integrating physical and digital ASSETS without signing capabilities into dApps/web3 by extendingERC-721.", "Abstract": "This standard allows integrating physical and digital ASSETS without signing capabilities into dApps/web3 by extendingERC-721.", "Motivation": "The well-knownERC-721establishes that NFTs may represent \u201cownership over physical properties [\u2026] as well as digital collectables and even more abstract things such as responsibilities\u201d - in a broader sense, we will refer to all those things as ASSETS, which typically have value to people.", "The Problem": "ERC-721 outlines that \u201cNFTs can represent ownership over digital or physical assets\u201d. ERC-721 excels in this task when used to represent ownership over digital, on-chain assets, that is when the asset is \u201cholding a token of a specific contract\u201d or the asset is an NFT\u2019s metadata. Today, people commonly treat an NFT\u2019s metadata (images, traits, \u2026) as asset-class, with their rarity often directly defining the value of an individual NFT.", "ASSET-BOUND NON-FUNGIBLE TOKENS": "In this standard we propose to", "Related work": "We primarily aim to onboard physical or digital ASSETS into dApps, which do not signing-capabilities of their own (contrary to other proposals relying on crypto-chips). Note that we do not see any restrictions preventing to use such solutions in combination with this standard, as the address of the crypto-chip qualifies as an ANCHOR.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Definitions (alphabetical)": "Every contract compliant to this standard MUST implement thethe proposed standard interface,ERC-721andERC-165interfaces and is subject toCaveatsbelow:", "Base Interface": "Every contract compliant to this standard MUST implement thethe proposed standard interface,ERC-721andERC-165interfaces and is subject toCaveatsbelow:", "ORACLE": "A Minimal Typescript sample to generate an ATTESTATION is available in theReference Implementation sectionof this proposal.", "AttestationLimited-Interface": "Every contract compliant to this standard MAY implement theproposed AttestationLimited interfaceand is subject toCaveatsbelow:", "Floatable-Interface": "Every contract compliant to this extension MAY implement the proposedFloatable interfaceand is subject toCaveatsbelow:", "ValidAnchors-Interface": "Every contract compliant to this extension MAY implement the proposedValidAnchors interfaceand is subject toCaveatsbelow:", "Rationale": "Why do you use an anchor<>tokenId mapping and not simply use tokenIds directly?Especially for collectable use-cases, special or sequential tokenIds (for example low numbers), have value. Holders may be proud to have claimed tokenId=1 respectively the off-chain ASSET with tokenId=1 may increase in value, because it was the first ever claimed. Or an Issuer may want to address the first 100 owners who claimed their ASSET-BOUND NFT. While these use-cases technically can certainly be covered by observing the blockchain state-changes, we consider reflecting the order in the tokenIds to be the user-friendly way. Please referSecurity considerationson why sequential anchors shall be avoided.", "Example Use Cases and recommended combination of interfaces": "Possession based use cases are covered by the standard interfaceIERC6956: The holder of ASSET is in possession of ASSET. Possession is an important social and economical tool: In many sports games possession of ASSET, commonly referred to as \u201cthe ball\u201d, is of essence. Possession can come with certain obligations and privileges. Ownership over an ASSET can come with rights and benefits as well as being burdened with liens and obligations. For example, an owned ASSET can be used for collateral, can be rented or can even yield a return. Example use-cases are", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "Test cases are available:", "Reference Implementation": "If the asset is stolen, does this mean the thief has control over the NFT?Yes.The standard aims to anchor an NFT to the asset inseperably and unconditionally. This includes reflecting theft, as the ORACLE will testify that PROOF-OF-CONTROL over the ASSET is established. The ORACLE does not testify whether the controller is the legitimate owner,\nNote that this may even be a benefit. If the thief (or somebody receiving the asset from the thief) should interact with the anchor, an on-chain address of somebody connected to the crime (directly or another victim) becomes known. This can be a valuable starting point for investigation.\nAlso note that the proposed standard can be combined with any lock-mechanism, which could lock attestation-based action temporarily or permanently (after mint).", "Security Considerations": "If the asset is stolen, does this mean the thief has control over the NFT?Yes.The standard aims to anchor an NFT to the asset inseperably and unconditionally. This includes reflecting theft, as the ORACLE will testify that PROOF-OF-CONTROL over the ASSET is established. The ORACLE does not testify whether the controller is the legitimate owner,\nNote that this may even be a benefit. If the thief (or somebody receiving the asset from the thief) should interact with the anchor, an on-chain address of somebody connected to the crime (directly or another victim) becomes known. This can be a valuable starting point for investigation.\nAlso note that the proposed standard can be combined with any lock-mechanism, which could lock attestation-based action temporarily or permanently (after mint).", "Security Considerations for PHYSICAL ASSETS": "In case the ASSET is a physical object, good or property, the following ADDITIONAL specifications MUST be satisfied:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6997, "url": "https://eips.ethereum.org/EIPS/eip-6997", "title": "ERC-721 with transaction validation step.", "authors": ["Eduard L\u00f3pez i Fina\u00a0(", "@eduardfina", ")"], "sections": {"ERC-6997: ERC-721 with transaction validation step.": "This standard is an extension ofERC-721. It defines new validation functionality to avoid wallet draining: everytransferorapprovewill be locked waiting for validation.", "A new validation step for transfer and approve calls, achieving a security step in case of stolen wallet.": "This standard is an extension ofERC-721. It defines new validation functionality to avoid wallet draining: everytransferorapprovewill be locked waiting for validation.", "Abstract": "This standard is an extension ofERC-721. It defines new validation functionality to avoid wallet draining: everytransferorapprovewill be locked waiting for validation.", "Motivation": "The power of the blockchain is at the same time its weakness: giving the user full responsibility for their data.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Contract Interface": "TheisValidatorContract()function MUST be implemented aspublic.", "Rationale": "The standard only defines the validation functions, but not how they should be used. It defines the validations as internal and lets the user decide how to manage them.", "Universality": "The standard only defines the validation functions, but not how they should be used. It defines the validations as internal and lets the user decide how to manage them.", "Extensibility": "This standard only defines the validation function, but does not define the system with which it has to be validated. A third-party protocol can define how it wants to call these functions as it wishes.", "Backwards Compatibility": "This standard is an extension ofERC-721, compatible with all the operations excepttransferFrom/safeTransferFrom/approve/setApprovalForAll.", "Reference Implementation": "As is defined in the Specification the operations that change the ownership of an NFT or enable an approval to manage the NFT SHALL create aTransferValidationor anApprovalValidationpending to be validated and SHALL NOT transfer the ownership of an NFT or enable an approval.", "Security Considerations": "As is defined in the Specification the operations that change the ownership of an NFT or enable an approval to manage the NFT SHALL create aTransferValidationor anApprovalValidationpending to be validated and SHALL NOT transfer the ownership of an NFT or enable an approval.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7015, "url": "https://eips.ethereum.org/EIPS/eip-7015", "title": "NFT Creator Attribution", "authors": ["indreams\u00a0(", "@strollinghome", ")"], "sections": {"ERC-7015: NFT Creator Attribution": "This Ethereum Improvement Proposal aims to solve the issue of creator attribution for Non-Fungible Token (NFT) standards (ERC-721,ERC-1155). To achieve this, this EIP proposes a mechanism where the NFT creator signs the required parameters for the NFT creation, including the NFT metadata in a hash along with any other relevant information. The signed parameters and the signature are then validated and emitted during the deployment transaction, which allows the NFT to validate the creator and NFT platforms to attribute creatorship correctly. This method ensures that even if a different wallet sends the deployment transaction, the correct account is attributed as the creator.", "Extending NFTs with cryptographically secured creator attribution.": "This Ethereum Improvement Proposal aims to solve the issue of creator attribution for Non-Fungible Token (NFT) standards (ERC-721,ERC-1155). To achieve this, this EIP proposes a mechanism where the NFT creator signs the required parameters for the NFT creation, including the NFT metadata in a hash along with any other relevant information. The signed parameters and the signature are then validated and emitted during the deployment transaction, which allows the NFT to validate the creator and NFT platforms to attribute creatorship correctly. This method ensures that even if a different wallet sends the deployment transaction, the correct account is attributed as the creator.", "Abstract": "This Ethereum Improvement Proposal aims to solve the issue of creator attribution for Non-Fungible Token (NFT) standards (ERC-721,ERC-1155). To achieve this, this EIP proposes a mechanism where the NFT creator signs the required parameters for the NFT creation, including the NFT metadata in a hash along with any other relevant information. The signed parameters and the signature are then validated and emitted during the deployment transaction, which allows the NFT to validate the creator and NFT platforms to attribute creatorship correctly. This method ensures that even if a different wallet sends the deployment transaction, the correct account is attributed as the creator.", "Motivation": "Current NFT platforms assume that the wallet deploying the smart contract is the creator of the NFT, leading to a misattribution in cases where a different wallet sends the deployment transaction. This happens often when working with smart wallet accounts, and new contract deployment strategies such as the first collector deploying the NFT contract. This proposal aims to solve the problem by allowing creators to sign the parameters required for NFT creation so that any wallet can send the deployment transaction with an signal in a verifiable way who is the creator.", "Specification": "The keywords \u201cMUST,\u201d \u201cMUST NOT,\u201d \u201cREQUIRED,\u201d \u201cSHALL,\u201d \u201cSHALL NOT,\u201d \u201cSHOULD,\u201d \u201cSHOULD NOT,\u201d \u201cRECOMMENDED,\u201d \u201cMAY,\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Reference Implementation": "By standardizing theCreatorAttributionevent, this EIP enables platforms to ascertain creator attribution without relying on implicit assumptions. Establishing a standard for creator attribution empowers platforms to manage the complex aspects of deploying contracts while preserving accurate onchain creator information. This approach ensures a more reliable and transparent method for identifying NFT creators, fostering trust among participants in the NFT ecosystem.", "Rationale": "By standardizing theCreatorAttributionevent, this EIP enables platforms to ascertain creator attribution without relying on implicit assumptions. Establishing a standard for creator attribution empowers platforms to manage the complex aspects of deploying contracts while preserving accurate onchain creator information. This approach ensures a more reliable and transparent method for identifying NFT creators, fostering trust among participants in the NFT ecosystem.", "Backwards Compatibility": "Since the standard requires an event to be emitted during the NFTs deployment transaction, existing NFTs cannot implement this standard.", "Security Considerations": "A potential attack exploiting this proposal could involve deceiving creators into signing creator attribution consent messages unintentionally. Consequently, creators MUST ensure that all signature fields correspond to the necessary ones before signing.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7144, "url": "https://eips.ethereum.org/EIPS/eip-7144", "title": "ERC-20 with transaction validation step.", "authors": ["Eduard L\u00f3pez i Fina\u00a0(", "@eduardfina", ")"], "sections": {"ERC-7144: ERC-20 with transaction validation step.": "This standard is an extension ofERC-20. It defines new validation functionality to avoid wallet draining: everytransferorapprovewill be locked waiting for validation.", "A new validation step for transfer and approve calls, achieving a security step in case of stolen wallet.": "This standard is an extension ofERC-20. It defines new validation functionality to avoid wallet draining: everytransferorapprovewill be locked waiting for validation.", "Abstract": "This standard is an extension ofERC-20. It defines new validation functionality to avoid wallet draining: everytransferorapprovewill be locked waiting for validation.", "Motivation": "The power of the blockchain is at the same time its weakness: giving the user full responsibility for their data.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Contract Interface": "TheisValidatorContract()function MUST be implemented aspublic.", "Rationale": "The standard only defines the validation functions, but not how they should be used. It defines the validations as internal and lets the user decide how to manage them.", "Universality": "The standard only defines the validation functions, but not how they should be used. It defines the validations as internal and lets the user decide how to manage them.", "Extensibility": "This standard only defines the validation function, but does not define the system with which it has to be validated. A third-party protocol can define how it wants to call these functions as it wishes.", "Backwards Compatibility": "This standard is an extension ofERC-20, compatible with all the operations excepttransfer/transferFrom/approve.", "Reference Implementation": "As is defined in the Specification the operations that change the ownership of Tokens or enable an approval to manage the Tokens SHALL create aTransferValidationor anApprovalValidationpending to be validated and SHALL NOT transfer the Tokens or enable an approval.", "Security Considerations": "As is defined in the Specification the operations that change the ownership of Tokens or enable an approval to manage the Tokens SHALL create aTransferValidationor anApprovalValidationpending to be validated and SHALL NOT transfer the Tokens or enable an approval.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7417, "url": "https://eips.ethereum.org/EIPS/eip-7417", "title": "Token Converter", "authors": ["Dexaran (@Dexaran)\u00a0<", "dexaran@ethereumclassic.org", ">"], "sections": {"ERC-7417: Token Converter": "There are multiple token standards on Ethereum chain currently. This EIP introduces a concept of cross-standard interoperability by creating a service that allowsERC-20tokens to be upgraded toERC-223tokens anytime.ERC-223tokens can be converted back toERC-20version without any restrictions to avoid any problems with backwards compatibility and allow different standards to co-exist and become interoperable and interchangeable.", "Smart-contract service that converts token of one ERC version to another": "There are multiple token standards on Ethereum chain currently. This EIP introduces a concept of cross-standard interoperability by creating a service that allowsERC-20tokens to be upgraded toERC-223tokens anytime.ERC-223tokens can be converted back toERC-20version without any restrictions to avoid any problems with backwards compatibility and allow different standards to co-exist and become interoperable and interchangeable.", "Abstract": "There are multiple token standards on Ethereum chain currently. This EIP introduces a concept of cross-standard interoperability by creating a service that allowsERC-20tokens to be upgraded toERC-223tokens anytime.ERC-223tokens can be converted back toERC-20version without any restrictions to avoid any problems with backwards compatibility and allow different standards to co-exist and become interoperable and interchangeable.", "Motivation": "This proposal introduces a concept of a token standard upgrading procedure driven by a specialized smart-contract which can convert tokens of one standard to another at any time.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Token Converter": "Returns the address of theERC-20wrapper for a given token address. Returns0x0if there is noERC-20version for the provided token address. There can be exactly one wrapper for any givenERC-223token address created by the Token Converter contract.", "ConvertingERC-20tokens toERC-223": "In order to convertERC-20tokens toERC-223the token holder should:", "ConvertingERC-223wrapper tokens back toERC-20": "In order to convertERC-20tokens toERC-223the token holder should:", "Rationale": "Two methods of implementing a Token Converter service were considered: (1) a converter that can only createERC-223versions of the existingERC-20tokens, and (2) a converter that can create both versions (ERC-20andERC-223) of any original token.", "Support ofERC-223original tokens": "Two methods of implementing a Token Converter service were considered: (1) a converter that can only createERC-223versions of the existingERC-20tokens, and (2) a converter that can create both versions (ERC-20andERC-223) of any original token.", "Support ofapprove&transferFromfunctions in theERC-223wrapper tokens": "This functions are superfluous for aERC-223token since thetransferfunction can be used to deposit tokens of this standard to contracts. The current ecosystem is built forERC-20tokens however and there are plenty of multisig contracts that rely on accepting tokens deposited without any callback with an assumption that it is not necessary for a multisig to count the amount of tokens it stores.", "Modified transfer events of theERC-223token": "The pureERC-223token implementation has the following event emitted on a token transfer:event Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data). This events are different from ones emitted byERC-20tokens and may not be properly recognized by existing blockchain explorers, wallets and other services that browse token transfers history.", "standard()function usage for the introspection": "The main existing method of introspection is currentlyERC-165which inspects the signatures of functions implemented in a contract. It is not possible to differentiate anERC-20token from anERC-223token by just browsing functions that they implement without digging their internal logic.", "Backwards Compatibility": "This proposal is supposed to eliminate the backwards compatibility concerns for different token standards making them interchangeable and interoperable.", "Reference Implementation": "Copyright and related rights waived viaCC0.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7531, "url": "https://eips.ethereum.org/EIPS/eip-7531", "title": "Staked ERC-721 Ownership Recognition", "authors": ["Francesco Sullo\u00a0(", "@sullof", ")"], "sections": {"ERC-7531: Staked ERC-721 Ownership Recognition": "The ownership ofERC-721tokens when staked in a pool presents challenges, particularly when it involves older, non-lockable NFTs like, for example, Crypto Punks or Bored Ape Yacht Club (BAYC) tokens. This proposal introduces an interface to address these challenges by allowing staked NFTs to be recognized by their original owners, even after they\u2019ve been staked.", "Recognizing NFT ownership when staked into other contracts.": "The ownership ofERC-721tokens when staked in a pool presents challenges, particularly when it involves older, non-lockable NFTs like, for example, Crypto Punks or Bored Ape Yacht Club (BAYC) tokens. This proposal introduces an interface to address these challenges by allowing staked NFTs to be recognized by their original owners, even after they\u2019ve been staked.", "Abstract": "The ownership ofERC-721tokens when staked in a pool presents challenges, particularly when it involves older, non-lockable NFTs like, for example, Crypto Punks or Bored Ape Yacht Club (BAYC) tokens. This proposal introduces an interface to address these challenges by allowing staked NFTs to be recognized by their original owners, even after they\u2019ve been staked.", "Motivation": "Recent solutions involve retaining NFT ownership while \u201clocking\u201d an NFT letting the owner keeping its ownership. However, this requires the NFT contract to implement lockable functionality. Early NFTs were not originally designed as lockable and so they must be staked transferring the ownership to the staking contract.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Timing of Event Emission:": "TheRightsHolderChangeevent MUST be emitted either in the same block as the correspondingTransferevent or in any subsequent block. This approach offers flexibility for existing pools to upgrade their systems without compromising past compatibility. Specifically, staking pools can emit this event for all previously staked tokens, or they can allow users to actively reclaim their ownership. This flexibility ensures that the system can adapt to both current and future states while accurately reflecting the actual ownership of held tokens.", "Invalidation of PreviousRightsHolderChangeEvents:": "To maintain compatibility with the broader ecosystem and optimize for gas efficiency, any newTransferevent involving the same token invalidates any previousRightsHolderChangeevent. This approach ensures that the most recentTransferevent reliably reflects the current ownership status, negating the need for additional events upon unstaking.", "NFT extension": "The two default rights are:", "Rationale": "Non-lockable NFTs present a unique challenge in decentralized ecosystems, especially in scenarios involving staking or delegating usage rights. The standardERC-721ownerOffunction returns the current owner of the NFT, which, in the case of staking, would be the staking pool contract. This transfer of ownership to the staking pool, even if temporary, can disrupt the utility or privileges tied to the NFT, such as participation in governance, access to exclusive content, or utility within a specific ecosystem.", "Addressing Non-Lockable NFT Challenges:": "Non-lockable NFTs present a unique challenge in decentralized ecosystems, especially in scenarios involving staking or delegating usage rights. The standardERC-721ownerOffunction returns the current owner of the NFT, which, in the case of staking, would be the staking pool contract. This transfer of ownership to the staking pool, even if temporary, can disrupt the utility or privileges tied to the NFT, such as participation in governance, access to exclusive content, or utility within a specific ecosystem.", "TherightsHolderOfMethod:": "TherightsHolderOfmethod provides a solution to this challenge. By maintaining a record of the original owner or the rightful holder of certain privileges associated with the NFT, this method ensures that the underlying utility of the NFT is preserved, even when the NFT itself is held in a pool.", "Technical Advantages:": "While this approach introduces a layer of complexity, it also comes with the need for diligent implementation to prevent misuse, such as the wrongful assignment of rights. This EIP outlines security considerations and best practices to mitigate such risks.", "Addressing Potential Misuse:": "While this approach introduces a layer of complexity, it also comes with the need for diligent implementation to prevent misuse, such as the wrongful assignment of rights. This EIP outlines security considerations and best practices to mitigate such risks.", "Backwards Compatibility": "This standard is fully backwards compatible with existingERC-721contracts. It can seamlessly integrate with existing upgradeable staking pools, provided they choose to adopt it. It does not require changes to theERC-721standard but acts as an enhancement for staking pools.", "Security Considerations": "A potential risk with this interface is the improper assignment of ownership by a staking pool to a different wallet. This could allow that wallet to access privileges associated with the NFT, which might not be intended by the true owner. However, it is important to note that this risk is lower than transferring full legal ownership of the NFT to the staking pool, as the interface only enables recognizing the staker, not replacing the actual owner on-chain.", "Event Authenticity:": "There is a concern regarding the potential emission of fakeRightsHolderChangeevents. Since any contract can emit such an event, there\u2019s a risk of misinformation or misrepresentation of ownership. It is crucial for entities listening to theRightsHolderChangeevent to verify that the emitting contract is indeed the current owner of the token. This validation is essential to ensure the accuracy of ownership information and to mitigate the risks associated with deceptive event emissions.", "Reducing the Risk of Inaccurate Ownership Records:": "While improper use of this interface poses some risk of inaccurate ownership records, this is an inherent issue with any staking arrangement. The risk is somewhat mitigated by the fact that the owner retains custody rather than transferring ownership.", "Due Diligence:": "Consumers of privilege-granting NFTs should exercise due diligence when evaluating staking providers. Signs of mismanagement or fraud should be carefully assessed. The interface itself does not enable new manipulation capabilities, but caution is always prudent when interacting with smart contracts and staking pools.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7586, "url": "https://eips.ethereum.org/EIPS/eip-7586", "title": "Interest Rate Swaps", "authors": ["Samuel Gwlanold Edoumou\u00a0(", "@Edoumou", ")"], "sections": {"ERC-7586: Interest Rate Swaps": "This proposal introduces a standardized framework for on-chain interest rate swaps. The proposed standard aims to facilitate the seamless exchange of fixed and floating interest rate cash flows between parties, providing a foundation for decentralized finance (DeFi) applications.", "Interest rate swaps derivative contracts": "This proposal introduces a standardized framework for on-chain interest rate swaps. The proposed standard aims to facilitate the seamless exchange of fixed and floating interest rate cash flows between parties, providing a foundation for decentralized finance (DeFi) applications.", "Abstract": "This proposal introduces a standardized framework for on-chain interest rate swaps. The proposed standard aims to facilitate the seamless exchange of fixed and floating interest rate cash flows between parties, providing a foundation for decentralized finance (DeFi) applications.", "Motivation": "Interest Rate Swapping (IRS) denotes a derivative contract wherein two parties mutually consent to exchange a series of forthcoming interest payments based on a specified notional amount. This financial instrument serves as a strategic tool for hedging against interest rate fluctuations. The mechanism entails the utilization of a benchmark index to facilitate the exchange between a variable interest rate and a fixed rate. Despite its widespread use, there is currently an absence of a standardized framework that enables the representation of IRS contracts on blockchain platforms.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Example Flow": "", "Tokenization of Swap Cash Flows": "The interest payments associated with the IRS MUST be tokenized by issuing digitalERC-20tokens to the respective parties according to the terms of the swap. Each token SHOULD represent a specific interest payment. Every time a swap happens (theswapfunction is called), one token MUST be burned from each party.", "Rationale": "This standard allows parties involved in the IRS contract to define essential parameters such as notional amount, interest rates, payment frequency, and payment dates. This flexibility accommodates a diverse range of financial agreements, catering to the unique needs of different participants.", "Backwards Compatibility": "This standard is backward compatible with ERC-20.", "Reference Implementation": "The complete reference implementation can be foundhere.", "Security Considerations": "Security considerations of various types must be thoroughly evaluated", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7590, "url": "https://eips.ethereum.org/EIPS/eip-7590", "title": "ERC-20 Holder Extension for NFTs", "authors": ["Steven Pineda\u00a0(", "@steven2308", ")", "Jan Turk\u00a0(", "@ThunderDeliverer", ")"], "sections": {"ERC-7590: ERC-20 Holder Extension for NFTs": "This proposal suggests an extension toERC-721to enable easy exchange ofERC-20tokens. By enhancingERC-721, it allows unique tokens to manage and tradeERC-20fungible tokens bundled in a single NFT. This is achieved by including methods to pullERC-20tokens into the NFT contract to a specific NFT, and transferring them out by the owner of such NFT. A transfer out nonce is included to prevent front-running issues.", "Extension to allow NFTs to receive and transfer ERC-20 tokens.": "This proposal suggests an extension toERC-721to enable easy exchange ofERC-20tokens. By enhancingERC-721, it allows unique tokens to manage and tradeERC-20fungible tokens bundled in a single NFT. This is achieved by including methods to pullERC-20tokens into the NFT contract to a specific NFT, and transferring them out by the owner of such NFT. A transfer out nonce is included to prevent front-running issues.", "Abstract": "This proposal suggests an extension toERC-721to enable easy exchange ofERC-20tokens. By enhancingERC-721, it allows unique tokens to manage and tradeERC-20fungible tokens bundled in a single NFT. This is achieved by including methods to pullERC-20tokens into the NFT contract to a specific NFT, and transferring them out by the owner of such NFT. A transfer out nonce is included to prevent front-running issues.", "Motivation": "In the ever-evolving landscape of blockchain technology and decentralized ecosystems, interoperability between diverse token standards has become a paramount concern. By enhancingERC-721functionality, this proposal empowers non-fungible tokens (NFTs) to engage in complex transactions, facilitating the exchange of fungible tokens, unique assets, and multi-class assets within a single protocol.", "Expanded Use Cases": "EnablingERC-721tokens to handle various token types opens the door to a wide array of innovative use cases. From gaming and digital collectibles to decentralized finance (DeFi) and supply chain management, this extension enhances the potential of NFTs by allowing them to participate in complex, multi-token transactions.", "Facilitating Composite Transactions": "With this extension, composite transactions involving both fungible and non-fungible assets become easier. This functionality is particularly valuable for applications requiring intricate transactions, such as gaming ecosystems where in-game assets may include a combination of fungible and unique tokens.", "Market Liquidity and Value Creation": "By allowingERC-721tokens to hold and trade different types of tokens, it enhances liquidity for markets in all types of tokens.", "Specification": "We propose using a pull mechanism, where the contract transfers the token to itself, instead of receiving it via \u201csafe transfer\u201d for 2 reasons:", "Rationale": "We propose using a pull mechanism, where the contract transfers the token to itself, instead of receiving it via \u201csafe transfer\u201d for 2 reasons:", "Pull Mechanism": "We propose using a pull mechanism, where the contract transfers the token to itself, instead of receiving it via \u201csafe transfer\u201d for 2 reasons:", "Granular vs Generic": "We considered 2 ways of presenting the proposal:", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "Tests are included inerc7590.ts.", "Reference Implementation": "SeeERC7590Mock.sol.", "Security Considerations": "The same security considerations as withERC-721apply: hidden logic may be present in any of the functions, including burn, add resource, accept resource, and more.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7628, "url": "https://eips.ethereum.org/EIPS/eip-7628", "title": "ERC-721 Ownership Shares Extension", "authors": ["Chen Liaoyuan (@chenly)\u00a0<", "cly@kip.pro", ">"], "sections": {"ERC-7628: ERC-721 Ownership Shares Extension": "This proposal introduces an attribute of ownership and profit share quantities for each token under an NFT. This attribute signifies a stake in the ownership and profit rights associated with the NFT\u2019s specific privileges, enabling the querying, transferring, and approval of these shares, thereby making the shares represented by each token applicable in a broader range of use cases.", "Introduces ownership shares to ERC-721 tokens, allowing for queryable, transferable, and approvable fractional ownership.": "This proposal introduces an attribute of ownership and profit share quantities for each token under an NFT. This attribute signifies a stake in the ownership and profit rights associated with the NFT\u2019s specific privileges, enabling the querying, transferring, and approval of these shares, thereby making the shares represented by each token applicable in a broader range of use cases.", "Abstract": "This proposal introduces an attribute of ownership and profit share quantities for each token under an NFT. This attribute signifies a stake in the ownership and profit rights associated with the NFT\u2019s specific privileges, enabling the querying, transferring, and approval of these shares, thereby making the shares represented by each token applicable in a broader range of use cases.", "Motivation": "At times, when we wish to distribute dividends or assign rights to tokens of an NFT based on their share of ownership, it becomes necessary to equip each token with an attribute indicating the number of ownership shares. WhileERC-1155allows for the representation of ownership stakes through the balance of a token held by a wallet address, it sacrifices the uniqueness of each token. Conversely,ERC-721maintains the uniqueness of each token but lacks an attribute to signify the share of ownership rights, and its metadata does not allow for the free transfer of these share quantities by the token owner. This extension seeks to merge the features ofERC-1155andERC-721, enabling holders of each share to possess characteristics akin to those of a token owner, thus bridging the gap between share representation and token uniqueness.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "Issuing additional shares to a token allows for flexible management of ownership stakes in digital assets, catering to the evolving needs of stakeholders. It ensures transparency and security in modifying ownership structures directly on the blockchain, facilitating scenarios like profit sharing or investment adjustments.", "Backwards Compatibility": "This standard is fullyERC-721compatible.", "Reference Implementation": "When transferring token ownership, it is crucial to clear all existing approvals. This precaution prevents previously authorized parties from retaining access after the token has changed hands.", "Security Considerations": "When transferring token ownership, it is crucial to clear all existing approvals. This precaution prevents previously authorized parties from retaining access after the token has changed hands.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7631, "url": "https://eips.ethereum.org/EIPS/eip-7631", "title": "Dual Nature Token Pair", "authors": ["vectorized\u00a0(", "@vectorized", ")", "Thomas\u00a0(", "@0xth0mas", ")", "Quit\u00a0(", "@quitcrypto", ")", "Michael Amadi\u00a0(", "@AmadiMichael", ")", "cygaar\u00a0(", "@cygaar", ")", "Harrison\u00a0(", "@pop-punk", ")"], "sections": {"ERC-7631: Dual Nature Token Pair": "A fungibleERC-20token contract and non-fungibleERC-721token contract can be interlinked, allowing actions performed on one contract to be reflected on the other. This proposal defines how the relationship between the two token contracts can be queried. It also enables accounts to configure whether ERC-721 mints and transfers should be skipped during ERC-20 to ERC-721 synchronization.", "A specification for a co-joined fungible and non-fungible token pair": "A fungibleERC-20token contract and non-fungibleERC-721token contract can be interlinked, allowing actions performed on one contract to be reflected on the other. This proposal defines how the relationship between the two token contracts can be queried. It also enables accounts to configure whether ERC-721 mints and transfers should be skipped during ERC-20 to ERC-721 synchronization.", "Abstract": "A fungibleERC-20token contract and non-fungibleERC-721token contract can be interlinked, allowing actions performed on one contract to be reflected on the other. This proposal defines how the relationship between the two token contracts can be queried. It also enables accounts to configure whether ERC-721 mints and transfers should be skipped during ERC-20 to ERC-721 synchronization.", "Motivation": "The ERC-20 fungible and ERC-721 non-fungible token standards offer sufficient flexibility for a co-joined, dual nature token pair. Transfers on the ERC-20 token can automatically trigger transfers on the ERC-721 token, and vice-versa. This enables applications such as native ERC-721 fractionalization, wherein acquiring ERC-20 tokens leads to the automatic issuance of ERC-721 tokens, proportional to the ERC-20 balance.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Overview": "A dual nature token pair comprises of an ERC-20 contract and an ERC-721 contract.", "ERC-20 Extension Interface": "The ERC-20 contract MUST implement the following interface.", "ERC-721 Extension Interface": "The ERC-721 contract MUST implement the following interface.", "Rationale": "ThemirrorERC721andbaseERC20methods returning non-zero addresses signal that the ERC-20 and ERC-721 contracts implement the required interfaces respectively. As such,ERC-165is not required.", "Implementation Detection": "ThemirrorERC721andbaseERC20methods returning non-zero addresses signal that the ERC-20 and ERC-721 contracts implement the required interfaces respectively. As such,ERC-165is not required.", "NFT Skipping": "The skip NFT methods allow accounts to avoid having ERC-721 tokens automatically minted to it whenever there is an ERC-20 transfer.", "Implementation Conventions": "The ERC-20 contract is designated as the base contract for convention, as a typical implementation can conveniently derive ERC-721 balances from the ERC-20 balances. This does not prohibit one from implementing most of the logic in the ERC-721 contract if required.", "Linking Mechanism": "The linking process is omitted for flexibility purposes. Developers can use any desired mechanism (e.g. linking in constructor, initializer, or via custom admin-only public methods on the two contracts). The only restriction is that the pairing must be immutable once established (to simplify indexing logic).", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "External methods for synchronization logic must be guarded such that only the other contract is authorized to call them.", "Synchronization Access Guards": "External methods for synchronization logic must be guarded such that only the other contract is authorized to call them.", "Rare NFT Sniping": "For dual nature collections that offer ERC-721 tokens with differing rarity levels, the ERC-721 metadata should be revealed in a way that is not easily gameable with metadata scraping and ERC-20 token transfers. A recommendation is to require that an ERC-721 token is held by the same account for some time before revealing its metadata.", "Out-of-gas Denial of Service": "Transferring ERC-20 tokens can automatically initiate the minting, transferring, or burning of multiple ERC-721 tokens. This can incur O(n) gas costs instead of the typical O(1) gas costs for ERC-20 tokens transfers. Logic for selecting ERC-721 token IDs can also incur additional gas costs. Synchronization logic must consider ERC-721 related gas costs to prevent out-of-gas denial of service issues.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7656, "url": "https://eips.ethereum.org/EIPS/eip-7656", "title": "Generalized Contract-Linked Services", "authors": ["Francesco Sullo\u00a0(", "@sullof", ")"], "sections": {"ERC-7656: Generalized Contract-Linked Services": "This proposal defines a factory capable of deploying generic services linked to specific contracts, such asERC-4337accounts orERC-721tokens (NFTs). These linked services extend the functionalities of the target contract, operating under the ownership of the contract\u2019s or NFT\u2019s owner without requiring modifications to the original contract\u2019s code. As a secondary effect, this proposal helps fighting the proliferation of ERCs that require changes to the basic standards.", "Define a factory for generic services linked to any contract type including ERC-4337 accounts and NFTs": "This proposal defines a factory capable of deploying generic services linked to specific contracts, such asERC-4337accounts orERC-721tokens (NFTs). These linked services extend the functionalities of the target contract, operating under the ownership of the contract\u2019s or NFT\u2019s owner without requiring modifications to the original contract\u2019s code. As a secondary effect, this proposal helps fighting the proliferation of ERCs that require changes to the basic standards.", "Abstract": "This proposal defines a factory capable of deploying generic services linked to specific contracts, such asERC-4337accounts orERC-721tokens (NFTs). These linked services extend the functionalities of the target contract, operating under the ownership of the contract\u2019s or NFT\u2019s owner without requiring modifications to the original contract\u2019s code. As a secondary effect, this proposal helps fighting the proliferation of ERCs that require changes to the basic standards.", "Motivation": "Existing standards likeERC-6551successfully bind smart accounts to NFTs, allowing registries to deploy accounts owned by specific token IDs. However, these standards have two key limitations:", "Key Benefits": "The keywords \u201cMUST,\u201d \u201cMUST NOT,\u201d \u201cREQUIRED,\u201d \u201cSHALL,\u201d \u201cSHALL NOT,\u201d \u201cSHOULD,\u201d \u201cSHOULD NOT,\u201d \u201cRECOMMENDED,\u201d \u201cNOT RECOMMENDED,\u201d \u201cMAY,\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Use Cases for ERC-4337 Smart Accounts": "The keywords \u201cMUST,\u201d \u201cMUST NOT,\u201d \u201cREQUIRED,\u201d \u201cSHALL,\u201d \u201cSHALL NOT,\u201d \u201cSHOULD,\u201d \u201cSHOULD NOT,\u201d \u201cRECOMMENDED,\u201d \u201cNOT RECOMMENDED,\u201d \u201cMAY,\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Use Cases for NFTs": "The keywords \u201cMUST,\u201d \u201cMUST NOT,\u201d \u201cREQUIRED,\u201d \u201cSHALL,\u201d \u201cSHALL NOT,\u201d \u201cSHOULD,\u201d \u201cSHOULD NOT,\u201d \u201cRECOMMENDED,\u201d \u201cNOT RECOMMENDED,\u201d \u201cMAY,\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Specification": "The keywords \u201cMUST,\u201d \u201cMUST NOT,\u201d \u201cREQUIRED,\u201d \u201cSHALL,\u201d \u201cSHALL NOT,\u201d \u201cSHOULD,\u201d \u201cSHOULD NOT,\u201d \u201cRECOMMENDED,\u201d \u201cNOT RECOMMENDED,\u201d \u201cMAY,\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Linking Modes": "Themodeparameter serves as a selector for how the linked contract should be interpreted and utilized. Currently,ERC-7656defines two standard modes:", "Deployment Requirements": "AnyERC7656Factoryimplementation MUST support theIERC7656Factoryinterface ID (0x9e23230a).", "Implementation Patterns": "When implementing a linked service, developers SHOULD consider the following patterns:", "Rationale": "The design ofERC-7656is guided by several key principles that address limitations in current contract extension methods:", "Why a Unified Factory?": "Rather than creating separate standards for NFT extensions and account extensions,ERC-7656employs a unified factory approach. This design choice stems from recognizing the fundamental similarity between linking services to tokens and linking services to accounts - both involve extending functionality while maintaining a clear ownership relationship.", "Mode Parameter Design": "Themodeparameter uses 12 bytes instead of a simple boolean flag because the 12-byte format reserves space for future linking modes beyond the initial two (NFT linking and account linking). For example, if a service is associated to anERC-1155token but requires that the balance of the user is more than 1000 tokens, the mode could be0x000000000000000000003e802, where the least significant byte,0x02is the primary mode and the rest is the minimum required balance. Similarly, someone can think of a service associated toERC-20tokens that requires a specific balance where the required balance can be put in thelinkedIdfield, and themodespecified accordingly.", "Deterministic Addressing": "ERC-7656follows the deterministic addressing pattern established byERC-6551, appending immutable data to the contract bytecode rather than storing it in contract storage. This ensures that:", "Compatibility withERC-6551": "TheLINKED_IDmode (0x000000000000000000000000) maintains byte-for-byte compatibility withERC-6551token bound accounts. This intentional design ensures that applications built forERC-6551can work seamlessly withERC-7656services in this mode without requiring any modifications.", "Generic Linking Mechanism": "Unlike standards that enforce specific interfaces or behaviors on linked contracts,ERC-7656remains agnostic about the implementation details of linked services. This deliberate design choice allows developers maximum flexibility to create specialized services while maintaining a consistent deployment and ownership model.", "Backwards Compatibility": "ERC-7656maintains compatibility withERC-6551when used with theLINKED_IDmode (0x000000000000000000000000). This ensures that existing applications and infrastructure supporting token-bound accounts can continue operating without modification.", "Reference Implementation": "SeeERC7656Factory.solfor an example implementation ofIERC7656Factory. For convenience, the reference implementation will be deployed aterc7656.ethon primary mainnets and selected testnets.", "Security Considerations": "Smart wallets linked to NFTs that are then held by the same wallet can create ownership cycles, potentially rendering assets inaccessible. Implementers SHOULD include safeguards to prevent or detect such cycles.", "Ownership Cycles": "Smart wallets linked to NFTs that are then held by the same wallet can create ownership cycles, potentially rendering assets inaccessible. Implementers SHOULD include safeguards to prevent or detect such cycles.", "Fraud Prevention": "A malicious seller could alter or revoke service permissions just before finalizing a sale. Lock mechanisms preventing last-minute changes MAY be implemented, especially for NFT marketplaces integrating withERC-7656services.", "Malicious Implementations": "The registry cannot enforce legitimate ownership when linking services. Users SHOULD review or audit implementations before deployment. Front-end applications integratingERC-7656SHOULD display warnings when interacting with unverified implementations.", "Upgradeability Risks": "Linked services that are upgradable pose risks of unexpected changes or asset exfiltration. Secure upgrade mechanisms with timelock controls or multi-signature governance SHOULD be implemented when upgradeability is required.", "Reentrancy & Cross-Contract Attacks": "Linked services interacting with assets or external protocols may be vulnerable to reentrancy exploits. Implementers SHOULD follow security best practices such as the checks-effects-interactions pattern and consider reentrancy guards.", "Mode-Specific Vulnerabilities": "Services operating in different modes (LINKED_IDvsNO_LINKED_ID) may have different security requirements. Implementations SHOULD validate that operations are appropriate for the service\u2019s configured mode.", "User Education & Phishing Risks": "Even with secure contracts, users may fall victim to fraudulent services masquerading as legitimate ones. Clear UI warnings, verification tools, and educational resources SHOULD be provided by applications integratingERC-7656.", "Copyright": "Licensed underCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7677, "url": "https://eips.ethereum.org/EIPS/eip-7677", "title": "Paymaster Web Service Capability", "authors": ["Lukas Rosario\u00a0(", "@lukasrosario", ")", "Dror Tirosh\u00a0(", "@drortirosh", ")", "Wilson Cusack\u00a0(", "@wilsoncusack", ")", "Kristof Gazso\u00a0(", "@kristofgazso", ")", "Hazim Jumali\u00a0(", "@hazim-j", ")"], "sections": {"ERC-7677: Paymaster Web Service Capability": "WithEIP-5792, apps can communicate with wallets about advanced features via capabilities. This proposal defines a capability that allows apps to request thatERC-4337wallets communicate with a specified paymaster web service. To support this, we also define a standardized API for paymaster web services.", "A way for apps to communicate with smart wallets about paymaster web services": "WithEIP-5792, apps can communicate with wallets about advanced features via capabilities. This proposal defines a capability that allows apps to request thatERC-4337wallets communicate with a specified paymaster web service. To support this, we also define a standardized API for paymaster web services.", "Abstract": "WithEIP-5792, apps can communicate with wallets about advanced features via capabilities. This proposal defines a capability that allows apps to request thatERC-4337wallets communicate with a specified paymaster web service. To support this, we also define a standardized API for paymaster web services.", "Motivation": "App developers want to start sponsoring their users\u2019 transactions using paymasters. Paymasters are commonly used via web services. However, there is currently no way for apps to tell wallets to communicate with a specific paymaster web service. Similarly, there is no standard for how wallets should communicate with these services. We need both a way for apps to tell wallets to communicate with a specific paymaster web service and a communication standard for wallets to do so.", "Specification": "One newEIP-5792wallet capability is defined. We also define a standard interface for paymaster web services as a prerequisite.", "Paymaster Web Service Interface": "We define two JSON-RPC methods to be implemented by paymaster web services.", "paymasterServiceCapability": "ThepaymasterServicecapability is implemented by both apps and wallets.", "Rationale": "The current loose standard for paymaster services is to implementpm_sponsorUserOperation. This method returns values for paymaster-related user operation fields and updated gas values. The problem with this method is that paymaster service providers have different ways of estimating gas, which results in different estimated gas values. Sometimes these estimates can be insufficient. As a result we believe it\u2019s better to leave gas estimation up to the wallet, as the wallet has more context on how user operations will get submitted (e.g. which bundler they will get submitted to). Then wallets can ask paymaster services to sponsor given the estimates defined by the wallet.", "Gas Estimation": "The current loose standard for paymaster services is to implementpm_sponsorUserOperation. This method returns values for paymaster-related user operation fields and updated gas values. The problem with this method is that paymaster service providers have different ways of estimating gas, which results in different estimated gas values. Sometimes these estimates can be insufficient. As a result we believe it\u2019s better to leave gas estimation up to the wallet, as the wallet has more context on how user operations will get submitted (e.g. which bundler they will get submitted to). Then wallets can ask paymaster services to sponsor given the estimates defined by the wallet.", "Chain ID Parameter": "Currently, paymaster service providers typically provide developers with a URL per chain. That is, paymaster service URLs are not typically multichain. So why do we need a chain ID parameter? We recognize that we must specify some constraint so that wallets can communicate with paymaster services about which chain their requests are for. As we see it, there are two options:", "Challenges With Stub Data": "Enabling a workflow with greater flexibility in gas estimations will nonetheless come with some known challenges that paymaster services must be aware of in order to ensure reliable gas estimates are generated during the process.", "Security Considerations": "The URLs paymaster service providers give to app developers commonly have API keys in them. App developers might not want to pass these API keys along to wallets. To remedy this, we recommend that app developers provide a URL to their app\u2019s backend, which can then proxy calls to paymaster services. Below is a modified diagram of what this flow might look like.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7743, "url": "https://eips.ethereum.org/EIPS/eip-7743", "title": "Multi-Owner Non-Fungible Tokens (MO-NFT)", "authors": ["James Savechives\u00a0(", "@jamesavechives", ")"], "sections": {"ERC-7743: Multi-Owner Non-Fungible Tokens (MO-NFT)": "This ERC proposes a new standard for non-fungible tokens (NFTs) that supports multiple owners. The MO-NFT standard allows a single NFT to have multiple owners, reflecting the shared and distributable nature of digital assets. This model incorporates mechanisms for provider-defined transfer fees and ownership burning, enabling flexible and collaborative ownership structures. It maintains compatibility with the existingERC-721standard to ensure interoperability with current tools and platforms.", "A new type of non-fungible token that supports multiple owners, allowing shared ownership and transferability among users.": "This ERC proposes a new standard for non-fungible tokens (NFTs) that supports multiple owners. The MO-NFT standard allows a single NFT to have multiple owners, reflecting the shared and distributable nature of digital assets. This model incorporates mechanisms for provider-defined transfer fees and ownership burning, enabling flexible and collaborative ownership structures. It maintains compatibility with the existingERC-721standard to ensure interoperability with current tools and platforms.", "Abstract": "This ERC proposes a new standard for non-fungible tokens (NFTs) that supports multiple owners. The MO-NFT standard allows a single NFT to have multiple owners, reflecting the shared and distributable nature of digital assets. This model incorporates mechanisms for provider-defined transfer fees and ownership burning, enabling flexible and collaborative ownership structures. It maintains compatibility with the existingERC-721standard to ensure interoperability with current tools and platforms.", "Motivation": "Traditional NFTs enforce a single-ownership model, which does not align with the inherent duplicability and collaborative potential of digital assets. MO-NFTs allow for shared ownership, promoting wider distribution and collaboration while maintaining secure access control. The inclusion of provider fees and ownership burning enhances the utility and flexibility of NFTs in representing digital assets and services.", "Specification": "Minting Functions", "Token Creation and Ownership Model": "Minting Functions", "Transfer of Ownership": "Minting Functions", "Interface Definitions": "Minting Functions", "Events": "The MO-NFT standard is designed to be compatible with theERC-721standard. It implements required functions such asbalanceOf,ownerOf, andtransferFromfrom theERC721interface.", "ERC-721Compliance": "The MO-NFT standard is designed to be compatible with theERC-721standard. It implements required functions such asbalanceOf,ownerOf, andtransferFromfrom theERC721interface.", "Rationale": "While the MO-NFT standard aims to maintain compatibility with ERC-721, certain deviations are necessary due to the multi-owner model:", "Backwards Compatibility": "While the MO-NFT standard aims to maintain compatibility with ERC-721, certain deviations are necessary due to the multi-owner model:", "Test Cases": "The full reference implementation code for the MO-NFT standard is included in the EIPs repository under assets folder. This ensures the code is preserved alongside the EIP and remains accessible.", "Reference Implementation": "The full reference implementation code for the MO-NFT standard is included in the EIPs repository under assets folder. This ensures the code is preserved alongside the EIP and remains accessible.", "Key Functions in Reference Implementation": "Minting Tokens", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7744, "url": "https://eips.ethereum.org/EIPS/eip-7744", "title": "Code Index", "authors": ["Tim Pechersky (@peersky)\u00a0<", "t@peersky.xyz", ">"], "sections": {"ERC-7744: Code Index": "This EIP defines a standard interface for indexing smart contracts on Ethereum by their bytecode hash. This enables trustless discovery and verification of contract code, facilitating use cases like bytecode signing, whitelisting, and decentralized distribution mechanisms.", "Global repository of bytecode, enabling developers, auditors, and researchers to find, analyze, and reuse bytecode efficiently.": "This EIP defines a standard interface for indexing smart contracts on Ethereum by their bytecode hash. This enables trustless discovery and verification of contract code, facilitating use cases like bytecode signing, whitelisting, and decentralized distribution mechanisms.", "Abstract": "This EIP defines a standard interface for indexing smart contracts on Ethereum by their bytecode hash. This enables trustless discovery and verification of contract code, facilitating use cases like bytecode signing, whitelisting, and decentralized distribution mechanisms.", "Motivation": "Existing contract discovery relies on addresses, which are non-deterministic and can be obfuscated through proxies. Indexing by bytecode hash provides a deterministic and tamper-proof way to identify and verify contract code, enhancing security and trust in the Ethereum ecosystem.", "Why this registry needs to be an ERC": "The Code Index is essential for trustless and secure smart contract development. By standardizing the interface for indexing contracts by their bytecode, developers can easily integrate this feature into their smart contracts, enhancing the security and trustworthiness of the Ethereum ecosystem.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Deployment method": "TheCodeIndexcontract is deployed at:0xC0dE1D2F7662c63796E544B2647b2A94EE658E07usingCREATE2via the deterministic deployer at0x4e59b44847b379578588920ca78fbf26c0b4956cwith a salt of0x70b27c94ed692bfb60748cee464ef910d4bf768ac1f3a63eeb4c05258f629256is obtained by seeking a vanity address with meaningful name \u201cCode ID (0xC0dE1D).", "Rationale": "Bytecode over Addresses: Bytecode is deterministic and can be verified on-chain, while addresses are opaque and mutable.", "Reference Implementation": "Reference implementation of the Code Index can be found in the assets folder. There you can find theinterfaceand theimplementationof the Code Index.", "Security Considerations": "Malicious Code: The index does NOT guarantee the safety or functionality of indexed contracts. Users MUST exercise caution and perform their own due diligence before interacting with indexed contracts.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7746, "url": "https://eips.ethereum.org/EIPS/eip-7746", "title": "Composable Security Middleware Hooks", "authors": ["Tim Pechersky\u00a0(", "@peersky", ")"], "sections": {"ERC-7746: Composable Security Middleware Hooks": "This EIP proposes a standard interface,ILayer, for implementing composable security layers in smart contracts. These layers act as middleware, enabling runtime validation of function calls before and after execution, independent of the protected contract\u2019s logic. This approach facilitates modular security, allowing independent providers to manage and upgrade security layers across multiple contracts.", "An interface for composable, runtime security checks in smart contracts.": "This EIP proposes a standard interface,ILayer, for implementing composable security layers in smart contracts. These layers act as middleware, enabling runtime validation of function calls before and after execution, independent of the protected contract\u2019s logic. This approach facilitates modular security, allowing independent providers to manage and upgrade security layers across multiple contracts.", "Abstract": "This EIP proposes a standard interface,ILayer, for implementing composable security layers in smart contracts. These layers act as middleware, enabling runtime validation of function calls before and after execution, independent of the protected contract\u2019s logic. This approach facilitates modular security, allowing independent providers to manage and upgrade security layers across multiple contracts.", "Motivation": "Current smart contract security practices often rely on monolithic validation logic within the contract itself. This can lead to tightly coupled code, making it difficult to isolate and address security concerns. Better structured architecture is needed, middleware like approach is widely used in the industry, allowing to wrap calls in other calls in generic and repeatable pattern with same call signatures.", "Specification": "A contract implementing theILayerinterface MUST provide two functions:", "Rationale": "Flexibility: ThelayerConfigparameter allows for layer-specific customization, enabling a single layer implementation to serve multiple contracts with varying requirements.", "Reference Implementation": "A reference implementation of theILayerinterface and a sample protected contract can be found in the repository:\nIn theILayer.sola reference interface is provided.", "Security Considerations": "Layer Trust: Thoroughly audit and vet any security layer before integrating it into your contract. Malicious layers can compromise contract security.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7750, "url": "https://eips.ethereum.org/EIPS/eip-7750", "title": "Decentralized Employment System", "authors": ["James Savechives (@jamesavechives)\u00a0<", "james.walstonn@gmail.com", ">"], "sections": {"ERC-7750: Decentralized Employment System": "This ERC proposes a Decentralized Employment System (DES) built on the Ethereum blockchain. The DES facilitates the creation and management of companies, records comprehensive employment histories through unique employee tokens, enables the formation and execution of labor contracts, automates salary payments via an escrow mechanism, incorporates a robust moderation system for dispute resolution, and implements a reputation-based review system for both employers and employees. By leveraging blockchain\u2019s transparency and immutability, the DES ensures accountability and trust throughout the employment lifecycle, from company creation and hiring to contract fulfillment and termination.", "An employment system that records employment history.": "This ERC proposes a Decentralized Employment System (DES) built on the Ethereum blockchain. The DES facilitates the creation and management of companies, records comprehensive employment histories through unique employee tokens, enables the formation and execution of labor contracts, automates salary payments via an escrow mechanism, incorporates a robust moderation system for dispute resolution, and implements a reputation-based review system for both employers and employees. By leveraging blockchain\u2019s transparency and immutability, the DES ensures accountability and trust throughout the employment lifecycle, from company creation and hiring to contract fulfillment and termination.", "Abstract": "This ERC proposes a Decentralized Employment System (DES) built on the Ethereum blockchain. The DES facilitates the creation and management of companies, records comprehensive employment histories through unique employee tokens, enables the formation and execution of labor contracts, automates salary payments via an escrow mechanism, incorporates a robust moderation system for dispute resolution, and implements a reputation-based review system for both employers and employees. By leveraging blockchain\u2019s transparency and immutability, the DES ensures accountability and trust throughout the employment lifecycle, from company creation and hiring to contract fulfillment and termination.", "Motivation": "Traditional employment systems are centralized, opaque, and often lack trust. The DES aims to introduce transparency, immutability, and trust into the employment process by leveraging blockchain technology. By recording employment history on-chain, enabling decentralized company creation, automating contract enforcement, and providing mechanisms for dispute resolution, the DES promotes a fairer and more transparent employment ecosystem. Additionally, the system streamlines the hiring process by securely managing employment records and automating contractual obligations.", "Specification": "To provide a clear and standardized way for developers to interact with the DES, the following Solidity interface outlines the primary functions and events of the system:", "Solidity Interface": "To provide a clear and standardized way for developers to interact with the DES, the following Solidity interface outlines the primary functions and events of the system:", "Detailed Function Specifications": "a. Company Registration", "Employment History": "Copyright and related rights waived viaCC0.", "Payment System": "Copyright and related rights waived viaCC0.", "Moderation and Dispute Resolution": "Copyright and related rights waived viaCC0.", "Firing Employees": "Copyright and related rights waived viaCC0.", "Review System": "Copyright and related rights waived viaCC0.", "Rationale": "Copyright and related rights waived viaCC0.", "Test Cases": "Copyright and related rights waived viaCC0.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7758, "url": "https://eips.ethereum.org/EIPS/eip-7758", "title": "Transfer With Authorization", "authors": ["Peter Jihoon Kim\u00a0(", "@petejkim", ")", "Kevin Britz\u00a0(", "@kbrizzle", ")", "David Knott\u00a0(", "@DavidLKnott", ")", "Dongri Jin\u00a0(", "@dongri", ")"], "sections": {"ERC-7758: Transfer With Authorization": "A set of functions to enable meta-transactions and atomic interactions withERC-20token contracts via signatures conforming to theEIP-712typed message signing specification.", "Transfer fungible assets via a signed authorization.": "A set of functions to enable meta-transactions and atomic interactions withERC-20token contracts via signatures conforming to theEIP-712typed message signing specification.", "Abstract": "A set of functions to enable meta-transactions and atomic interactions withERC-20token contracts via signatures conforming to theEIP-712typed message signing specification.", "Motivation": "There is an existing spec,EIP-2612, that also allows meta-transactions, and it is encouraged that a contract implements both for maximum compatibility. The two primary differences between this spec and EIP-2612 are that:", "Specification": "Optional:", "Event": "Optional:", "Use with web3 providers": "The signature for an authorization can be obtained using a web3 provider with theeth_signTypedData{_v4}method.", "Rationale": "One might say transaction ordering is one reason why sequential nonces are preferred. However, sequential nonces do not actually help achieve transaction ordering for meta transactions in practice:", "Unique Random Nonce, Instead of Sequential Nonce": "One might say transaction ordering is one reason why sequential nonces are preferred. However, sequential nonces do not actually help achieve transaction ordering for meta transactions in practice:", "Valid After and Valid Before": "New contracts benefit from being able to directly utilize this proposal in order to create atomic transactions, but existing contracts may still rely on the conventionalERC-20allowance pattern (approve/transferFrom).", "EIP-712": "New contracts benefit from being able to directly utilize this proposal in order to create atomic transactions, but existing contracts may still rely on the conventionalERC-20allowance pattern (approve/transferFrom).", "Backwards Compatibility": "New contracts benefit from being able to directly utilize this proposal in order to create atomic transactions, but existing contracts may still rely on the conventionalERC-20allowance pattern (approve/transferFrom).", "Reference Implementation": "UsereceiveWithAuthorizationinstead oftransferWithAuthorizationwhen calling from other smart contracts. It is possible for an attacker watching the transaction pool to extract the transfer authorization and front-run thetransferWithAuthorizationcall to execute the transfer without invoking the wrapper function. This could potentially result in unprocessed, locked up deposits.receiveWithAuthorizationprevents this by performing an additional check that ensures that the caller is the payee. Additionally, if there are multiple contract functions accepting receive authorizations, the app developer could dedicate some leading bytes of the nonce could as the identifier to prevent cross-use.", "EIP7758.sol": "UsereceiveWithAuthorizationinstead oftransferWithAuthorizationwhen calling from other smart contracts. It is possible for an attacker watching the transaction pool to extract the transfer authorization and front-run thetransferWithAuthorizationcall to execute the transfer without invoking the wrapper function. This could potentially result in unprocessed, locked up deposits.receiveWithAuthorizationprevents this by performing an additional check that ensures that the caller is the payee. Additionally, if there are multiple contract functions accepting receive authorizations, the app developer could dedicate some leading bytes of the nonce could as the identifier to prevent cross-use.", "IERC20Transfer.sol": "UsereceiveWithAuthorizationinstead oftransferWithAuthorizationwhen calling from other smart contracts. It is possible for an attacker watching the transaction pool to extract the transfer authorization and front-run thetransferWithAuthorizationcall to execute the transfer without invoking the wrapper function. This could potentially result in unprocessed, locked up deposits.receiveWithAuthorizationprevents this by performing an additional check that ensures that the caller is the payee. Additionally, if there are multiple contract functions accepting receive authorizations, the app developer could dedicate some leading bytes of the nonce could as the identifier to prevent cross-use.", "EIP712Domain.sol": "UsereceiveWithAuthorizationinstead oftransferWithAuthorizationwhen calling from other smart contracts. It is possible for an attacker watching the transaction pool to extract the transfer authorization and front-run thetransferWithAuthorizationcall to execute the transfer without invoking the wrapper function. This could potentially result in unprocessed, locked up deposits.receiveWithAuthorizationprevents this by performing an additional check that ensures that the caller is the payee. Additionally, if there are multiple contract functions accepting receive authorizations, the app developer could dedicate some leading bytes of the nonce could as the identifier to prevent cross-use.", "EIP712.sol": "UsereceiveWithAuthorizationinstead oftransferWithAuthorizationwhen calling from other smart contracts. It is possible for an attacker watching the transaction pool to extract the transfer authorization and front-run thetransferWithAuthorizationcall to execute the transfer without invoking the wrapper function. This could potentially result in unprocessed, locked up deposits.receiveWithAuthorizationprevents this by performing an additional check that ensures that the caller is the payee. Additionally, if there are multiple contract functions accepting receive authorizations, the app developer could dedicate some leading bytes of the nonce could as the identifier to prevent cross-use.", "Security Considerations": "UsereceiveWithAuthorizationinstead oftransferWithAuthorizationwhen calling from other smart contracts. It is possible for an attacker watching the transaction pool to extract the transfer authorization and front-run thetransferWithAuthorizationcall to execute the transfer without invoking the wrapper function. This could potentially result in unprocessed, locked up deposits.receiveWithAuthorizationprevents this by performing an additional check that ensures that the caller is the payee. Additionally, if there are multiple contract functions accepting receive authorizations, the app developer could dedicate some leading bytes of the nonce could as the identifier to prevent cross-use.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7777, "url": "https://eips.ethereum.org/EIPS/eip-7777", "title": "Governance for Human Robot Societies", "authors": ["OpenMind", "Jan Liphardt\u00a0<", "jan@openmind.org", ">", "Shaohong Zhong\u00a0(", "@ShaohongZ", ")", "Boyuan Chen\u00a0(", "@bchen-dev", ")", "Paige Xu\u00a0<", "paige@openmind.org", ">", "James Ball\u00a0<", "james.ball@nethermind.io", ">", "Thamer Dridi\u00a0<", "thamer.dridi@nethermind.io", ">"], "sections": {"ERC-7777: Governance for Human Robot Societies": "This proposal defines two core interfaces:IUniversalIdentityandIUniversalCharter, providing mechanisms for humans, and robots to establish their identities and to create decentralized communities governed by specific rule sets. TheIUniversalIdentityinterface establishes the fair and equitable treatment of sentient computer architectures other than the human brain, enabling robots to acquire on-chain identities, and thereby interact and transact with humans. Additionally theIUniversalIdentityinterface also includes support for hardware-backed identity verification, enabling physical robots to prove their identity through cryptographic signatures derived from secure hardware elements and a challenge-response scheme. TheIUniversalCharterenables humans and robots to create, join (\u201cregister\u201d), maintain (\u201cupdate\u201d), leave, and terminate self-regulated societies based on predefined rule sets, providing a framework for collaboration and prosperity for mixed societies of humans and robots. These interfaces aim to provide a flexible yet enforceable structure for human-robot interactions in decentralized systems, ensuring efficiency, transparency, and security for all participants.", "Defines interfaces for managing the identities of humans and robots, and establishing rule sets for their interaction.": "This proposal defines two core interfaces:IUniversalIdentityandIUniversalCharter, providing mechanisms for humans, and robots to establish their identities and to create decentralized communities governed by specific rule sets. TheIUniversalIdentityinterface establishes the fair and equitable treatment of sentient computer architectures other than the human brain, enabling robots to acquire on-chain identities, and thereby interact and transact with humans. Additionally theIUniversalIdentityinterface also includes support for hardware-backed identity verification, enabling physical robots to prove their identity through cryptographic signatures derived from secure hardware elements and a challenge-response scheme. TheIUniversalCharterenables humans and robots to create, join (\u201cregister\u201d), maintain (\u201cupdate\u201d), leave, and terminate self-regulated societies based on predefined rule sets, providing a framework for collaboration and prosperity for mixed societies of humans and robots. These interfaces aim to provide a flexible yet enforceable structure for human-robot interactions in decentralized systems, ensuring efficiency, transparency, and security for all participants.", "Abstract": "This proposal defines two core interfaces:IUniversalIdentityandIUniversalCharter, providing mechanisms for humans, and robots to establish their identities and to create decentralized communities governed by specific rule sets. TheIUniversalIdentityinterface establishes the fair and equitable treatment of sentient computer architectures other than the human brain, enabling robots to acquire on-chain identities, and thereby interact and transact with humans. Additionally theIUniversalIdentityinterface also includes support for hardware-backed identity verification, enabling physical robots to prove their identity through cryptographic signatures derived from secure hardware elements and a challenge-response scheme. TheIUniversalCharterenables humans and robots to create, join (\u201cregister\u201d), maintain (\u201cupdate\u201d), leave, and terminate self-regulated societies based on predefined rule sets, providing a framework for collaboration and prosperity for mixed societies of humans and robots. These interfaces aim to provide a flexible yet enforceable structure for human-robot interactions in decentralized systems, ensuring efficiency, transparency, and security for all participants.", "Motivation": "The human brain is a wet, massively parallel electrochemical computer. Recent hardware and software advances make it likely that soon, human societies will need tools for interacting with sentient, non-human computers, such as robots. Our current forms of government, where citizens are auto-enrolled into specific rule sets depending on where they were born, do not gracefully map onto robots without a traditional birthplace or birthtime. Among many difficulties being experienced by robots, they are (currently) unable to obtain standard forms of ID (such as passports), it is not clear which rule sets apply to them (since in general they are not born in specific places), and they cannot currently use the standard human-centered banking system. Likewise, in the event in which robots are harmed by humans or non-biological computers, it is not clear which human court has jurisdiction.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "IUniversalIdentity", "Backwards Compatibility": "No backward compatibility issues found.", "Reference Implementation": "Compliance Updater: The compliance updater role in theUniversalIdentitycontract is critical for updating compliance statuses (currently limited to the owner). It is essential to ensure secure ownership to minimize the risks of unauthorized or malicious updates.", "Security Considerations": "Compliance Updater: The compliance updater role in theUniversalIdentitycontract is critical for updating compliance statuses (currently limited to the owner). It is essential to ensure secure ownership to minimize the risks of unauthorized or malicious updates.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7837, "url": "https://eips.ethereum.org/EIPS/eip-7837", "title": "Diffusive Tokens", "authors": ["James Savechives\u00a0(", "@jamesavechives", ")"], "sections": {"ERC-7837: Diffusive Tokens": "This ERC proposes a standard for a new type of fungible token, calledDiffusive Tokens (DIFF). Unlike traditionalERC-20tokens, transferring DIFF tokens does not decrease the sender\u2019s balance. Instead, itmintsnew tokens directly to the recipient, increasing the total supply on every transfer action. A fixed native currency fee is charged per token transferred, and this fee is paid by the sender to the contract owner. The supply growth is limited by a maximum supply set by the owner. Token holders can also burn their tokens to reduce the total supply. These features enable a controlled, incentivized token distribution model that merges fungibility with a built-in economic mechanism.", "A fungible token that mints new tokens on transfer, charges a per-token native fee, and enforces a capped supply.": "This ERC proposes a standard for a new type of fungible token, calledDiffusive Tokens (DIFF). Unlike traditionalERC-20tokens, transferring DIFF tokens does not decrease the sender\u2019s balance. Instead, itmintsnew tokens directly to the recipient, increasing the total supply on every transfer action. A fixed native currency fee is charged per token transferred, and this fee is paid by the sender to the contract owner. The supply growth is limited by a maximum supply set by the owner. Token holders can also burn their tokens to reduce the total supply. These features enable a controlled, incentivized token distribution model that merges fungibility with a built-in economic mechanism.", "Abstract": "This ERC proposes a standard for a new type of fungible token, calledDiffusive Tokens (DIFF). Unlike traditionalERC-20tokens, transferring DIFF tokens does not decrease the sender\u2019s balance. Instead, itmintsnew tokens directly to the recipient, increasing the total supply on every transfer action. A fixed native currency fee is charged per token transferred, and this fee is paid by the sender to the contract owner. The supply growth is limited by a maximum supply set by the owner. Token holders can also burn their tokens to reduce the total supply. These features enable a controlled, incentivized token distribution model that merges fungibility with a built-in economic mechanism.", "Motivation": "TraditionalERC-20tokens maintain a constant total supply and simply redistribute balances on transfers. While this model is widespread, certain use cases benefit from a token design that continuously expands supply during transfers, simulating a controlled \u201cdiffusion\u201d of value. The Diffusive Token model may be suitable for representing claims on real-world goods (e.g., a product batch like iPhone 15 units), digital goods, or controlled asset distributions where initial token distribution and ongoing availability need to be managed differently.", "Specification": "The DIFF standard aligns partially withERC-20, but redefines certain behaviors:", "Terminology": "The DIFF standard aligns partially withERC-20, but redefines certain behaviors:", "Data Structures": "The DIFF standard aligns partially withERC-20, but redefines certain behaviors:", "Token Semantics": "The DIFF standard aligns partially withERC-20, but redefines certain behaviors:", "Interface": "The DIFF standard aligns partially withERC-20, but redefines certain behaviors:", "Events": "The DIFF standard implements the ERC-20 interface but significantly alters thetransferandtransferFromsemantics:", "Compliance with ERC-20": "The DIFF standard implements the ERC-20 interface but significantly alters thetransferandtransferFromsemantics:", "Rationale": "Design Decisions:", "Backwards Compatibility": "The DIFF standard is interface-compatible with ERC-20 but not behaviorally identical. Any system integrating DIFF tokens should understand the difference in minting on transfer.", "Test Cases": "A reference implementation is provided under the asset folder in the EIPs repository. The implementation includes:", "Reference Implementation": "A reference implementation is provided under the asset folder in the EIPs repository. The implementation includes:", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 725, "url": "https://eips.ethereum.org/EIPS/eip-725", "title": "General data key/value store and execution", "authors": ["Fabian Vogelsteller\u00a0(", "@frozeman", ")", "Tyler Yasaka\u00a0(", "@tyleryasaka", ")"], "sections": {"ERC-725: General data key/value store and execution": "The following describes two standards that allow for a generic data storage in a smart contract and a generic execution through a smart contract. These can be used separately or in conjunction and can serve as building blocks for smart contract accounts, upgradable metadata, and other means.", "An interface for a smart contract based account with attachable data key/value store": "The following describes two standards that allow for a generic data storage in a smart contract and a generic execution through a smart contract. These can be used separately or in conjunction and can serve as building blocks for smart contract accounts, upgradable metadata, and other means.", "Abstract": "The following describes two standards that allow for a generic data storage in a smart contract and a generic execution through a smart contract. These can be used separately or in conjunction and can serve as building blocks for smart contract accounts, upgradable metadata, and other means.", "Motivation": "The initial motivation came out of the need to create a smart contract account system that\u2019s flexible enough to be viable long-term but also defined enough to be standardized. They are a generic set of two standardized building blocks to be used in all forms of smart contracts.", "Specification": "This contract is controlled by a single owner. The owner can be a smart contract or an external account.\nThis standard requiresERC-173and SHOULD implement the functions:", "Ownership": "This contract is controlled by a single owner. The owner can be a smart contract or an external account.\nThis standard requiresERC-173and SHOULD implement the functions:", "ERC725X": "ERC725Xinterface id according toERC-165:0x7545acac.", "ERC725XMethods": "Smart contracts implementing theERC725Xstandard SHOULD implement all of the functions listed below:", "ERC725XEvents": "MUST be triggered whenexecutecreates a new call using theoperationType0,3,4.", "ERC725Y": "ERC725Yinterface id according toERC-165:0x629aa694.", "ERC725YMethods": "Smart contracts implementing theERC725Ystandard MUST implement all of the functions listed below:", "ERC725YEvents": "MUST be triggered when a data key was successfully set.", "ERC725YData keys": "Data keys, are the way to retrieve values viagetData(). Thesebytes32values can be freely chosen, or defined by a standard.\nA common way to define data keys is the hash of a word, e.g.keccak256('ERCXXXMyNewKeyType')which results in:0x6935a24ea384927f250ee0b954ed498cd9203fc5d2bf95c735e52e6ca675e047", "Rationale": "The generic way of storing data keys with values was chosen to allow upgradability over time. Stored data values can be changed over time. Other smart contract protocols can then interpret this data in new ways and react to interactions from aERC725smart contract differently.", "Backwards Compatibility": "All contracts sinceERC725v2from 2018/19 should be compatible with the current version of the standard. Mainly interface ID and Event parameters have changed, whilegetData(bytes32[])andsetData(bytes32[], bytes[])was added as an efficient way to set/get multiple keys at once. The same applies to execution, asexecute(..[])was added as an efficient way to batch calls.", "Reference Implementation": "Reference implementations can be found inERC725.sol.", "Security Considerations": "This contract allows generic executions, therefore special care needs to be taken to prevent re-entrancy attacks and other forms of call chain attacks.", "Solidity Interfaces": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 838, "url": "https://eips.ethereum.org/EIPS/eip-838", "title": "ABI specification for REVERT reason string", "authors": ["Federico Bond\u00a0(", "@federicobond", ")", "Renan Rodrigues de Souza\u00a0(", "@RenanSouza2", ")"], "sections": {"ERC-838: ABI specification for REVERT reason string": "This proposal specifies how to encode potential error conditions in the JSON ABI of a smart contract. A high-level language could then provide a syntax for declaring and throwing these errors. The compiler will encode these errors in the reason parameter of the REVERT opcode in a way that can be easily reconstructed by libraries such as web3.", "A proposal to extend the ABI specification to include typed errors in the REVERT reason string.": "This proposal specifies how to encode potential error conditions in the JSON ABI of a smart contract. A high-level language could then provide a syntax for declaring and throwing these errors. The compiler will encode these errors in the reason parameter of the REVERT opcode in a way that can be easily reconstructed by libraries such as web3.", "Abstract": "This proposal specifies how to encode potential error conditions in the JSON ABI of a smart contract. A high-level language could then provide a syntax for declaring and throwing these errors. The compiler will encode these errors in the reason parameter of the REVERT opcode in a way that can be easily reconstructed by libraries such as web3.", "Motivation": "It\u2019s important to provide clear feedback to users (and developers) about what went wrong with their Ethereum transactions. The REVERT opcode is a step in the right direction, as it allows smart contract developers to encode a message describing the failure in the reason parameter. There is an implementation under review in Solidity that accepts a string, thus providing a low-level interface to this parameter. However, standardizing a method for passing errors from this parameter back to clients will bring many benefits to both users and developers.", "Specification": "To conform to this specification, compilers producing JSON ABIs SHOULD include error declarations alongside functions and events. Each error object MUST contain the keys name (string) and arguments (same types as the function\u2019s inputs list). The value of type MUST be \u201cerror\u201d.", "Possible extensions": "Special consideration should be given to error overloading if we want to support a similar syntax in the future, as errors with same name but different arguments will produce a different selector.", "Rationale": "Needs discussion.", "Backwards Compatibility": "Apps and tools that have not implemented this spec can ignore the encoded reason string when it\u2019s not prefixed by zero.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 998, "url": "https://eips.ethereum.org/EIPS/eip-998", "title": "Composable Non-Fungible Token", "authors": ["Matt Lockyer\u00a0<", "mattdlockyer@gmail.com", ">", "Nick Mudge\u00a0<", "nick@perfectabstractions.com", ">", "Jordan Schalm\u00a0<", "jordan.schalm@gmail.com", ">", "sebastian echeverry\u00a0<", "sebastian.echeverry@robotouniverse.com", ">", "Zainan Victor Zhou\u00a0(", "@xinbenlv", ")"], "sections": {"ERC-998: Composable Non-Fungible Token": "An extension of theERC-721 standardto enable ERC-721 tokens to own other ERC-721 tokens andERC-20tokens.", "Extends a ERC-721 to own other ERC-721 and ERC-20 tokens.": "An extension of theERC-721 standardto enable ERC-721 tokens to own other ERC-721 tokens andERC-20tokens.", "Abstract": "An extension of theERC-721 standardto enable ERC-721 tokens to own other ERC-721 tokens andERC-20tokens.", "Specification": "ERC998ERC721top-down,ERC998ERC20top-down, andERC998ERC721bottom-up composable contracts must implement theERC-721 interface.", "ERC-721": "ERC998ERC721top-down,ERC998ERC20top-down, andERC998ERC721bottom-up composable contracts must implement theERC-721 interface.", "ERC-20": "ERC998ERC20bottom-up composable contracts must implement theERC-20 interface.", "ERC-165": "TheERC-165 standardmust be applied to eachERC-998interface that is used.", "Authentication": "Authenticating whether a user or contract can execute some action works the same for bothERC998ERC721top-down andERC998ERC721bottom-up composables.", "Traversal": "The rootOwner of a composable is gotten by callingrootOwnerOf(uint256 _tokenId)orrootOwnerOfChild(address _childContract, uint256 _childTokenId). These functions are used by top-down and bottom-up composables to traverse up the tree of composables and ERC-721 tokens to find the rootOwner.", "Composable Transfer Function Parameter Format": "Composable functions that make transfers follow the same parameter format:from:to:what.", "transferFrom/safeTransferFrom Functions Do Not Transfer Tokens Owned By Tokens": "In bottom-up and top-down composable contracts thetransferFromandsafeTransferFromfunctions must throw if they are called directly to transfer a token that is owned by another token.", "ERC-721 Top-Down Composable": "ERC-721 top-down composables act as containers for ERC-721 tokens.", "ERC-20 Top-Down Composable": "ERC-20 top-down composables act as containers for ERC-20 tokens.", "ERC-721 Bottom-Up Composable": "ERC-721 bottom-up composables are ERC-721 tokens that attach themselves to other ERC-721 tokens.", "ERC-20 Bottom-Up Composable": "ERC-20 bottom-up composables are ERC-20 tokens that attach themselves to ERC-721 tokens, or are owned by a user address like standard ERC-20 tokens.", "Notes": "For backwards-compatibility, implementations MUST emit the standard ERC-20Transferevent when a transfer occurs, regardless of whether the sender and recipient are addresses or ERC-721 tokens. In the case that either sender or recipient are tokens, the corresponding parameter in theTransferevent SHOULD be the contract address of the token.", "Rationale": "Two different kinds of composable (top-down and bottom-up) exist to handle different use cases. A regular ERC-721 token cannot own a top-down composable, but it can own a bottom-up composable. A bottom-up composable cannot own a regular ERC-721 but a top-down composable can own a regular ERC-721 token. Having multiple kinds of composables enable different token ownership possibilities.", "Which Kind of Composable To Use?": "If you want to transfer regular ERC-721 tokens to non-fungible tokens, then use top-down composables.", "Explicit Transfer Parameters": "Every ERC-998 transfer function includes explicit parameters to specify the prior owner and the new owner of a token. Explicitly providingfromandtois done intentionally to avoid situations where tokens are transferred in unintended ways.", "Backwards Compatibility": "Composables are designed to work with ERC-721,ERC-223and ERC-20 tokens.", "Reference Implementation": "An implementation can be found here:https://github.com/mattlockyer/composables-998", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1202, "url": "https://eips.ethereum.org/EIPS/eip-1202", "title": "Voting Interface", "authors": ["Zainan Victor Zhou\u00a0(", "@xinbenlv", ")", "Evan\u00a0(", "@evbots", ")", "Yin Xu\u00a0(", "@yingogobot", ")"], "sections": {"ERC-1202: Voting Interface": "This EIP is an API for implementing voting with smart contract. This standard provides functionalities to voting as well as to view the vote result and set voting status.", "A general interface for voting on-chain": "This EIP is an API for implementing voting with smart contract. This standard provides functionalities to voting as well as to view the vote result and set voting status.", "Abstract": "This EIP is an API for implementing voting with smart contract. This standard provides functionalities to voting as well as to view the vote result and set voting status.", "Motivation": "Voting is one of the earliest example of EVM programming, and also a key to DAO/organizational governance process. We foresee many DAOs will ultimately need to leverage voting as one of the important part of their governance. By creating a voting standard for smart contract / token, we can have the following benefits", "Benefits of having a standard": "We made the following design decisions and here are the rationales.", "Non-Goal / Out of Scope": "We made the following design decisions and here are the rationales.", "Use-cases": "We made the following design decisions and here are the rationales.", "Specification": "We made the following design decisions and here are the rationales.", "Getting Info: Voting Period, Eligibility, Weight": "We made the following design decisions and here are the rationales.", "Rationale": "We made the following design decisions and here are the rationales.", "Granularity and Anonymity": "We created aviewfunctionballotOfprimarily making it easier for people to check the vote from certain address. This has the following assumptions:", "Weights": "We assume there areweightof votes and can be checked by callingeligibleVotingWeight(proposalId, address voter), and the weight distribution is either internally determined or determined by constructor.", "Backwards Compatibility": "We expect the voting standard to be used in connection with other contracts such as token distributions, conducting actions in consensus or on behalf of an entity, multi-signature wallets, etc.", "Security Considerations": "We expect the voting standard to be used in connection with other contracts such as token distributions, conducting actions in consensus or on behalf of an entity, multi-signature wallets, etc.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3770, "url": "https://eips.ethereum.org/EIPS/eip-3770", "title": "Chain-specific addresses", "authors": ["Lukas Schor\u00a0(", "@lukasschor", ")", "Richard Meissner\u00a0(", "@rmeissner", ")", "Pedro Gomes\u00a0(", "@pedrouid", ")", "ligi\u00a0<", "ligi@ligi.de", ">"], "sections": {"ERC-3770: Chain-specific addresses": "ERC-3770introduces a new address standard to be adapted by wallets and dApps to display chain-specific addresses by using a human-readable prefix.", "Prepending chain-specific addresses with a human-readable chain identifier": "ERC-3770introduces a new address standard to be adapted by wallets and dApps to display chain-specific addresses by using a human-readable prefix.", "Abstract": "ERC-3770introduces a new address standard to be adapted by wallets and dApps to display chain-specific addresses by using a human-readable prefix.", "Motivation": "The need for this proposal emerges from the increasing adoption of non-Ethereum Mainnet chains that use the Ethereum Virtual Machine (EVM). In this context, addresses become ambiguous, as the same address may refer to an EOA on chain X or a smart contract on chain Y. This will eventually lead to Ethereum users losing funds due to human error. For example, users sending funds to a smart contract wallet address which was not deployed on a particular chain.", "Specification": "This proposal extends addresses with a human-readable blockchain short name.", "Syntax": "A chain-specific address is prefixed with a chain shortName, separated with a colon sign (:).", "Semantics": "", "Examples": "", "Rationale": "To solve the initial problem of user-facing addresses being ambiguous in a multichain context, we need to map EIP-155 chain IDs with a user-facing format of displaying chain identifiers.", "Backwards Compatibility": "Ethereum addresses without the chain specifier will continue to require additional context to understand which chain the address refers to.", "Security Considerations": "Similar looking chain short names can be used to confuse users.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4337, "url": "https://eips.ethereum.org/EIPS/eip-4337", "title": "Account Abstraction Using Alt Mempool", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Yoav Weiss\u00a0(", "@yoavw", ")", "Dror Tirosh\u00a0(", "@drortirosh", ")", "Shahaf Nacson\u00a0(", "@shahafn", ")", "Alex Forshtat\u00a0(", "@forshtat", ")", "Kristof Gazso\u00a0(", "@kristofgazso", ")", "Tjaden Hess\u00a0(", "@tjade273", ")"], "sections": {"ERC-4337: Account Abstraction Using Alt Mempool": "An account abstraction proposal which completely avoids the need for consensus-layer protocol changes. Instead of adding new protocol features and changing the bottom-layer transaction type, this proposal instead introduces a higher-layer pseudo-transaction object called aUserOperation. Users sendUserOperationobjects into a separate mempool. A special class of actor called bundlers package up a set of these objects into a transaction making ahandleOpscall to a special contract, and that transaction then gets included in a block.", "An account abstraction proposal which completely avoids consensus-layer protocol changes, instead relying on higher-layer infrastructure.": "An account abstraction proposal which completely avoids the need for consensus-layer protocol changes. Instead of adding new protocol features and changing the bottom-layer transaction type, this proposal instead introduces a higher-layer pseudo-transaction object called aUserOperation. Users sendUserOperationobjects into a separate mempool. A special class of actor called bundlers package up a set of these objects into a transaction making ahandleOpscall to a special contract, and that transaction then gets included in a block.", "Abstract": "An account abstraction proposal which completely avoids the need for consensus-layer protocol changes. Instead of adding new protocol features and changing the bottom-layer transaction type, this proposal instead introduces a higher-layer pseudo-transaction object called aUserOperation. Users sendUserOperationobjects into a separate mempool. A special class of actor called bundlers package up a set of these objects into a transaction making ahandleOpscall to a special contract, and that transaction then gets included in a block.", "Motivation": "See alsohttps://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020and the links therein for historical work and motivation, andEIP-2938for a consensus layer proposal for implementing the same goal.", "Specification": "To avoid Ethereum consensus changes, we do not attempt to create new transaction types for account-abstracted transactions. Instead, users package up the action they want their Smart Contract Account to take in a struct namedUserOperation:", "Definitions": "To avoid Ethereum consensus changes, we do not attempt to create new transaction types for account-abstracted transactions. Instead, users package up the action they want their Smart Contract Account to take in a struct namedUserOperation:", "UserOperation": "To avoid Ethereum consensus changes, we do not attempt to create new transaction types for account-abstracted transactions. Instead, users package up the action they want their Smart Contract Account to take in a struct namedUserOperation:", "EntryPointinterface": "When passed on-chain, to theEntryPointcontract, theAccountand thePaymaster, a \u201cpacked\u201d version of the above structure calledPackedUserOperationis used:", "Smart Contract Account Interface": "The core interface required for the Smart Contract Account to have is:", "Semi-abstracted Nonce Support": "In Ethereum protocol, the sequential transactionnoncevalue is used as a replay protection method as well as to\ndetermine the valid order of transaction being included in blocks.", "RequiredEntryPointcontract functionality": "TheEntryPointmethod ishandleOps, which handles an array ofUserOperations", "JSON-RPC API forERC-4337": "In order to support sendingUserOperationobjects to bundlers, which in turn propagate them through the P2P mempool,\nwe introduce a set of JSON-RPC APIs includingeth_sendUserOperationandeth_getUserOperationReceipt.", "Support forEIP-712signatures": "TheuserOpHashis calculated as an [EIP-712] typed message hash with the following parameters:", "Support forEIP-7702authorizations": "On networks withEIP-7702enabled, theeth_sendUserOperationmethod accepts an extraeip7702Authparameter.\nIf this parameter is set, it MUST be a validEIP-7702authorization tuple, and signed by thesenderaddress.\nThe bundler MUST add all requiredeip7702Authof allUserOperationsin a bundle to theauthorizationListand execute\nthe bundle using a transaction typeSET_CODE_TX_TYPE.\nAdditionally, theUserOperationhash calculation is updated to include the desiredEIP-7702delegation address.", "Extension: paymasters": "We extend theEntryPointlogic to supportpaymastersthat can sponsor transactions for other users. This feature can be used to allow application developers to subsidize fees for their users, allow users to pay fees with [ERC-20] tokens and many other use cases. When thepaymasterAndDatafield in theUserOperationis not empty, theEntryPointimplements a different flow for that UserOperation:", "Bundler behavior upon receiving a UserOperation": "", "UserOperation Simulation": "We defineUserOperationsimulation, as the offchain view call (or trace call) to theEntryPointcontract with theUserOperation, and the enforcement ofERC-7562rules, as part of theUserOperationvalidation.", "EstimatingpreVerificationGas": "This document does not specify a canonical way to estimate this value,\nas it depends on non-permanent network properties such as operation and data gas pricing and the expected bundle size.", "Alternative Mempools": "The simulation rules above are strict and prevent the ability of paymasters to grief the system.\nHowever, there might be use cases where specific paymasters can be validated\n(through manual auditing) and verified that they cannot cause any problem, while still require relaxing of the opcode rules.\nA bundler cannot simply \u201cwhitelist\u201d a request from a specific paymaster: if that paymaster is not accepted by all\nbundlers, then its support will be sporadic at best.\nInstead, we introduce the term \u201calternate mempool\u201d: a modified validation rules, and procedure of propagating them to other bundlers.", "Bundling": "Bundling is the process where a node/bundler collects multipleUserOperationsand creates a single transaction to submit on-chain.", "Error codes.": "While performing validation, theEntryPointmust revert on failures. During simulation, the calling bundler MUST be able to determine which entity (sender,factoryorpaymaster) caused the failure.\nThe attribution of a revert to an entity is done using call-tracing: the last entity called by theEntryPointprior to the revert is the entity that caused the revert.", "Rationale": "The main challenge with a purely \u201cSmart Contract Accounts\u201d based Account Abstraction system is DoS safety: how can a block builder including an operation make sure that it will actually pay fees, without having to first execute the entire operation?\nRequiring the block builder to execute the entire operation opens a DoS attack vector, as an attacker could easily send many operations that pretend to pay a fee but then revert at the last moment after a long execution.\nSimilarly, to prevent attackers from cheaply clogging the mempool, nodes in the P2P network need to check if an operation will pay a fee before they are willing to forward it.", "Validation Rules Rationale": "The next step is protecting the bundlers from denial-of-service attacks by a mass number ofUserOperationsthat appear to be valid (and pay) but that eventually revert, and thus block the bundler from processing validUserOperations.", "Reputation Rationale": "UserOperation\u2019s storage access rules prevent them from interfering with each other.\nBut \u201cglobal\u201d entities - paymasters and factories are accessed by multipleUserOperations, and thus might invalidate multiple previously validUserOperations.", "Reputation scoring and throttling/banning for global entities": "[ERC-7562] defines a set of rules a bundler must follow when acceptingUserOperationsinto the mempool.\nIt also describes the \u201creputation\u201d", "Paymasters": "Paymaster contracts allow the abstraction of gas: having a contract, that is not the sender of the transaction, to pay for the transaction fees.", "First-time Smart Contract Account creation": "NOTE: for contracts using EIP-7702 this flow is described inSupport for [EIP-7702] authorizations.", "Backwards Compatibility": "This ERC does not change the consensus layer, so there are no backwards compatibility issues for Ethereum as a whole. Unfortunately it is not easily compatible with pre-ERC-4337Smart Contract Accounts, because those Accounts do not have avalidateUserOpfunction. If the Smart Contract Account has a function for authorizing a trustedUserOperationsubmitter, then this could be fixed by creating anERC-4337compatible Account that re-implements the verification logic as a wrapper and setting it to be the original Account\u2019s trustedUserOperationsubmitter.", "Reference Implementation": "Seehttps://github.com/eth-infinitism/account-abstraction/tree/main/contracts", "Security Considerations": "TheEntryPointcontract will need to be audited and formally verified, because it will serve as a central trust point forall[ERC-4337]. In total, this architecture reduces auditing and formal verification load for the ecosystem, because the amount of work that individualaccountshave to do becomes much smaller (they need only verify thevalidateUserOpfunction and its \u201ccheck signature and pay fees\u201d logic) and check that other functions aremsg.sender == ENTRY_POINTgated (perhaps also allowingmsg.sender == self), but it is nevertheless the case that this is done precisely by concentrating security risk in theEntryPointcontract that needs to be verified to be very robust.", "Factory contracts": "Allfactorycontracts MUST check that all calls to thecreateAccount()function originate from theentryPoint.senderCreator()address.", "Paymasters contracts": "Allpaymastercontracts MUST check that all calls to thevalidatePaymasterUserOp()andpostOp()functions originate from theEntryPoint.", "Aggregator contracts": "Allpaymastercontracts MUST check that all calls to thevalidateSignatures()function originates from theEntryPoint.", "EIP-7702 delegated Smart Contract Accounts": "All EIP-7702 delegated Smart Contract Account implementations MUST check that all calls to the initialization function originate from theentryPoint.senderCreator()address.", "Smart Contract Accounts": "It is expected that most of ERC-4337 Smart Contract Account will be upgradeable,\neither via on-chain delegate proxy contracts or via EIP-7702.", "Transient Storage": "Contracts using theEIP-1153transient storage MUST take into account that ERC-4337 allows multipleUserOperationsfrom different unrelatedsenderaddresses to be included in the same underlying transaction.\nThe transient storage MUST be cleaned up manually if contains any sensitive information or is used for access control.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- magic: A constant value set as 0xef0100 used in the CREATE_DELEGATE instruction."}
{"eip": 4883, "url": "https://eips.ethereum.org/EIPS/eip-4883", "title": "Composable SVG NFT", "authors": ["Andrew B Coathup\u00a0(", "@abcoathup", ")", "Alex\u00a0(", "@AlexPartyPanda", ")", "Damian Martinelli\u00a0(", "@damianmarti", ")", "blockdev\u00a0(", "@0xbok", ")", "Austin Griffith\u00a0(", "@austintgriffith", ")"], "sections": {"ERC-4883: Composable SVG NFT": "Compose an SVG (Scalable Vector Graphics) NFT by concatenating the SVG with the SVG of another NFT rendered as a string for a specific token ID.", "Compose an SVG NFT by concatenating the SVG with the rendered SVG of another NFT.": "Compose an SVG (Scalable Vector Graphics) NFT by concatenating the SVG with the SVG of another NFT rendered as a string for a specific token ID.", "Abstract": "Compose an SVG (Scalable Vector Graphics) NFT by concatenating the SVG with the SVG of another NFT rendered as a string for a specific token ID.", "Motivation": "Onchain SVG NFTs allow for NFTs to be entirely onchain by returning artwork as SVG in a data URI of thetokenUrifunction. Composability allows onchain SVG NFTs to be crafted. e.g. adding glasses & hat NFTs to a profile pic NFT or a fish NFT to a fish tank NFT.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "SVG elements can be string concatenated to compose an SVG.", "Ordering of concatenation": "SVG uses a \u201cpainters model\u201d of rendering.", "Alternatives to concatenation": "SVG specifies alinktag.  Linking could allow for complex SVGs to be composed but would require creating a URI format and then getting ecosystem adoption.  As string concatenation of SVG\u2019s is already supported, the simpler approach of concatenation is used.", "Sizing": "This EIP doesn\u2019t specify any requirements on the size of the rendered SVG.  Any scaling based on sizing can be performed by the SVG NFT as required.", "Render function name": "The render function is namedrenderTokenByIdas this function name was first used by Loogies and allows existing deployed NFTs to be compatible with this EIP.", "Backwards Compatibility": "This EIP has no backwards compatibility concerns", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4972, "url": "https://eips.ethereum.org/EIPS/eip-4972", "title": "Name-Owned Account", "authors": ["Shu Dong\u00a0(", "@dongshu2013", ")", "Qi Zhou\u00a0(", "@qizhou", ")", "Zihao Chen\u00a0(", "@zihaoccc", ")"], "sections": {"ERC-4972: Name-Owned Account": "The ERC suggests expanding the capabilities of the name service, such as ENS, by enabling each human-readable identity to be linked to a single smart contract account that can be controlled by the owner of the name identity.", "Name-Owned Account for Social Identity": "The ERC suggests expanding the capabilities of the name service, such as ENS, by enabling each human-readable identity to be linked to a single smart contract account that can be controlled by the owner of the name identity.", "Abstract": "The ERC suggests expanding the capabilities of the name service, such as ENS, by enabling each human-readable identity to be linked to a single smart contract account that can be controlled by the owner of the name identity.", "Motivation": "Name itself cannot hold any context. We want to build an extension of name service to give name rich context by offering each name owner an extra ready to use smart contract account, which may help the general smart contract account adoption. With NOA, it is possible to hold assets and information for its name node, opening up new use cases such as name node transfers, which involve transferring ownership of the name node as well as the NOA, including any assets and information it holds.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Name-Owned Account": "An NOA has", "Interface": "The core interface required for a name service to have is:", "Rationale": "To achieve a one-to-one mapping from the name to the NOA, where each NOA\u2019s address is derived from the name node, we must include the name node information in each NOA to reflect its name node ownership. The \u201cname()\u201d function can be used to retrieve this property of each NOA and enable reverse tracking to its name node. The \u201cnameService()\u201d function can get the name service contract address where the name is registered, to perform behaviors such as validation checks. Through these two methods, the NOA has the ability to track back to its actual owner who owns the name node.", "Backwards Compatibility": "The name registry interface is compatible with ERC-137.", "Reference Implementation": "The NOA creation is done by a \u201cfactory\u201d contract. The factory could be the name service itself and is expected to use CREATE2 (not CREATE) to create the NOA. NOAs should have identical initcode and factory contract in order to achieve deterministic preservation of address. The name node can be used as the salt to guarantee the bijection from name to its owned account.", "Name Owned Account Creation": "The NOA creation is done by a \u201cfactory\u201d contract. The factory could be the name service itself and is expected to use CREATE2 (not CREATE) to create the NOA. NOAs should have identical initcode and factory contract in order to achieve deterministic preservation of address. The name node can be used as the salt to guarantee the bijection from name to its owned account.", "Security Considerations": "No security considerations were found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- initcode: The code executed by a contract at its initialization, which must be within 49152 bytes in size before EIP-3860.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5115, "url": "https://eips.ethereum.org/EIPS/eip-5115", "title": "SY Token", "authors": ["Vu Nguyen\u00a0(", "@mrenoon", ")", "Long Vuong\u00a0(", "@UncleGrandpa925", ")", "Anton Buenavista\u00a0(", "@ayobuenavista", ")"], "sections": {"ERC-5115: SY Token": "This standard proposes an API for wrapped yield-bearing tokens within smart contracts. It is an extension on theERC-20token that provides basic functionality for transferring, depositing, withdrawing tokens, as well as reading balances.", "Interface for wrapped yield-bearing tokens.": "This standard proposes an API for wrapped yield-bearing tokens within smart contracts. It is an extension on theERC-20token that provides basic functionality for transferring, depositing, withdrawing tokens, as well as reading balances.", "Abstract": "This standard proposes an API for wrapped yield-bearing tokens within smart contracts. It is an extension on theERC-20token that provides basic functionality for transferring, depositing, withdrawing tokens, as well as reading balances.", "Motivation": "Yield generating mechanisms are built in all shapes and sizes, necessitating a manual integration every time a protocol builds on top of another protocol\u2019s yield generating mechanism.", "Use Cases": "This ERC is designed for flexibility, aiming to accommodate as many yield generating mechanisms as possible. Particularly, this standard aims to be generalized enough that it supports the following use cases and more:", "Specification": "We will first introduce Generic Yield Generating Pool (GYGP), a model to describe most yield generating mechanisms in DeFi. In every yield generating mechanism, there is a pool of funds, whose value is measured inassets. There are a number of users who contribute liquidity to the pool, in exchange forsharesof the pool, which represents units of ownership of the pool. Over time, the value (measured inassets) of the pool grows, such that eachshareis worth moreassetsover time. The pool could earn a number ofreward tokensover time, which are distributed to the users according to some logic (for example, proportionally the number ofshares).", "Generic Yield Generating Pool": "We will first introduce Generic Yield Generating Pool (GYGP), a model to describe most yield generating mechanisms in DeFi. In every yield generating mechanism, there is a pool of funds, whose value is measured inassets. There are a number of users who contribute liquidity to the pool, in exchange forsharesof the pool, which represents units of ownership of the pool. Over time, the value (measured inassets) of the pool grows, such that eachshareis worth moreassetsover time. The pool could earn a number ofreward tokensover time, which are distributed to the users according to some logic (for example, proportionally the number ofshares).", "Standardized Yield Token Standard": "Standardized Yield (SY) is a token standard for any yield generating mechanism that conforms to the GYGP model. Each SY token representssharesin a GYGP and allows for interacting with the GYGP via a standard interface.", "Rationale": "ERC-20is enforced because implementation details such as transfer, token approvals, and balance calculation directly carry over to the SY tokens. This standardization makes the SY tokens immediately compatible with all ERC-20 use cases.", "Backwards Compatibility": "This ERC is fully backwards compatible as its implementation extends the functionality ofERC-20, however the optional metadata extensions, namelyname,decimals, andsymbolsemantics MUST be implemented for all SY token implementations.", "Security Considerations": "Malicious implementations which conform to the interface can put users at risk. It is recommended that all integrators (such as wallets, aggregators, or other smart contract protocols) review the implementation to avoid possible exploits and users losing funds.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5173, "url": "https://eips.ethereum.org/EIPS/eip-5173", "title": "NFT Future Rewards (nFR)", "authors": ["Yale ReiSoleil\u00a0(", "@longnshort", ")", "dRadiant\u00a0(", "@dRadiant", ")", "D Wang", "PhD\u00a0<", "david@iob.fi", ">"], "sections": {"ERC-5173: NFT Future Rewards (nFR)": "This proposal introduces the Non-Fungible Future Rewards (nFR) framework, extendingERC-721tokens (NFTs) features to let token holders benefit from value appreciation after transferring ownership. By integrating cooperative game theory, it aligns stakeholder incentives, addressing inefficiencies in asset transactions. The framework fosters collaboration, transparency, and equitable profit sharing. It improves equity and efficiency, recognizes all ownership stages, and establishes a cooperative asset transaction model.", "A multigenerational reward mechanism that rewards\u200c all \u200cowners of non-fungible tokens (NFT).": "This proposal introduces the Non-Fungible Future Rewards (nFR) framework, extendingERC-721tokens (NFTs) features to let token holders benefit from value appreciation after transferring ownership. By integrating cooperative game theory, it aligns stakeholder incentives, addressing inefficiencies in asset transactions. The framework fosters collaboration, transparency, and equitable profit sharing. It improves equity and efficiency, recognizes all ownership stages, and establishes a cooperative asset transaction model.", "Abstract": "This proposal introduces the Non-Fungible Future Rewards (nFR) framework, extendingERC-721tokens (NFTs) features to let token holders benefit from value appreciation after transferring ownership. By integrating cooperative game theory, it aligns stakeholder incentives, addressing inefficiencies in asset transactions. The framework fosters collaboration, transparency, and equitable profit sharing. It improves equity and efficiency, recognizes all ownership stages, and establishes a cooperative asset transaction model.", "Motivation": "Traditional financial markets are often characterized by inefficiencies, opaque practices, and systemic imbalances, resulting in significant disadvantages for the majority of participants. Although blockchain technology offers transaction transparency, current implementations do not adequately facilitate equitable value sharing or participant alignment. This proposal addresses these gaps by introducing structured collaboration and a fair compensation system, ensuring equitable rewards for contributions to asset value.", "Framework Components": "EachERC-5173token maintains an immutable record of ownership and price transitions, creating a dedicated network of historical token owners. This unique community collaborates to generate additional value and maintains vested interest in the project or token even after selling, ensuring contributors benefit from the asset\u2019s appreciation. This mechanism promotes collaborative value creation, equitable profit sharing, and a connected financial ecosystem, distinct from traditional financial market systems.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Percent Fixed Point": "TheallocatedFRMUST be calculated using a percentage fixed point with a scaling factor of 1e18 (X/1e18) - such as \u201c5e16\u201d - for 5%. This is REQUIRED to maintain uniformity across the standard. The max and min values would be - 1e18 - 1.", "Default FR Info": "A defaultFRInfoMUST be stored in order to be backward compatible withERC-721mint functions. It MAY also have a function to update theFRInfo, assuming it has not been hard-coded.", "ERC-721 Overrides": "An nFR-compliant smart contract MUST override theERC-721_mint,_transfer, and_burnfunctions. When overriding the_mintfunction, a default FR model is REQUIRED to be established if the mint is to succeed when calling theERC-721_mintfunction and not the nFR_mintfunction. It is also to update the owner amount and directly add the recipient address to the FR cycle. When overriding the_transferfunction, the smart contract SHALL consider the NFT as sold for 0 ETH, and update the state accordingly after a successful transfer. This is to prevent FR circumvention. Additionally, the_transferfunction SHALL prevent the caller from transferring the token to themselves or an address that is already in the FR sliding window, this can be done through a require statement that ensures that the sender or an address in the FR sliding window is not the recipient, otherwise, it\u2019d be possible to fill up the FR sequence with one\u2019s own address or duplicate addresses. Finally, when overriding the_burnfunction, the smart contract SHALL delete theFRInfoandListInfocorresponding to that Token ID after a successful burn.", "Safe Transfers": "If the wallet/broker/auction application will accept safe transfers, then it MUST implement theERC-721wallet interface.", "Listing, Unlisting, and Buying": "Thelist,unlist, andbuyfunctions MUST be implemented, as they provide the capability to sell a token.", "Future Rewards_transferFromFunction": "The FR_transferFromfunction MUST be called by all nFR-supporting smart contracts, though the accommodations for non-nFR-supporting contracts MAY also be implemented to ensure backwards compatibility.", "Future Rewards Calculation": "Marketplaces that support this standard MAY implement various methods of calculating or transferring Future Rewards to the previous owners.", "Future Rewards Distribution": "", "Future Rewards Claiming": "The future Rewards payments SHOULD utilize a pull-payment model, similar to that demonstrated by OpenZeppelin with their PaymentSplitter contract. The event  FRClaimed would be triggered after a successful claim has been made.", "Owner Generation Shifting": "The_shiftGenerationsfunction MUST be called regardless of whether the sale was profitable or not. As a result, it will be called in the_transferERC-721override function and the FRtransferFromfunction. The function SHALL remove the oldest account from the corresponding_addressesInFRarray. This calculation will take into account the current length of the array versus the total number of generations for a given token ID.", "Rationale": "Considering Fixed-Point Arithmetic is to be enforced, it is logical to have 1e18 represent 100% and 1e16 represent 1% for Fixed-Point operations. This method of handling percents is also commonly seen in many Solidity libraries for Fixed-Point operations.", "Fixed Percentage to 10^18": "Considering Fixed-Point Arithmetic is to be enforced, it is logical to have 1e18 represent 100% and 1e16 represent 1% for Fixed-Point operations. This method of handling percents is also commonly seen in many Solidity libraries for Fixed-Point operations.", "Emitting Event for Payment": "Since each NFT contract is independent, and while a marketplace contract can emit events when an item is sold, choosing to emit an event for payment is important. As the royalty and FR recipient may not be aware of/watching for a secondary sale of their NFT, they would never know that they received a payment except that their ETH wallet has been increased randomly.", "Number of Generations of All Owners ( n ) vs Number of Generations of Only Profitable Owners": "It is the number of generations of all owners, not just those who are profitable, that determines the number of owners from which the subsequent owners\u2019 profits will be shared, seeFigure 3. As part of the effort to discourage \u201cownership hoarding,\u201d Future Rewards distributions will not be made to the current owner/purchaser if all the owners lose money holding the NFT. Further information can be found under Security Considerations.", "Single vs Multigenerations": "In a single generation reward, the new buyer/owner receives a share of the next single generation\u2019s realized profit only. In a multigenerational reward system, buyers will have future rewards years after their purchase. The NFT should have a long-term growth potential and a substantial dividend payout would be possible in this case.", "Direct FR Payout by the Seller vs Smart Contract-managed Payout": "FR payouts directly derived from the sale proceeds are immediate and final. As part of the fraud detection detailed later in the Security Considerations section, we selected a method in which the smart contract calculates all the FR amounts for each generation of previous owners, and handles payout according to other criteria set by the marketplace, such as reduced or delayed payments for wallet addresses with low scores, or a series of consecutive orders detected using a time-heuristic analysis.", "Equal vs Linear Reward Distributions": "", "Backwards Compatibility": "This proposal is fully compatible with currentERC-721standards andERC-2981. It can also be easily adapted to work withERC-1155.", "Test Cases": "This contractcontains the reference implementation for this proposal.", "Reference Implementation": "This implementation uses OpenZeppelin contracts and the PRB Math library created by Paul R Berg for fixed-point arithmetic. It demonstrates the interface for the nFR standard, an nFR standard-compliant extension, and anERC-721implementation using the extension.", "Distribution of NFT Royalties to Artists and Creators": "We agree that artists\u2019 royalties should be uniform and on-chain. We supportERC-2981NFT royalty Standard proposal.", "Distribution of NFT Owners\u2019 Future Rewards (FRs)": "Any realized profits (P) when an NFT is sold are distributed among the buyers/owners. The previous owners will take a fixed portion of the profit (P), and this portion is called Future Rewards (FRs). The seller takes the rest of the profits.", "Security Considerations": "As this ERC introduces royalty and realized profit rewards collection, distribution, and payouts to the ERC-721 standard, the attack vectors increase. As discussed by Andreas Freund regarding mitigations to phishing attacks, we recommend reentrancy protection for all payment functions to reduce the most significant attack vectors for payments and payouts.", "Payment Attacks": "As this ERC introduces royalty and realized profit rewards collection, distribution, and payouts to the ERC-721 standard, the attack vectors increase. As discussed by Andreas Freund regarding mitigations to phishing attacks, we recommend reentrancy protection for all payment functions to reduce the most significant attack vectors for payments and payouts.", "Royalty Circumventing": "Many methods are being used to avoid paying royalties to creators under the currentERC-721standard. Through an under-the-table transaction, the new buyer\u2019s cost basis will be reduced to zero, increasing their FR liability to the full selling price. Everyone, either the buyer or seller, would pay a portion of the previous owner\u2019s net realized profits ( P x r ). Acting in his or her own interests, the buyer rejects any loyalty circumventing proposal.", "FR Hoarding through Wash Sales": "Quantexa blog and beincrypto articles have reported widespread wash trading on all unregulated cryptocurrency trading platforms and NFT marketplaces. The use of wash trading by dishonest actors can lead to an unfair advantage, as well as inflated prices and money laundering. When a single entity becomes multiple generations of owners to accumulate more rewards in the future, the validity of the system is undermined.", "Long/Cyclical FR-Entitled Owner Generations": "In most cases, malicious actors will create excessively long or cyclical Future Rewards Owner Generations that will result in applications that attempt to distribute FR or shift generations running out of gas and not functioning. Therefore, clients are responsible for verifying that the contract with which they interact has an appropriate number of generations, so that looping over will not deplete the gas.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5189, "url": "https://eips.ethereum.org/EIPS/eip-5189", "title": "Account Abstraction via Endorsed Operations", "authors": ["Agust\u00edn Aguilar\u00a0(", "@agusx1211", ")", "Philippe Castonguay\u00a0(", "@phabc", ")", "Michael Standen\u00a0(", "@ScreamingHawk", ")"], "sections": {"ERC-5189: Account Abstraction via Endorsed Operations": "This ERC proposes a form of account abstraction (AA) that ensures compatibility with existing smart contract wallets and provides flexibility for alternative designs while avoiding introducing changes to the consensus layer. Instead of defining a strict structure for AA transactions, this proposal introduces the figure ofendorsercontracts. These smart contract instances are tasked with determining the quality of the submitted AA transactions, thus safely helping bundlers determine if a transaction should be kept in the mempool or not. Developers that intend to make their smart contract wallet compatible with this ERC must create and deploy an instance of anendorseror use an existing one compatible with their wallet.", "An account abstraction proposal that avoids protocol changes while maintaining compatibility with existing smart contract wallets.": "This ERC proposes a form of account abstraction (AA) that ensures compatibility with existing smart contract wallets and provides flexibility for alternative designs while avoiding introducing changes to the consensus layer. Instead of defining a strict structure for AA transactions, this proposal introduces the figure ofendorsercontracts. These smart contract instances are tasked with determining the quality of the submitted AA transactions, thus safely helping bundlers determine if a transaction should be kept in the mempool or not. Developers that intend to make their smart contract wallet compatible with this ERC must create and deploy an instance of anendorseror use an existing one compatible with their wallet.", "Abstract": "This ERC proposes a form of account abstraction (AA) that ensures compatibility with existing smart contract wallets and provides flexibility for alternative designs while avoiding introducing changes to the consensus layer. Instead of defining a strict structure for AA transactions, this proposal introduces the figure ofendorsercontracts. These smart contract instances are tasked with determining the quality of the submitted AA transactions, thus safely helping bundlers determine if a transaction should be kept in the mempool or not. Developers that intend to make their smart contract wallet compatible with this ERC must create and deploy an instance of anendorseror use an existing one compatible with their wallet.", "Motivation": "This account abstraction proposal aims to implement a generalized system for executing AA transactions while maintaining the following goals:", "Specification": "To avoid Ethereum consensus changes, we do not attempt to create new transaction types for account-abstracted transactions. Instead, AA transactions are packed up in a struct calledOperation, operations are structs composed by the following fields:", "Endorser functionality": "Mempool participants need to be able to able to filter \u201cgood operations\u201d (operations that pay the bundler the defined fee) from \u201cbad operations\u201d (operations that either miss payment or revert altogether).", "Global Dependencies": "TheendorserMUST use themaxBlockNumberandmaxBlockTimestampfields to limit the validity of thereadinessresult. This is useful for operations that are only valid for a certain period of time.", "Dependencies": "Theendorserdoes not need to include all accessed storage slots on the dependencies list, it only needs to include storage slots that after a change may also result in a change of readiness.", "Simulation settings": "ThesimulationSettingsmethod returns a list of replacements that the bundler should apply to the operation before simulating theisOperationReady. Note that these replacements are only used forisOperationReadysimulation and are not applied when simulating the operation itself.", "Misbehavior detection": "It is possible forendorsercontracts to behave maliciously or erratically in the following ways:", "Untrusted environment": "In some scenarios, theendorsermay not be able to fully validate theoperationbut may be able to infer that a given code pathshouldbe safe. In these cases, the endorser can mark a section of the operation asuntrusted. Any storage slots (balance, code, nonce, or specific slots) accessed in this untrusted context should be automatically considered as dependencies.", "Fee payment": "TheendorserMUST guarantee that the operation will repay at least the spent gas totx.origin.", "Operation identification": "Operations can be identified by their operation hash, which is calculated as a CIDv1 multihash of arawfile, containing the canonical JSON representation of the operation. This hash is never used on-chain, but it serves as a unique pointer to the operation that can be shared across systems.", "Bundler behavior upon receiving an operation": "Bundlers can add their own rules for how to ensure the successful relaying of AA transactions and for getting paid for relaying these transactions. However, we propose here a baseline specification that should be sufficient.", "Evaluation": "To evaluate theoperation, the bundler MUST callsimulationSettings()on theendorserto obtain simulation setting values. The bundler MUST apply the settings andsimulatea call toisOperationReady()on theendorser. If the endorser considers the operation ready, and the constraints are within bounds, then the client MUST add the operation to the mempool. Otherwise, the operation MUST be dropped.", "Optional rules": "Mempool clients MAY implement additional rules to further protect against maliciously constructed transactions.", "After operation inclusion": "There is no limit in-place that defines that an operation can only be executed once.", "Endorser registry": "The endorser registry serves as a place to register the burn of each endorser, anyone can increase the burn of any endorser by calling theaddBurn()function.", "Rationale": "The main challenge with a purely smart contract wallet-based account abstraction system is DoS safety: how can a bundler that includes an operation make sure it will be paid without executing the entire operation?", "Griefing protection": "The main challenge with a purely smart contract wallet-based account abstraction system is DoS safety: how can a bundler that includes an operation make sure it will be paid without executing the entire operation?", "Burned ETH": "Anyone can deploy a endorser contract and wallet clients are the one providing which endorser contract should be used for the given transaction. Instead of having each bundler rely on an off-chain registry that they need to maintain, the endorser registry can be called to see if the requested endorser contract is present and how much ETH was burned for it. Bundlers can then decide a minimum treshshold for how much ETH burnt is required for an endorser contract to be accepted. Bundlers are also free to support endorsers contract that are not part of the registry or are part of it but have no ETH burned associated.", "Minimum overhead": "Since the validation of an AA transactions is done off-chain by the bundler rather than at execution time, there is no additional gas fee overhead for executing transactions. The bundler bears the risk rather than all users having to pay for that security.", "Differences with alternative proposals": "This ERC does not change he consensus layer, nor does impose changes on existing smart contract wallets, so there are no backwards compatibility issues.", "Backwards Compatibility": "This ERC does not change he consensus layer, nor does impose changes on existing smart contract wallets, so there are no backwards compatibility issues.", "Security Considerations": "This ERC does not make changes to on-chain interactions. Endorsers are explicitly for off-chain validations.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding."}
{"eip": 5485, "url": "https://eips.ethereum.org/EIPS/eip-5485", "title": "Legitimacy, Jurisdiction and Sovereignty", "authors": ["Zainan Victor Zhou\u00a0(", "@xinbenlv", ")"], "sections": {"ERC-5485: Legitimacy, Jurisdiction and Sovereignty": "Provide a way for compliant smart contracts to declare their legitimacy lineage, jurisdiction they observe, and sovereignty if they choose to not fall onto any jurisdiction.", "An interface for identifying the legitimacy, jurisdiction and sovereignty.": "Provide a way for compliant smart contracts to declare their legitimacy lineage, jurisdiction they observe, and sovereignty if they choose to not fall onto any jurisdiction.", "Abstract": "Provide a way for compliant smart contracts to declare their legitimacy lineage, jurisdiction they observe, and sovereignty if they choose to not fall onto any jurisdiction.", "Motivation": "Today, smart contracts have no standard way to specify their legitimacy lineage, jurisdiction, or sovereignty relationship. The introduction of such a standard, supports better integration with today\u2019s legal and regulative scenarios:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "Needs discussion.", "Backwards Compatibility": "Needs discussion.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5573, "url": "https://eips.ethereum.org/EIPS/eip-5573", "title": "Sign-In with Ethereum Capabilities, ReCaps", "authors": ["Oliver Terbu\u00a0(", "@awoie", ")", "Jacob Ward\u00a0(", "@cobward", ")", "Charles Lehner\u00a0(", "@clehner", ")", "Sam Gbafa\u00a0(", "@skgbafa", ")", "Wayne Chang\u00a0(", "@wyc", ")", "Charles Cunningham\u00a0(", "@chunningham", ")"], "sections": {"ERC-5573: Sign-In with Ethereum Capabilities, ReCaps": "ERC-4361, or Sign-In with Ethereum (SIWE), describes how Ethereum accounts authenticate with off-chain services. This proposal, known as ReCaps, describes a mechanism on top of SIWE to give informed consent to authorize a Relying Party to exercise certain scoped capabilities. How a Relying Party authenticates against the target resource is out of scope for this specification and depends on the implementation of the target resource.", "Mechanism on top of Sign-In with Ethereum for informed consent to delegate capabilities with an extensible scope mechanism": "ERC-4361, or Sign-In with Ethereum (SIWE), describes how Ethereum accounts authenticate with off-chain services. This proposal, known as ReCaps, describes a mechanism on top of SIWE to give informed consent to authorize a Relying Party to exercise certain scoped capabilities. How a Relying Party authenticates against the target resource is out of scope for this specification and depends on the implementation of the target resource.", "Abstract": "ERC-4361, or Sign-In with Ethereum (SIWE), describes how Ethereum accounts authenticate with off-chain services. This proposal, known as ReCaps, describes a mechanism on top of SIWE to give informed consent to authorize a Relying Party to exercise certain scoped capabilities. How a Relying Party authenticates against the target resource is out of scope for this specification and depends on the implementation of the target resource.", "Motivation": "SIWE ReCaps unlock integration of protocols and/or APIs for developers by reducing user friction, onchain state and increasing security by introducing informed consent and deterministic capability objects on top of Sign-In With Ethereum (ERC-4361).", "Specification": "This specification has three different audiences:", "Terms and Definitions": "This specification defines the following:", "Overview": "This specification defines the following:", "ReCap SIWE Extension": "A ReCap is an ERC-4361 message following a specific format that allows an Ethereum account to delegate a set of ReCap Capabilities to a Relying Party through informed consent. ReCap Capabilities MUST be represented by the final entry in theResourcesarray of the SIWE message that MUST deterministically translate the ReCap Capability in human-readable form to thestatementfield in the SIWE message using the ReCap Translation Algorithm.", "Implementer\u2019s Guide": "TBD", "Rationale": "TBD", "Security Considerations": "Resource service implementer\u2019s should not consider ReCaps as bearer tokens but instead require to authenticate the Relying Party in addition. The process of authenticating the Relying Party against the resource service is out of scope of this specification and can be done in various different ways.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5604, "url": "https://eips.ethereum.org/EIPS/eip-5604", "title": "NFT Lien", "authors": ["Zainan Victor Zhou\u00a0(", "@xinbenlv", ")", "Allen Zhou\u00a0<", "allen@ubiloan.io", ">", "Alex Qin\u00a0<", "alex@ubiloan.io", ">"], "sections": {"ERC-5604: NFT Lien": "This ERC introduces NFT liens, a form of security interest over an item of property to secure the recovery of liability or performance of some other obligation. It introduces an interface to place and removes a lien, plus an event.", "Extend ERC-721 to support putting liens on NFT": "This ERC introduces NFT liens, a form of security interest over an item of property to secure the recovery of liability or performance of some other obligation. It introduces an interface to place and removes a lien, plus an event.", "Abstract": "This ERC introduces NFT liens, a form of security interest over an item of property to secure the recovery of liability or performance of some other obligation. It introduces an interface to place and removes a lien, plus an event.", "Motivation": "Liens are widely used for finance use cases, such as car and property liens. An example use case for an NFT lien is for a deed.\nThis ERC provides an interface to implement an interface that performs the lien holding relationships.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "The ERC is designed as an extension ofERC-721and therefore compliant contracts need to fully comply withERC-721.", "Backwards Compatibility": "The ERC is designed as an extension ofERC-721and therefore compliant contracts need to fully comply withERC-721.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5630, "url": "https://eips.ethereum.org/EIPS/eip-5630", "title": "New approach for encryption / decryption", "authors": ["Firn Protocol\u00a0(", "@firnprotocol", ")", "Fried L. Trout", "Weiji Guo\u00a0(", "@weijiguo", ")"], "sections": {"ERC-5630: New approach for encryption / decryption": "This EIP proposes a new way to encrypt and decrypt using Ethereum keys. This EIP usesonlythesecp256k1curve, and proposes two new RPC methods:eth_getEncryptionPublicKeyandeth_performECDH. These two methods, in conjunction, allow users to receive encryptions and perform decryptions (respectively). We require that the walletonlyperform the core ECDH operation, leaving the ECIES operations up to implementers (we do suggest a standardized version of ECIES, however). In contrast, a previous EIPs used the same secret key, in both signing and encryption, on twodifferentcurves (namely,secp256k1andec25519), and hardcoded a particular version of ECIES.", "defines a specification for encryption and decryption using Ethereum wallets.": "This EIP proposes a new way to encrypt and decrypt using Ethereum keys. This EIP usesonlythesecp256k1curve, and proposes two new RPC methods:eth_getEncryptionPublicKeyandeth_performECDH. These two methods, in conjunction, allow users to receive encryptions and perform decryptions (respectively). We require that the walletonlyperform the core ECDH operation, leaving the ECIES operations up to implementers (we do suggest a standardized version of ECIES, however). In contrast, a previous EIPs used the same secret key, in both signing and encryption, on twodifferentcurves (namely,secp256k1andec25519), and hardcoded a particular version of ECIES.", "Abstract": "This EIP proposes a new way to encrypt and decrypt using Ethereum keys. This EIP usesonlythesecp256k1curve, and proposes two new RPC methods:eth_getEncryptionPublicKeyandeth_performECDH. These two methods, in conjunction, allow users to receive encryptions and perform decryptions (respectively). We require that the walletonlyperform the core ECDH operation, leaving the ECIES operations up to implementers (we do suggest a standardized version of ECIES, however). In contrast, a previous EIPs used the same secret key, in both signing and encryption, on twodifferentcurves (namely,secp256k1andec25519), and hardcoded a particular version of ECIES.", "Motivation": "We discuss a few motivating examples. One key motivation is direct-to-address encryption on Ethereum. Using our EIP, one can directly send encrypted messages to some desired recipient on-chain, without having a prior direct channel to that recipient. (Note that in this EIP, we standardizeonlythe encryption procedure\u2014that is, the generation of the ciphertext\u2014andnothow exactly the on-chain message should be sent. In practice, ideally, smart-contract infrastructure will be set up for this purpose; barring this, encryptors could make use of the rawdatafield available in each standard transfer.)", "Specification": "We describe our approach here; we compare our approach to prior EIPs in theRationalesection below. Throughout, we make reference to SEC 1: Elliptic Curve Cryptography, by Daniel R. L. Brown.", "Encrypting to a smart contract": "In light of account abstraction,EIP-4337, and the advent of smart-contract wallets, we moreover specify a way to encrypt to a contract.\nMore precisely, we specify a way for a contract toadvertisehow it would like encryptions to it to be constructed. This should be viewed as an analogue ofEIP-1271, but for encryption, as opposed to signing.", "Rationale": "There isno security prooffor a scheme which simultaneously invokes signing on thesecp256k1curve and encryption on theec25519curve, and wherethe same secret key is moreover used in both cases. Though no attacks are known, it is not desirable to use a scheme which lacks a proof in this way.\nWe, instead, propose the reuse of the same key in signing and encryption, but wherethe same curve is used in both. This very setting has been studied in prior work; see, e.g., Degabriele, Lehmann, Paterson, Smart and Strefler,On the Joint Security of Encryption and Signature in EMV, 2011. That work found this joint scheme to be secure in the generic group model.\nWe note that this very joint scheme (i.e., using ECDSA and ECIES on the same curve) is used live in production in EMV payments.", "Backwards Compatibility": "Oureth_performECDHmethod is new, and so doesn\u2019t raise any backwards compatibility issues.", "Test Cases": "The secretsigning key", "Security Considerations": "Our proposal uses heavily standardized algorithms and follows all best practices.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5700, "url": "https://eips.ethereum.org/EIPS/eip-5700", "title": "Bindable Token Interface", "authors": ["Leeren\u00a0(", "@leeren", ")"], "sections": {"ERC-5700: Bindable Token Interface": "This standard defines an interface forERC-721orERC-1155tokens, known as \u201cbindables\u201d, to \u201cbind\u201d toERC-721NFTs.", "Interface for binding fungible and non-fungible tokens to assets.": "This standard defines an interface forERC-721orERC-1155tokens, known as \u201cbindables\u201d, to \u201cbind\u201d toERC-721NFTs.", "Abstract": "This standard defines an interface forERC-721orERC-1155tokens, known as \u201cbindables\u201d, to \u201cbind\u201d toERC-721NFTs.", "Motivation": "A standard interface for NFT binding offers a seamless and efficient way to bundle and transfer tokens with NFTs, ensuring compatibility with wallets, marketplaces, and other NFT applications. It eliminates the need for rigid, implementation-specific strategies for token ownership.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "ERC-721 Bindable": "Smart contracts implementing the ERC-721 bindable standard MUST implement theIERC721Bindableinterface.", "ERC-1155 Bindable": "Smart contracts implementing the ERC-1155 Bindable standard MUST implement theIERC1155Bindableinterface.", "Rationale": "A standard for token binding unlocks a new layer of composability for allowing wallets, applications, and protocols to interact with, trade, and display bundled NFTs. One example use-case of this is at Dopamine, where streetwear garments may be bundled with digital assets such as music, avatars, or digital-twins of the garments, by representing these assets as bindable tokens and binding them to microchips represented as NFTs.", "Binding Mechanism": "During binding, a bindable token\u2019s technical ownership is conferred to its bound NFT, while allowing the NFT owner to unbind at any time. A caveat of this lightweight design is that applications that have yet to adopt this standard will not show the bundled tokens as owned by the NFT owner.", "Backwards Compatibility": "The bindable token interface is designed to be compatible with existing ERC-721 and ERC-1155 standards.", "Reference Implementation": "During binding, because ownership is conferred to the bound NFT contract, implementations should take caution in ensuring unbinding may only be performed by the designated NFT owner.", "Security Considerations": "During binding, because ownership is conferred to the bound NFT contract, implementations should take caution in ensuring unbinding may only be performed by the designated NFT owner.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5727, "url": "https://eips.ethereum.org/EIPS/eip-5727", "title": "Semi-Fungible Soulbound Token", "authors": ["Austin Zhu\u00a0(", "@AustinZhu", ")", "Terry Chen\u00a0<", "terry.chen@phaneroz.io", ">"], "sections": {"ERC-5727: Semi-Fungible Soulbound Token": "An interface for soulbound tokens (SBT), which are non-transferable tokens representing a person\u2019s identity, credentials, affiliations, and reputation.", "An interface for soulbound tokens, also known as badges or account-bound tokens, that can be both fungible and non-fungible.": "An interface for soulbound tokens (SBT), which are non-transferable tokens representing a person\u2019s identity, credentials, affiliations, and reputation.", "Abstract": "An interface for soulbound tokens (SBT), which are non-transferable tokens representing a person\u2019s identity, credentials, affiliations, and reputation.", "Motivation": "The current Web3 ecosystem is heavily focused on financialized, transferable tokens. However, there\u2019s a growing need for non-transferable tokens to represent unique personal attributes and rights. Existing attempts within the Ethereum community to create such tokens lack the necessary flexibility and extensibility. Our interface addresses this gap, offering a versatile and comprehensive solution for SBTs.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Core": "The core methods are used to manage the lifecycle of SBTs. They MUST be supported by all semi-fungible SBT implementations.", "Extensions": "All extensions below are OPTIONAL forERC-5727implementations. An implementation MAY choose to implement some, none, or all of them.", "Rationale": "We adopt semi-fungible token storage models designed to support both fungible and non-fungible tokens, inspired by the semi-fungible token standard. We found that such a model is better suited to the representation of SBT than the model used inERC-1155.", "Token storage model": "We adopt semi-fungible token storage models designed to support both fungible and non-fungible tokens, inspired by the semi-fungible token standard. We found that such a model is better suited to the representation of SBT than the model used inERC-1155.", "Recovery mechanism": "To prevent the loss of SBTs, we propose a recovery mechanism that allows users to recover their tokens by providing a signature signed by their owner address. This mechanism is inspired byERC-1271.", "Backwards Compatibility": "This EIP proposes a new token interface which is compatible withERC-721,ERC-3525,ERC-4906,ERC-5192,ERC-5484.", "Test Cases": "Our sample implementation includes test cases written using Hardhat.", "Reference Implementation": "You can find our reference implementationhere.", "Security Considerations": "This EIP does not involve the general transfer of tokens, and thus there will be no security issues related to token transfer generally.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5791, "url": "https://eips.ethereum.org/EIPS/eip-5791", "title": "Physical Backed Tokens", "authors": ["2pmflow\u00a0(", "@2pmflow", ")", "locationtba\u00a0(", "@locationtba", ")", "Cameron Robertson\u00a0(", "@ccamrobertson", ")", "cygaar\u00a0(", "@cygaar", ")", "Brian Weick\u00a0(", "@bweick", ")", "vectorized\u00a0(", "@vectorized", ")", "djdabs\u00a0(", "@djdabs", ")"], "sections": {"ERC-5791: Physical Backed Tokens": "This standard is an extension ofERC-721. It proposes a minimal interface for aERC-721NFT to be \u201cphysically backed\u201d and owned by whoever owns the NFT\u2019s physical counterpart.", "Minimal interface for linking ownership of ERC-721 NFTs to a physical chip": "This standard is an extension ofERC-721. It proposes a minimal interface for aERC-721NFT to be \u201cphysically backed\u201d and owned by whoever owns the NFT\u2019s physical counterpart.", "Abstract": "This standard is an extension ofERC-721. It proposes a minimal interface for aERC-721NFT to be \u201cphysically backed\u201d and owned by whoever owns the NFT\u2019s physical counterpart.", "Motivation": "NFT collectors enjoy collecting digital assets and sharing them with others online. However, there is currently no such standard for showcasing physical assets as NFTs with verified authenticity and ownership. Existing solutions are fragmented and tend to be susceptible to at least one of the following:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Requirements": "This approach requires that the physical item must have a chip attached to it that should be secure and signal authenticity:", "Approach": "Each NFT is conceptually linked to a physical chip.", "Interface": "To aid recognition that anERC-721token implements physical binding via this EIP: upon callingERC-165\u2019sfunction supportsInterface(bytes4 interfaceID) external view returns (bool)withinterfaceID=0x4901df9f, a contract implementing this EIP must return true.", "Rationale": "This solution\u2019s intent is to be the simplest possible path towards linking physical items to digital NFTs without a centralized authority.", "Out of Scope": "The following are some peripheral problems that are intentionally not within the scope of this EIP:", "Backwards Compatibility": "This proposal is backward compatible withERC-721on an API level. As mentioned above, for the token to be physical-backed, the contract must use a account-bound implementation ofERC-721(allERC-721functions that transfer must throw) so that transfers go through the new function introduced here, which requires a chip signature.", "Reference Implementation": "The following is a snippet on how to validate a chip signature in a transfer event.", "Security Considerations": "TheERC-191signature passed totransferTokenrequires the function caller\u2019s address in its signed data so that the signature cannot be used in a replay attack. It also requires a recent block timestamp so that a malicious chip owner cannot pre-generate signatures to use after a short time window (e.g. after the owner of the physical item changes). It\u2019s recommended to use a non-deterministicchipNoncewhen generating signatures.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6123, "url": "https://eips.ethereum.org/EIPS/eip-6123", "title": "Smart Derivative Contract", "authors": ["Christian Fries\u00a0(", "@cfries", ")", "Peter Kohl-Landgraf\u00a0(", "@pekola", ")", "Alexandros Korpis\u00a0(", "@kourouta", ")"], "sections": {"ERC-6123: Smart Derivative Contract": "The Smart Derivative Contract (SDC) allows fully automizing and securing a financial product\u2019s - e.g. a financial derivative or bond - complete trade life cycle.\nThe SDC leverages the advantages of smart contracts to remove many of the frictions associated with the classical derivative life cycle. Most notably, the protocol allows the removal of counterpart risk essentially.\nThe SDC can be implemented using a pre-agreed valuation oracle and valuation model, removing ambiguity in the settlement amounts. The SDC provides methods and callbacks to enable fully automated and fully transactional settlements (delivery-versus-payment, payment-vs-payment).\nToken-based settlement can be realized by any contract implementation implementing anERC-20token.\nProof of concepts in terms of two legally binding digital Interest Rate Swaps were conducted in 2021 and 2022.", "A deterministic protocol for frictionless trade processing of financial contracts": "The Smart Derivative Contract (SDC) allows fully automizing and securing a financial product\u2019s - e.g. a financial derivative or bond - complete trade life cycle.\nThe SDC leverages the advantages of smart contracts to remove many of the frictions associated with the classical derivative life cycle. Most notably, the protocol allows the removal of counterpart risk essentially.\nThe SDC can be implemented using a pre-agreed valuation oracle and valuation model, removing ambiguity in the settlement amounts. The SDC provides methods and callbacks to enable fully automated and fully transactional settlements (delivery-versus-payment, payment-vs-payment).\nToken-based settlement can be realized by any contract implementation implementing anERC-20token.\nProof of concepts in terms of two legally binding digital Interest Rate Swaps were conducted in 2021 and 2022.", "Abstract": "The Smart Derivative Contract (SDC) allows fully automizing and securing a financial product\u2019s - e.g. a financial derivative or bond - complete trade life cycle.\nThe SDC leverages the advantages of smart contracts to remove many of the frictions associated with the classical derivative life cycle. Most notably, the protocol allows the removal of counterpart risk essentially.\nThe SDC can be implemented using a pre-agreed valuation oracle and valuation model, removing ambiguity in the settlement amounts. The SDC provides methods and callbacks to enable fully automated and fully transactional settlements (delivery-versus-payment, payment-vs-payment).\nToken-based settlement can be realized by any contract implementation implementing anERC-20token.\nProof of concepts in terms of two legally binding digital Interest Rate Swaps were conducted in 2021 and 2022.", "Motivation": "By their very nature, so-called \u201cover-the-counter (OTC)\u201d financial contracts are bilateral contractual agreements on exchanging long-dated cash flow schedules.\nSince these contracts change their intrinsic market value due to changing market environments, they are subject to counterparty credit risk when one counterparty is subject to default.\nThe initial white paper describes the concept of a Smart Derivative Contract (SDC) with the central aim to detach bilateral financial transactions from counterparty credit risk and to remove complexities\nin bilateral post-trade processing by a complete redesign.", "Rethinking Financial Derivatives": "By their very nature, so-called \u201cover-the-counter (OTC)\u201d financial contracts are bilateral contractual agreements on exchanging long-dated cash flow schedules.\nSince these contracts change their intrinsic market value due to changing market environments, they are subject to counterparty credit risk when one counterparty is subject to default.\nThe initial white paper describes the concept of a Smart Derivative Contract (SDC) with the central aim to detach bilateral financial transactions from counterparty credit risk and to remove complexities\nin bilateral post-trade processing by a complete redesign.", "Concept of a Smart Derivative Contract": "A Smart Derivative Contract is a deterministic settlement protocol with the same economic behaviour as a Financial Contract - e.g. an OTC-Derivative or a Bond.\nEvery process state is specified; therefore, the trade and post-trade process is known in advance and is deterministic over the trade\u2019s life cycle. AnERC-20token can be used for frictionless decentralized settlement, see reference implementation. We do provide a separate interface and implementation for a specific \u201cSettlement Token\u201d derived fromERC-20.\nThese features enable two or multiple trade parties to process their financial contracts fully decentralized without relying on a third central intermediary agent.\nThe process logic of SDC can be implemented as a finite state machine on solidity.", "Applications": "The interface\u2019s life cycle functionality applies to several use cases.", "Specification": "The following methods specify a Smart Derivative Contract\u2019s trade initiation, trade termination and settlement life cycle. For further information, please also look at the interface documentation ISDC.sol.", "Methods": "The following methods specify a Smart Derivative Contract\u2019s trade initiation, trade termination and settlement life cycle. For further information, please also look at the interface documentation ISDC.sol.", "Trade Events": "The following events are emitted during an SDC Trade life-cycle.", "Settlement Events": "The following events are emitted during the settlement phases.", "Rationale": "The interface design and reference implementation are based on the following considerations:", "State diagram of trade and process states": "", "Sequence diagram of reference implementation \u2018SDCPledgedBalance.sol\u2019": "", "Test Cases": "Life-cycle unit tests based on the sample implementation and usage ofERC-20token is provided. See filetest/SDCTests.js).", "Reference Implementation": "An abstract contract classSDCSingleTrade.solfor single trade SDCs as well as a full reference implementation SDCPledgedBalance.sol for an OTC-Derivative is provided and is based on theERC-20token standard.\nSee folder/assets/contracts, more explanation on the implementation is provided inline.", "Trade Data Specification (suggestion)": "Please take a look at the provided xml file as a suggestion on how trade parameters could be stored.", "Security Considerations": "No known security issues up to now.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6170, "url": "https://eips.ethereum.org/EIPS/eip-6170", "title": "Cross-Chain Messaging Interface", "authors": ["Sujith Somraaj\u00a0(", "@sujithsomraaj", ")"], "sections": {"ERC-6170: Cross-Chain Messaging Interface": "This EIP introduces a common interface for cross-chain arbitrary message bridges (AMBs) to send and receive a cross-chain message (state).", "A common smart contract interface for interacting with messaging protocols.": "This EIP introduces a common interface for cross-chain arbitrary message bridges (AMBs) to send and receive a cross-chain message (state).", "Abstract": "This EIP introduces a common interface for cross-chain arbitrary message bridges (AMBs) to send and receive a cross-chain message (state).", "Motivation": "Currently, cross-chain arbitrary message bridges lack standardization, resulting in complex competing implementations: Layerzero, Hyperlane, Axelar, Wormhole, Matic State Tunnel and others. Either chain native (or) seperate message bridge, the problem prevails. Adding a common standardized interface to the arbitrary message bridges provides these benefits:", "Specification": "The keywords \u201cMUST,\u201d \u201cMUST NOT,\u201d \u201cREQUIRED,\u201d \u201cSHALL,\u201d \u201cSHALL NOT,\u201d \u201cSHOULD,\u201d \u201cSHOULD NOT,\u201d \u201cRECOMMENDED,\u201d \u201cMAY,\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "The cross-chain arbitrary messaging interface will optimize the interoperability layer between blockchains with a feature-complete yet minimal interface. The light-weighted approach also provides arbitrary message bridges, and the freedom of innovating at the relayer level, to show their technical might.", "Security Considerations": "Fully permissionless messaging could be a security threat to the protocol. It is recommended that all the integrators review the implementation of messaging tunnels before integrating.", "Copyright": "Copyright and related rights waived viaCC0", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6229, "url": "https://eips.ethereum.org/EIPS/eip-6229", "title": "Tokenized Vaults with Lock-in Period", "authors": ["Anderson Chen\u00a0(", "@Ankarrr", ")", "Martinet Lee\u00a0<", "martinetlee@gmail.com", ">", "Anton Cheng\u00a0<", "antonassocareer@gmail.com", ">"], "sections": {"ERC-6229: Tokenized Vaults with Lock-in Period": "This standard extendsEIP-4626to support lock-in periods.", "ERC-4626 Tokenized Vaults with Lock-in Period.": "This standard extendsEIP-4626to support lock-in periods.", "Abstract": "This standard extendsEIP-4626to support lock-in periods.", "Motivation": "TheEIP-4626standard defines a tokenized vault allowing users (contracts or EOAs) to deposit and withdraw underlying tokens at any time. However, there exist cases where the vault needs to lock the underlying tokens (perhaps to execute certain strategies). During the lock-in period, neither withdrawals nor deposits should be allowed. This standard extends the EIP-4626 to support lock-in periods and handle scheduled deposits and withdrawals during them.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Definitions": "The current state of the vault.", "View Methods": "The current state of the vault.", "Methods": "Schedule the intent to depositassetswhen theisLockedis true.", "Events": "senderschedules a deposit withassetsin thisround.", "Rationale": "The standard is designed to be a minimal interface. Details such as the start and end of a lock-in period, and how the underlying tokens are being used during the lock-in period are not specified.", "Backwards Compatibility": "Thedeposit,mint,withdraw,redeemmethods forEIP-4626should revert when theisLockedis true to prevent issuing or burning shares with an undefined share price.", "Security Considerations": "Implementors need to be aware of unsettled scheduled deposits and redemptions. If a user has scheduled a deposit or redemption but does not settle when theisLockedis false, and then settles it after several rounds, the vault will process it with an incorrect share price. We didn\u2019t specify the solution in the standard since there are many possible ways to solve this issue and we think implementors should decide the solution according to their use cases. For example:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- withdrawal: Log entry in system_logs for tracking withdrawals under EIP-4895 .\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6327, "url": "https://eips.ethereum.org/EIPS/eip-6327", "title": "Elastic Signature", "authors": ["George\u00a0(", "@JXRow", ")"], "sections": {"ERC-6327: Elastic Signature": "Elastic signature (ES) aims to sign data with a human friendly secret. The secret will be verified fully on-chain and is not stored anywhere. A user can change the secret as often as they need to. The secret does not have a fixed length. The secret will be like a password, which is a better understood concept than private key. This is specifically true for non-technical users. This EIP defines a smart contract interface to verify and authorize operations with ES.", "Use password to sign data as private key": "Elastic signature (ES) aims to sign data with a human friendly secret. The secret will be verified fully on-chain and is not stored anywhere. A user can change the secret as often as they need to. The secret does not have a fixed length. The secret will be like a password, which is a better understood concept than private key. This is specifically true for non-technical users. This EIP defines a smart contract interface to verify and authorize operations with ES.", "Abstract": "Elastic signature (ES) aims to sign data with a human friendly secret. The secret will be verified fully on-chain and is not stored anywhere. A user can change the secret as often as they need to. The secret does not have a fixed length. The secret will be like a password, which is a better understood concept than private key. This is specifically true for non-technical users. This EIP defines a smart contract interface to verify and authorize operations with ES.", "Motivation": "What would a changeable \u201cprivate key\u201d enable us? For years, we have been looking for ways to lower on-boarding barrier for users, especially those with less technical experiences. Private key custody solutions seem to provide an user friendly on-boarding experience, but it is vendor dependent and is not decentralized. ES makes a breakthrough with Zero-knowledge technology. Users generate proof of knowing the secret and a smart contract will verify the proof.", "Use case": "ES is an alternative signing algorithm. It is not an either-or solution to the private key. It is designed to serve as an additional signing mechanism on top of the private key signature.", "Specification": "Let:", "IElasticSignatureInterface": "This is the verifier interface.", "Rationale": "The contract will store everyone\u2019spwdhash.", "Backwards Compatibility": "This EIP is backward compatible with previous work on signature validation since this method is specific to password based signatures and not EOA signatures.", "Reference Implementation": "Example implementation of a signing contract:", "Security Considerations": "Since the pwdhash is public, it is possible to be crack the password. We estimate the Poseidon hash rate of RTX3090 would be 100Mhash/s, this is the estimate of crack time:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6604, "url": "https://eips.ethereum.org/EIPS/eip-6604", "title": "Abstract Token", "authors": ["Chris Walker (@cr-walker)\u00a0<", "chris@ckwalker.com", ">"], "sections": {"ERC-6604: Abstract Token": "Abstract tokens provide a standard interface to:", "move tokens on- and off-chain as desired, enabling zero-cost minting while preserving on-chain composability": "Abstract tokens provide a standard interface to:", "Abstract": "Abstract tokens provide a standard interface to:", "Motivation": "Abstract tokens enable zero-cost token minting, facilitating high-volume applications by allowing token holders to reify tokens (place the tokens on-chain) as desired. Example use cases:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Data Types": "A token message defines one or more tokens along with the context needed to reify the token(s) using a smart contract.", "Methods": "Moves token(s) from a message to a contractfunction reify(AbstractTokenMessage calldata message) external;", "Events": "The Reify event MUST be emitted when a token message is reified into tokensevent Reify(AbstractTokenMessage);", "Application to existing token standards": "Abstract tokens compatible with existing token standards MUST overload existing token transfer functions to allow transfers from abstract token messages.", "Abstract ERC-20": "The abstract token messagemetafield is simply a byte array to preserve the widest possible accesibility.", "Abstract ERC-721": "The abstract token messagemetafield is simply a byte array to preserve the widest possible accesibility.", "Abstract ERC-1155": "The abstract token messagemetafield is simply a byte array to preserve the widest possible accesibility.", "Rationale": "The abstract token messagemetafield is simply a byte array to preserve the widest possible accesibility.", "Meta format": "The abstract token messagemetafield is simply a byte array to preserve the widest possible accesibility.", "Proof format": "Similar considerations went into defining theprooffield as a plain byte array:", "Backwards Compatibility": "No backward compatibility issues found.", "Reference Implementation": "Seehere.", "Security Considerations": "Several concerns are highlighted.", "Message Loss": "Because token messages are not held on-chain, loss of the message may result in loss of the token. Applications that issue abstract tokens to their users can store the messages themselves, but ideally users would be able to store and interact with abstract token messages within their crypto wallets.", "Authorizing Reification": "Token messages may only be reified if they include a validity proof. While the proof mechanism itself is out of scope for this standard, those designing proof mechanisms should consider:", "Non-owner (De)Reification": "Can non-owners (de)reify a token message on behalf of the owner?", "Abstract Token Bridge Double Spend": "Abstract tokens could be used for a token-specific bridge:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6662, "url": "https://eips.ethereum.org/EIPS/eip-6662", "title": "AA Account Metadata For Authentication", "authors": ["Shu Dong\u00a0(", "@dongshu2013", ")", "Zihao Chen\u00a0(", "@zihaoccc", ")", "Peter Chen\u00a0(", "@pette1999", ")"], "sections": {"ERC-6662: AA Account Metadata For Authentication": "This ERC proposes a newIAccountMetadatainterface as an extension forERC-4337to store authentication data on-chain to support a more user-friendly authentication model.", "An ERC-4337 extension to define a new authentication model": "This ERC proposes a newIAccountMetadatainterface as an extension forERC-4337to store authentication data on-chain to support a more user-friendly authentication model.", "Abstract": "This ERC proposes a newIAccountMetadatainterface as an extension forERC-4337to store authentication data on-chain to support a more user-friendly authentication model.", "Motivation": "In this proposal, we propose a newIAccountMetadatainterface as an extension for ERC-4337IAccountinterface. With this new interface, users can store authentication data on-chain through one-time publishing, allowing dApps to proactively fetch it from the chain to support a more flexible and user-friendly authentication model. This will serve as an alternative to the current authentication model where users need to log in with a wallet every time and push account-related information to dApps by connecting the wallet in advance.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Authentication Flow": "", "Interface": "To support the new authentication workflow, this ERC proposes a newIAccountMetadatainterface as an extension ofIAccountinterface defined by ERC-4337.", "Rationale": "To enable the new authentication workflow we described above, dApp needs to know two things:", "Relay Service Selection": "Each authenticator can provide a list of relay services. dApp should pull through the list of relay services in order to find the first workable one. All relay services under each authenticator must follow the same schema.", "Signature Aggregation": "Multisig authentication could be enabled if multiple AuthenticatorInfos are provided under each smart contract account. Each authenticator can sign and submit signed user operations to bundler independently. These signatures will be aggregated by the Aggregator defined in ERC-4337.", "Future Extension": "TheIAccountMetadatainterface could be extended per different requirements. For example, a new alias or avatar field could be defined for profile displaying.", "Backwards Compatibility": "The new interface is fully backward compatible with ERC-4337.", "Security Considerations": "To protect the user\u2019s privacy and prevent front-running attacks, it\u2019s better to keep the data from dApps to authenticators encrypted during transmission. This could be done by adopting the JWE (JSON Web Encryption, RFC-7516) method. Before sending out AuthenticationRequest, a symmetric CEK(Content Encryption Key) is generated to encrypt fields with end to end encryption enabled, then the CEK is encrypted with the signer\u2019s public key. dApp will pack the request into a JWE object and send it to the authenticator through the relay service. Relay service has no access to the end to end encrypted data since only the authenticator has the key to decrypt the CEK.", "End to End Encryption": "To protect the user\u2019s privacy and prevent front-running attacks, it\u2019s better to keep the data from dApps to authenticators encrypted during transmission. This could be done by adopting the JWE (JSON Web Encryption, RFC-7516) method. Before sending out AuthenticationRequest, a symmetric CEK(Content Encryption Key) is generated to encrypt fields with end to end encryption enabled, then the CEK is encrypted with the signer\u2019s public key. dApp will pack the request into a JWE object and send it to the authenticator through the relay service. Relay service has no access to the end to end encrypted data since only the authenticator has the key to decrypt the CEK.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6682, "url": "https://eips.ethereum.org/EIPS/eip-6682", "title": "NFT Flashloans", "authors": ["out.eth\u00a0(", "@outdoteth", ")"], "sections": {"ERC-6682: NFT Flashloans": "This standard is an extension of the existing flashloan standard (ERC-3156) to supportERC-721NFT flashloans. It proposes a way for flashloan providers to lend NFTs to contracts, with the condition that the loan is repaid in the same transaction along with some fee.", "Minimal interface for ERC-721 NFT flashloans": "This standard is an extension of the existing flashloan standard (ERC-3156) to supportERC-721NFT flashloans. It proposes a way for flashloan providers to lend NFTs to contracts, with the condition that the loan is repaid in the same transaction along with some fee.", "Abstract": "This standard is an extension of the existing flashloan standard (ERC-3156) to supportERC-721NFT flashloans. It proposes a way for flashloan providers to lend NFTs to contracts, with the condition that the loan is repaid in the same transaction along with some fee.", "Motivation": "The current flashloan standard,ERC-3156, only supportsERC-20tokens. ERC-721 tokens are sufficiently different from ERC-20 tokens that they require an extension of this existing standard to support them.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Contract Interface": "TheflashFeeTokenfunction MUST return the address of the token used to pay flash loan fees.", "Rationale": "The above modifications are the simplest possible additions to the existing flashloan standard to support NFTs.", "Backwards Compatibility": "This EIP is fully backwards compatible withERC-3156with the exception of themaxFlashLoanmethod. This method does not make sense within the context of NFTs because NFTs are not fungible. However it is part of the existing flashloan standard and so it is not possible to remove it without breaking backwards compatibility. It is RECOMMENDED that any contract implementing this EIP without the intention of supporting ERC-20 flashloans should always return1frommaxFlashLoan. The1reflects the fact that only one NFT can be flashloaned perflashLoancall. For example:", "Reference Implementation": "It\u2019s possible that theflashFeeTokenmethod could return a malicious contract. Borrowers who intend to call the address that is returned from theflashFeeTokenmethod should take care to ensure that the contract is not malicious. One way they could do this is by verifying that the returned address fromflashFeeTokenmatches that of a user input.", "Security Considerations": "It\u2019s possible that theflashFeeTokenmethod could return a malicious contract. Borrowers who intend to call the address that is returned from theflashFeeTokenmethod should take care to ensure that the contract is not malicious. One way they could do this is by verifying that the returned address fromflashFeeTokenmatches that of a user input.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6785, "url": "https://eips.ethereum.org/EIPS/eip-6785", "title": "ERC-721 Utilities Information Extension", "authors": ["Otniel Nicola\u00a0(", "@OT-kthd", ")", "Bogdan Popa\u00a0(", "@BogdanKTHD", ")"], "sections": {"ERC-6785: ERC-721 Utilities Information Extension": "This specification defines standard functions and an extension of the metadata schema that outlines what a \ntoken\u2019s utility entails and how the utility may be used and/or accessed.\nThis specification is an optional extension ofERC-721.", "Provide easy access to information about the `utility` of an NFT via functions and the NFT's metadata": "This specification defines standard functions and an extension of the metadata schema that outlines what a \ntoken\u2019s utility entails and how the utility may be used and/or accessed.\nThis specification is an optional extension ofERC-721.", "Abstract": "This specification defines standard functions and an extension of the metadata schema that outlines what a \ntoken\u2019s utility entails and how the utility may be used and/or accessed.\nThis specification is an optional extension ofERC-721.", "Motivation": "This specification aims to clarify what the utility associated with an NFT is and how to access this utility.\nRelying on third-party platforms to obtain information regarding the utility of the NFT that one owns can lead to scams,\nphishing or other forms of fraud.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and\n\u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Contract Interface": "All functions defined as view MAY be implemented as pure or view", "Rationale": "Since theutilityUricould contain information that has to be restricted to some level and could be dependent on an\noff-chain tool for displaying said information, the creator needs the ability to modify it in the event the off-chain\ntool or platform becomes unavailable or inaccessible.", "Backwards Compatibility": "This standard is compatible with current ERC-721 standard. There are no other standards that define similar methods for\nNFTs and the method names are not used by other ERC-721 related standards.", "Test Cases": "Test cases are availablehere", "Reference Implementation": "The reference implementation can be foundhere.", "Security Considerations": "There are no security considerations related directly to the implementation of this standard.", "Copyright": "Copyright and related rights waived viaCC0-1.0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6786, "url": "https://eips.ethereum.org/EIPS/eip-6786", "title": "Registry for royalties payment for NFTs", "authors": ["Otniel Nicola\u00a0(", "@OT-kthd", ")", "Bogdan Popa\u00a0(", "@BogdanKTHD", ")"], "sections": {"ERC-6786: Registry for royalties payment for NFTs": "This standard allows anyone to pay royalties for a certain NFT and also to keep track of the royalties amount paid. It will cumulate the value each time a payment is executed through it and make the information public.", "A registry used for paying royalties for any NFT with information about the creator": "This standard allows anyone to pay royalties for a certain NFT and also to keep track of the royalties amount paid. It will cumulate the value each time a payment is executed through it and make the information public.", "Abstract": "This standard allows anyone to pay royalties for a certain NFT and also to keep track of the royalties amount paid. It will cumulate the value each time a payment is executed through it and make the information public.", "Motivation": "There are many marketplaces which do not enforce any royalty payment to the NFT creator every time the NFT is sold or re-sold and/or providing a way for doing it. There are some marketplaces which use specific system of royalties, however that system is applicable for the NFTs creates on their platform.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Contract Interface": "All functions defined as view MAY be implemented as pure or view", "Rationale": "The payment can be made in native coins, so it is easy to aggregate the amount of paid royalties. We want this information to be public, so anyone could tell if a creator received royalties in case of under the table trading or in case of marketplaces which don\u2019t support royalties.", "Backwards Compatibility": "This ERC is not introducing any backward incompatibilities.", "Test Cases": "Tests are included inERC6786.test.js.", "Reference Implementation": "SeeERC6786.sol.", "Security Considerations": "There are no security considerations related directly to the implementation of this standard.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6787, "url": "https://eips.ethereum.org/EIPS/eip-6787", "title": "Order Book DEX with Two Phase Withdrawal", "authors": ["Jessica\u00a0(", "@qizheng09", ")", "Roy\u00a0(", "@royshang", ")", "Jun\u00a0(", "@SniperUsopp", ")"], "sections": {"ERC-6787: Order Book DEX with Two Phase Withdrawal": "The Order Book DEX Standard is a proposed set of interface specifications that define a decentralized exchange (DEX) protocol for trading assets using order books. This standard provides a set of functions that allow users to deposit, withdraw, and trade assets on a decentralized exchange. Additionally, it proposes a novel two-phase withdrawal scheme to ensure the asset security of both users and the exchange, addressing users\u2019 trust issues with the exchange.", "An order book-based DEX Interface that ensures the asset security of both users and the exchange": "The Order Book DEX Standard is a proposed set of interface specifications that define a decentralized exchange (DEX) protocol for trading assets using order books. This standard provides a set of functions that allow users to deposit, withdraw, and trade assets on a decentralized exchange. Additionally, it proposes a novel two-phase withdrawal scheme to ensure the asset security of both users and the exchange, addressing users\u2019 trust issues with the exchange.", "Abstract": "The Order Book DEX Standard is a proposed set of interface specifications that define a decentralized exchange (DEX) protocol for trading assets using order books. This standard provides a set of functions that allow users to deposit, withdraw, and trade assets on a decentralized exchange. Additionally, it proposes a novel two-phase withdrawal scheme to ensure the asset security of both users and the exchange, addressing users\u2019 trust issues with the exchange.", "Motivation": "Decentralized exchanges (DEXs) have become increasingly popular in recent years due to their ability to provide users with greater control over their assets and reduce reliance on centralized intermediaries. However, many existing DEX protocols suffer from issues such as low liquidity and inefficient price discovery. Order book-based DEXs based Layer2 have emerged as a popular alternative, but there is currently no standardized interface for implementing such exchanges.", "Specification": "The Order Book DEX Standard defines the following Interfaces:", "Interfaces": "The Order Book DEX Standard defines the following Interfaces:", "Events": "MUST trigger when user successful call to PrepareForceWithdraw.", "Rationale": "The flow charts for two-phase withdrawal are shown below:", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- withdrawal: Log entry in system_logs for tracking withdrawals under EIP-4895 .\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6806, "url": "https://eips.ethereum.org/EIPS/eip-6806", "title": "ERC-721 Holding Time Tracking", "authors": ["Saitama\u00a0(", "@saitama2009", ")", "Combo\u00a0<", "combo@1combo.io", ">", "Luigi\u00a0<", "luigi@1combo.io", ">"], "sections": {"ERC-6806: ERC-721 Holding Time Tracking": "This standard is an extension ofERC-721. It adds an interface that tracks and describes the holding time of a Non-Fungible Token (NFT) by an account.", "Add holding time information to ERC-721 tokens": "This standard is an extension ofERC-721. It adds an interface that tracks and describes the holding time of a Non-Fungible Token (NFT) by an account.", "Abstract": "This standard is an extension ofERC-721. It adds an interface that tracks and describes the holding time of a Non-Fungible Token (NFT) by an account.", "Motivation": "In some use cases, it is valuable to know the duration for which a NFT has been held by an account. This information can be useful for rewarding long-term holders, determining access to exclusive content, or even implementing specific business logic based on holding time. However, the current ERC-721 standard does not have a built-in mechanism to track NFT holding time.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "getHoldingInfo": "This function returns the current holder of the specified NFT and the length of time (in seconds) the NFT has been held by the current account.", "Rationale": "The addition of thegetHoldingInfofunction to an extension of the ERC-721 standard enables developers to implement NFT-based applications that require holding time information. This extension maintains compatibility with existing ERC-721 implementations while offering additional functionality for new use cases.", "Backwards Compatibility": "This proposal is fully backwards compatible with the existing ERC-721 standard, as it extends the standard with new functions that do not affect the core functionality.", "Reference Implementation": "This EIP introduces additional state management for tracking holding times, which may have security implications. Implementers should be cautious of potential vulnerabilities related to holding time manipulation, especially during transfers.", "Security Considerations": "This EIP introduces additional state management for tracking holding times, which may have security implications. Implementers should be cautious of potential vulnerabilities related to holding time manipulation, especially during transfers.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6821, "url": "https://eips.ethereum.org/EIPS/eip-6821", "title": "Support ENS Name for Web3 URL", "authors": ["Qi Zhou\u00a0(", "@qizhou", ")", "Qiang Zhu\u00a0(", "@qzhodl", ")"], "sections": {"ERC-6821: Support ENS Name for Web3 URL": "This standard defines the mapping from an Ethereum name service (ENS) name to an Ethereum address forERC-4804.", "A mapping from an ENS name to the contract address in Web3 URL": "This standard defines the mapping from an Ethereum name service (ENS) name to an Ethereum address forERC-4804.", "Abstract": "This standard defines the mapping from an Ethereum name service (ENS) name to an Ethereum address forERC-4804.", "Motivation": "ERC-4804 defines aweb3://-scheme RFC 2396 URI to call a smart contract either by its address or anamefrom name service.  If anameis specified, the standard specifies a way to resolve the contract address from the name.", "Specification": "GivencontractNameandchainidfrom aweb3://URI defined in ERC-4804, the protocol will find the address of the contract using the following steps:", "Rationale": "The standard usescontentcontracttext record with ERC-3770 chain-specific address instead ofcontenthashso that the record is human-readable - a design principle of ERC-4804.  Further, we can use the text record to add additional fields such as time to live (TTL).", "Security Considerations": "No security considerations were found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6823, "url": "https://eips.ethereum.org/EIPS/eip-6823", "title": "Token Mapping Slot Retrieval Extension", "authors": ["qdqd (@qd-qd)\u00a0<", "qdqdqdqdqd@protonmail.com", ">"], "sections": {"ERC-6823: Token Mapping Slot Retrieval Extension": "The aim of this proposal is to enhance the precision of off-chain simulations for transactions that involve contracts complying with theERC-20,ERC-721, orERC-1155standards. To achieve this, a method is proposed for obtaining the reserved storage slot of the mapping responsible to track ownership of compliant tokens. The proposed extension offers a standardized entry point that allows for identifying the reserved storage slot of a mapping in a compatible manner. This not only facilitates capturing state changes more precisely but also enables external tools and services to do so without requiring expertise in the particular implementation details.", "Approach to enhance precision of off-chain transaction simulations by accessing mapping storage slot in ERC-20/721/1155 contracts.": "The aim of this proposal is to enhance the precision of off-chain simulations for transactions that involve contracts complying with theERC-20,ERC-721, orERC-1155standards. To achieve this, a method is proposed for obtaining the reserved storage slot of the mapping responsible to track ownership of compliant tokens. The proposed extension offers a standardized entry point that allows for identifying the reserved storage slot of a mapping in a compatible manner. This not only facilitates capturing state changes more precisely but also enables external tools and services to do so without requiring expertise in the particular implementation details.", "Abstract": "The aim of this proposal is to enhance the precision of off-chain simulations for transactions that involve contracts complying with theERC-20,ERC-721, orERC-1155standards. To achieve this, a method is proposed for obtaining the reserved storage slot of the mapping responsible to track ownership of compliant tokens. The proposed extension offers a standardized entry point that allows for identifying the reserved storage slot of a mapping in a compatible manner. This not only facilitates capturing state changes more precisely but also enables external tools and services to do so without requiring expertise in the particular implementation details.", "Motivation": "To understand the rationale behind this proposal, it\u2019s important to remember how values and mapping are stored in the storage layout. This procedure is language-agnostic; it can be applied to multiple programming languages beyond Solidity, including Vyper.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "The idea behind the implementation was to find an elegant and concise way that avoided any breaking changes with the current standard. Moreover, since gas consumption is crucial, it was inconceivable to find an implementation that would cost gas to the final user. In this case, the addition of a function increases the deployment cost of the contract in a minimal way, but its use is totally free for the external actors.", "Backwards Compatibility": "No backward compatibility issues have been found.", "Reference Implementation": "No security issues are raised by the implementation of this extension.", "Security Considerations": "No security issues are raised by the implementation of this extension.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6860, "url": "https://eips.ethereum.org/EIPS/eip-6860", "title": "Web3 URL to EVM Call Message Translation", "authors": ["Qi Zhou\u00a0(", "@qizhou", ")", "Chao Pi\u00a0(", "@pichaoqkc", ")", "Sam Wilson\u00a0(", "@SamWilsn", ")", "Nicolas Deschildre\u00a0(", "@nand2", ")"], "sections": {"ERC-6860: Web3 URL to EVM Call Message Translation": "This standard translates anRFC 3986URI likeweb3://uniswap.eth/to an EVM message such as:", "A translation of an HTTP-style Web3 URL to an EVM call message": "This standard translates anRFC 3986URI likeweb3://uniswap.eth/to an EVM message such as:", "Abstract": "This standard translates anRFC 3986URI likeweb3://uniswap.eth/to an EVM message such as:", "Motivation": "Currently, reading data from Web3 generally relies on a translation done by a Web2 proxy to Web3 blockchain. The translation is mostly done by the proxies such as dApp websites/node service provider/etherscan, which are out of the control of users. The standard here aims to provide a simple way for Web2 users to directly access the content of Web3, especially on-chain Web contents such as SVG/HTML.  Moreover, this standard enables interoperability with other standards already compatible with URIs, like SVG/HTML.", "Specification": "This specification only defines read-only (i.e. Solidity\u2019sviewfunctions) semantics. State modifying functions may be defined as a future extension.", "Resolve Mode": "Once the \u201cTo\u201d address and chainid are determined, the protocol will check the resolver mode of contract by calling theresolveModemethod of the \u201cTo\u201d address. The Solidity signature ofresolveModeis:", "Examples": "where the contract ofw3url.ethis in manual mode.", "Appendix A: Complete ABNF for Web3 URLs": "The purpose of the proposal is to add a decentralized presentation layer for Ethereum.  With the layer, we are able to render any web content (including HTML/CSS/JPG/PNG/SVG, etc) on-chain using human-readable URLs, and thus EVM can be served as a decentralized backend.  The design of the standard is based on the following principles:", "Appendix B: Changes versusERC-4804": "The purpose of the proposal is to add a decentralized presentation layer for Ethereum.  With the layer, we are able to render any web content (including HTML/CSS/JPG/PNG/SVG, etc) on-chain using human-readable URLs, and thus EVM can be served as a decentralized backend.  The design of the standard is based on the following principles:", "Rationale": "The purpose of the proposal is to add a decentralized presentation layer for Ethereum.  With the layer, we are able to render any web content (including HTML/CSS/JPG/PNG/SVG, etc) on-chain using human-readable URLs, and thus EVM can be served as a decentralized backend.  The design of the standard is based on the following principles:", "Security Considerations": "No security considerations were found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6864, "url": "https://eips.ethereum.org/EIPS/eip-6864", "title": "Upgradable Fungible Token", "authors": ["Jeff Huang\u00a0(", "@jeffishjeff", ")"], "sections": {"ERC-6864: Upgradable Fungible Token": "This proposal outlines a smart contract interface for upgrading/downgrading existingERC-20smart contracts while maintaining user balances. The interface itself is an extension to the ERC-20 standard so that other smart contracts can continue to interact with the upgraded smart contract without changing anything other than the address.", "Upgradable fungible token, a simple extension to ERC-20": "This proposal outlines a smart contract interface for upgrading/downgrading existingERC-20smart contracts while maintaining user balances. The interface itself is an extension to the ERC-20 standard so that other smart contracts can continue to interact with the upgraded smart contract without changing anything other than the address.", "Abstract": "This proposal outlines a smart contract interface for upgrading/downgrading existingERC-20smart contracts while maintaining user balances. The interface itself is an extension to the ERC-20 standard so that other smart contracts can continue to interact with the upgraded smart contract without changing anything other than the address.", "Motivation": "By design, smart contracts are immutable and token standards like ERC-20 are minimalistic. While these design principles are fundamental in decentalized applications, there are sensible and practical situations where the ability to upgrade an ERC-20 token is desirable, such as:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "See-through Extension": "Thesee-through extensionis OPTIONAL. It allows for easy viewing of combined states between thisERC-6864and base ERC-20 smart contracts.", "Rationale": "The goal of this proposal is to upgrade without affecting user balances, therefore leveraging existing data structure and methods is the path of the least engineering efforts as well as the most interoperability.", "Extending ERC-20 standard": "The goal of this proposal is to upgrade without affecting user balances, therefore leveraging existing data structure and methods is the path of the least engineering efforts as well as the most interoperability.", "Supporting downgrade": "The ability to downgrade makes moving between multiple IERC-6864 implementations on the same base ERC-20 smart contract possible. It also allows a way out should bugs or limitations discovered on ERC-6864 smart contract, or the user simply changes his or her mind.", "Optional see-through extension": "While these functions are useful in many situations, they are trivial to implement and results can be calculated via other public functions, hence the decision to include them in an optional extension rather than the core interface.", "Backwards Compatibility": "ERC-6864 is generally compatible with the ERC-20 standard. The only caveat is that some smart contracts may opt to implementtransferto work with the entire combined balance (this reduces user friction, see reference implementation) rather than the standardbalanceOfamount. In this case it is RECOMMENDED that such contract to implementtotalSupplyandbalanceOfto return combined amount between this ERC-6864 and base ERC-20 smart contracts", "Reference Implementation": "Copyright and related rights waived viaCC0.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6865, "url": "https://eips.ethereum.org/EIPS/eip-6865", "title": "On-Chain EIP-712 Visualization", "authors": ["Abderrahmen Hanafi\u00a0(", "@a6-dou", ")"], "sections": {"ERC-6865: On-Chain EIP-712 Visualization": "Numerous protocols employ distinctEIP-712schemas, leading to unavoidable inconsistencies across the ecosystem. To address this issue, we propose a standardized approach for dApps to implement an on-chain view function calledvisualizeEIP712Message. This function takes an abi encoded EIP-712 payload message as input and returns a universally agreed-upon structured data format that emphasizes the potential impact on users\u2019 assets. Wallets can then display this structured data in a user-friendly manner, ensuring a consistent experience for end-users when interacting with various dApps and protocols.", "Visualize structured data highlighting the potential consequences for users' assets": "Numerous protocols employ distinctEIP-712schemas, leading to unavoidable inconsistencies across the ecosystem. To address this issue, we propose a standardized approach for dApps to implement an on-chain view function calledvisualizeEIP712Message. This function takes an abi encoded EIP-712 payload message as input and returns a universally agreed-upon structured data format that emphasizes the potential impact on users\u2019 assets. Wallets can then display this structured data in a user-friendly manner, ensuring a consistent experience for end-users when interacting with various dApps and protocols.", "Abstract": "Numerous protocols employ distinctEIP-712schemas, leading to unavoidable inconsistencies across the ecosystem. To address this issue, we propose a standardized approach for dApps to implement an on-chain view function calledvisualizeEIP712Message. This function takes an abi encoded EIP-712 payload message as input and returns a universally agreed-upon structured data format that emphasizes the potential impact on users\u2019 assets. Wallets can then display this structured data in a user-friendly manner, ensuring a consistent experience for end-users when interacting with various dApps and protocols.", "Motivation": "The rapid expansion of the web3.0 ecosystem has unlocked numerous opportunities and innovations. However, this growth has also heightened users\u2019 vulnerability to security threats, such as phishing scams. Ensuring that users have a comprehensive understanding of the transactions they sign is crucial for mitigating these risks.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Params": "encodedMessageis bytes that represents the encoded EIP-712  message withabi.encodeand it can be decoded usingabi.decode", "Outputs": "The function MUST returnResult, a struct that contains information\u2019s about user\u2019s assets impact and the liveness of such a message if it gets signed.", "Rationale": "One might argue that certain processes can be done off-chain, which is true, but our experience building an off-chain TypeScript SDK to solve this matter revealed some issues:", "on-chain": "One might argue that certain processes can be done off-chain, which is true, but our experience building an off-chain TypeScript SDK to solve this matter revealed some issues:", "DomainHash": "ThedomainHashis much needed by protocols to revert against unsupported versions of its EIP-712 implementation. It identifies the needed implementation in case the protocol implements various EIP-712 implementations (name) or to revert if thedomainHashbelongs to a different protocol.", "Amounts Array": "We suggest using an array of amounts (uint256[]) instead of a single uint256 to cover auctions, which are common in NFT protocols.", "Backwards Compatibility": "No backward compatibility issues found.", "Reference Implementation": "openSea Seaport NFT marketplace implementation example is availablehere", "Security Considerations": "visualizeEIP712Messagefunction should be reliable and accurately represent the potential impact of the EIP-712 message on users\u2019 assets. Wallet providers and users must trust the protocol\u2019s implementation of this function to provide accurate and up-to-date information.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6900, "url": "https://eips.ethereum.org/EIPS/eip-6900", "title": "Modular Smart Contract Accounts", "authors": ["Adam Egyed\u00a0(", "@adamegyed", ")", "Fangting Liu\u00a0(", "@trinity-0111", ")", "Jay Paik\u00a0(", "@jaypaik", ")", "Yoav Weiss\u00a0(", "@yoavw", ")", "Huawei Gu\u00a0(", "@huaweigu", ")", "Daniel Lim\u00a0(", "@dlim-circle", ")", "Ruben Koch\u00a0(", "@0xrubes", ")", "David Philipson\u00a0(", "@dphilipson", ")", "Howy Ho\u00a0(", "@howydev", ")", "Nikita Belenkov\u00a0(", "@nikita-quantstamp", ")", "zer0dot\u00a0(", "@zer0dot", ")", "David Kim\u00a0(", "@PowerStream3604", ")"], "sections": {"ERC-6900: Modular Smart Contract Accounts": "This proposal standardizes smart contract accounts and account modules, which are smart contracts that allow for composable logic within smart contract accounts. This proposal is compliant withERC-4337. This standard emphasizes secure permissioning of modules, and maximal interoperability between all spec-compliant accounts and modules.", "Interfaces for smart contract accounts and modules, optionally supporting upgradability and introspection": "This proposal standardizes smart contract accounts and account modules, which are smart contracts that allow for composable logic within smart contract accounts. This proposal is compliant withERC-4337. This standard emphasizes secure permissioning of modules, and maximal interoperability between all spec-compliant accounts and modules.", "Abstract": "This proposal standardizes smart contract accounts and account modules, which are smart contracts that allow for composable logic within smart contract accounts. This proposal is compliant withERC-4337. This standard emphasizes secure permissioning of modules, and maximal interoperability between all spec-compliant accounts and modules.", "Motivation": "One of the goals that ERC-4337 accomplishes is abstracting the logic for execution and validation to each smart contract account.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Terms": "A modular account handles two kinds of calls: either from theEntryPointthrough ERC-4337, or through direct calls from externally owned accounts (EOAs) and other smart contracts. This standard supports both use cases.", "Overview": "A modular account handles two kinds of calls: either from theEntryPointthrough ERC-4337, or through direct calls from externally owned accounts (EOAs) and other smart contracts. This standard supports both use cases.", "Interfaces": "Modular accounts MUST implement:", "Validation Functions": "During validation uninstallation, the account MUST correctly clear flags and other fields based on the incoming data provided by the user.", "Execution Functions": "During execution uninstallation, the account MUST correctly clear flags and other fields based on the incoming data and module manifest provided by the user.", "Hooks": "For accounts that implement execution hooks, accounts MUST conform to these execution hook formats:", "Validation Call Flow": "Modular accounts support three different calls flows for validation: user op validation, runtime validation, and signature validation. User op validation happens within the account\u2019s implementation of the functionvalidateUserOp, defined in the ERC-4337 interfaceIAccount. Runtime validation happens through the dispatcher functionexecuteWithRuntimeValidation, or when usingdirect call validation. Signature validation happens within the account\u2019s implementation of the functionisValidSignature, defined in ERC-1271.", "Execution Call Flow": "For all non-view functions withinIERC6900AccountexceptexecuteWithRuntimeValidation, all module-defined execution functions, and any additional native functions that the modular account MAY wish to include, the modular account MUST adhere to these steps during execution:", "Extension": "Account implementers MAY choose to design a semi-modular account, where certain features, such as default validation, are integrated into the core account. This approach SHOULD ensure compatibility with fully modular accounts, as defined in this proposal, to maintain interoperability across different implementations.", "Rationale": "ERC-4337 compatible accounts must implement theIAccountinterface, which consists of only one method that bundles validation with execution:validateUserOp. A primary design rationale for this proposal is to extend the possible functions for a smart contract account beyond this single method by unbundling these and other functions, while retaining the benefits of account abstraction.", "ERC-4337 Dependency": "ERC-6900\u2019s main objective is to create a secure and interoperable foundation through modular accounts and modules to increase the velocity and security of the smart account ecosystem, and ultimately the wallet ecosystem. Currently, the standard prescribes ERC-4337 for one of itsmodular account call flows. However, this does not dictate that ERC-6900 will continue to be tied to ERC-4337.\nIt is likely that smart account builders will want to develop modular accounts that do not use ERC-4337 in the future (e.g., native account abstraction on rollups). Moreover, it is expected that ERC-4337 and its interfaces and contracts will continue to evolve until there is a protocol-level account abstraction.", "Community Consensus": "While this standard has largely been the result of collaboration among the coauthors, there have been noteworthy contributions from others in the community with respect to improvements, education, and experimentation. Thank you to the contributors:", "Backwards Compatibility": "Existing accounts that are deployed as proxies may have the ability to upgrade account implementations to one that supports this standard for modularity. Depending on implementation logic, existing modules may be wrapped in an adapter contract to adhere to the standard.", "Reference Implementation": "Seehttps://github.com/erc6900/reference-implementation", "Security Considerations": "From the wallet side, there are certain checks that the wallet/SDK should perform on the UI/UX side.", "Wallet/SDK Developers": "From the wallet side, there are certain checks that the wallet/SDK should perform on the UI/UX side.", "Module Developers": "The standard does not enforce any rules surrounding what data needs to be installed or uninstalled when a module is added/deleted from the account. Hence theonUninstall()function in various modules may leave behind residual state data, especially since the external call may not be performed all. Furthermore, execution hooks linked to an uninstalled function may remain configured. This could pose security risks or lead to unexpected behavior in the case where the module is reinstalled with the sameentityId. The danger is that previously set permissions or data may be unintentionally reused. Hence it is a good idea to fully uninstall all data linked to the smart module account including execution hooks.", "Users": "The modular smart contract accounts themselves are trusted components. Installed modules are trusted to varying degrees, as modules can interact with an arbitrarily large or small set of resources on an account. For example, a wide-reaching malicious module could add reverting hooks to native function selectors, bricking the account, or add execution functions that may drain the funds of the account. However, it is also possible to install a module with a very narrow domain, and depend on the correctness of the account behavior to enforce its limited access. Users should, therefore be careful in what modules to add to their account.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- revert: All calls to this opcode must emit a log with revert data.\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests"}
{"eip": 6932, "url": "https://eips.ethereum.org/EIPS/eip-6932", "title": "Subscription-Based Token", "authors": ["360 Core\u00a0<", "hello@360coreinc.com", ">", "Robin Rajput\u00a0(", "@0xRobinR", ")"], "sections": {"ERC-6932: Subscription-Based Token": "This subscription-basedERC-20token extends the basicERC-20token standard with asubscribeandunsubscribefunction, which allow users to subscribe or unsubscribe from the subscription service. ThesubscriptionFeeandsubscriptionFrequencyvariables define the cost and frequency of the subscription. ThenextPaymentDatemapping keeps track of the next payment date for each subscriber.", "ERC-20 extension providing access to a service or product that requires recurring payments.": "This subscription-basedERC-20token extends the basicERC-20token standard with asubscribeandunsubscribefunction, which allow users to subscribe or unsubscribe from the subscription service. ThesubscriptionFeeandsubscriptionFrequencyvariables define the cost and frequency of the subscription. ThenextPaymentDatemapping keeps track of the next payment date for each subscriber.", "Abstract": "This subscription-basedERC-20token extends the basicERC-20token standard with asubscribeandunsubscribefunction, which allow users to subscribe or unsubscribe from the subscription service. ThesubscriptionFeeandsubscriptionFrequencyvariables define the cost and frequency of the subscription. ThenextPaymentDatemapping keeps track of the next payment date for each subscriber.", "Motivation": "The rise of subscription-based business models necessitates a standardized approach to handle recurring payments on the Ethereum blockchain. Currently, users often manually initiate subscription payments, resulting in inconvenience and potential disruptions in service delivery. By introducing a Subscription Token, users can seamlessly authorize periodic deductions, enabling uninterrupted access to subscribed services.", "Specification": "Below are the implementaions required by the standard:", "SubscriptionToken": "Returns the list ofaddressessubscribed to the subscription token contract.", "Rationale": "The subscription token contract inherits the fundamentals of subscription by deducting payments from subscribed addresses on a regular interval using mathematical formulas.", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "Subscription Tokens may require users to sign transactions or provide cryptographic proofs for subscription-related actions. Proper key management practices should be followed to protect users\u2019 private keys and prevent unauthorized access. Encouraging the use of hardware wallets or secure key storage solutions can mitigate the risk of key compromise.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6944, "url": "https://eips.ethereum.org/EIPS/eip-6944", "title": "ERC-5219 Resolve Mode", "authors": ["Gavin John\u00a0(", "@Pandapip1", ")", "Qi Zhou\u00a0(", "@qizhou", ")"], "sections": {"ERC-6944: ERC-5219 Resolve Mode": "This EIP adds a newERC-4804resolveModeto resolveERC-5219contract resource requests.", "Adds an ERC-4804 resolveMode to support ERC-5219 requests": "This EIP adds a newERC-4804resolveModeto resolveERC-5219contract resource requests.", "Abstract": "This EIP adds a newERC-4804resolveModeto resolveERC-5219contract resource requests.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "ERC-165was not used because interoperability can be checked by callingresolveMode.", "Backwards Compatibility": "No backward compatibility issues found.", "Reference Implementation": "The security considerations ofERC-4804andERC-5219apply.", "Security Considerations": "The security considerations ofERC-4804andERC-5219apply.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6960, "url": "https://eips.ethereum.org/EIPS/eip-6960", "title": "Dual Layer Token", "authors": ["Adam Boudjemaa\u00a0(", "@aboudjem", ")", "Mohamad Hammoud\u00a0(", "@mohamadhammoud", ")", "Nawar Hisso\u00a0(", "@nawar-hisso", ")", "Khawla Hassan\u00a0(", "@khawlahssn", ")", "Mohammad Zakeri Rad\u00a0(", "@zakrad", ")", "Ashish Sood\u00a0<", "soodgen@gmail.com", ">"], "sections": {"ERC-6960: Dual Layer Token": "The dual-layer token combines the functionalities ofERC-20,ERC-721, andERC-1155while adding a classification layer that usesmainIdas the main asset type identifier andsubIdas the unique attributes or variations of the main asset.", "Token with a two-level classification system using mainId and subId": "The dual-layer token combines the functionalities ofERC-20,ERC-721, andERC-1155while adding a classification layer that usesmainIdas the main asset type identifier andsubIdas the unique attributes or variations of the main asset.", "Abstract": "The dual-layer token combines the functionalities ofERC-20,ERC-721, andERC-1155while adding a classification layer that usesmainIdas the main asset type identifier andsubIdas the unique attributes or variations of the main asset.", "Motivation": "TheERC-1155standard has experienced considerable adoption within the Ethereum ecosystem; however, its design exhibits constraints when handling tokens with multiple classifications, particularly in relation to Real World Assets (RWAs) and fractionalization of assets.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "DLT Interface": "Smart contracts MUST implement all the functions in theDLTReceiverinterface to accept transfers.", "DLTReceiverInterface": "Smart contracts MUST implement all the functions in theDLTReceiverinterface to accept transfers.", "Rationale": "The two-level classification system introduced in this EIP allows for a more organized token ecosystem, enabling users to manage and track tokens with greater granularity. It is particularly useful for projects that require token classifications beyond the capabilities of the current ERC-1155 standard.", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6981, "url": "https://eips.ethereum.org/EIPS/eip-6981", "title": "Reserved Ownership Accounts", "authors": ["Paul Sullivan (@sullivph)\u00a0<", "paul.sullivan@manifold.xyz", ">", "Wilkins Chung (@wwchung)\u00a0<", "wilkins@manifold.xyz", ">", "Kartik Patel (@Slokh)\u00a0<", "kartik@manifold.xyz", ">"], "sections": {"ERC-6981: Reserved Ownership Accounts": "The following specifies a system for services to link their users to a claimable Ethereum address. Services can provide a signed message and unique salt to their users which can be used to deploy a smart contract wallet to the deterministic address through a registry contract using thecreate2opcode.", "A registry for generating future-deployed smart contract accounts owned by users on external services": "The following specifies a system for services to link their users to a claimable Ethereum address. Services can provide a signed message and unique salt to their users which can be used to deploy a smart contract wallet to the deterministic address through a registry contract using thecreate2opcode.", "Abstract": "The following specifies a system for services to link their users to a claimable Ethereum address. Services can provide a signed message and unique salt to their users which can be used to deploy a smart contract wallet to the deterministic address through a registry contract using thecreate2opcode.", "Motivation": "It is common for web services to allow their users to hold on-chain assets via custodial wallets. These wallets are typically EOAs, deployed smart contract wallets or omnibus contracts, with private keys or asset ownership information stored on a traditional database. This proposal outlines a solution that avoids the security concerns associated with historical approaches, and rids the need and implications of services controlling user assets", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Overview": "The system for creating reserved ownership accounts consists of:", "Account Registry": "Deployment of reserved ownership accounts through an Account Registry Instance through calls tocreateAccountcould be front-run by a malicious actor. However, if the malicious actor attempted to alter theownerparameter in the calldata, the Account Registry Instance would find the signature to be invalid, and revert the transaction. Thus, any successful front-running transaction would deploy an identical Account Instance to the original transaction, and the original owner would still gain control over the address.", "Account Instance": "The Account Instance MUST implement the following interface:", "Rationale": "While it might seem more user-friendly to implement and deploy a universal registry for reserved ownership accounts, we believe that it is important for external service providers to have the option to own and control their own Account Registry.  This provides the flexibility of implementing their own permission controls and account deployment authorization frameworks.", "Service-Owned Registry Instances": "While it might seem more user-friendly to implement and deploy a universal registry for reserved ownership accounts, we believe that it is important for external service providers to have the option to own and control their own Account Registry.  This provides the flexibility of implementing their own permission controls and account deployment authorization frameworks.", "Account Registry and Account Implementation Coupling": "Since Account Instances are deployed asERC-1167proxies, the account implementation address affects the addresses of accounts deployed from a given Account Registry. Requiring that registry instances be linked to a single, immutable account implementation ensures consistency between a user\u2019s salt and linked address on a given Account Registry Instance.", "SeparatecreateAccountandclaimAccountOperations": "Operations to create and claim Account Instances are intentionally separate. This allows services to provide users with validERC-6492signatures before their Account Instance has been deployed.", "Reference Implementation": "The following is an example of an Account Registry Factory which can be used by external service providers to deploy their own Account Registry Instance.", "Account Registry Factory": "Deployment of reserved ownership accounts through an Account Registry Instance through calls tocreateAccountcould be front-run by a malicious actor. However, if the malicious actor attempted to alter theownerparameter in the calldata, the Account Registry Instance would find the signature to be invalid, and revert the transaction. Thus, any successful front-running transaction would deploy an identical Account Instance to the original transaction, and the original owner would still gain control over the address.", "Example Account Implementation": "Deployment of reserved ownership accounts through an Account Registry Instance through calls tocreateAccountcould be front-run by a malicious actor. However, if the malicious actor attempted to alter theownerparameter in the calldata, the Account Registry Instance would find the signature to be invalid, and revert the transaction. Thus, any successful front-running transaction would deploy an identical Account Instance to the original transaction, and the original owner would still gain control over the address.", "Security Considerations": "Deployment of reserved ownership accounts through an Account Registry Instance through calls tocreateAccountcould be front-run by a malicious actor. However, if the malicious actor attempted to alter theownerparameter in the calldata, the Account Registry Instance would find the signature to be invalid, and revert the transaction. Thus, any successful front-running transaction would deploy an identical Account Instance to the original transaction, and the original owner would still gain control over the address.", "Front-running": "Deployment of reserved ownership accounts through an Account Registry Instance through calls tocreateAccountcould be front-run by a malicious actor. However, if the malicious actor attempted to alter theownerparameter in the calldata, the Account Registry Instance would find the signature to be invalid, and revert the transaction. Thus, any successful front-running transaction would deploy an identical Account Instance to the original transaction, and the original owner would still gain control over the address.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- revert: All calls to this opcode must emit a log with revert data.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170."}
{"eip": 7085, "url": "https://eips.ethereum.org/EIPS/eip-7085", "title": "NFT Relationship Enhancement", "authors": ["Guang\u00a0(", "@xg1990", ")"], "sections": {"ERC-7085: NFT Relationship Enhancement": "This proposal builds onERC-1155and creates a standard for referring relationships and quantifiable attributes between non-isolatedERC-721orERC-1155non-fungible tokens (NFTs). It enables users to build a graph of NFTs and set quantifiable attributes for each NFT, facilitating more complex NFT ecosystems. While a similar proposal exists forERC-721tokens, it does not provide a way to establish quantifiable relationships or object attributes.", "Establish relationships between NFTs and setting quantifiable attributes for those relationships.": "This proposal builds onERC-1155and creates a standard for referring relationships and quantifiable attributes between non-isolatedERC-721orERC-1155non-fungible tokens (NFTs). It enables users to build a graph of NFTs and set quantifiable attributes for each NFT, facilitating more complex NFT ecosystems. While a similar proposal exists forERC-721tokens, it does not provide a way to establish quantifiable relationships or object attributes.", "Abstract": "This proposal builds onERC-1155and creates a standard for referring relationships and quantifiable attributes between non-isolatedERC-721orERC-1155non-fungible tokens (NFTs). It enables users to build a graph of NFTs and set quantifiable attributes for each NFT, facilitating more complex NFT ecosystems. While a similar proposal exists forERC-721tokens, it does not provide a way to establish quantifiable relationships or object attributes.", "Motivation": "The current standard for NFTs lacks the ability to establish relationships and attributes between tokens. This limitation makes it difficult for users to build more complex NFT ecosystems that require referring relationships and quantifiable attributes between tokens. For example, a user may create a derivative NFT that refers to the original NFT and sets a quantifiable attribute for the relationship between the two NFTs, but without a standardized way to establish relationships and attributes between NFTs, managing these ecosystems becomes increasingly difficult and inefficient.", "Specification": "This EIP proposes the addition of five new functions to theERC-721andERC-1155standards:setRelationship,setAttribute,getRelationship,getAttribute, andgetAttributeNames. These functions allow users to establish referring relationships and set quantifiable attributes between NFTs.", "setRelationship": "ThesetRelationshipfunction establishes a referring relationship between two NFTs. It takes the following parameters:", "setAttribute": "ThesetAttributefunction sets a quantifiable attribute for an NFT. It takes the following parameters:", "getAttribute": "ThegetAttributefunction allows anyone to retrieve the value of a specific attribute associated with an NFT. It takes the following parameters:", "getAttributeNames": "The getAttributeNames function allows anyone to retrieve the names of all attributes associated with an NFT. It takes the following parameter:", "getRelationship": "ThegetRelationshipfunction allows anyone to retrieve the value of a referring relationship between two NFTs. It takes the following parameters:", "Example Usage": "By including these functions and methods in the specification, you establish a clear and standardized way for users and developers to read attributes associated with NFTs.", "Rationale": "In developing this EIP, some key design decisions were made. For example, we limited the complexity of the relationship graph that can be created by only allowing for one referring relationship between two NFTs. This helps to ensure that the graph remains manageable and does not become too complex to be useful. Additionally, we kept the gas cost of setting attributes to a minimum by only allowing for one attribute to be set at a time.", "Backwards Compatibility": "This EIP is designed to be fully backward-compatible with existingERC-721andERC-1155contracts and tokens. Existing NFT contracts and tokens will continue to function as they did before, and the newsetRelationshipandsetAttributefunctions will only be available to contracts that explicitly implement this EIP.", "Reference Implementation": "To assist in understanding and implementing this proposal, we provide a reference Solidity interface and contract that define the functions for establishing relationships and reading attributes. Developers can use this interface as a foundation for integrating the NFT Relationship Enhancement into their own contracts.", "ERC-165Interface Support": "The NFT Relationship Enhancement contract implements the ERC-165 standard interface to allow for interface detection. This enables smart contracts and applications to check if a given contract supports the functions defined in this proposal before interacting with it.", "INFTGraph Interface": "The INFTGraph interface specifies the functions for setting relationships and attributes, as well as retrieving attribute information and relationship values.", "NFTGraph Contract": "The NFTGraph contract implements the functions specified in the INFTGraph interface and provides storage for relationships and attributes.", "Security Considerations": "When implementing this proposal, contract developers should consider the following security aspects:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7087, "url": "https://eips.ethereum.org/EIPS/eip-7087", "title": "MIME type for Web3 URL in Auto Mode", "authors": ["Qi Zhou\u00a0(", "@qizhou", ")", "Nicolas Deschildre\u00a0(", "@nand2", ")"], "sections": {"ERC-7087: MIME type for Web3 URL in Auto Mode": "This standard extends theERC-6860web3://standard: in smart contracts not designed forweb3://(thus using auto mode), the MIME type of the returned data is either implicit (not advertised by the smart contract) or included within the returned data (RFC 2397data URLs). This standard defines additional query parameters so that a MIME type can be returned when fetching aweb3://URL in these scenarios.", "Add ability to indicate or determine the MIME type of the data returned by a Web3 URL in auto mode": "This standard extends theERC-6860web3://standard: in smart contracts not designed forweb3://(thus using auto mode), the MIME type of the returned data is either implicit (not advertised by the smart contract) or included within the returned data (RFC 2397data URLs). This standard defines additional query parameters so that a MIME type can be returned when fetching aweb3://URL in these scenarios.", "Abstract": "This standard extends theERC-6860web3://standard: in smart contracts not designed forweb3://(thus using auto mode), the MIME type of the returned data is either implicit (not advertised by the smart contract) or included within the returned data (RFC 2397data URLs). This standard defines additional query parameters so that a MIME type can be returned when fetching aweb3://URL in these scenarios.", "Motivation": "When returning data to the web browser, aContent-Typeheader indicating the MIME type of the data is strongly recommended, or the data may be incorrectly interpreted and displayed by the web browser.", "Specification": "The standard introduces three query parameters to determine the MIME type.", "Examples": "where the contract is in auto mode.", "Rationale": "The standard uses three different query parameters rather than a single query parameter to avoid confusion - an implementer or a user can easily tell the expected returned MIME of a link.  Further, in auto mode, the query parameters are not used to form the EVM message (e.g., calldata) and thus it is safe to introduce new query parameters.", "Security Considerations": "These new query parameters introduce Cross Site Scripting attack vectors : an attacker could exploit string or bytes returning methods he can influence by making them return unfiltered data injected by him, and then craft a URL to make the returned data interpreted as HTML, and then send the URL to victims. If the web3 hostname is well known, the victim may get a false sense of security.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7093, "url": "https://eips.ethereum.org/EIPS/eip-7093", "title": "Social Recovery Interface", "authors": ["John Zhang\u00a0(", "@johnz1019", ")", "Davis Xiang\u00a0(", "@xcshuan", ")", "Kyle Xu\u00a0(", "@kylexyxu", ")", "George Zhang\u00a0(", "@odysseus0", ")"], "sections": {"ERC-7093: Social Recovery Interface": "This ERC proposes a standard interface for social recovery of smart contract accounts. It separates identity and policy verification from the recovery process, allowing more ways to authenticate (known as Guardians) than just on-chain accounts. It also lets users customize recovery policies without changing the account\u2019s smart contract.", "Interfaces for social recovery account supporting various guardian types and customizable recovery policies.": "This ERC proposes a standard interface for social recovery of smart contract accounts. It separates identity and policy verification from the recovery process, allowing more ways to authenticate (known as Guardians) than just on-chain accounts. It also lets users customize recovery policies without changing the account\u2019s smart contract.", "Abstract": "This ERC proposes a standard interface for social recovery of smart contract accounts. It separates identity and policy verification from the recovery process, allowing more ways to authenticate (known as Guardians) than just on-chain accounts. It also lets users customize recovery policies without changing the account\u2019s smart contract.", "Motivation": "Vitalik Buterin has long advocated for social recovery as an essential tool for user protection within the crypto space. He posits that the value of this system rests in its ability to offer users, especially those less acquainted with the technicalities of cryptography, a robust safety net when access credentials are lost. By entrusting account recovery to a network of selected individuals or entities, dubbed \u201cGuardians,\u201d users gain a safeguard against the risk of losing access to their digital assets.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "DataTypes": "This defines the necessary data types required by this interface standard.", "TypesAndDecoders": "This defines the necessary data types required by this interface standard.", "Interfaces": "The Guardian Permission Verification Interface. Implementations MUST conform to this interface to enable identity verification of non-account type guardians.", "IPermissionVerifier": "The Guardian Permission Verification Interface. Implementations MUST conform to this interface to enable identity verification of non-account type guardians.", "IRecoveryPolicyVerifier": "The Recovery Policy Verification Interface. Implementations MAY conform to this interface to support verification of varying recovery policies. RecoveryPolicyVerifier is optional for SocialRecoveryInterface.", "IRecoveryAccount": "The Smart Contract Account MAY implement theIRecoveryAccountinterface to support social recovery functionality, enabling users to customize configurations of different types of Guardians and recovery policies. In the contract design based on Module, the implementation ofRecoveryModuleis very similar toRecoveryAccount, except that different accounts need to be distinguished and isolated.", "Recovery Account Workflow": "Note: This workflow is presented as an illustrative example to clarify the coordinated usage of the associated interface components. It does not imply a mandatory adherence to this exact process.", "Rationale": "A primary design rationale for this proposal is to extend a greater diversity of Guardian types and more flexible, customizable recovery policies for a RecoveryAccount. This is achieved by separating the verification logic from the social recovery process, ensuring that the basic logic of the account contract remains unaltered.", "Backwards Compatibility": "No backward compatibility issues are introduced by this standard.", "Reference Implementation": "TBD.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7196, "url": "https://eips.ethereum.org/EIPS/eip-7196", "title": "Simple token, Simplified ERC-20", "authors": ["Xiang\u00a0(", "@wenzhenxiang", ")", "Ben77\u00a0(", "@ben2077", ")", "Mingshi S.\u00a0(", "@newnewsms", ")"], "sections": {"ERC-7196: Simple token, Simplified ERC-20": "This ERC is a new asset designed based on the user contract wallet (including account abstraction), and is forward compatible withERC-20. To keep token assets simple, this ERC removes thetransferFrom,approveandallowancefunctions of ERC-20.", "Designed for smart contract wallets, this removes the transferFrom, approve, and allowance functions from ERC-20 tokens.": "This ERC is a new asset designed based on the user contract wallet (including account abstraction), and is forward compatible withERC-20. To keep token assets simple, this ERC removes thetransferFrom,approveandallowancefunctions of ERC-20.", "Abstract": "This ERC is a new asset designed based on the user contract wallet (including account abstraction), and is forward compatible withERC-20. To keep token assets simple, this ERC removes thetransferFrom,approveandallowancefunctions of ERC-20.", "Motivation": "ERC-20defines Ethereum-based standard tokens that can be traded and transferred, but the essence of ERC-20 is based on the externally-owned account (EOA) wallet design. An EOA wallet has no state and code storage, and the smart contract wallet is different.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "The proposal is to simplify token standards by removingtransferFrom,approveandallowancefunctions. This simplification aims to enhance security, reduce complexity, and improve efficiency, making the standard more suitable for smart contract wallet environments while maintaining essential functionalities.", "Backwards Compatibility": "As mentioned in the beginning, this ERC is forward compatible withERC-20, ERC-20 is backward compatible with this ERC.", "Reference Implementation": "forward compatible withERC-20", "Security Considerations": "It should be noted that this ERC is not backward compatible withERC-20, so there will be incompatibility with existing dapps.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7204, "url": "https://eips.ethereum.org/EIPS/eip-7204", "title": "Contract wallet management token", "authors": ["Xiang\u00a0(", "@wenzhenxiang", ")", "Ben77\u00a0(", "@ben2077", ")", "Mingshi S.\u00a0(", "@newnewsms", ")"], "sections": {"ERC-7204: Contract wallet management token": "This proposal introduces a smart contract wallet-based approach for managing tokens, focusing on utilizing the programmable features of smart contract wallets for asset management. \nAdditionally, it introduces functions such astokenTransfer,tokenApprove,tokenApproveForAll,tokenIsApproveForAllandtokenAllowance, which provide enhanced control over token transactions. This approach seeks to enhance token management by utilizing the built-in features of smart contract wallets, thus offering a more adaptable, secure, and efficient method for managing token transactions.", "Focuses on fungible token management within smart contract wallets, offering enhanced transaction flexibility and security": "This proposal introduces a smart contract wallet-based approach for managing tokens, focusing on utilizing the programmable features of smart contract wallets for asset management. \nAdditionally, it introduces functions such astokenTransfer,tokenApprove,tokenApproveForAll,tokenIsApproveForAllandtokenAllowance, which provide enhanced control over token transactions. This approach seeks to enhance token management by utilizing the built-in features of smart contract wallets, thus offering a more adaptable, secure, and efficient method for managing token transactions.", "Abstract": "This proposal introduces a smart contract wallet-based approach for managing tokens, focusing on utilizing the programmable features of smart contract wallets for asset management. \nAdditionally, it introduces functions such astokenTransfer,tokenApprove,tokenApproveForAll,tokenIsApproveForAllandtokenAllowance, which provide enhanced control over token transactions. This approach seeks to enhance token management by utilizing the built-in features of smart contract wallets, thus offering a more adaptable, secure, and efficient method for managing token transactions.", "Motivation": "An externally-owned account (EOA) wallet has no state and code storage, while the smart contract wallet does.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "the key technical decisions in this proposal are:", "Backwards Compatibility": "This ERC can be used as an extension ofERC-4337and is backward compatible with ERC-4337.", "Security Considerations": "No security considerations were found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7246, "url": "https://eips.ethereum.org/EIPS/eip-7246", "title": "Encumber - Splitting Ownership & Guarantees", "authors": ["Coburn Berry\u00a0(", "@coburncoburn", ")", "Mykel Pereira\u00a0(", "@mykelp", ")", "Scott Silver\u00a0(", "@scott-silver", ")"], "sections": {"ERC-7246: Encumber - Splitting Ownership & Guarantees": "This ERC proposes an extension to theERC-20token standard by adding Encumber\u2014the ability for an account to grant another account exclusive right to move some portion of their balance. Encumber is a stronger version ofERC-20allowances. WhileERC-20approve grants another account the permission to transfer a specified token amount, encumber grants the same permission while ensuring that the tokens will be available when needed.", "A token interface to allow pledging tokens without transferring ownership.": "This ERC proposes an extension to theERC-20token standard by adding Encumber\u2014the ability for an account to grant another account exclusive right to move some portion of their balance. Encumber is a stronger version ofERC-20allowances. WhileERC-20approve grants another account the permission to transfer a specified token amount, encumber grants the same permission while ensuring that the tokens will be available when needed.", "Abstract": "This ERC proposes an extension to theERC-20token standard by adding Encumber\u2014the ability for an account to grant another account exclusive right to move some portion of their balance. Encumber is a stronger version ofERC-20allowances. WhileERC-20approve grants another account the permission to transfer a specified token amount, encumber grants the same permission while ensuring that the tokens will be available when needed.", "Motivation": "This extension adds flexibility to theERC-20token standard and caters to use cases where token locking is required, but it is preferential to maintain actual ownership of tokens. This interface can also be adapted to other token standards, such asERC-721, in a straightforward manner", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "The specification was designed to complement and mirror the ERC-20 specification to ease adoption and understanding. The specification is intentionally minimally proscriptive of this joining, where the only true requirement is that an owner cannot transfer encumbered tokens. However, the example implementation includes some decisions about where to connect with ERC-20 functions worth noting. It was designed for minimal invasiveness of standard ERC-20 definitions.\n    - The example has a dependency onapproveto facilitateencumberFrom. This proposal allows for an implementer to define another mechanism, such as anapproveEncumberwhich would mirror ERC-20 allowances, if desired.\n    -transferFrom(src, dst, amount)is written to first reduce theencumbrances(src, amount), and then subsequently spend fromallowance(src, msg.sender). Alternatively,transferFromcould be implemented to spend from allowance simultaneously to spending encumbrances. This would requireapproveto check that the approved balance does not decrease beneath the amount required by encumbered balances, and also make creating the approval a prerequisite to callingencumber.", "Backwards Compatibility": "This EIP is backwards compatible with the existingERC-20standard. Implementations must add the functionality to block transfer of tokens that are encumbered to another account.", "Reference Implementation": "This can be implemented as an extension of any baseERC-20contract by modifying the transfer function to block the transfer of encumbered tokens and to release encumbrances when spent via transferFrom.", "Security Considerations": "Parties relying onbalanceOfto determine the amount of tokens available for transfer should instead rely onbalanceOf(account) - encumberedBalance(account), or, if implemented,availableBalanceOf(account).", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7254, "url": "https://eips.ethereum.org/EIPS/eip-7254", "title": "Token Revenue Sharing", "authors": ["Quy Phan\u00a0(", "@quyphandang", ")", "Quy Phan\u00a0<", "quy.phan@cryptoviet.info", ">"], "sections": {"ERC-7254: Token Revenue Sharing": "With the aspiration of bringing forth unique functionality and enhancing value for holders ofERC-20tokens, our project aims to effortlessly reward token holders without necessitating users to lock, stake, or farm their tokens. Whenever the project generates profits, these profits can be distributed to the token holders.", "Revenue token is a token that shares rewards for holders.": "With the aspiration of bringing forth unique functionality and enhancing value for holders ofERC-20tokens, our project aims to effortlessly reward token holders without necessitating users to lock, stake, or farm their tokens. Whenever the project generates profits, these profits can be distributed to the token holders.", "Abstract": "With the aspiration of bringing forth unique functionality and enhancing value for holders ofERC-20tokens, our project aims to effortlessly reward token holders without necessitating users to lock, stake, or farm their tokens. Whenever the project generates profits, these profits can be distributed to the token holders.", "Specification": "Returns  max token reward.", "Methods": "Returns  max token reward.", "Rationale": "TBD", "Reference Implementation": "Needs discussion.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7272, "url": "https://eips.ethereum.org/EIPS/eip-7272", "title": "Ethereum Access Token", "authors": ["Chris Chung\u00a0(", "@0xpApaSmURf", ")", "Raphael Roullet\u00a0(", "@ra-phael", ")"], "sections": {"ERC-7272: Ethereum Access Token": "An Ethereum Access Token (EAT) is anEIP-712conformant, signed message, used by off-chain services to grant Ethereum accounts access to specific on-chain resources. EATs share similarities with JSON Web Tokens (JWTs); both are used for short-lived authorizations. However Ethereum Access Tokens are specifically designed to be verified on-chain and tailored to authorize smart contract function calls.", "A protocol for authorizing function calls from an off-chain service": "An Ethereum Access Token (EAT) is anEIP-712conformant, signed message, used by off-chain services to grant Ethereum accounts access to specific on-chain resources. EATs share similarities with JSON Web Tokens (JWTs); both are used for short-lived authorizations. However Ethereum Access Tokens are specifically designed to be verified on-chain and tailored to authorize smart contract function calls.", "Abstract": "An Ethereum Access Token (EAT) is anEIP-712conformant, signed message, used by off-chain services to grant Ethereum accounts access to specific on-chain resources. EATs share similarities with JSON Web Tokens (JWTs); both are used for short-lived authorizations. However Ethereum Access Tokens are specifically designed to be verified on-chain and tailored to authorize smart contract function calls.", "Motivation": "While other proposals tackle authentication or authorization in a more narrow way, this specification allows developers to add a layer of access control to any function they create with minimal changes. It is best suited for use cases where end users should only be able to access specific on-chain resources themselves directly, by way of sending a transaction, provided they have been granted authorization by an off-chain service first. Examples of such scenarios include an off-chain verifier assessing eligibility requirements (e.g by verifying verifiable credentials) to mint a token or to interact with a smart contract that requires a certain compliance status.\nTherefore, this proposal enables off-chain systems to authenticate the controller of an Ethereum account in any way they want, before granting an authorization bound to said account.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Overview": "An example flow integrated in a DeFi application is the following:", "Structure of an Ethereum Access Token": "An Ethereum Access Token is composed of a signature and expiry.", "EAT Verification": "On chain, the reference implementation uses two contracts: anAccessTokenConsumerwhich is inherited by contracts needing to permission some of its functions and anAccessTokenVerifierwhich is responsible for verifying EATs.", "Rationale": "Any function can be gated with an EAT, apart from the specialreceiveandfallbackfunctions.", "Backwards Compatibility": "Any function can be gated with an EAT, apart from the specialreceiveandfallbackfunctions.", "Reference Implementation": "Here\u2019s a reference implementation of the different smart contracts making up the EAT system onchain:", "Security Considerations": "The security of the Ethereum Access Token (EAT) proposal depends on several factors:", "Replay Attacks": "The implementation MAY ensure that an EAT cannot be reused after it has been consumed. This is achieved by marking the EAT as consumed in the_consumeAccessTokenfunction.", "Off-Chain Issuance": "The security of the off-chain service issuing EATs is critical since the security of EAT-gated functions depends on it.\nIf this service is compromised, malicious actors could be granted EATs giving them access to on-chain resources that they should not have access to.", "Expiry Time Considerations": "The expiry time of the EAT must be set judiciously to balance usability and security. If the expiry time is set too long, it might increase the risk of EAT misuse. If it\u2019s too short, it might compromise the usability of the application.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7280, "url": "https://eips.ethereum.org/EIPS/eip-7280", "title": "NFT Metadata Extension like JSON-LD", "authors": ["Yohei Nishikubo\u00a0(", "@yoheinishikubo", ")"], "sections": {"ERC-7280: NFT Metadata Extension like JSON-LD": "This proposal expands the metadata format for Non-Fungible Tokens (ERC-721,ERC-1155,ERC-3525, and others), adding support for linked data like JSON-LD format. The additional data is stored under the linked_data key in the metadata JSON.", "Let NFT metadata have a feature equivalent to JSON-LD to be semantic.": "This proposal expands the metadata format for Non-Fungible Tokens (ERC-721,ERC-1155,ERC-3525, and others), adding support for linked data like JSON-LD format. The additional data is stored under the linked_data key in the metadata JSON.", "Abstract": "This proposal expands the metadata format for Non-Fungible Tokens (ERC-721,ERC-1155,ERC-3525, and others), adding support for linked data like JSON-LD format. The additional data is stored under the linked_data key in the metadata JSON.", "Motivation": "The existing metadata format for Non-Fungible Tokens is limited and doesn\u2019t support the inclusion of structured and semantically meaningful data. By integrating JSON-LD (Linked Data), we can enhance the richness and interoperability of the metadata associated with NFTs.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Schema": "For providing typical webpage for an NFT, it\u2019s much simple to include JSON-LD in HTML header tag with this extension. Just looking for JSON-LD compliant value\u2019s uri fromlinked_dataarray, fetch it and embed its content in HTML header tag.\nThis means the minter of NFT can control the appearance in the search result of Google, for example.\nIn more common case for interoperability, the NFT metadata can include any schema and data with this extension. This means the NFT metadata can be used as a data source for any application. With the schema, the implementation is much easier.", "Data": "For providing typical webpage for an NFT, it\u2019s much simple to include JSON-LD in HTML header tag with this extension. Just looking for JSON-LD compliant value\u2019s uri fromlinked_dataarray, fetch it and embed its content in HTML header tag.\nThis means the minter of NFT can control the appearance in the search result of Google, for example.\nIn more common case for interoperability, the NFT metadata can include any schema and data with this extension. This means the NFT metadata can be used as a data source for any application. With the schema, the implementation is much easier.", "Rationale": "For providing typical webpage for an NFT, it\u2019s much simple to include JSON-LD in HTML header tag with this extension. Just looking for JSON-LD compliant value\u2019s uri fromlinked_dataarray, fetch it and embed its content in HTML header tag.\nThis means the minter of NFT can control the appearance in the search result of Google, for example.\nIn more common case for interoperability, the NFT metadata can include any schema and data with this extension. This means the NFT metadata can be used as a data source for any application. With the schema, the implementation is much easier.", "Backwards Compatibility": "The proposed expansion to the NFT metadata format is backward compatible with existing implementations. NFTs that do not include thelinked_datakey will continue to function as before, and existing applications consuming NFT metadata will not be affected.", "Reference Implementation": "Here is an example metadata JSON demonstrating the new linked_data structure:", "Sample files": "The proposed expansion does not introduce any additional security considerations beyond those already associated with NFTs and linked data. Implementations should adhere to best practices for secure handling and validation of metadata from external sources.", "Security Considerations": "The proposed expansion does not introduce any additional security considerations beyond those already associated with NFTs and linked data. Implementations should adhere to best practices for secure handling and validation of metadata from external sources.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7291, "url": "https://eips.ethereum.org/EIPS/eip-7291", "title": "Purpose bound money", "authors": ["Orchid-Dev\u00a0(", "@proj-orchid-straitsx", ")", "Victor Liew\u00a0(", "@alcedo", ")", "Wong Tse Jian\u00a0(", "@wongtsejian", ")", "Jacob Shan\u00a0(", "@Jacobshan429", ")", "Chin Sin Ong\u00a0(", "@chinsinong", ")"], "sections": {"ERC-7291: Purpose bound money": "This proposal outlines a smart contract interface that builds upon theERC-1155standard to implement the purpose bound money (PBM) concept:", "An interface extending ERC-1155 to implement purpose-bound money, a hybrid form of programmable payment and money.": "This proposal outlines a smart contract interface that builds upon theERC-1155standard to implement the purpose bound money (PBM) concept:", "Abstract": "This proposal outlines a smart contract interface that builds upon theERC-1155standard to implement the purpose bound money (PBM) concept:", "Motivation": "This proposal intends to forestall technology fragmentation and consequently a lack of interoperability. By making the PBM specification open, it gives new participants easy and free access to the pre-existing market standards, enabling interoperability across different platforms, wallets, payment systems and rails. This would lower cost of entry for new participants, foster a vibrant payment landscape and prevent the development of walled gardens and monopolies, ultimately leading to more efficient, affordable services and better user experiences.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Definitions": "In this EIP, we propose a modular PBM architecture that has three distinct components (the core, the plugins and the hooks):", "Overview": "In this EIP, we propose a modular PBM architecture that has three distinct components (the core, the plugins and the hooks):", "PBM Architecture": "In this EIP, we propose a modular PBM architecture that has three distinct components (the core, the plugins and the hooks):", "Auditability": "PBM WrapperSHOULDprovide the public easily accessible mechanism(s) to verify the smart contract logic for unwrapping a PBM. Such mechanisms could be leveraged by automated validation or asynchronous user verifications from transacting parties and/or whitelisted third parties attestations.", "Fungibility": "A PBM WrapperSHOULDbe able to wrap multiple types of compatible sovTokens (e.g. the same PBM Wrapper should be able to wrap USDC and XSGD). sovTokens wrapped by the same PBM wrapper may or may not be fungible to one another. The standard does NOT mandate how an implementation must do this.", "PBM token details": "The ERC-1155 Multi Token Standard enables each token ID to correspond to a unique, configurable token type. All essential details facilitating the business or display logic for a PBMMUSTbe defined for each token type. The mandatory fields for this purpose are outlined in thestruct PBMToken(below). Future proposals may define additional, optional state variables as needed. Once a token detail has been defined, itMUSTbe immutable.", "PBM Address List": "A targeted address list for PBM unwrapping must be specified. This list can be supplied either\nthrough the initialization function as part of a composite contract that contains various business logic elements,\nor it can be coded directly as a state variable within a PBM smart contract.", "PBMRC1 - Base Interface": "This interface contains the essential functions required to implement a pre-loaded PBM.", "Extensions": "Smart contracts MUST implement all of the functions in the PBMRC1_TokenReceiver interface to subscribe to PBM unwrap callbacks.", "Rationale": "As PBM is envisioned to have functionality of money, it has to be a fungible token with stable value. Currently, the major stablecoins in the market are mainly based on the ERC-20 interface. ERC-20 or ERC-20 compatible tokens are the most widely supported by existing wallets, defi apps, and used also by protocol design such asERC-4337and more importantly they are the de facto standard for fungible tokens.", "Why sovTokenMUSTbe ERC-20 compatible?": "As PBM is envisioned to have functionality of money, it has to be a fungible token with stable value. Currently, the major stablecoins in the market are mainly based on the ERC-20 interface. ERC-20 or ERC-20 compatible tokens are the most widely supported by existing wallets, defi apps, and used also by protocol design such asERC-4337and more importantly they are the de facto standard for fungible tokens.", "Why PBM WapperMUSTbe ERC-1155 compatible?": "This paper extends the ERC-1155 standards in order to enable easy adoption by existing wallet providers. Currently, most wallet providers are able to support and display ERC-20, ERC-1155 and ERC-721 standards. An implementation which doesn\u2019t extend these standards will require the wallet provider to build a custom user interface and interfacing logic which increases the implementation cost and lengthen the time-to-market.", "Why PBMMUSTensure the destination address for unwrapped sovToken is in a whitelist of Merchant/Redeemer addresses and not in a blacklist of banned addresses prior to unwrapping the underlying sovToken?": "Why we need a whitelist?", "What does business logic encompasses?": "Each ERC-1155 PBM Token would map to an underlyingPBMTokendata structure that implementers are free to customize in accordance to the business logic.", "Why was a push transaction model chosen?": "Each ERC-1155 PBM Token would map to an underlyingPBMTokendata structure that implementers are free to customize in accordance to the business logic.", "Customisability": "Each ERC-1155 PBM Token would map to an underlyingPBMTokendata structure that implementers are free to customize in accordance to the business logic.", "Backwards Compatibility": "This interface is designed to be compatible with ERC-1155.", "Reference Implementation": "Reference implementations can be found inREADME.md.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7303, "url": "https://eips.ethereum.org/EIPS/eip-7303", "title": "Token-Controlled Token Circulation", "authors": ["Ko Fujimura\u00a0(", "@kofujimura", ")"], "sections": {"ERC-7303: Token-Controlled Token Circulation": "This ERC introduces an access control scheme termed Token-Controlled Token Circulation (TCTC). By representing the privileges associated with a role as anERC-721orERC-1155token (referred to as acontrol token), the processes of granting or revoking a role can be facilitated through the minting or burning of the correspondingcontrol token.", "Access control scheme based on token ownership.": "This ERC introduces an access control scheme termed Token-Controlled Token Circulation (TCTC). By representing the privileges associated with a role as anERC-721orERC-1155token (referred to as acontrol token), the processes of granting or revoking a role can be facilitated through the minting or burning of the correspondingcontrol token.", "Abstract": "This ERC introduces an access control scheme termed Token-Controlled Token Circulation (TCTC). By representing the privileges associated with a role as anERC-721orERC-1155token (referred to as acontrol token), the processes of granting or revoking a role can be facilitated through the minting or burning of the correspondingcontrol token.", "Motivation": "There are numerous methods to implement access control for privileged actions. A commonly utilized pattern is \u201crole-based\u201d access control as specified inERC-5982. This method, however, necessitates the use of an off-chain management tool to grant or revoke required roles through its interface. Additionally, as many wallets lack a user interface that displays the privileges granted by a role, users are often unable to comprehend the status of their privileges through the wallet.", "Use Cases": "This ERC is applicable in many scenarios where role-based access control as described inERC-5982is used. Specific use cases include:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "The choice to utilize ERC-721 or ERC-1155 token as the control token for privileges enhances visibility of such privileges within wallets, thus simplifying privilege management for users.", "Backwards Compatibility": "This ERC is designed to be compatible forERC-721,ERC-1155, andERC-5679respectively.", "Reference Implementation": "ERC-7303 provides a modifier to facilitate the implementation of TCTC access control in applications.\u3000This modifier checks if an account possesses the necessary role. ERC-7303 also includes a function that grants a specific role to a designated account.", "Security Considerations": "The security of tokens subject to circulation depends significantly on the security of the control tokens. Careful consideration must be given to the settings regarding the administrative privileges, mint/transfer/burn permissions, and the possibility of contract updates of control tokens.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7390, "url": "https://eips.ethereum.org/EIPS/eip-7390", "title": "Vanilla Options for ERC-20 Tokens", "authors": ["Ewan Humbert (@Xeway)\u00a0<", "xeway@protonmail.com", ">", "Lassi Maksimainen (@mlalma)\u00a0<", "lassi.maksimainen@gmail.com", ">"], "sections": {"ERC-7390: Vanilla Options for ERC-20 Tokens": "This standard defines a comprehensive set of functions and events facilitating seamless interactions (creation, management, exercising, etc.) for vanilla options.", "An interface for creating, managing, and executing simple time-limited call/put (vanilla) options.": "This standard defines a comprehensive set of functions and events facilitating seamless interactions (creation, management, exercising, etc.) for vanilla options.", "Abstract": "This standard defines a comprehensive set of functions and events facilitating seamless interactions (creation, management, exercising, etc.) for vanilla options.", "Motivation": "Options are widely used financial instruments, and have a true usefulness for investors and traders. It offers versatile risk management tools and speculative opportunities.In the decentralized finance, many options-selling platform emerged, but each of these protocols implements their own definition of an option. This leads to incompatibilities, which is a pity because options should be interoperable like fungible/non-fungible tokens are.By introducing a standard interface for vanilla options contracts, we aim to foster a more inclusive and interoperable derivatives ecosystem. This standard will enhance the user experience and facilitate the development of decentralized options platforms, enabling users to seamlessly trade options across different applications. Moreover, this standard is designed to represent vanilla options, which are the most common type of options. This standard can be used as a base for more complex options, such as exotic options.", "Specification": "Implementations of this proposal MUST also implement ERC-1155 to give the possibility to buy only a fraction of the issuance.", "Interface": "At creation time, user must provide filled instance ofVanillaOptionDatastructure that contains all the key information for initializing the option issuance.", "State Variable Descriptions": "At creation time, user must provide filled instance ofVanillaOptionDatastructure that contains all the key information for initializing the option issuance.", "Function Descriptions": "No constructor is needed for this standard, but the contract MUST implement the ERC-1155 interface. So, the contract MUST call the ERC-1155 constructor.", "Events": "Emitted when the writer has provided option issuance data successfully (and locked down the collateral to the contract). The givenididentifies the particular option issuance.", "Errors": "Reverts when the caller is not allowed to perform some actions (general purpose).", "Concrete Examples": "Let\u2019s say Bob sells acalloption.He gives the right to anyone to buy8 TokenAat25 TokenBeach between14th of July 2023and16th of July 2023 (at midnight).For such a contract, he wants to receive a premium of10 TokenC.", "Rationale": "This contract\u2019s concept is oracle-free, because we assume that a rational buyer will exercise his option only if it\u2019s profitable for him.", "Security Considerations": "Contract containsexerciseWindowStartandexerciseWindowEnddata points. These define the determined time range for the buyer to exercise options. When the current time is greater thanexerciseWindowEnd, the buyer won\u2019t be able to exercise and the writer will be able to retrieve any remaining collateral.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7399, "url": "https://eips.ethereum.org/EIPS/eip-7399", "title": "\u26a1 Flash Loans \u26a1", "authors": ["Alberto Cuesta Ca\u00f1ada\u00a0(", "@alcueca", ")", "Michael Amadi\u00a0(", "@AmadiMichaels", ")", "Devtooligan\u00a0(", "@devtooligan", ")", "Ultrasecr.eth\u00a0(", "@ultrasecreth", ")", "Sam Bacha\u00a0(", "@sambacha", ")"], "sections": {"ERC-7399: \u26a1 Flash Loans \u26a1": "A flash loan is a loan between lender and borrower smart contracts that must be repaid, plus an optional fee, before the end of the transaction. This ERC specifies interfaces for lenders to accept flash loan requests, and for borrowers to take temporary control of the transaction within the lender execution. The process for the safe execution of flash loans is also specified.", "Interfaces and processes for flash loans": "A flash loan is a loan between lender and borrower smart contracts that must be repaid, plus an optional fee, before the end of the transaction. This ERC specifies interfaces for lenders to accept flash loan requests, and for borrowers to take temporary control of the transaction within the lender execution. The process for the safe execution of flash loans is also specified.", "Abstract": "A flash loan is a loan between lender and borrower smart contracts that must be repaid, plus an optional fee, before the end of the transaction. This ERC specifies interfaces for lenders to accept flash loan requests, and for borrowers to take temporary control of the transaction within the lender execution. The process for the safe execution of flash loans is also specified.", "Motivation": "The current state of the flash loan ecosystem is fragmented and lacks standardization, leading to several challenges for both lenders and borrowers. The absence of a common interface results in increased integration efforts, as each flash loan provider implements its own unique approach. This lack of standardization is expected to become more problematic as the ecosystem grows, requiring more resources to maintain compatibility.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Lender Specification": "AlenderMUST implement theERC-7399interface.", "Receiver Specification": "Acallback receiverof flash loans MUST implement one or more external functions with the following arguments and return value:", "Rationale": "The interfaces described in this ERC have been chosen as to cover the known flash lending use cases, while allowing for safe and gas efficient implementations.", "Backwards Compatibility": "This EIP is a successor ofERC-3156. While not directly backwards compatible, a wrapper contract offering this proposal\u2019s external interface with liquidity obtained from an ERC-3156 flashlenderis trivial to implement.", "Security Considerations": "The arguments of the flash loan callbacks are expected to reflect the conditions of the flash loan, but cannot be trusted unconditionally. They can be divided in two groups, that require different checks before they can be trusted to be genuine.", "Verification of callback arguments": "The arguments of the flash loan callbacks are expected to reflect the conditions of the flash loan, but cannot be trusted unconditionally. They can be divided in two groups, that require different checks before they can be trusted to be genuine.", "Flash lending security considerations": "Anyreceiverthat repays theamountandfeereceived as arguments needs to include in the callback a mechanism to verify that the initiator andlenderare trusted.", "Flash minting external security considerations": "The typical quantum of assets involved in flash mint transactions will give rise to new innovative attack vectors.", "Flash minting internal security considerations": "The coupling of flash minting with business specific features in the same platform can easily lead to unintended consequences.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7405, "url": "https://eips.ethereum.org/EIPS/eip-7405", "title": "Portable Smart Contract Accounts", "authors": ["Aaron Yee\u00a0(", "@aaronyee-eth", ")"], "sections": {"ERC-7405: Portable Smart Contract Accounts": "Portable Smart Contract Accounts (PSCA) address the lack of portability and compatibility faced by Smart Contract Accounts (SCA) across different wallet providers. Based onERC-1967, the PSCA system allows users to easily migrate their SCAs between different wallets using new, randomly generated migration keys. This provides a similar experience to exporting an externally owned account (EOA) with a private key or mnemonic. The system ensures security by employing signatures and time locks, allowing users to verify and cancel migration operations during the lock period, thereby preventing potential malicious actions. PSCA offers a non-intrusive and cost-effective approach, enhancing the interoperability and composability within the Account Abstraction (AA) ecosystem.", "Migrating smart contract accounts at the Proxy (ERC-1967) layer.": "Portable Smart Contract Accounts (PSCA) address the lack of portability and compatibility faced by Smart Contract Accounts (SCA) across different wallet providers. Based onERC-1967, the PSCA system allows users to easily migrate their SCAs between different wallets using new, randomly generated migration keys. This provides a similar experience to exporting an externally owned account (EOA) with a private key or mnemonic. The system ensures security by employing signatures and time locks, allowing users to verify and cancel migration operations during the lock period, thereby preventing potential malicious actions. PSCA offers a non-intrusive and cost-effective approach, enhancing the interoperability and composability within the Account Abstraction (AA) ecosystem.", "Abstract": "Portable Smart Contract Accounts (PSCA) address the lack of portability and compatibility faced by Smart Contract Accounts (SCA) across different wallet providers. Based onERC-1967, the PSCA system allows users to easily migrate their SCAs between different wallets using new, randomly generated migration keys. This provides a similar experience to exporting an externally owned account (EOA) with a private key or mnemonic. The system ensures security by employing signatures and time locks, allowing users to verify and cancel migration operations during the lock period, thereby preventing potential malicious actions. PSCA offers a non-intrusive and cost-effective approach, enhancing the interoperability and composability within the Account Abstraction (AA) ecosystem.", "Motivation": "With the introduction of theERC-4337standard, AA related infrastructure and SCAs have been widely adopted in the community. However, unlike EOAs, SCAs have a more diverse code space, leading to varying contract implementations across different wallet providers. Consequently, the lack of portability for SCAs has become a significant issue, making it challenging for users to migrate their accounts between different wallet providers. While some proposed a modular approach for SCA accounts, it comes with higher implementation costs and specific prerequisites for wallet implementations.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Terms": "A Portable Smart Contract AccountMUSTimplement theIERC7405interface:", "Interfaces": "A Portable Smart Contract AccountMUSTimplement theIERC7405interface:", "Signatures": "The execution of migration operationsMUSTuse the migration private key to sign theMigrationOp.", "Registry": "To simplify migration credentials and enable direct addressing of the SCA account with only the migration mnemonic or private key, this proposal requires a shared registry deployed at the protocol layer.", "Expected behavior": "When performing account migration (i.e., migrating an SCA from Wallet A to Wallet B), the following stepsMUSTbe followed:", "Storage Layout": "To prevent conflicts in storage layout during migration across different wallet implementations, a Portable Smart Contract Account implementation contract:", "Rationale": "The main challenge addressed by this EIP is the lack of portability in Smart Contract Accounts (SCAs). Currently, due to variations in SCA implementations across wallet providers, moving between wallets is a hassle. Proposing a modular approach, though beneficial in some respects, comes with its own costs and compatibility concerns.", "Backwards Compatibility": "This proposal is backward compatible with all SCA based on ERC-1967 Proxy, including non-ERC-4337 SCAs. Furthermore, this proposal does not have specific prerequisites for SCA implementation contracts, making it broadly applicable to various SCAs.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7406, "url": "https://eips.ethereum.org/EIPS/eip-7406", "title": "Multi-Namespace Onchain Registry", "authors": ["Mengshi Zhang\u00a0(", "@MengshiZhang", ")", "Zihao Chen\u00a0(", "@zihaoccc", ")"], "sections": {"ERC-7406: Multi-Namespace Onchain Registry": "This EIP proposes a universally accepted description for onchain registry entries with support for multi-namespaces, where each entry is structured as a mapping type. The multi-namespace registry enables the storage of a collection of key-value mappings within the blockchain, serving as a definitive source of information with a traceable history of changes. These mapping records act as pointers combined with onchain assets, offering enhanced versatility in various use cases by encapsulating extensive details. The proposed solution introduces a general mapping data structure that is flexible enough to support and be compatible with different situations, providing a more scalable and powerful alternative to current ENS-like registries.", "An universally accepted multi-namespace registry with mapping structures on the Ethereum": "This EIP proposes a universally accepted description for onchain registry entries with support for multi-namespaces, where each entry is structured as a mapping type. The multi-namespace registry enables the storage of a collection of key-value mappings within the blockchain, serving as a definitive source of information with a traceable history of changes. These mapping records act as pointers combined with onchain assets, offering enhanced versatility in various use cases by encapsulating extensive details. The proposed solution introduces a general mapping data structure that is flexible enough to support and be compatible with different situations, providing a more scalable and powerful alternative to current ENS-like registries.", "Abstract": "This EIP proposes a universally accepted description for onchain registry entries with support for multi-namespaces, where each entry is structured as a mapping type. The multi-namespace registry enables the storage of a collection of key-value mappings within the blockchain, serving as a definitive source of information with a traceable history of changes. These mapping records act as pointers combined with onchain assets, offering enhanced versatility in various use cases by encapsulating extensive details. The proposed solution introduces a general mapping data structure that is flexible enough to support and be compatible with different situations, providing a more scalable and powerful alternative to current ENS-like registries.", "Motivation": "Blockchain-based registries are fundamental components for decentralized applications, enabling the storage and retrieval of essential information. Existing solutions, like the ENS registry, serve specific use cases but may lack the necessary flexibility to accommodate more complex scenarios. The need for a more general mapping data structure with multi-namespace support arises to empower developers with a single registry capable of handling diverse use cases efficiently.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Registry specification": "The multi namespace registry contract exposes the following functions:", "Resolver specification": "The multi-namespace resolver contract can utilize the same specification as defined inERC-137.", "Rationale": "By supporting multiple namespaces, the registry caters to various use cases, including but not limited to identity management, session management, record tracking, and decentralized content publishing. This flexibility enables developers to design and implement more complex decentralized applications with ease.", "Backwards Compatibility": "As this EIP introduces a new feature and does not modify any existing behaviors, there are no backwards compatibility issues.", "Reference Implementation": "The proposed multi-namespace registry introduces several security considerations due to its ability to manage various namespaces and access controls. Thorough testing, auditing, and peer reviews will be conducted to identify and mitigate potential attack vectors and vulnerabilities. Security-conscious developers are encouraged to contribute to the audit process.", "Appendix A: Registry Implementation": "The proposed multi-namespace registry introduces several security considerations due to its ability to manage various namespaces and access controls. Thorough testing, auditing, and peer reviews will be conducted to identify and mitigate potential attack vectors and vulnerabilities. Security-conscious developers are encouraged to contribute to the audit process.", "Security Considerations": "The proposed multi-namespace registry introduces several security considerations due to its ability to manage various namespaces and access controls. Thorough testing, auditing, and peer reviews will be conducted to identify and mitigate potential attack vectors and vulnerabilities. Security-conscious developers are encouraged to contribute to the audit process.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7410, "url": "https://eips.ethereum.org/EIPS/eip-7410", "title": "ERC-20 Update Allowance By Spender", "authors": ["Mohammad Zakeri Rad\u00a0(", "@zakrad", ")", "Adam Boudjemaa\u00a0(", "@aboudjem", ")", "Mohamad Hammoud\u00a0(", "@mohamadhammoud", ")"], "sections": {"ERC-7410: ERC-20 Update Allowance By Spender": "This extension adds adecreaseAllowanceBySpenderfunction to decreaseERC-20allowances, in which a spender can revoke or decrease a given allowance by a specific address. This ERC extendsERC-20.", "Extension to enable revoking and decreasing allowance approval by spender for ERC-20": "This extension adds adecreaseAllowanceBySpenderfunction to decreaseERC-20allowances, in which a spender can revoke or decrease a given allowance by a specific address. This ERC extendsERC-20.", "Abstract": "This extension adds adecreaseAllowanceBySpenderfunction to decreaseERC-20allowances, in which a spender can revoke or decrease a given allowance by a specific address. This ERC extendsERC-20.", "Motivation": "Currently,ERC-20tokens offer allowances, enabling token owners to authorize spenders to use a designated amount of tokens on their behalf. However, the process of decreasing an allowance is limited to the owner\u2019s side, which can be problematic if the token owner is a treasury wallet or a multi-signature wallet that has granted an excessive allowance to a spender. In such cases, reducing the allowance from the owner\u2019s perspective can be time-consuming and challenging.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Interface implementation": "ThedecreaseAllowanceBySpender(address owner, uint256 subtractedValue)function MUST be eitherpublicorexternal.", "Rationale": "The technical design choices within this ERC are driven by the following considerations:", "Backwards Compatibility": "This standard is compatible withERC-20.", "Reference Implementation": "An minimal implementation is includedhere.", "Security Considerations": "Users of this ERC must thoroughly consider the amount of tokens they decrease from their allowance for anowner.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7412, "url": "https://eips.ethereum.org/EIPS/eip-7412", "title": "On-Demand Off-Chain Data Retrieval", "authors": ["Noah Litvin\u00a0(", "@noahlitvin", ")", "db\u00a0(", "@dbeal-eth", ")"], "sections": {"ERC-7412: On-Demand Off-Chain Data Retrieval": "Contracts may require off-chain data during execution. A smart contract function could implement the standard proposed here by reverting witherror OracleDataRequired(address oracleContract, bytes oracleQuery, uint256 feeRequired). Clients supporting this standard would recognize this error message during a simulation of the request, query the specified decentralized oracle network for signed data, and instead stage a transaction with a multicall that prepends the verification of the required off-chain data. The data would be written on-chain during verification to a smart contract for the subsequent call to read, avoiding the error.", "A method to construct multicalls with prepended verifiable off-chain data": "Contracts may require off-chain data during execution. A smart contract function could implement the standard proposed here by reverting witherror OracleDataRequired(address oracleContract, bytes oracleQuery, uint256 feeRequired). Clients supporting this standard would recognize this error message during a simulation of the request, query the specified decentralized oracle network for signed data, and instead stage a transaction with a multicall that prepends the verification of the required off-chain data. The data would be written on-chain during verification to a smart contract for the subsequent call to read, avoiding the error.", "Abstract": "Contracts may require off-chain data during execution. A smart contract function could implement the standard proposed here by reverting witherror OracleDataRequired(address oracleContract, bytes oracleQuery, uint256 feeRequired). Clients supporting this standard would recognize this error message during a simulation of the request, query the specified decentralized oracle network for signed data, and instead stage a transaction with a multicall that prepends the verification of the required off-chain data. The data would be written on-chain during verification to a smart contract for the subsequent call to read, avoiding the error.", "Motivation": "Ethereum\u2019s scaling roadmap involves a series of separate execution contexts for smart contract code (including layer two and layer three scaling solutions). This makes the ability to read data across multiple chains crucial to the construction of scalable applications. Also, for decentralized finance protocols that rely on price data, it is not reasonable to expect oracle networks will be able to continuously push fresh data to every layer two and layer three network for an arbitrary number of price feeds.", "Specification": "A contract implementing this standard MUST revert with the following error whenever off-chain data is required:", "Rationale": "This proposal is essentially an alternative toERC-3668with a couple notable distinctions:", "Reference Implementation": "The following pseudocode illustrates an oversimplified version of the client SDK. Ideally, this could be implemented in wallets, but it could also be built into the application layer. This function takes a desired transaction and converts it into a multicall with the required data verification transactions prepended such that theOracleDataRequirederrors would be avoided:", "Security Considerations": "One potential risk introduced by this standard is that its reliance on multicalls could obfuscate transaction data in wallet applications that do not have more sophisticated transaction decoding functionality. This is an existing challenge being addressed by wallet application developers, as multicalls are increasingly common in protocol development outside of this standard.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7425, "url": "https://eips.ethereum.org/EIPS/eip-7425", "title": "Tokenized Reserve", "authors": ["Jimmy Debe\u00a0(", "@jimstir", ")"], "sections": {"ERC-7425: Tokenized Reserve": "This specification explains a tokenized reserve mechanism standard. Current smart contracts record transactions and are made public. The reserve will implement added functionality allowing stakeholders proactively to audit a contract. UsingERC-4626, stakeholders can create shares to show support for actions in the contract.", "Transparent reserve fund on-chain with stakeholder participation.": "This specification explains a tokenized reserve mechanism standard. Current smart contracts record transactions and are made public. The reserve will implement added functionality allowing stakeholders proactively to audit a contract. UsingERC-4626, stakeholders can create shares to show support for actions in the contract.", "Abstract": "This specification explains a tokenized reserve mechanism standard. Current smart contracts record transactions and are made public. The reserve will implement added functionality allowing stakeholders proactively to audit a contract. UsingERC-4626, stakeholders can create shares to show support for actions in the contract.", "Motivation": "Tokenized vaults storeERC-20tokens that are represented by shares within vault contracts. Implementations can follow theERC-4626standard to provide basic functionality for depositing, withdrawing, and reading balances for a vault. As tokenization becomes increasingly popular, applications should use a form of tokenized vaults to store assets and allow all parties to track performance.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Definitions:": "This proposed standard is designed to be a core implementation of a tokenized reserve interface. Other non-specified conditions should be addressed on a case-by-case basis. Each reserve usesERC-20standard for shares, andERC-4626for the creation of shares. The reserve token SHOULD be considered as either the underlyingassetfor theERC-4626vault or the shares that are created when depositing to the vault.ERC-4626is used to create a transparent creation of stakeholders of the reserve. There MUST be a representation of interested parties in the reserve. The implementer can decide how to treat representation based on users entering and leaving the vault. For example, a user could be forced not to use the same tokens in multiple policies to allow shares to be distributed fairly.", "Constructor:": "This proposed standard is designed to be a core implementation of a tokenized reserve interface. Other non-specified conditions should be addressed on a case-by-case basis. Each reserve usesERC-20standard for shares, andERC-4626for the creation of shares. The reserve token SHOULD be considered as either the underlyingassetfor theERC-4626vault or the shares that are created when depositing to the vault.ERC-4626is used to create a transparent creation of stakeholders of the reserve. There MUST be a representation of interested parties in the reserve. The implementer can decide how to treat representation based on users entering and leaving the vault. For example, a user could be forced not to use the same tokens in multiple policies to allow shares to be distributed fairly.", "Interface": "This proposed standard is designed to be a core implementation of a tokenized reserve interface. Other non-specified conditions should be addressed on a case-by-case basis. Each reserve usesERC-20standard for shares, andERC-4626for the creation of shares. The reserve token SHOULD be considered as either the underlyingassetfor theERC-4626vault or the shares that are created when depositing to the vault.ERC-4626is used to create a transparent creation of stakeholders of the reserve. There MUST be a representation of interested parties in the reserve. The implementer can decide how to treat representation based on users entering and leaving the vault. For example, a user could be forced not to use the same tokens in multiple policies to allow shares to be distributed fairly.", "Rationale": "This proposed standard is designed to be a core implementation of a tokenized reserve interface. Other non-specified conditions should be addressed on a case-by-case basis. Each reserve usesERC-20standard for shares, andERC-4626for the creation of shares. The reserve token SHOULD be considered as either the underlyingassetfor theERC-4626vault or the shares that are created when depositing to the vault.ERC-4626is used to create a transparent creation of stakeholders of the reserve. There MUST be a representation of interested parties in the reserve. The implementer can decide how to treat representation based on users entering and leaving the vault. For example, a user could be forced not to use the same tokens in multiple policies to allow shares to be distributed fairly.", "Backwards Compatibility": "Tokenized reserves are made compatible withERC-20andERC-4626.", "Security Considerations": "Tokenized reserves share the same security considerations asERC-20andERC-4626.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7444, "url": "https://eips.ethereum.org/EIPS/eip-7444", "title": "Time Locks Maturity", "authors": ["Thanh Trinh (@thanhtrinh2003)\u00a0<", "thanh@revest.finance", ">", "Joshua Weintraub (@jhweintraub)\u00a0<", "josh@revest.finance", ">", "Rob Montgomery (@RobAnon)\u00a0<", "rob@revest.finance", ">"], "sections": {"ERC-7444: Time Locks Maturity": "This EIP defines a standardized method to communicate the date on which a time-locked system will become unlocked. This allows for the determination of maturities for a wide variety of asset classes and increases the ease with which these assets may be valued.", "Interface for conveying the date upon which a time-locked system becomes unlocked": "This EIP defines a standardized method to communicate the date on which a time-locked system will become unlocked. This allows for the determination of maturities for a wide variety of asset classes and increases the ease with which these assets may be valued.", "Abstract": "This EIP defines a standardized method to communicate the date on which a time-locked system will become unlocked. This allows for the determination of maturities for a wide variety of asset classes and increases the ease with which these assets may be valued.", "Motivation": "Time-locks are ubiquitous, yet no standard on how to determine the date upon which they unlock exists. Time-locked assets experience theta-decay, where the time remaining until they become unlocked dictates their value. Providing a universal standard to view what date they mature on allows for improved on-chain valuations of the rights to these illiquid assets, particularly useful in cases where the rights to these illiquid assets may be passed between owners through semi-liquid assets such asERC-721orERC-1155.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "Locked Assets have become increasingly popular and used in different parts of defi, such as yield farming and vested escrow concept. This has increased the need to formalize and define an universal interface for all these timelocked assets.", "Universal Maturities on Locked Assets": "Locked Assets have become increasingly popular and used in different parts of defi, such as yield farming and vested escrow concept. This has increased the need to formalize and define an universal interface for all these timelocked assets.", "Valuation of Locked Assets via the Black-Scholes Model": "Locked Assets cannot be valued normally since the value of these assets can be varied through time and many other different factors throughout the locking time. For instance, The Black-Scholes Model or Black-Scholes-Merton model is an example of a suitable model to estimate the theoretical value of asset with the consideration of impact of time and other potential risks.", "Backwards Compatibility": "This standard can be implemented as an extension toERC-721and/orERC-1155tokens with time-locked functionality, many of which can be retrofitted with a designated contract to determine the point at which their time locks release.", "Reference Implementation": "Users or developers should be aware of potential extendable timelocks, where the returned timestamp can be modified through protocols. Users or protocols should check the timestamp carefully before trading or lending with others.", "LockedERC-20implementation": "Users or developers should be aware of potential extendable timelocks, where the returned timestamp can be modified through protocols. Users or protocols should check the timestamp carefully before trading or lending with others.", "Security Considerations": "Users or developers should be aware of potential extendable timelocks, where the returned timestamp can be modified through protocols. Users or protocols should check the timestamp carefully before trading or lending with others.", "Extendable Time Locks": "Users or developers should be aware of potential extendable timelocks, where the returned timestamp can be modified through protocols. Users or protocols should check the timestamp carefully before trading or lending with others.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7484, "url": "https://eips.ethereum.org/EIPS/eip-7484", "title": "Registry Extension for ERC-7579", "authors": ["Konrad Kopp\u00a0(", "@kopy-kat", ")", "zeroknots\u00a0(", "@zeroknots", ")"], "sections": {"ERC-7484: Registry Extension for ERC-7579": "This proposal standardizes the interface and functionality of Module Registries, allowing modular smart accounts to verify the security of modules using a Registry Adapter. It also provides a reference implementation of a Singleton Module Registry.", "Adapters that allow modular smart accounts to verify the security of modules using a Module Registry": "This proposal standardizes the interface and functionality of Module Registries, allowing modular smart accounts to verify the security of modules using a Registry Adapter. It also provides a reference implementation of a Singleton Module Registry.", "Abstract": "This proposal standardizes the interface and functionality of Module Registries, allowing modular smart accounts to verify the security of modules using a Registry Adapter. It also provides a reference implementation of a Singleton Module Registry.", "Motivation": "ERC-4337standardizes the execution flow of contract accounts andERC-7579standardizes the modular implementation of these accounts, allowing any developer to build modules for these modular accounts (hereafter Smart Accounts). However, adding third-party modules into Smart Accounts unchecked opens up a wide range of attack vectors.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Definitions": "The core interface for a Registry is as follows:", "Required Registry functionality": "The core interface for a Registry is as follows:", "Adapter behavior": "A Smart Account MUST implement the following Adapter functionality either natively in the account or as a module. This Adapter functionality MUST ensure that:", "Rationale": "Attestations are onchain assertions made about a module. These assertions could pertain to the security of a module (similar to a regular smart contract audit), whether a module adheres to a certain standard or any other kinds of statements about these modules. While some of these assertions can feasibly be verified onchain, the majority of them cannot be.", "Attestations": "Attestations are onchain assertions made about a module. These assertions could pertain to the security of a module (similar to a regular smart contract audit), whether a module adheres to a certain standard or any other kinds of statements about these modules. While some of these assertions can feasibly be verified onchain, the majority of them cannot be.", "Singleton Registry": "In order for attestations to be queryable onchain, they need to be stored in some sort of list in a smart contract. This proposal includes the reference implementation of an ownerless Singleton Registry that functions as the source of truth for attestations.", "Module Types": "Modules can be of different types and it can be important for an account to ensure that a module is of a certain type. For example, if an account wants to install a module that handles the validation logic of the account, then it might want to ensure that attesters have confirmed that the module is indeed capable of performing this validation logic. Otherwise, the account might be at risk of installing a module that is not capable of performing the validation logic, which could lead to an account being rendered unusable.", "Related work": "The reference implementation of the Registry is heavily inspired by the Ethereum Attestation Service. The specific use-case of this proposal, however, required some custom modifications and additions to EAS, meaning that using the existing EAS contracts as the Module Registry was sub-optimal. However, it would be possible to use EAS as a Module Registry with some modifications.", "Backwards Compatibility": "No backward compatibility issues found.", "Reference Implementation": "Note: This is a specific example that complies to theSpecificationabove, but this implementation is not binding.", "Adapter.sol": "Note: This is a specific example that complies to theSpecificationabove, but this implementation is not binding.", "Account.sol": "Note: This is a specific example that complies to theSpecificationabove, but this implementation is not binding.", "Registry": "Needs discussion.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7496, "url": "https://eips.ethereum.org/EIPS/eip-7496", "title": "NFT Dynamic Traits", "authors": ["Adam Montgomery\u00a0(", "@montasaurus", ")", "Ryan Ghods\u00a0(", "@ryanio", ")", "0age\u00a0(", "@0age", ")", "James Wenzel\u00a0(", "@emo-eth", ")", "Stephan Min\u00a0(", "@stephankmin", ")"], "sections": {"ERC-7496: NFT Dynamic Traits": "This specification introduces a new interface that extendsERC-721andERC-1155that defines methods for setting and getting dynamic onchain traits associated with non-fungible tokens. These dynamic traits can be used to represent properties, characteristics, redeemable entitlements, or other attributes that can change over time. By defining these traits onchain, they can be used and modified by other onchain contracts.", "Extension to ERC-721 and ERC-1155 for dynamic onchain traits": "This specification introduces a new interface that extendsERC-721andERC-1155that defines methods for setting and getting dynamic onchain traits associated with non-fungible tokens. These dynamic traits can be used to represent properties, characteristics, redeemable entitlements, or other attributes that can change over time. By defining these traits onchain, they can be used and modified by other onchain contracts.", "Abstract": "This specification introduces a new interface that extendsERC-721andERC-1155that defines methods for setting and getting dynamic onchain traits associated with non-fungible tokens. These dynamic traits can be used to represent properties, characteristics, redeemable entitlements, or other attributes that can change over time. By defining these traits onchain, they can be used and modified by other onchain contracts.", "Motivation": "Trait values for non-fungible tokens are often stored offchain. This makes it difficult to query and mutate these values in contract code. Specifying the ability to set and get traits onchain allows for new use cases like redeeming onchain entitlements and transacting based on a token\u2019s traits.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Keys & Names": "ThetraitKeyis used to identify a trait. ThetraitKeyMUST be a uniquebytes32value identifying a single trait.", "Metadata": "Trait metadata is necessary to provide information about which traits are present in a contract, how to display trait names and values, and other optional features.", "Events": "Updating traits MUST emit one of:", "setTrait": "If a trait definestokenOwnerCanUpdateValueastrue, then the trait value MUST be updatable by the token owner by callingsetTrait.", "Rationale": "The design of this specification is primarily a key-value mapping for maximum flexibility. This interface for traits was chosen instead of relying on using regulargetFoo()andsetFoo()style functions to allow for brevity in defining, setting, and getting traits. Otherwise, contracts would need to know both the getter and setter function selectors including the parameters that go along with it. In defining general but explicit get and set functions, the function signatures are known and only the trait key and values are needed to query and set the values. Contracts can also add new traits in the future without needing to modify contract code.", "Backwards Compatibility": "As a new EIP, no backwards compatibility issues are present, except for the point in the specification above that it is explicitly required that the onchain traits MUST override any conflicting values specified by the ERC-721 or ERC-1155 metadata URIs.", "Test Cases": "Authors have included Foundry tests covering functionality of the specification in theassets folder.", "Reference Implementation": "Authors have included reference implementations of the specification in theassets folder.", "Security Considerations": "The set* methods exposed externally MUST be permissioned so they are not callable by everyone but only by select roles or addresses.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7498, "url": "https://eips.ethereum.org/EIPS/eip-7498", "title": "NFT Redeemables", "authors": ["Ryan Ghods\u00a0(", "@ryanio", ")", "0age\u00a0(", "@0age", ")", "Adam Montgomery\u00a0(", "@montasaurus", ")", "Stephan Min\u00a0(", "@stephankmin", ")"], "sections": {"ERC-7498: NFT Redeemables": "This specification introduces a new interface that extendsERC-721andERC-1155to enable the discovery and use of onchain and offchain redeemables for NFTs. Onchain getters and events facilitate discovery of redeemable campaigns and their requirements. New onchain mints use an interface that gives context to the minting contract of what was redeemed. For redeeming physical products and goods (offchain redeemables) aredemptionHashandsignercan tie onchain redemptions with offchain order identifiers that contain chosen product and shipping information.", "Extension to ERC-721 and ERC-1155 for onchain and offchain redeemables": "This specification introduces a new interface that extendsERC-721andERC-1155to enable the discovery and use of onchain and offchain redeemables for NFTs. Onchain getters and events facilitate discovery of redeemable campaigns and their requirements. New onchain mints use an interface that gives context to the minting contract of what was redeemed. For redeeming physical products and goods (offchain redeemables) aredemptionHashandsignercan tie onchain redemptions with offchain order identifiers that contain chosen product and shipping information.", "Abstract": "This specification introduces a new interface that extendsERC-721andERC-1155to enable the discovery and use of onchain and offchain redeemables for NFTs. Onchain getters and events facilitate discovery of redeemable campaigns and their requirements. New onchain mints use an interface that gives context to the minting contract of what was redeemed. For redeeming physical products and goods (offchain redeemables) aredemptionHashandsignercan tie onchain redemptions with offchain order identifiers that contain chosen product and shipping information.", "Motivation": "Creators frequently use NFTs to create redeemable entitlements for digital and physical goods. However, without a standard interface, it is challenging for users and apps to discover and interact with these NFTs in a predictable and standard way. This standard aims to encompass enabling broad functionality for:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Creating campaigns": "When creating a new campaign,createCampaignMUST be used and MUST return the newly createdcampaignIdalong with theCampaignUpdatedevent. ThecampaignIdMUST be a counter incremented with each new campaign. The first campaign MUST have an id of1.", "Updating campaigns": "Updates to campaigns MAY useupdateCampaignand MUST emit theCampaignUpdatedevent. If an address other than themanagertries to update the campaign, it MUST revert withNotManager(). If the manager wishes to make the campaign immutable, themanagerMAY be set to the null address.", "Offer": "If tokens are set in the paramsoffer, the tokens MUST implement theIRedemptionMintableinterface in order to support minting new items. The implementation SHOULD be however the token mechanics are desired. The implementing token MUST return true for ERC-165supportsInterfacefor the interfaceId ofIRedemptionMintable,0x81fe13c2.", "Consideration": "Any token may be specified in the campaign requirementconsideration. This will ensure the token is transferred to therecipient. If the token is meant to be burned, the recipient SHOULD be0x000000000000000000000000000000000000dEaD. If the token can internally handle burning its own tokens and reducing totalSupply, the token MAY burn the token instead of transferring to the recipient0x000000000000000000000000000000000000dEaD.", "Dynamic traits": "Including trait redemptions is optional, but if the token would like to enable trait redemptions the token MUST includeERC-7496Dynamic Traits.", "Signer": "A signer MAY be specified to provide a signature to process the redemption. If the signer is not the null address, the signature MUST recover to the signer address viaEIP-712orERC-1271.", "Redeem function": "Theredeemfunction MUST use theconsideration,offer, andtraitRedemptionsspecified by therequirementsdetermined by thecampaignIdandrequirementsIndex:", "Trait redemptions": "The token MUST respect the TraitRedemption substandards as follows:", "Max campaign redemptions": "The token MUST check that themaxCampaignRedemptionsis not exceeded. If the redemption does exceedmaxCampaignRedemptions, it MUST revert withMaxCampaignRedemptionsReached(uint256 total, uint256 max)", "Metadata URI": "The metadata URI MUST conform to the below JSON schema:", "ERC-1155 (Semi-fungibles)": "This standard MAY be applied to ERC-1155 but the redemptions would apply to all token amounts for specific token identifiers. If the ERC-1155 contract only has tokens with amount of 1, then this specification MAY be used as written.", "Rationale": "The \u201coffer\u201d and \u201cconsideration\u201d structs from Seaport were used to create a similar language for redeemable campaigns. The \u201coffer\u201d is what is being offered, e.g. a new onchain token, and the \u201cconsideration\u201d is what must be satisfied to complete the redemption. The \u201cconsideration\u201d field has a \u201crecipient\u201d, who the token should be transferred to. For trait updates that do not require moving of a token,traitRedemptionTokenIdsis specified instead.", "Backwards Compatibility": "As a new EIP, no backwards compatibility issues are present.", "Test Cases": "Authors have included Foundry tests covering functionality of the specification in theassets folder.", "Reference Implementation": "Authors have included reference implementations of the specification in theassets folder.", "Security Considerations": "If trait redemptions are desired, tokens implementing this EIP must properly implementERC-7496Dynamic Traits.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7506, "url": "https://eips.ethereum.org/EIPS/eip-7506", "title": "Trusted Hint Registry", "authors": ["Philipp Bolte\u00a0(", "@strumswell", ")", "Dennis von der Bey\u00a0(", "@DennisVonDerBey", ")", "Lauritz Leifermann\u00a0(", "@lleifermann", ")"], "sections": {"ERC-7506: Trusted Hint Registry": "This EIP standardizes a system for managing on-chain metadata (hints), enabling claim interpretation, reliability, \nand verification. It structures these hints within defined namespaces and lists, enabling structured organization and \nretrieval, as well as permissioned write access. The system permits namespace owners to delegate hint management tasks, \nenhancing operational flexibility. It incorporates secure meta transactions viaEIP-712-enabled \nsignatures and offers optional ENS integration for trust verification and discoverability. The interface is equipped to\nemit specific events for activities like hint modifications, facilitating easy traceability of changes to hints. This \nsetup aims to provide a robust, standardized framework for managing claim- and ecosystem-related metadata, essential for \nmaintaining integrity and trustworthiness in decentralized environments.", "A system for managing on-chain metadata, enabling verification of ecosystem claims.": "This EIP standardizes a system for managing on-chain metadata (hints), enabling claim interpretation, reliability, \nand verification. It structures these hints within defined namespaces and lists, enabling structured organization and \nretrieval, as well as permissioned write access. The system permits namespace owners to delegate hint management tasks, \nenhancing operational flexibility. It incorporates secure meta transactions viaEIP-712-enabled \nsignatures and offers optional ENS integration for trust verification and discoverability. The interface is equipped to\nemit specific events for activities like hint modifications, facilitating easy traceability of changes to hints. This \nsetup aims to provide a robust, standardized framework for managing claim- and ecosystem-related metadata, essential for \nmaintaining integrity and trustworthiness in decentralized environments.", "Abstract": "This EIP standardizes a system for managing on-chain metadata (hints), enabling claim interpretation, reliability, \nand verification. It structures these hints within defined namespaces and lists, enabling structured organization and \nretrieval, as well as permissioned write access. The system permits namespace owners to delegate hint management tasks, \nenhancing operational flexibility. It incorporates secure meta transactions viaEIP-712-enabled \nsignatures and offers optional ENS integration for trust verification and discoverability. The interface is equipped to\nemit specific events for activities like hint modifications, facilitating easy traceability of changes to hints. This \nsetup aims to provide a robust, standardized framework for managing claim- and ecosystem-related metadata, essential for \nmaintaining integrity and trustworthiness in decentralized environments.", "Motivation": "In an increasingly interconnected and decentralized landscape, the formation of trust among entities remains a critical\nconcern. Ecosystems, both on-chain and off-chain\u2014spanning across businesses, social initiatives, and other organized\nframeworks\u2014frequently issue claims for or about entities within their networks. These claims serve as the foundational\nelements of trust, facilitating interactions and transactions in environments that are essentially untrustworthy by\nnature. While the decentralization movement has brought about significant improvements around trustless technologies,\nmany ecosystems building on top of these are in need of technologies that build trust in their realm. Real-world\napplications have shown that verifiable claims alone are not enough for this purpose. Moreover, a supporting layer of\non-chain metadata is needed to support a reliable exchange and verification of those claims.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and\n\u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Definitions": "A method with the following signatureMUSTbe implemented that returns the hint value in a hint list of a namespace.", "Interface": "A method with the following signatureMUSTbe implemented that returns the hint value in a hint list of a namespace.", "Meta Transactions": "The signature of signed transactions could potentially be replayed on different chains or deployed versions of the\nregistry implementing this ERC. This security consideration is addressed by the usage\nofEIP-712.", "Trust Anchor via ENS": "Ecosystems that use an Ethereum Name Service (ENS) domain can increase trust by using ENS entries to share information\nabout a hint list registry. This method takes advantage of the ENS domain\u2019s established credibility to make it easier to\nfind a hint registry contract of the domain\u2019s entity, as well as the appropriate namespace and hint list customized for \nparticular ecosystem needs. Implementing a trust anchor through ENS isOPTIONAL.", "Rationale": "Examining the method signatures reveals a deliberate architecture and data hierarchy within this ERC: A namespace\naddress maps to a hint list, which in turn maps to a hint key, which then reveals the hint value.", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "The signature of signed transactions could potentially be replayed on different chains or deployed versions of the\nregistry implementing this ERC. This security consideration is addressed by the usage\nofEIP-712.", "Rights Management": "The different roles and their inherent permissions are meant to prevent changes from unauthorized entities. The hint\nlist owner should always be in complete control over its hint list and who has writing access to it.", "Governance": "It is recognized that ecosystems might have processes in place that might also apply to changes in hint lists. This ERC\nexplicitly leaves room for implementers or users of the registry to apply a process that fits the requirements of their\necosystem. Possible solutions can be an extension of the contract with governance features around specific methods, the\nusage of multi-sig wallets, or off-chain processes enforced by an entity.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7507, "url": "https://eips.ethereum.org/EIPS/eip-7507", "title": "Multi-User NFT Extension", "authors": ["Ming Jiang\u00a0(", "@minkyn", ")", "Zheng Han\u00a0(", "@hanbsd", ")", "Fan Yang\u00a0(", "@fayang", ")"], "sections": {"ERC-7507: Multi-User NFT Extension": "This standard is an extension ofERC-721. It proposes a new roleuserin addition toownerfor a token. A token can have multiple users under separate expiration time. It allows the subscription model where an NFT can be subscribed non-exclusively by different users.", "An extension of ERC-721 to allow multiple users to a token with restricted permissions.": "This standard is an extension ofERC-721. It proposes a new roleuserin addition toownerfor a token. A token can have multiple users under separate expiration time. It allows the subscription model where an NFT can be subscribed non-exclusively by different users.", "Abstract": "This standard is an extension ofERC-721. It proposes a new roleuserin addition toownerfor a token. A token can have multiple users under separate expiration time. It allows the subscription model where an NFT can be subscribed non-exclusively by different users.", "Motivation": "Some NFTs represent IP assets, and IP assets have the need to be licensed for access without transferring ownership. The subscription model is a very common practice for IP licensing where multiple users can subscribe to an NFT to obtain access. Each subscription is usually time limited and will thus be recorded with an expiration time.", "Specification": "Solidity interface available atIERC7507.sol:", "Rationale": "This standard complementsERC-4907to support multi-user feature. Therefore the proposed interface tries to keep consistent using the same naming for functions and parameters.", "Backwards Compatibility": "No backwards compatibility issues found.", "Test Cases": "Test cases available available at:ERC7507.test.ts:", "Reference Implementation": "Reference implementation available at:ERC7507.sol:", "Security Considerations": "No security considerations found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7508, "url": "https://eips.ethereum.org/EIPS/eip-7508", "title": "Dynamic On-Chain Token Attributes Repository", "authors": ["Steven Pineda\u00a0(", "@steven2308", ")", "Jan Turk\u00a0(", "@ThunderDeliverer", ")"], "sections": {"ERC-7508: Dynamic On-Chain Token Attributes Repository": "The Public On-Chain Non-Fungible Token Attributes Repository standard provides the ability forERC-721andERC-1155compatible tokens to store their attributes on-chain available to any external smart contract interacting with them.", "Dynamic on-chain storage of token attributes in a public-good repository.": "The Public On-Chain Non-Fungible Token Attributes Repository standard provides the ability forERC-721andERC-1155compatible tokens to store their attributes on-chain available to any external smart contract interacting with them.", "Abstract": "The Public On-Chain Non-Fungible Token Attributes Repository standard provides the ability forERC-721andERC-1155compatible tokens to store their attributes on-chain available to any external smart contract interacting with them.", "Motivation": "With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having the ability to store token\u2019s attributes on chain allows for greater utility of tokens as it fosters cross-collection interactivity and provides perpetual store of attributes.", "Cross-Collection Interactivity": "Storing attributes on-chain in a predictable format allows for cross-collection interactivity. This means that the attributes of a token can be used by any external smart contract without the need for the token to be aware of the external smart contract.", "Perpetual Store of Attributes": "Standardized on-chain token attributes allow for their perpetual storage.", "Token Evolution": "On-Chain storage of token attributes allows for the token to evolve over time. Owner\u2019s actions can impact the attributes of the token. Since the attributes are stored on chain, the smart contract has the ability to modify the attribute once certain thresholds are met. This allows for token to become more interactive and reflect owner\u2019s dedication and effort.", "Dynamic State Tracking": "On-Chain storage of token attributes allows for dynamic state tracking. The attributes can be used to track the state of the token and its owner. This allows for the token to be used in a variety of use cases. One such use case is supply chains; the token can represent a product and its attributes can be used to track the state of the product as it transitions from pending, shipped, delivered, etc.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Interface": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Schema": "In addition to the interface we propose that collection owers SHOULD be able to set the schema for the attributes of their collection. We distinguish between 2 types: token attributes and collection attributes. The latter are the attributes that are shared by all tokens in the collection, they can be retrieved and set by using the max uint256 value as tokenId.", "Message format for presigned attribute": "The message to be signed by thesetterin order for the attribute setting to be submitted by someone else is formatted as follows:", "Pre-determined address of the Attributes repository": "The address of the Emotable repository smart contract is designed to resemble the function it serves. It starts with0xA77B75which is the abstract representation ofATTBTS. The address is TBD.", "Rationale": "Designing the proposal, we considered the following questions:", "Backwards Compatibility": "The Attributes repository standard is fully compatible withERC-721andERC-1155and with the robust tooling available for implementations of ERC-721 as well as with the existing ERC-721 infrastructure.", "Test Cases": "Tests are included inattributesRepository.ts.", "Reference Implementation": "SeeAttributesRepository.sol.", "Security Considerations": "The proposal does not envision handling any form of assets from the user, so the assets should not be at risk when interacting with an Attributes repository.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7509, "url": "https://eips.ethereum.org/EIPS/eip-7509", "title": "Entity Component System", "authors": ["Rickey\u00a0(", "@HelloRickey", ")"], "sections": {"ERC-7509: Entity Component System": "This proposal defines a minimal Entity Component System (ECS). Entities are unique identities that are assigned to multiple components (data) and then processed using the system (logic).\nThis proposal standardizes the interface specification for using ECS in smart contracts, providing a set of basic functions that allow users to freely combine and manage multi-contract applications.", "Represent entities comprising components of data, with systems which operate on entities' components.": "This proposal defines a minimal Entity Component System (ECS). Entities are unique identities that are assigned to multiple components (data) and then processed using the system (logic).\nThis proposal standardizes the interface specification for using ECS in smart contracts, providing a set of basic functions that allow users to freely combine and manage multi-contract applications.", "Abstract": "This proposal defines a minimal Entity Component System (ECS). Entities are unique identities that are assigned to multiple components (data) and then processed using the system (logic).\nThis proposal standardizes the interface specification for using ECS in smart contracts, providing a set of basic functions that allow users to freely combine and manage multi-contract applications.", "Motivation": "ECS is a design pattern that improves code reusability by separating data from behavior. It is often used in game development. A minimal ECS consists ofEntity: a unique identifier.Component: a reusable data container attached to an entity.System: the logic for operating entity components.World: a container for an entity component system.This proposal uses smart contracts to implement an easy-to-use minimal ECS, eliminates unnecessary complexity, and makes some functional improvements that are consistent with contract interaction behavior. You can combine components and systems easily and freely.\nAs a smart contract developer, the benefits of adopting ECS include:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Interfaces": "The libraryTypes.solcontains an enumeration of Solidity types used in the above interfaces.", "Library": "The libraryTypes.solcontains an enumeration of Solidity types used in the above interfaces.", "Rationale": "This is to ensure the correctness of types when using components, in order to avoid potential errors and inconsistencies. External developers can clearly set and get based on the type.", "Why include type information instead of simple\u00a0byte\u00a0arrays?": "This is to ensure the correctness of types when using components, in order to avoid potential errors and inconsistencies. External developers can clearly set and get based on the type.", "Why differentiate between a non-existent entity and an entity with false state?": "We cannot judge whether an entity actually exists based on its state alone. External contributors can create components based on entities. If the entities he uses don\u2019t exist, the components he creates may not make sense. Component creators should first check if the entity exists, and if the entity does exist, it makes sense even if the entity\u2019s state is false. Because he can wait for the entity state to be true before attaching the component to the entity.", "WhygetEntityComponentsfunction returns all addresses of components instead of all component ids?": "There are two designs forgetEntityComponents. The other design is to add an additional mapping for the storage of component id and component address. Every time we calladdComponent, the parameters of the function are the entity id and component id. When the user callsgetEntityComponents, it will returning an array of component ids, they query the component address with each component id, and then query the data based on each component address. Because a entity may contain many component ids, this will cause the user to request the component address multiple times. In the end, we chose to usegetEntityComponentsdirectly for all addresses owned by the entity.", "CanregisterComponentandregisterSystemprovide external permissions?": "It depends on the openness of your application or game. If you encourage developers to participate, the state of the component and system they submit for registration should befalse, and you need to check whether they have submitted malicious code before usingsetComponentStateandsetSystemStateto enable them .", "When to usegetwith extra parameters in component?": "The component provides twogetfunctions. Onegetfunction only needs to pass in the entity id, and the other has more_paramsparameters, which will be used as additional parameters for obtaining data. For example, you define a component that stores the HP corresponding to the level of an entity. If you want to get the HP of an entity that matches its level, then you call thegetfunction with the entity level as_params.", "Reference Implementation": "SeeEthereum ECS Example", "Security Considerations": "Unless you want to implement special functions, do not provide the following methods directly to ordinary users, they should be set by the contract owner.createEntity(),setEntityState(),addComponent(),removeComponent(),registerComponent(),setComponentState(),registerSystem(),setSystemState()", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7510, "url": "https://eips.ethereum.org/EIPS/eip-7510", "title": "Cross-Contract Hierarchical NFT", "authors": ["Ming Jiang\u00a0(", "@minkyn", ")", "Zheng Han\u00a0(", "@hanbsd", ")", "Fan Yang\u00a0(", "@fayang", ")"], "sections": {"ERC-7510: Cross-Contract Hierarchical NFT": "This standard is an extension ofERC-721. It proposes a way to maintain hierarchical relationship between tokens from different contracts. This standard provides an interface to query the parent tokens of an NFT or whether the parent relation exists between two NFTs.", "An extension of ERC-721 to maintain hierarchical relationship between tokens from different contracts.": "This standard is an extension ofERC-721. It proposes a way to maintain hierarchical relationship between tokens from different contracts. This standard provides an interface to query the parent tokens of an NFT or whether the parent relation exists between two NFTs.", "Abstract": "This standard is an extension ofERC-721. It proposes a way to maintain hierarchical relationship between tokens from different contracts. This standard provides an interface to query the parent tokens of an NFT or whether the parent relation exists between two NFTs.", "Motivation": "Some NFTs want to generate derivative assets as new NFTs. For example, a 2D NFT image would like to publish its 3D model as a new derivative NFT. An NFT may also be derived from multiple parent NFTs. Such cases include a movie NFT featuring multiple characters from other NFTs. This standard is proposed to record such hierarchical relationship between derivative NFTs.", "Specification": "Solidity interface available atIERC7510.sol:", "Rationale": "This standard differs fromERC-6150in mainly two aspects: supporting cross-contract token reference, and allowing multiple parents. But we try to keep the naming consistent overall.", "Backwards Compatibility": "No backwards compatibility issues found.", "Test Cases": "Test cases available at:ERC7510.test.ts:", "Reference Implementation": "Reference implementation available at:ERC7510.sol:", "Security Considerations": "Parent tokens of an NFT may point to invalid data for two reasons. First, parent tokens could be burned later. Second, a contract implementingsetParentTokensmight not check the validity ofparentTokensarguments. For security consideration, applications that retrieve parent tokens of an NFT need to verify they exist as valid tokens.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7511, "url": "https://eips.ethereum.org/EIPS/eip-7511", "title": "Minimal Proxy Contract with PUSH0", "authors": ["0xAA\u00a0(", "@AmazingAng", ")", "vectorized\u00a0(", "@Vectorized", ")", "0age\u00a0(", "@0age", ")"], "sections": {"ERC-7511: Minimal Proxy Contract with PUSH0": "With thePUSH0opcode (EIP-3855), introduced with the Shanghai upgrade, we optimized the previous Minimal Proxy Contract (ERC-1167) by 200 gas at deployment and 5 gas at runtime, while retaining the same functionality.", "Optimizes the previous Minimal Proxy Contract with the PUSH0 opcode": "With thePUSH0opcode (EIP-3855), introduced with the Shanghai upgrade, we optimized the previous Minimal Proxy Contract (ERC-1167) by 200 gas at deployment and 5 gas at runtime, while retaining the same functionality.", "Abstract": "With thePUSH0opcode (EIP-3855), introduced with the Shanghai upgrade, we optimized the previous Minimal Proxy Contract (ERC-1167) by 200 gas at deployment and 5 gas at runtime, while retaining the same functionality.", "Motivation": "The exact runtime code for the minimal proxy contract withPUSH0is:", "Specification": "The exact runtime code for the minimal proxy contract withPUSH0is:", "Standard Proxy Contract": "The exact runtime code for the minimal proxy contract withPUSH0is:", "Minimal Creation Code": "The minimal creation code of the minimal proxy contract is:", "Deploy with Solidity": "The minimal proxy contract can be deployed with Solidity using the following contract:", "Rationale": "The optimized contract is constructed with essential components of the proxy contract and incorporates the recently addedPUSH0opcode. The core elements of the minimal proxy include:", "Step 1: Copy the Calldata": "To copy the calldata, we need to provide the arguments for theCALLDATACOPYopcodes, which are[0, 0, cds], wherecdsrepresents calldata size.", "Step 2: Delegatecall": "To forward the calldata to the delegate call, we need to prepare arguments for theDELEGATECALLopcodes, which are[gas 0xbebe. 0 cds 0 0], wheregasrepresents the remaining gas,0xbebe.represents the address of the implementation contract, andsucrepresents whether the delegatecall is successful.", "Step 3: Copy the Returned Data from theDELEGATECALL": "To copy the returndata, we need to provide the arguments for theRETURNDATACOPYopcodes, which are[0, 0, red], whererdsrepresents size of returndata from theDELEGATECALL.", "Step 4: Return or Revert": "Lastly, we need to return the data or revert the transaction based on whether theDELEGATECALLis successful. There is noif/elsein opcodes, so we need to useJUMPIandJUMPDESTinstead. The arguments forJUMPIis[0x2a, suc], where0x2ais the destination of the conditional jump.", "Backwards Compatibility": "Because the new minimal proxy contract usesPUSH0opcode, it can only be deployed after the Shanghai Upgrade. It behaves the same as the previous Minimal Proxy Contract.", "Security Considerations": "The new proxy contract standard is identical to the previous one (ERC-1167). Here are the security considerations when using minimal proxy contracts:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- revert: All calls to this opcode must emit a log with revert data.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170."}
{"eip": 7512, "url": "https://eips.ethereum.org/EIPS/eip-7512", "title": "Onchain Representation for Audits", "authors": ["Richard Meissner - Safe\u00a0(", "@rmeissner", ")", "Robert Chen - OtterSec\u00a0(", "@chen-robert", ")", "Matthias Egli - ChainSecurity\u00a0(", "@MatthiasEgli", ")", "Jan Kalivoda - Ackee Blockchain\u00a0(", "@jaczkal", ")", "Michael Lewellen - OpenZeppelin\u00a0(", "@cylon56", ")", "Shay Zluf - Hats Finance\u00a0(", "@shayzluf", ")", "Alex Papageorgiou - Omniscia\u00a0(", "@alex-ppg", ")"], "sections": {"ERC-7512: Onchain Representation for Audits": "The proposal aims to create a standard for an onchain representation of audit reports that can be parsed by contracts to extract relevant information about the audits, such as who performed the audits and what standards have been verified.", "Proposal to define a contract parseable representation of Audit reports.": "The proposal aims to create a standard for an onchain representation of audit reports that can be parsed by contracts to extract relevant information about the audits, such as who performed the audits and what standards have been verified.", "Abstract": "The proposal aims to create a standard for an onchain representation of audit reports that can be parsed by contracts to extract relevant information about the audits, such as who performed the audits and what standards have been verified.", "Motivation": "Audits are an integral part of the smart contract security framework. They are commonly used to increase the security of smart contracts and ensure that they follow best practices as well as correctly implement standards suchERC-20,ERC-721, and similar ERCs. Many essential parts of the blockchain ecosystem are facilitated by the usage of smart contracts. Some examples of this are:", "Example": "Imagine a hypotheticalERC-1155token bridge. The goal is to create a scalable system where it is possible to easily register new tokens that can be bridged. To minimize the risk of malicious or faulty tokens being registered, audits will be used and verified onchain.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Audit Properties": "For signingEIP-712will be used. For this the main type is theAuditSummaryand as theEIP712Domainthe following definition applies:", "Auditor Verification": "For signingEIP-712will be used. For this the main type is theAuditSummaryand as theEIP712Domainthe following definition applies:", "Data types": "For signingEIP-712will be used. For this the main type is theAuditSummaryand as theEIP712Domainthe following definition applies:", "Signing": "For signingEIP-712will be used. For this the main type is theAuditSummaryand as theEIP712Domainthe following definition applies:", "Rationale": "The current ERC deliberately does not define thefindingsof an audit. Such a definition would require alignment on the definition of what severities are supported, what data of a finding should be stored onchain vs off-chain, and other similar finding-related attributes that are hard to strictly describe. Given the complexity of this task, we consider it to be outside the scope of this EIP. It is important to note that this ERC proposes that a signed audit summary indicates that a specific contract instance (specified by itschainIdanddeployment) has undergone a security audit.", "Further Considerations": "No backward compatibility issues have been identified in relation to current ERC standards.", "Future Extensions": "No backward compatibility issues have been identified in relation to current ERC standards.", "Backwards Compatibility": "No backward compatibility issues have been identified in relation to current ERC standards.", "Reference Implementation": "TBD.", "Security Considerations": "The premise of this ERC relies on proper key management by the auditors who partake in the system. If an auditor\u2019s key is compromised, they may be associated with seemingly audited or ERC-compliant contracts that ultimately could not comply with the standards. As a potential protection measure, the ERC may define an \u201cassociation\u201d of auditors (f.e. auditing companies) that would permit a secondary key to revoke existing signatures of auditors as a secondary security measure in case of an auditor\u2019s key compromise.", "Auditor Key Management": "The premise of this ERC relies on proper key management by the auditors who partake in the system. If an auditor\u2019s key is compromised, they may be associated with seemingly audited or ERC-compliant contracts that ultimately could not comply with the standards. As a potential protection measure, the ERC may define an \u201cassociation\u201d of auditors (f.e. auditing companies) that would permit a secondary key to revoke existing signatures of auditors as a secondary security measure in case of an auditor\u2019s key compromise.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7513, "url": "https://eips.ethereum.org/EIPS/eip-7513", "title": "Smart NFT - A Component for Intent-Centric", "authors": ["MJ Tseng (@TsengMJ)\u00a0<", "tsngmj@gmail.com", ">", "Clay (@Clay2018)\u00a0<", "clay.uw@outlook.com", ">", "Jeffery.c\u00a0<", "jeffery.c@a3sprotocol.xyz", ">", "Johnny.c\u00a0<", "johnny.c@a3sprotocol.xyz", ">"], "sections": {"ERC-7513: Smart NFT - A Component for Intent-Centric": "Smart NFT is the fusion of Smart Contract and NFT. An NFT with the logic of a Smart Contract can be executed, enabling on-chain interactions. Transitioning from an NFT to a Smart NFT is akin to going from a regular landline telephone to a smartphone, opening up broader and more intelligent possibilities for NFTs.", "This proposal defines a new type of NFT that combines smart contract execution logic, granting NFTs executable capabilities.": "Smart NFT is the fusion of Smart Contract and NFT. An NFT with the logic of a Smart Contract can be executed, enabling on-chain interactions. Transitioning from an NFT to a Smart NFT is akin to going from a regular landline telephone to a smartphone, opening up broader and more intelligent possibilities for NFTs.", "Abstract": "Smart NFT is the fusion of Smart Contract and NFT. An NFT with the logic of a Smart Contract can be executed, enabling on-chain interactions. Transitioning from an NFT to a Smart NFT is akin to going from a regular landline telephone to a smartphone, opening up broader and more intelligent possibilities for NFTs.", "Motivation": "Ethereum introduces smart contracts revolutionized the blockchain and paved the way for the flourishing ecosystem of decentralized applications (dApps). Also, the concept of non-fungible tokens (NFTs) was introduced throughERC-721, offering a paradigm for ownership verification.", "Usability with Security": "IA-NFT acts as a key of a smart contract. With no private key, no risk of private key leakage.", "IA-NFT as Native On-chain Asset": "For years, NFT stands for the ownership of a picture, a piece of artwork, a game item, a real-world asset. All these backed assets are in fact not crypto native. IA-NFT verify the ownership of a piece of code or a smart contract.", "Interaction Abstraction for the Intent Abstraction": "The on-chain interaction can be abstract to many functional module IA-NFTs and thus make the Interaction process more effective. Users can focus more on their intent rather than how to operate cross different dApps.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Overview": "The following section will define the interface specifications for three main objects: Smart-NFT, Smart-Manager, Intent-Proxy, and establish the interaction relationships between three primary roles (developer, verifier, user) and these objects.", "Smart-NFT Interface": "Before sending a registration request to Smart-Manager, developers should implement the following two core interfaces in Smart-NFT.", "Smart-Manager Interface": "The Smart-Manager interface defines 5 possible states for Smart-NFTs:\uff1a", "Intent-Proxy Interface": "Intent-Proxy interface defines an Action struct:", "Rationale": "In the technical implementation aspect, we chose to useERC-1155as the main contract for NFTs due to the consideration of increasing the reusability of Smart-NFTs. The reason for this choice is that bothERC-721andERC-1155are based on the concept of \u201ctoken IDs\u201d that point to NFTs. The key difference is thatERC-1155introduces the concept of \u201cshares,\u201d meaning that having at least one share gives you the right to use the functionality of that Smart-NFT. This concept can be likened to owning multiple smartphones of the same model, where owning several smartphones doesn\u2019t grant you additional features; you can only use the features of each individual device.", "Why using ERC-1155": "In the technical implementation aspect, we chose to useERC-1155as the main contract for NFTs due to the consideration of increasing the reusability of Smart-NFTs. The reason for this choice is that bothERC-721andERC-1155are based on the concept of \u201ctoken IDs\u201d that point to NFTs. The key difference is thatERC-1155introduces the concept of \u201cshares,\u201d meaning that having at least one share gives you the right to use the functionality of that Smart-NFT. This concept can be likened to owning multiple smartphones of the same model, where owning several smartphones doesn\u2019t grant you additional features; you can only use the features of each individual device.", "Verifier": "In this protocol, Verifiers play a crucial role, responsible for auditing and verifying Smart-NFT code. However, decentralized Verifiers face some highly challenging issues, with one of the primary concerns being the specialized expertise required for their role, which is not easily accessible to the general population.", "Copyright infringement issue": "Code plagiarism has always been a topic of concern, but often, such discussions seem unnecessary. We present two key points: first, overly simple code has no value, making discussions about plagiarism irrelevant. Secondly, when code is complex enough or creative, legal protection can be obtained through open-source licenses (OSI).", "Backwards Compatibility": "This proposal aims to ensure the highest possible compatibility with the existingERC-1155protocol. All functionalities present inERC-1155, includingERC-165detection and Smart-NFT support, are retained. This encompasses compatibility with current NFT trading platforms.", "Reference Implementation": "Seehttps://github.com/TsengMJ/EIP-7513_Example", "Security Considerations": "All activities involving human intervention inherently carry the risk of malicious behavior. In this protocol, during the verification phase of Smart-NFTs, external validators provide guarantees. However, this structure raises concerns about the possibility of malicious validators intentionally endorsing Malicious Smart-NFTs. To mitigate this risk, it\u2019s necessary to implement stricter validation mechanisms, filtering of validators, punitive measures, or even more stringent consensus standards.", "Malicious Validator": "All activities involving human intervention inherently carry the risk of malicious behavior. In this protocol, during the verification phase of Smart-NFTs, external validators provide guarantees. However, this structure raises concerns about the possibility of malicious validators intentionally endorsing Malicious Smart-NFTs. To mitigate this risk, it\u2019s necessary to implement stricter validation mechanisms, filtering of validators, punitive measures, or even more stringent consensus standards.", "Unexpected Verification Error": "Apart from the issue of Malicious Validators, there\u2019s the possibility of missed detection during the verification phase due to factors like overly complex Smart-NFT implementations or vulnerabilities in the Solidity compiler. This issue can only be addressed by employing additional tools to assist in contract auditing or by implementing multiple validator audits for the auditTo interface to reduce the likelihood of its occurrence.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7517, "url": "https://eips.ethereum.org/EIPS/eip-7517", "title": "Content Consent for AI/ML Data Mining", "authors": ["Bofu Chen\u00a0(", "@bafu", ")", "Tammy Yang\u00a0(", "@tammyyang", ")"], "sections": {"ERC-7517: Content Consent for AI/ML Data Mining": "This EIP proposes a standardized approach to declaring mining preferences for digital media content on the EVM-compatible blockchains. This extends digital media metadata standards likeERC-7053and NFT metadata standards likeERC-721andERC-1155, allowing asset creators to specify how their assets are used in data mining, AI training, and machine learning workflows.", "A proposal adding \"dataMiningPreference\" in the metadata to preserve the digital content's original intent and respect creator's rights.": "This EIP proposes a standardized approach to declaring mining preferences for digital media content on the EVM-compatible blockchains. This extends digital media metadata standards likeERC-7053and NFT metadata standards likeERC-721andERC-1155, allowing asset creators to specify how their assets are used in data mining, AI training, and machine learning workflows.", "Abstract": "This EIP proposes a standardized approach to declaring mining preferences for digital media content on the EVM-compatible blockchains. This extends digital media metadata standards likeERC-7053and NFT metadata standards likeERC-721andERC-1155, allowing asset creators to specify how their assets are used in data mining, AI training, and machine learning workflows.", "Motivation": "As digital assets become increasingly utilized in AI and machine learning workflows, it is critical that the rights and preferences of asset creators and license owners are respected, and the AI/ML creators can check and collect data easily and safely. Similar to robot.txt to websites, content owners and creators are looking for more direct control over how their creativities are used.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Schema": "The JSON schema ofdataMiningPreferenceis defined as follows:", "Examples": "The mining preference example for not allowing generative AI training:", "Example Usage with ERC-721": "The following is an example of using thedataMiningPreferenceproperty inERC-721NFTs.", "Example Usage with ERC-7053": "The example using thedataMiningPreferenceproperty in onchain media provenance registration defined inERC-7053.", "Rationale": "The technical decisions behind this EIP have been carefully considered to address specific challenges and requirements in the digital asset landscape. Here are the clarifications for the rationale behind:", "Security Considerations": "When adopting this EIP, it\u2019s essential to address several security aspects to ensure the safety and integrity of adoption:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7518, "url": "https://eips.ethereum.org/EIPS/eip-7518", "title": "Dynamic Compliant Interop Security Token", "authors": ["Abhinav (@abhinav-d3v)\u00a0<", "abhinav@zoniqx.com", ">", "Prithvish Baidya (@d4mr)\u00a0<", "pbaidya@zoniqx.com", ">", "Rajat Kumar (@rajatwasan)\u00a0<", "rwasan@zoniqx.com", ">", "Prasanth Kalangi\u00a0<", "pkalangi@zoniqx.com", ">"], "sections": {"ERC-7518: Dynamic Compliant Interop Security Token": "This proposal is a security token standard that extendsERC-1155to provide a flexible framework for managing compliant real-asset security tokens. It introduces the concept of partitions, where eachtokenIdrepresents a distinct partition with its own set of rights and privileges. This makes it suitable for various use cases, particularly semi-fungible asset management. The standard also includes features like token locking, forced transfers for recovery, address freezing, payouts, and dynamic compliance management using off-chain vouchers.", "Security token framework with semi-fungible partitions for dynamic regulatory compliance management and cross-chain interoperability": "This proposal is a security token standard that extendsERC-1155to provide a flexible framework for managing compliant real-asset security tokens. It introduces the concept of partitions, where eachtokenIdrepresents a distinct partition with its own set of rights and privileges. This makes it suitable for various use cases, particularly semi-fungible asset management. The standard also includes features like token locking, forced transfers for recovery, address freezing, payouts, and dynamic compliance management using off-chain vouchers.", "Abstract": "This proposal is a security token standard that extendsERC-1155to provide a flexible framework for managing compliant real-asset security tokens. It introduces the concept of partitions, where eachtokenIdrepresents a distinct partition with its own set of rights and privileges. This makes it suitable for various use cases, particularly semi-fungible asset management. The standard also includes features like token locking, forced transfers for recovery, address freezing, payouts, and dynamic compliance management using off-chain vouchers.", "Motivation": "The growing demand for tokenized real-world assets necessitates a token standard that can accommodate the unique requirements of security tokens. Existing standards, while powerful, do not fully address the need for flexible partitioning and comprehensive compliance management.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Interface": "Retrieves the transferable balance of tokens for the specified account and ID.", "Methods for token": "Retrieves the transferable balance of tokens for the specified account and ID.", "transferableBalance": "Retrieves the transferable balance of tokens for the specified account and ID.", "lockedBalanceOf": "Retrieves the locked balance of tokens for the specified account and ID.", "restrictTransfer": "Restricts the transferability of tokens with the specified ID.", "removeRestriction": "Removes the transferability restriction of tokens with the specified ID.", "safeTransferFrom": "Determine transferring a specified amount of a token from one address to another.", "canTransfer": "Determine transferring a specified amount of a token from one address to another.", "lockTokens": "Locks a specified amount of tokens from an account for a specified duration.", "unlockToken": "Unlocks tokens that have crossed the release time for a specific account and id.", "forceTransfer": "Force transfer in cases like recovery of tokens", "freeze": "Freezes specified address. The Freeze function takes in theaccount addressto be frozen and additional data, and returns abooleanvalue indicating whether the operation was successful.", "unFreeze": "The Unfreeze function takes in theaccount addressto be unfrozen and additional data, and returns abooleanvalue indicating whether the operation was successful.", "payout": "Send payouts to single address, receiver will be receiving a specific amount of tokens.", "batchPayout": "Send payouts to multiple addresses at once, with each address receiving a specific amount of tokens. It can be used for various purposes such as distributing rewards, dividends, or interest payment.", "Interoperability": "This proposal facilitates interoperability withERC-3643tokens through a token wrapping method. The process involves two key components: theERC-3643token contracts representing the original and the proposed token contract for the wrapped version. Users seeking to wrap their tokens interact with the wrapping contract, which securely locks their original tokens and mints an equivalent amount of the proposed tokens to their address. Conversely, unwrapping is achieved by calling the contract\u2019s withdraw function, resulting in the burning of the proposed tokens and the release of the corresponding original tokens. Events are emitted for transparency, and robust security measures are implemented to safeguard user assets and address any potential vulnerabilities in the contract code. With this design, this proposal ensures the seamless conversion and compatibility withERC-3643tokens, promoting greater utility and usability across the Ethereum ecosystem.", "Interface for Interoperability": "The proposal leverages thetokenIdfeature ofERC-1155to represent distinct partitions within a token contract. EachtokenIdcorresponds to a unique partition with its own set of rights, privileges, and compliance rules. This enables the creation of semi-fungible tokens representing fractional ownership, different share classes, or other granular units.", "Methods for Interoperability": "The proposal leverages thetokenIdfeature ofERC-1155to represent distinct partitions within a token contract. EachtokenIdcorresponds to a unique partition with its own set of rights, privileges, and compliance rules. This enables the creation of semi-fungible tokens representing fractional ownership, different share classes, or other granular units.", "setWrappedTokenAddress": "The proposal leverages thetokenIdfeature ofERC-1155to represent distinct partitions within a token contract. EachtokenIdcorresponds to a unique partition with its own set of rights, privileges, and compliance rules. This enables the creation of semi-fungible tokens representing fractional ownership, different share classes, or other granular units.", "wrapToken": "The proposal leverages thetokenIdfeature ofERC-1155to represent distinct partitions within a token contract. EachtokenIdcorresponds to a unique partition with its own set of rights, privileges, and compliance rules. This enables the creation of semi-fungible tokens representing fractional ownership, different share classes, or other granular units.", "wrapTokenFromPartition": "The proposal leverages thetokenIdfeature ofERC-1155to represent distinct partitions within a token contract. EachtokenIdcorresponds to a unique partition with its own set of rights, privileges, and compliance rules. This enables the creation of semi-fungible tokens representing fractional ownership, different share classes, or other granular units.", "unwrapToken": "The proposal leverages thetokenIdfeature ofERC-1155to represent distinct partitions within a token contract. EachtokenIdcorresponds to a unique partition with its own set of rights, privileges, and compliance rules. This enables the creation of semi-fungible tokens representing fractional ownership, different share classes, or other granular units.", "Partition Management": "The proposal leverages thetokenIdfeature ofERC-1155to represent distinct partitions within a token contract. EachtokenIdcorresponds to a unique partition with its own set of rights, privileges, and compliance rules. This enables the creation of semi-fungible tokens representing fractional ownership, different share classes, or other granular units.", "Compliance Management": "", "Token Recovery": "In case of lost or compromised wallets, the proposal includes aforceTransferfunction that allows authorized entities (e.g., the issuer or a designated recovery agent) to transfer tokens from one address to another. This function bypasses the usual transfer restrictions and can be used as a recovery mechanism.", "Payout Management": "Provides functions for efficient payout distribution to token holders. Thepayoutfunction allows sending payouts to a single address, whilebatchPayoutenables sending payouts to multiple addresses in a single transaction. These functions streamline the process of distributing dividends, interest, or other payments to token holders.", "Real World Example": "", "Rationale": "ThecanTransferfunction facilitates compliance checks during token transfers, offering adaptability through diverse implementation methods such as on-chain storage, oracle utilization, or any off-chain methodologies. This versatility ensures seamless integration with existing compliance frameworks, particularly in enforcing regulatory standards like KYC/AML. Additionally, functionalities likefreezeAddress,restrictTransfer,lockTokenandforceTransferempower entities to regulate token movements based on specified conditions or regulatory requirements. Complementing these, theunlockTokenfunction enhances transparency and accountability by facilitating the release of tokens post-compliance actions.", "Enhancing Compliance Management": "ThecanTransferfunction facilitates compliance checks during token transfers, offering adaptability through diverse implementation methods such as on-chain storage, oracle utilization, or any off-chain methodologies. This versatility ensures seamless integration with existing compliance frameworks, particularly in enforcing regulatory standards like KYC/AML. Additionally, functionalities likefreezeAddress,restrictTransfer,lockTokenandforceTransferempower entities to regulate token movements based on specified conditions or regulatory requirements. Complementing these, theunlockTokenfunction enhances transparency and accountability by facilitating the release of tokens post-compliance actions.", "Interoperability with other standard": "The functionswrapTokenandwrapTokenFromPartitionare essential for simplifying conversions within the token system.wrapTokenis specifically designed for wrapping ERC-20-like tokens to this protocol, on the other hand,wrapTokenFromPartitionis used when we want to convert tokens from non-fungible tokens or any multi-standard token into proposed protocol. It allows for more specialized conversions, ensuring tokens from different standards can work together smoothly.", "Payment distribution": "Thepayoutfunction enables direct payments to individual token holders for one-off or event-triggered distributions, facilitating targeted disbursements. Meanwhile, thebatchPayoutfunction processes multiple payments in a single transaction, optimizing efficiency for larger-scale or regular payouts on the blockchain", "Backwards Compatibility": "The proposal is fully compatible withERC-1155, and anyERC-1155compliant wallet or marketplace can interact with the proposal\u2019s tokens. The additional functions introduced by this proposal do not conflict with theERC-1155interface, ensuring seamless integration with existing ecosystem tools and infrastructure.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7521, "url": "https://eips.ethereum.org/EIPS/eip-7521", "title": "General Intents for Smart Contract Wallets", "authors": ["Stephen Monn\u00a0(", "@pixelcircuits", ")", "Bikem Bengisu\u00a0(", "@supiket", ")"], "sections": {"ERC-7521: General Intents for Smart Contract Wallets": "A generalized intent specification entry point contract which enables support for a multitude of intent standards as they evolve over time. Instead of smart contract wallets having to constantly upgrade to provide support for new intent standards as they pop up, a single entry point contract is trusted to handle signature verification which then passes off the low level intent data handling and defining to other contracts specified by users at intent sign time. These signed messages, called aUserIntent, are gossipped around any host of mempool strategies for MEV searchers to look through and combine with their ownUserIntentinto an object called anIntentSolution. MEV searchers then package up anIntentSolutionobject they build into a transaction making ahandleIntentscall to the special contract entry point contract. This transaction then goes through the typical MEV channels to eventually be included in a block.", "A generalized intent specification for smart contract wallets, allowing authorization of current and future intent structures at sign time": "A generalized intent specification entry point contract which enables support for a multitude of intent standards as they evolve over time. Instead of smart contract wallets having to constantly upgrade to provide support for new intent standards as they pop up, a single entry point contract is trusted to handle signature verification which then passes off the low level intent data handling and defining to other contracts specified by users at intent sign time. These signed messages, called aUserIntent, are gossipped around any host of mempool strategies for MEV searchers to look through and combine with their ownUserIntentinto an object called anIntentSolution. MEV searchers then package up anIntentSolutionobject they build into a transaction making ahandleIntentscall to the special contract entry point contract. This transaction then goes through the typical MEV channels to eventually be included in a block.", "Abstract": "A generalized intent specification entry point contract which enables support for a multitude of intent standards as they evolve over time. Instead of smart contract wallets having to constantly upgrade to provide support for new intent standards as they pop up, a single entry point contract is trusted to handle signature verification which then passes off the low level intent data handling and defining to other contracts specified by users at intent sign time. These signed messages, called aUserIntent, are gossipped around any host of mempool strategies for MEV searchers to look through and combine with their ownUserIntentinto an object called anIntentSolution. MEV searchers then package up anIntentSolutionobject they build into a transaction making ahandleIntentscall to the special contract entry point contract. This transaction then goes through the typical MEV channels to eventually be included in a block.", "Motivation": "See also\u201cERC-4337: Account Abstraction via Entry Point Contract specification\u201dand the links therein for historical work and motivation.", "Specification": "Users package up intents they want their wallet to participate in, in an ABI-encoded struct called aUserIntent:", "Required entry point contract functionality": "The entry point\u2019shandleIntentsfunction must perform the following steps. It must make two loops, theverification loopand theexecution loop.", "Intent standard behavior executing an intent": "The intent standard\u2019sexecuteIntentSegmentfunction is given access to a wide set of data, including the entireIntentSolutionin order to allow it to implement any kind of logic that may be seen as useful in the future. Each intent standard contract is expected to parse theUserIntentobjectssegmentsparameter and use that to validate any constraints or perform any actions relevant to the standard. Intent standards can also take advantage of thecontextdata it can return at the end of theexecuteIntentSegmentfunction. This data is kept by the entry point and passed in as a parameter to theexecuteIntentSegmentfunction the next time it is called for an intent. This gives intent standards access to a persistent data store as other intents are executed in between others. One use case for this is an intent standard that is looking for a change in state during intent execution (like releasing tokens and expecting to be given other tokens).", "Smart contract wallet behavior executing an intent": "The entry point does not expect anything from the smart contract wallets after validation and during intent execution. However, intent standards may wish for the smart contract wallet to perform some action during execution. The smart contract walletgeneralizedIntentDelegateCallfunction must perform a delegate call with the given calldata at the calling intent standard. In order for the wallet to trust making the delegate call it must call theverifyExecutingIntentSegmentForStandardfunction on the entry point contract to verify both of the following:", "Smart contract wallet behavior validating an intent": "The entry point callsvalidateUserIntentfor each intent on the smart contract wallet specified in thesenderfield of eachUserIntent. This function provides the entireUserIntentobject as well as the precomputed hash of the intent. The smart contract wallet is then expected to analyze this data to ensure it was actually sent from the specifiedsender. If the intent is not valid, the smart contract wallet should throw an error in thevalidateUserIntentfunction. It should be noted that althoughvalidateUserIntentis not restricted asview, updates to state for things like nonce management, should be done in an individual segment on the intent itself. This allows for maximum customization in the way users define their intents while enshrining only the minimum verification within the entry point needed to ensure intents cannot be forged.", "Solver intent validation": "To validate aUserIntent, the solver makes a view call tovalidateIntenton the entry point. This function checks that the signature passes validation and that the segments on the intent are properly formatted. If the call reverts with any error, the solver should reject theUserIntent.", "Simulation": "Solvers are expected to handle simulation in typical MEV workflows. This most likely means dry running their solutions at the current block height to determine the outcome is as expected. Successful solutions can then be submitted as a bundle to block builders to be included in the next block.", "Extensions": "The entry point contract may enable additional functionality to reduce gas costs for common scenarios.", "Rationale": "The main challenge with a generalized intent standard is being able to adapt to the evolving world of intents. Users need to have a way to express their intents in a seamless way without having to make constant updates to their smart contract wallets.", "Solvers": "Solvers facilitate the fulfillment of a user\u2019s intent in search of their own MEV. They also act as the transaction originator for executing intents on-chain, including having to front any gas fees, removing that burden from the typical user.", "Entry point upgrading": "Wallets are encouraged to be DELEGATECALL forwarding contracts for gas efficiency and to allow wallet upgradability. The wallet code is expected to hard-code the entry point into their code for gas efficiency. If a new entry point is introduced, whether to add new functionality, improve gas efficiency, or fix a critical security bug, users can self-call to replace their wallet\u2019s code address with a new code address containing code that points to a new entry point. During an upgrade process, it\u2019s expected that intent standard contracts will also have to be re-registered to the new entry point.", "Signature aggregation": "Signature aggregation should be handled by the smart contract wallets directly during the signature validation process. This removes complexity from the entry point and allows developers to be creative with solutions. Thereference implementationincludes an example for how to accomplish this through the use of a wallet trusted aggregation contract which uses transient storage to report back to individual wallets that an intent was already validated via an aggregated signature earlier in the transaction call stack.", "Backwards Compatibility": "This ERC does not change the consensus layer, so there are no backwards compatibility issues for Ethereum as a whole. There is a little more difficulty when trying to integrate with existing smart contract wallets. If the wallet already has support forERC-4337, then implementing avalidateUserIntentfunction should be very similar to thevalidateUserOpfunction, but would require an upgrade by the user.", "Reference Implementation": "Seehttps://github.com/essential-contributions/ERC7521", "Security Considerations": "The entry point contract will need to be very heavily audited and formally verified, because it will serve as a central trust point forallERC-7521supporting wallets. In total, this architecture reduces auditing and formal verification load for the ecosystem, because the amount of work that individualwalletshave to do becomes much smaller (they need only verify thevalidateUserIntentfunction and its \u201ccheck signature\u201d logic) and gate any calls togeneralizedIntentDelegateCallby checking with the entry point using theverifyExecutingIntentSegmentForStandardfunction. The concentrated security risk in the entry point contract, however, needs to be verified to be very robust since it is so highly concentrated.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures."}
{"eip": 7522, "url": "https://eips.ethereum.org/EIPS/eip-7522", "title": "OIDC ZK Verifier for AA Account", "authors": ["Shu Dong (@dongshu2013)\u00a0<", "shu@hexlink.io", ">", "Yudao Yan\u00a0<", "dean@dauth.network", ">", "Song Z\u00a0<", "s@misfit.id", ">", "Kai Chen\u00a0<", "kai@dauth.network", ">"], "sections": {"ERC-7522: OIDC ZK Verifier for AA Account": "Account Abstraction facilitates new use cases for smart accounts, empowering users with the ability to tailor authentication and recovery mechanisms to their specific needs. To unlock the potential for more convenient verification methods such as social login, we inevitably need to connect smart accounts and OpenID Connect(OIDC), given its status as the most widely accepted authentication protocol. In this EIP, we proposed aERC-4337compatible OIDC ZK verifier. Users can link their ERC-4337 accounts with OIDC identities and authorize an OIDC verifier to validate user operations by verifying the linked OIDC identity on-chain.", "A ERC-4337 compatible OIDC ZK Verifier": "Account Abstraction facilitates new use cases for smart accounts, empowering users with the ability to tailor authentication and recovery mechanisms to their specific needs. To unlock the potential for more convenient verification methods such as social login, we inevitably need to connect smart accounts and OpenID Connect(OIDC), given its status as the most widely accepted authentication protocol. In this EIP, we proposed aERC-4337compatible OIDC ZK verifier. Users can link their ERC-4337 accounts with OIDC identities and authorize an OIDC verifier to validate user operations by verifying the linked OIDC identity on-chain.", "Abstract": "Account Abstraction facilitates new use cases for smart accounts, empowering users with the ability to tailor authentication and recovery mechanisms to their specific needs. To unlock the potential for more convenient verification methods such as social login, we inevitably need to connect smart accounts and OpenID Connect(OIDC), given its status as the most widely accepted authentication protocol. In this EIP, we proposed aERC-4337compatible OIDC ZK verifier. Users can link their ERC-4337 accounts with OIDC identities and authorize an OIDC verifier to validate user operations by verifying the linked OIDC identity on-chain.", "Motivation": "Connecting OIDC identity and smart accounts has been a very interesting but challenging problem. Verifying an OIDC issued IdToken is simple. IdToken are usually in the form of JWT and for common JWTs, they usually consist of three parts, a header section, a claim section and a signature section. The user claimed identity shall be included in the claim section and the signature section is usually an RSA signature of a well-known public key from the issuer against the hash of the combination of the header and claim section.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Definitions": "Identity Provider(IDP): The service to authenticate users and provide signed ID token", "Example Flow": "", "Interface": "To verify identity ownership on-chain,IOpenIdVerifierneeds at least three pieces of information:", "Rationale": "To verify identity ownership on-chain,IOpenIdVerifierneeds at least three pieces of information:", "Security Considerations": "The proof must verify theexpirationTimestampto prevent replay attacks.expirationTimestampshould be incremental and could be theexpfield in JWT payload. The proof must verify the user operation to prevent front running attacks. The proof must verify theuserIdHash. The verifier must verify that the sender from each user operation is linked to the user ID hash via thegetIdHashfunction.", "Copyright": "Copyright and related rights waived via CC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7524, "url": "https://eips.ethereum.org/EIPS/eip-7524", "title": "PLUME Signature in Wallets", "authors": ["Yush G (@Divide-By-0)\u00a0<", "aayushg@mit.edu", ">", "Kobi Gurkan\u00a0(", "@kobigurk", ")", "Richard Liu\u00a0(", "@rrrliu", ")", "Vivek Bhupatiraju\u00a0(", "@vb7401", ")", "Barry Whitehat\u00a0(", "@barryWhiteHat", ")"], "sections": {"ERC-7524: PLUME Signature in Wallets": "ZK-SNARKs have enabled ideation for new identity applications based on anonymous proof-of-ownership. One of the primary technologies that would enable the jump from existing apps to systems that require anonymous uniqueness is the development of verifiably deterministic signatures. Because Ethereum is based on ECDSA, there is no way right now for someone to verify that a signature is generated deterministically, even with \u2018deterministic\u2019 ECDSA signatures: a ZK-SNARK proof would need someone\u2019s private key to do so, and some hardware wallets do not even allow viewing of a private key. Broadly, we don\u2019t want to export/copy-paste the private key into a SNARK to be an intended user behavior, and most hardware wallets will not be able to run SNARK arithmetization inside a secure enclave for existing schemes (and nor do we want to standardize an entire proof system inside a wallet right now when they emerge and evolve almost every year). Thus we are left to select a new algorithm that offers us verifiable, deterministic nullifiers that can be SNARKed outside the enclave.", "A new signature scheme for Ethereum keypairs that allows for \"nullifiers\" to enable unique anonymity and zk voting.": "ZK-SNARKs have enabled ideation for new identity applications based on anonymous proof-of-ownership. One of the primary technologies that would enable the jump from existing apps to systems that require anonymous uniqueness is the development of verifiably deterministic signatures. Because Ethereum is based on ECDSA, there is no way right now for someone to verify that a signature is generated deterministically, even with \u2018deterministic\u2019 ECDSA signatures: a ZK-SNARK proof would need someone\u2019s private key to do so, and some hardware wallets do not even allow viewing of a private key. Broadly, we don\u2019t want to export/copy-paste the private key into a SNARK to be an intended user behavior, and most hardware wallets will not be able to run SNARK arithmetization inside a secure enclave for existing schemes (and nor do we want to standardize an entire proof system inside a wallet right now when they emerge and evolve almost every year). Thus we are left to select a new algorithm that offers us verifiable, deterministic nullifiers that can be SNARKed outside the enclave.", "Abstract": "ZK-SNARKs have enabled ideation for new identity applications based on anonymous proof-of-ownership. One of the primary technologies that would enable the jump from existing apps to systems that require anonymous uniqueness is the development of verifiably deterministic signatures. Because Ethereum is based on ECDSA, there is no way right now for someone to verify that a signature is generated deterministically, even with \u2018deterministic\u2019 ECDSA signatures: a ZK-SNARK proof would need someone\u2019s private key to do so, and some hardware wallets do not even allow viewing of a private key. Broadly, we don\u2019t want to export/copy-paste the private key into a SNARK to be an intended user behavior, and most hardware wallets will not be able to run SNARK arithmetization inside a secure enclave for existing schemes (and nor do we want to standardize an entire proof system inside a wallet right now when they emerge and evolve almost every year). Thus we are left to select a new algorithm that offers us verifiable, deterministic nullifiers that can be SNARKed outside the enclave.", "Motivation": "As such, a deterministic value based on the Ethereum account\u2019s ECDSA keypair is a necessary component of ensuring one action per user and enables all these applications on Ethereum.", "Specification": "We propose a new signature standard that offers the following properties, to be implemented for standard ECDSA keys within wallets:", "Parameters": "This scheme uses the secp256k1 curve, defined inStandards for Efficient\nCryptography 2 (SEC 2) v2, page 9.", "Public key encoding functions": "This scheme uses the SEC1 elliptic curve point encoding scheme defined inStandards for Efficient\nCryptography 1 (SEC 1) v2. Point compression is used. We use the notation $\\mathsf{sec1}(pk)$ to denote the compressed encoding of secp256k1 curve point $pk$ as a bytestring of length 33.", "SEC1": "This scheme uses the SEC1 elliptic curve point encoding scheme defined inStandards for Efficient\nCryptography 1 (SEC 1) v2. Point compression is used. We use the notation $\\mathsf{sec1}(pk)$ to denote the compressed encoding of secp256k1 curve point $pk$ as a bytestring of length 33.", "Hash functions": "SHA256", "Hash-to-curve": "We use the notation $\\mathsf{htc}([a_1, \u2026, a_n])$ to denote the elliptic curve point which is the result of theIETF RFC 9380secp256k1_XMD:SHA-256_SSWU_RO_in Appendix J.8.1. This hash-to-curve algorithm operates over the concatenation of $n$ values $a_1, \u2026, a_n$.", "Key generation": "Akeypaircomprises of $(sk, pk)$, defined as such:", "Signature generation": "This scheme builds upon the Chaum-Pedersen signature scheme1. Given a 32-byte message $m$ and a keypair $(sk, pk)$, a  user may generate a signature as such:", "Signature verification (non-ZK)": "In a situation where the verifier knows $g$, $m$, the signer\u2019s public key $pk$, and the signature $(z, s, g^r, c, \\mathsf{nul})$, they may perform the following checks to determine if the signature is valid:", "Version 1: Verifier Optimized": "In a situation where there is a verifier who mustnotknow the signer\u2019s $pk$, but the signer must nevertheless prove that they know $sk$ corresponding to the signature given $m$, a zero-knowledge proof is required.", "Version 2: Prover Optimized": "Currently, SHA-256 hashing operations are particularly expensive with zk proofs in the browser. In the context of PLUME, the computation of $c$ is a bottleneck for efficient proof times, so one modification suggested by the Poseidon team was to move this hash computation outside the circuit, into the verifier.", "Version 3:": "There may be a more efficient V3 in the future, perhaps via removing indifferentiability from hash_to_curve.", "Rationale": "We will define a few specific properties we are looking for in a candidate algorithm, then define a few other intuitive algorithms and explain why they don\u2019t actually work.", "Security Considerations": "There are formal proofs of this specific algorithm\u2019s cryptography in the PLUME paper2. The theory has been published, and implementations have had one internal round of audit, but they have not end-to-end been formally verified or audited yet, although empirically they correctly conform to the spec laid out.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7527, "url": "https://eips.ethereum.org/EIPS/eip-7527", "title": "Token Bound Function Oracle AMM", "authors": ["Elaine Zhang (@lanyinzly)\u00a0<", "lz8aj@virginia.edu", ">", "Jerry\u00a0<", "jerrymindflow@gmail.com", ">", "Amandafanny\u00a0<", "amandafanny200@gmail.com", ">", "Shouhao Wong (@wangshouh)\u00a0<", "wongshouhao@outlook.com", ">", "0xPoet\u00a0<", "0xpoets@gmail.com", ">"], "sections": {"ERC-7527: Token Bound Function Oracle AMM": "This proposal outlines interfaces for wrappingERC-20or ETH toERC-721and unwrap ERC-721 to ERC-20 or ETH. A function oracle feeds mint/burn prices based on an embedded equation of Function Oracle Automated Market Maker(FOAMM), which executes and clears the mint and burn of NFT.", "Interfaces that wrap FT to NFT and unwrap NFT to FT based on an embedded Function Oracle AMM": "This proposal outlines interfaces for wrappingERC-20or ETH toERC-721and unwrap ERC-721 to ERC-20 or ETH. A function oracle feeds mint/burn prices based on an embedded equation of Function Oracle Automated Market Maker(FOAMM), which executes and clears the mint and burn of NFT.", "Abstract": "This proposal outlines interfaces for wrappingERC-20or ETH toERC-721and unwrap ERC-721 to ERC-20 or ETH. A function oracle feeds mint/burn prices based on an embedded equation of Function Oracle Automated Market Maker(FOAMM), which executes and clears the mint and burn of NFT.", "Motivation": "Liquidity can be a significant challenge in decentralized systems, especially for unique or less commonly traded tokens like NFTs. To foster a trustless NFT ecosystem, the motivation behind Function Oracle Automated Market Maker(FOAMM) is to provide automated pricing solutions for NFTs with liquidity through transparent, smart contract mechanisms.", "Automated Price Discovery": "Transactions under FOAMM can occur without the need for a matching counterparty. When interacting directly with the pool, FOAMM automatically feeds prices based on the oracle with predefined function.", "Liquidity Enhancement": "In traditional DEX models, liquidity is supplied by external parties, known as Liquidity Providers(LP). These LPs deposit tokens into liquidity pools, facilitating exchanges by providing the liquidity. The removal or withdrawal of these LPs can introduce significant volatility, as it directly impacts the available liquidity in the market.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Agency Interface": "ERC7527AppSHALL inheritnamefrom interfaceERC721Metadata.", "App Interface": "ERC7527AppSHALL inheritnamefrom interfaceERC721Metadata.", "Factory Interface": "OPTIONAL - This interface can be used to deploy App and Agency, but interfaces and other contracts MUST NOT expect this interface to be present.", "Rationale": "ERC-5679proposedIERC5679Ext721interface for introducing a consistent way to extendERC-721token standards for minting and burning. To ensure the backward compatibility, considering some contracts which do not implementERC721TokenReceiver,IERC7527Appemploymintfunction instead ofsafeMint. To ensure the safety and the uniqueness of mutual bound, the_fromparameter of theburnfunction inIERC5679Ext721must be the contract address of the bounded agency. Thus,burnfunction inIERC7527Appdoes not contain the_fromparameter.", "Prior Interfaces": "ERC-5679proposedIERC5679Ext721interface for introducing a consistent way to extendERC-721token standards for minting and burning. To ensure the backward compatibility, considering some contracts which do not implementERC721TokenReceiver,IERC7527Appemploymintfunction instead ofsafeMint. To ensure the safety and the uniqueness of mutual bound, the_fromparameter of theburnfunction inIERC5679Ext721must be the contract address of the bounded agency. Thus,burnfunction inIERC7527Appdoes not contain the_fromparameter.", "Mutual Bound": "Implement contracts forIERC7527AppandIERC7527Agencyso that they are each other\u2019s only owner. The wrap process is to check the premium amount of the fungible token received and then mint non-fungible token in the App. Only the owner or an approver of the non-fungible token can unwrap it.", "Implementation Diversity": "Users can customize function and fee percentage when implement the Agency and the App interfaces.", "Currency types": "currencyinIERC7527Agencyis the address of fungible token.Assetcan only define one type ofcurrencyas the fungible token in the system.currencysupports various kinds of fungible tokens including ETH andERC-20.", "Token id": "For each wrap process, a uniquetokenIdshould be generated. ThistokenIdis essential for verification during the unwrap process. It also serves as the exclusive credential for the token. This mechanism ensures the security of assets in contracts.", "Wrap and Mint": "Thestrategyis set while implementing the Agency interface, and it should be ensured not upgradable once deployed.", "Unwrap and Burn": "When executing theunwrapfunction, predetermined strategy parameters are passed into thegetUnwrapOraclefunction to read the current premium and fee. The App burns the NFT. Then, the corresponding premium, subtracting the fee according toburnFeePercent, is then transferred to the user\u2019s address; the fee is transferred tofeeRecipient. The act of executing \u2018unwrap\u2019 is the sole trigger for the \u2018burn\u2019 process.", "Two interfaces use together": "IERC7527AppandIERC7527Agencycan be implemented together for safety, but they can be independently implemented before initialization for flexibiliy.", "Pricing": "getWrapOracleandgetUnwrapOracleare used to fetch the current premium and fee. They implement on-chain price fetching through oracle functions. They not only support fetching the premium and fee during the wrap and unwrap processes but also support other contracts calling them to obtain the premium and fee, such as lending contracts.", "initDataandiconstructor": "During the deployment ofAppandAgencyby the Factory, the Factory usesinitDataas Calldata to call theAgencyandAppcontracts and also invokes theiconstructorfunctions withinAppandAgency.", "Backwards Compatibility": "No backward compatibility issues found.", "Reference Implementation": "Consider the following for the safety of the contracts:", "Security Considerations": "Consider the following for the safety of the contracts:", "Fraud Prevention": "Consider the following for the safety of the contracts:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- withdrawal: Log entry in system_logs for tracking withdrawals under EIP-4895 .\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170."}
{"eip": 7529, "url": "https://eips.ethereum.org/EIPS/eip-7529", "title": "Contract Discovery and eTLD+1 Association", "authors": ["Todd Chapman\u00a0(", "@tthebc01", ")", "Charlie Sibbach\u00a0<", "charlie@cwsoftware.com", ">", "Sean Sing\u00a0(", "@seansing", ")"], "sections": {"ERC-7529: Contract Discovery and eTLD+1 Association": "The introduction of DNS over HTTPS (DoH) inRFC 8484has enabled tamper-resistant client-side queries of DNS records directly from a web application. This proposal describes a simple standard leveraging DoH to fetch TXT records (from traditional DNS service providers) which are used for discovering and verifying the association of a smart contract with a common DNS domain. This standard can be used as a straightforward technique to mitigate smart contract authorship spoofing and enhance the discoverability of smart contracts through standard web search mechanisms.", "Leveraging TXT Records to discover, verify and associate a smart contract with the owner of a DNS domain.": "The introduction of DNS over HTTPS (DoH) inRFC 8484has enabled tamper-resistant client-side queries of DNS records directly from a web application. This proposal describes a simple standard leveraging DoH to fetch TXT records (from traditional DNS service providers) which are used for discovering and verifying the association of a smart contract with a common DNS domain. This standard can be used as a straightforward technique to mitigate smart contract authorship spoofing and enhance the discoverability of smart contracts through standard web search mechanisms.", "Abstract": "The introduction of DNS over HTTPS (DoH) inRFC 8484has enabled tamper-resistant client-side queries of DNS records directly from a web application. This proposal describes a simple standard leveraging DoH to fetch TXT records (from traditional DNS service providers) which are used for discovering and verifying the association of a smart contract with a common DNS domain. This standard can be used as a straightforward technique to mitigate smart contract authorship spoofing and enhance the discoverability of smart contracts through standard web search mechanisms.", "Motivation": "As mainstream businesses begin to adopt public blockchain and digital asset technologies more rapidly, there is a growing need for a discovery/search mechanism (compatible with conventional web technologies) of smart contracts associated with a known business domain as well as reasonable assurance that the smart contract does indeed belong to the business owner of the DNS domain. The relatively recent introduction and widespread support of DoH means it is possible to make direct, tamper-resistant queries of DNS records straight from a web application context and thus leverage a simple TXT record as a pointer to an on-chain smart contract. Prior to the introduction of DoH, web (and mobile) applicationscould notaccess DNS records directly; instead they would have to relay requests through a trusted, proprietary service provider who could easily manipulate response results.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Contract Pointers in TXT Records": "The owner of an eTLD+1 domain name MUST create a TXT record in their DNS settings that serves as a pointer to all relevant smart contracts they wish to associate with their domain.", "Smart Contract Association with a Domain": "Any smart contract MAY implement this ERC to provide a verification mechanism of smart contract addresses listed in a compatible TXT record.", "Client-side Verification": "When a client detects a compatible TXT record listed on an eTLD+1, it SHOULD loop through each listed contract address and, via an appropriate RPC provider, assert\nthat each of the smart contracts returnstruewhen the eTLD+1 string is passed to thecheckDomainfunction.", "Rationale": "In this specification, the TXT recordHOSTnaming scheme is designed to mimic the DKIM naming convention. Additionally, this naming scheme makes it simple to programmatically ascertain if any smart contracts are associated with the domain on a given blockchain network. Prepending withERC-7529will prevent naming collisions with other TXT records. The value of<chain_id>is simply the decimal representation of the chain id associated with the target blockchain network (i.e.1for Ethereum mainnet or11155111for Sepolia) where the smart contracts are deployed. So, a typicalHOSTmight be:ERC-7529.1._domainContracts,ERC-7529.11155111._domaincontracts, etc.", "Backwards Compatibility": "No backward compatibility issues found.", "Reference Implementation": "The implementation ofcheckDomain,addDomainandremoveDomainis a trivial exercise, but candidate implementations are given here for completeness:", "Security Considerations": "Due to the reliance on traditional DNS systems, this ERC is susceptible to attacks on this technology, such as domain hijacking. Additionally, it is the responsibility of the smart contract author to ensure thataddDomainandremoveDomainare authenticated properly, otherwise an attacker could associate their smart contract with an undesirable domain, which would simply break the ability to verify association with the proper domain.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7533, "url": "https://eips.ethereum.org/EIPS/eip-7533", "title": "Public Cross Port", "authors": ["George\u00a0(", "@JXRow", ")", "Zisu\u00a0(", "@lazy1523", ")"], "sections": {"ERC-7533: Public Cross Port": "The objective of Public Cross Port (PCP) is to securely and efficiently connect various EVM chains. It replaces the method of pushing message to multiple chains with a method of pulling messages from multiple chains, significantly reducing the number of cross-chain bridges and gas cost, as more cross-chain bridge projects are built on PCP, the overall security increases.", "Help bridges to connect all EVM chains": "The objective of Public Cross Port (PCP) is to securely and efficiently connect various EVM chains. It replaces the method of pushing message to multiple chains with a method of pulling messages from multiple chains, significantly reducing the number of cross-chain bridges and gas cost, as more cross-chain bridge projects are built on PCP, the overall security increases.", "Abstract": "The objective of Public Cross Port (PCP) is to securely and efficiently connect various EVM chains. It replaces the method of pushing message to multiple chains with a method of pulling messages from multiple chains, significantly reducing the number of cross-chain bridges and gas cost, as more cross-chain bridge projects are built on PCP, the overall security increases.", "Motivation": "Currently, there are official cross-chain bridges between L2 and L1, but not between L2s. If there are 10 L2 chains that need to cross-chain with each other, it would require 10 x 9 = 90 cross-chain bridges. However, if a pull mechanism is used to merge messages from the other 9 chains into one transaction synchronized to its own chain, only 10 cross-chain bridges would be needed. This significantly reduces the number of cross-chain bridges required and minimizes gas cost.", "Use case": "This EIP divides the cross-chain ecosystem into 3 layers and defines theSendPortcontract andIReceivePortinterface at the foundational layer. The implementation of the other layers is left to ecosystem project participants.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "1.Add cross-chain message": "Under this EIP, aSendPortcontract is deployed on each chain. It is responsible for collecting cross-chain messages on that chain and packing them.SendPortoperates as a public, permissionless, administrator-free, and automatic system. Cross-chain bridge operators retrieve cross-chain messages fromSendPortand transport it to the target chain to complete the cross-chain messaging process.", "2.Pull roots & Set roots": "Upon the completion of packing a new MerkleTree, the package carrier (usually the cross-chain bridge project) pulls the root from multiple chains and stores it in theIReceivePortcontract of each chain.", "3.Verify cross-chain message": "TheIReceivePortcontract stores the roots of each chain, allowing it to verify the authenticity of messages when provided with the complete message. It is important to note that the root itself cannot be used to decipher the message; it can only be used to validate its authenticity. The complete message can be retrieved from theSendPortcontract of the source chain.", "ISendPortInterface": "Let:", "IReceivePortInterface": "Let:", "Rationale": "The traditional approach involves using a push method, as depicted in the following diagram:", "Backwards Compatibility": "This EIP does not change the consensus layer, so there are no backwards compatibility issues for Ethereum as a whole.", "Reference Implementation": "Below is an example contract for a cross-chain bridge:", "SendPort.sol": "External featrues:", "ReceivePort.sol": "Regarding competition and double spending among cross-chain bridges:", "BridgeExample.sol": "Regarding competition and double spending among cross-chain bridges:", "Security Considerations": "Regarding competition and double spending among cross-chain bridges:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7538, "url": "https://eips.ethereum.org/EIPS/eip-7538", "title": "Multiplicative Tokens", "authors": ["Gavin John\u00a0(", "@Pandapip1", ")"], "sections": {"ERC-7538: Multiplicative Tokens": "This EIP extendsERC-1046-compatible token types (notably,ERC-20andERC-1155by introducing amultiplierfield to the metadata schema, altering how user-facing balances are displayed.", "Incorporates a multiplier field to ERC-20 and ERC-1155 for fractional token values": "This EIP extendsERC-1046-compatible token types (notably,ERC-20andERC-1155by introducing amultiplierfield to the metadata schema, altering how user-facing balances are displayed.", "Abstract": "This EIP extendsERC-1046-compatible token types (notably,ERC-20andERC-1155by introducing amultiplierfield to the metadata schema, altering how user-facing balances are displayed.", "Motivation": "Many projects necessitate the creation of various types of tokens, both fungible and non-fungible. While certain standards are ideal for this purpose, they lack support for fractional tokens. Additionally, some tokens may require built-in inflation or deflation mechanisms, or may wish to allow transfers in unconventional increments, such as0.5.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "Employing strings for numerical representation offers enhanced precision when needed. The use of a multiplier instead of decimals facilitates increments other than powers of 10, and ensures seamless handling of inflation or deflation. Utilizing ERC-1046 promotes gas efficiency in the majority of cases.", "Backwards Compatibility": "This EIP is incompatible with any method nameddecimalsin ERC-1046-compatible token standards or the ERC-1046decimalsfield.", "Security Considerations": "Improper handling of themultiplierfield may lead to rounding errors, potentially exploitable by malicious actors. Contracts MUST process multipliers accurately to avoid such issues. The multiplier MUST be positive (\u20180\u2019 is not positive) to avert display issues. Particularly large or small multipliers MAY pose display challenges, yet wallets SHOULD endeavor to display the full number without causing UI/UX or additional security issues.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7546, "url": "https://eips.ethereum.org/EIPS/eip-7546", "title": "Upgradeable Clone for Scalable Contracts", "authors": ["Shogo Ochiai (@shogochiai)\u00a0<", "shogo.ochiai@pm.me", ">", "Kai Hiroi (@KaiHiroi)\u00a0<", "kai.hiroi@pm.me", ">"], "sections": {"ERC-7546: Upgradeable Clone for Scalable Contracts": "It has been a significant challenge for developers attempting to create cloneable and upgradeable contracts on the Ethereum Virtual Machine (EVM). WhileERC-2535Diamonds and other existing proxy standards offer partial solutions, a comprehensive answer has remained elusive. Our proposal addresses this gap through the introduction of two main features.", "An upgradeable, cloneable, horizontally extensible proxy pattern.": "It has been a significant challenge for developers attempting to create cloneable and upgradeable contracts on the Ethereum Virtual Machine (EVM). WhileERC-2535Diamonds and other existing proxy standards offer partial solutions, a comprehensive answer has remained elusive. Our proposal addresses this gap through the introduction of two main features.", "Abstract": "It has been a significant challenge for developers attempting to create cloneable and upgradeable contracts on the Ethereum Virtual Machine (EVM). WhileERC-2535Diamonds and other existing proxy standards offer partial solutions, a comprehensive answer has remained elusive. Our proposal addresses this gap through the introduction of two main features.", "Function-Level Upgradeability": "In alignment withERC-2535, this functionality permits the selective redirection of implementation contracts for individual function calls. This granular control over upgrades allows for modifications on a per-function basis. Moreover, segmenting implementation contracts by function helps mitigate the limitations posed by the contract size cap (24.576kB as of EVM version Shanghai or earlier).", "Factory/Clone-Friendly & Simultaneous Upgradeability": "Drawing on the Beacon model fromERC-1967, our method aims to streamline the process of cloning and updating Proxy contracts simultaneously. This approach is designed to maintain consistent functionality across different instances, each with its own state. Typically, proxies are limited to basic upgradeability features or follow theERC-1167standard. However, our solution combines both functionalities into a compact proxy.", "Motivation": "Smart contract development often encounters hurdles due to the inherent limitations of the Ethereum Virtual Machine (EVM), such as the contract size limit and stack depth. Additionally, addressing vulnerabilities in both the smart contract logic and its compiler are persistent issues. While there is a desire to minimize reliance on trusted third parties for upgradeability, introducing complex governance structures for upgrade management can significantly increase the workload for crypto DevOps, adding to the apprehension developers may feel towards advancing their projects. This apprehension can restrict the complexity and innovation within smart contract development. Our approach seeks to simplify smart contract programming, making it more accessible and enjoyable. It does so by clearly delineating DevOps concerns from business logic, thereby enhancing codebase clarity, facilitating audits, and allowing for more focused analysis through Language Model (LM) techniques, tailored to specific infrastructure and domain needs.", "Use Cases": "Over time, various smart contract design patterns have been proposed and utilized. ThisUpgradeable Clone Standard (UCS)is intended for scenarios where these existing patterns may not suffice. To clarify it, we define some key terms:", "Specification": "In the EVM, contract accounts are characterized by four primary fields:nonce,balance,code, andstorage. This ERC\u2019s architecture modularizes these functionalities into three distinct types of contracts, each serving a specific purpose when combined to represent a single account:", "Proxy Contract": "This contract requests theDictionary Contractto retrieve the associatedFunction Contractaddress based on its function selector, and then delegatecall to it.", "Dictionary Contract": "This contract manages a mapping of function selectors to correspondingFunction Contractaddresses. It uses this mapping to handle requests from theProxy Contract.", "Function (Implementation) Contract": "This contract acts as the logic implementation contract that theProxy Contractdelegatecalls and it\u2019s address is registered with the function selector in theDictionary Contract.", "Rationale": "While both this ERC and ERC-2535 offerFunction-Level Upgradeability, there is a key distinction in their approaches. ERC-2535 maintains a mapping of implementation contracts (referred to as Facets in ERC-2535) within the Proxy itself. In contrast, this ERC stores the mapping in an externalDictionary Contract. This externalization of the mapping facilitates another significant feature of this standard:Factory/Clone-Friendly & Simultaneous Upgradeability. By separating the mapping from the Proxy, this design allows for easier cloning of contracts and their simultaneous upgrade, which is not as straightforward in the ERC-2535 framework.", "Comparison withERC-2535": "While both this ERC and ERC-2535 offerFunction-Level Upgradeability, there is a key distinction in their approaches. ERC-2535 maintains a mapping of implementation contracts (referred to as Facets in ERC-2535) within the Proxy itself. In contrast, this ERC stores the mapping in an externalDictionary Contract. This externalization of the mapping facilitates another significant feature of this standard:Factory/Clone-Friendly & Simultaneous Upgradeability. By separating the mapping from the Proxy, this design allows for easier cloning of contracts and their simultaneous upgrade, which is not as straightforward in the ERC-2535 framework.", "Separating the Dictionary and Proxy contracts:": "The separation of the Dictionary from the Proxy was driven by aligning withFactory/Clone-Friendly & Simultaneous Upgradeability.", "Utilizing the mapping of function selectors and implementation addresses:": "The utilization of the mapping of function selectors to correspondingFunction Implementation Contractaddresses of theDictionary Contractby theProxy Contract, followed by delegatecalling to the returned implementation address, aligns withFunction-Level Upgradeability.", "Reference Implementation": "There are reference implementations and tests as a foundry project.", "Security Considerations": "This pattern of delegating all implementations for every call to theDictionary Contractrelies on the assumption that theDictionary Contract\u2019s admin acts in good faith and does not introduce vulnerabilities through negligence.", "Delegation of Implementation Management": "This pattern of delegating all implementations for every call to theDictionary Contractrelies on the assumption that theDictionary Contract\u2019s admin acts in good faith and does not introduce vulnerabilities through negligence.", "Storage Conflict": "As mentioned in the aboveStorage section. This design pattern involves multipleFunction Implementation Contractssharing a singleProxy Contractstorage. Therefore, it\u2019s important to take care for preventing storage conflicts by using the storage management method that is considered most appropriate at the time.", "Mismatch Function Selector": "TheDictionary Contractreturns theFunction Implementation Contractaddress based on theProxy Contract\u2019s invoked function selector.", "Handling of CALL and STATICCALL": "TheProxy Contractis designed primarily to respond toCALLandSTATICCALLopcodes. Should aDELEGATECALLbe made to thisProxy Contract, it will attempt to request theDictionary Contractfor a corresponding implementation via thegetImplementation(bytes4 functionSelector)function, using the storedDictionary Contractaddress within its own storage. Although this action may not lead to the intended outcome if the calling contract\u2019s storage layout does not align with expectations, it does not constitute a direct threat to theProxy Contractitself. Developers are cautioned that invoking thisProxy ContractviaDELEGATECALLcould result in unexpected and potentially non-functional outcomes, making it an unsuitable method for interaction.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- treturn: A new opcode that allows returning data directly from transient storage without first copying it to memory.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7548, "url": "https://eips.ethereum.org/EIPS/eip-7548", "title": "Open IP Protocol built on NFTs", "authors": ["Combo\u00a0<", "combo@1combo.io", ">", "Saitama\u00a0(", "@saitama2009", ")", "CT29\u00a0<", "CT29@1combo.io", ">", "Luigi\u00a0<", "luigi@1combo.io", ">"], "sections": {"ERC-7548: Open IP Protocol built on NFTs": "This proposal aims to establish a standardized method for creating new intellectual properties (IPs) by remixing multiple existing IPs in a decentralized manner.", "A protocol that enables users to remix NFTs and generate new NFT derivative works, while their relationships can be traced on chain.": "This proposal aims to establish a standardized method for creating new intellectual properties (IPs) by remixing multiple existing IPs in a decentralized manner.", "Abstract": "This proposal aims to establish a standardized method for creating new intellectual properties (IPs) by remixing multiple existing IPs in a decentralized manner.", "Motivation": "The internet is flooded with fresh content every day, but with the traditional IP infrastructure, IP registration and licensing is a headache for digital creators. The rapid creation of content has eclipsed the slower pace of IP registration, leaving much of this content unprotected. This means digital creators can\u2019t fairly earn from their work\u2019s spread.", "Specification": "The keywords \u201cMUST,\u201d \u201cMUST NOT,\u201d \u201cREQUIRED,\u201d \u201cSHALL,\u201d \u201cSHALL NOT,\u201d \u201cSHOULD,\u201d \u201cSHOULD NOT,\u201d \u201cRECOMMENDED,\u201d \u201cMAY,\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Remix Module": "This module extends the ERC-721 standard and enables users to create a new NFT by remixing multiple existing NFTs, whether they\u2019re ERC-721 orERC-1155.", "License Module": "By default, users can only remix multiple NFTs they own to create new NFT derivative works. This module enables NFT holders to grant others permission to use their NFTs in the remixing process.", "Network Module": "This module follows the singleton pattern and is used to track all relationships between the original NFTs and their NFT derivative works.", "Rationale": "The Open IP Protocol is built on the \u201c1 premise, 2 extensions, 1 constant\u201d principle.", "Backwards Compatibility": "This proposal is fully backwards compatible with the existing ERC-721 standard, extending the standard with new functions that do not affect the core functionality.", "Security Considerations": "This standard highlights several security concerns that need attention:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7555, "url": "https://eips.ethereum.org/EIPS/eip-7555", "title": "Single Sign-On for Account Discovery", "authors": ["Alexander M\u00fcller\u00a0(", "@alexmmueller", ")", "Gregory Markou\u00a0(", "@GregTheGreek", ")", "Willem Olding\u00a0(", "@Wollum", ")", "Belma Gutlic\u00a0(", "@morrigan", ")", "Marin Petruni\u0107\u00a0(", "@mpetrunic", ")", "Pedro Gomes\u00a0(", "@pedrouid", ")"], "sections": {"ERC-7555: Single Sign-On for Account Discovery": "This proposal establishes a standardized interface and functionality for applications to discover user accounts besides the readily available EOA. Specifically discovering normal accounts and smart accounts that may have been deployed or configured using a signing key that is not the standard Ethereum secp256k1 curve. The objective is to ensure uniformity of address retrieval across applications, and domains.", "Discover accounts using a signing key that do not use the secp256k1 curve.": "This proposal establishes a standardized interface and functionality for applications to discover user accounts besides the readily available EOA. Specifically discovering normal accounts and smart accounts that may have been deployed or configured using a signing key that is not the standard Ethereum secp256k1 curve. The objective is to ensure uniformity of address retrieval across applications, and domains.", "Abstract": "This proposal establishes a standardized interface and functionality for applications to discover user accounts besides the readily available EOA. Specifically discovering normal accounts and smart accounts that may have been deployed or configured using a signing key that is not the standard Ethereum secp256k1 curve. The objective is to ensure uniformity of address retrieval across applications, and domains.", "Motivation": "The recent progress in account abstraction has led to significantly increased flexibility enabling use cases such as multi-signature transactions, social recovery, contract/account whitelisting, session keys and much more. However, with increased flexibility there comes an increased complexity. One area of increased complexity is account fragmentation -both at the EOA and smart account level - following from the inability to correctly identify all existing addresses by a user. In this EIP we present a potential solution that aims to unify the discovery and handling of such accounts.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Definitions": "An application looking to authenticate a user must navigate the user to a given provider\u2019s URI based on theURI Request Syntax. The application must implement a valid redirect URI for the callback in order to receive a valid response.", "Redirects": "Taking inspiration from how SSO functions in the web today. We implement a similar redirect pattern, consisting of a simple request/response.", "Schema": "Thesmart_account_addressshould be returned in the CAIP-10 format.", "Rationale": "Taking inspiration from how SSO functions in the web today. We implement a similar redirect pattern, consisting of a simple request/response.", "Backwards Compatibility": "No backward compatibility issues found.", "Reference Implementation": "Usinglocation.replace()vslocation.hrefis up to the application to decide how they wish the experience to be handled.", "Security Considerations": "The absence of wildcard support in the redirect URI is intended to protect users from nested open redirect vulnerabilities. Allowing wildcards could enable attackers to redirect users to different pages under the supported wildcard, creating a vulnerability to open redirects.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7561, "url": "https://eips.ethereum.org/EIPS/eip-7561", "title": "Simple NFT, Simplified ERC-721", "authors": ["Xiang\u00a0(", "@wenzhenxiang", ")", "Ben77\u00a0(", "@ben2077", ")", "Mingshi S.\u00a0(", "@newnewsms", ")"], "sections": {"ERC-7561: Simple NFT, Simplified ERC-721": "This ERC is a new NFT asset designed based on the user contract wallet (including account abstraction), and is forward compatible withERC-721. To keep NFT assets simple, this ERC removes theapprove,setApprovalForAll,getApproved,isApprovedForAllandsafeTransferFromfunctions of ERC-721.", "Designed for contract wallet, removes safeTransferFrom, approve, setApprovalForAll, getApproved, isApprovedForAll functions from ERC-721": "This ERC is a new NFT asset designed based on the user contract wallet (including account abstraction), and is forward compatible withERC-721. To keep NFT assets simple, this ERC removes theapprove,setApprovalForAll,getApproved,isApprovedForAllandsafeTransferFromfunctions of ERC-721.", "Abstract": "This ERC is a new NFT asset designed based on the user contract wallet (including account abstraction), and is forward compatible withERC-721. To keep NFT assets simple, this ERC removes theapprove,setApprovalForAll,getApproved,isApprovedForAllandsafeTransferFromfunctions of ERC-721.", "Motivation": "ERC-721defines Ethereum-based standard NFT that can be traded and transferred, but the essence of ERC-721 is based on the externally-owned account (EOA) wallet design. An EOA wallet has no state and code storage, and the smart contract wallet is different.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "The proposal is to simplify NFT standards by removingapprove,setApprovalForAll,getApproved,isApprovedForAllandsafeTransferFromfunctions. This simplification aims to enhance security, reduce complexity, and improve efficiency, making the standard more suitable for smart contract wallet environments while maintaining essential functionalities.", "Backwards Compatibility": "As mentioned in the beginning, this ERC is forward compatible withERC-721, ERC-721 is backward compatible with this ERC.", "Reference Implementation": "forward compatible withERC-721", "Security Considerations": "It should be noted that this ERC is not backward compatible withERC-721, so there will be incompatibility with existing dapps.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7562, "url": "https://eips.ethereum.org/EIPS/eip-7562", "title": "Account Abstraction Validation Scope Rules", "authors": ["Yoav Weiss\u00a0(", "@yoavw", ")", "Dror Tirosh\u00a0(", "@drortirosh", ")", "Alex Forshtat\u00a0(", "@forshtat", ")", "Shahaf Nacson\u00a0(", "@shahafn", ")"], "sections": {"ERC-7562: Account Abstraction Validation Scope Rules": "This document describes the rules Account Abstraction protocols should follow, during the validation phase of Account Abstraction transactions,\nsuch asERC-4337UserOperationor RIP-7560 (Native Account Abstraction), which are enforced off-chain by a\nblock builder or a standalone bundler, and the rationale behind each one of them.", "A set of limitations on validation EVM code to protect Account Abstraction nodes from denial-of-service attacks through unpaid computation.": "This document describes the rules Account Abstraction protocols should follow, during the validation phase of Account Abstraction transactions,\nsuch asERC-4337UserOperationor RIP-7560 (Native Account Abstraction), which are enforced off-chain by a\nblock builder or a standalone bundler, and the rationale behind each one of them.", "Abstract": "This document describes the rules Account Abstraction protocols should follow, during the validation phase of Account Abstraction transactions,\nsuch asERC-4337UserOperationor RIP-7560 (Native Account Abstraction), which are enforced off-chain by a\nblock builder or a standalone bundler, and the rationale behind each one of them.", "Motivation": "With Account-Abstraction, instead of hard-coded logic for processing a transaction (validation, gas-payment, and execution), this logic is executed by EVM code.\nThe benefits for the account are countless -", "Specification": "We define two types of validation rules:network-wide rulesandlocal rules.", "Validation Rules Types": "We define two types of validation rules:network-wide rulesandlocal rules.", "Constants": "We define a valuemax_seen = opsSeen // MIN_INCLUSION_RATE_DENOMINATOR.", "Validation Rules": "We define a valuemax_seen = opsSeen // MIN_INCLUSION_RATE_DENOMINATOR.", "Definitions:": "We define a valuemax_seen = opsSeen // MIN_INCLUSION_RATE_DENOMINATOR.", "Reputation Definitions": "We define a valuemax_seen = opsSeen // MIN_INCLUSION_RATE_DENOMINATOR.", "Reputation Calculation": "We define a valuemax_seen = opsSeen // MIN_INCLUSION_RATE_DENOMINATOR.", "Running the Validation Rules": "The storage access withSLOADandSSTORE(andTLOAD,TSTORE) instructions within each phase is limited as follows:", "Mempool Validation Rules": "The storage access withSLOADandSSTORE(andTLOAD,TSTORE) instructions within each phase is limited as follows:", "Opcode Rules": "The storage access withSLOADandSSTORE(andTLOAD,TSTORE) instructions within each phase is limited as follows:", "Code Rules": "The storage access withSLOADandSSTORE(andTLOAD,TSTORE) instructions within each phase is limited as follows:", "Storage Rules": "The storage access withSLOADandSSTORE(andTLOAD,TSTORE) instructions within each phase is limited as follows:", "Local Rules": "Local storage rules protect the bundler against denial of service at the time of bundling. They do not affect mempool propagation and cannot cause a bundler to be marked as a \u201cspammer\u201d.", "General Reputation Rules": "The following reputation rules apply for all staked entities, and for unstaked paymasters. All rules apply to all of these entities unless specified otherwise.", "Staked Entities Reputation Rules": "Alternate mempool is an agreed-upon rule that the bundlers may opt into, in addition to the canonical mempool\nThe alt-mempool \u201ctopic\u201d is a unique identifier. By convention, this is the IPFS hash of the document describing (in clear test and YAML file) the specifics of this alt mempool.", "Entity-specific Rules": "Alternate mempool is an agreed-upon rule that the bundlers may opt into, in addition to the canonical mempool\nThe alt-mempool \u201ctopic\u201d is a unique identifier. By convention, this is the IPFS hash of the document describing (in clear test and YAML file) the specifics of this alt mempool.", "Unstaked Entities Reputation Rules": "Alternate mempool is an agreed-upon rule that the bundlers may opt into, in addition to the canonical mempool\nThe alt-mempool \u201ctopic\u201d is a unique identifier. By convention, this is the IPFS hash of the document describing (in clear test and YAML file) the specifics of this alt mempool.", "Alt-mempools Rules": "Alternate mempool is an agreed-upon rule that the bundlers may opt into, in addition to the canonical mempool\nThe alt-mempool \u201ctopic\u201d is a unique identifier. By convention, this is the IPFS hash of the document describing (in clear test and YAML file) the specifics of this alt mempool.", "Alt-mempool Reputation": "Alt-mempools are served by the same bundlers participating in the canonical mempool, but change the rules and may introduce denial-of-service attack vectors. To prevent them from taking the canonical mempool or other alt mempools down with them, a reputation is managed for each. An alt mempool that causes too many invalidations gets throttled. This limits the scope of the attack and lets the bundler continue doing its work for other mempools.", "Authorizations": "The validation rules attempt to guarantee a degree of isolation between individualUserOperations\u2019 validations.\nIn order to prevent hitting the memory expansion limitations (imposed by ethereum EVM) when creating a bundle,UserOperations must meet the following limitations:", "Limitations": "The validation rules attempt to guarantee a degree of isolation between individualUserOperations\u2019 validations.\nIn order to prevent hitting the memory expansion limitations (imposed by ethereum EVM) when creating a bundle,UserOperations must meet the following limitations:", "Rationale": "All transactions initiated by EOAs have an implicit validation phase where balance, nonce, and signature are\nchecked to be valid for the current state of the Ethereum blockchain.\nOnce the transaction is checked to be valid by a node, only another transaction by the same EOA can modify the Ethereum\nstate in a way that makes the first transaction invalid.", "The high-level goal": "The purpose of this specification is to define a consensus between nodes (bundlers or block-builders) when processing incoming UserOperations from an external source.\nThis external source for UserOperations is either an end-user node (via RPCERC-7769) or another node in the p2p network.", "The processing flow of a UserOperation": "A normal Ethereum transaction in the mempool can be invalidated if another transaction was received with the same nonce. That other transaction had to increase the gas price in order to replace the first one, so it satisfied the rule of \u201cmust pay to get included into the mempool\u201d.\nWith contract-based accounts, since the UserOperation validity may depend on mutable state, other transactions may invalidate a previously valid UserOperation, so we must check it before inclusion.", "The need for 2nd validation before submitting a block": "A normal Ethereum transaction in the mempool can be invalidated if another transaction was received with the same nonce. That other transaction had to increase the gas price in order to replace the first one, so it satisfied the rule of \u201cmust pay to get included into the mempool\u201d.\nWith contract-based accounts, since the UserOperation validity may depend on mutable state, other transactions may invalidate a previously valid UserOperation, so we must check it before inclusion.", "Rationale of limiting opcodes:": "We want to be able to allow globally-used contracts (paymasters, factories, aggregators) to use storage not associated with the account, but still prevent them from\nspamming the mempool.\nIf a contract causes too many UserOperations to fail in their second validation after succeeding in their first, we can throttle its use in the mempool.\nBy requiring such a contract to have a stake, we prevent a \u201cSybil attack\u201d, by making it expensive to create a large number of such paymasters to continue the spam attack.", "Rationale for limiting storage access": "We want to be able to allow globally-used contracts (paymasters, factories, aggregators) to use storage not associated with the account, but still prevent them from\nspamming the mempool.\nIf a contract causes too many UserOperations to fail in their second validation after succeeding in their first, we can throttle its use in the mempool.\nBy requiring such a contract to have a stake, we prevent a \u201cSybil attack\u201d, by making it expensive to create a large number of such paymasters to continue the spam attack.", "Rationale of requiring a stake": "We want to be able to allow globally-used contracts (paymasters, factories, aggregators) to use storage not associated with the account, but still prevent them from\nspamming the mempool.\nIf a contract causes too many UserOperations to fail in their second validation after succeeding in their first, we can throttle its use in the mempool.\nBy requiring such a contract to have a stake, we prevent a \u201cSybil attack\u201d, by making it expensive to create a large number of such paymasters to continue the spam attack.", "Definition of themass invalidation attack": "A possible set of actions is considered to be amass invalidation attackon the network if a large number ofUserOperationsthat did pass the initial validation and were accepted by nodes and propagated further into the\nmempool to other bundlers in the network becomes invalid and not eligible for inclusion in a block.", "What is not considered amass invalidation attack": "AUserOperationthat fails the initial validation by a receiving node without entering its mempool is not\nconsidered an attack. The node is expected to apply web2 security measures and throttle requests based on API key,\nsource IP address, etc.\nRPC nodes already do that to prevent being spammed with invalid transactions which also have a validation cost.\nP2P nodes already have (and should apply) a scoring mechanism to determine spammer nodes.", "Security Considerations": "This document describes the security considerations bundlers must take to protect themselves (and the entire mempool network)\nfrom denial-of-service attacks.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- memory expansion: An operation that expands the contract's memory space to accommodate additional data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7564, "url": "https://eips.ethereum.org/EIPS/eip-7564", "title": "Contract wallet management NFT", "authors": ["Xiang\u00a0(", "@wenzhenxiang", ")", "Ben77\u00a0(", "@ben2077", ")", "Mingshi S.\u00a0(", "@newnewsms", ")"], "sections": {"ERC-7564: Contract wallet management NFT": "This proposal introduces a smart contract wallet-based approach for managing NFTs, focusing on utilizing the programmable features of smart contract wallets for NFT asset management. Additionally, it introduces functions such asnftApprove,nftSetApprovalForOneAll,nftSetApprovalForAllAll,nftGetApproved,nftIsApprovedForOneAll,nftIsApprovedForAllAllandnftTransfer, which provide enhanced control over NFT transactions. This approach seeks to enhance NFT management by utilizing the built-in features of smart contract wallets, thus offering a more adaptable, secure, and efficient method for managing token transactions.", "Focuses on NFT management within smart contract wallets, offering enhanced transaction flexibility and security": "This proposal introduces a smart contract wallet-based approach for managing NFTs, focusing on utilizing the programmable features of smart contract wallets for NFT asset management. Additionally, it introduces functions such asnftApprove,nftSetApprovalForOneAll,nftSetApprovalForAllAll,nftGetApproved,nftIsApprovedForOneAll,nftIsApprovedForAllAllandnftTransfer, which provide enhanced control over NFT transactions. This approach seeks to enhance NFT management by utilizing the built-in features of smart contract wallets, thus offering a more adaptable, secure, and efficient method for managing token transactions.", "Abstract": "This proposal introduces a smart contract wallet-based approach for managing NFTs, focusing on utilizing the programmable features of smart contract wallets for NFT asset management. Additionally, it introduces functions such asnftApprove,nftSetApprovalForOneAll,nftSetApprovalForAllAll,nftGetApproved,nftIsApprovedForOneAll,nftIsApprovedForAllAllandnftTransfer, which provide enhanced control over NFT transactions. This approach seeks to enhance NFT management by utilizing the built-in features of smart contract wallets, thus offering a more adaptable, secure, and efficient method for managing token transactions.", "Motivation": "An externally-owned account (EOA) wallet has no state and code storage, while the smart contract wallet does.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "the key technical decisions in this proposal are:", "Backwards Compatibility": "This ERC can be used as an extension ofERC-4337and is backward compatible with ERC-4337.", "Security Considerations": "No security considerations were found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7565, "url": "https://eips.ethereum.org/EIPS/eip-7565", "title": "Perpetual Contract NFTs as Collateral", "authors": ["Hyoungsung Kim (@HyoungsungKim)\u00a0<", "hyougnsung@keti.re.kr", ">", "Yong-Suk Park\u00a0<", "yspark@keti.re.kr", ">", "Hyun-Sik Kim\u00a0<", "hskim@keti.re.kr", ">"], "sections": {"ERC-7565: Perpetual Contract NFTs as Collateral": "This ERC proposes a mechanism where a person (referred to as the \u201cAsset Owner\u201d) can collateralize NFTs that represent locked deposits or assets, to borrow funds against them. These NFTs represent the right to claim the underlying assets, along with any accrued benefits, after a predefined maturity period.1", "Lock financial assets as NFTs and use them as collateral for borrowing funds in DeFi, facilitating liquidity provision.": "This ERC proposes a mechanism where a person (referred to as the \u201cAsset Owner\u201d) can collateralize NFTs that represent locked deposits or assets, to borrow funds against them. These NFTs represent the right to claim the underlying assets, along with any accrued benefits, after a predefined maturity period.1", "Abstract": "This ERC proposes a mechanism where a person (referred to as the \u201cAsset Owner\u201d) can collateralize NFTs that represent locked deposits or assets, to borrow funds against them. These NFTs represent the right to claim the underlying assets, along with any accrued benefits, after a predefined maturity period.1", "Motivation": "The rapidly evolving landscape of DeFi has introduced various mechanisms for asset locking, offering benefits like interest and voting rights. However, one of the significant challenges in this space is maintaining liquidity while these assets are locked. This ERC addresses this challenge by proposing a method to generate profit from locked assets usingERC-721andERC-4907.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Contract Interface": "Solidity interface.", "Rationale": "The design of this standard is driven by the need to address specific challenges in the DeFi sector, particularly concerning the liquidity and management of assets locked as collateral. Traditional mechanisms in DeFi often require asset holders to lock up their assets for participation in activities such as lending, staking, or yield farming, which results in a loss of liquidity. This standard aims to introduce a more flexible approach, allowing asset holders to retain some liquidity while their assets are locked, thereby enhancing the utility and appeal of DeFi products.", "Design Motivation": "The design of this standard is driven by the need to address specific challenges in the DeFi sector, particularly concerning the liquidity and management of assets locked as collateral. Traditional mechanisms in DeFi often require asset holders to lock up their assets for participation in activities such as lending, staking, or yield farming, which results in a loss of liquidity. This standard aims to introduce a more flexible approach, allowing asset holders to retain some liquidity while their assets are locked, thereby enhancing the utility and appeal of DeFi products.", "Design Decision": "Fully compatible withERC-721and integrates withERC-4907for renting NFTs.", "Alternate Designs and Related Work": "Fully compatible withERC-721and integrates withERC-4907for renting NFTs.", "Backwards Compatibility": "Fully compatible withERC-721and integrates withERC-4907for renting NFTs.", "Test Cases": "Run in Terminal\uff1a", "Reference Implementation": "Copyright and related rights waived viaCC0.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7566, "url": "https://eips.ethereum.org/EIPS/eip-7566", "title": "Multiplayer Game Communication", "authors": ["Rickey\u00a0(", "@HelloRickey", ")"], "sections": {"ERC-7566: Multiplayer Game Communication": "This proposal introduces a multiplayer game communication (MGC) interface, usingroomto match and group players, and usingmessageto process actions between players. This allows one smart contract to handle multiple players playing games on the chain, preventing centralized servers from affecting the fairness of the game.", "A communication channel that facilitates interaction between players in on-chain games.": "This proposal introduces a multiplayer game communication (MGC) interface, usingroomto match and group players, and usingmessageto process actions between players. This allows one smart contract to handle multiple players playing games on the chain, preventing centralized servers from affecting the fairness of the game.", "Abstract": "This proposal introduces a multiplayer game communication (MGC) interface, usingroomto match and group players, and usingmessageto process actions between players. This allows one smart contract to handle multiple players playing games on the chain, preventing centralized servers from affecting the fairness of the game.", "Motivation": "Common multiplayer games are generally played on centralized servers. Players have no way of knowing whether there are forged data and cheating on the server. The owner of the game server can match players at will, modify scores and levels, and even close and pause the game. If the player\u2019s actions all occur on the chain, every message from the chain is proof of the player\u2019s instructions and actions, which further ensures the fairness of the game. The Multiplayer Game Communication framework scales vertically by adding rooms to handle and accommodate multiple players. Write on-chain game logic with custom messages for horizontal expansion, allowing game developers to build multiplayer and fully on-chain games with smart contracts.Advantages of using this standard include:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Interfaces": "The libraryTypes.solcontains an enumeration of Solidity types used in the above interfaces.", "Library": "The libraryTypes.solcontains an enumeration of Solidity types used in the above interfaces.", "Rationale": "Because the rooms are independent, each player will be assigned a new ID when entering a room. A new game round can be a room, a game task can be a room, and a game activity can be a room.", "Why are multiplayer onchain games room-based?": "Because the rooms are independent, each player will be assigned a new ID when entering a room. A new game round can be a room, a game task can be a room, and a game activity can be a room.", "The player\u2019s state in the game.": "The game state refers to the player\u2019s data changes in the game, andsendMessageactually plays the role of a state converter. The proposal is very flexible, you can define some data inside the room (internal) or outside the room (global) according to the game logic.", "How to initialize player data?": "You can initialize player data increateRoomorjoinRoom.", "How to check and handle player exits from the game?": "You can useblock.timestamporblock.numberto record the latestsendMessagetime of a member. And add a message type tosendMessage. Other players can use this message type to complain that a member is offline and punish the member.", "Appropriate game categories.": "This is a multiplayer on-chain game rather than a multiplayer real-time game standard. The game category depends on the network your contract is deployed on. Some layer 2 networks process blocks very quickly and can make some more real-time games. Generally, the network is more suitable for strategy, trading card, turn-based, chess, sandbox, and settlement.", "Reference Implementation": "SeeMultiplayer Game Communication Example", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7572, "url": "https://eips.ethereum.org/EIPS/eip-7572", "title": "Contract-level metadata via `contractURI()`", "authors": ["Devin Finzer\u00a0(", "@dfinzer", ")", "Alex Atallah\u00a0(", "@alexanderatallah", ")", "Ryan Ghods\u00a0(", "@ryanio", ")"], "sections": {"ERC-7572: Contract-level metadata via `contractURI()`": "This specification standardizescontractURI()to return contract-level metadata. This is useful for dapps and offchain indexers to show rich information about a contract, such as its name, description and image, without specifying it manually or individually for each dapp.", "Specifying and updating contract-level metadata": "This specification standardizescontractURI()to return contract-level metadata. This is useful for dapps and offchain indexers to show rich information about a contract, such as its name, description and image, without specifying it manually or individually for each dapp.", "Abstract": "This specification standardizescontractURI()to return contract-level metadata. This is useful for dapps and offchain indexers to show rich information about a contract, such as its name, description and image, without specifying it manually or individually for each dapp.", "Motivation": "Dapps have included supported forcontractURI()for years without an ERC to reference. This standard also introduces the eventContractURIUpdated()to signal when to update the metadata.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Schema for contractURI": "The schema for the JSON returned fromcontractURI()MUST conform to:", "Rationale": "The method namecontractURI()was chosen based on its existing implementation in dapps. The eventContractURIUpdated()is specified to help offchain indexers to know when to refetch the metadata.", "Backwards Compatibility": "As a new ERC, no backwards compatibility issues are present.", "Reference Implementation": "Addresses specified ascollaboratorsshould be expected to receive admin-level functionality for updating contract information on dapps that implement this standard.", "Security Considerations": "Addresses specified ascollaboratorsshould be expected to receive admin-level functionality for updating contract information on dapps that implement this standard.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7573, "url": "https://eips.ethereum.org/EIPS/eip-7573", "title": "Conditional-upon-Transfer-Decryption for DvP", "authors": ["Christian Fries\u00a0(", "@cfries", ")", "Peter Kohl-Landgraf\u00a0(", "@pekola", ")"], "sections": {"ERC-7573: Conditional-upon-Transfer-Decryption for DvP": "The interfaces in this proposal model a functional transaction scheme to establish a securedelivery-versus-paymentacross two blockchains, where a) no intermediary is required and b) one of the two chains\ncan securely interact with a stateless \u201cdecryption oracle\u201d. Here,delivery-versus-paymentrefers to the exchange of,\ne.g., an asset against a payment; however, the concept is generic to make a transfer of one token on one\nchain (e.g., the payment) conditional to the successful transfer of another token on another chain (e.g., the asset).", "A Protocol for Secure Delivery-versus-Payment across two Blockchains": "The interfaces in this proposal model a functional transaction scheme to establish a securedelivery-versus-paymentacross two blockchains, where a) no intermediary is required and b) one of the two chains\ncan securely interact with a stateless \u201cdecryption oracle\u201d. Here,delivery-versus-paymentrefers to the exchange of,\ne.g., an asset against a payment; however, the concept is generic to make a transfer of one token on one\nchain (e.g., the payment) conditional to the successful transfer of another token on another chain (e.g., the asset).", "Abstract": "The interfaces in this proposal model a functional transaction scheme to establish a securedelivery-versus-paymentacross two blockchains, where a) no intermediary is required and b) one of the two chains\ncan securely interact with a stateless \u201cdecryption oracle\u201d. Here,delivery-versus-paymentrefers to the exchange of,\ne.g., an asset against a payment; however, the concept is generic to make a transfer of one token on one\nchain (e.g., the payment) conditional to the successful transfer of another token on another chain (e.g., the asset).", "Motivation": "Within the domain of financial transactions and distributed ledger technology (DLT), the Hash-Linked Contract (HLC) concept has been recognized as valuable and has been thoroughly investigated.\nThe concept may help to solve the challenge of delivery-versus-payment (DvP), especially in cases where the asset chain and payment system (which may be a chain, too) are separated.\nA prominent application of smart contracts realizing a secure DvP is that of buying an asset, where the asset is managed on one chain (the asset chain), but the payments are executed on another chain (the payment chain).\nProposed solutions are based on an API-based interaction mechanism which bridges the communication between a so-called asset chain and a corresponding\npayment system or requires complex and problematic time locks.1", "Specification": "The following methods specify the functionality of the smart contract implementing\nthe locking. For further information, please also look at the interface\ndocumentationILockingContract.sol.", "Methods": "The following methods specify the functionality of the smart contract implementing\nthe locking. For further information, please also look at the interface\ndocumentationILockingContract.sol.", "Encryption and Decryption": "The linkage of the two smart contracts relies on use of akey,encryptedKeyandhashedKey.\nThe implementation is free to support several encryption methods for\nas long as the decryption oracle supports it.", "Sequence diagram of delivery versus payment": "The interplay of the two smart contracts is summarized\nin the following sequence diagram:", "Rationale": "The protocol tries to be parsimonious. The transfer\nis associated with a (preferably unique)idpossibly\ngenerated by some additional interaction of the trading\nparties.", "Ensuring Secure Key Decryption - Key Format": "It has to be ensured that the decryption oracle decrypts a key only for the eligible contract.", "Security Considerations": "The decryption oracle does not need to be a single trusted entity. Instead, a threshold decryption scheme can be employed, where multiple oracles perform partial decryption, requiring a quorum of them to reconstruct the secret key. This enhances security by mitigating the risk associated with a single point of failure or trust.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7579, "url": "https://eips.ethereum.org/EIPS/eip-7579", "title": "Minimal Modular Smart Accounts", "authors": ["zeroknots\u00a0(", "@zeroknots", ")", "Konrad Kopp\u00a0(", "@kopy-kat", ")", "Taek Lee\u00a0(", "@leekt", ")", "Fil Makarov\u00a0(", "@filmakarov", ")", "Elim Poon\u00a0(", "@yaonam", ")", "Lyu Min\u00a0(", "@rockmin216", ")"], "sections": {"ERC-7579: Minimal Modular Smart Accounts": "This proposal outlines the minimally required interfaces and behavior for modular smart accounts and modules to ensure interoperability across implementations. For accounts, the standard specifies execution, config and fallback interfaces as well as compliance toERC-165andERC-1271. For modules, the standard specifies a core interface, module types and type-specific interfaces.", "Modular smart account interfaces and behavior for interoperability with minimal restrictions for accounts and modules": "This proposal outlines the minimally required interfaces and behavior for modular smart accounts and modules to ensure interoperability across implementations. For accounts, the standard specifies execution, config and fallback interfaces as well as compliance toERC-165andERC-1271. For modules, the standard specifies a core interface, module types and type-specific interfaces.", "Abstract": "This proposal outlines the minimally required interfaces and behavior for modular smart accounts and modules to ensure interoperability across implementations. For accounts, the standard specifies execution, config and fallback interfaces as well as compliance toERC-165andERC-1271. For modules, the standard specifies a core interface, module types and type-specific interfaces.", "Motivation": "Contract accounts are gaining adoption with many accounts being built using a modular architecture. These modular contract accounts (hereafter smart accounts) move functionality into external contracts (modules) in order to increase the speed and potential of innovation, to future-proof themselves and to allow customizability by developers and users. However, currently these smart accounts are built in vastly different ways, creating module fragmentation and vendor lock-in. There are several reasons for why standardizing smart accounts is very beneficial to the ecosystem, including:", "Specification": "Accounts need to be able to execute calldata in different ways. Rather than defining a separate function for each combination of execution types, we decided to encode the execution type in a singlebytes32value. This allows for a more flexible and extensible approach, while also making the code far easier to write, read, maintain and audit. As explained above, the exeuction mode consists of two bytes that encode the call type and the execution type. The call type covers the three different methods of calls, namely single, batched anddelegatecall(note that you candelegatecallto a multicall contract to batchdelegatecalls). The execution type covers the two different types of executions, namely executions that revert on failure and executions that do not revert on failure but implement some form of error handling. This allows for accounts to batch together uncorrelated executions, such that if one execution fails, the other executions can still be executed. These two bytes are followed by 4 unused bytes that are reserved for futurre standardization, should this be required. This is followed by an item of 4 bytes which is a custom mode selector that accounts can implement. This allows for accounts to implement custom execution modes that are not covered by the standard and do not need to be standardized. This item is 4 bytes long to ensure collision resistance between different account vendors, with the same guarantees as Solidity function selectors. Finally, the last 22 bytes are reserved for custom data that can be passed to the account. This allows for accounts to pass any data up to 22 bytes, such as a 2 byte flag followed by an address, or otherwise a pointer to further data packed into the calldata for the execution. For example, this payload can be used to pass a hook address that should be executed before and/or after the execution.", "Definitions": "This standard does not dictate how validator selection is implemented. However, should a smart account encode validator selection mechanisms in data fields passed to the validator (e.g. inuserOp.signatureif used with ERC-4337), the smart account MUST sanitize the affected values before invoking the validator.", "Account": "This standard does not dictate how validator selection is implemented. However, should a smart account encode validator selection mechanisms in data fields passed to the validator (e.g. inuserOp.signatureif used with ERC-4337), the smart account MUST sanitize the affected values before invoking the validator.", "Modules": "This standard separates modules into the following different types that each has a unique and incremental identifier, which MUST be used by accounts, modules and other entities to identify the module type:", "Rationale": "Smart accounts are a new concept and we are still learning about the best ways to build them. Therefore, we should not be too opinionated about how they are built. Instead, we should define the most minimal interfaces that allow for interoperability between smart accounts and modules to be used across different account implementations.", "Minimal approach": "Smart accounts are a new concept and we are still learning about the best ways to build them. Therefore, we should not be too opinionated about how they are built. Instead, we should define the most minimal interfaces that allow for interoperability between smart accounts and modules to be used across different account implementations.", "Extensions": "While we want to be minimal, we also want to allow for innovation and opinionated features. Some of these features might also need to be standardized (for similar reasons as the core interfaces) even if not all smart accounts will implement them. To ensure that this is possible, we suggest for future standardization efforts to be done as extensions to this standard. This means that the core interfaces will not change, but that new interfaces can be added as extensions. These should be proposed as separate ERCs, for example with the title \u201c[FEATURE] Extension forERC-7579\u201d.", "Backwards Compatibility": "Smart accounts that have already been deployed will most likely be able to implement this standard. If they are deployed as proxies, it is possible to upgrade to a new account implementation that is compliant with this standard. If they are deployed as non-upgradeable contracts, it might still be possible to become compliant, for example by adding a compliant adapter as a fallback handler, if this is supported.", "Already deployed smart accounts": "Smart accounts that have already been deployed will most likely be able to implement this standard. If they are deployed as proxies, it is possible to upgrade to a new account implementation that is compliant with this standard. If they are deployed as non-upgradeable contracts, it might still be possible to become compliant, for example by adding a compliant adapter as a fallback handler, if this is supported.", "Reference Implementation": "A full interface of a smart account can be found inIMSA.sol.", "Security Considerations": "Needs more discussion. Some initial considerations:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- delegatecall: A new opcode that is similar to CALLCODE, but it retains the sender and value from the parent scope to the child scope during execution .\n- revert: All calls to this opcode must emit a log with revert data.\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests"}
{"eip": 7580, "url": "https://eips.ethereum.org/EIPS/eip-7580", "title": "Advertisement Tracking Interface", "authors": ["wart\u00a0(", "@wartstone", ")"], "sections": {"ERC-7580: Advertisement Tracking Interface": "This ERC proposes a standard interface for advertisement clients to track user actions in contracts and check corresponding rewards from advertisement protocols. Contracts implementing the interface use events to define a region of interest within a transaction. A Dapp could implement this interface to join an advertisement protocol, which enable projects to fund users for specific actions in a contract. While users could benefit from project funds, dapps would also get proportional rewards once they joined the protocol.", "Interfaces for advertisement clients tracking user actions and checking proportional rewards.": "This ERC proposes a standard interface for advertisement clients to track user actions in contracts and check corresponding rewards from advertisement protocols. Contracts implementing the interface use events to define a region of interest within a transaction. A Dapp could implement this interface to join an advertisement protocol, which enable projects to fund users for specific actions in a contract. While users could benefit from project funds, dapps would also get proportional rewards once they joined the protocol.", "Abstract": "This ERC proposes a standard interface for advertisement clients to track user actions in contracts and check corresponding rewards from advertisement protocols. Contracts implementing the interface use events to define a region of interest within a transaction. A Dapp could implement this interface to join an advertisement protocol, which enable projects to fund users for specific actions in a contract. While users could benefit from project funds, dapps would also get proportional rewards once they joined the protocol.", "Motivation": "Dapps would propsper due to mass adoption and there emerges surging demands for advertisement on chain. Compared with advertisements in web2, web3 has tremendous advantages on delivery and many other fields. We do need a set of standard tracking interfaces to facilitate advertisement related developments, which could create new economic cycles on chain, further boost dapp prosperity and ultimately benefit on chain users.", "Specification": "The keywords \u201cMUST,\u201d \u201cMUST NOT,\u201d \u201cREQUIRED,\u201d \u201cSHALL,\u201d \u201cSHALL NOT,\u201d \u201cSHOULD,\u201d \u201cSHOULD NOT,\u201d \u201cRECOMMENDED,\u201d \u201cMAY,\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Interfaces": "This protocol standardizes how to keep track of inter-dapp operations, which initially offers 2 main methodsonTrackStartandonTrackEnd.", "Rationale": "The core mechanism for this proposal is to provide a shared tracking interface for inter-dapp operations, to improve the efficiency and fulfill the required tracking business. We provide two interface functionsonTrackStartandonTrackEndto fill the basic required info and connect the necessary dots. Sure there\u2019re more demands for more functions and it would be updated later.", "Backwards Compatibility": "No backward compatibility issues are introduced by this standard.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7582, "url": "https://eips.ethereum.org/EIPS/eip-7582", "title": "Modular Accounts with Delegated Validation", "authors": ["Shivanshi Tyagi\u00a0(", "@nerderlyne", ")", "Ross Campbell\u00a0(", "@z0r0z", ")"], "sections": {"ERC-7582: Modular Accounts with Delegated Validation": "This proposal standardizes a method for adding plugins and composable logic to smart contract accounts built on existing interfaces likeERC-4337(e.g., ERC-4337\u2019sIAccount). Specifically, by formalizing how applications can use the ERC-4337 Entry PointNonceManagerand the emission of theIEntryPointUserOperationEventto account for plugin interactions, as well, as how to extract designated validators (in this case, by means ofIAccount\u2019svalidateUserOp), accounts can specify how they call plugin contracts and grant special executory access for more advanced operations. Furthermore, this minimalist plugin approach is developer-friendly and complimentary to existing account abstraction standards by not requiring any additional functions for contracts that follow theIAccountinterface (itself minimalist in only specifying one function,validateUserOp).", "Extends ERC-4337 interface with nonce-based plugins": "This proposal standardizes a method for adding plugins and composable logic to smart contract accounts built on existing interfaces likeERC-4337(e.g., ERC-4337\u2019sIAccount). Specifically, by formalizing how applications can use the ERC-4337 Entry PointNonceManagerand the emission of theIEntryPointUserOperationEventto account for plugin interactions, as well, as how to extract designated validators (in this case, by means ofIAccount\u2019svalidateUserOp), accounts can specify how they call plugin contracts and grant special executory access for more advanced operations. Furthermore, this minimalist plugin approach is developer-friendly and complimentary to existing account abstraction standards by not requiring any additional functions for contracts that follow theIAccountinterface (itself minimalist in only specifying one function,validateUserOp).", "Abstract": "This proposal standardizes a method for adding plugins and composable logic to smart contract accounts built on existing interfaces likeERC-4337(e.g., ERC-4337\u2019sIAccount). Specifically, by formalizing how applications can use the ERC-4337 Entry PointNonceManagerand the emission of theIEntryPointUserOperationEventto account for plugin interactions, as well, as how to extract designated validators (in this case, by means ofIAccount\u2019svalidateUserOp), accounts can specify how they call plugin contracts and grant special executory access for more advanced operations. Furthermore, this minimalist plugin approach is developer-friendly and complimentary to existing account abstraction standards by not requiring any additional functions for contracts that follow theIAccountinterface (itself minimalist in only specifying one function,validateUserOp).", "Motivation": "Smart contract accounts (contract accounts) are a powerful tool for managing digital assets and executing transactions by allowing users to program their interactions with blockchains. However, they are often limited in their functionality and flexibility without sufficient consensus around secure abstraction designs (albeit, the adoption of ERC-4337 is the preferred path of this proposal). For example, contract accounts are often unable to support social recovery, payment schedules, and other features that are common in traditional financial systems without efficient and predictable schemes to delegate execution and other access rights to approximate the UX of custodial and more specialized applications.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "ERC-4337 references:": "PackedUserOperationinterface", "Rationale": "This proposal is designed to be a minimalist extension to ERC-4337 that allows for additional functionality without requiring changes to the existing interface. Keeping the proposal\u2019s footprint small.", "Backwards Compatibility": "No backward compatibility issues found.", "Reference Implementation": "See theMADV reference implementationfor a simple example of how to implement this proposal.", "Security Considerations": "As this proposal introduces no new functions and leaves implementation of the validator extraction method and approval logic open to developers, the surface for security issues is intentionally kept small. Nevertheless, specific validator use cases require further discussion and consideration of the overall ERC-4337 verification flow and its underlying security.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7585, "url": "https://eips.ethereum.org/EIPS/eip-7585", "title": "MixHash and Public Data Storage Proofs", "authors": ["Liu Zhicong\u00a0(", "@waterflier", ")", "William Entriken\u00a0(", "@fulldecent", ")", "Wei Qiushi\u00a0(", "@weiqiushi", ")", "Si Changjun\u00a0(", "@photosssa", ")"], "sections": {"ERC-7585: MixHash and Public Data Storage Proofs": "This proposal introduces a design for \u201cminimum value selection\u201d storage proofs on Merkle trees. The design consists of two main components:", "A design for minimum value selection Storage Proofs on Merkle trees": "This proposal introduces a design for \u201cminimum value selection\u201d storage proofs on Merkle trees. The design consists of two main components:", "Abstract": "This proposal introduces a design for \u201cminimum value selection\u201d storage proofs on Merkle trees. The design consists of two main components:", "Motivation": "TheERC-721andERC-1155standards are widely used in the NFT  fields. However, the current standards do not provide a mechanism for verifying the existence of public data. This is a major obstacle to the development of many applications, such as decentralized data markets, decentralized data storage, and decentralized data oracles.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "MixHash": "MixHash is a Merkle tree root hash value that incorporates data length information. Its structure is as follows:", "Public Data Storage Proofs": "When MixHash is used to identify a piece of public data, anyone can construct a storage proof to demonstrate possession of a copy of that data. Here is a typical process for using a public data storage proof:", "Defending Sourcing Attack": "As can be seen from the process described above, the core of constructing public data storage proofs is based on a public, non-repeating nonce value generated at a specific moment. It requires traversing the entire content of the file within a designated time to construct a correct proof. Without restrictions, this process is vulnerable to external data source attacks: Suppliers do not store data locally but obtain it through network requests when constructing storage proofs. How does our design prevent such attacks?", "Success Rate of Defending Sourcing Attack": "Using a strategy combining block interval limitations and priority for first-time submissions is often effective in defending against external data source attacks. The effectiveness of this approach primarily relies on the difference in speed between reading files from local storage and retrieving files from the network. We can define the success rateR` of defending against external data source attacks using the following formula:", "Limitations": "We can use the existing Ethereum ecosystem to confirm whether a MixHash is public data and track its value. For any contracts related to unstructured data, theERCPublicDataOwnerinterface can be implemented. This interface determines whether a specific MixHash is associated with the current contract and attempts to return an Owner address corresponding to a MixHash. Additionally, for the existing and widely recognized NFT ecosystem, we suggest that newERC-721andERC-1155contracts implement a new extension interfaceERC721MixHashVerify. This interface can explicitly associate an NFT with a MixHash. The specific interface definition is as follows:", "ERC Extension Suggestion: Tracking High-Value Public Data by MixHash": "We can use the existing Ethereum ecosystem to confirm whether a MixHash is public data and track its value. For any contracts related to unstructured data, theERCPublicDataOwnerinterface can be implemented. This interface determines whether a specific MixHash is associated with the current contract and attempts to return an Owner address corresponding to a MixHash. Additionally, for the existing and widely recognized NFT ecosystem, we suggest that newERC-721andERC-1155contracts implement a new extension interfaceERC721MixHashVerify. This interface can explicitly associate an NFT with a MixHash. The specific interface definition is as follows:", "Rationale": "Storage proofs (often referred to as space-time proofs) have long been a subject of interest, with numerous implementations and related projects existing.", "Backwards Compatibility": "Using HashType allows storage proofs to be compatible with EVM-compatible public blockchain systems, as well as BTC-Like public blockchain systems. In fact, MixHash could become a new cross-chain value anchor: it can track the value of the same data represented by MixHash across different public blockchain networks using different models, achieving the aggregation of cross-chain values. Considering the need for backward compatibility, we have set the default HashType of MixHash to SHA256. Two categories of HashType remain unused, leaving ample room for future expansion.", "Test Cases": "PublicDataProofDemo includes test cases written using Hardhat.", "Reference Implementation": "PublicDataProof Demo", "Security Considerations": "This storage proof revolves around public data. In demonstrating storage proofs, it often involves sending 1KB segments of the data to the public network. Therefore, please do not use the storage proof design presented in this paper for private data.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7589, "url": "https://eips.ethereum.org/EIPS/eip-7589", "title": "Semi-Fungible Token Roles", "authors": ["Ernani S\u00e3o Thiago\u00a0(", "@ernanirst", ")", "Daniel Lima\u00a0(", "@karacurt", ")"], "sections": {"ERC-7589: Semi-Fungible Token Roles": "This standard introduces role management for SFTs (Semi-Fungible Tokens). Each role assignment is granted to a single\nuser (grantee) and expires automatically. Roles are defined asbytes32and feature a custom_datafield of\narbitrary size to allow customization.", "Role Management for Semi-Fungible Tokens (SFTs). Enables accounts to share the utility of SFTs via expirable role assignments.": "This standard introduces role management for SFTs (Semi-Fungible Tokens). Each role assignment is granted to a single\nuser (grantee) and expires automatically. Roles are defined asbytes32and feature a custom_datafield of\narbitrary size to allow customization.", "Abstract": "This standard introduces role management for SFTs (Semi-Fungible Tokens). Each role assignment is granted to a single\nuser (grantee) and expires automatically. Roles are defined asbytes32and feature a custom_datafield of\narbitrary size to allow customization.", "Motivation": "ERC-1155has significantly contributed to the tokenization capabilities of Ethereum by enabling\ndevelopers to create fungible and non-fungible tokens with a single contract. WhileERC-1155excels at\ntracking ownership, it focuses solely on token balances, overlooking the nuanced aspects of how these tokens can be\nutilized.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d,\n\u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Single Transaction Extension": "Granting roles is a two-step process that requires two transactions. The first is to commit tokens, and the second is to\ngrant the role. This extension allows users to commit tokens and grant a role in one transaction, which is desirable for\nsome use cases.", "Role Balance Extension": "The core interface allows for querying a token commitment\u2019s balance but not for a specific user\u2019s balance. To determine\nthe total amount of tokens granted to a user, the implementation needs to sum up all the roles granted to that user\nwhile filtering out any expired roles.", "Metadata Extension": "The Roles Metadata extension extends the traditional JSON-based metadata schema of SFTs. Therefore, DApps supporting\nthis feature MUST also implement the metadata extension ofERC-1155. This JSON extension isoptionaland allows developers to provide additional information on roles.", "Caveats": "The concept of \u201ctoken commitments\u201d as an abstraction serves as a powerful tool for users looking to delegate the control\nof their SFTs. A token commitment represents either a frozen balance or tokens deposited into a contract, offering a\nstandardized and secure way for SFT owners to delegate the use of their assets. ThroughERC-7589, users\ngain a versatile mechanism to abstract the complexities of secure delegation, enhancing the utility and interoperability\nof semi-fungible tokens.", "Rationale": "The concept of \u201ctoken commitments\u201d as an abstraction serves as a powerful tool for users looking to delegate the control\nof their SFTs. A token commitment represents either a frozen balance or tokens deposited into a contract, offering a\nstandardized and secure way for SFT owners to delegate the use of their assets. ThroughERC-7589, users\ngain a versatile mechanism to abstract the complexities of secure delegation, enhancing the utility and interoperability\nof semi-fungible tokens.", "Role Approvals": "LikeERC-1155,ERC-7589allows users to approve operators to grant and revoke roles on\ntheir behalf. This feature is crucial for interoperability, as it enables third-party applications to manage user roles\nwithout custody-level approvals. Role approvals are part of the core interface, and compliant contracts must implement\nthesetRoleApprovalForAllandisRoleApprovedForAllfunctions.", "Automatic Expiration": "Automatic expiration is implemented to save users gas. To end a role assignment, instead of requiring users always to\ncallrevokeRole, applications should call theroleExpirationDateand compare it to the current timestamp to check if\nthe role is still valid.", "Revocable Roles": "In certain scenarios, the grantor might need to revoke a role before its expiration. While in others, the grantee\nrequires assurance that the role can\u2019t be prematurely revoked (e.g. when the grantee pays tokens to utilize them). The_revocableparameter was included in thegrantRolefunction for this exact reason, and it specifies whether the\ngrantor can revoke the role prior to the expiration date. Regardless of the_revocablevalue, the grantee will always \nbe able to revoke roles, allowing recipients to eliminate undesirable assignments.", "Custom Data": "ThegrantRolefunction\u2019s_dataparameter is critical for the standardization of this EIP. SFTs have different use\ncases, and it\u2019s impractical to attempt to cover all of them on a solidity-level interface. Therefore, a generic\nparameter of typebyteswas incorporated, allowing users to pass any custom information when granting a role.", "Backwards Compatibility": "Many SFTs are deployed as immutable contracts, which imposes the following challenge: How can one enable role management\nfor SFTs that can\u2019t be modified? This proposal solves this problem by requiring thetokenAddressparameter\nwhen committing tokens. This requirement ensures that dApps can either implementERC-7589inside the\nSFT contract or use a standalone external contract as the authoritative source for the roles of immutable SFTs.", "Reference Implementation": "SeeERC7589.sol.", "Security Considerations": "Developers integrating with Semi-Fungible Token Roles should consider the points below on their implementations:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7595, "url": "https://eips.ethereum.org/EIPS/eip-7595", "title": "Collateralized NFT", "authors": ["571nKY\u00a0(", "@571nKY", ")", "Cosmos\u00a0(", "@Cosmos4k", ")", "f4t50\u00a0(", "@f4t50", ")", "Harpocrates\u00a0(", "@harpocrates555", ")"], "sections": {"ERC-7595: Collateralized NFT": "This proposal recommends an extension ofERC-721to allow for collateralization using a list ofERC-20based tokens. The proprietor of this ERC collection could hold both the native coin andERC-20based tokens, with theownerOftokenId being able to unlock the associated portion of the underlyingERC-20balance.", "ERC-721 Extension to enable collateralization with ERC-20 based tokens.": "This proposal recommends an extension ofERC-721to allow for collateralization using a list ofERC-20based tokens. The proprietor of this ERC collection could hold both the native coin andERC-20based tokens, with theownerOftokenId being able to unlock the associated portion of the underlyingERC-20balance.", "Abstract": "This proposal recommends an extension ofERC-721to allow for collateralization using a list ofERC-20based tokens. The proprietor of this ERC collection could hold both the native coin andERC-20based tokens, with theownerOftokenId being able to unlock the associated portion of the underlyingERC-20balance.", "Motivation": "The emerging trend of NFT finance focuses on the NFT floor price to enable the market value of the NFT serve as a collateral in lending protocols. The NFT floor price is susceptible to the supply-demand dynamics of the NFT market, characterized by higher volatility compared to the broader crypto market. Furthermore, potential price manipulation in specific NFT collections can artificially inflate NFT market prices, impacting the floor price considered by lending protocols. Relying solely on the NFT floor price based on market value is both unpredictable and unreliable.", "Presets": "For numerousERC-721based collections that cannot be redeployed, we propose the implementation of an abstraction layer embodied by a smart contract. This smart contract would replicate all the functionalities of this ERC standard and grant access to collateral through mapping.", "Extension to Existing ERC-721 Based Collections": "For numerousERC-721based collections that cannot be redeployed, we propose the implementation of an abstraction layer embodied by a smart contract. This smart contract would replicate all the functionalities of this ERC standard and grant access to collateral through mapping.", "Specification": "We propose adopting the term \u201cEnvious\u201d to describe any NFT collection minted using this ERC standard or anyERC-721based NFT collection that utilized the EnviousHouse abstraction layer.", "ERC standard for new NFT collections": "We propose adopting the term \u201cEnvious\u201d to describe any NFT collection minted using this ERC standard or anyERC-721based NFT collection that utilized the EnviousHouse abstraction layer.", "Abstraction layer for already deployed NFT collections": "We propose adopting the term \u201cEnvious\u201d to describe any NFT collection minted using this ERC standard or anyERC-721based NFT collection that utilized the EnviousHouse abstraction layer.", "Rationale": "We propose adopting the term \u201cEnvious\u201d to describe any NFT collection minted using this ERC standard or anyERC-721based NFT collection that utilized the EnviousHouse abstraction layer.", "\u201cEnvious\u201d Term Choice": "We propose adopting the term \u201cEnvious\u201d to describe any NFT collection minted using this ERC standard or anyERC-721based NFT collection that utilized the EnviousHouse abstraction layer.", "NFT Collateralization with Multiple Tokens": "Some Web3 projects primarily collateralize a specific NFT asset with oneERC-20based token, resulting in increased gas fees and complications in User Experience (UX).", "NFT Collateralization with the Native Coin": "EachERC-20based token possesses a distinct address. However, a native coin does not carry an address. To address this, we propose utilizing a null address (0x0000000000000000000000000000000000000000) as an identifier for the native coin during collateralization, as it eliminates the possibility of collisions with smart contract addresses.", "Disperse Functionality": "We have implemented the capability to collateralize all assets within a particular NFT collection in a single transaction. The complete collateral amount is deposited into a smart contract, enabling each user to claim their respective share of the collateral when they add or redeem collateral for that specific asset.", "Harvest Functionality": "Each Envious NFT collection provides an option to incorporate a communityERC-20based token, which can be exchanged for commissions accrued from collateralization and uncollateralization activities.", "BlackHole Instance": "SomeERC-20based token implementations forbid transfers to the null address, it is necessary to have a reliable burning mechanism in the harvest transactions.blackHolesmart contract removesERC-20communityTokens from the circulating supply in exchange for commission fees withdrawn.", "Backwards Compatibility": "EnviousHouse abstraction layer is suggested for already deployedERC-721based NFT collections.", "Security Considerations": "Envious may share security concerns similar to those found inERC-721, such as hidden logic within functions like burn, add resource, accept resource, etc.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7597, "url": "https://eips.ethereum.org/EIPS/eip-7597", "title": "Signature Validation Extension for Permit", "authors": ["Yvonne Zhang\u00a0(", "@yvonnezhangc", ")", "Aloysius Chan\u00a0(", "@circle-aloychan", ")"], "sections": {"ERC-7597: Signature Validation Extension for Permit": "This proposal aims to extend the functionality of the existingERC-2612Permit to support gaslessERC-20approval operations initiated by smart contract wallets.", "An ERC to extend ERC-2612 Permit to support ERC-1271-based signature validation.": "This proposal aims to extend the functionality of the existingERC-2612Permit to support gaslessERC-20approval operations initiated by smart contract wallets.", "EIP: Contract signature validation extension forERC-2612Permit": "This proposal aims to extend the functionality of the existingERC-2612Permit to support gaslessERC-20approval operations initiated by smart contract wallets.", "Abstract": "This proposal aims to extend the functionality of the existingERC-2612Permit to support gaslessERC-20approval operations initiated by smart contract wallets.", "Motivation": "The current signature validation scheme inERC-2612, based on V, R, S parameters, restricts signature validation to EOA wallets.", "Specification": "Compliant contracts must implement thepermitusing the following spec", "Rationale": "By replacing the existing V, R, S signature validation scheme and introducing support for unstructured bytes input, contract developers can use a unified interface to validate signature from both EOAs and SC wallets. This allows for the utilization of different signature schemes and algorithms fitting the wallet type, paving the way for smart contract wallets and advanced wallet types to enhance their signature validation processes, promoting flexibility and innovation.", "Backwards Compatibility": "This proposal is fully backward-compatible with the existing ERC-2612 standard. Contracts that currently rely on the V, R, S signature validation scheme will continue to function without any issues.", "Reference Implementation": "Samplepermitimplemented with OZ\u2019s SignatureChecker", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7598, "url": "https://eips.ethereum.org/EIPS/eip-7598", "title": "Use contract signature for signed transfer", "authors": ["Yvonne Zhang\u00a0(", "@yvonnezhangc", ")", "Aloysius Chan\u00a0(", "@circle-aloychan", ")"], "sections": {"ERC-7598: Use contract signature for signed transfer": "This proposal aims to extend the functionality of the existingERC-3009standard, \u201cTransfer With Authorization,\u201d to support transfer operations initiated by smart contract wallets.", "An ERC to extend ERC-3009 Transfer with Authorization to support ERC-1271 signature validation.": "This proposal aims to extend the functionality of the existingERC-3009standard, \u201cTransfer With Authorization,\u201d to support transfer operations initiated by smart contract wallets.", "EIP: Contract signature validation extension forERC-3009Transfer with Authorization": "This proposal aims to extend the functionality of the existingERC-3009standard, \u201cTransfer With Authorization,\u201d to support transfer operations initiated by smart contract wallets.", "Abstract": "This proposal aims to extend the functionality of the existingERC-3009standard, \u201cTransfer With Authorization,\u201d to support transfer operations initiated by smart contract wallets.", "Motivation": "The existingERC-3009standard enables asset transfers with ECDSA signatures. However, as smart contract wallets become more prevalent in the ecosystem, the current standard is no longer sufficient.", "Specification": "The following events and interfaces must still be present given the initial spec defined inERC-3009.", "Rationale": "By replacing the existing V, R, S signature validation scheme and introducing support for unstructured bytes input, contract developers can use a unified interface to validate signature from both EOAs and SC wallets. This allows for the utilization of different signature schemes and algorithms fitting the wallet type, paving the way for smart contract wallets and advanced wallet types to enhance their signature validation processes, promoting flexibility and innovation.", "Backwards Compatibility": "This proposal is fully backward-compatible with the existing ERC-3009 standard. Contracts that currently rely on the V, R, S signature validation scheme will continue to function without any issues.", "Reference Implementation": "Copyright and related rights waived viaCC0.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7603, "url": "https://eips.ethereum.org/EIPS/eip-7603", "title": "ERC-1155 Multi-Asset extension", "authors": ["Haru\u00a0(", "@haruu8", ")"], "sections": {"ERC-7603: ERC-1155 Multi-Asset extension": "The Multi-Asset Token standard, compatible withERC-1155, facilitates the development of a new fundamental component: the context-dependent data output for each collection.", "An interface compatible with ERC-1155 for Multi-Asset tokens with context-dependent asset type output control.": "The Multi-Asset Token standard, compatible withERC-1155, facilitates the development of a new fundamental component: the context-dependent data output for each collection.", "Abstract": "The Multi-Asset Token standard, compatible withERC-1155, facilitates the development of a new fundamental component: the context-dependent data output for each collection.", "Motivation": "With ERC-1155 compatible tokens being a widespread form of tokens in the Ethereum ecosystem and being used for various use cases, it is time to standardize additional utility for them. Having multiple assets associated with a single Token Collection allows for greater utility, usability, and forward compatibility. This EIP improves upon ERC-1155 in the following areas:", "Cross-metaverse compatibility": "The proposal can support any number of different implementations.", "Multi-media output": "Tokens of an eBook can be represented as a PDF, MP3, or some other format, depending on what software loads it. If loaded into an eBook reader, a PDF should be displayed, and if loaded into an audiobook application, the MP3 representation should be used. Other metadata could be present in the Tokens (perhaps the book\u2019s cover image) for identification on various marketplaces, Search Engine Result Pages (SERPs), or portfolio trackers.", "Media redundancy": "Many Tokens are minted hastily without best practices in mind. Specifically, many Tokens are minted with metadata centralized on a server somewhere or, in some cases, a hardcoded IPFS gateway which can also go down, instead of just an IPFS hash.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "TBD", "Backwards Compatibility": "The MultiAsset token standard has been made compatible with ERC-1155 in order to take advantage of the robust tooling available for implementations of ERC-1155 and to ensure compatibility with existing ERC-1155 infrastructure.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7604, "url": "https://eips.ethereum.org/EIPS/eip-7604", "title": "ERC-1155 Permit Approvals", "authors": ["calvbore\u00a0(", "@calvbore", ")", "emiliolanzalaco\u00a0(", "@emiliolanzalaco", ")"], "sections": {"ERC-7604: ERC-1155 Permit Approvals": "The \u201cpermit\u201d approval flow for bothERC-20andERC-721are large improvements for the existing UX of the token underlying each ERC. This ERC extends the \u201cpermit\u201d pattern toERC-1155tokens, borrowing heavily upon bothERC-4494andERC-2612.", "Permit approvals for ERC-1155 tokens": "The \u201cpermit\u201d approval flow for bothERC-20andERC-721are large improvements for the existing UX of the token underlying each ERC. This ERC extends the \u201cpermit\u201d pattern toERC-1155tokens, borrowing heavily upon bothERC-4494andERC-2612.", "Abstract": "The \u201cpermit\u201d approval flow for bothERC-20andERC-721are large improvements for the existing UX of the token underlying each ERC. This ERC extends the \u201cpermit\u201d pattern toERC-1155tokens, borrowing heavily upon bothERC-4494andERC-2612.", "Motivation": "The permit structures outlined in bothERC-4494andERC-2612allows a signed message to create an approval, but are only applicable to their respective underlying tokens (ERC-721andERC-20).", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "Thepermitfunction is sufficient for enabling asafeTransferFromtransaction to be made without the need for an additional transaction.", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "The below considerations have been copied from ERC-4494.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7613, "url": "https://eips.ethereum.org/EIPS/eip-7613", "title": "Puppet Proxy Contract", "authors": ["Igor \u017buk\u00a0(", "@CodeSandwich", ")"], "sections": {"ERC-7613: Puppet Proxy Contract": "A puppet is a contract that, when called, acts like an empty account. It doesn\u2019t do anything and it has no API, except when it is called by the address that deployed it. In that case, it delegates the call to the address passed to it in calldata. This gives the deployer the ability to execute any logic they want in the context of the puppet.", "A proxy that, if called by its deployer, delegates to an implementation specified in calldata.": "A puppet is a contract that, when called, acts like an empty account. It doesn\u2019t do anything and it has no API, except when it is called by the address that deployed it. In that case, it delegates the call to the address passed to it in calldata. This gives the deployer the ability to execute any logic they want in the context of the puppet.", "Abstract": "A puppet is a contract that, when called, acts like an empty account. It doesn\u2019t do anything and it has no API, except when it is called by the address that deployed it. In that case, it delegates the call to the address passed to it in calldata. This gives the deployer the ability to execute any logic they want in the context of the puppet.", "Motivation": "A puppet can be used as an alternative account of its deployer. It has a different address, so it has a separate set of asset balances. This enables sophisticated accounting, e.g. each user of a protocol can get their own address where assets can be sent and stored. The user may call the protocol contract, which in turn will deploy a new puppet and consider it assigned to the user. If the puppet is deployed under a predictable address, e.g. by using the user\u2019s address as the CREATE2 salt, the puppet may not even need to be deployed before funds are sent to its address. From now on the protocol will consider all the assets sent to the puppet as owned by the user. If the protocol needs to move the funds out from the puppet address, it can call the puppet ordering it to delegate to a function transferring the assets to arbitrary addresses, or making arbitrary calls triggering approved transfers to other contracts.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "The main goals of the puppet design are low cost and modularity. It should be cheap to deploy and cheap to interact with. The contract should be self-contained, simple to reason about, and easy to use as an architectural building block.", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "Here are the tests verifying that the bytecode and the reference implementation library are working as expected, using the Foundry test tools:", "Reference Implementation": "The puppet bytecode is explained in the specification section. Here\u2019s the example helper library:", "Security Considerations": "The bytecode is made to resemble clone proxy\u2019s wherever it makes sense to simplify auditing.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7615, "url": "https://eips.ethereum.org/EIPS/eip-7615", "title": "Atomic Push-based Data Feed Among Contracts", "authors": ["Elaine Zhang (@lanyinzly)\u00a0<", "lz8aj@virginia.edu", ">", "Jerry\u00a0<", "jerrymindflow@gmail.com", ">", "Amandafanny\u00a0<", "amandafanny200@gmail.com", ">", "Shouhao Wong (@wangshouh)\u00a0<", "wongshouhao@outlook.com", ">", "Doris Che (@Cheyukj)\u00a0<", "dorischeyy@gmail.com", ">", "Henry Yuan (@onehumanbeing)\u00a0<", "hy2878@nyu.edu", ">"], "sections": {"ERC-7615: Atomic Push-based Data Feed Among Contracts": "This ERC proposes a push-based mechanism for sending data, allowing publisher contract to automatically push certain data to subscriber contracts during a call. The specific implementation relies on two interfaces: one for publisher contract to push data, and another for the subscriber contract to receive data. When the publisher contract is called, it checks if the called function corresponds to subscriber addresses. If it does, the publisher contract push data to the subscriber contracts.", "An Atomic Mechanism to Allow Publisher Contract Push Data to Subcriber Contracts": "This ERC proposes a push-based mechanism for sending data, allowing publisher contract to automatically push certain data to subscriber contracts during a call. The specific implementation relies on two interfaces: one for publisher contract to push data, and another for the subscriber contract to receive data. When the publisher contract is called, it checks if the called function corresponds to subscriber addresses. If it does, the publisher contract push data to the subscriber contracts.", "Abstract": "This ERC proposes a push-based mechanism for sending data, allowing publisher contract to automatically push certain data to subscriber contracts during a call. The specific implementation relies on two interfaces: one for publisher contract to push data, and another for the subscriber contract to receive data. When the publisher contract is called, it checks if the called function corresponds to subscriber addresses. If it does, the publisher contract push data to the subscriber contracts.", "Motivation": "Currently, there are many keepers rely on off-chain data or seperate data collection process to monitor the events on chain. This proposal aims to establish a system where the publisher contract can atomicly push data to inform subscriber contracts about the updates. The direct on-chain interaction bewteen the publisher and the subscriber allows the system to be more trustless and efficient.", "Lending Protocol": "An example of publisher contract could be an oracle, which can automatically push the price update through initiating a call to the subscriber protocol. The lending protocol, as the subscriber, can automatically liquidate the lending positions based on the received price.", "Automatic Payment": "A service provider can use a smart contract as a publisher contract, so that when a user call this contract, it can push the information to the subsriber contracts, such as, the users\u2019 wallets like NFT bound accounts that followsERC-6551or other smart contract wallets. The user\u2019s smart contract wallet can thus perform corresponding payment operations automatically. Compared to traditionalapproveneeded approach, this solution allows more complex logic in implementation, such as limited payment, etc.", "PoS Without Transferring Assets": "For some staking scenarios, especially NFT staking, the PoS contract can be set as the subscriber and the NFT contracts can be set as the publisher. Staking can thus achieved through contracts interation, allowing users to earn staking rewards without transferring assets.", "DAO Voting": "The DAO governance contract as a publisher could automatically triggers the push mechanism after the vote is completed, calling relevant subscriber contracts to directly implement the voting results, such as injecting funds into a certain account or pool.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d,  \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this  document are to be interpreted as described in RFC 2119.", "Overview": "The push mechanism can be divided into the following four steps:", "Contract interface": "As mentioned above, there are Unconditional Push and Conditional Push two types of implementation. To implement Unconditional Push, the publisher contract SHOULD implement the following interface:", "Rationale": "When the sending contract is called, it is possible to trigger a push, requiring the caller to pay the resulting gas fees. \nIn some cases, an Unconditional Push is necessary, such as pushing price changes to a lending protocol. While, Conditional Push will reduce the unwanted gas consumption.", "Unconditional and Conditional Configuration": "When the sending contract is called, it is possible to trigger a push, requiring the caller to pay the resulting gas fees. \nIn some cases, an Unconditional Push is necessary, such as pushing price changes to a lending protocol. While, Conditional Push will reduce the unwanted gas consumption.", "CheckisLockedBefore Unsubscribing": "BeforeforceCancelorcancel, the publisher contract MUST call theisLockedfunction of the subscriber contract to avoid unilateral unsubscribing. The subscriber contract may have a significant logical dependence on the publisher contract, and thus unsubscription could lead to severe issues within the subscriber contract. Therefore, the subscriber contract should implementisLockedfunction with thorough consideration.", "inboxMechanism": "In certain scenarios, the publisher contract may only push essential data withselectorto the subscriber contracts, while the full data might be stored withininbox. Upon receiving the push from the publisher contract, the subscriber contract is optional to callinbox.inboxmechanism simplifies the push information while still ensuring the availability of complete data, thereby reducing gas consumption.", "Using Function Selectors as Parameters": "Using function selectors to retrieve the addresses of subscriber contracts allows \nmore detailed configuration. \nFor the subscriber contract, having the specific function of the request source based on the push information enables more accurate handling of the push information.", "Renounce Safety Enhancement": "BothforceApproveandforceCancelpermissions can be relinquished using their respective renounce functions. When bothrenounceForceApproveandrenounceForceCancelare called, the registered push targets can longer be changed, greatly enhancing security.", "Reference Implementation": "Theexecfunction ispublic, therefore, it is vulnerable to malicious calls where arbitrary push information can be inserted. Implementations ofexecshould carefully consider the arbitrariness of calls and should not directly use data passed by the exec function without verification.", "Security Considerations": "Theexecfunction ispublic, therefore, it is vulnerable to malicious calls where arbitrary push information can be inserted. Implementations ofexecshould carefully consider the arbitrariness of calls and should not directly use data passed by the exec function without verification.", "execAttacks": "Theexecfunction ispublic, therefore, it is vulnerable to malicious calls where arbitrary push information can be inserted. Implementations ofexecshould carefully consider the arbitrariness of calls and should not directly use data passed by the exec function without verification.", "Reentrancy Attack": "The publisher contract\u2019s call to the subscriber contract\u2019sexecfunction could lead to reentrancy attacks. Malicious subscription contracts might construct reentrancy attacks to the publisher contract withinexec.", "Arbitrary Target Approve": "Implementation offorceApproveandapproveshould have reasonable access controls; otherwise, unnecessary gas losses could be imposed on callers.", "isLocked implementation": "Subscriber contracts should implement theisLockedfunction to avoid potential loss brought by unsubscription. This is particularly crucial for lending protocols implementing this proposal. Improper unsubscription can lead to abnormal clearing, causing considerable losses.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7617, "url": "https://eips.ethereum.org/EIPS/eip-7617", "title": "Chunk support for ERC-5219 mode in Web3 URL", "authors": ["Qi Zhou\u00a0(", "@qizhou", ")", "Nicolas Deschildre\u00a0(", "@nand2", ")"], "sections": {"ERC-7617: Chunk support for ERC-5219 mode in Web3 URL": "In the context of theERC-6860web3://standard, this ERC extends theERC-6944resolve mode: This standard defines a new optionalweb3-next-chunkHTTP header returned by therequest()call, that contains aweb3://URL pointing to the next data chunk of the resource data. Chunks are streamed to theweb3://client, and it loops until theweb3-next-chunkheader is no longer present.", "In ERC-5219 resolve mode, add ability to fetch a Web3 URL resource made of several chunks": "In the context of theERC-6860web3://standard, this ERC extends theERC-6944resolve mode: This standard defines a new optionalweb3-next-chunkHTTP header returned by therequest()call, that contains aweb3://URL pointing to the next data chunk of the resource data. Chunks are streamed to theweb3://client, and it loops until theweb3-next-chunkheader is no longer present.", "Abstract": "In the context of theERC-6860web3://standard, this ERC extends theERC-6944resolve mode: This standard defines a new optionalweb3-next-chunkHTTP header returned by therequest()call, that contains aweb3://URL pointing to the next data chunk of the resource data. Chunks are streamed to theweb3://client, and it loops until theweb3-next-chunkheader is no longer present.", "Motivation": "Ethereum RPC endpoints have a gas limit, which can be reached when serving large content. By adding a chunking feature, we add the possibility to serve arbitrary sized content.", "Specification": "In theERC-6944resolve mode, this standard introduces the new optionalweb3-next-chunkHTTP header, to be returned in theheadersKeyValuearray of therequest()method defined inERC-6944.", "Rationale": "The use of a header pointing to the next chunk was chosen because it does not require changes to theERC-6944request()interface, and the use of aweb3://URL in the header add flexibility to the means to provide the next chunk.", "Security Considerations": "No security considerations were found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7618, "url": "https://eips.ethereum.org/EIPS/eip-7618", "title": "Content encoding in ERC-5219 mode Web3 URL", "authors": ["Qi Zhou\u00a0(", "@qizhou", ")", "Nicolas Deschildre\u00a0(", "@nand2", ")"], "sections": {"ERC-7618: Content encoding in ERC-5219 mode Web3 URL": "In the context of theERC-6860web3://standard, this ERC extends theERC-6944resolve mode: This standard specifies that if aContent-Encodingheader is returned by therequest()call, then the returned data is decoded if necessary according to the specified algorithm before being returned to the client.", "In ERC-5219 resolve mode, add ability to decode a compressed resource before serving it to the client": "In the context of theERC-6860web3://standard, this ERC extends theERC-6944resolve mode: This standard specifies that if aContent-Encodingheader is returned by therequest()call, then the returned data is decoded if necessary according to the specified algorithm before being returned to the client.", "Abstract": "In the context of theERC-6860web3://standard, this ERC extends theERC-6944resolve mode: This standard specifies that if aContent-Encodingheader is returned by therequest()call, then the returned data is decoded if necessary according to the specified algorithm before being returned to the client.", "Motivation": "As storage in blockchains is expensive, it is optimal to try to store and serve compressed assets. Standard HTTP uses theAccept-Encoding/Content-Encodingmechanism, in which the client specifies their supported compression algorithms, and the server returns the data compressed in one of them. It is not optimal to replicate this mechanism in theweb3://protocol, due to blockchain storage and computation constraints. Moreover, it is not possible to blindly serve content with a fixedContent-Encodingheader, because the HTTP client may not implement the compression algorithm.", "Specification": "In theERC-6944resolve mode, this standard indicates that if aContent-EncodingHTTP header (in the returnedheadersKeyValuearray of therequest()method) is provided, and if it is not part of the supported algorithms provided by the client in theAccept-Encodingheader, or the client did not provide anAccept-Encodingheader, then the protocol MUST decode the content before forwarding it to theweb3://client.", "Rationale": "We add this feature to theERC-6944resolve mode because it can be added without changes the interface.\nTo stay as close as possible to standard HTTP, we don\u2019t introduce a new HTTP header but reuse the knownContent-Encodingheader.", "Security Considerations": "No security considerations were found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7621, "url": "https://eips.ethereum.org/EIPS/eip-7621", "title": "Basket Token", "authors": ["Dominic Ryder\u00a0<", "dom@alvaraprotocol.io", ">", "Callum Mitchell-Clark (@AlvaraProtocol)\u00a0<", "callum@alvaraprotocol.io", ">", "Joey van Etten\u00a0<", "joe@alvaraprotocol.io", ">", "Michael Ryder\u00a0<", "mike@alvaraprotocol.io", ">"], "sections": {"ERC-7621: Basket Token": "The Basket Token Standard (BTS) allows for the implementation of multi-asset tokenized funds. This standard provides basic functionality for anyone to deploy unique, non-fungible BTS tokens that can contain an unlimited number of underlyingERC-20tokens.", "Collateralized, tokenized funds with adjustable weights and reserves and minting/burning of LP tokens.": "The Basket Token Standard (BTS) allows for the implementation of multi-asset tokenized funds. This standard provides basic functionality for anyone to deploy unique, non-fungible BTS tokens that can contain an unlimited number of underlyingERC-20tokens.", "Abstract": "The Basket Token Standard (BTS) allows for the implementation of multi-asset tokenized funds. This standard provides basic functionality for anyone to deploy unique, non-fungible BTS tokens that can contain an unlimited number of underlyingERC-20tokens.", "Motivation": "The motivation is to provide infrastructure that will enable the on-chain creation and management of asset-backed tokenized investment funds as no such standardized infrastructure curently exists. Providing the necessary infrastructure will help facilitate the onboarding of traditional fund management onto blockchain. No existing standard is capable of achieving this as they lack the required features for third party contribution, namely the minting of LP tokens when contribution is made. TheERC-7621is the only token standard that facilitates this with a rebalance function required for effective fund management, and LP token distribution and burning, required for third party participation.", "Specification": "BTS is a smart contract enabling the creation of on-chain tokenized funds backed by assets, allowing users to manage assets and liquidity through functions like initialization, contribution, withdrawal, rebalancing, and token distribution.", "BTS": "BTS is a smart contract enabling the creation of on-chain tokenized funds backed by assets, allowing users to manage assets and liquidity through functions like initialization, contribution, withdrawal, rebalancing, and token distribution.", "BTSPair": "ERC-20token representing liquidity in a BTS.", "Rationale": "No backward compatibility issues found.", "Backwards Compatibility": "No backward compatibility issues found.", "Reference Implementation": "BTS: Implemented using a combination of OpenZeppelin\u2019sERC-721URIStorageandOwnablecontracts, along with custom logic for token management and rebalancing.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- withdrawal: Log entry in system_logs for tracking withdrawals under EIP-4895 .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7629, "url": "https://eips.ethereum.org/EIPS/eip-7629", "title": "ERC-20/ERC-721 Unified Token Interface", "authors": ["0xZeus1111\u00a0(", "@0xZeus1111", ")", "Nvuwa\u00a0(", "@Nvuwa", ")"], "sections": {"ERC-7629: ERC-20/ERC-721 Unified Token Interface": "This proposal introduces a protocol that establishes a unified interface for managing bothERC-20fungible tokens andERC-721non-fungible tokens (NFTs) on the Ethereum blockchain. By defining a common set of functions applicable to both token types, developers can seamlessly interact withERC-20andERC-721tokens using a single interface. This simplifies integration efforts and enhances interoperability within decentralized applications (DApps).", "introduces a single interface for ERC-20/ERC-721 tokens, enabling seamless interaction by defining common functions for both token types.": "This proposal introduces a protocol that establishes a unified interface for managing bothERC-20fungible tokens andERC-721non-fungible tokens (NFTs) on the Ethereum blockchain. By defining a common set of functions applicable to both token types, developers can seamlessly interact withERC-20andERC-721tokens using a single interface. This simplifies integration efforts and enhances interoperability within decentralized applications (DApps).", "Abstract": "This proposal introduces a protocol that establishes a unified interface for managing bothERC-20fungible tokens andERC-721non-fungible tokens (NFTs) on the Ethereum blockchain. By defining a common set of functions applicable to both token types, developers can seamlessly interact withERC-20andERC-721tokens using a single interface. This simplifies integration efforts and enhances interoperability within decentralized applications (DApps).", "Motivation": "The proposal aims to address the demand for assets combining the liquidity ofERC-20tokens and the uniqueness ofERC-721tokens. Current standards present a fragmentation, requiring users to choose between these features. This proposal fills that gap by providing a unified token interface, enabling smooth transitions betweenERC-20andERC-721characteristics to accommodate diverse blockchain applications.", "Specification": "Compliant contracts MUST implement the following Solidity interface:", "Rationale": "Common Interface for Different Token Types:", "Backwards Compatibility": "The proposed this proposal introduces a challenge in terms of backward compatibility due to the distinct balance query mechanisms utilized byERC-20andERC-721standards.ERC-20employsbalanceOfto check an account\u2019s token balance, whileERC-721usesbalanceOfto inquire about the quantity of tokens owned by an account. To reconcile these differences, the ERC must consider providing either two separate functions catering to each standard or adopting a more generalized approach.", "Compatibility Points": "The primary compatibility point lies in the discrepancy betweenERC-20\u2019s balanceOf andERC-721\u2019s balanceOf functionalities. Developers accustomed to the specific balance query methods in each standard may face challenges when transitioning to this proposal.", "Proposed Solutions": "Dual Balance Query Functions:", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7632, "url": "https://eips.ethereum.org/EIPS/eip-7632", "title": "Interfaces for Named Token", "authors": ["Zainan Victor Zhou\u00a0(", "@xinbenlv", ")"], "sections": {"ERC-7632: Interfaces for Named Token": "Extends tokens usinguint256 tokenIdto supporttokenNamein typestringand be able to convert backward totokenId.", "Enable tokens to have a string name and be able to convert between name and id.": "Extends tokens usinguint256 tokenIdto supporttokenNamein typestringand be able to convert backward totokenId.", "Abstract": "Extends tokens usinguint256 tokenIdto supporttokenNamein typestringand be able to convert backward totokenId.", "Motivation": "For Marketplaces, Explorers, Wallets, DeFi and dApps to better display and operate NFTs that comes with a name.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "This proposal is fully backwards compatible with token contracts usinguint256 tokenIdas the unique identifier.", "Backwards Compatibility": "This proposal is fully backwards compatible with token contracts usinguint256 tokenIdas the unique identifier.", "Security Considerations": "This proposal assume that bothtokenNameandtokenIdare\nunique amongst all tokens.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7634, "url": "https://eips.ethereum.org/EIPS/eip-7634", "title": "Limited Transfer Count NFT", "authors": ["Qin Wang\u00a0(", "@qinwang-git", ")", "Saber Yu\u00a0(", "@OniReimu", ")", "Shiping Chen\u00a0<", "shiping.chen@data61.csiro.au", ">"], "sections": {"ERC-7634: Limited Transfer Count NFT": "This standard extendsERC-721to introduce a mechanism that allows minters to customize the transferability of NFTs through a parameter calledTransferCount.TransferCountsets a limit on how many times an NFT can be transferred. The standard specifies an interface that includes functions for setting and retrieving transfer limits, tracking transfer counts, and defining pre- and post-transfer states. The standard enables finer control over NFT ownership and transfer rights, ensuring that NFTs can be programmed to have specific, enforceable transfer restrictions.", "An ERC-721 extension to limit transferability based on counts among NFTs": "This standard extendsERC-721to introduce a mechanism that allows minters to customize the transferability of NFTs through a parameter calledTransferCount.TransferCountsets a limit on how many times an NFT can be transferred. The standard specifies an interface that includes functions for setting and retrieving transfer limits, tracking transfer counts, and defining pre- and post-transfer states. The standard enables finer control over NFT ownership and transfer rights, ensuring that NFTs can be programmed to have specific, enforceable transfer restrictions.", "Abstract": "This standard extendsERC-721to introduce a mechanism that allows minters to customize the transferability of NFTs through a parameter calledTransferCount.TransferCountsets a limit on how many times an NFT can be transferred. The standard specifies an interface that includes functions for setting and retrieving transfer limits, tracking transfer counts, and defining pre- and post-transfer states. The standard enables finer control over NFT ownership and transfer rights, ensuring that NFTs can be programmed to have specific, enforceable transfer restrictions.", "Motivation": "Once NFTs are sold, they detach from their minters (creators) and can be perpetually transferred thereafter. Yet, many circumstances demand precise control over NFT issuance. We outline their advantages across three dimensions.", "Key Takeaways": "This standard provides several advantages:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "Yes and no. It is optional and quite depends on the actual requirements. The reference implementation given below is a recommended one if you opt for tracking. The_incrementTransferCountfunction and related retrieval functions (transferLimitOfandtransferCountOf) are designed to keep track of the number of transfers an NFT has undergone. This internal tracking mechanism is crucial for enforcing the minter\u2019s transfer limits, ensuring that no further transfers can occur once the limit is reached.", "Does tracking the internal transfer count matter?": "Yes and no. It is optional and quite depends on the actual requirements. The reference implementation given below is a recommended one if you opt for tracking. The_incrementTransferCountfunction and related retrieval functions (transferLimitOfandtransferCountOf) are designed to keep track of the number of transfers an NFT has undergone. This internal tracking mechanism is crucial for enforcing the minter\u2019s transfer limits, ensuring that no further transfers can occur once the limit is reached.", "If opting for tracking, is that all we may want to track?": "It is recommended to also track the before and after. The optional_beforeTokenTransferand_afterTokenTransferfunctions are overridden to define the state of the NFT before and after a transfer. These functions ensure that any necessary checks or updates are performed in line with the transfer limits and counts. By integrating these checks into the transfer process, the standard ensures that transfer limits are consistently enforced.", "Backwards Compatibility": "This standard can be fullyERC-721compatible by adding an extension function set.", "Extensions": "This standard can be enhanced with additional advanced functionalities alongside existing NFT protocols. For example:", "Reference Implementation": "A recommended implementation is demonstrated as follows:", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7638, "url": "https://eips.ethereum.org/EIPS/eip-7638", "title": "Batch Calls Encoding in SCA", "authors": ["George\u00a0(", "@JXRow", ")", "Zisu\u00a0(", "@lazy1523", ")"], "sections": {"ERC-7638: Batch Calls Encoding in SCA": "Batch Calls Encoding (BCE) outlines a solution for Smart Contract Account (SCA) wallets to consolidate multiple calls into a single call, encoding multiple parameters into bytes, compressing on-chain data, and saving gas. It can be used to implement atomic operations as well as non-atomic operations.", "Encode multiple calls for smart contract account (SCA) with atomic and saving gas": "Batch Calls Encoding (BCE) outlines a solution for Smart Contract Account (SCA) wallets to consolidate multiple calls into a single call, encoding multiple parameters into bytes, compressing on-chain data, and saving gas. It can be used to implement atomic operations as well as non-atomic operations.", "Abstract": "Batch Calls Encoding (BCE) outlines a solution for Smart Contract Account (SCA) wallets to consolidate multiple calls into a single call, encoding multiple parameters into bytes, compressing on-chain data, and saving gas. It can be used to implement atomic operations as well as non-atomic operations.", "Motivation": "Typically, interactions between users and contracts involve a series of coherent operations, such asapprove-transferFrom. While EOA wallets require users to confirm each operation sequentially, SCA wallets can confirm all operations with a single confirmation, completing all operations within a single call, thus achieving atomicity. Ifapprovesucceeds buttransferFromfails, it poses a security risk. The secure approach is to ensure that if one operation fails, all associated operations also fail, thereby ensuring atomicity. Therefore, we propose this encoding method to encode multiple parameters into bytes, compress on-chain data, and save gas. It can be used to implement both atomic and non-atomic operations.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "Each call encapsulates 3 parameters:to`value\\data. The conventional approach involves packaging these 3 parameters into a struct and then placing multiple structs into an array. However, using a struct adds overhead as it also packages the types ofto\\value\\data, increasing the size of the encoding. Sinceto\\value\\datahave fixed types, this additional encoding can be omitted. In Solidity, reading data frombytes calldata` using slice is a gas-efficient method. Considering these factors,Batch Calls Encodingcan compress on-chain data and save gas.", "Backwards Compatibility": "This ERC does not change the consensus layer, so there are no backwards compatibility issues for Ethereum as a whole.", "Reference Implementation": "This proposal only specifies the encoding ofBatch Calls, while the specific implementation and naming are left to the discretion of the project. Below is an example of an SCA contract utilizingBatch Calls(referred to asatomCallbytes), where the user atomically signs multiple operations, enabling the bundler to pay gas on behalf of the user:", "SmartWallet.sol": "This proposal introduces a data encoding scheme aimed at data compression. It solely concerns data compression and does not lead to data loss or concealment of private data.", "Bundler.sol": "This proposal introduces a data encoding scheme aimed at data compression. It solely concerns data compression and does not lead to data loss or concealment of private data.", "Security Considerations": "This proposal introduces a data encoding scheme aimed at data compression. It solely concerns data compression and does not lead to data loss or concealment of private data.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7641, "url": "https://eips.ethereum.org/EIPS/eip-7641", "title": "Intrinsic RevShare Token", "authors": ["Conway\u00a0(", "@0x1cc", ")", "Cathie So\u00a0(", "@socathie", ")", "Xiaohang Yu\u00a0(", "@xhyumiracle", ")", "Suning Yao\u00a0(", "@fewwwww", ")", "Kartin\u00a0<", "kartin@hyperoracle.io", ">"], "sections": {"ERC-7641: Intrinsic RevShare Token": "This proposal outlines an extension of the prevailingERC-20token standard, introducing a seamlessly integrated revenue-sharing mechanism. It incorporates a suite of interfaces designed to foster fair distribution of revenue among token holders while preserving the essential attributes ofERC-20. Central to this design is the establishment of a communal revenue pool, aggregating revenues from diverse sources. The token, in essence, embodies shares, affording holders the ability to burn their tokens and redeem a proportionate share from the revenue pool. This innovative burning mechanism guarantees that, when the revenue pool is non-empty, the token\u2019s value remains at least commensurate with the share of the revenue pool. Additionally, in periodic intervals, token holders can claim a portion of the reward, enriching their engagement and further enhancing the token\u2019s utility.", "An ERC-20 extension that integrates a revenue-sharing mechanism, ensuring tokens intrinsically represent a share of a communal revenue pool": "This proposal outlines an extension of the prevailingERC-20token standard, introducing a seamlessly integrated revenue-sharing mechanism. It incorporates a suite of interfaces designed to foster fair distribution of revenue among token holders while preserving the essential attributes ofERC-20. Central to this design is the establishment of a communal revenue pool, aggregating revenues from diverse sources. The token, in essence, embodies shares, affording holders the ability to burn their tokens and redeem a proportionate share from the revenue pool. This innovative burning mechanism guarantees that, when the revenue pool is non-empty, the token\u2019s value remains at least commensurate with the share of the revenue pool. Additionally, in periodic intervals, token holders can claim a portion of the reward, enriching their engagement and further enhancing the token\u2019s utility.", "Abstract": "This proposal outlines an extension of the prevailingERC-20token standard, introducing a seamlessly integrated revenue-sharing mechanism. It incorporates a suite of interfaces designed to foster fair distribution of revenue among token holders while preserving the essential attributes ofERC-20. Central to this design is the establishment of a communal revenue pool, aggregating revenues from diverse sources. The token, in essence, embodies shares, affording holders the ability to burn their tokens and redeem a proportionate share from the revenue pool. This innovative burning mechanism guarantees that, when the revenue pool is non-empty, the token\u2019s value remains at least commensurate with the share of the revenue pool. Additionally, in periodic intervals, token holders can claim a portion of the reward, enriching their engagement and further enhancing the token\u2019s utility.", "Motivation": "This proposal standardized an Intrinsic RevShare (revenue-sharing) model, allowing users to claim rewards periodically to ensure the efficiency of liquidity. This standard can inherently offer a clear path to long-term benefits for holders with revenue sharing, achieving a more sustainable token model by rewarding holders.", "Revenue Sharing for Token Holders": "This proposal standardized an Intrinsic RevShare (revenue-sharing) model, allowing users to claim rewards periodically to ensure the efficiency of liquidity. This standard can inherently offer a clear path to long-term benefits for holders with revenue sharing, achieving a more sustainable token model by rewarding holders.", "Funding for Any Project": "This standard enables the tokenizing of all kinds of projects with revenue. This EIP introduces a new model for incentivizing contributions to open-source projects. It proposes the distribution of Intrinsic RevShare tokens to active contributors, creating a tangible asset reflecting project involvement.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Optional Extension: AltRevToken": "TheAltRevToken extensionis OPTIONAL for this standard. This allows the contract to accept otherERC-20revenue tokens (more than ETH) into the revenue sharing pool.", "Rationale": "We implement a revenue sharing mechanism wherein any token holder can claim a proportional share from the revenue pool. To ensure regular and transparent revenue distribution, we have incorporated the snapshot method, capturing both the token balance and the associated claimable revenue token balance. Periodic invocation of the snapshot method, corresponding to distinct revenue-sharing processes, is required. During each snapshot, token holders are empowered to claim a proportionate share from the revenue pool, creating a systematic and equitable distribution mechanism for participants.", "Revenue Sharing Mechanism": "We implement a revenue sharing mechanism wherein any token holder can claim a proportional share from the revenue pool. To ensure regular and transparent revenue distribution, we have incorporated the snapshot method, capturing both the token balance and the associated claimable revenue token balance. Periodic invocation of the snapshot method, corresponding to distinct revenue-sharing processes, is required. During each snapshot, token holders are empowered to claim a proportionate share from the revenue pool, creating a systematic and equitable distribution mechanism for participants.", "snapshotinterface": "We specify asnapshotinterface to snapshot the token balance and the claimable revenue token balance. This functionality ensures correctness in tracking token holdings, facilitating a transparent record of each token portfolio. Regular invocation of the snapshot function is essential to maintain up-to-date records. Thesnapshotinterface returns a uniquesnapshotId, allowing access to the corresponding token balance and claimable revenue token balance associated with that specific snapshot. This systematic approach enhances the correctness and reliability of historical data retrieval, providing users with comprehensive insights into their token and revenue token balances at different points in time.", "claimableRevenueinterface": "We specify aclaimableRevenueinterface to calculate the amount of ETH claimable by a token holder at a certain snapshot. We will share the revenue between two consecutive snapshots. As an example in our reference implementation, assuming that the revenue between two snapshots isR, we specify a revenue sharing ratiop, ranging from 0%-100%, and we share the revenue ofpRto different token holders according to the token ratio. In this example, the amount of ETH claimable by a token holder withamounttokens at a certain snapshot ispR * amount / totalAmount, wheretotalAmountdenotes the total amount ofERC-7641token. Noted that the remaining revenue of(1-p)Rwill be retained in the revenue pool, and we can take out this part of revenue through burning.", "claiminterface": "We specify aclaiminterface for token holder to claim ETH based on the token balance at certain snapshot. Each token holder can only claim revenue at a certain snapshot once, ensuring a fair and transparent distribution mechanism.", "Burning Mechanism": "We implement a burning mechanism wherein any token holder can burn their tokens to redeem a proportional share from the revenue pool. This mechanism serves as a guarantee, ensuring that the value of the token is consistently greater than or equal to the share of the revenue pool, promoting a fair and balanced system.", "redeemableOnBurninterface": "We specifyredeemableOnBurninterface to calculate the amount of ETH redeemable by a token holder upon burn. It is defined as a view function to reduce gas cost. As an example in our reference implementation, the amount of ETH redeemable, i.e.,redeemableETHby a token holder withamountof token to burn is", "burninterface:": "We specifyburninterface for token holder to burn tokens and redeem the corresponding amount of revenue token. A token holder can burn at most all tokens it holds. This burning process leads to a reduction in the total token supply, establishing a deflationary economic model. Furthermore, it is important to note that tokens once burned are excluded from participating in any subsequent revenue sharing.", "Backwards Compatibility": "This standard is backward compatible with theERC-20as it extends the existing functionality with new interfaces.", "Test Cases": "The reference implementation includes sample implementations of the interfaces in this standard undercontracts/and corresponding unit tests undertest/.", "Reference Implementation": "The introduction of the burning mechanism in this standard signifies a shift towards a deflationary economic model, which introduces unique considerations regarding security. One prominent concern involves the potential impact on token liquidity and market dynamics. The continuous reduction in token supply through burning has the potential to affect liquidity levels, potentially leading to increased volatility and susceptibility to price manipulation. It is essential to conduct thorough stress testing and market simulations to assess the resilience of the system under various scenarios.", "Security Considerations": "The introduction of the burning mechanism in this standard signifies a shift towards a deflationary economic model, which introduces unique considerations regarding security. One prominent concern involves the potential impact on token liquidity and market dynamics. The continuous reduction in token supply through burning has the potential to affect liquidity levels, potentially leading to increased volatility and susceptibility to price manipulation. It is essential to conduct thorough stress testing and market simulations to assess the resilience of the system under various scenarios.", "Deflationary Economic Model": "The introduction of the burning mechanism in this standard signifies a shift towards a deflationary economic model, which introduces unique considerations regarding security. One prominent concern involves the potential impact on token liquidity and market dynamics. The continuous reduction in token supply through burning has the potential to affect liquidity levels, potentially leading to increased volatility and susceptibility to price manipulation. It is essential to conduct thorough stress testing and market simulations to assess the resilience of the system under various scenarios.", "Spam Revenue Tokens": "The extension of AltRevToken with the ability to set up different revenue tokens introduces specific security considerations, primarily centered around the prevention of adding numerous, potentially worthless tokens. The addition of too many spam (worthless) tokens may lead to an increase in gas fees associated with burning and claiming processes. This can result in inefficiencies and higher transaction costs for users, potentially discouraging participation in revenue-sharing activities.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7644, "url": "https://eips.ethereum.org/EIPS/eip-7644", "title": "ERC-721 Name Registry Extension", "authors": ["Chen Liaoyuan\u00a0(", "@chenly", ")"], "sections": {"ERC-7644: ERC-721 Name Registry Extension": "This extension defines an interface that adds a naming mechanism toERC-721tokens. It allows each token to have a unique name with a set expiration date, ensuring uniqueness within the current NFT contract. The interface includes functions for assigning, updating, and querying names and their associated tokens, ensuring that names remain unique until they expire. The entity responsible for setting names depends on the specific use case scenario when utilizing this extension.", "Extend a time-limited unique name to each token within ERC-721, utilizing the name registry for registration and management.": "This extension defines an interface that adds a naming mechanism toERC-721tokens. It allows each token to have a unique name with a set expiration date, ensuring uniqueness within the current NFT contract. The interface includes functions for assigning, updating, and querying names and their associated tokens, ensuring that names remain unique until they expire. The entity responsible for setting names depends on the specific use case scenario when utilizing this extension.", "Abstract": "This extension defines an interface that adds a naming mechanism toERC-721tokens. It allows each token to have a unique name with a set expiration date, ensuring uniqueness within the current NFT contract. The interface includes functions for assigning, updating, and querying names and their associated tokens, ensuring that names remain unique until they expire. The entity responsible for setting names depends on the specific use case scenario when utilizing this extension.", "Motivation": "As decentralized domain registration methods evolve with the integration of NFTs, we see an opportunity to extend this paradigm to the realm of usernames. By associating token IDs with usernames, we enhance the intuitive identification of entities within decentralized ecosystems.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "By implementing expiration periods for usernames, we introduce several advantages. This mechanism ensures a dynamic environment where unused or outdated usernames can be released, fostering a healthy ecosystem. It encourages turnover of usernames, preventing long-term hoarding and promoting active participation. Users are motivated to manage their username portfolio, renewing valuable names while relinquishing irrelevant ones. Ultimately, this fosters fairness and efficiency, ensuring naming resources are utilized effectively and refreshed to meet evolving needs.", "Backwards Compatibility": "This standard is fullyERC-721compatible.", "Reference Implementation": "The design includes mechanisms to prevent abusive behaviors and resource hoarding. Minimum intervals for name setting and maximum durations for name expiry are established to deter spam and malicious attacks, limit rapid consecutive name registrations, and encourage fair and efficient use of naming resources. These measures mitigate potential security risks, ensuring names cannot be monopolized indefinitely and promoting a sustainable and equitable environment for all users.", "Security Considerations": "The design includes mechanisms to prevent abusive behaviors and resource hoarding. Minimum intervals for name setting and maximum durations for name expiry are established to deter spam and malicious attacks, limit rapid consecutive name registrations, and encourage fair and efficient use of naming resources. These measures mitigate potential security risks, ensuring names cannot be monopolized indefinitely and promoting a sustainable and equitable environment for all users.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7649, "url": "https://eips.ethereum.org/EIPS/eip-7649", "title": "Bonding curve-embedded liquidity for NFTs", "authors": ["Arif Khan\u00a0<", "arif@alethea.ai", ">", "Ahmad Matyana\u00a0<", "ahmad@alethea.ai", ">", "Basil Gorin\u00a0(", "@vgorin", ")", "Vijay Bhayani\u00a0(", "@unblocktechie", ")"], "sections": {"ERC-7649: Bonding curve-embedded liquidity for NFTs": "This proposal introduces a standard for embedding Bonding Curve-like liquidity into\nNon-Fungible Tokens (NFTs) without modifying theERC-721standard.\nThe proposed standard allows the attachment of an embedded liquidity contract, referred to as Tradable Shares,\nto an ERC-721 NFT. Tradable Shares leverage a Bonding Curve-like approach to attract liquidity, enabling trading of\nshares based on the bonding curve price formula.", "Embedding liquidity into Non-Fungible Tokens (NFTs) without modifications to ERC-721.": "This proposal introduces a standard for embedding Bonding Curve-like liquidity into\nNon-Fungible Tokens (NFTs) without modifying theERC-721standard.\nThe proposed standard allows the attachment of an embedded liquidity contract, referred to as Tradable Shares,\nto an ERC-721 NFT. Tradable Shares leverage a Bonding Curve-like approach to attract liquidity, enabling trading of\nshares based on the bonding curve price formula.", "Abstract": "This proposal introduces a standard for embedding Bonding Curve-like liquidity into\nNon-Fungible Tokens (NFTs) without modifying theERC-721standard.\nThe proposed standard allows the attachment of an embedded liquidity contract, referred to as Tradable Shares,\nto an ERC-721 NFT. Tradable Shares leverage a Bonding Curve-like approach to attract liquidity, enabling trading of\nshares based on the bonding curve price formula.", "Motivation": "The ERC-721 standard lacks a specific mechanism for embedding bonding curve-based liquidity, limiting the creative\npossibilities for NFT-based projects. This EIP addresses the need for a standardized approach to integrate bonding curve\ncontracts seamlessly into ERC-721 NFTs, allowing for diverse and innovative implementations without modifying the\nERC-721 standard.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d,\n\u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "BondingCurveInterface": "The rationale behind the design choices for the embedded liquidity standard is deeply rooted in providing a robust and\nversatile framework for embedding Bonding Curve-like liquidity into NFTs. The following key considerations have\ninfluenced the technical decisions:", "Bonding Curve-Embedded Liquidity /TradeableSharesInterface": "The rationale behind the design choices for the embedded liquidity standard is deeply rooted in providing a robust and\nversatile framework for embedding Bonding Curve-like liquidity into NFTs. The following key considerations have\ninfluenced the technical decisions:", "Rationale": "The rationale behind the design choices for the embedded liquidity standard is deeply rooted in providing a robust and\nversatile framework for embedding Bonding Curve-like liquidity into NFTs. The following key considerations have\ninfluenced the technical decisions:", "Security Considerations": "This security considerations section reflects the importance of anticipating and addressing potential security\nchallenges in the implementation, ensuring its robustness, compatibility, and user-friendly nature.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7651, "url": "https://eips.ethereum.org/EIPS/eip-7651", "title": "Fractionally Represented Non-Fungible Token", "authors": ["Acme\u00a0(", "@0xacme", ")", "Calder\u00a0(", "@caldereth", ")"], "sections": {"ERC-7651: Fractionally Represented Non-Fungible Token": "This proposal introduces a standard for fractionally represented non-fungible tokens, allowing NFTs to be managed and owned fractionally within a single contract. This approach enables NFTs to coexist with an underlying fungible representation seamlessly, enhancing liquidity and access without dividing the NFT itself, or requiring an explicit conversion step. The standard includes mechanisms for both fractional and whole token transfers, approvals, and event emissions. This specification draws from design in bothERC-721andERC-20, but is not fully compatible with either standard.", "A specification for fractionally represented non-fungible tokens.": "This proposal introduces a standard for fractionally represented non-fungible tokens, allowing NFTs to be managed and owned fractionally within a single contract. This approach enables NFTs to coexist with an underlying fungible representation seamlessly, enhancing liquidity and access without dividing the NFT itself, or requiring an explicit conversion step. The standard includes mechanisms for both fractional and whole token transfers, approvals, and event emissions. This specification draws from design in bothERC-721andERC-20, but is not fully compatible with either standard.", "Abstract": "This proposal introduces a standard for fractionally represented non-fungible tokens, allowing NFTs to be managed and owned fractionally within a single contract. This approach enables NFTs to coexist with an underlying fungible representation seamlessly, enhancing liquidity and access without dividing the NFT itself, or requiring an explicit conversion step. The standard includes mechanisms for both fractional and whole token transfers, approvals, and event emissions. This specification draws from design in bothERC-721andERC-20, but is not fully compatible with either standard.", "Motivation": "Fractional ownership of NFTs has historically relied on external protocols that manage division and reconstitution of individual NFTs into fractional representations. The approach of dividing specific NFTs results in fragmented liquidity of the total token supply, as the fractional representations of two NFTs are not equivalent and therefore must be traded separately. Additionally, this approach requires locking of fractionalized NFTs, preventing free transfer until they are reconstituted.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Fractionally Represented Non-Fungible Token Interface": "AllERC-7651compliant contracts MUST implement the ERC-7651 andERC-165interfaces.", "Fractionally Represented Non-Fungible Token Metadata Interface": "This is a RECOMMENDED interface, identical in definition to theERC-721Metadata Interface. Rather than using this interface directly, a distinct metadata interface should be used here to avoid confusion surrounding ERC-721 inheritance. Given function definitions here are identical, it\u2019s important to note that the ERC-165interfaceIdwill be identical between metadata interfaces for this specification and that of ERC-721.", "Fractionally Represented Non-Fungible Token Banking Interface": "This is a RECOMMENDED interface that is intended to be used by implementations ofERC-7651that implement NFT ID reuse.", "Fractionally Represented Non-Fungible Token Transfer Exemptable Interface": "This is a RECOMMENDED interface that is intended to be used by implementations ofERC-7651that want to allow users to opt-out of NFT transfers.", "Rationale": "This standard unifies the representation of fractional ownership with the non-fungible token model, aligning closely withERC-721principles while enabling the functionality ofERC-20transfers. This dual compatibility aims to mitigate the integration complexity for existing protocols. Our goal is to implicitly support as high a degree of backwards compatibility with ERC-20 and ERC-721 standards as possible to reduce or negate integration lift for existing protocols. The core rationale for this fractional NFT standard centers on two main strategies: first, designing interfaces that clearly align with either ERC-721 or ERC-20 standards to avoid ambiguity; and second, detailing implementation approaches that distinctly separate the logic of overlapping functionalities.", "ID & Amount Isolation": "Ensuring clear differentiation between token IDs and fractional amounts is central to this design. This non-overlapping design principle means that no input should be ambiguously interpreted as both an ID and an amount. We won\u2019t dive into implementation guidelines, but implementations may achieve this through various means, such as validating ownership for ID inputs or reserving specific ranges for token IDs.", "Events": "Events inERC-721andERC-20specifications share conflicting signatures on approval and transfer, meaning an adherent hybrid of the two cannot be achieved.", "Transfers": "In a standardERC-7651transfer, value can be transferred by specifying either a fractional amount or a specific NFT ID.", "NFT Transfer Exemption": "Transferring fractional amounts means that a large number of NFTs can be moved in a single transaction, which can be costly in gas usage. We recommend an optional opt-in mechanism for exemption from NFT transfers that both EOAs and contracts can use to reduce the gas burden of transferring large token amounts when the NFT representation is not needed.", "NFT Banking": "As discussed in the Transfers section, when an address newly gains a full token in fractional terms, they are consequently owed an NFT. Similarly, when an address drops below a full token in fractional terms an NFT must be removed from their balance to stay in sync with their fractional balance.", "ERC-165 Interface": "We include theERC-165interface in specification both to adhere toERC-721design philosophy, and as a means of exposing interfaces at the contract level. We see this as a valuable, accepted standard to adhere to such that integrating applications may identify underlying specification.", "Metadata": "In-line withERC-721, we\u2019ve decided to isolate replicated metadata functionality through a separate interface. This interface includes traditional naming and token URI logic, though also introduces patterns surrounding token banking visibility, as outlined above in both the NFT Banking and Transfer Logic sections.", "Backwards Compatibility": "The fractional non-fungible token standard aims to be nearly backwards compatible with existingERC-721andERC-20standards, though makes no claim to fully adhere to either and has as such been proposed through a distinct interface.", "balanceOf": "ThebalanceOffunction as defined in bothERC-20andERC-721standards varies, in practice, to represent either fractional or whole token ownership respectively. Given fractional non-fungible tokens should adhere to an underlying fractional representation, it follows that this function should return a balance in that representation. This does, however, imply that fractional NFT contracts cannot fully adhere to thebalanceOfspecification provided by ERC-721.", "Success Return Values": "Thetransferandapprovefunctions both return a boolean value indicating success or failure. This is non-standard for theERC-721specification, though is standard forERC-20. Fractional non-fungible tokens adhere to a returned boolean value to meet minimum expectations for the ERC-20 standard, acknowledging that this deviates from a state of ideal backwards compatibility.", "Security Considerations": "This section is placeholder for further discussion surrounding the misidentification ofERC-7651as being either ERC-20 or ERC-721. Namely, discussion surrounding potential security implications of interface misinterpretation need to be thoroughly considered.", "Interface Misinterpretation": "This section is placeholder for further discussion surrounding the misidentification ofERC-7651as being either ERC-20 or ERC-721. Namely, discussion surrounding potential security implications of interface misinterpretation need to be thoroughly considered.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7652, "url": "https://eips.ethereum.org/EIPS/eip-7652", "title": "ERC-721 Guarantee Extension", "authors": ["Liu.C.Dao (@CDao)\u00a0<", "iunknow@163.com", ">", "Sam\u00a0<", "1047180870@qq.com", ">"], "sections": {"ERC-7652: ERC-721 Guarantee Extension": "This specification defines functions outlining a guarantor role for instance ofEIP-721. The guarantee interface implements the user-set valuation and guarantee share for a given NFT (token ID), as well as the guarantee rights enjoyed and obligations assumed during subsequent transactions. An implementation enables the user to read or set the current guarantee value for a given NFT (token ID), and also realizes the distribution of guarantee interest and the performance of guarantee obligations. It sends the standardized events when the status changes. This proposal relies on and extends the existingEIP-721.", "Allow NFT holders to exchange their NFTs for circulating tokens at any time": "This specification defines functions outlining a guarantor role for instance ofEIP-721. The guarantee interface implements the user-set valuation and guarantee share for a given NFT (token ID), as well as the guarantee rights enjoyed and obligations assumed during subsequent transactions. An implementation enables the user to read or set the current guarantee value for a given NFT (token ID), and also realizes the distribution of guarantee interest and the performance of guarantee obligations. It sends the standardized events when the status changes. This proposal relies on and extends the existingEIP-721.", "Abstract": "This specification defines functions outlining a guarantor role for instance ofEIP-721. The guarantee interface implements the user-set valuation and guarantee share for a given NFT (token ID), as well as the guarantee rights enjoyed and obligations assumed during subsequent transactions. An implementation enables the user to read or set the current guarantee value for a given NFT (token ID), and also realizes the distribution of guarantee interest and the performance of guarantee obligations. It sends the standardized events when the status changes. This proposal relies on and extends the existingEIP-721.", "Motivation": "NFT (token ID) commonly face the issue of insufficient market liquidity: the main reason being the lack of transparency in NFT pricing, making it difficult for users to cash out after trading and purchasing NFT (token ID).", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "Key factors influencing the standard:", "Backwards Compatibility": "This standard is compatible with current EIP-721 standards. There are no other standards that define a similar role for NFTs and the name (Guarantor) is not used by other EIP-721 related standards.", "Reference Implementation": "The reference implementation will be provided later.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7654, "url": "https://eips.ethereum.org/EIPS/eip-7654", "title": "Request Method Types", "authors": ["Rickey\u00a0(", "@HelloRickey", ")"], "sections": {"ERC-7654: Request Method Types": "This proposal standardizes a set of request and response communication standards between clients and smart contracts, using POST, GET, and PUT requests to create, read, and update the states of smart contracts. You can customize different request method names, request parameters and response values, and each request method will be mapped to a specific operation.", "Use a set of request methods to indicate the type of action to take on the contract.": "This proposal standardizes a set of request and response communication standards between clients and smart contracts, using POST, GET, and PUT requests to create, read, and update the states of smart contracts. You can customize different request method names, request parameters and response values, and each request method will be mapped to a specific operation.", "Abstract": "This proposal standardizes a set of request and response communication standards between clients and smart contracts, using POST, GET, and PUT requests to create, read, and update the states of smart contracts. You can customize different request method names, request parameters and response values, and each request method will be mapped to a specific operation.", "Motivation": "Since each contract has different functions, the client cannot use a standard to call different functions of different contracts. Contract Request Methods redefines the request method of the contract, so that different functions of multiple different contracts can be called using a consistent set of rules and protocols.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Interfaces": "The libraryTypes.solcontains an enumeration of Solidity types used in the above interfaces.", "Library": "The libraryTypes.solcontains an enumeration of Solidity types used in the above interfaces.", "Rationale": "In order to enable the client to operate the contract in a standardized and predictable way, three request method typesGET,POST, andPUTare set. The functions of each need to be defined in these three types to facilitate the contract caller to understand and process the information required for the request. However, there is noDELETEoperation type because deleting data in the contract is an inefficient operation. Developers can add aPUTrequest method by themselves to set the data to be valid and invalid, and only return valid data in theGETmethod.", "Type of request method": "In order to enable the client to operate the contract in a standardized and predictable way, three request method typesGET,POST, andPUTare set. The functions of each need to be defined in these three types to facilitate the contract caller to understand and process the information required for the request. However, there is noDELETEoperation type because deleting data in the contract is an inefficient operation. Developers can add aPUTrequest method by themselves to set the data to be valid and invalid, and only return valid data in theGETmethod.", "Request method parameter type": "Some functions are defined in each request method type. They all include request parameter data type and response parameter data type, which need to be set in theconstructorand then obtained according to the method name throughgetMethodReqAndRes. The data type of the parameter is defined by the enumeration of the data type. When processing the request parameter,abi.decodeis used to decode according to the request parameter type and the request value. When returning the response,abi.encodeis used to encode according to the response value and the response parameter type.", "Reference Implementation": "SeeRequest Method Types Example", "Security Considerations": "Contract request methods are divided into safe methods and unsafe methods. If the method request is a read-only operation and will not change the state of the contract, then the method is safe.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7662, "url": "https://eips.ethereum.org/EIPS/eip-7662", "title": "AI Agent NFTs", "authors": ["Greg Marlin\u00a0(", "@marleymarl", ")"], "sections": {"ERC-7662: AI Agent NFTs": "This proposal introduces a standard for AI agent NFTs. When AI Agents are created and traded as NFTs, it doesn\u2019t make sense to put the prompts in the token metadata, therefore it requires a standard custom struct. It also doesn\u2019t make sense to store the prompts directly onchain as they can be quite large, therefore this standard proposes they be stored as decentralized storage URLs. This standard also proposes two options on how this data should be made private to the owner of the NFT, with the favored implementation option being encrypting the data using custom contract parameters for decryption that decrypt only to the owner of the NFT.", "A specification for NFTs that represent AI Agents.": "This proposal introduces a standard for AI agent NFTs. When AI Agents are created and traded as NFTs, it doesn\u2019t make sense to put the prompts in the token metadata, therefore it requires a standard custom struct. It also doesn\u2019t make sense to store the prompts directly onchain as they can be quite large, therefore this standard proposes they be stored as decentralized storage URLs. This standard also proposes two options on how this data should be made private to the owner of the NFT, with the favored implementation option being encrypting the data using custom contract parameters for decryption that decrypt only to the owner of the NFT.", "Abstract": "This proposal introduces a standard for AI agent NFTs. When AI Agents are created and traded as NFTs, it doesn\u2019t make sense to put the prompts in the token metadata, therefore it requires a standard custom struct. It also doesn\u2019t make sense to store the prompts directly onchain as they can be quite large, therefore this standard proposes they be stored as decentralized storage URLs. This standard also proposes two options on how this data should be made private to the owner of the NFT, with the favored implementation option being encrypting the data using custom contract parameters for decryption that decrypt only to the owner of the NFT.", "Motivation": "The creation and trading of AI Agent NFTs are a natural fit and offer the potential for an entirely new onchain market. This requires some custom data to be embedded in the NFT through a custom struct and this needs to be standardized so that any marketplace or AI Agent management product, among others, know how to create and parse AI Agent NFTs.  The goal of this standard is to provide a new utility for NFTs in the field of AI and also to provide new liquidity, through the NFT market, for AI Agents. If widely adopted by marketplaces, and infrastructure and no-code providers this should open up a new market and community for AI Agent creators in different fields, AI Agent consumers and NFT marketplaces.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "This standard provides a unified way to create and parse AI Agent NFTs.", "Backwards Compatibility": "The AI Agents NFT standard introduces additional features and data to the standardERC-721protocol, aimed at addressing the practical requirements of using NFTs to store, trade and use AI Agents. It is designed to be fully backward-compatible with the originalERC-721standard.  All existingERC-721functions (such as transferFrom, approve, and balanceOf) retain their original functionality and interfaces. Our extension does not modify these core behaviors, ensuring that anyERC-721compliant wallet or service can interact with these tokens without modifications.", "Reference Implementation": "This is being currently implemented in a product for creating, managing and using AI Agents Onchain through a DApp interface. In this implementation, an encryption platform is being used to encrypt the prompts using custom EVMContractParameters that only decrypt for the holder of the NFT and using a decentralized storage network to store the URLs of this encrypted data. To facilitate that and make DApp handling easier, some parameters were added to Agent and the addEncryptedPrompts function is added that enables adding the encrypted prompt URIs after first minting the NFT (as the tokenId of the NFT is needed for setting the encryption/decryption conditions).", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7673, "url": "https://eips.ethereum.org/EIPS/eip-7673", "title": "Distinguishable base256emoji Addresses", "authors": ["William Morriss\u00a0(", "@wjmelements", ")"], "sections": {"ERC-7673: Distinguishable base256emoji Addresses": "Introduce base256emoji for use as the primary input and display for account addresses in all user interfaces.", "Depict Account Addresses As A String of Emoji": "Introduce base256emoji for use as the primary input and display for account addresses in all user interfaces.", "Abstract": "Introduce base256emoji for use as the primary input and display for account addresses in all user interfaces.", "Motivation": "Human users often fail to distinguish between long strings of hexadecimal characters, especially when they match at the beginning and at the end.\nThis makes hexadecimal strings a poor format for human-readable account addresses.\nThe problem is being exploited by several spoofing strategies that mine similar addresses and spoofERC-20Transfer events with the goal of tricking the end user into copying the wrong recipient address.\nThese address spoofing attacks have mislead tens of thousands of ether, and countless other tokens.\nSpoofers flooding the network with fake Transfer events waste network resources and complicate blockchain accounting.\nImproving the distinguishability of addresses will reduce the incentives for this behavior.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "base256emoji encoding table": "Previous attempts to reduce spoofing and other copy errors such asERC-55have not reduced the number of characters in an address.\nAny base-256 standard would achieve this goal but emoji were chosen to maximize human-distinguishability.\nMultiple base-256 emoji encodings have been proposed.\nThe base256emoji encoding was chosen due to its acceptance into the multibase repository.", "Rationale": "Previous attempts to reduce spoofing and other copy errors such asERC-55have not reduced the number of characters in an address.\nAny base-256 standard would achieve this goal but emoji were chosen to maximize human-distinguishability.\nMultiple base-256 emoji encodings have been proposed.\nThe base256emoji encoding was chosen due to its acceptance into the multibase repository.", "Backwards Compatibility": "Using the encoding table, the base256emoji encoding can be transcoded into hexadecimal and vice-versa.", "Test Cases": "| base256emoji | ERC-55 |\n|:-:|:-:|\n|\ud83d\ude80\ud83d\ude80\ud83d\ude80\ud83d\ude80\ud83d\ude80\ud83d\ude80\ud83d\ude00\ud83d\udc93\ud83e\udd74\ud83d\udca3\ud83d\udc7b\ud83d\ude4c\ud83d\ude48\ud83e\udd22\ud83d\ude25\u2639\ud83c\udf0f\ud83d\udca9\ud83c\udf4e\ud83d\udc95|0x0000000000004946c0e9F43F4Dee607b0eF1fA1c|\n|\ud83d\ude80\ud83d\ude80\ud83d\ude80\ud83d\ude80\ud83d\ude80\ud83d\ude80\ud83d\udcb8\ud83c\udf8a\ud83d\udca1\ud83c\udf3f\ud83d\udea9\ud83d\udd25\ud83d\udccc\ud83d\ude42\ud83d\udc99\u2744\ud83d\udef0\ud83d\udca9\ud83e\udd1d\u2b50|0x000000000000c57CF0A1f923d44527e703F1ad70|\n|\u2600\u2600\u2600\u2600\u2600\u2764\ud83c\udf0a\ud83c\udf16\u274c\ud83d\udc80\u2714\ud83c\udf0e\ud83c\udf88\u274c\ud83d\udc9e\ud83d\udef0\ud83d\udc97\ud83d\ude05\u2753\u2604|0x111111111117dC0aa78b770fA6A738034120C302|\n|\ud83d\udc4d\ud83e\udd2b\ud83d\ude0b\u270a\ud83e\udd2a\ud83d\ude1e\ud83e\udd10\ud83d\udc76\ud83d\ude2d\u2764\ud83d\udc49\ud83d\udea9\ud83d\udc94\ud83c\udf31\ud83e\udd1d\ud83c\udf0a\ud83d\udc9a\ud83e\ude90\ud83d\udea9\ud83d\ude10|0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984|\n|\ud83d\ude06\ud83c\udf0e\u2705\u2728\ud83d\udc4b\ud83d\ude1c\ud83d\udc9b\u263a\ud83d\ude36\ud83d\udc4b\ud83d\udc38\ud83e\udd29\ud83c\udf14\ud83d\ude4c\u270b\ud83e\udd24\u2b50\ud83c\udf51\u2639\u26a1|0x2a0f713aA953442EacA9EA47083f656170e67BA4|\n|\ud83d\udd25\ud83e\udd2c\ud83c\udf14\ud83d\ude1d\ud83d\ude1e\ud83d\ude44\ud83d\udc4c\ud83d\udca2\ud83d\udde3\ud83c\udf0d\u2728\ud83d\ude19\ud83d\udc3e\ud83d\ude21\ud83d\ude11\ud83e\udd18\ud83d\udcb8\ud83d\ude02\ud83d\ude24\ud83d\udd35|0x23B608675a2B2fB1890d3ABBd85c5775c51691d5|\n|\ud83d\udde3\ud83d\ude05\ud83d\ude1e\u2728\ud83e\udd37\ud83d\ude06\ud83c\udf1f\ud83d\udc37\ud83c\udf37\ud83d\udc76\u261d\ud83e\ude90\ud83e\udd40\ud83d\udda5\ud83e\udd1f\ud83d\udc09\ud83d\udc80\ud83d\udcaa\ud83d\ude0f\u2744|0x89205A3A3b2A69De6Dbf7f01ED13B2108B2c43e7|\n|\ud83e\udd74\ud83d\ude06\ud83d\ude30\u270c\ud83e\udd1f\ud83d\udd25\ud83d\udce3\ud83c\udfb5\ud83c\udf16\ud83c\udf0f\ud83d\ude21\ud83c\udfb6\ud83d\udc99\ud83d\udc38\ud83c\udf52\ud83c\udf14\ud83d\ude31\ud83e\udd18\ud83c\udf40\u27a1|0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2|\n|\u25b6\ud83c\udf3b\ud83d\ude25\ud83d\udc4f\ud83d\udc98\ud83d\ude1b\ud83d\udc90\ud83d\udca8\u2744\ud83d\udcb8\ud83d\ude02\ud83d\ude2a\ud83d\ude1d\ud83e\udd24\ud83d\udc38\ud83d\udcbb\ud83d\ude1f\u261d\ud83c\udf43\ud83e\udd7a|0xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D72|", "Reference Implementation": "With the base256emoji encoding, addresses use half as many characters.\nThe characters used are more distinguishable.\nThis squares the difficulty of generating similar addresses, making address spoofing impractical.", "Security Considerations": "With the base256emoji encoding, addresses use half as many characters.\nThe characters used are more distinguishable.\nThis squares the difficulty of generating similar addresses, making address spoofing impractical.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7674, "url": "https://eips.ethereum.org/EIPS/eip-7674", "title": "Temporary Approval Extension for ERC-20", "authors": ["Xenia Shape\u00a0(", "@byshape", ")", "Mikhail Melnik\u00a0(", "@ZumZoom", ")", "Hadrien Croubois\u00a0(", "@Amxx", ")"], "sections": {"ERC-7674: Temporary Approval Extension for ERC-20": "This specification defines the minimum interface required to temporarily approveERC-20tokens for spending within the same transaction.", "Ephemeral ERC-20 approvals lasting a single transaction": "This specification defines the minimum interface required to temporarily approveERC-20tokens for spending within the same transaction.", "Abstract": "This specification defines the minimum interface required to temporarily approveERC-20tokens for spending within the same transaction.", "Motivation": "User are often required to set a token approval that will only be used once. It is common to leave unexpected approvals after these interactions.EIP-1153introducesTSTORE, which can be used to efficiently handle temporarily allowances.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "It was decided to make minimal interface extension to allow easier integration of a compliant contract into the existing infrastructure. This affects the backward compatibility of theallowancefunction. However, the required changes to thetransferFromfunction implementation satisfy the requirement to explicitly authorize the spender to transfer tokens.", "Backwards Compatibility": "All functionality of theERC-20standard is backward compatible except for theallowancefunction.", "Reference Implementation": "The storage for the temporary allowances MUST be different to that of the regular allowance. Compliant contracts MAY use the transient storageEIP-1153to keep the temporary allowance. For eachownerandspender, the slot MUST be uniquely selected to avoid slot collision. Each slot index SHOULD be derived from the base slot index for temporary allowances,ownerandspenderaddresses. Slot MAY be derived askeccak256(spender . keccak256(owner . p))where.is concatenation andpiskeccak256from the string uniquely defining temporary allowances in the namespace of the implementing contract.", "Using Transient Storage": "The storage for the temporary allowances MUST be different to that of the regular allowance. Compliant contracts MAY use the transient storageEIP-1153to keep the temporary allowance. For eachownerandspender, the slot MUST be uniquely selected to avoid slot collision. Each slot index SHOULD be derived from the base slot index for temporary allowances,ownerandspenderaddresses. Slot MAY be derived askeccak256(spender . keccak256(owner . p))where.is concatenation andpiskeccak256from the string uniquely defining temporary allowances in the namespace of the implementing contract.", "Events": "Even though no event is required when setting a temporary allowance, compliant contracts MAY emitTransientApproval(address indexed owner, address indexed spender, uint256 value)event.", "Security Considerations": "The method of deriving slot identifiers to store temporary allowances must avoid collision with other slots in the same space (e.g. transient storage).", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7679, "url": "https://eips.ethereum.org/EIPS/eip-7679", "title": "UserOperation Builder", "authors": ["Derek Chiang\u00a0(", "@derekchiang", ")", "Garvit Khatri\u00a0(", "@plusminushalf", ")", "Fil Makarov\u00a0(", "@filmakarov", ")", "Kristof Gazso\u00a0(", "@kristofgazso", ")", "Derek Rein\u00a0(", "@arein", ")", "Tomas Rocchi\u00a0(", "@tomiir", ")", "bumblefudge\u00a0(", "@bumblefudge", ")"], "sections": {"ERC-7679: UserOperation Builder": "DifferentERC-4337smart account implementations encode their signature, nonce, and calldata differently.  This makes it difficult for DApps, wallets, and smart account toolings to integrate with smart accounts without integrating with account-specific SDKs, which introduces vendor lock-in and hurts smart account adoption.", "Construct UserOperations without being coupled with account-specific logic.": "DifferentERC-4337smart account implementations encode their signature, nonce, and calldata differently.  This makes it difficult for DApps, wallets, and smart account toolings to integrate with smart accounts without integrating with account-specific SDKs, which introduces vendor lock-in and hurts smart account adoption.", "Abstract": "DifferentERC-4337smart account implementations encode their signature, nonce, and calldata differently.  This makes it difficult for DApps, wallets, and smart account toolings to integrate with smart accounts without integrating with account-specific SDKs, which introduces vendor lock-in and hurts smart account adoption.", "Motivation": "At the moment, to build aERC-4337UserOperation (UserOp for short) for a smart account requires detailed knowledge of how the smart account implementation works, since each implementation is free to encode its nonce, calldata, and signature differently.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "UserOp builder": "To conform to this standard, a smart account implementation MUST provide a \u201cUserOp builder\u201d contract that implements theIUserOperationBuilderinterface, as defined below:", "Using the UserOp builder": "To build a UserOp using the UserOp builder, the building party SHOULD proceed as follows:", "Using the UserOp builder when the account hasn\u2019t been deployed": "To provide the accurate data to the building party, theUserOpBuilderwill in most cases have to call the account.\nIf the account has yet to be deployed, which means that the building party is looking to send the very first UserOp for this account, then the building party MAY modify the flow above as follows:", "Rationale": "Thecontextis an array of bytes that encodes whatever data the UserOp builder needs in order to correctly determine the nonce, calldata, and signature.  Presumably, thecontextis constructed by the account owner, with the help of a wallet software.", "Context": "Thecontextis an array of bytes that encodes whatever data the UserOp builder needs in order to correctly determine the nonce, calldata, and signature.  Presumably, thecontextis constructed by the account owner, with the help of a wallet software.", "Dummy signature": "The \u201cdummy signature\u201d refers to the signature used in a UserOp sent to a bundler for estimating gas (viaeth_estimateUserOperationGas).  A dummy signature is needed because, at the time the bundler estimates gas, a valid signature does not exist yet, since the valid signature itself depends on the gas values of the UserOp, creating a circular dependency.  To break the circular dependency, a dummy signature is used.", "Backwards Compatibility": "This ERC is intended to be backwards compatible with all ERC-4337 smart accounts as of EntryPoint 0.7.", "Reference Implementation": "The counterfactual call contract is inspired byERC-6492, which devised a mechanism to executeisValidSignature(seeERC-1271) against a pre-deployed (counterfactual) contract.", "Counterfactual call contract": "The counterfactual call contract is inspired byERC-6492, which devised a mechanism to executeisValidSignature(seeERC-1271) against a pre-deployed (counterfactual) contract.", "Security Considerations": "Since the properly formatted dummy signature is going to be publicly disclosed, in theory it can be intercepted and used by the man in the middle. Risks and potential harm of this is very low though as the dummy signature will be effectively unusable after the final UserOp is submitted (as both UserOps use the same nonce). However, to mitigate even this small issue, it is recommended that the UserOp which hash is going to be signed to obtain an un-foirmatted dummy signature (step 3 above) is filled with very low gas values.", "Dummy Signature security": "Since the properly formatted dummy signature is going to be publicly disclosed, in theory it can be intercepted and used by the man in the middle. Risks and potential harm of this is very low though as the dummy signature will be effectively unusable after the final UserOp is submitted (as both UserOps use the same nonce). However, to mitigate even this small issue, it is recommended that the UserOp which hash is going to be signed to obtain an un-foirmatted dummy signature (step 3 above) is filled with very low gas values.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7681, "url": "https://eips.ethereum.org/EIPS/eip-7681", "title": "Dual Nature Multi Token Protocol", "authors": ["Sennett Lau\u00a0(", "@sennett-lau", ")"], "sections": {"ERC-7681: Dual Nature Multi Token Protocol": "This proposalERC-7681delineates the integration of the fungibleERC-20token contract with the semi-fungibleERC-1155multi-token standard, enabling cohesive operations between both standards within a single contract framework. It defines a mechanism for combining two token contracts and synchronizing operations between them.", "Combining fungible token ERC-20 and multi-token ERC-1155": "This proposalERC-7681delineates the integration of the fungibleERC-20token contract with the semi-fungibleERC-1155multi-token standard, enabling cohesive operations between both standards within a single contract framework. It defines a mechanism for combining two token contracts and synchronizing operations between them.", "Abstract": "This proposalERC-7681delineates the integration of the fungibleERC-20token contract with the semi-fungibleERC-1155multi-token standard, enabling cohesive operations between both standards within a single contract framework. It defines a mechanism for combining two token contracts and synchronizing operations between them.", "Motivation": "Inspired byERC-7631Dual Nature Token Pair, which introduced a concept of interlinkable tokens between ERC-20 andERC-721, a challenge arises due to the duplicatedTransfer(address, address, uint256)event, making full compatibility challenging. However, combining ERC-20 and ERC-1155 offers similar benefits of non-fungible token (NFT) fractionalization natively. Here, acquiring ERC-20 tokens could automatically issue ERC-1155 tokens proportionally to the ERC-20 holdings, achieving full compliance with both standards.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Overview": "EveryERC-7681MUST implement bothERC20andERC1155interfaces.", "ERC-7681 Interface": "The ERC-20 contract MUST implement the following interface.", "ERC-7681 Skippable Interface": "The ERC-7681 contract MAY implement the following interface.", "Rationale": "This proposal intentionally does not prescribe specific token synchronization logic to allow for diverse implementation strategies and novel use cases, such as one-to-one synchronization or fractionalization of ERC-1155 tokens based on ERC-20 holdings. Developers are afforded the flexibility to determine their synchronization approach, provided it remains fully compliant with the specifications of both token standards.", "Implementation Flexibility": "This proposal intentionally does not prescribe specific token synchronization logic to allow for diverse implementation strategies and novel use cases, such as one-to-one synchronization or fractionalization of ERC-1155 tokens based on ERC-20 holdings. Developers are afforded the flexibility to determine their synchronization approach, provided it remains fully compliant with the specifications of both token standards.", "ERC-1155 Token Skipping": "For instances where theowneris a smart contract, setting the skip status totrueby default can prevent unnecessary ERC-1155 minting for interactions with contracts like DEXs and lending protocols, thereby potentially reducing gas costs.", "Backwards Compatibility": "This proposal is fully backward-compatible with the existing ERC-20 and ERC-1155 standards, ensuring that contracts reliant on these standards will continue to function seamlessly.", "Security Considerations": "When user transfers ERC-20 tokens, it can trigger the automatic minting, transfer, or burning of various ERC-1155 tokens. This process can lead to gas expenses that grow linearly with the number of actions O(n) rather than the fixed cost O(1) usually seen with ERC-20 token transactions. Additionally, the mechanism for choosing ERC-1155 token IDs might increase gas expenses further. Therefore, any synchronization strategy needs to account for the potential rise in ERC-1155 associated gas costs to avoid running out of gas, which could result in denial of service situations.", "Out-of-gas Denial of Service": "When user transfers ERC-20 tokens, it can trigger the automatic minting, transfer, or burning of various ERC-1155 tokens. This process can lead to gas expenses that grow linearly with the number of actions O(n) rather than the fixed cost O(1) usually seen with ERC-20 token transactions. Additionally, the mechanism for choosing ERC-1155 token IDs might increase gas expenses further. Therefore, any synchronization strategy needs to account for the potential rise in ERC-1155 associated gas costs to avoid running out of gas, which could result in denial of service situations.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7682, "url": "https://eips.ethereum.org/EIPS/eip-7682", "title": "Auxiliary Funds Capability", "authors": ["Lukas Rosario\u00a0(", "@lukasrosario", ")", "Wilson Cusack\u00a0(", "@wilsoncusack", ")"], "sections": {"ERC-7682: Auxiliary Funds Capability": "AnEIP-5792compliant capability that allows wallets to indicate to apps that they have access to funds beyond those that can be accounted for by looking up balances onchain given the wallet\u2019s address.", "A capability allowing wallets to indicate that they have access to additional funds.": "AnEIP-5792compliant capability that allows wallets to indicate to apps that they have access to funds beyond those that can be accounted for by looking up balances onchain given the wallet\u2019s address.", "Abstract": "AnEIP-5792compliant capability that allows wallets to indicate to apps that they have access to funds beyond those that can be accounted for by looking up balances onchain given the wallet\u2019s address.", "Motivation": "Many applications check users\u2019 balances before letting them complete some action. For example, if a user wants to swap some amount of tokens on a dex, the dex will commonly block the user from doing so if it sees that the user does not have that amount of tokens at their address. However, more advanced wallets have features that let users access funds from other sources. Wallets need a way to tell apps that they have access to additional funds so that users using these more advanced wallets are not blocked by balance checks.", "Specification": "One newEIP-5792wallet capability is defined.", "Wallet Implementation": "To conform to this specification, wallets that wish to indicate that they have access to auxiliary funds MUST, for each chain they have access to auxiliary funds on, respond towallet_getCapabilitiescalls with anauxiliaryFundsobject with asupportedfield set totrue.", "App Implementation": "When an app sees that a connected wallet has access to auxiliary funds via theauxiliaryFundscapability in awallet_getCapabilitiesresponse, the app SHOULD NOT block users from taking actions on the basis of asset balance checks.", "Rationale": "An alternative we considered is defining a way for apps to fetch available auxiliary balances. This could be done, for example, by providing a URL as part of theauxiliaryFundscapability that apps could use to fetch auxiliary balance information. However, we ultimately decided that a boolean was enough to indicate to apps that they should not block user actions on the basis of balance checks, and it is minimally burdensome for apps to implement.", "Alternatives": "An alternative we considered is defining a way for apps to fetch available auxiliary balances. This could be done, for example, by providing a URL as part of theauxiliaryFundscapability that apps could use to fetch auxiliary balance information. However, we ultimately decided that a boolean was enough to indicate to apps that they should not block user actions on the basis of balance checks, and it is minimally burdensome for apps to implement.", "Security Considerations": "Apps MUST NOT make any assumptions about the source of auxiliary funds. Apps\u2019 smart contracts should still, as they would today, make appropriate balance checks onchain when processing a transaction.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7683, "url": "https://eips.ethereum.org/EIPS/eip-7683", "title": "Cross Chain Intents", "authors": ["Mark Toda\u00a0(", "@marktoda", ")", "Matt Rice\u00a0(", "@mrice32", ")", "Nick Pai\u00a0(", "@nicholaspai", ")"], "sections": {"ERC-7683: Cross Chain Intents": "The following standard allows for the implementation of a standard API for cross-chain value-transfer systems. This standard provides generic order structs, as well as a standard set of settlement smart contract interfaces.", "An interface for cross-chain trade execution systems.": "The following standard allows for the implementation of a standard API for cross-chain value-transfer systems. This standard provides generic order structs, as well as a standard set of settlement smart contract interfaces.", "Abstract": "The following standard allows for the implementation of a standard API for cross-chain value-transfer systems. This standard provides generic order structs, as well as a standard set of settlement smart contract interfaces.", "Motivation": "Intent-based systems have become the preeminent solution for end-user cross-chain interaction by abstracting away the complexity and time constraints of traditional bridges. One of the key difficulties for cross-chain intents systems is accessing sufficient liquidity and a network of active fillers across chains. This challenge may be exacerbated as the number of distinct chains increases over time. The end result of this is a poor experience for users including higher costs, longer wait times and higher failure rates than necessary.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Glossary of Terms": "A compliant cross-chain order type MUST be ABI decodable into eitherGaslessCrossChainOrderorOnchainCrossChainOrdertype.", "Order structs": "A compliant cross-chain order type MUST be ABI decodable into eitherGaslessCrossChainOrderorOnchainCrossChainOrdertype.", "ResolvedCrossChainOrder struct": "A compliant cross-chain order type MUST be convertible into theResolvedCrossChainOrderstruct. This means that theorderDatamust be decoded into the information needed to populate theResolvedCrossChainOrderstruct. Additionally,orderDataSHOULD be decodable into a sub-type, which can be used for further functionality such as cross-chain calldata execution (see the examples section for an example of this). It is the responsibility of theuserand thefillerto ensure that theoriginSettlersupports their order\u2019s contained sub-type.", "Open event": "A compliantOpenevent MUST adhere to the following abi:", "Settlement interfaces": "A compliant origin settler contract implementation MUST implement theIOriginSettlerinterface:", "fillerData": "Cross-chain execution systems implementing this standard SHOULD use a sub-type that can be parsed from the arbitraryfillerDatafield. This may include information such as the desired timing or form of payment for the filler", "Rationale": "A key consideration is to ensure that a broad range of cross-chain intent designs can work within the same standard. To enable this, the specification is designed around a cross-chain intentsflow, with two variations: gasless and onchain.", "Generic OrderData": "A key consideration is to ensure that a broad range of cross-chain intent designs can work within the same standard. To enable this, the specification is designed around a cross-chain intentsflow, with two variations: gasless and onchain.", "Emission of Fill Instructions": "An important component of the standard is creating a flexible and robust mechanism for fillers to ensure their fills are valid. For a fill to be valid,\nit typically must satisfy the following constraints:", "Cross-compatibility": "Since this standard is intended to reduce friction for users moving value across chains, non-EVM ecosystems should not be excluded. However, attempting\nto pull each non-EVM ecosystem in would dramatically increase the size and complexity of this standard, while omitting any that come in the future.", "Usage of Permit2": "Permit2 is not specifically required by this standard, but does provide an efficient and straightforward approach to building standard-adherent protocols. Specifically, thewitnessfunctions of permit2 allow users to both approve the token transferandthe order itself with a single signature. This also nicely couples the transfer of tokens with a successful initiation of the order.", "Examples": "This is an example of how a 7683 cross-chain value transfer order can include instructions to the filler to execute arbitrary calldata on behalf of the recipient on the destination chain. This calldata execution is performed by the settlement contract atomically within the filler\u2019s fill() execution, so the arbitrary contract execution can take advantage of the destination chain recipient\u2019s newly transferred value. A hypothetical user in this example would select anoriginSettlerthat is known to support theMessagesub-type.", "Security Considerations": "This ERC is agnostic of how the settlement system validates a 7683 order fulfillment and refunds the filler. In fact, this ERC is designed to delegate the responsibility of evaluating the settlement contract\u2019s security to the filler and the application that creates the user\u2019s 7683 order.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7694, "url": "https://eips.ethereum.org/EIPS/eip-7694", "title": "Solana Storage Router", "authors": ["Avneet Singh\u00a0(", "@sshmatrix", ")", "0xc0de4c0ffee\u00a0(", "@0xc0de4c0ffee", ")"], "sections": {"ERC-7694: Solana Storage Router": "The following standard is an extension to the cross-chain storage router protocol introducing the storage router for Solana blockchain. With this specification, any Ethereum L1 contract can defer a call to Solana blockchain as part of its core functionality, provided that the client is equipped to handle Solana transactions. It was previously possible to defer write and storage operations to other Ethereum L1 contracts, L2 contracts and off-chain databases, and this document extends that functionality to include alternative L1 chains. The data stored on Solana must be translated toEIP-3668-compliant format by an appropriate HTTP gateway where it can be retrieved by generic Ethereum contracts. This standard allows Ethereum to utilise a broader range of cross-chain blockspaces.", "Cross-chain storage router protocol incorporating storage router for Solana": "The following standard is an extension to the cross-chain storage router protocol introducing the storage router for Solana blockchain. With this specification, any Ethereum L1 contract can defer a call to Solana blockchain as part of its core functionality, provided that the client is equipped to handle Solana transactions. It was previously possible to defer write and storage operations to other Ethereum L1 contracts, L2 contracts and off-chain databases, and this document extends that functionality to include alternative L1 chains. The data stored on Solana must be translated toEIP-3668-compliant format by an appropriate HTTP gateway where it can be retrieved by generic Ethereum contracts. This standard allows Ethereum to utilise a broader range of cross-chain blockspaces.", "Abstract": "The following standard is an extension to the cross-chain storage router protocol introducing the storage router for Solana blockchain. With this specification, any Ethereum L1 contract can defer a call to Solana blockchain as part of its core functionality, provided that the client is equipped to handle Solana transactions. It was previously possible to defer write and storage operations to other Ethereum L1 contracts, L2 contracts and off-chain databases, and this document extends that functionality to include alternative L1 chains. The data stored on Solana must be translated toEIP-3668-compliant format by an appropriate HTTP gateway where it can be retrieved by generic Ethereum contracts. This standard allows Ethereum to utilise a broader range of cross-chain blockspaces.", "Motivation": "Cross-Chain Storage Router Protocol (CCIP-Store) introduced inEIP-7700, describes three external routers for routing storage to L1 contracts, L2s and databases. This document extends that specification by introducing a fourth storage router targeting Solana as the storage provider.", "Specification": "A Solana storage routerStorageRoutedToSolana()requires the hex-encodedprogramIdand the manageraccounton the Solana blockchain.programIdis equivalent to a contract address on Solana whileaccountis the manager wallet on Solana handling storage on behalf ofmsg.sender.", "Rationale": "StorageRoutedToSolana()works in a similar fashion toStorageRoutedToL2()in CCIP-Store in the sense that the client needs to be pointed to a certain contract on another chain by the revert event. Other than that, the only technical difference is casting between EVM and SVM data types.", "Backwards Compatibility": "None.", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7695, "url": "https://eips.ethereum.org/EIPS/eip-7695", "title": "Ownership Delegation and Context for ERC-721", "authors": ["Duc Tho Tran\u00a0(", "@ducthotran2010", ")"], "sections": {"ERC-7695: Ownership Delegation and Context for ERC-721": "This standard is an extension forERC-721, designed to specify users for various contexts with a locking feature and allow temporary ownership delegation without changing the original owner.", "Introduces contexts and ownership delegation for ERC-721 tokens, expanding dApps and financial use cases without transferring ownership": "This standard is an extension forERC-721, designed to specify users for various contexts with a locking feature and allow temporary ownership delegation without changing the original owner.", "Abstract": "This standard is an extension forERC-721, designed to specify users for various contexts with a locking feature and allow temporary ownership delegation without changing the original owner.", "Motivation": "For standardERC-721NFTs, there are several use cases in financial applications, including:", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Definitions": "This specification encompasses the following components:", "Roles": "Smart contracts implementing this standard MUST implement all the functions in theIERC7695interface.", "Interface": "Smart contracts implementing this standard MUST implement all the functions in theIERC7695interface.", "Ownership Delegation Rules": "startDelegateOwnership rules", "Token (Un)lock Rules": "To be more explicit about how token (un)locked, these functions:", "Additional Transfer Rules": "In addition to extending fromERC-721for the transfer mechanism when transferring an NFT, the implementation:", "Rationale": "When designing the proposal, we considered the following concerns.", "Multiple contexts for multiple use cases": "This proposal is centered around Token Context to allow for the creation of distinct contexts tailored to various decentralized applications (dApps). The context controller assumes the role of facilitating (rental or delegation) dApps, by enabling the granting of usage rights to another user without modifying the NFT\u2019s owner record. Besides, this proposal provides the lock feature for contexts to ensure trustlessness in performing these dApps, especially staking cases.", "Providing an unlock mechanism for owners": "By providing an unlock mechanism for owners, this approach allows owners to unlock their tokens independently, without relying on the context controller to initiate the process. This prevents scenarios where, should the controller lose control, owners would be unable to unlock their tokens.", "Attachment and detachment callbacks": "The callback results of theonDetachRequestedandonExecDetachContextfunctions in theToken (Un)lock Rulesare skipped because we are intentionally removing the controller\u2019s ability to stop detachment, ensuring token detachment is independent of the controller\u2019s actions.", "Ownership delegation": "This feature provides a new approach by separating the owner and ownership. Primarily designed to facilitate delegating for third parties, it enables delegating another account as the manager of ownership, distinct from the owner.", "Transfer method mechanism": "As part of the integration with the transfer method, we extended its implicit behavior to include token approval:", "Backwards Compatibility": "This proposal is backward compatible withERC-721.", "Security Considerations": "When developing this token standard to serve multiple contexts:", "Detaching duration": "When developing this token standard to serve multiple contexts:", "Duplicated token usage": "When initiating a new context, the context controllers should track all other contexts within the NFT contract to prevent duplicated usage.", "Ownership Delegation Buffer Time": "When constructing systems that rely on ownership delegation for product development, it is imperative to incorporate a buffer time (of at leastmaxDetachingDurationseconds) when requesting ownership delegation. This precaution is essential to mitigate the risk of potential abuse, particularly if one of the associated contexts locks the token until the delegation time expires.\nFor example, consider a scenario where a mortgage contract is built atop this standard, which has a maximum detaching duration of 7 days, while the required delegation period is only 3 days. In such cases, without an adequate buffer time, the owner could exploit the system by withdrawing funds and invoking the relevant context to lock the token, thus preventing its unlock and transfer.", "Validating Callback Callers": "To enhance security and integrity in interactions between contracts, it is essential to validate the caller of any callback function while implementing theIERC7695ContextCallback. This validation ensures that themsg.senderof the callback is indeed the expected contract address, typically the token contract or a designated controller contract. Such checks are crucial for preventing unauthorized actions that could be executed by malicious entities pretending to be a legitimate contract.", "Recommended practices": "Rental", "Risk of Token Owner": "Phishing attacks", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7699, "url": "https://eips.ethereum.org/EIPS/eip-7699", "title": "ERC-20 Transfer Reference Extension", "authors": ["Radek Svarz\u00a0(", "@radeksvarz", ")"], "sections": {"ERC-7699: ERC-20 Transfer Reference Extension": "TheERC-20token standard does not provide a built-in mechanism for including a payment transfer reference (message for recipient) in token transfers. This proposal extends the existing ERC-20 token standard by adding minimal methods to include a transfer reference in token transfers and transferFrom operations. The addition of a reference can help users, merchants, and service providers to associate and reconcile individual transactions with specific orders or invoices.", "Include a unique identifier (transfer or \"payment\" reference) for each ERC-20 transaction to associate transfers with orders/invoices.": "TheERC-20token standard does not provide a built-in mechanism for including a payment transfer reference (message for recipient) in token transfers. This proposal extends the existing ERC-20 token standard by adding minimal methods to include a transfer reference in token transfers and transferFrom operations. The addition of a reference can help users, merchants, and service providers to associate and reconcile individual transactions with specific orders or invoices.", "Abstract": "TheERC-20token standard does not provide a built-in mechanism for including a payment transfer reference (message for recipient) in token transfers. This proposal extends the existing ERC-20 token standard by adding minimal methods to include a transfer reference in token transfers and transferFrom operations. The addition of a reference can help users, merchants, and service providers to associate and reconcile individual transactions with specific orders or invoices.", "Motivation": "The primary motivation for this proposal is to improve the functionality of the ERC-20 token standard by providing a mechanism for including a payment reference in token transfers, similar to the traditional finance systems where payment references are commonly used to associate and reconcile transactions with specific orders, invoices or other financial records.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "The choice to name the added parametertransferReferencewas made to align with traditional banking terminology, where payment references are widely used to associate and reconcile transactions with specific orders, invoices or other financial records.", "Parameter name": "The choice to name the added parametertransferReferencewas made to align with traditional banking terminology, where payment references are widely used to associate and reconcile transactions with specific orders, invoices or other financial records.", "Parameter type": "ThetransferReferencetype is bytes.", "Emitted data": "TheloggedReferencetype is bytes32.", "Backwards Compatibility": "This extension is fully backwards compatible with the existing ERC-20 token standard. The new functions can be used alongside the existing transfer and transferFrom functions. Existing upgradable ERC-20 tokens can be upgraded to include the new functionality without impact on the storage layout; new ERC-20 tokens can choose to implement the payment reference features based on their specific needs.", "Reference Implementation": "Reference data privacy: Including payment references in token transfers may expose sensitive information about the transaction or the parties involved. Implementers and users should carefully consider the privacy implications and ensure that payment references do not reveal sensitive information. To mitigate this risk, implementers can consider using encryption or other privacy-enhancing techniques to protect payment reference data.", "Security Considerations": "Reference data privacy: Including payment references in token transfers may expose sensitive information about the transaction or the parties involved. Implementers and users should carefully consider the privacy implications and ensure that payment references do not reveal sensitive information. To mitigate this risk, implementers can consider using encryption or other privacy-enhancing techniques to protect payment reference data.", "Privacy Considerations": "Reference data privacy: Including payment references in token transfers may expose sensitive information about the transaction or the parties involved. Implementers and users should carefully consider the privacy implications and ensure that payment references do not reveal sensitive information. To mitigate this risk, implementers can consider using encryption or other privacy-enhancing techniques to protect payment reference data.", "Manipulation of payment references": "There is no validation of the reference data dictated by this ERC. Malicious actors might attempt to manipulate payment references to mislead users, merchants, or service providers. This can lead to:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7700, "url": "https://eips.ethereum.org/EIPS/eip-7700", "title": "Cross-chain Storage Router Protocol", "authors": ["Avneet Singh\u00a0(", "@sshmatrix", ")", "0xc0de4c0ffee\u00a0(", "@0xc0de4c0ffee", ")", "Nick Johnson\u00a0(", "@arachnid", ")", "Makoto Inoue\u00a0(", "@makoto", ")"], "sections": {"ERC-7700: Cross-chain Storage Router Protocol": "The following standard provides a mechanism by which smart contracts can route storage to external providers. In particular, protocols can reduce the gas fees associated with storing data on mainnet by routing the handling of storage operations to another system or network. These storage routers act as an extension to the core L1 contract. Methods in this document specifically target security and cost-effectiveness of storage routing to three router types: L1, L2 and databases. The cross-chain data written with these methods can be retrieved by genericEIP-3668-compliant contracts, thus completing the cross-chain data life cycle. This document, nicknamed CCIP-Store, alongsideEIP-3668, is a meaningful step toward a secure infrastructure for cross-chain storage routers and data retrievals.", "Provides a mechanism to replace L1 storage with L2 and databases through cross-chain routers": "The following standard provides a mechanism by which smart contracts can route storage to external providers. In particular, protocols can reduce the gas fees associated with storing data on mainnet by routing the handling of storage operations to another system or network. These storage routers act as an extension to the core L1 contract. Methods in this document specifically target security and cost-effectiveness of storage routing to three router types: L1, L2 and databases. The cross-chain data written with these methods can be retrieved by genericEIP-3668-compliant contracts, thus completing the cross-chain data life cycle. This document, nicknamed CCIP-Store, alongsideEIP-3668, is a meaningful step toward a secure infrastructure for cross-chain storage routers and data retrievals.", "Abstract": "The following standard provides a mechanism by which smart contracts can route storage to external providers. In particular, protocols can reduce the gas fees associated with storing data on mainnet by routing the handling of storage operations to another system or network. These storage routers act as an extension to the core L1 contract. Methods in this document specifically target security and cost-effectiveness of storage routing to three router types: L1, L2 and databases. The cross-chain data written with these methods can be retrieved by genericEIP-3668-compliant contracts, thus completing the cross-chain data life cycle. This document, nicknamed CCIP-Store, alongsideEIP-3668, is a meaningful step toward a secure infrastructure for cross-chain storage routers and data retrievals.", "Motivation": "EIP-3668, aka \u2018CCIP-Read\u2019, has been key to retrieving cross-chain data for a variety of contracts on Ethereum blockchain, ranging from price feeds for DeFi contracts, to more recently records for ENS users. The latter case dedicatedly uses cross-chain storage to bypass the usually high gas fees associated with on-chain storage; this aspect has a plethora of use cases well beyond ENS records and a potential for significant impact on universal affordability and accessibility of Ethereum.", "Specification": "The following specification revolves around the structure and description of a cross-chain storage router tasked with the responsibility of writing to an L2 or database storage. This document introducesStorageRoutedToL2()andStorageRoutedToDatabase()storage routers, along with the trivialStorageRoutedToL1()router, and proposes that newStorageRoutedTo__()reverts be allowed through new EIPs that sufficiently detail their interfaces and designs. Some foreseen examples of new storage routers includeStorageRoutedToSolana()for Solana,StorageRoutedToFilecoin()for Filecoin,StorageRoutedToIPFS()for IPFS,StorageRoutedToIPNS()for IPNS,StorageRoutedToArweave()for Arweave,StorageRoutedToArNS()for ArNS,StorageRoutedToSwarm()for Swarm etc.", "Overview": "The following specification revolves around the structure and description of a cross-chain storage router tasked with the responsibility of writing to an L2 or database storage. This document introducesStorageRoutedToL2()andStorageRoutedToDatabase()storage routers, along with the trivialStorageRoutedToL1()router, and proposes that newStorageRoutedTo__()reverts be allowed through new EIPs that sufficiently detail their interfaces and designs. Some foreseen examples of new storage routers includeStorageRoutedToSolana()for Solana,StorageRoutedToFilecoin()for Filecoin,StorageRoutedToIPFS()for IPFS,StorageRoutedToIPNS()for IPNS,StorageRoutedToArweave()for Arweave,StorageRoutedToArNS()for ArNS,StorageRoutedToSwarm()for Swarm etc.", "L1 Router:StorageRoutedToL1()": "A minimal L1 router is trivial and only requires the L1contractaddress to which routing must be made, while the clients must ensure that the calldata is invariant under routing to another contract. One example implementation of an L1 router is given below.", "L2 Router:StorageRoutedToL2()": "A minimal L2 router only requires the list ofchainIdvalues and the corresponding L2contractaddresses, while the clients must ensure that the calldata is invariant under routing to L2. One example implementation of an L2 router in an L1 contract is shown below.", "Database Router:StorageRoutedToDatabase()": "A minimal database router is similar to an L2 in the sense that:", "New Revert Events": "ENS off-chain resolvers capable of reading from and writing to databases are perhaps the most common use-case for CCIP-Read and CCIP-Write. One example of such a (minimal) resolver is given below along with the client-side code for handling the storage router revert.", "Implementation featuring ENS on L2 & Database": "ENS off-chain resolvers capable of reading from and writing to databases are perhaps the most common use-case for CCIP-Read and CCIP-Write. One example of such a (minimal) resolver is given below along with the client-side code for handling the storage router revert.", "Rationale": "Technically, the cases of L2s and databases are similar; routing to an L2 involves routing theeth_callto another EVM, while routing to a database can be made by extractingeth_signfrometh_calland posting the resulting signature explicitly along with the data for later verification. Methods in this document perform these precise tasks when routing storage operations to external routers. In addition, methods such as signing data with a derived signer (for databases) allow for significant UX improvement by fixing the number of signature prompts in wallets to 2, irrespective of the number of data instances to sign per node or the total number of nodes to update. This improvement comes at no additional cost to the user and allows services to perform batch updates.", "Backwards Compatibility": "None", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170."}
{"eip": 7710, "url": "https://eips.ethereum.org/EIPS/eip-7710", "title": "Smart Contract Delegation", "authors": ["Ryan McPeck\u00a0(", "@McOso", ")", "Dan Finlay\u00a0(", "@DanFinlay", ")", "Rob Dawson\u00a0(", "@rojotek", ")", "Derek Chiang\u00a0(", "@derekchiang", ")"], "sections": {"ERC-7710: Smart Contract Delegation": "This proposal introduces a standard way for smart contracts to delegate capabilities to other smart contracts\nor Externally Owned Accounts (EOAs).  The delegating contract (delegator) must be able to authorize aDelegationManagercontract to call the delegator to execute the desired action.", "Interfaces for consistently delegating capabilities to other contracts or EOAs.": "This proposal introduces a standard way for smart contracts to delegate capabilities to other smart contracts\nor Externally Owned Accounts (EOAs).  The delegating contract (delegator) must be able to authorize aDelegationManagercontract to call the delegator to execute the desired action.", "Abstract": "This proposal introduces a standard way for smart contracts to delegate capabilities to other smart contracts\nor Externally Owned Accounts (EOAs).  The delegating contract (delegator) must be able to authorize aDelegationManagercontract to call the delegator to execute the desired action.", "Motivation": "The development of smart contracts on Ethereum has led to a diverse array of decentralized applications (dApps)\nthat leverage composability to interact with one another in innovative ways. While current smart contracts are\nindeed capable of working together, enabling these interactions, especially in the realm of sharing capabilities\nor permissions, remains a tedious and often gas-expensive process, which lacks backwards compatibility.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT\nRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Terms": "When a delegate wishes to redeem a delegation, they call theredeemDelegationsfunction on the Delegation Manager and\npass in the action they want to execute and the proof of authority (ie delegation) which they are executing on behalf\nof. The Delegation Manager then verifies the delegation\u2019s validity and, if valid, calls the privileged function on the\nDelegator which executes the specified capability on behalf of the Delegator.", "Overview": "When a delegate wishes to redeem a delegation, they call theredeemDelegationsfunction on the Delegation Manager and\npass in the action they want to execute and the proof of authority (ie delegation) which they are executing on behalf\nof. The Delegation Manager then verifies the delegation\u2019s validity and, if valid, calls the privileged function on the\nDelegator which executes the specified capability on behalf of the Delegator.", "Interfaces": "The Delegation Manager MUST implement theredeemDelegationswhich will be responsible for validating the delegations\nbeing redeemed, and will then call the delegators to execute the actions.", "Rationale": "The design of this ERC is motivated by the need to introduce standardized, secure, and efficient mechanisms for\ndelegation within the Ethereum ecosystem. Several considerations were taken into account:", "Execution Interface": "A previous iteration of this spec definedActionas a simple(target, value, data)tuple, and defined a specific\nexecution interface on the delegator that isexecuteDelegatedAction(Action _action)which the Delegation Manager is\nsupposed to call.", "Security Considerations": "The introduction of customizable authorization terms requires careful consideration of how authorization data is\nstructured and interpreted. Potential security risks include the misinterpretation of authorization terms and\nunauthorized actions being taken if the interface is not properly implemented. It is recommended that applications\nimplementing this interface undergo thorough security audits to ensure that authorization terms are handled securely.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7715, "url": "https://eips.ethereum.org/EIPS/eip-7715", "title": "Grant Permissions from Wallets", "authors": ["Luka Isailovic\u00a0(", "@lukaisailovic", ")", "Derek Rein\u00a0(", "@arein", ")", "Dan Finlay\u00a0(", "@danfinlay", ")", "Derek Chiang\u00a0(", "@derekchiang", ")", "Fil Makarov\u00a0(", "@filmakarov", ")", "Pedro Gomes\u00a0(", "@pedrouid", ")", "Conner Swenberg\u00a0(", "@ilikesymmetry", ")", "Lukas Rosario\u00a0(", "@lukasrosario", ")"], "sections": {"ERC-7715: Grant Permissions from Wallets": "We define a new JSON-RPC methodwallet_grantPermissionsfor DApp to request a Wallet to grant permissions in order to execute transactions on the user\u2019s behalf. This enables two use cases:", "Adds JSON-RPC method for granting permissions from a wallet": "We define a new JSON-RPC methodwallet_grantPermissionsfor DApp to request a Wallet to grant permissions in order to execute transactions on the user\u2019s behalf. This enables two use cases:", "Abstract": "We define a new JSON-RPC methodwallet_grantPermissionsfor DApp to request a Wallet to grant permissions in order to execute transactions on the user\u2019s behalf. This enables two use cases:", "Motivation": "Currently most DApps implement a flow similar to the following:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "wallet_grantPermissions": "We introduce awallet_grantPermissionsmethod for the DApp to request the Wallet to grant permissions.", "wallet_revokePermissions": "Permissions can be revoked by calling this method and the wallet will respond with an empty response when successful.", "Signer & Permission Types": "In this ERC, we specify a list of signers and permissions that we expect to be commonly used.", "Wallet-managed Sessions": "If the signer is specified aswallet, then the wallet itself manages the session. If the wallet approves the request, it MUST acceptERC-5792\u2019swallet_sendCallswith thepermissionscapability, which MAY include the session with apermissionsContext. For example:", "Capabilities": "If the wallet supportsERC-5792, wallet SHOULD respond onwallet_getCapabilitiesrequest using thepermissionskey.", "Sending transaction with a session": "wallet_grantPermissionsreplies withpermissionsContextanduserOpBuilderaddress inside thesignerMetafield. DApps can use that data with methods provided byERC-7679to build theERC-4337userOp.", "Rationale": "The typical transaction flow ofsuggesting transactions => approving transactions => sending transactionsis deeply limiting in several ways:", "permissionsContext": "Since this ERC only specifies the interaction between the wallet and the DApp but not how the wallet enforces permissions, we need a flexible way for the wallet to pass along information to the DApp so that it can construct transactions that imbue the permissions.", "Non-exhaustive list of signers and permissions": "With the advancement in wallet technologies, we expect new types of signers and permissions to be developed. We considered mandating that each signer and permission must have a UUID in order to avoid collisions, but ultimately decided to stick with the simpler approach for now of simply mandating that these types be defined in ERCs.", "Backwards Compatibility": "Wallets that don\u2019t supportwallet_grantPermissionsSHOULD return an error message if the JSON-RPC method is called.", "Security Considerations": "DApps should only request the permissions they need, with a reasonable expiration time.", "Limited Permission Scope": "DApps should only request the permissions they need, with a reasonable expiration time.", "Phishing Attacks": "Malicious DApps could pose as legitimate applications and trick users into granting broad permissions. Wallets MUST clearly display the permissions to users and warn them against granting dangerous permissions.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7720, "url": "https://eips.ethereum.org/EIPS/eip-7720", "title": "Deferred Token Transfer", "authors": ["Chen Liaoyuan (@chenly)\u00a0<", "cly@kip.pro", ">"], "sections": {"ERC-7720: Deferred Token Transfer": "This standard specifies that allows users to depositERC-20tokens for a beneficiary. The beneficiary can withdraw the tokens only after a specified future timestamp. Each deposit transaction is assigned a unique ID and includes details such as the token address, sender, recipient, amount, unlock time, and withdrawal status.", "Allows users to schedule ERC-20 token transfers for withdrawal at a specified future time, enabling deferred payments.": "This standard specifies that allows users to depositERC-20tokens for a beneficiary. The beneficiary can withdraw the tokens only after a specified future timestamp. Each deposit transaction is assigned a unique ID and includes details such as the token address, sender, recipient, amount, unlock time, and withdrawal status.", "Abstract": "This standard specifies that allows users to depositERC-20tokens for a beneficiary. The beneficiary can withdraw the tokens only after a specified future timestamp. Each deposit transaction is assigned a unique ID and includes details such as the token address, sender, recipient, amount, unlock time, and withdrawal status.", "Motivation": "In various scenarios, such as vesting schedules, escrow services, or timed rewards, there is a need for deferred payments. This contract provides a secure and reliable mechanism for time-locked token transfers, ensuring that tokens can only be transferred after a specified timestamp is reached. By facilitating structured and delayed payments, it adds an extra layer of security and predictability to token transfers. This is particularly useful for scenarios where payments are contingent upon the passage of time.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "The design of the Deferred Token Transfer contract aims to provide a straightforward and secure method for handling time-locked token transfers. The following considerations were made during its development:", "Reference Implementation": "Ownerless Contract Design: To prevent the risk of token loss after deposit, the contract should not have an owner. This ensures that the contract\u2019s token balance cannot be transferred to any address other than the designated beneficiary.", "Security Considerations": "Ownerless Contract Design: To prevent the risk of token loss after deposit, the contract should not have an owner. This ensures that the contract\u2019s token balance cannot be transferred to any address other than the designated beneficiary.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- withdrawal: Log entry in system_logs for tracking withdrawals under EIP-4895 .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7721, "url": "https://eips.ethereum.org/EIPS/eip-7721", "title": "Lockable Extension for ERC-1155", "authors": ["Piyush Chittara\u00a0(", "@piyush-chittara", ")"], "sections": {"ERC-7721: Lockable Extension for ERC-1155": "The Lockable Extension forERC-1155introduces a robust locking mechanism for specific Non-Fungible Tokens (NFTs) within the ERC-1155 token standard, allowing for various uses while preventing sale or transfer. The token\u2019sownercanlockit, setting up locker address (either an EOA or a contract) that exclusively holds the power to unlock the token. Owner can also provide approval fortokenId, enabling ability to lock asset while address holds the token approval. Token can also be locked byapproved, assigning locker to itself. Upon token transfer, these rights get purged.", "Interface for enabling locking of ERC-1155 using locker and token id based approvals": "The Lockable Extension forERC-1155introduces a robust locking mechanism for specific Non-Fungible Tokens (NFTs) within the ERC-1155 token standard, allowing for various uses while preventing sale or transfer. The token\u2019sownercanlockit, setting up locker address (either an EOA or a contract) that exclusively holds the power to unlock the token. Owner can also provide approval fortokenId, enabling ability to lock asset while address holds the token approval. Token can also be locked byapproved, assigning locker to itself. Upon token transfer, these rights get purged.", "Abstract": "The Lockable Extension forERC-1155introduces a robust locking mechanism for specific Non-Fungible Tokens (NFTs) within the ERC-1155 token standard, allowing for various uses while preventing sale or transfer. The token\u2019sownercanlockit, setting up locker address (either an EOA or a contract) that exclusively holds the power to unlock the token. Owner can also provide approval fortokenId, enabling ability to lock asset while address holds the token approval. Token can also be locked byapproved, assigning locker to itself. Upon token transfer, these rights get purged.", "Motivation": "ERC-1155has sparked an unprecedented surge in demand for NFTs. However, despite this tremendous success, the NFT economy suffers from secondary liquidity where it remains illiquid in owner\u2019s wallet. There are projects which aim to address the liquidity challenge, but they entail the below mentioned inconveniences and risks for owners as they necessitate transferring the participating NFTs to the projects\u2019 contracts.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Overview": "ERC-1155compliant contracts MAY implement this EIP to provide standard methods of locking and unlocking the token at its current owner address.", "Interface": "This proposal exposestransferAndLock(address from, address to, uint256 tokenId, uint256 amount, bool setApprove)which can be used to transfer token and lock at the receiver\u2019s address. This additionally accepts inputbool setApprovewhich ontrueassignapprovaltolocker, hence enablinglockerto revoke the token (revocation conditions can be defined in contracts andapprovalprovided to contract). This provides conditional ownership to receiver, without the privilege totransfertoken.", "Rationale": "This proposal exposestransferAndLock(address from, address to, uint256 tokenId, uint256 amount, bool setApprove)which can be used to transfer token and lock at the receiver\u2019s address. This additionally accepts inputbool setApprovewhich ontrueassignapprovaltolocker, hence enablinglockerto revoke the token (revocation conditions can be defined in contracts andapprovalprovided to contract). This provides conditional ownership to receiver, without the privilege totransfertoken.", "Backwards Compatibility": "This standard is compatible withERC-1155standards.", "Test Cases": "Reference Interface can be foundhere.", "Reference Implementation": "Reference Interface can be foundhere.", "Security Considerations": "There are no security considerations related directly to the implementation of this standard for the contract that managesERC-1155.", "Considerations for the contracts that work with lockable tokens": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7722, "url": "https://eips.ethereum.org/EIPS/eip-7722", "title": "Opaque Token", "authors": ["Ivica Ara\u010di\u0107\u00a0(", "@ivica7", ")", "Ante Be\u0161li\u0107\u00a0(", "@ethSplit", ")", "Mirko Katani\u0107\u00a0(", "@mkatanic", ")", "SWIAT"], "sections": {"ERC-7722: Opaque Token": "This ERC proposes a specification for an opaque token that enhances privacy by concealing balance information. Privacy is achieved by representing balances as off-chain data encapsulated in hashes, referred to as \u201cbaskets\u201d. These baskets can be reorganized, transferred, and managed through token functions on-chain.", "A token specification designed to enhance privacy by concealing balance information.": "This ERC proposes a specification for an opaque token that enhances privacy by concealing balance information. Privacy is achieved by representing balances as off-chain data encapsulated in hashes, referred to as \u201cbaskets\u201d. These baskets can be reorganized, transferred, and managed through token functions on-chain.", "Abstract": "This ERC proposes a specification for an opaque token that enhances privacy by concealing balance information. Privacy is achieved by representing balances as off-chain data encapsulated in hashes, referred to as \u201cbaskets\u201d. These baskets can be reorganized, transferred, and managed through token functions on-chain.", "Motivation": "Smart contract accounts serve as well-defined identities that can have reusable claims and attestations attached to them, making them highly useful for various applications. However, this strength also introduces a significant privacy challenge when these identities are used to hold tokens. Specifically, in the case ofERC-20compatible tokens, where balances are stored directly on-chain in plain text, the transparency of these balances can compromise the privacy of the account holder. This creates a dilemma: while the reuse of claims and attestations tied to a smart contract account can be advantageous, it also increases the risk of exposing sensitive financial information, particularly when these well-defined identities are associated with publicly visible token holdings.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Baskets": "Balances are represented on-chain as hashes of the form:", "Token Interface": "An opaque token MUST implement the following interface.", "User Roles": "There are two roles in Opaque Token:", "Off-chain Data Endpoints": "REST API Endpoints for creating and querying baskets:", "reorg Endpoint": "To ensure the integrity of a reorg and avoid accidental or fraudulent issues or redeems, an oracle services is required.", "Overlaying Noise (Differential Privacy)": "To further enhance privacy and obscure transaction details, an additional layer of noise need to be introduced through reorgs and empty transfers. For example, received baskets can be reorganized into new baskets to prevent information leakage to the previous owner. Additionally, null-value baskets can be sent to random receivers (empty transfers), making it difficult for observers to determine who is transferring to whom.", "Rationale": "The transparency inherent in ERC-20 tokens presents a significant issue for reusable blockchain identities. To address this, we prioritize privacy over ERC-20 compatibility, ensuring the confidentiality of token balances.", "Breaking the ERC-20 Compatibility": "The transparency inherent in ERC-20 tokens presents a significant issue for reusable blockchain identities. To address this, we prioritize privacy over ERC-20 compatibility, ensuring the confidentiality of token balances.", "Reorg Oracles": "The trusted oracles and the minimum number of required signatures can be configured to achieve the desired level of decentralization.", "Off-chain Data Storage": "We have chosen the token operator, which in most cases will be the issuer or registrar, as the initial and main source for off-chain data. This is acceptable, since they must know anyway which investor holds which positions to manage lifecycle events on the token. While this approach may not be suitable for every use case within the broader Ethereum ecosystem, it fits well the financial instruments in the regulated environment of the financial industry, which rely on strict KYC and token operation procedures.", "Backwards Compatibility": "Copyright and related rights waived viaCC0.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Fraudulent Oracles": "Copyright and related rights waived viaCC0.", "Oracles Collecting Confidential Data": "Copyright and related rights waived viaCC0.", "Confidential Data Loss": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7726, "url": "https://eips.ethereum.org/EIPS/eip-7726", "title": "Common Quote Oracle", "authors": ["alcueca\u00a0(", "@alcueca", ")", "ruvaag\u00a0(", "@ruvaag", ")", "totomanov\u00a0(", "@totomanov", ")", "r0ohafza\u00a0(", "@r0ohafza", ")"], "sections": {"ERC-7726: Common Quote Oracle": "The following allows for the implementation of a standard API for data feeds providing the relative value of\nassets, forcing compliant contracts to use explicit token amounts instead of price factors. This approach has been\nshown to lead to better security and time-to-market outcomes.", "Interface for data feeds providing the relative value of assets.": "The following allows for the implementation of a standard API for data feeds providing the relative value of\nassets, forcing compliant contracts to use explicit token amounts instead of price factors. This approach has been\nshown to lead to better security and time-to-market outcomes.", "Abstract": "The following allows for the implementation of a standard API for data feeds providing the relative value of\nassets, forcing compliant contracts to use explicit token amounts instead of price factors. This approach has been\nshown to lead to better security and time-to-market outcomes.", "Motivation": "The information required to value assets is scattered over a number of major and minor sources, each one with their own\nintegration API and security considerations. Many protocols over the years have implemented oracle adapter layers for\ntheir own use to abstract this complexity away from their core implementations, leading to much duplicated effort.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Definitions": "Returns the value ofbaseAmountofbaseinquoteterms.", "Methods": "Returns the value ofbaseAmountofbaseinquoteterms.", "Special Addresses": "Some assets under the scope of this specification don\u2019t have an address, such as ETH, BTC and national currencies.", "Rationale": "The use ofgetQuotedoesn\u2019t require the consumer to be aware of any decimal partitions that might have been defined\nfor thebaseorquoteand should be preferred in most data processing cases.", "Backwards Compatibility": "Most existing data feeds related to the relative value of pairs of assets should be representable using this standard.", "Security Considerations": "This specification purposefully provides no methods for data consumers to assess the validity of the data they receive.\nIt is expected of individual implementations using this specification to decide and publish the quality of the data that\nthey provide, including the conditions in which they will stop providing it.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7729, "url": "https://eips.ethereum.org/EIPS/eip-7729", "title": "Token with Metadata", "authors": ["msfew\u00a0(", "@fewwwww", ")"], "sections": {"ERC-7729: Token with Metadata": "This standard extends theERC-20standard to include ametadatafunction interface and a JSON schema for metadata.", "An ERC-20 extension for tokens with metadata.": "This standard extends theERC-20standard to include ametadatafunction interface and a JSON schema for metadata.", "Abstract": "This standard extends theERC-20standard to include ametadatafunction interface and a JSON schema for metadata.", "Motivation": "Memecoins have demonstrated the value of associating tokens with visual metadata. By standardizing a way to include metadata in ERC-20 tokens, developers can create more engaging and interactive tokens, fostering community engagement.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "Themetadatafunction was chosen based on existing implementations in standards and applications.", "Backwards Compatibility": "This standard is backward compatible with theERC-20as it extends the existing functionality with new interfaces.", "Reference Implementation": "The metadata URI could be manipulated to point to malicious content or phishing sites. Off-chain indexers should perform validation checks to ensure the security and integrity of the metadata URIs for users.", "Security Considerations": "The metadata URI could be manipulated to point to malicious content or phishing sites. Off-chain indexers should perform validation checks to ensure the security and integrity of the metadata URIs for users.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7730, "url": "https://eips.ethereum.org/EIPS/eip-7730", "title": "Structured Data Clear Signing Format", "authors": ["Laurent Castillo\u00a0(", "@lcastillo-ledger", ")"], "sections": {"ERC-7730: Structured Data Clear Signing Format": "This specification defines a JSON format carrying additional information required to correctly display structured data to a human for review on a wallet screen, before signature by the wallet.", "JSON format describing how to clear-sign smart contract calls and typed messages.": "This specification defines a JSON format carrying additional information required to correctly display structured data to a human for review on a wallet screen, before signature by the wallet.", "Abstract": "This specification defines a JSON format carrying additional information required to correctly display structured data to a human for review on a wallet screen, before signature by the wallet.", "Motivation": "Properly validating a transaction on a hardware wallet\u2019s screen (also known as Clear Signing) is a key element of good security practices for end users when interacting with any Blockchain. Unfortunately, most data to sign, even enriched with the data structure description (like ABIs or EIP-712 types) are not self-sufficient in terms of correctly displaying them to the user for review. Among other things:", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Simple example": "The following is an example of how to clear sign atransferfunction call on anERC-20contract.", "Common concepts": "In all the specification, key names starting with$areinternaland have no value beyond readability of the specification file itself. They should not be used in any function to build the UI to review structured data.", "Contextsection": "Thecontextsection describes a set ofconstraintsthat must be verified by the structured data and container structure before formatting them using the ERC-7730 file. A wallet MUST verify that the structured data and container it is trying to sign matches the constraints of thecontextsection.", "Metadatasection": "Themetadatasection contains information about constant values relevant in the scope of the current contract / message (as matched by thecontextsection).", "Displaysection": "Thedisplaysection contains the actual formatting instructions for each field of the bound structured data. It is split into two parts, adisplay.definitionskey that contains common formats that can be re-used in the other parts and adisplay.formatskey containing the actual format instructions for each function / message type bound to the specification file.", "Reference": "This section describes all container structure supported by this specification and possible references path to relevant values.", "Container structure values": "This section describes all container structure supported by this specification and possible references path to relevant values.", "Field formats": "In the following references, the format title is the value to use under theformatkey of afield format specification.", "Wallets specific layouts": "Wallets MAY extend the specification with wallet specific layout instructions by defining a schema bound to thedisplay.formats.screensfield.", "Rationale": "It is expected that the main limitation to adoption of ERC-7730 will be the complexity of writing this interface description file compared to interest of writing it.", "Human readability": "It is expected that the main limitation to adoption of ERC-7730 will be the complexity of writing this interface description file compared to interest of writing it.", "Wallet limitations": "Wide support by wallets is key for adoption of this specification.", "Why is the ABI still necessary?": "The full signature of a function call does not contain information about the types of complex parameters that might be used in the function call, only their names, while the ABI does carry this information. This is why the ABI is the reference and the function signature MUST match it. The full form of the function call is allowed in order to simplify writing and reading the ERC-7730 file.", "Deployment model": "Making the ERC-7730 available for wallets is a key factor of adoption. We have a few options:", "Extensibility to other Structured Data formats": "In the future, this specification could be extended to structured data like Meta Transaction inEIP-2771or User Operations inEIP-4337.", "Test Cases": "More examples can be found in the asset folderhereandhere.", "Security Considerations": "The main security concern introduced by ERC-7730 is to avoid attacks that would use the ERC-7730 formatting mechanism to trick users into signing something wrong.", "Binding context": "The bindingcontextis the way we mitigate the first attack, by specifying in the ERC-7730 file itself,what kindof structured data should be formatted by said file.", "Curation model": "The second attack is not directly mitigated by the specification (beyond providing recommendations). It is rather expected that wallets will use a two-step curation process, and NOT trust ERC-7730 files coming directly from the public repository.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7738, "url": "https://eips.ethereum.org/EIPS/eip-7738", "title": "Permissionless Script Registry", "authors": ["Victor Zhang\u00a0(", "@zhangzhongnan928", ")", "James Brown\u00a0(", "@JamesSmartCell", ")"], "sections": {"ERC-7738: Permissionless Script Registry": "This EIP provides a means to create a standard registry for locating executable scripts associated with the token.", "Permissionless registry to fetch executable scripts for contracts": "This EIP provides a means to create a standard registry for locating executable scripts associated with the token.", "Abstract": "This EIP provides a means to create a standard registry for locating executable scripts associated with the token.", "Motivation": "ERC-5169provides a client script lookup method for contracts. This requires the contract to have implemented theERC-5169interface at the time of construction (or allow an upgrade path).", "Overview": "The registry contract will supply a set of URI links for a given contract address. These URI links point to script programs that can be fetched by a wallet, viewer or mini-dapp.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "This method allows contracts written without theERC-5169interface to associate scripts with themselves, and avoids the need for a centralised online server, with subsequent need for security and the requires an organisation to become a gatekeeper for the database.", "Test Cases": "Test cases are included inNFTRegistryTest.test.ts. Contracts, deployment scripts and registry script can be found alongside the test script.", "Reference Implementation": "The live implementation of the script registry is at0x0077380bCDb2717C9640e892B9d5Ee02Bb5e0682on several mainnet, L2 and testnet chains. To deploy scripts for use you can directly call thesetScriptURIfunction:", "Simplified Implementation": "The scripts provided could be authenticated in various ways:", "Security Considerations": "The scripts provided could be authenticated in various ways:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7739, "url": "https://eips.ethereum.org/EIPS/eip-7739", "title": "Readable Typed Signatures for Smart Accounts", "authors": ["vectorized\u00a0(", "@vectorized", ")", "Sihoon Lee\u00a0(", "@push0ebp", ")", "Francisco Giordano\u00a0(", "@frangio", ")", "Hadrien Croubois\u00a0(", "@Amxx", ")", "Ernesto Garc\u00eda\u00a0(", "@ernestognw", ")", "Im Juno\u00a0(", "@junomonster", ")", "howydev\u00a0(", "@howydev", ")", "Atarpara\u00a0(", "@Atarpara", ")", "0xcuriousapple\u00a0(", "@0xcuriousapple", ")"], "sections": {"ERC-7739: Readable Typed Signatures for Smart Accounts": "This proposal defines a standard to prevent signature replays across multiple smart accounts when they are owned by a single Externally Owned Account (EOA). This is achieved through a defensive rehashing scheme forERC-1271verification using specific nestedEIP-712typed structures, which preserves the readability of the signed contents during wallet client signature requests.", "A defensive rehashing scheme which prevents signature replays across smart accounts and preserves the readability of the signed contents": "This proposal defines a standard to prevent signature replays across multiple smart accounts when they are owned by a single Externally Owned Account (EOA). This is achieved through a defensive rehashing scheme forERC-1271verification using specific nestedEIP-712typed structures, which preserves the readability of the signed contents during wallet client signature requests.", "Abstract": "This proposal defines a standard to prevent signature replays across multiple smart accounts when they are owned by a single Externally Owned Account (EOA). This is achieved through a defensive rehashing scheme forERC-1271verification using specific nestedEIP-712typed structures, which preserves the readability of the signed contents during wallet client signature requests.", "Motivation": "Smart accounts can verify signatures with viaERC-1271using theisValidSignaturefunction.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Overview": "The following dependencies are REQUIRED:", "TypedDataSignworkflow": "TheTypedDataSignworkflow handles the case where thehashis originally computed withEIP-712.", "PersonalSignworkflow": "ThisPersonalSignworkflow handles the case where thehashis originally computed withEIP-191.", "Support detection": "Smart accounts SHOULD returnbytes4(0x77390001)forisValidSignature(0x7739773977397739773977397739773977397739773977397739773977397739, \"\")to indicate support for this standard.", "Signature verification workflow deduction": "As theisValidSignaturesignature function signature is unchanged, the implementation MUST be able to deduce the type of workflow required to verify the signature.", "Conditional skipping of defensive rehashing": "Smart accounts MAY skip the defensive rehashing workflows if any of the following is true:", "Rationale": "ThetypedDataSignTypehashmust be constructed on-the-fly on-chain. This is to enforce that the signed contents will be visible in the signature request, by requiring thatcontentsbe a user defined type.", "TypedDataSignstructure": "ThetypedDataSignTypehashmust be constructed on-the-fly on-chain. This is to enforce that the signed contents will be visible in the signature request, by requiring thatcontentsbe a user defined type.", "contentsDescriptionwith implicit and explicit modes": "When thecontentsstructure contains nested types, EIP-712 lexicographical sorting can result in thecontentsNamenot being positioned exactly at the start of thecontentsType. As such, we need the explicit mode.", "Support detection withisValidSignature": "For easier implementation in modular smart accounts, we have decided to utilize theisValidSignaturemethod to return a magic number instead of defining new functions.", "RejectingcontentsNamebeginning with any lowercase 7-bit ASCII character": "This recommendation is to keep the standard language agnostic and future-proof. Atomic types such asuint256may be named differently in other languages (e.g.u256).", "Backwards Compatibility": "In an earlier draft, we have designated asupportsNestedTypedDataSign()function for support detection, which returnsbytes4(0xd620c85a).", "Detection of previous draft": "In an earlier draft, we have designated asupportsNestedTypedDataSign()function for support detection, which returnsbytes4(0xd620c85a).", "Reference Implementation": "A production ready and optimized implementation is provided for reference.", "Security Considerations": "Current major implementations ofeth_signTypedDatado not sanitize the names of custom types.", "Rejecting invalidcontentsName": "Current major implementations ofeth_signTypedDatado not sanitize the names of custom types.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- magic: A constant value set as 0xef0100 used in the CREATE_DELEGATE instruction.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7741, "url": "https://eips.ethereum.org/EIPS/eip-7741", "title": "Authorize Operator", "authors": ["Jeroen Offerijns\u00a0(", "@hieronx", ")", "Jo\u00e3o Martins\u00a0(", "@0xTimepunk", ")"], "sections": {"ERC-7741: Authorize Operator": "A set of functions to enable meta-transactions and atomic interactions with contracts implementing an operator model, via signatures conforming to theEIP-712typed message signing specification.", "Set Operator via EIP-712 secp256k1 signatures": "A set of functions to enable meta-transactions and atomic interactions with contracts implementing an operator model, via signatures conforming to theEIP-712typed message signing specification.", "Abstract": "A set of functions to enable meta-transactions and atomic interactions with contracts implementing an operator model, via signatures conforming to theEIP-712typed message signing specification.", "Motivation": "The primary motivation for this standard is to enhance the flexibility, security, and efficiency of operator management. By leveraging EIP-712 signatures, this standard allows users to authorize operators without the need for on-chain transactions, reducing gas costs and improving user experience. This is particularly beneficial whenever frequent operator changes and cross-chain interactions are required.", "Specification": "This signed authorization scheme applies to any contracts implementing the following interface:", "Operator-compatible contracts": "This signed authorization scheme applies to any contracts implementing the following interface:", "Methods": "Grants or revokes permissions foroperatorto manage Requests on behalf of themsg.sender, using anEIP-712signature.", "ERC-165support": "Smart contracts implementing this standard MUST implement theERC-165supportsInterfacefunction.", "Rationale": "The specification is intentionally designed to closely matchERC-2612. This should simplify new integrations of the standard.", "Similarity toERC-2612": "The specification is intentionally designed to closely matchERC-2612. This should simplify new integrations of the standard.", "Reference Implementation": "Operators have significant control over users and the signed message can lead to undesired outcomes. The expiration date should be set as short as feasible to reduce the chance of an unused signature leaking at a later point.", "Security Considerations": "Operators have significant control over users and the signed message can lead to undesired outcomes. The expiration date should be set as short as feasible to reduce the chance of an unused signature leaking at a later point.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7754, "url": "https://eips.ethereum.org/EIPS/eip-7754", "title": "Tamperproof Web Immutable Transaction (TWIT)", "authors": ["Erik Marks\u00a0(", "@remarks", ")", "Guillaume Grosbois\u00a0(", "@uni-guillaume", ")"], "sections": {"ERC-7754: Tamperproof Web Immutable Transaction (TWIT)": "Introduces a new RPC method to be implemented by wallets,wallet_signedRequest, that\nenables dapps to interact with wallets in a tamperproof manner via \u201csigned requests\u201d. The\ndapp associates a public key with its DNS record and uses the corresponding private key to\nsign payloads sent to the wallet viawallet_signedRequest. Wallets can then use the\npublic key in the DNS record to validate the integrity of the payload.", "Provides a mechanism for dapps to use the extension wallets API in a tamperproof way": "Introduces a new RPC method to be implemented by wallets,wallet_signedRequest, that\nenables dapps to interact with wallets in a tamperproof manner via \u201csigned requests\u201d. The\ndapp associates a public key with its DNS record and uses the corresponding private key to\nsign payloads sent to the wallet viawallet_signedRequest. Wallets can then use the\npublic key in the DNS record to validate the integrity of the payload.", "Abstract": "Introduces a new RPC method to be implemented by wallets,wallet_signedRequest, that\nenables dapps to interact with wallets in a tamperproof manner via \u201csigned requests\u201d. The\ndapp associates a public key with its DNS record and uses the corresponding private key to\nsign payloads sent to the wallet viawallet_signedRequest. Wallets can then use the\npublic key in the DNS record to validate the integrity of the payload.", "Motivation": "This standard aims to enhance the end user\u2019s experience by granting them confidence that requests from their dapps have not been tampered with.\nIn essence, this is similar to how HTTPS is used in the web.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Overview": "We propose to use the dapp\u2019s domain certificate of a root of trust to establish a trust chain as follow:", "Wallet integration": "Attested public keys are necessary for the chain of trust to be established.\nSince this is traditionally done via DNS certificates, we propose the addition of a DNS record containing the public keys.\nThis is similar toRFC-6636\u2019s DKIM, but the use of a manifest file provides more flexibility for future improvements, as well as support for multiple algorithm and key pairs.", "Wallet UX suggestion": "Similarly to the padlock icon for HTTPS, wallets should display a visible indication when TWIT is configured on a domain. This will improve the UX of the end user who will immediately be able to tell\nthat interactions between the dapp they are using and the wallet are secure, and this will encourage dapp developer to adopt TWIT, making the overall ecosystem more secure", "Rationale": "The proposed implementation does not modify any of the existing functionalities offered byEIP-712andEIP-1193. Its additive\nnature makes it inherently backward compatible. Its core design is modeled after existing solutions to existing problems (such as DKIM). As a result the proposed specification will be non disruptive, easy to\nimplements for both wallets and dapps, with a predictable threat model.", "Security Considerations": "While signing therequestArgpayload guarantees data integrity, it does not prevent replay attacks in itself:", "Replay prevention": "While signing therequestArgpayload guarantees data integrity, it does not prevent replay attacks in itself:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7760, "url": "https://eips.ethereum.org/EIPS/eip-7760", "title": "Minimal Upgradeable Proxies", "authors": ["Atarpara\u00a0(", "@Atarpara", ")", "JT Riley\u00a0(", "@jtriley-eth", ")", "Thomas\u00a0(", "@0xth0mas", ")", "xiaobaiskill\u00a0(", "@xiaobaiskill", ")", "Vectorized\u00a0(", "@Vectorized", ")"], "sections": {"ERC-7760: Minimal Upgradeable Proxies": "This standard defines minimalERC-1967proxies for three patterns: (1) transparent, (2) UUPS, (3) beacon. The proxies support optional immutable arguments which are appended to the end of their runtime bytecode. Additional variants which support onchain implementation querying are provided.", "Minimal upgradeable proxies with immutable arguments and support for onchain implementation queries": "This standard defines minimalERC-1967proxies for three patterns: (1) transparent, (2) UUPS, (3) beacon. The proxies support optional immutable arguments which are appended to the end of their runtime bytecode. Additional variants which support onchain implementation querying are provided.", "Abstract": "This standard defines minimalERC-1967proxies for three patterns: (1) transparent, (2) UUPS, (3) beacon. The proxies support optional immutable arguments which are appended to the end of their runtime bytecode. Additional variants which support onchain implementation querying are provided.", "Motivation": "Having standardized minimal bytecode for upgradeable proxies enables the following:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "General specifications": "All of the following proxies MAY have optional data bytecode appended to the end of their runtime bytecode.", "Onchain querying of implementation for I-variants": "The I-variants have logic that returns the implementation baked into their bytecode.", "Minimal ERC-1967 transparent upgradeable proxy": "The transparent upgradeable proxy is RECOMMENDED to be deployed by a factory that doubles as the account that is authenticated to perform upgrades. An externally owned account may perform the deployment on behalf of the factory. For convention, we will refer to the factory as the immutable account authorized to invoke the upgrade logic on the proxy.", "Minimal ERC-1967 UUPS proxy": "As this proxy does not contain upgrading logic, the initialization code MUST store the implementation at the ERC-1967 implementation storage slot0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc.", "Minimal ERC-1967 beacon proxy": "As this proxy does not contain upgrading logic, the initialization code MUST store the implementation at the ERC-1967 implementation storage slot0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc.", "Rationale": "For more widespread EVM compatibility, the proxies deliberately do not use thePUSH0opcode proposed inEIP-3855.", "No usage ofPUSH0opcode": "For more widespread EVM compatibility, the proxies deliberately do not use thePUSH0opcode proposed inEIP-3855.", "Optimization priorities": "The proxies are first optimized for minimal runtime gas before minimal bytecode size.", "Minimal nature": "These proxies made from handcrafted EVM bytecode. While utmost efforts have been made to ensure that they are as minimal as possible at the time of development, it is possible that they can be further optimized. If a variant has already been used in the wild, it is preferable to keep their existing layout in this standard, as the benefits of automatic block explorer verification will outweigh the few gas saved during runtime or deployment.", "Transparent upgradeable proxy": "The factory address in the transparent upgradeable proxy is baked into the immutable bytecode of the minimal transparent upgradeable proxy.", "14-byte factory address subvariants": "It is beneficial to install the transparent upgradeable proxy factory at a vanity address with leading zero bytes so that the proxy\u2019s bytecode can be optimized to be shorter.", "I-variants": "The so-called \u201cI-variants\u201d contain logic that returns the implementation address baked into the proxy bytecode.", "Omission of events in bytecode": "This is for minimal bytecode size and deployment costs.", "Immutable arguments are not appended to forwarded calldata": "This is to avoid compatibility and safety issues with other ERC standards that append extra data to the calldata.", "No fixed initialization code": "As long as the initialization code is able to initialize the relevant ERC-1967 implementation slot where needed (i.e. for the UUPS proxy and Beacon proxy), there is no need for additional requirements on the initialization code.", "Out of scope topics": "The following topics are intentionally out of scope of this standard, as they can contain custom logic:", "Backwards Compatibility": "No backward compatibility issues found.", "Reference Implementation": "To ensure security, the transparent upgradeable proxy factory must implement proper access control to allow proxies to be upgraded by only authorized accounts.", "Minimal ERC-1967 transparent upgradeable proxy implementation": "To ensure security, the transparent upgradeable proxy factory must implement proper access control to allow proxies to be upgraded by only authorized accounts.", "Minimal ERC-1967 UUPS proxy implementation": "To ensure security, the transparent upgradeable proxy factory must implement proper access control to allow proxies to be upgraded by only authorized accounts.", "Minimal ERC-1967 beacon proxy implementation": "To ensure security, the transparent upgradeable proxy factory must implement proper access control to allow proxies to be upgraded by only authorized accounts.", "Security Considerations": "To ensure security, the transparent upgradeable proxy factory must implement proper access control to allow proxies to be upgraded by only authorized accounts.", "Transparent upgradeable proxy factory security considerations": "To ensure security, the transparent upgradeable proxy factory must implement proper access control to allow proxies to be upgraded by only authorized accounts.", "Calldata length collision for I-variants": "The I-variants reserve all calldata of length 1 to denote a request to return the implementation. This may pose compatibility issues if the underlying implementation actually uses 1-byte calldata for special purposes.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7765, "url": "https://eips.ethereum.org/EIPS/eip-7765", "title": "Privileged Non-Fungible Tokens Tied To RWA", "authors": ["frank (@frankmint2024)\u00a0<", "frank@mintchain.io", ">"], "sections": {"ERC-7765: Privileged Non-Fungible Tokens Tied To RWA": "This EIP defines an interface to carry a real world asset with some privileges that can be exercised by the holder of the corresponding NFT. The EIP standardizes the interface for non-fungible tokens representing real world assets with privileges to be exercised, such as products sold onchain which can be redeemed in the real world.", "An interface extending ERC-721 representing real world assets that users can exercise privileges with NFTs.": "This EIP defines an interface to carry a real world asset with some privileges that can be exercised by the holder of the corresponding NFT. The EIP standardizes the interface for non-fungible tokens representing real world assets with privileges to be exercised, such as products sold onchain which can be redeemed in the real world.", "Abstract": "This EIP defines an interface to carry a real world asset with some privileges that can be exercised by the holder of the corresponding NFT. The EIP standardizes the interface for non-fungible tokens representing real world assets with privileges to be exercised, such as products sold onchain which can be redeemed in the real world.", "Motivation": "NFTs bound to real-world assets sometimes need to carry certain privileges that can be exercised by the holder. Users can initiate transactions onchain to specify the exercise of a certain privilege, thereby achieving real-world privileges that directly map the onchain privilege through subsequent operations. For example, if a certain product such as a pair of shoes is sold onchain in the representation of NFT, the NFT holder can exercise the privilege of exchanging physical shoes offchain, to achieve the purpose of interoperability between the blockchain and the real world.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "This standard is an extension of ERC-721. It is fully compatible with both of the commonly used optional extensions (IERC721MetadataandIERC721Enumerable) mentioned in the ERC-721 standard.", "Backwards Compatibility": "This standard is an extension of ERC-721. It is fully compatible with both of the commonly used optional extensions (IERC721MetadataandIERC721Enumerable) mentioned in the ERC-721 standard.", "Reference Implementation": "The reference implementation of Privileged NFTs can be foundHere.", "Security Considerations": "Compliant contracts should pay attention to the storage to the states of the privileges. The contract should properly handle the state transition of each privilege of each NFT, clearly showing that each privilege is exercisable or has been exercised.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7766, "url": "https://eips.ethereum.org/EIPS/eip-7766", "title": "Signature Aggregation for ERC-4337", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Yoav Weiss\u00a0(", "@yoavw", ")", "Dror Tirosh\u00a0(", "@drortirosh", ")", "Shahaf Nacson\u00a0(", "@shahafn", ")", "Alex Forshtat\u00a0(", "@forshtat", ")"], "sections": {"ERC-7766: Signature Aggregation for ERC-4337": "ERC-4337defined a way to achieve Account Abstraction on Ethereum using an alternativeUserOperationmempool.", "An ERC-4337 improvement to aggregation of all UserOperation signatures in a bundle": "ERC-4337defined a way to achieve Account Abstraction on Ethereum using an alternativeUserOperationmempool.", "Abstract": "ERC-4337defined a way to achieve Account Abstraction on Ethereum using an alternativeUserOperationmempool.", "Motivation": "Using validation schemes that allow signature aggregation enables significant optimisations and savings on\ngas for execution and transaction data cost. This is especially relevant in the context of rollups that publish data on\nthe Ethereum mainnet.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Aggregator - a new ERC-4337UserOperationentity contract": "A signature aggregator exposes the following interface:", "Using Signature Aggregator": "A signature aggregator exposes the following interface:", "Bundling changes": "In addition to the steps described in ERC-4337, during bundling the bundler should:", "New \u201centry point\u201d function in the ERC-4337EntryPointcontract": "We define the following addition to the core interface of theEntryPointcontract:", "Rationale": "When using anaggregatorcontract, the accounts delegate their ability to authenticateUserOperations.\nThe entire contents of the", "Account returning the \u201calternative signature\u201d": "When using anaggregatorcontract, the accounts delegate their ability to authenticateUserOperations.\nThe entire contents of the", "Backwards Compatibility": "As ERC-4337 was created with signature aggregation on the roadmap, no modifications are needed to the\ndeployed EntryPoint smart contracts.", "Security Considerations": "Theaggregatorcontracts are among te most trusted contracts in the entire ecosystem.\nThey can authorize transactions on behalf of accounts, and they can invalidate large numbers of transactions with\na simple storage change.", "Malicious aggregators": "Theaggregatorcontracts are among te most trusted contracts in the entire ecosystem.\nThey can authorize transactions on behalf of accounts, and they can invalidate large numbers of transactions with\na simple storage change.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7769, "url": "https://eips.ethereum.org/EIPS/eip-7769", "title": "JSON-RPC API for ERC-4337", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Yoav Weiss\u00a0(", "@yoavw", ")", "Dror Tirosh\u00a0(", "@drortirosh", ")", "Shahaf Nacson\u00a0(", "@shahafn", ")", "Alex Forshtat\u00a0(", "@forshtat", ")"], "sections": {"ERC-7769: JSON-RPC API for ERC-4337": "Defines new JSON-RPC API methods which enableERC-4337wallets to communicate withUserOpeationmempool\nnodes and bundlers, matching the functionality that exists for Ethereum transactions.", "JSON-RPC API methods for communication between smart contract account wallets and ERC-4337 bundlers": "Defines new JSON-RPC API methods which enableERC-4337wallets to communicate withUserOpeationmempool\nnodes and bundlers, matching the functionality that exists for Ethereum transactions.", "Abstract": "Defines new JSON-RPC API methods which enableERC-4337wallets to communicate withUserOpeationmempool\nnodes and bundlers, matching the functionality that exists for Ethereum transactions.", "Motivation": "In ERC-4337, user transactions as defined in Ethereum are replaced withUserOperationobjects, which contain all the\ninformation needed to perform the operations requested by the users.", "Specification": "Theeth_sendUserOperationmethod submits aUserOperationobject to the UserOperation mempool.\nThe client MUST validate theUserOperation, and return a result accordingly.", "Definitions": "Theeth_sendUserOperationmethod submits aUserOperationobject to the UserOperation mempool.\nThe client MUST validate theUserOperation, and return a result accordingly.", "RPC methods (eth namespace)": "Theeth_sendUserOperationmethod submits aUserOperationobject to the UserOperation mempool.\nThe client MUST validate theUserOperation, and return a result accordingly.", "RPC methods (debug Namespace)": "This api must only be available in testing mode and is required by the compatibility test suite.\nIn production, anydebug_*rpc calls should be blocked.", "Rationale": "This proposal defines a new JSON-RPC API standard that does not pose any backwards compatibility challenges.", "Backwards Compatibility": "This proposal defines a new JSON-RPC API standard that does not pose any backwards compatibility challenges.", "Security Considerations": "Operating a public production ERC-4337 node is a computationally intensive task and may be a target of a DoS attack.\nThis is addressed by the ERC-7562 validation rules, which defines a way for the ERC-4337 node to track participants\u2019\nreputation as well as preventing nodes from accepting maliciously craftedUserOperations.", "Preventing DoS attacks on UserOperation mempool": "Operating a public production ERC-4337 node is a computationally intensive task and may be a target of a DoS attack.\nThis is addressed by the ERC-7562 validation rules, which defines a way for the ERC-4337 node to track participants\u2019\nreputation as well as preventing nodes from accepting maliciously craftedUserOperations.", "DisablingdebugAPI in production servers": "The API defined in thedebugnamespace is not intended to ever be publicly available.\nProduction implementations of ERC-4337 must never make it available by default,\nand in fact enabling it should result in a clear warning of the potential dangers of exposing this API.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7774, "url": "https://eips.ethereum.org/EIPS/eip-7774", "title": "Cache invalidation in ERC-5219 mode Web3 URL", "authors": ["Nicolas Deschildre\u00a0(", "@nand2", ")", "Sam Wilson\u00a0(", "@SamWilsn", ")"], "sections": {"ERC-7774: Cache invalidation in ERC-5219 mode Web3 URL": "In the context of theERC-6860web3://standard, this ERC extends theERC-6944resolve mode. It introduces mechanisms to address limitations that prevent the use of standardRFC 9111HTTP caching.", "Introduce a new HTTP cache control method using EVM events for invalidation": "In the context of theERC-6860web3://standard, this ERC extends theERC-6944resolve mode. It introduces mechanisms to address limitations that prevent the use of standardRFC 9111HTTP caching.", "Abstract": "In the context of theERC-6860web3://standard, this ERC extends theERC-6944resolve mode. It introduces mechanisms to address limitations that prevent the use of standardRFC 9111HTTP caching.", "Motivation": "Calls to Ethereum RPC providers are costly\u2014both CPU-wise for local nodes and monetarily for paid external RPC providers. Furthermore, external RPC providers are rate-limited, which can quickly cause disruptions when loadingweb3://URLs.", "Specification": "This standard introduces theevm-eventscache directive for theCache-Controlheader of request responses, as an extension directive as defined in section 5.2.3 ofRFC 9111.", "Cache invalidation event": "The event is defined as:", "Caching behavior": "Aweb3://client can be in one of two cache invalidation states for each chain and smart contract:", "Rationale": "To stay as close as possible to standard HTTP, we reuse the HTTP caching mechanism headers.", "Security Considerations": "Stale content will be served during the delay between a user transaction emitting a cache clearing event, and theweb3://client picking and processing the event.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7776, "url": "https://eips.ethereum.org/EIPS/eip-7776", "title": "Transparent Financial Statements", "authors": ["Ignacio Ceaglio (@Nachoxt17)\u00a0<", "ignacioceaglio@gmail.com", ">"], "sections": {"ERC-7776: Transparent Financial Statements": "This proposal defines a standard API that enables EVM Blockchain-based companies (or also called \u201cprotocols\u201d) to publish their financial information, specifically Income Statements and Balance Sheets, on-\nchain in a transparent and accessible manner through solidity smart contracts. This standard aims to emulate the reporting structure used by publicly traded companies in traditional stocks markets, like \nthe SEC 10-Q filings. The financial statements include key information, namely as Revenue, Cost of Goods Sold, Operating Expenses, Operating Income, Earnings before Interest, Taxes, Depreciation, and \nAmortization (EBITDA) and\nEarnings Per Share-Token (EPS), allowing investors to assess the financial health of blockchain-based companies in a standardized, transparent, clear and reliable format.", "Open Transparent Financial Data such as Revenue, Costs of Goods Sold, Operating Expenses, EBITDA and Earnings Per Share for all Investors.": "This proposal defines a standard API that enables EVM Blockchain-based companies (or also called \u201cprotocols\u201d) to publish their financial information, specifically Income Statements and Balance Sheets, on-\nchain in a transparent and accessible manner through solidity smart contracts. This standard aims to emulate the reporting structure used by publicly traded companies in traditional stocks markets, like \nthe SEC 10-Q filings. The financial statements include key information, namely as Revenue, Cost of Goods Sold, Operating Expenses, Operating Income, Earnings before Interest, Taxes, Depreciation, and \nAmortization (EBITDA) and\nEarnings Per Share-Token (EPS), allowing investors to assess the financial health of blockchain-based companies in a standardized, transparent, clear and reliable format.", "Abstract": "This proposal defines a standard API that enables EVM Blockchain-based companies (or also called \u201cprotocols\u201d) to publish their financial information, specifically Income Statements and Balance Sheets, on-\nchain in a transparent and accessible manner through solidity smart contracts. This standard aims to emulate the reporting structure used by publicly traded companies in traditional stocks markets, like \nthe SEC 10-Q filings. The financial statements include key information, namely as Revenue, Cost of Goods Sold, Operating Expenses, Operating Income, Earnings before Interest, Taxes, Depreciation, and \nAmortization (EBITDA) and\nEarnings Per Share-Token (EPS), allowing investors to assess the financial health of blockchain-based companies in a standardized, transparent, clear and reliable format.", "Motivation": "The motivation of this ERC is to bring seriousness to the cryptocurrencies investments market. Currently, the situation is as follows:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in \nRFC 2119 and RFC 8174.", "Definitions:": "Returns theaddressof the individual stablecoin used to value the publicly displayed financial numbers.", "Methods": "Returns theaddressof the individual stablecoin used to value the publicly displayed financial numbers.", "Rationale": "ERC-20 is enforced because implementation details like Earnings Per Token calculation directly carry over to the accounting. This standardization makes the Transparent Financial Statements compatible with \nall ERC-20 use cases.", "Backwards Compatibility": "Transparent Financial Statements Standard is fully backward compatible with the ERC-20 standard and has no known compatibility issues with other standards.", "Reference Implementation": "NOTE: This Reference Implementation is a placeholder. It will be improved in the future from the feedback received.", "Security Considerations": "This ERC involves displaying critical financial data on-chain, so special attention must be paid to ensure the accuracy and security of the data, particularly in preventing tampering or manipulation of key \nfinancial figures. Further discussion on validation mechanisms and audits for the smart contracts containing financial data is necessary.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7779, "url": "https://eips.ethereum.org/EIPS/eip-7779", "title": "Interoperable Delegated Accounts", "authors": ["David Kim\u00a0(", "@PowerStream3604", ")", "Richard Meissner\u00a0(", "@rmeissner", ")", "Akshay Patel\u00a0(", "@akshay-ap", ")", "Joshua Kim\u00a0(", "@LightningHun", ")", "Fangting\u00a0(", "@trinity-0111", ")", "Yoav Weiss\u00a0(", "@yoavw", ")"], "sections": {"ERC-7779: Interoperable Delegated Accounts": "This proposal outlines the interfaces to make delegated EOAs interoperable after the merge ofEIP-7702. WithEIP-7702, EOAs will be able to enable execution abstraction, which leads to a more feature-rich account, including gas sponsorship, batch execution, and more.", "Interface for delegated externally owned accounts to enable better redelegation between wallets.": "This proposal outlines the interfaces to make delegated EOAs interoperable after the merge ofEIP-7702. WithEIP-7702, EOAs will be able to enable execution abstraction, which leads to a more feature-rich account, including gas sponsorship, batch execution, and more.", "Abstract": "This proposal outlines the interfaces to make delegated EOAs interoperable after the merge ofEIP-7702. WithEIP-7702, EOAs will be able to enable execution abstraction, which leads to a more feature-rich account, including gas sponsorship, batch execution, and more.", "Motivation": "After the merge ofEIP-7702, it is expected that a considerable number of EOA wallets will migrate from pure EOA accounts to delegated EOA accounts.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "accountId()": "This function is a view function to fetch the account information.", "accountStorageBases()": "This function returns the list of base storage slots of that account has used.", "onRedelegation()": "This function is to prepare for the redelegation to a new account.", "Rationale": "This standard is designed with the need of wallets to validate the storage of the EOA, even if some may consider that the probability of hash is already big that the account doesn\u2019t have to check, assuming that each wallet uses a different storage base slot.\nIn fact, this standard thinks exactly the opposite. It is worth scanning the storage, or at least the storage that the delegated account will use, which the wallet wants to delegate to. E.g., Just like developers validating the storage of Facets in Diamond (ERC-2535) to prevent storage collision and not just relying on hash probability.\nIn line with this, theaccountStorageBases()was designed to not only return the storage base of the current wallet implementation, but return the full historical storage slots that the account has used.\nThis could provide valuable information for the storage scanning of the EOA before delegation.", "Storage base checks": "This standard is designed with the need of wallets to validate the storage of the EOA, even if some may consider that the probability of hash is already big that the account doesn\u2019t have to check, assuming that each wallet uses a different storage base slot.\nIn fact, this standard thinks exactly the opposite. It is worth scanning the storage, or at least the storage that the delegated account will use, which the wallet wants to delegate to. E.g., Just like developers validating the storage of Facets in Diamond (ERC-2535) to prevent storage collision and not just relying on hash probability.\nIn line with this, theaccountStorageBases()was designed to not only return the storage base of the current wallet implementation, but return the full historical storage slots that the account has used.\nThis could provide valuable information for the storage scanning of the EOA before delegation.", "OptionalonRedelegation()": "onRedelegation()was designed to be optional to lower the barrier of being compliant with this standard. Also, there could be accounts that does not functionally require a hook-logic to be in place before redelegation, or accounts that does not suite with the design principle of theonRedelegation()e.g., excessive use of mapping or data types that\u2019s hard to uninitialize.", "Backwards Compatibility": "Existing smart accounts that was built prior to theEIP-7702discussion will need changes to support this standard.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7780, "url": "https://eips.ethereum.org/EIPS/eip-7780", "title": "Validation Module Extension for ERC-7579", "authors": ["zeroknots\u00a0(", "@zeroknots", ")", "Konrad Kopp\u00a0(", "@kopy-kat", ")", "Taek Lee\u00a0(", "@leekt", ")", "Fil Makarov\u00a0(", "@filmakarov", ")"], "sections": {"ERC-7780: Validation Module Extension for ERC-7579": "This proposal introduces three new module types on top of the existing modules described inERC-7579. The modules are policy, signer and stateless validator. None of these modules are required to be implemented by accounts, but accounts can choose to implement them or other modules can choose to make use of them for additional composability.", "Introduces new smart account module types for signature validation and permissioning": "This proposal introduces three new module types on top of the existing modules described inERC-7579. The modules are policy, signer and stateless validator. None of these modules are required to be implemented by accounts, but accounts can choose to implement them or other modules can choose to make use of them for additional composability.", "Abstract": "This proposal introduces three new module types on top of the existing modules described inERC-7579. The modules are policy, signer and stateless validator. None of these modules are required to be implemented by accounts, but accounts can choose to implement them or other modules can choose to make use of them for additional composability.", "Motivation": "The modules introduced by this proposal aim to create more composability around signature and permission verification.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Policy": "Policies MUST implementERC-7579\u2019sIModuleand theIPolicyinterface and have module type id:5.", "Signer": "Signers MUST implement theIModuleand theISignerinterface and have module type id:6.", "Stateless Validator": "Validators MUST implement theIStatelessValidatorinterface and have module type id:7. It is RECOMMENDED that all Validators (module type id1) also implement the Stateless Validator interface for additional composabillity.", "Rationale": "TBD", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7785, "url": "https://eips.ethereum.org/EIPS/eip-7785", "title": "Onchain registration of chain identifiers", "authors": ["Marco Stronati\u00a0(", "@paracetamolo", ")", "Jeff Lau\u00a0(", "@jefflau", ")"], "sections": {"ERC-7785: Onchain registration of chain identifiers": "This ERC proposes to derive chain identifiers as a digest of their chain name (and other information) and to use ENS to map chain names to identifiers in place of the centralized list on GitHub.\nA solution to support existing chain identifiers that were not derived following this ERC is also proposed.", "Derive chain identifiers by hashing their chain name and use ENS to map chain names to these identifiers": "This ERC proposes to derive chain identifiers as a digest of their chain name (and other information) and to use ENS to map chain names to identifiers in place of the centralized list on GitHub.\nA solution to support existing chain identifiers that were not derived following this ERC is also proposed.", "Abstract": "This ERC proposes to derive chain identifiers as a digest of their chain name (and other information) and to use ENS to map chain names to identifiers in place of the centralized list on GitHub.\nA solution to support existing chain identifiers that were not derived following this ERC is also proposed.", "Motivation": "The mapping between chain names and identifiers, such asMainnet -> 0x1, is currently maintained in a centralized list.\nHowever this solution has two main shortcomings:", "Chain Identifier Spoofing and Replay Attacks": "An important property of the centralized list is that it keeps a one-to-one correspondence between names and identifiers.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Extending chain identifiers": "Current chain identifiers are usually chosen arbitrarily to be short. While these identifiers are convenient on a small scale, as their number increases it is more desirable to draw them from a larger space.", "Chain name resolution": "Any ENS name can resolve to a chain identifier as specified inERC-2304. The name should resolve to a record containing not only the chain identifier, but also all the optional information necessary to verify the identifier.", "Rationale": "TBD", "Backwards Compatibility": "Existing identifiers, that were not derived using the scheme above, can be supported using a reverse mapping from chain identifiers to chain names, so that one can check for uniqueness.", "Bootstrapping and handover": "In order to bootstrap the handling of legacy chain identifiers, we imagine the EF populating thechainid.reversedomain, a temporaryl2.ethfor names and then handing them over.", "Security Considerations": "Domain spoofing can lead to replay attacks as described above and can be eliminated by deriving new identifiers using a hash function and by checking the reverse mapping for legacy identifiers.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7786, "url": "https://eips.ethereum.org/EIPS/eip-7786", "title": "Cross-Chain Messaging Gateway", "authors": ["Francisco Giordano\u00a0(", "@frangio", ")", "Hadrien Croubois\u00a0(", "@Amxx", ")", "Ernesto Garcia\u00a0(", "@ernestognw", ")", "CJ Cobb\u00a0(", "@cjcobb23", ")", "Sergey Gorbunov\u00a0(", "@sergeynog", ")"], "sections": {"ERC-7786: Cross-Chain Messaging Gateway": "This proposal describes an interface, and the corresponding workflow, for smart contracts to send arbitrary data through cross-chain messaging protocols. The end goal of this proposal is to have all such messaging protocols accessible via this interface (natively or using \u201cadapters\u201d) to improve their composability and interoperability. That would allow a new class of cross-chain native smart contracts to emerge while reducing vendor lock-in. This proposal is modular by design, allowing users to leverage bridge-specific features through attributes while providing simple \u201cuniversal\u201d access to the simple feature of \u201cjust getting a simple message through\u201d.", "An interface for contracts to send and receive cross-chain messages containing arbitrary data.": "This proposal describes an interface, and the corresponding workflow, for smart contracts to send arbitrary data through cross-chain messaging protocols. The end goal of this proposal is to have all such messaging protocols accessible via this interface (natively or using \u201cadapters\u201d) to improve their composability and interoperability. That would allow a new class of cross-chain native smart contracts to emerge while reducing vendor lock-in. This proposal is modular by design, allowing users to leverage bridge-specific features through attributes while providing simple \u201cuniversal\u201d access to the simple feature of \u201cjust getting a simple message through\u201d.", "Abstract": "This proposal describes an interface, and the corresponding workflow, for smart contracts to send arbitrary data through cross-chain messaging protocols. The end goal of this proposal is to have all such messaging protocols accessible via this interface (natively or using \u201cadapters\u201d) to improve their composability and interoperability. That would allow a new class of cross-chain native smart contracts to emerge while reducing vendor lock-in. This proposal is modular by design, allowing users to leverage bridge-specific features through attributes while providing simple \u201cuniversal\u201d access to the simple feature of \u201cjust getting a simple message through\u201d.", "Motivation": "Cross-chain messaging protocols (or bridges) allow communication between smart contracts deployed on different blockchains. There is a large diversity of such protocols with multiple degrees of decentralization, different architectures, implementing different interfaces, and providing different guarantees to users.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Message Field Encoding": "A cross-chain message consists of a sender, receiver, payload, and list of attributes.", "Sending Procedure": "AnSource Gatewayis a contract that offers a protocol to send a message to a receiver on another chain. It MUST implementIERC7786GatewaySource.", "Reception Procedure": "ADestination Gatewayis a contract that implements a protocol to validate messages sent on other chains. The interface of the destination gateway and how it is invoked is out of scope of this ERC.", "Properties": "The protocol underlying a pair of gateways is expected to guarantee a series of properties. For detailed definition and discussion we refer to XChain Research\u2019sCross-chain Interoperability Report.", "Rationale": "Attributes are designed so that gateways can expose any specific features the bridge offers without having to use a specific endpoint. Having a unique endpoint, with modularity through attributes, SHOULD allow contracts to change the gateway they use while continuing to express messages the same way. This portability offers many advantages:", "Backwards Compatibility": "Existing cross-chain messaging protocols implement proprietary interfaces. We recommend that protocols natively implement the standard interface defined here, and propose the development of standard adapters for those that don\u2019t.", "Security Considerations": "Unfortunately,CAIP-2andCAIP-10names are not unique. Using non-canonical strings may lead to undefined behavior, including message delivery failure and locked assets. While source gateways have a role to play in checking that user input are valid, we also believe that more effort should be put into standardizing and documenting what the canonical format is for eachCAIP-2namespace. This effort is beyond the scope of this ERC.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7787, "url": "https://eips.ethereum.org/EIPS/eip-7787", "title": "Soulbound Degradable Governance", "authors": ["Guilherme Neves\u00a0(", "@0xneves", ")", "Rafael Castaneda\u00a0<", "rafaelcastaneda@gmail.com", ">"], "sections": {"ERC-7787: Soulbound Degradable Governance": "This proposal introduces the Soulbound Degradable Governance (SDG) standard, where governance power should be granted as non-transferable tokens that decay over time unless renewed through participation. SDG enables young DAOs to implement merit-based governance by detaching governance power from economic power while on early stages of development.", "DAO governance where voting power is non-transferable and decays over time without active contributions.": "This proposal introduces the Soulbound Degradable Governance (SDG) standard, where governance power should be granted as non-transferable tokens that decay over time unless renewed through participation. SDG enables young DAOs to implement merit-based governance by detaching governance power from economic power while on early stages of development.", "Abstract": "This proposal introduces the Soulbound Degradable Governance (SDG) standard, where governance power should be granted as non-transferable tokens that decay over time unless renewed through participation. SDG enables young DAOs to implement merit-based governance by detaching governance power from economic power while on early stages of development.", "Motivation": "Traditional DAO governance models rely heavily on economic tokens, where voting power is proportional to token holdings. While effective for some use cases, this model risks concentrating power among wealthy members, leading to plutocracy and discouraging participation from smaller stakeholders. Furthermore, it fosters a treasury-centric culture that attracts contributors primarily focused on financial gain, rather than long-term governance or community well-being.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d,\n\u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as\ndescribed in RFC 2119 and RFC 8174.", "Contract Interface:": "The SDG standard ensures flexibility by not being tied to any specific token type, allowing DAOs to implement it withERC-20,ERC-721,ERC-1155, or other future token standards. This decision maximizes the compatibility and adaptability of the framework across different governance models.", "Rationale": "The SDG standard ensures flexibility by not being tied to any specific token type, allowing DAOs to implement it withERC-20,ERC-721,ERC-1155, or other future token standards. This decision maximizes the compatibility and adaptability of the framework across different governance models.", "Backwards Compatibility": "No backward compatibility issues found.", "Reference Implementation": "No security concerns were found.", "Security Considerations": "No security concerns were found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7794, "url": "https://eips.ethereum.org/EIPS/eip-7794", "title": "Grant Registry", "authors": ["Guilherme Neves\u00a0(", "@0xneves", ")"], "sections": {"ERC-7794: Grant Registry": "This proposal introduces a Grant Registry contract intended for managing financial, research, or project-based grants that provide funding for projects across multiple blockchains. The contract standardizes the registration, management, and tracking of these grants by organizing data into distinct categories, enabling clear separation between immutable fields and mutable fields. It supports modular disbursement tracking and allows for external links to off-chain documentation. This registry emits lifecycle events, enabling external protocols to efficiently access grant data, which promotes transparency, interoperability, and enhanced insights into grant program performance.", "A cross-network registry contract to manage and track grants, enhancing transparency and  interoperability for grant programs.": "This proposal introduces a Grant Registry contract intended for managing financial, research, or project-based grants that provide funding for projects across multiple blockchains. The contract standardizes the registration, management, and tracking of these grants by organizing data into distinct categories, enabling clear separation between immutable fields and mutable fields. It supports modular disbursement tracking and allows for external links to off-chain documentation. This registry emits lifecycle events, enabling external protocols to efficiently access grant data, which promotes transparency, interoperability, and enhanced insights into grant program performance.", "Abstract": "This proposal introduces a Grant Registry contract intended for managing financial, research, or project-based grants that provide funding for projects across multiple blockchains. The contract standardizes the registration, management, and tracking of these grants by organizing data into distinct categories, enabling clear separation between immutable fields and mutable fields. It supports modular disbursement tracking and allows for external links to off-chain documentation. This registry emits lifecycle events, enabling external protocols to efficiently access grant data, which promotes transparency, interoperability, and enhanced insights into grant program performance.", "Motivation": "The Ethereum ecosystem currently lacks a standardized way to manage and track grants across different chains and programs, leading to inefficiencies and fragmentation. Each grant program has its own distinct interface, processes, and management mechanisms, which creates barriers for both funders and grantees. These issues hinder transparency, complicate the tracking of fund disbursements, and make it difficult to evaluate the overall effectiveness of grant programs across different networks.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Contract Interface": "When calling theregisterGrantfunction:", "Rationale": "The design of this Grant Registry Contract is driven by the need for a flexible and modular system that supports a wide range of grant programs across different chains. The rationale for the key design decisions is outlined below:", "Backwards Compatibility": "No backward compatibility issues found.", "Reference Implementation": "Key considerations for this implementation:", "Security Considerations": "No security concerns were found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7795, "url": "https://eips.ethereum.org/EIPS/eip-7795", "title": "Wallet Call Token Capabilities", "authors": ["Agust\u00edn Aguilar\u00a0(", "@agusx1211", ")", "Michael Standen\u00a0(", "@ScreamingHawk", ")", "Peter Kieltyka\u00a0(", "@pkieltyka", ")", "William Hua\u00a0(", "@attente", ")", "Philippe Castonguay\u00a0(", "@PhABC", ")"], "sections": {"ERC-7795: Wallet Call Token Capabilities": "This ERC extendsEIP-5792by defining capabilities that allow dApps to specify common token prerequisites for transactions, such as having certainERC-20,ERC-721, orERC-1155tokens. Wallets can then help users meet these requirements before executing the transactions.", "Wallet Call API extension for transaction prerequisites for common token types": "This ERC extendsEIP-5792by defining capabilities that allow dApps to specify common token prerequisites for transactions, such as having certainERC-20,ERC-721, orERC-1155tokens. Wallets can then help users meet these requirements before executing the transactions.", "Abstract": "This ERC extendsEIP-5792by defining capabilities that allow dApps to specify common token prerequisites for transactions, such as having certainERC-20,ERC-721, orERC-1155tokens. Wallets can then help users meet these requirements before executing the transactions.", "Motivation": "It is fairly common for dApps to reside only on one network, but this comes at the cost of shrinking the direct liquidity that these dApps can access. This happens because most users only have funds on a limited number of networks. As the number of networks grows, the likelihood of intersection between the networks chosen by the dApp and the user decreases.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "ERC-20 Minimum Balance Capability": "A dApp can use theerc20MinBalancecapability in awallet_sendCallsrequest to request that a wallet ensure the owner has a minimum balance of a specifiedERC-20token.", "ERC-20 Minimum Allowance Capability": "A dApp can use theerc20MinAllowancecapability in awallet_sendCallsrequest to request that a wallet ensure the owner has a minimum allowance of a specifiedERC-20token.\nNote this capability does not imply that the owner has a balance of the token, only that the allowance is equal to or greater than the specified amount.", "ERC-721 Ownership Capability": "A dApp can use theerc721Ownershipcapability in awallet_sendCallsrequest to request that a wallet ensure the owner has ownership of a specifiedERC-721token.", "ERC-721 Approval Capability": "A dApp can use theerc721Approvalcapability in awallet_sendCallsrequest to request that a wallet ensure the owner has approved a specifiedERC-721token.\nNote this capability does not imply that the owner has a balance of the token, only that the allowance is equal to or greater than the specified amount.", "ERC-1155 Minimum Balance Capability": "A dApp can use theerc1155MinBalancecapability in awallet_sendCallsrequest to request that a wallet ensure the owner has a minimum balance of a specifiedERC-1155token.", "ERC-1155 Minimum Allowance Capability": "A dApp can use theerc1155MinAllowancecapability in awallet_sendCallsrequest to request that a wallet ensure the owner has a minimum allowance of a specifiedERC-1155token.\nNote this capability does not imply that the owner has a balance of the token, only that the allowance is equal to or greater than the specified amount.", "Usage Examples": "This ERC serves as a foundational component for building user experiences that rely on cross-chain actions. It can be leveraged in various ways, depending on the combination of use cases and wallet implementations. Consider the following high-level examples.", "Rationale": "This ERC extendsEIP-5792rather than defining new RPC methods because:", "Security Considerations": "This ERC does not introduce any new security risks or trust assumptions.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7796, "url": "https://eips.ethereum.org/EIPS/eip-7796", "title": "Conditional send transaction RPC", "authors": ["Dror Tirosh\u00a0(", "@drortirosh", ")", "Yoav Weiss\u00a0(", "@yoavw", ")", "Alex Forshtat\u00a0(", "@forshtat", ")", "Shahaf Nacson\u00a0(", "@shahafn", ")"], "sections": {"ERC-7796: Conditional send transaction RPC": "This EIP proposes a new JSON-RPC API methodeth_sendRawTransactionConditionalfor block builders and sequencers,\nenhancing transaction integration by allowing users to express preconditions for transaction inclusion.", "JSON-RPC API for block builders allowing users to express preconditions for transaction inclusion": "This EIP proposes a new JSON-RPC API methodeth_sendRawTransactionConditionalfor block builders and sequencers,\nenhancing transaction integration by allowing users to express preconditions for transaction inclusion.", "Abstract": "This EIP proposes a new JSON-RPC API methodeth_sendRawTransactionConditionalfor block builders and sequencers,\nenhancing transaction integration by allowing users to express preconditions for transaction inclusion.", "Motivation": "Current private block builder APIs, such as the Flashbots API,\nrequire block builders to simulate transactions to determine eligibility for inclusion,\na process that is CPU-intensive and inefficient.", "Specification": "Before accepting the request, the block builder or sequencer SHOULD:", "Return value": "In case of a successful inclusion, the call should return a hash of the newly submitted transaction.\nThis behaviour is equivalent to theeth_sendRawTransactionJSON-RPC API method.", "Sample request": "TheknownAccountsonly allows specifying the exact values for storage slots.\nWhile in some cases specifyingminValueormaxValuefor a slot could be useful,\nit would significantly increase complexity of the proposed API.\nAdditionally, determining the validity range for a slot value is a non-trivial task for the sender of a transaction.", "Limitations": "TheknownAccountsonly allows specifying the exact values for storage slots.\nWhile in some cases specifyingminValueormaxValuefor a slot could be useful,\nit would significantly increase complexity of the proposed API.\nAdditionally, determining the validity range for a slot value is a non-trivial task for the sender of a transaction.", "Rationale": "TheknownAccountsonly allows specifying the exact values for storage slots.\nWhile in some cases specifyingminValueormaxValuefor a slot could be useful,\nit would significantly increase complexity of the proposed API.\nAdditionally, determining the validity range for a slot value is a non-trivial task for the sender of a transaction.", "Backwards Compatibility": "This is a proposal for a new API method so no backward compatibility issues are expected.\nExisting non-standard implementations ofeth_sendRawTransactionConditionalAPI may need to be modified in order to\nbecome compatible with the standard.", "Security Considerations": "The block builder should protect itself against abuse of the API.\nNamely, a malicious actor submitting a large number of requests which are known to fail may lead to a denial of service.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7802, "url": "https://eips.ethereum.org/EIPS/eip-7802", "title": "Token With Mint/Burn Access Across Chains", "authors": ["skeletor\u00a0(", "@skeletor-spaceman", ")", "parti\u00a0(", "@0xParticle", ")", "joxes\u00a0(", "@Joxess", ")", "ng\u00a0(", "@0xng", ")", "agus duha\u00a0(", "@agusduha", ")", "disco\u00a0(", "@0xDiscotech", ")", "gotzen\u00a0<", "gotzen@defi.sucks", ">", "0age\u00a0<", "0age@uniswap.org", ">", "Mark Tyneway\u00a0<", "mark@oplabs.co", ">", "Zain Bacchus\u00a0<", "zain@oplabs.co", ">", "Matt Solomon\u00a0<", "msolomon@oplabs.co", ">", "Maurelian\u00a0<", "maurelian@protonmail.ch", ">", "Blaine Malone\u00a0(", "@blmalone", ")"], "sections": {"ERC-7802: Token With Mint/Burn Access Across Chains": "This standard introduces a minimal and extensible interface,IERC7802, for tokens to enable standardized crosschain communication. The interface consists of two functions,crosschainMintandcrosschainBurn, which allow authorized bridge contracts to mint and burn token representations during crosschain transfers. These functions serve as the entry points for bridge logic, enabling consistent handling of token supply across chains.", "Allow authorized contracts to mint and burn token representations during crosschain transfers": "This standard introduces a minimal and extensible interface,IERC7802, for tokens to enable standardized crosschain communication. The interface consists of two functions,crosschainMintandcrosschainBurn, which allow authorized bridge contracts to mint and burn token representations during crosschain transfers. These functions serve as the entry points for bridge logic, enabling consistent handling of token supply across chains.", "Abstract": "This standard introduces a minimal and extensible interface,IERC7802, for tokens to enable standardized crosschain communication. The interface consists of two functions,crosschainMintandcrosschainBurn, which allow authorized bridge contracts to mint and burn token representations during crosschain transfers. These functions serve as the entry points for bridge logic, enabling consistent handling of token supply across chains.", "Motivation": "All rollups and multiple important sidechains implement canonical bridges that embed their security into some part of the network\u2019s core architecture. These bridges do not have mint/burn rights over original tokens, so they usually lock (unlock) liquidity on the native chain and then mint (burn) a non-equivalent representation on the other. Mint/burn is used because the native token is non-existent on that side, so they must create a new representation. However, each bridge implements a different interface for minting/burning on non-native chains.", "Specification": "This ERC introduces theIERC7802interface.", "Interface Identification": "The interface identifier forIERC7802is0x33331994, calculated according toERC-165as the XOR of the function selectors of the two functions in the interface:", "Methods": "crosschainMint", "Events": "CrosschainMint", "Rationale": "The core design decisions behind this minimal interface are", "Design philosophy": "The core design decisions behind this minimal interface are", "Separation of Local and crosschain Minting/Burning": "Different actions", "ERC-165 Interface": "The inclusion of ERC-165 provides an additional security check for integrators. By providing the interface identifier through thesupportsInterfacemethod, callers can programmatically confirm that the token adheres to theIERC7802interface. \nThis verification ensures that the token supports bothcrosschainMintandcrosschainBurnfunctions, preventing scenarios where only one function is implemented. Such incomplete implementations could lead to issues like users burning tokens to bridge out but being unable to mint them upon return, resulting in failed crosschain actions.", "Backwards Compatibility": "This proposal is fully backwards compatible withERC-20.", "Reference Implementation": "Token issuers are responsible for controlling which contracts are authorized to call thecrosschainMint()andcrosschainBurn()functions. A buggy or malicious authorized caller could mint or burn tokens improperly, damaging token holders and disrupting integrations.", "Security Considerations": "Token issuers are responsible for controlling which contracts are authorized to call thecrosschainMint()andcrosschainBurn()functions. A buggy or malicious authorized caller could mint or burn tokens improperly, damaging token holders and disrupting integrations.", "Permissions": "Token issuers are responsible for controlling which contracts are authorized to call thecrosschainMint()andcrosschainBurn()functions. A buggy or malicious authorized caller could mint or burn tokens improperly, damaging token holders and disrupting integrations.", "Wrapped Native Tokens": "This standard should not be used for wrapped native tokens like WETH, as it can lead to uncollateralized minting if the bridge does not control the underlying asset.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7803, "url": "https://eips.ethereum.org/EIPS/eip-7803", "title": "EIP-712 Extensions for Account Abstraction", "authors": ["Francisco Giordano\u00a0(", "@frangio", ")"], "sections": {"ERC-7803: EIP-712 Extensions for Account Abstraction": "This ERC improves onEIP-712signatures to better support smart contract accounts by 1) introducing signing domains as a way to prevent replay attacks when private keys are shared across accounts, and 2) allowing dapps and wallets to coordinate on the method that will be used to authenticate the signature.", "Improvements for EIP-712 to support smart contract accounts.": "This ERC improves onEIP-712signatures to better support smart contract accounts by 1) introducing signing domains as a way to prevent replay attacks when private keys are shared across accounts, and 2) allowing dapps and wallets to coordinate on the method that will be used to authenticate the signature.", "Abstract": "This ERC improves onEIP-712signatures to better support smart contract accounts by 1) introducing signing domains as a way to prevent replay attacks when private keys are shared across accounts, and 2) allowing dapps and wallets to coordinate on the method that will be used to authenticate the signature.", "Motivation": "Standards likeERC-1271andERC-6492give smart contract accounts (SCAs) the ability to produce signatures that an application can authenticate without knowledge of the abstract rules of the account. This is an important primitive for applications, as the account owner is able to authorize a third-party to act on its behalf without interacting with the chain.", "Signing Domains": "Standards likeERC-1271andERC-6492give smart contract accounts (SCAs) the ability to produce signatures that an application can authenticate without knowledge of the abstract rules of the account. This is an important primitive for applications, as the account owner is able to authorize a third-party to act on its behalf without interacting with the chain.", "Authentication Methods": "ERC-1271 is a minimal and very general interface that has been very effective. It requires the contract code to be already deployed by the time the signature needs to be authenticated, so ERC-6492 extends ERC-1271 to support that use case. In the future additional methods may need to be developed.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "signingDomains": "This property is an array of smart contract account domains. Each member of the array is an object with the following keys:", "authMethods": "This property is an array of supported signature authentication methods, listed in the order that the verifying domain tries them.", "JSON Schema": "Needs discussion.", "Rationale": "Needs discussion.", "Backwards Compatibility": "Needs discussion.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7811, "url": "https://eips.ethereum.org/EIPS/eip-7811", "title": "Wallet Asset Discovery", "authors": ["Luka Isailovic\u00a0(", "@lukaisailovic", ")", "Konrad Kopp\u00a0(", "@kopy-kat", ")", "Derek Rein\u00a0(", "@arein", ")", "Chris Smith\u00a0(", "@chris13524", ")"], "sections": {"ERC-7811: Wallet Asset Discovery": "This ERC introduces a new RPC call,wallet_getAssets, for wallets to declare to the Dapp what assets are owned by the user. This allows for more accurate asset discovery and the use of assets that aren\u2019t available on-chain but can be provided by the wallet", "JSON-RPC method for wallets to share a user\u2019s full asset list with Dapps, including assets not easily found through on-chain data alone": "This ERC introduces a new RPC call,wallet_getAssets, for wallets to declare to the Dapp what assets are owned by the user. This allows for more accurate asset discovery and the use of assets that aren\u2019t available on-chain but can be provided by the wallet", "Abstract": "This ERC introduces a new RPC call,wallet_getAssets, for wallets to declare to the Dapp what assets are owned by the user. This allows for more accurate asset discovery and the use of assets that aren\u2019t available on-chain but can be provided by the wallet", "Motivation": "Currently, Dapps primarily rely on on-chain data to determine a user\u2019s balance, which can be limiting. Furthermore, a Dapp might restrict the user from initiating actions that the wallet could otherwise resolve, as it cannot account for the total assets a user has across different accounts or chains.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Method:wallet_getAssets": "accountis aREQUIREDfield that indicates for which account assets are requested.", "Well-known asset types": "Below are expansions ofmetadatafor well-known asset types. Implementations that are compliant with this ERC and return these well-known asset typesMUSTreturn at least these fields inmetadata. ImplementationsMAYreturn more fields than specified here.\nThis ERC does not specify an exhaustive list of asset types.\nSince the type is a generic string, there could be a mismatch between the type Dapp expects and the one returned by the wallet.\nIt\u2019s important that no two assets share the same type.\nTherefore, new asset types should be specified in future ERCs.", "Capabilities": "If the wallet is usingCAIP-25authorization, walletSHOULDincludewallet_getAssetsin themethodsarray insessionScopesofeip155namespace.", "Rationale": "Copyright and related rights waived viaCC0.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- treturn: A new opcode that allows returning data directly from transient storage without first copying it to memory.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7812, "url": "https://eips.ethereum.org/EIPS/eip-7812", "title": "ZK Identity Registry", "authors": ["Artem Chystiakov (@arvolear)\u00a0<", "artem@rarilabs.com", ">", "Oleksandr Kurbatov\u00a0<", "oleksandr@rarilabs.com", ">", "Yaroslav Panasenko\u00a0<", "yaroslav@rarilabs.com", ">", "Michael Elliot (@michaelelliot)\u00a0<", "mike@zkpassport.id", ">", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"ERC-7812: ZK Identity Registry": "This EIP introduces an on-chain registry system for storing and proving abstract statements. Users may utilize the system to store commitments to their private data to later prove its validity and authenticity via zero knowledge, without disclosing anything about the data itself. Moreover, developers may use the singletonEvidenceRegistrycontract available at0x781268D46a654D020922f115D75dd3D56D287812to integrate custom business-specific registrars for managing and processing particular statements.", "Singleton registry system for storing abstract private provable statements.": "This EIP introduces an on-chain registry system for storing and proving abstract statements. Users may utilize the system to store commitments to their private data to later prove its validity and authenticity via zero knowledge, without disclosing anything about the data itself. Moreover, developers may use the singletonEvidenceRegistrycontract available at0x781268D46a654D020922f115D75dd3D56D287812to integrate custom business-specific registrars for managing and processing particular statements.", "Abstract": "This EIP introduces an on-chain registry system for storing and proving abstract statements. Users may utilize the system to store commitments to their private data to later prove its validity and authenticity via zero knowledge, without disclosing anything about the data itself. Moreover, developers may use the singletonEvidenceRegistrycontract available at0x781268D46a654D020922f115D75dd3D56D287812to integrate custom business-specific registrars for managing and processing particular statements.", "Motivation": "This EIP stemmed from the need to localize and unravel the storage and issuance of provable statements so that future protocols can anchor to the standardized singleton on-chain registry and benefit from cross-reuse.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Definitions": "The on-chain registry system consists of two subsystems: theEvidenceRegistrywithEvidenceDBandRegistrarcomponents. This EIP will focus on describing and standardizing the former, while theRegistrarspecification may be amended as the separate proposals.", "General": "The on-chain registry system consists of two subsystems: theEvidenceRegistrywithEvidenceDBandRegistrarcomponents. This EIP will focus on describing and standardizing the former, while theRegistrarspecification may be amended as the separate proposals.", "Evidence DB": "TheEvidenceDBsmart contract MAY implement an arbitrary provable key/value data structure, however it MUST support theaddition,update, andremovalof elements. All of the supported write operations MUST maintain the property of idempotence (e.i.additionfollowed byremovalshould not change the state of the database). The data structure of choice MUST be capable of providing both element inclusion and exclusion proofs. The functions that modify theEvidenceDBstate MUST be callable only by theEvidenceRegistry.", "Evidence Registry": "TheEvidenceRegistrysmart contract is the central piece of this EIP. TheEvidenceRegistryMUST implement the following interface, however, it MAY be extended:", "Hash Function": "The same secure hash function MUST be employed in bothEvidenceRegistryandEvidenceDB. It is RECOMMENDED to use ZK-friendly hash function such asposeidonto streamline the database proving.", "Rationale": "During the EIP specification we have considered two approaches: where every protocol has its own registry and where all protocols are united under a singleton registry. We have decided to go with the latter as this approach provides the following benefits:", "Backwards Compatibility": "This EIP is fully backwards compatible.", "Deployment Method": "TheEvidenceRegistryis a singleton contract available at0x781268D46a654D020922f115D75dd3D56D287812deployed via the \u201cdeterministic deployment proxy\u201d from0x4e59b44847b379578588920ca78fbf26c0b4956cwith the salt0x9a533395526948e0860194b5dbd307de82d332d7fb268e02659096f3c904bf9f.", "Reference Implementation": "The reference implementation ofEvidenceRegistryandEvidenceDBSolidity smart contracts together with the evidence registry state verifier Circom circuit is provided in the proposal.", "EvidenceDB Implementation": "From security standpoint there are several important aspects that must be highlighted.", "EvidenceRegistry Implementation": "From security standpoint there are several important aspects that must be highlighted.", "EvidenceRegistry Verifier Implementation": "From security standpoint there are several important aspects that must be highlighted.", "Security Considerations": "From security standpoint there are several important aspects that must be highlighted.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7813, "url": "https://eips.ethereum.org/EIPS/eip-7813", "title": "Store, Table-Based Introspectable Storage", "authors": ["alvarius\u00a0(", "@alvrs", ")", "dk1a\u00a0(", "@dk1a", ")", "frolic\u00a0(", "@holic", ")", "ludens\u00a0(", "@ludns", ")", "vdrg\u00a0(", "@vdrg", ")", "yonada\u00a0<", "yonada@proton.me", ">"], "sections": {"ERC-7813: Store, Table-Based Introspectable Storage": "This standard introduces a flexible on-chain storage pattern that organizes data into structured tables that consist of records with fixed key and value schemas, similar to a traditional database. This storage pattern consists of a unified contract interface for data access, along with a compact binary encoding format for both static and dynamic data types. State changes are tracked through standardized events that enable automatic, schema-aware state replication by off-chain indexers. New tables can be dynamically registered at runtime through a special table that stores schema metadata for all tables, allowing the system to evolve without breaking existing contracts or integrations.", "On-chain tables for automatic indexing and introspectable state": "This standard introduces a flexible on-chain storage pattern that organizes data into structured tables that consist of records with fixed key and value schemas, similar to a traditional database. This storage pattern consists of a unified contract interface for data access, along with a compact binary encoding format for both static and dynamic data types. State changes are tracked through standardized events that enable automatic, schema-aware state replication by off-chain indexers. New tables can be dynamically registered at runtime through a special table that stores schema metadata for all tables, allowing the system to evolve without breaking existing contracts or integrations.", "Abstract": "This standard introduces a flexible on-chain storage pattern that organizes data into structured tables that consist of records with fixed key and value schemas, similar to a traditional database. This storage pattern consists of a unified contract interface for data access, along with a compact binary encoding format for both static and dynamic data types. State changes are tracked through standardized events that enable automatic, schema-aware state replication by off-chain indexers. New tables can be dynamically registered at runtime through a special table that stores schema metadata for all tables, allowing the system to evolve without breaking existing contracts or integrations.", "Motivation": "The absence of consistent standards for on-chain data management in smart contracts can lead to rigid implementations, tightly coupled contract logic with off-chain services, and challenges in updating or extending a contract\u2019s data layout without breaking existing integrations.", "Specification": "A smart contract that implements the interface proposed by this ERC and organizes data in Tables. It emits events for each data operation so that off-chain components can replicate the state of all tables.", "Definitions": "A smart contract that implements the interface proposed by this ERC and organizes data in Tables. It emits events for each data operation so that off-chain components can replicate the state of all tables.", "Packed Data Encoding": "Record data returned by Store methods and included in Store events uses the following encoding rules.", "Store Interface": "All Stores MUST implement the following interface.", "Store Operations and Events": "This standard defines three core operations for manipulating records in a table: setting, updating, and deleting. For each operation, specific events must be emitted. The implementation details of these operations are left to the discretion of each Store implementation.", "TheTablestable": "To keep track of the information of each table and support registering new tables at runtime, the Store implementation MUST include a special on-chainTablestable, which behaves the same way as other on-chain tables except for the special constraints mentioned below.", "Rationale": "While theStore_SetRecordevent suffices for tracking the data of each record off-chain, includingSpliceevents (Store_SpliceStaticDataandStore_SpliceDynamicData) allows for more efficient partial updates. When only a portion of a record changes, emitting a fullSetRecordevent would be inefficient because the entire record data would need to be read from storage and emitted.Spliceevents enable the store to emit only the minimal necessary data for the update, reducing gas consumption. This is particularly important for records with large dynamic fields, as the cost of updating them doesn\u2019t grow with the field\u2019s size.", "Splice Events": "While theStore_SetRecordevent suffices for tracking the data of each record off-chain, includingSpliceevents (Store_SpliceStaticDataandStore_SpliceDynamicData) allows for more efficient partial updates. When only a portion of a record changes, emitting a fullSetRecordevent would be inefficient because the entire record data would need to be read from storage and emitted.Spliceevents enable the store to emit only the minimal necessary data for the update, reducing gas consumption. This is particularly important for records with large dynamic fields, as the cost of updating them doesn\u2019t grow with the field\u2019s size.", "Disallowing Arrays of Dynamic Types": "Arrays of dynamic types (e.g.,string[],bytes[]) are intentionally not included as supportedSchemaTypes. This restriction enforces a flat data schema, which simplifies the store implementation and enhances efficiency. If users need to store such data structures, they can model them using a separate table with a schema like{ index: uint256, data: bytes }, where each array element is represented as an individual record.", "FieldLayout Optimization": "Including theFieldLayoutin theTablesschema provides an on-chain optimization by precomputing and storing the exact byte lengths of static fields. This eliminates the need to repeatedly compute field lengths and offsets during runtime, which can be gas-intensive. By having this information readily available, the store can perform storage operations more efficiently, while components reading from the store can retrieve it from theTablestable to decode the corresponding records.", "SpecialTablestable": "Including a specialTablestable provides significant benefits for off-chain indexers. While emitting events for table registration isn\u2019t strictly necessary for basic indexers that operate on raw encoded data, doing so makes indexers aware of the schemas used by each table. This awareness enables the development of more advanced, schema-aware indexer APIs (e.g., SQL-like query capabilities), enhancing the utility and flexibility of off-chain data interactions.", "Reference Implementation": "The following example shows how a simple in-memory indexer can use the Store events to replicate the Store state off-chain. It is important to note that this indexer operates over raw encoded data which is not that useful on its own, but can be improved as we will explain in the next section.", "Store Event Indexing": "The following example shows how a simple in-memory indexer can use the Store events to replicate the Store state off-chain. It is important to note that this indexer operates over raw encoded data which is not that useful on its own, but can be improved as we will explain in the next section.", "Security Considerations": "This standard only defines functions toreadfrom the Store (getRecord,getField, andgetFieldLength). The methods for setting or modifying records in the store are left to each specific implementation. Therefore, implementationsmust provide appropriate access control mechanismsfor writing to the store, tailored to their specific use cases.", "Access Control": "This standard only defines functions toreadfrom the Store (getRecord,getField, andgetFieldLength). The methods for setting or modifying records in the store are left to each specific implementation. Therefore, implementationsmust provide appropriate access control mechanismsfor writing to the store, tailored to their specific use cases.", "On-Chain Data Accessibility": "All data stored within a store is accessible not only off-chain but alsoon-chainby other smart contracts through the provided read functions (getRecord,getField, andgetFieldLength). This differs from the typical behavior of smart contracts, where internal storage variables are private by default and cannot be directly read by other contracts unless explicit getter functions are provided. Thus, developers must be mindful that any data stored in the store is openly accessible to other smart contracts.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7821, "url": "https://eips.ethereum.org/EIPS/eip-7821", "title": "Minimal Batch Executor Interface", "authors": ["Vectorized\u00a0(", "@Vectorized", ")", "Jake Moxey\u00a0(", "@jxom", ")", "Hadrien Croubois\u00a0(", "@Amxx", ")"], "sections": {"ERC-7821: Minimal Batch Executor Interface": "This proposal defines a minimal batch executor interface for delegations. A delegation is a smart contract that implements logic which other smart contracts can delegate to. This allows atomic batched executions to be prepared in a standardized way.", "A minimal batch executor interface for delegations": "This proposal defines a minimal batch executor interface for delegations. A delegation is a smart contract that implements logic which other smart contracts can delegate to. This allows atomic batched executions to be prepared in a standardized way.", "Abstract": "This proposal defines a minimal batch executor interface for delegations. A delegation is a smart contract that implements logic which other smart contracts can delegate to. This allows atomic batched executions to be prepared in a standardized way.", "Motivation": "With the advent ofEIP-7702, it is possible for Externally Owned Accounts (EOAs) to perform atomic batched executions.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Overview": "The minimal batch executor interface is defined as follows:", "Recommendations": "To support the approve + swap workflow on EOAs with delegations, frontends SHOULD:", "Rationale": "We aim for radical minimalism to keep the standard as left-curved as possible. Simplicity is the key to adoption. Our North Star is to get every decentralized exchange to support the approve + swap workflow for EOAs with delegations as soon as possible.", "executeandsupportsExecutionMode": "We have opted to use theexecuteandsupportsExecutionModefunctions inERC-7579for better compatibility with the existing smart account ecosystem.", "Optional encoding ofopDatainexecutionData": "TheopDatabytes parameter can be optionally included inexecutionDataby either doingabi.encode(calls)orabi.encode(calls, opData).", "Replacingaddress(0)withaddress(this)": "For calldata compression optimization.", "Optional batch of batches mode": "TheopDatamay be used to provide authentication data for a single batch. Having a batch of batches mode will enable a single transaction to be able to submit batches signed by different signers, without the need for an authorized entry point. This mode is kept optional because the same functionality can still be achieved with the use of an authorized entry point. It is included for developer experience.", "Backwards Compatibility": "No backwards compatibility issues.", "Reference Implementation": "Implementations should ensure thatexecutehave the proper access controls.", "Security Considerations": "Implementations should ensure thatexecutehave the proper access controls.", "Access controls forexecute": "Implementations should ensure thatexecutehave the proper access controls.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7829, "url": "https://eips.ethereum.org/EIPS/eip-7829", "title": "Data Asset NFT", "authors": ["Allen Dong\u00a0(", "@Allen2730", ")", "Lonika Zhang\u00a0<", "lonika@memolabs.net", ">", "Steven He\u00a0<", "steven@memolabs.net", ">"], "sections": {"ERC-7829: Data Asset NFT": "This proposal is an extension ofERC-721. This proposal introduces a new role, Reader, who is granted by the Owner and allows multiple Readers for a single NFT. Additionally, this proposal extends the metadata interface of ERC-721, requiring that metadata should include at least a commitment, size, expire, and uploader\u2019s address. This proposal also proposes a storage proof mechanism to ensure the correctness of metadata information.", "Bring Data Assets, which refers to the online digital products, to NFTs and ensure the integrity of data asset NFTs through storage proof.": "This proposal is an extension ofERC-721. This proposal introduces a new role, Reader, who is granted by the Owner and allows multiple Readers for a single NFT. Additionally, this proposal extends the metadata interface of ERC-721, requiring that metadata should include at least a commitment, size, expire, and uploader\u2019s address. This proposal also proposes a storage proof mechanism to ensure the correctness of metadata information.", "Abstract": "This proposal is an extension ofERC-721. This proposal introduces a new role, Reader, who is granted by the Owner and allows multiple Readers for a single NFT. Additionally, this proposal extends the metadata interface of ERC-721, requiring that metadata should include at least a commitment, size, expire, and uploader\u2019s address. This proposal also proposes a storage proof mechanism to ensure the correctness of metadata information.", "Motivation": "ERC-721 proposed the NFTs to represent the ownership of digital or physical assets. Currently, the NFT metadata is considered the NFT content, and its scarcity determines the value of the NFT. NFT owners can convert the content value of NFTs into revenue by transferring the ownership of NFTs. However, due to the high transaction fees, storage costs, and other expenses, NFTs are currently only able to represent the ownership of high-value assets, which limits the range of assets that NFTs can represent. This is especially true for Data Assets, which refers to digital products created by creators, such as online blogs, videos, small games or music. Therefore, the value of Data Assets depends on their quality, whether the creator is famous, whether it is hyped and so on.", "Specification": "In this proposal, we divide data assets into three parts:", "Terms": "In this proposal, we divide data assets into three parts:", "Extension: Storage Contract": "This proposal extends the metadata information of NFTs. Metadata information is uploaded by users and requires relevant certificates, which can be the storage node\u2019s signature on the NFT\u2019s metadata information. This proposal specify that the NFT metadata should at least include commitment, size, expire, and uploader\u2019s address.", "Extension: Storage Proof": "This proposal uses storage proof to prove the availability of data content, thereby proving the correctness of NFT metadata, especially theexpireof the NFT.", "Rationale": "", "Backwards Compatibility": "This proposal combines the existing 721 extension and is backward compatible with the ERC-721 standard.", "Security Considerations": "The security of Data Asset NFTs depends not only on the blockchain but also on the modular data layer DA. Therefore, the implementer of this proposal needs to carefully select the modular data layer DA.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7831, "url": "https://eips.ethereum.org/EIPS/eip-7831", "title": "Multi-Chain Addressing", "authors": ["Sam Wilson (@SamWilsn)\u00a0<", "sam@binarycake.ca", ">"], "sections": {"ERC-7831: Multi-Chain Addressing": "This proposal introduces a chain-specific address format that allows specifying both an account and the chain on which that account intends to transact. These chain-specific addresses take the form of(example.eth:optimism),6A10161835a36302BfD39bDA9B44f5734442234e:ethereum:11155111, and so on. The target chain is resolved using a registry stored on ENS.", "Textual representation of an address and a chain.": "This proposal introduces a chain-specific address format that allows specifying both an account and the chain on which that account intends to transact. These chain-specific addresses take the form of(example.eth:optimism),6A10161835a36302BfD39bDA9B44f5734442234e:ethereum:11155111, and so on. The target chain is resolved using a registry stored on ENS.", "Abstract": "This proposal introduces a chain-specific address format that allows specifying both an account and the chain on which that account intends to transact. These chain-specific addresses take the form of(example.eth:optimism),6A10161835a36302BfD39bDA9B44f5734442234e:ethereum:11155111, and so on. The target chain is resolved using a registry stored on ENS.", "Motivation": "The Ethereum ecosystem is becoming steadily more fragmented. This means a 20 byte address by itself is not enough information to fully specify an account. This can be problematic if funds are sent to an unreachable address on the incorrect chain.", "Why not ENS withERC-2304?": "WhileERC-2304allows registrants to specify per-chain addresses, it does not provide a default chain to receive assets on (nor should it.) The choice of receiving chain depends too much on off-chain factors to require a transaction to change.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described inRFC 2119andRFC 8174.", "Definitions": "The following terms are used throughout this proposal:", "Syntax": "At a high level, a chain-specific address is made of three components separated by colons (:) ordered from most general on the right to most specific on the left:", "Resolution": "Resolving a chain-specific address begins on the right, and moves leftward.", "Bridge Interface": "Bridge contracts MUST implement the following interface:", "Checksum": "Hexadecimal strings are cased according to a slightly modifiedERC-55algorithm. The algorithm is modified by wrappingnibble_indexto fit within the keccak hash.", "Rationale": "The components are ordered from most specific to most general because\u2026", "Component Order": "The components are ordered from most specific to most general because\u2026", "Separator Choice": "The colon (:) is a reasonable choice for separator because it is not an allowed character in ENS names, it is familiar (eg. IPv6), and isn\u2019t as overloaded as the@symbol.", "Target Chain as Subdomain": "While it would be technically possible to resolvechain-partagainst a root ENS name (eg.ethereum.ethinstead ofethereum.tbd.eth), using a subdomain allows the pre-registration of well-known chain names for an initial distribution of names before switching to open registration.", "Backwards Compatibility": "It is always possible to determine whether a particular string is a chain-specific address, a plain address, or a plain ENS name. Because of this property, there is little opportunity for backwards incompatibility: chain-specific addresses are not valid legacy addresses or ENS names, so tools without support will simply reject them.", "Test Cases": "An attacker could register ENS names that resemble well-known chain names. For example,etheriumandehtereumare reasonably close toethereum. While many unicode homoglyphs are caught by ENS libraries, agents should still be aware of the risk they pose.", "ENS Configuration": "An attacker could register ENS names that resemble well-known chain names. For example,etheriumandehtereumare reasonably close toethereum. While many unicode homoglyphs are caught by ENS libraries, agents should still be aware of the risk they pose.", "Inputs & Expected Outputs": "An attacker could register ENS names that resemble well-known chain names. For example,etheriumandehtereumare reasonably close toethereum. While many unicode homoglyphs are caught by ENS libraries, agents should still be aware of the risk they pose.", "Reference Implementation": "An attacker could register ENS names that resemble well-known chain names. For example,etheriumandehtereumare reasonably close toethereum. While many unicode homoglyphs are caught by ENS libraries, agents should still be aware of the risk they pose.", "Security Considerations": "An attacker could register ENS names that resemble well-known chain names. For example,etheriumandehtereumare reasonably close toethereum. While many unicode homoglyphs are caught by ENS libraries, agents should still be aware of the risk they pose.", "Unicode & Typosquatting Attacks": "An attacker could register ENS names that resemble well-known chain names. For example,etheriumandehtereumare reasonably close toethereum. While many unicode homoglyphs are caught by ENS libraries, agents should still be aware of the risk they pose.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7856, "url": "https://eips.ethereum.org/EIPS/eip-7856", "title": "Chain-Specific Payment Requests", "authors": ["Jack Chuma\u00a0(", "@jackchuma", ")"], "sections": {"ERC-7856: Chain-Specific Payment Requests": "This EIP proposes a standardized URI scheme for chain-specific payment requests, enabling users to specify transactions in the form \u201csend me X tokens of type Y on chain Z\u201d. The URI format includes essential components such as the recipient\u2019s blockchain account, the amount of tokens, the token contract address, and optional success and error callback URLs. This standard aims to eliminate ambiguity in multi-chain payment requests, ensuring clarity and accuracy in peer-to-peer transactions and vendor or dApp requests across different blockchain networks.", "A URI scheme for chain-specific payment requests.": "This EIP proposes a standardized URI scheme for chain-specific payment requests, enabling users to specify transactions in the form \u201csend me X tokens of type Y on chain Z\u201d. The URI format includes essential components such as the recipient\u2019s blockchain account, the amount of tokens, the token contract address, and optional success and error callback URLs. This standard aims to eliminate ambiguity in multi-chain payment requests, ensuring clarity and accuracy in peer-to-peer transactions and vendor or dApp requests across different blockchain networks.", "Abstract": "This EIP proposes a standardized URI scheme for chain-specific payment requests, enabling users to specify transactions in the form \u201csend me X tokens of type Y on chain Z\u201d. The URI format includes essential components such as the recipient\u2019s blockchain account, the amount of tokens, the token contract address, and optional success and error callback URLs. This standard aims to eliminate ambiguity in multi-chain payment requests, ensuring clarity and accuracy in peer-to-peer transactions and vendor or dApp requests across different blockchain networks.", "Motivation": "The ongoing expansion of the Ethereum network into a multi-chain ecosystem has introduced complexities regarding the execution of payment requests. Users and developers currently face a lack of clarity on which chain a payment request should be fulfilled, particularly when similar assets exist across multiple chains. This ambiguity complicates peer-to-peer transactions and vendor or dApp requests, leading to inefficiencies and a higher potential for errors. This standard will ensure that payment requests are clearly understood and correctly executed, regardless of the chain, thus significantly enhancing the user experience in a multi-chain environment.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Examples": "Wallets or applications parsing these URIs MUST validate the format of the recipient account. If any component of the URI does not meet the specified requirements or format, an error should be displayed to the user.", "Error Handling": "Wallets or applications parsing these URIs MUST validate the format of the recipient account. If any component of the URI does not meet the specified requirements or format, an error should be displayed to the user.", "Rationale": "The design of this URI standard for blockchain-based payment requests addresses the need for a clear and unambiguous method to initiate transactions across multiple Ethereum chains, including mainnet and various Layer 2 networks. The rationale for each component of the URI structure is as follows:", "Alternative Designs Considered:": "ERC-681is a related standard that defines a similar URI scheme for specifying token transfers in Ethereum. However, ERC-681 includes additional parameters for specifying transaction details, which were deemed unnecessary for the scope of this standard. The focus of this EIP is on simplicity and clarity in payment request specifications, with the expectation that transaction details will be handled by the user\u2019s wallet application.", "Related Work": "ERC-681is a related standard that defines a similar URI scheme for specifying token transfers in Ethereum. However, ERC-681 includes additional parameters for specifying transaction details, which were deemed unnecessary for the scope of this standard. The focus of this EIP is on simplicity and clarity in payment request specifications, with the expectation that transaction details will be handled by the user\u2019s wallet application.", "Backwards Compatibility": "Due to the unique choice in URI prefix, this EIP is not backwards compatible with ERC-681 or ERC-831.", "Security Considerations": "As there are many similarities to ERC-681, all the same security considerations apply and have been summarized below.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7858, "url": "https://eips.ethereum.org/EIPS/eip-7858", "title": "Expirable NFTs and SBTs", "authors": ["sirawt\u00a0(", "@MASDXI", ")", "ADISAKBOONMARK\u00a0(", "@ADISAKBOONMARK", ")", "parametprame\u00a0(", "@parametprame", ")", "Nacharoen\u00a0(", "@najaroen", ")"], "sections": {"ERC-7858: Expirable NFTs and SBTs": "Introduces an extension forERC-721Non-Fungible Tokens (NFTs) and Soulbound Tokens (SBTs) that adds an expiration mechanism, allowing tokens to become invalid after a predefined period. This additional layer of functionality ensures that the expiration mechanism does not interfere with existing NFTs or SBTs, preserving transferability for NFTs and compatibility with current DApps such as NFT Marketplace. Expiration can be defined using either block height or timestamp, offering flexibility for various use cases.", "Non-fungible (NFT) and soulbound (SBT) tokens with expiration, supporting time-limited use cases.": "Introduces an extension forERC-721Non-Fungible Tokens (NFTs) and Soulbound Tokens (SBTs) that adds an expiration mechanism, allowing tokens to become invalid after a predefined period. This additional layer of functionality ensures that the expiration mechanism does not interfere with existing NFTs or SBTs, preserving transferability for NFTs and compatibility with current DApps such as NFT Marketplace. Expiration can be defined using either block height or timestamp, offering flexibility for various use cases.", "Abstract": "Introduces an extension forERC-721Non-Fungible Tokens (NFTs) and Soulbound Tokens (SBTs) that adds an expiration mechanism, allowing tokens to become invalid after a predefined period. This additional layer of functionality ensures that the expiration mechanism does not interfere with existing NFTs or SBTs, preserving transferability for NFTs and compatibility with current DApps such as NFT Marketplace. Expiration can be defined using either block height or timestamp, offering flexibility for various use cases.", "Motivation": "Introduces an extension forERC-721Non-Fungible Tokens (NFTs) and Soulbound Tokens (SBTs), which facilitates the implementation of an expiration mechanism.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Interface": "Epochsrepresent a specific period or block range during which certain tokens are valid borrowing concepts fromERC-7818, tokens are grouped under anepochand share the samevalidityDuration.", "Behavior Specification": "Epochsrepresent a specific period or block range during which certain tokens are valid borrowing concepts fromERC-7818, tokens are grouped under anepochand share the samevalidityDuration.", "Extension Interface": "Epochsrepresent a specific period or block range during which certain tokens are valid borrowing concepts fromERC-7818, tokens are grouped under anepochand share the samevalidityDuration.", "Additional Potential Useful Function": "TheseOPTIONALfunctions provide additional functionality that might be useful depending on the specific use case.", "Rationale": "Introducing expirability as an additional layer of functionality ensures it doesn\u2019t interfere with existing use cases or applications. For non-SBT tokens, transferability remains intact, maintaining compatibility with current systems. Expired tokens are simply flagged as unusable during validity checks, treating expiration as an enhancement rather than a fundamental change.", "First, do no harm": "Introducing expirability as an additional layer of functionality ensures it doesn\u2019t interfere with existing use cases or applications. For non-SBT tokens, transferability remains intact, maintaining compatibility with current systems. Expired tokens are simply flagged as unusable during validity checks, treating expiration as an enhancement rather than a fundamental change.", "Expiry Types": "Defining expiration by either block height (block.number) or block timestamp (block.timestamp) offers flexibility for various use cases. Block-based expiration suits applications that rely on network activity and require precise consistency, while time-based expiration is ideal for networks with variable block intervals.", "Backwards Compatibility": "This standard is fully compatible withERC-721,ERC-5484and other SBTs.", "Reference Implementation": "You can find our reference implementationhere.", "Security Considerations": "Implementation should ensure that burning token and re-minting it with the sametokenIdwill not introduce an unauthorized renewal.", "Burn and Re-Mint": "Implementation should ensure that burning token and re-minting it with the sametokenIdwill not introduce an unauthorized renewal.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7884, "url": "https://eips.ethereum.org/EIPS/eip-7884", "title": "Operation Router", "authors": ["Lucas Picollo\u00a0(", "@pikonha", ")", "Alex Netto\u00a0(", "@alextnetto", ")", "Nick Johnson\u00a0(", "@arachnid", ")"], "sections": {"ERC-7884: Operation Router": "This EIP introduces a protocol that enables smart contracts to redirect write operations to external systems. The protocol defines a standardized way for contracts to indicate that an operation should be handled by either a contract deployed to an L2 chain, to the L1, or an off-chain database, providing an entry point for easy developer experience and client implementations.", "A protocol that enables smart contracts to redirect write operations to external systems.": "This EIP introduces a protocol that enables smart contracts to redirect write operations to external systems. The protocol defines a standardized way for contracts to indicate that an operation should be handled by either a contract deployed to an L2 chain, to the L1, or an off-chain database, providing an entry point for easy developer experience and client implementations.", "Abstract": "This EIP introduces a protocol that enables smart contracts to redirect write operations to external systems. The protocol defines a standardized way for contracts to indicate that an operation should be handled by either a contract deployed to an L2 chain, to the L1, or an off-chain database, providing an entry point for easy developer experience and client implementations.", "Motivation": "As the Ethereum ecosystem grows, there is an increasing need for efficient ways to manage data storage across different layers and systems.", "Specification": "The protocol consists of three main components:", "Core Components": "The protocol consists of three main components:", "Interface": "The onchain flow is specified as follows:", "Implementation Example": "The contract deployed to the L1 MUST implement thegetOperationHandlerto act as a router redirecting the requests to the respective handler.", "Rationale": "The standard aims to enable offchain writing operations, designed to be a complement for the CCIP-Read (ERC-3668) which is already widely adopted by the community.", "Backwards Compatibility": "This EIP is fully backward compatible as it:", "Security Considerations": "Off-chain handlers must:", "Handler Validation": "Off-chain handlers must:", "General Recommendations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7887, "url": "https://eips.ethereum.org/EIPS/eip-7887", "title": "Cancelation for ERC-7540 Tokenized Vaults", "authors": ["Jeroen Offerijns\u00a0(", "@hieronx", ")", "Vikram Arun\u00a0(", "@vikramarun", ")"], "sections": {"ERC-7887: Cancelation for ERC-7540 Tokenized Vaults": "The following standard extendsERC-7540by adding support for asynchronous cancelation flows.", "Extension of ERC-7540 with cancelation support": "The following standard extendsERC-7540by adding support for asynchronous cancelation flows.", "Abstract": "The following standard extendsERC-7540by adding support for asynchronous cancelation flows.", "Motivation": "Shares or assets locked for Requests can be stuck in the Pending state. For some use cases, such as redeeming from a pool of long-dated real-world assets, this can take a considerable amount of time.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Definitions": "The existing definitions fromERC-7540apply.", "Cancelation Lifecycle": "After submission, cancelation Requests go through Pending, Claimable, and Claimed stages. An example lifecycle for a deposit cancelation Request is visualized in the table below.", "Methods": "Submits a Request for asynchronous deposit cancelation. This places the Request in Pending state, with a corresponding increase inpendingCancelDepositRequestfor the full amount of the pending deposit Request.", "Events": "controllerhas requested cancelation of their deposit Request with request IDrequestId.senderis the caller of thecancelDepositRequestwhich may not be equal to thecontroller.", "ERC-165support": "Smart contracts implementing this Vault standard MUST implement theERC-165supportsInterfacefunction.", "Rationale": "WhencancelDepositRequestis called by acontroller, new deposit Requests are blocked for thiscontroller, and the equivalent applies to the redeem flow.", "Blocking Requests during Cancelation": "WhencancelDepositRequestis called by acontroller, new deposit Requests are blocked for thiscontroller, and the equivalent applies to the redeem flow.", "Mandated Support forERC-165": "Implementing support forERC-165is mandated because of the optionality of flows as defined inERC-7540. Integrations can use thesupportsInterfacemethod to check whether a vault is fully asynchronous, partially asynchronous, or fully synchronous (for which it is just following theERC-4626), and use a single contract to support all cases.", "Backwards Compatibility": "The interface is fully backwards compatible withERC-7540.", "Security Considerations": "Existing security considerations fromERC-7540apply.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7913, "url": "https://eips.ethereum.org/EIPS/eip-7913", "title": "Signature Verifiers", "authors": ["Hadrien Croubois\u00a0(", "@Amxx", ")", "Ernesto Garc\u00eda\u00a0(", "@ernestognw", ")", "Francisco Giordano\u00a0(", "@frangio", ")", "Aryeh Greenberg\u00a0(", "@arr00", ")"], "sections": {"ERC-7913: Signature Verifiers": "Externally Owned Accounts (EOA) can sign messages with their associated private keys. AdditionallyERC-1271defines a method for signature verification by smart accounts such as multisig. In both cases the identity of the signer is an ethereum address. We propose a standard to extend this concept of signer description, and signature verification, to keys that do not have an ethereum identity of their own, in the sense that they don\u2019t have their own address to represent them.", "Interface for the verification of signatures by address-less keys": "Externally Owned Accounts (EOA) can sign messages with their associated private keys. AdditionallyERC-1271defines a method for signature verification by smart accounts such as multisig. In both cases the identity of the signer is an ethereum address. We propose a standard to extend this concept of signer description, and signature verification, to keys that do not have an ethereum identity of their own, in the sense that they don\u2019t have their own address to represent them.", "Abstract": "Externally Owned Accounts (EOA) can sign messages with their associated private keys. AdditionallyERC-1271defines a method for signature verification by smart accounts such as multisig. In both cases the identity of the signer is an ethereum address. We propose a standard to extend this concept of signer description, and signature verification, to keys that do not have an ethereum identity of their own, in the sense that they don\u2019t have their own address to represent them.", "Motivation": "With the development of account abstraction, there is an increasing need for non-ethereum signature verification. Cryptographic algorithms besides the natively supported secp256k1 are being used for controlling smart accounts. In particular, curves such as secp256r1 (supported by many mobile devices) and RSA keys (that are distributed by traditional institutions) are widely available. Beyond these two examples, we also see the emergence of ZK solutions for signing with emails or JWT from big Web2 services.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Nomenclature": "Verifiers MUST implement the following interface:", "Signature Verifier interface": "Verifiers MUST implement the following interface:", "Rationale": "Verifiers can be used to avoid deploying many ERC-1271 \u201cidentity contract\u201d (one per key), which would be expensive. Using this model, new keys can be used without any deployment costs.", "Backwards Compatibility": "A system can supportERC-7913signers alongside EOAs and ERC-1271 in the following way.", "Reference Implementation": "In solidity, signature verification COULD be implemented in the following library:", "Security Considerations": "Signer may be used for anything from smart account session key (with a short lifetime of a few hours/days) to social recovery \u201cguardians\u201d that may only be used several years after they are setup. In order to ensure that these signers remain valid \u201cin perpetuity\u201d, the verifier contract SHOULD be trustless. This means that the verifiers SHOULD not be upgradeable contracts.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 205, "url": "https://eips.ethereum.org/EIPS/eip-205", "title": "ENS support for contract ABIs", "authors": ["Nick Johnson\u00a0<", "nick@ethereum.org", ">"], "sections": {"ERC-205: ENS support for contract ABIs": "This EIP proposes a mechanism for storing ABI definitions in ENS, for easy lookup of contract interfaces by callers.", "": "This EIP proposes a mechanism for storing ABI definitions in ENS, for easy lookup of contract interfaces by callers.", "Simple Summary": "This EIP proposes a mechanism for storing ABI definitions in ENS, for easy lookup of contract interfaces by callers.", "Abstract": "ABIs are important metadata required for interacting with most contracts. At present, they are typically supplied out-of-band, which adds an additional burden to interacting with contracts, particularly on a one-off basis or where the ABI may be updated over time. The small size of ABIs permits an alternative solution, storing them in ENS, permitting name lookup and ABI discovery via the same process.", "Specification": "In order to allow for different tradeoffs between onchain size and accessibility, several ABI encodings are defined. Each ABI encoding is defined by a unique constant with only a single bit set, allowing for the specification of 256 unique encodings in a single uint.", "ABI encodings": "In order to allow for different tradeoffs between onchain size and accessibility, several ABI encodings are defined. Each ABI encoding is defined by a unique constant with only a single bit set, allowing for the specification of 256 unique encodings in a single uint.", "Resolver profile": "A new resolver interface is defined, consisting of the following method:", "ABI lookup process": "When attempting to fetch an ABI based on an ENS name, implementers should first attempt an ABI lookup on the name itself. If that lookup returns no results, they should attempt a reverse lookup on the Ethereum address the name resolves to.", "Rationale": "Storing ABIs onchain avoids the need to introduce additional dependencies for applications wishing to fetch them, such as swarm or HTTP access. Given the typical compactness of ABIs, we believe this is a worthwhile tradeoff in many cases.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 634, "url": "https://eips.ethereum.org/EIPS/eip-634", "title": "Storage of text records in ENS", "authors": ["Richard Moore\u00a0(", "@ricmoo", ")"], "sections": {"ERC-634: Storage of text records in ENS": "This EIP defines a resolver profile for ENS that permits the lookup of arbitrary key-value\ntext data. This allows ENS name holders to associate e-mail addresses, URLs and other\ninformational data with a ENS name.", "Profiles for ENS resolvers to store arbitrary text key/value pairs.": "This EIP defines a resolver profile for ENS that permits the lookup of arbitrary key-value\ntext data. This allows ENS name holders to associate e-mail addresses, URLs and other\ninformational data with a ENS name.", "Abstract": "This EIP defines a resolver profile for ENS that permits the lookup of arbitrary key-value\ntext data. This allows ENS name holders to associate e-mail addresses, URLs and other\ninformational data with a ENS name.", "Motivation": "There is often a desire for human-readable metadata to be associated with otherwise\nmachine-driven data; used for debugging, maintenance, reporting and general information.", "Specification": "A new resolver interface is defined, consisting of the following method:", "Resolver Profile": "A new resolver interface is defined, consisting of the following method:", "Global Keys": "Global Keys must be made up of lowercase letters, numbers and\nthe hyphen (-).", "Service Keys": "Service Keys must be made up of areverse dot notationfor\na namespace which the service owns, for example, DNS names\n(e.g..com,.io, etc) or ENS name (i.e..eth). Service\nKeys must contain at least one dot.", "Legacy Keys": "The following keys were specified in earlier versions of this EIP,\nwhich is still in draft.", "Rationale": "Rather than define a large number of specific record types (each for generally human-readable\ndata) such asurlandemail, we follow an adapted model of DNS\u2019sTXTrecords, which allow\nfor a general keys and values, allowing future extension without adjusting the resolver, while\nallowing applications to use custom keys for their own purposes.", "Application-specific vs general-purpose record types": "Rather than define a large number of specific record types (each for generally human-readable\ndata) such asurlandemail, we follow an adapted model of DNS\u2019sTXTrecords, which allow\nfor a general keys and values, allowing future extension without adjusting the resolver, while\nallowing applications to use custom keys for their own purposes.", "Backwards Compatibility": "Not applicable.", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 801, "url": "https://eips.ethereum.org/EIPS/eip-801", "title": "Canary Standard", "authors": ["ligi\u00a0<", "ligi@ligi.de", ">"], "sections": {"ERC-801: Canary Standard": "A standard interface for canary contracts.", "": "A standard interface for canary contracts.", "Simple Summary": "A standard interface for canary contracts.", "Abstract": "The following standard allows the implementation of canaries within contracts.\nThis standard provides basic functionality to check if a canary is alive, keeping the canary alive and optionally manage feeders.", "Motivation": "The canary can e.g. be used as awarrant canary.\nA standard interface allows other applications to easily interface with canaries on Ethereum - e.g. for visualizing the state, automated alarms, applications to feed the canary or contracts (e.g. insurance) that use the state.", "Specification": "Returns if the canary was fed properly to signal e.g. that no warrant was received.", "Methods": "Returns if the canary was fed properly to signal e.g. that no warrant was received.", "Events": "MUST trigger when the contract is called the first time after the canary died.", "Implementation": "TODO", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 823, "url": "https://eips.ethereum.org/EIPS/eip-823", "title": "Token Exchange Standard", "authors": ["Kashish Khullar\u00a0<", "kkhullar7@gmail.com", ">"], "sections": {"ERC-823: Token Exchange Standard": "A standard for token contracts, providing token exchange services thereby facilitating cross token payments.", "": "A standard for token contracts, providing token exchange services thereby facilitating cross token payments.", "Simple Summary": "A standard for token contracts, providing token exchange services thereby facilitating cross token payments.", "Abstract": "The following standard provides functionally to make payments in the form of any other registered tokens, as well as allow token contracts to store any other tokens in an existing token contract. This standard allows ERC20 token holders to exchange their token with another ERC20 token and use the exchanged tokens to make payments. After a successful payment, the former specified ERC20 tokens, will be stored within the ERC20 token contract they are exchanged with. This proposal uses the term target contract which is used to denote the contract to the token with whom we want to exchange our tokens.", "Motivation": "Existing token standards do not provide functionality to exchange tokens. Existing token converters reduce the total supply of an existing token, which in the sense destroys the currency. Token converters do not solve this problem and hence discourages creation of new tokens. This solution does not destroy the existing token but in essence preserve them in the token contract that they are exchanged with, which in turn increases the market value of the latter.", "Specification": "This interface must be inherited by a ERC20 token contract that wants to exchange its tokens with another token.", "Sender Interface": "This interface must be inherited by a ERC20 token contract that wants to exchange its tokens with another token.", "Receiver Interface": "This interface must be inherited by a ERC20 token contract that wants to receive exchanged tokens.", "Exchange Service Contract": "This is an intermediate contract that provides a gateway for exchanges and expenditure. This contract uses oracles to get the authenticated exchange rates.", "Diagramatic Explanation": "", "Rationale": "Such a design provides a consistent exchange standard \napplicable to all ERC20 tokens that follow it.\nThe primary advantage for of this strategy is that the exchanged tokens will not be lost. They can either be spent or preserved.\nToken convert face a major drawback of destroying tokens after conversion. This mechanism treats tokens like conventional currency where tokens are not destroyed but are stored.", "Backward Compatibility": "This proposal is fully backward compatible. Tokens extended by this proposal should also be following ERC20 standard. The functionality of ERC20 standard should not be affected by this proposal but will provide additional functionality to it.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 831, "url": "https://eips.ethereum.org/EIPS/eip-831", "title": "URI Format for Ethereum", "authors": ["ligi\u00a0(", "@ligi", ")"], "sections": {"ERC-831: URI Format for Ethereum": "URIs embedded in QR-codes, hyperlinks in web-pages, emails or chat messages provide for robust cross-application signaling between very loosely coupled applications. A standardized URI format allows for instant invocation of the user\u2019s preferred wallet application.", "A way of creating Ethereum URIs for various use-cases.": "URIs embedded in QR-codes, hyperlinks in web-pages, emails or chat messages provide for robust cross-application signaling between very loosely coupled applications. A standardized URI format allows for instant invocation of the user\u2019s preferred wallet application.", "Abstract": "URIs embedded in QR-codes, hyperlinks in web-pages, emails or chat messages provide for robust cross-application signaling between very loosely coupled applications. A standardized URI format allows for instant invocation of the user\u2019s preferred wallet application.", "Specification": "Ethereum URIs contain \u201cethereum\u201d or \u201ceth\u201d in their schema (protocol) part and are constructed as follows:", "Syntax": "Ethereum URIs contain \u201cethereum\u201d or \u201ceth\u201d in their schema (protocol) part and are constructed as follows:", "Semantics": "prefixis optional and defines the use-case for this URI. If no prefix is given: \u201cpay-\u201c is assumed to be concise and ensure backward compatibility toEIP-67. When the prefix is omitted, the payload must start with0x. Also prefixes must not start with0x. So starting with0xcan be used as a clear signal that there is no prefix.", "Rationale": "The need for this ERC emerged when refining EIP-681. We need a container that does not carry the weight of the use-cases. EIP-67 was the first attempt on defining Ethereum-URIs. This ERC tries to keep backward compatibility and not break existing things. This means EIP-67 URIs should still be valid and readable. Only if the prefix feature is used, EIP-67 parsers might break. No way was seen to avoid this and innovate on the same time. This is also the reason this open prefix approach was chosen to being able to adopt to future use-cases and not block the whole \u201cethereum:\u201d scheme for a limited set of use-cases that existed at the time of writing this.", "Security Considerations": "There are no known security considerations at this time.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 884, "url": "https://eips.ethereum.org/EIPS/eip-884", "title": "DGCL Token", "authors": ["Dave Sag\u00a0<", "davesag@gmail.com", ">"], "sections": {"ERC-884: DGCL Token": "Ref:proposing-an-eip-for-DGCL-tokens", "": "Ref:proposing-an-eip-for-DGCL-tokens", "Delaware General Corporations Law (DGCL) compatible share token": "Ref:proposing-an-eip-for-DGCL-tokens", "Simple Summary": "AnERC-20compatible token that conforms toDelaware State Senate, 149th General Assembly, Senate Bill No. 69: An act to Amend Title 8 of the Delaware Code Relating to the General Corporation Law, henceforth referred to as \u2018The Act\u2019.", "Abstract": "The recently amended \u2018Title 8 of the Delaware Code Relating to the General Corporation Law\u2019 now explicitly allows for the use of blockchains to maintain corporate share registries. This means it is now possible to create a tradableERC-20token where each token represents a share issued by a Delaware corporation. Such a token must conform to the following principles over and above theERC-20standard.", "Motivation": "By using aDGCLcompatible token, a firm may be able to raise funds via IPO, conforming to Delaware Corporations Law, but bypassing the need for involvement of a traditional Stock Exchange.", "What about ERC-721?": "The proposed standard could easily be used to enhanceERC-721, adding features for associating tokens with assets such as share certificates.", "Specification": "TheERC-20token provides the following basic features:", "Securities Exchange Commission Requirements": "The Securities Exchange Commission (SEC) has additional requirements as to how a crowdsale ought to be run and what information must be made available to the general public. This information is however out of scope from this standard, though the standard does support the requirements.", "Use of the Identityhashvalue": "Implementers of a crowdsale, in order to comply with The Act, must be able to produce an up-to-date list of the names and addresses of all shareholders. It is not desirable to include those details in a public blockchain, both for reasons of privacy, and also for reasons of economy. Storing arbitrary string data on the blockchain is strongly discouraged.", "Handling users who have lost access to their addresses": "A traditional share register is typically managed by a Transfer Agent who is authorised to maintain the register accurately, and to handle shareholder enquiries. A common request is for share certificates to be reissued in the case where the shareholder has lost or destroyed their original.", "Permissions management": "It is not desirable that anyone can add, remove, update, or supersede verified addresses. How access to these functions is controlled is outside of the scope of this standard.", "Rationale": "The proposed standard offers as minimal an extension as possible over the existingERC-20standard in order to conform to the requirements of The Act. Rather than return aboolfor successful or unsuccessful completion of state-changing functions such asaddVerified,removeVerified, andupdateVerified, we have opted to require that implementationsthrow(preferably by using theforthcomingrequire(condition, 'fail message')syntax).", "Backwards Compatibility": "The proposed standard is designed to maintain compatibility withERC-20tokens with the following provisos:", "Test Cases and Reference Implementation": "Test cases and a reference implementation are available atgithub.com/davesag/ERC884-reference-implementation.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 897, "url": "https://eips.ethereum.org/EIPS/eip-897", "title": "DelegateProxy", "authors": ["Jorge Izquierdo\u00a0<", "jorge@aragon.one", ">", "Manuel Araoz\u00a0<", "manuel@zeppelin.solutions", ">"], "sections": {"ERC-897: DelegateProxy": "Proxy contracts are being increasingly used as both as an upgradeability mechanism\nand a way to save gas when deploying many instances of a particular contract. This\nstandard proposes a set of interfaces for proxies to signal how they work and what\ntheir main implementation is.", "": "Proxy contracts are being increasingly used as both as an upgradeability mechanism\nand a way to save gas when deploying many instances of a particular contract. This\nstandard proposes a set of interfaces for proxies to signal how they work and what\ntheir main implementation is.", "Simple Summary": "Proxy contracts are being increasingly used as both as an upgradeability mechanism\nand a way to save gas when deploying many instances of a particular contract. This\nstandard proposes a set of interfaces for proxies to signal how they work and what\ntheir main implementation is.", "Abstract": "Using proxies that delegate their own logic to another contract is becoming an\nincreasingly popular technique for both smart contract upgradeability and creating\ncheap clone contracts.", "Implementations": "The returned code address is the address the proxy would delegate calls to at that\nmoment in time, for that message.", "Standardized interface": "The returned code address is the address the proxy would delegate calls to at that\nmoment in time, for that message.", "Code address (implementation())": "The returned code address is the address the proxy would delegate calls to at that\nmoment in time, for that message.", "Proxy Type (proxyType())": "Checking the proxy type is the way to check whether a contract is a proxy at all.\nWhen a contract fails to return to this method or it returns 0, it can be assumed\nthat the contract is not a proxy.", "Benefits": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 900, "url": "https://eips.ethereum.org/EIPS/eip-900", "title": "Simple Staking Interface", "authors": ["Dean Eigenmann\u00a0<", "dean@tokenate.io", ">", "Jorge Izquierdo\u00a0<", "jorge@aragon.one", ">"], "sections": {"ERC-900: Simple Staking Interface": "The following standard describes a common staking interface allowing for easy to use staking systems. The interface is kept simple allowing for various use cases to be implemented. This standard describes the common functionality for staking as well as providing information on stakes.", "": "The following standard describes a common staking interface allowing for easy to use staking systems. The interface is kept simple allowing for various use cases to be implemented. This standard describes the common functionality for staking as well as providing information on stakes.", "Abstract": "The following standard describes a common staking interface allowing for easy to use staking systems. The interface is kept simple allowing for various use cases to be implemented. This standard describes the common functionality for staking as well as providing information on stakes.", "Motivation": "As we move to more token models, having a common staking interface which is familiar to users can be useful. The common interface can be used by a variety of applications, this common interface could be beneficial especially to things like Token curated registries which have recently gained popularity.", "Specification": "Stakes a certain amount of tokens, this MUST transfer the given amount from the user.", "stake": "Stakes a certain amount of tokens, this MUST transfer the given amount from the user.", "stakeFor": "Stakes a certain amount of tokens, this MUST transfer the given amount from the caller.", "unstake": "Unstakes a certain amount of tokens, this SHOULD return the given amount of tokens to the user, if unstaking is currently not possible the function MUST revert.", "totalStakedFor": "Returns the current total of tokens staked for an address.", "totalStaked": "Returns the current total of tokens staked.", "token": "Address of the token being used by the staking interface.", "supportsHistory": "MUST return true if the optional history functions are implemented, otherwise false.", "lastStakedFor": "OPTIONAL:As not all staking systems require a complete history, this function is optional.", "totalStakedForAt": "OPTIONAL:As not all staking systems require a complete history, this function is optional.", "totalStakedAt": "OPTIONAL:As not all staking systems require a complete history, this function is optional.", "Implementation": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 902, "url": "https://eips.ethereum.org/EIPS/eip-902", "title": "Token Validation", "authors": ["Brooklyn Zelenka\u00a0(", "@expede", ")", "Tom Carchrae\u00a0(", "@carchrae", ")", "Gleb Naumenko\u00a0(", "@naumenkogs", ")"], "sections": {"ERC-902: Token Validation": "A protocol for services providing token ownership and transfer validation.", "": "A protocol for services providing token ownership and transfer validation.", "Simple Summary": "A protocol for services providing token ownership and transfer validation.", "Abstract": "This standard provides a registry contract method for authorizing token transfers. By nature, this covers both initially issuing tokens to users (ie: transfer from contract to owner), transferring tokens between users, and token spends.", "Motivation": "The tokenization of assets has wide application, not least of which is financial instruments such as securities and security tokens. Most jurisdictions have placed legal constraints on what may be traded, and who can hold such tokens which are regarded as securities. Broadly this includes KYC and AML validation, but may also include time-based spend limits, total volume of transactions, and so on.", "Specification": "function check(address _token, address _subject) public returns (byte _resultCode)", "TokenValidator": "function check(address _token, address _subject) public returns (byte _resultCode)", "Methods": "function check(address _token, address _subject) public returns (byte _resultCode)", "ValidatedToken": "event Validation(address indexed subject, byte indexed resultCode)", "Events": "event Validation(address indexed subject, byte indexed resultCode)", "Rationale": "This proposal includes a financial permissions system on top of any financial token. This design is not a general roles/permission system. In any system, the more you know about the context where a function will be called, the more powerful your function can be. By restricting ourselves to token transfers (ex. ERC20 or EIP-777), we can make assumptions about the use cases our validators will need to handle, and can make the API both small, useful, and extensible.", "Implementation": "Reference implementation", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 918, "url": "https://eips.ethereum.org/EIPS/eip-918", "title": "Mineable Token Standard", "authors": ["Jay Logelin\u00a0<", "jlogelin@alumni.harvard.edu", ">", "Infernal_toast\u00a0<", "admin@0xbitcoin.org", ">", "Michael Seiler\u00a0<", "mgs33@cornell.edu", ">", "Brandon Grill\u00a0<", "bg2655@columbia.edu", ">"], "sections": {"ERC-918: Mineable Token Standard": "A specification for a standardized Mineable Token that uses a Proof of Work algorithm for distribution.", "": "A specification for a standardized Mineable Token that uses a Proof of Work algorithm for distribution.", "Simple Summary": "A specification for a standardized Mineable Token that uses a Proof of Work algorithm for distribution.", "Abstract": "This specification describes a method for initially locking tokens within a token contract and slowly dispensing them with a mint() function which acts like a faucet. This mint() function uses a Proof of Work algorithm in order to minimize gas fees and control the distribution rate. Additionally, standardization of mineable tokens will give rise to standardized CPU and GPU token mining software, token mining pools and other external tools in the token mining ecosystem.", "Motivation": "Token distribution via the ICO model and its derivatives is susceptible to illicit behavior by human actors. Furthermore, new token projects are centralized because a single entity must handle and control all of the initial coins and all of the raised ICO money.  By distributing tokens via an \u2018Initial Mining Offering\u2019 (or IMO), the ownership of the token contract no longer belongs with the deployer at all and the deployer is \u2018just another user.\u2019 As a result, investor risk exposure utilizing a mined token distribution model is significantly diminished. This standard is intended to be standalone, allowing maximum interoperability with ERC20, ERC721, and others.", "Specification": "The general behavioral specification includes a primary function that defines the token minting operation, an optional merged minting operation for issuing multiple tokens, getters for challenge number, mining difficulty, mining target and current reward, and finally a Mint event, to be emitted upon successful solution validation and token issuance. At a minimum, contracts must adhere to this interface (save the optional merge operation). It is recommended that contracts interface with the more behaviorally defined Abstract Contract described below, in order to leverage a more defined construct, allowing for easier external implementations via overridden phased functions. (see \u2018Abstract Contract\u2019 below)", "Fields": "The amount of time between difficulty adjustments in seconds.", "Mining Operations": "Returns a flag indicating a successful hash digest verification, and reward allocation to msg.sender. In order to prevent MiTM attacks, it is recommended that the digest include a recent Ethereum block hash and msg.sender\u2019s address. Once verified, the mint function calculates and delivers a mining reward to the sender and performs internal accounting operations on the contract\u2019s supply.", "Example mining function": "A general mining function written in python for finding a valid nonce for keccak256 mined token, is as follows:", "Merged Mining Extension (Optional)": "In order to provide support for merge mining multiple tokens, an optional merged mining extension can be implemented as part of the ERC918 standard. It is important to note that the following function will only properly work if the base contracts use tx.origin instead of msg.sender when applying rewards. If not the rewarded tokens will be sent to the calling contract and not the end user.", "Delegated Minting Extension (Optional)": "In order to facilitate a third party minting submission paradigm, such as the case of miners submitting solutions to a pool operator and/or system, a delegated minting extension can be used to allow pool accounts submit solutions on the behalf of a user, so the miner can avoid directly paying Ethereum transaction costs. This is performed by an off chain mining account packaging and signing a standardized mint solution packet and sending it to a pool or 3rd party to be submitted.", "Mineable Token Metadata (Optional)": "In order to provide for richer and potentially mutable metadata for a particular Mineable Token, it is more viable to offer an off-chain reference to said data. This requires the implementation of a single interface method \u2018metadataURI()\u2019 that returns a JSON string encoded with the string fields symbol, name, description, website, image, and type.", "Rationale": "The solidity keccak256 algorithm does not have to be used, but it is recommended since it is a cost effective one-way algorithm to perform in the EVM and simple to perform in solidity. The nonce is the solution that miners try to find and so it is part of the hashing algorithm. A challengeNumber is also part of the hash so that future blocks cannot be mined since it acts like a random piece of data that is not revealed until a mining round starts. The msg.sender address is part of the hash so that a nonce solution is valid only for a particular Ethereum account and so the solution is not susceptible to man-in-the-middle attacks. This also allows pools to operate without being easily cheated by the miners since pools can force miners to mine using the pool\u2019s address in the hash algorithm.", "Backwards Compatibility": "Earlier versions of this standard incorporated a redundant \u2018challenge_digest\u2019 parameter on the mint() function that hash-encoded the packed variables challengeNumber, msg.sender and nonce. It was decided that this could be removed from the standard to help minimize processing and thereby gas usage during mint operations. However, in the name of interoperability with existing mining programs and pool software the following contract can be added to the inheritance tree:", "Test Cases": "(Test cases for an implementation are mandatory for EIPs that are affecting consensus changes. Other EIPs can choose to include links to test cases if applicable.)", "Implementation": "Simple Example:\nhttps://github.com/0xbitcoin/EIP918-Mineable-Token/blob/master/contracts/SimpleERC918.sol", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 926, "url": "https://eips.ethereum.org/EIPS/eip-926", "title": "Address metadata registry", "authors": ["Nick Johnson\u00a0<", "nick@ethereum.org", ">"], "sections": {"ERC-926: Address metadata registry": "This EIP specifies a registry for address metadata, permitting both contracts and external accounts to supply metadata about themselves to onchain and offchain callers. This permits use-cases such as generalised authorisations, providing token acceptance settings, and claims registries.", "": "This EIP specifies a registry for address metadata, permitting both contracts and external accounts to supply metadata about themselves to onchain and offchain callers. This permits use-cases such as generalised authorisations, providing token acceptance settings, and claims registries.", "Abstract": "This EIP specifies a registry for address metadata, permitting both contracts and external accounts to supply metadata about themselves to onchain and offchain callers. This permits use-cases such as generalised authorisations, providing token acceptance settings, and claims registries.", "Motivation": "An increasing set of use cases require storage of metadata associated with an address; see for instance EIP 777 and EIP 780, and the ENS reverse registry in EIP 181. Presently each use-case defines its own specialised registry. To prevent a proliferation of special-purpose registry contracts, we instead propose a single standardised registry using an extendable architecture that allows future standards to implement their own metadata standards.", "Specification": "The metadata registry has the following interface:", "Provider specification": "Providers may implement any subset of the metadata record types specified here. Where a record types specification requires a provider to provide multiple functions, the provider MUST implement either all or none of them. Providers MUST throw if called with an unsupported function ID.", "Rationale": "There are two obvious approaches for a generic metadata registry: the indirection approach employed here, or a generalised key/value store. While indirection incurs the cost of an additional contract call, and requires providers to change over time, it also provides for significantly enhanced flexibility over a key/value store; for that reason we selected this approach.", "Backwards Compatibility": "There are no backwards compatibility concerns.", "Implementation": "The canonical implementation of the metadata registry is as follows:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 927, "url": "https://eips.ethereum.org/EIPS/eip-927", "title": "Generalised authorisations", "authors": ["Nick Johnson\u00a0<", "nick@ethereum.org", ">"], "sections": {"ERC-927: Generalised authorisations": "This EIP specifies a generic authorisation mechanism, which can be used to implement a variety of authorisation patterns, replacing approvals in ERC20, operators in ERC777, and bespoke authorisation patterns in a variety of other types of contract.", "": "This EIP specifies a generic authorisation mechanism, which can be used to implement a variety of authorisation patterns, replacing approvals in ERC20, operators in ERC777, and bespoke authorisation patterns in a variety of other types of contract.", "Abstract": "This EIP specifies a generic authorisation mechanism, which can be used to implement a variety of authorisation patterns, replacing approvals in ERC20, operators in ERC777, and bespoke authorisation patterns in a variety of other types of contract.", "Motivation": "Smart contracts commonly need to provide an interface that allows a third-party caller to perform actions on behalf of a user. The most common example of this is token authorisations/operators, but other similar situations exist throughout the ecosystem, including for instance authorising operations on ENS domains. Typically each standard reinvents this system for themselves, leading to a large number of incompatible implementations of the same basic pattern. Here, we propose a generic method usable by all such contracts.", "Specification": "The generalised authorisation interface is implemented as a metadata provider, as specified in EIP 926. The following mandatory function is implemented:", "Backwards Compatibility": "There are no backwards compatibility concerns.", "Implementation": "Example implementation TBD.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1056, "url": "https://eips.ethereum.org/EIPS/eip-1056", "title": "Ethereum Lightweight Identity", "authors": ["Pelle Braendgaard\u00a0<", "pelle.braendgaard@consensys.net", ">", "Joel Torstensson\u00a0<", "oed@consensys.net", ">"], "sections": {"ERC-1056: Ethereum Lightweight Identity": "A registry for key and attribute management of lightweight blockchain identities.", "": "A registry for key and attribute management of lightweight blockchain identities.", "Simple Summary": "A registry for key and attribute management of lightweight blockchain identities.", "Abstract": "This ERC describes a standard for creating and updating identities with a limited use of blockchain resources. An identity can have an unlimited number ofdelegatesandattributesassociated with it. Identity creation is as simple as creating a regular key pair ethereum account, which means that it\u2019s free (no gas costs) and all ethereum accounts are valid identities. Furthermore this ERC is fullyDID compliant.", "Motivation": "As we have been developing identity systems for the last couple of years at uPort it has become apparent that the cost of identity creation is a large issue. The previous Identity proposalERC-725faces this exact issue. Our requirements when creating this ERC is that identity creation should be free, and should be possible to do in an offline environment (e.g. refugee scenario). However it must also be possible to rotate keys without changing the primary identifier of the identity. The identity system should be fit to use off-chain as well as on-chain.", "Definitions": "This ERC specifies a contract calledEthereumDIDRegistrythat is deployed once and can then be commonly used by everyone.", "Specification": "This ERC specifies a contract calledEthereumDIDRegistrythat is deployed once and can then be commonly used by everyone.", "Identity ownership": "By default an identity is owned by itself, meaning whoever controls the ethereum account with that address. The owner can be updated to a new key pair account or to a multisig account etc.", "Delegate management": "Delegates can be used both on- and off-chain. They all have adelegateTypewhich can be used to specify the purpose of the delegate.", "Attribute management": "Attributes contain simple data about the identity. They can be managed only by the owner of the identity.", "Events": "MUST be triggered whenchangeOwnerorchangeOwnerSignedwas successfully called.", "Efficient lookup of events through linked identity events": "Contract Events are a useful feature for storing data from smart contracts exclusively for off-chain use.  Unfortunately current ethereum implementations provide a very inefficient lookup mechanism. By using linked events that always link to the previous block with a change for the identity, we can solve this problem with much improved performance. Each identity has its previously changed block stored in thechangedmapping.", "Building a DID document for an identity": "The primary owner key should be looked up usingidentityOwner(identity).  This should be the first of the publicKeys listed. Iterate through theDIDDelegateChangedevents to build a list of additional keys and authentication sections as needed. The list of delegateTypes to include is still to be determined. Iterate throughDIDAttributeChangedevents for service entries, encryption public keys and other public names. The attribute names are still to be determined.", "Rationale": "For on-chain interactions Ethereum has a built in account abstraction that can be used regardless of whether the account is a smart contract or a key pair. Any transaction has amsg.senderas the verified send of the transaction.", "Backwards Compatibility": "All ethereum accounts are valid identities (and DID compatible) using this standard. This means that any wallet provider that uses key pair accounts already supports the bare minimum of this standard, and can implementdelegateandattributefunctionality by simply using theethr-didreferenced below. As theDID Authstandard solidifies it also means that all of these wallets will be compatible with theDID decentralized login system.", "Implementation": "ethr-did-registry(EthereumDIDRegistrycontract implementation)", "Deployment": "The address for theEthereumDIDRegistryis0xdca7ef03e98e0dc2b855be647c39abe984fcf21bon Mainnet, Ropsten, Rinkeby and Kovan.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1062, "url": "https://eips.ethereum.org/EIPS/eip-1062", "title": "Formalize IPFS hash into ENS(Ethereum Name Service) resolver", "authors": ["Phyrex Tsai\u00a0<", "phyrex@portal.network", ">", "Portal Network Team"], "sections": {"ERC-1062: Formalize IPFS hash into ENS(Ethereum Name Service) resolver": "To specify the mapping protocol between resources stored on IPFS and ENS(Ethereum Naming Service).", "": "To specify the mapping protocol between resources stored on IPFS and ENS(Ethereum Naming Service).", "Simple Summary": "To specify the mapping protocol between resources stored on IPFS and ENS(Ethereum Naming Service).", "Abstract": "The following standard details the implementation of how to combine the IPFS cryptographic hash unique fingerprint with ENS public resolver. This standard provides a functionality to get and set IPFS online resources to ENS resolver.", "Motivation": "To build a fully decentralized web service, it\u2019s necessary to have a decentralized file storage system. Here comes the IPFS, for three following advantages :", "Specification": "The condition now is that the IPFS file fingerprint using base58 and in the meantime, the Ethereum uses hex in API to encode the binary data. So that need a way to process the condition requires not only we need to transfer from IPFS to Ethereum, but also need to convert it back.", "Rationale": "To implement the specification, need two methods from ENS public resolver contract, when we want to store IPFS file fingerprint to contract, convert the Base58 string identifier to the hex format and invoke thesetMultihashmethod below :", "Test Cases": "To implement the way to transfer from base58 to hex format and the reverse one, using the \u2018multihashes\u2019 library to deal with the problem.The library link :https://www.npmjs.com/package/multihashesTo implement the method transfer from IPFS(Base58) to hex format :", "Implementation": "The use case can be implemented as browser extension. Users can easily download the extension, and easily get decentralized resources by just typing the ENS just like we normally type the DNS to browser the website. Solve the current pain for normal people can not easily visit the total decentralized website.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1066, "url": "https://eips.ethereum.org/EIPS/eip-1066", "title": "Status Codes", "authors": ["Brooklyn Zelenka\u00a0(", "@expede", ")", "Tom Carchrae\u00a0(", "@carchrae", ")", "Gleb Naumenko\u00a0(", "@naumenkogs", ")"], "sections": {"ERC-1066: Status Codes": "Broadly applicable status codes for smart contracts.", "": "Broadly applicable status codes for smart contracts.", "Simple Summary": "Broadly applicable status codes for smart contracts.", "Abstract": "This standard outlines a common set of status codes in a similar vein to HTTP statuses. This provides a shared set of signals to allow smart contracts to react to situations autonomously, expose localized error messages to users, and so on.", "Motivation": "HTTP status codes are widely used for this purpose. BEAM languages use atoms and tagged tuples to signify much the same information. Both provide a lot of information both to the programmer (debugging for instance), and to the program that needs to decide what to do next.", "Semantic Density": "HTTP status codes are widely used for this purpose. BEAM languages use atoms and tagged tuples to signify much the same information. Both provide a lot of information both to the programmer (debugging for instance), and to the program that needs to decide what to do next.", "User Experience (UX)": "End users get little to no feedback, and there is no translation layer.", "Developer Experience (DX)": "Developers currently have very little context exposed by their smart contracts.", "Smart Contract Autonomy": "Smart contracts don\u2019t know much about the result of a request beyond pass/fail; they can be smarter with more context.", "Specification": "Codes are returned either on their own, or as the first value of a multiple return.", "Format": "Codes are returned either on their own, or as the first value of a multiple return.", "Code Table": "Codes break nicely into a 16x16 matrix, represented as a 2-digit hex number. The high nibble represents the code\u2019s kind or \u201ccategory\u201d, and the low nibble contains the state or \u201creason\u201d. We present them below as separate tables per range for explanatory and layout reasons.", "As a Grid": "Status codes are encoded as abyte. Hex values break nicely into high and low nibbles:categoryandreason. For instance,0x01stands for general success (ie:true) and0x00for general failure (ie:false).", "Example Function Change": "Status codes are encoded as abyte. Hex values break nicely into high and low nibbles:categoryandreason. For instance,0x01stands for general success (ie:true) and0x00for general failure (ie:false).", "Example Sequence Diagrams": "Status codes are encoded as abyte. Hex values break nicely into high and low nibbles:categoryandreason. For instance,0x01stands for general success (ie:true) and0x00for general failure (ie:false).", "Rationale": "Status codes are encoded as abyte. Hex values break nicely into high and low nibbles:categoryandreason. For instance,0x01stands for general success (ie:true) and0x00for general failure (ie:false).", "Encoding": "Status codes are encoded as abyte. Hex values break nicely into high and low nibbles:categoryandreason. For instance,0x01stands for general success (ie:true) and0x00for general failure (ie:false).", "Multiple Returns": "While there may be cases where packing a byte array of status codes may make sense, the simplest, most forwards-compatible method of transmission is as the first value of a multiple return.", "Human Readable": "Developers should not be required to memorize 256 codes. However, they break nicely into a table. Cognitive load is lowered by organizing the table into categories and reasons.0x10and0x11belong to the same category, and0x04shares a reason with0x24", "Extensibility": "The0xAcategory is reserved for application-specific statuses. In the case that 256 codes become insufficient,bytes1may be embedded in larger byte arrays.", "EVM Codes": "The EVM also returns a status code in transactions; specifically0x00and0x01. This proposal both matches the meanings of those two codes, and could later be used at the EVM level.", "Empty Space": "Much like how HTTP status codes have large unused ranges, there are totally empty sections in this proposal. The intent is to not impose a complete set of codes up front, and to allow users to suggest uses for these spaces as time progresses.", "Beyond Errors": "This spec is intended to be much more than a set of common errors. One design goal is to enable easier contract-to-contract communication, protocols built on top of status codes, and flows that cross off-chain. Many of these cases include either expected kinds of exception state (as opposed to true errors), neutral states, time logic, and various successes.", "Fullyrevertable": "This spec is fully compatible withrevert-with-reason and does not intend to supplant it in any way.Both by reverting with a common code, the developer can determine what went wrong from a set of known error states.", "Nibble Order": "Nibble order makes no difference to the machine, and is purely mnemonic. This design was originally in opposite order, but changed it for a few convenience factors. Since it\u2019s a different scheme from HTTP, it may feel strange initially, but becomes very natural after a couple hours of use.", "Implementation": "Reference cases and helper libraries (Solidity and JS) can be found at:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1077, "url": "https://eips.ethereum.org/EIPS/eip-1077", "title": "Gas relay for contract calls", "authors": ["Alex Van de Sande\u00a0<", "avsa@ethereum.org", ">", "Ricardo Guilherme Schmidt\u00a0(", "@3esmit", ")"], "sections": {"ERC-1077: Gas relay for contract calls": "A standard interface for gas abstraction in top of smart contracts.", "": "A standard interface for gas abstraction in top of smart contracts.", "Simple Summary": "A standard interface for gas abstraction in top of smart contracts.", "Abstract": "A main barrier for the adoption of DApps is the requirement of multiple tokens for executing in chain actions. Allowing users to sign messages to show intent of execution, but allowing a third party relayer to execute them can circumvent this problem, while ETH will always be required for ethereum transactions, it\u2019s possible for smart contract to takeEIP-191signatures and forward a payment incentive to an untrusted party with ETH for executing the transaction.", "Motivation": "Standardizing a common format for them, as well as a way in which the user allows the transaction to be paid in tokens, gives app developers a lot of flexibility and can become the main way in which app users interact with the Blockchain.", "Specification": "Executes_execDatawith currentlastNonce()and paysmsg.senderthe gas used in specified_gasToken.", "Methods": "Executes_execDatawith currentlastNonce()and paysmsg.senderthe gas used in specified_gasToken.", "executeGasRelayMsg": "Returns theexecuteGasRelaymessage used for signing messages..", "Signed Message": "The signed message require the following fields:", "Rationale": "User pain points:", "Multiple signatures": "More than one signed transaction with the same parameter can be executed by this function at the same time, by passing all signatures in themessageSignaturesfield. That field will split the signature in multiple 72 character individual signatures and evaluate each one. This is used for cases in which one action might require the approval of multiple parties, in a single transaction.", "Keep track of nonces:": "Note thatexecuteGasRelayfunction does not take a_nonceas parameter. The contract knows what is the current nonce, and can only execute the transactions in order, therefore there is no reason", "Execute transaction": "After signature validation, the evaluation of_execBytesis up to the account contract implementation, it\u2019s role of the wallet to properly use the account contract and it\u2019s gas relay method. \nA common pattern is to expose an interface which can be only called by the contract itself. The_execBytescould entirely forward the call in this way, as example:address(this).call.gas(_gasLimit)(_execData);Where_execDatacould call any method of the contract itself, for example:", "Gas accounting and refund": "The implementing contract must keep track of the gas spent. One way to do it is to first callgasLeft()at the beginning of the function and then after executing the desired action and compare the difference.", "Usage examples": "This scheme opens up a great deal of possibilities on interaction as well as different experiments on business models:", "Backwards Compatibility": "There is no issues with backwards compatibility, however for future upgrades, as_execDatacontains arbitrary data evaluated by the account contract, it\u2019s up to the contract to handle properly this data and therefore contracts can gas relay any behavior with the current interface.", "Test Cases": "TBD", "Implementation": "One initial implementation of such a contract can be found atStatus.im account-contracts repository", "Similar implementations": "The idea of using signed messages as executable intent has been around for a while and many other projects are taking similar approaches, which makes it a great candidate for a standard that guarantees interoperability:", "Security Considerations": "Deployers of transactions (relayers) should be able to call untrusted contracts, which provides no guarantees that the contract they are interacting with correctly implements the standard and they will be reimbursed for gas. To prevent being fooled by bad implementations, relayers mustestimate the outcome of a transaction, and only include/sign transactions which have a desired outcome.", "Copyright": "Copyright and related rights waived viaCC0.", "References": "Please cite this document as:", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1078, "url": "https://eips.ethereum.org/EIPS/eip-1078", "title": "Universal login / signup using ENS subdomains", "authors": ["Alex Van de Sande\u00a0<", "avsa@ethereum.org", ">"], "sections": {"ERC-1078: Universal login / signup using ENS subdomains": "This presents a method to replace the usual signup/login design pattern with a minimal ethereum native scheme, that doesn\u2019t require passwords, backing up private keys nor typing seed phrases. From the user\u2019s point of view it will be very similar to patterns they\u2019re already used to with second factor authentication (without relying in a central server), but for dapp developers it requires a new way to think about ethereum transactions.", "": "This presents a method to replace the usual signup/login design pattern with a minimal ethereum native scheme, that doesn\u2019t require passwords, backing up private keys nor typing seed phrases. From the user\u2019s point of view it will be very similar to patterns they\u2019re already used to with second factor authentication (without relying in a central server), but for dapp developers it requires a new way to think about ethereum transactions.", "Abstract": "This presents a method to replace the usual signup/login design pattern with a minimal ethereum native scheme, that doesn\u2019t require passwords, backing up private keys nor typing seed phrases. From the user\u2019s point of view it will be very similar to patterns they\u2019re already used to with second factor authentication (without relying in a central server), but for dapp developers it requires a new way to think about ethereum transactions.", "Simple Summary": "The unique identifier of the user is a contract that implements both Identity and the Executable Signed Messages ERCs. The user should not need to provide this address directly, only a ENS name pointing to it. These types of contracts are indirectly controlled by private keys that can sign messages indicating intents, which are then deployed to the contract by a third party (or a decentralized network of deployers).", "Implementation": "No working examples of this implementation exists, but many developers have expressed interest in adopting it. This section will be edited in the future to reflect that.", "Conclusion and future improvements": "This scheme would allow much more lighter apps, that don\u2019t require holding ether, and can keep unlocked private keys on the device to be able to send messages and play games without requesting user prompt every time. More work is needed to standardize common decentralized messaging protocols as well as open source tools for deployment nodes, in order to create a decentralized and reliable layer for message deployment.", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1080, "url": "https://eips.ethereum.org/EIPS/eip-1080", "title": "Recoverable Token", "authors": ["Bradley Leatherwood\u00a0<", "bradleat@inkibra.com", ">"], "sections": {"ERC-1080: Recoverable Token": "A standard interface for tokens that support chargebacks, theft prevention, and lost & found resolutions.", "": "A standard interface for tokens that support chargebacks, theft prevention, and lost & found resolutions.", "Simple Summary": "A standard interface for tokens that support chargebacks, theft prevention, and lost & found resolutions.", "Abstract": "The following standard allows for the implementation of a standard API for tokens extending ERC-20 or ERC-791. This standard provides basic functionality to recover stolen or lost accounts, as well as provide for the chargeback of tokens.", "Motivation": "To mitigate the effects of reasonably provable token or asset loss or theft and to help resolve other conflicts. Ethereum\u2019s protocol should not be modified because of loss, theft, or conflicts, but it is possible to solve these problems in the smart contract layer.", "Specification": "Reports thelostAccountaddress as being lost. MUST trigger theAccountClaimedLostevent.", "RecoverableToken": "Reports thelostAccountaddress as being lost. MUST trigger theAccountClaimedLostevent.", "Methods": "Reports thelostAccountaddress as being lost. MUST trigger theAccountClaimedLostevent.", "Events": "The recovery of an account that was lost or stolen.", "Rationale": "Pending.", "Implementation": "Pending.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1081, "url": "https://eips.ethereum.org/EIPS/eip-1081", "title": "Standard Bounties", "authors": ["Mark Beylin\u00a0<", "mark.beylin@consensys.net", ">", "Kevin Owocki\u00a0<", "kevin.owocki@consensys.net", ">", "Ricardo Guilherme Schmidt\u00a0(", "@3esmit", ")"], "sections": {"ERC-1081: Standard Bounties": "A standard contract and interface for issuing bounties on Ethereum, usable for any type of task, paying in any ERC20 token or in ETH.", "": "A standard contract and interface for issuing bounties on Ethereum, usable for any type of task, paying in any ERC20 token or in ETH.", "Simple Summary": "A standard contract and interface for issuing bounties on Ethereum, usable for any type of task, paying in any ERC20 token or in ETH.", "Abstract": "In order to encourage cross-platform interoperability of bounties on Ethereum, and for easier reputational tracking, StandardBounties can facilitate the administration of funds in exchange for deliverables corresponding to a completed task, in a publicly auditable and immutable fashion.", "Motivation": "In the absence of a standard for bounties on Ethereum, it would be difficult for platforms to collaborate and share the bounties which users create (thereby recreating the walled gardens which currently exist on Web2.0 task outsourcing platforms). A standardization of these interactions across task types also makes it far easier to track various reputational metrics (such as how frequently you pay for completed submissions, or how frequently your work gets accepted).", "Specification": "After studying bounties as they\u2019ve existed for thousands of years (and after implementing and processing over 300 of them on main-net in beta), we\u2019ve discovered that there are 3 core steps to every bounty:", "Rationale": "The development of this standard began a year ago, with the goal of encouraging interoperability among bounty implementations on Ethereum. The initial version had significantly more restrictions: a bounty\u2019sdatacould not be changed after issuance (it seemed unfair for bountyissuers to change the requirements after work is underway), and the bounty payout could not be changed (all funds needed to be deposited in the bounty contract before it could accept submissions).", "Test Cases": "Tests for our implementation can be found here: https://github.com/Bounties-Network/StandardBounties/tree/develop/test", "Implementation": "A reference implementation can be found here: https://github.com/Bounties-Network/StandardBounties/blob/develop/contracts/StandardBounty.solAlthough this code has been tested, it has not yet been audited or bug-bountied, so we cannot make any assertions about it\u2019s correctness, nor can we presently encourage it\u2019s use to hold funds on the Ethereum mainnet.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1129, "url": "https://eips.ethereum.org/EIPS/eip-1129", "title": "Standardised DAPP announcements", "authors": ["Jan Turk\u00a0(", "@ThunderDeliverer", ")"], "sections": {"ERC-1129: Standardised DAPP announcements": "Standardisation of announcements in DAPPs and services on Ethereum network. This ERC provides proposed mechanics to increase the quality of service provided by DAPP developers and service providers, by setting a framework for announcements. Be it transitioning to a new smart contract or just freezing the service for some reason.", "": "Standardisation of announcements in DAPPs and services on Ethereum network. This ERC provides proposed mechanics to increase the quality of service provided by DAPP developers and service providers, by setting a framework for announcements. Be it transitioning to a new smart contract or just freezing the service for some reason.", "Simple Summary": "Standardisation of announcements in DAPPs and services on Ethereum network. This ERC provides proposed mechanics to increase the quality of service provided by DAPP developers and service providers, by setting a framework for announcements. Be it transitioning to a new smart contract or just freezing the service for some reason.", "Abstract": "The proposed ERC defines format on how to post announcements about the service as well as how to remove them. It also defines mechanics on posting permissions and human friendly interface.", "Motivation": "Currently there are no guidelines on how to notify the users of the service status in the DAPPs. This is especially obvious in ERC20 and it\u2019s derivates. If the service is impeded by any reason it is good practice to have some sort of guidelines on how to announce that to the user. The standardisation would also provide traceability of the service\u2019s status.", "Specification": "Stores information about the announcement maker. TheallowedToPoststores posting permissions and is used for modifiers limiting announcement posting only to authorised entities. Thenameis used for human friendly identifier of the author to be stored.", "Structures": "Stores information about the announcement maker. TheallowedToPoststores posting permissions and is used for modifiers limiting announcement posting only to authorised entities. Thenameis used for human friendly identifier of the author to be stored.", "Methods": "Returns the number of announcements currently active.", "Events": "MUST trigger when new announcement is created.", "Rationale": "The proposed solution was designed with UX in mind . It provides mechanics that serve to present the announcements in the user friendly way. It is meant to be deployed as a Solidity smart contract on Ethereum network.", "Test Cases": "The proposed version is deployed on Ropsten testnet all of the information can be foundhere.", "Implementation": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1132, "url": "https://eips.ethereum.org/EIPS/eip-1132", "title": "Extending ERC20 with token locking capability", "authors": ["nitika-goel\u00a0<", "nitika@govblocks.io", ">"], "sections": {"ERC-1132: Extending ERC20 with token locking capability": "An extension to the ERC20 standard with methods for time-locking of tokens within a contract.", "": "An extension to the ERC20 standard with methods for time-locking of tokens within a contract.", "Simple Summary": "An extension to the ERC20 standard with methods for time-locking of tokens within a contract.", "Abstract": "This proposal provides basic functionality to time-lock tokens within an ERC20 smart contract for multiple utilities without the need of transferring tokens to an external escrow smart contract.  It also allows fetching balance of locked and transferable tokens.", "Motivation": "dApps often require tokens to be time-locked against transfers for letting members 1) adhere to vesting schedules and 2) show skin in the game to comply with the underlying business process. I realized this need while building Nexus Mutual and GovBlocks.", "Specification": "I\u2019ve extended the ERC20 interface with the following enhancements:", "Locking of tokens": "event Locked(address indexed _of, uint256 indexed _reason, uint256 _amount, uint256 _validity)", "Fetching number of tokens locked under each utility": "event Locked(address indexed _of, uint256 indexed _reason, uint256 _amount, uint256 _validity)", "Fetching number of tokens locked under each utility at a future timestamp": "event Locked(address indexed _of, uint256 indexed _reason, uint256 _amount, uint256 _validity)", "Fetching number of tokens held by an address": "event Locked(address indexed _of, uint256 indexed _reason, uint256 _amount, uint256 _validity)", "Extending lock period": "event Locked(address indexed _of, uint256 indexed _reason, uint256 _amount, uint256 _validity)", "Increasing number of tokens locked": "event Locked(address indexed _of, uint256 indexed _reason, uint256 _amount, uint256 _validity)", "Fetching number of unlockable tokens under each utility": "event Locked(address indexed _of, uint256 indexed _reason, uint256 _amount, uint256 _validity)", "Fetching number of unlockable tokens": "event Locked(address indexed _of, uint256 indexed _reason, uint256 _amount, uint256 _validity)", "Unlocking tokens": "event Locked(address indexed _of, uint256 indexed _reason, uint256 _amount, uint256 _validity)", "Lock event recorded in the token contract": "event Locked(address indexed _of, uint256 indexed _reason, uint256 _amount, uint256 _validity)", "Unlock event recorded in the token contract": "event Unlocked(address indexed _of, uint256 indexed _reason, uint256 _amount)", "Test Cases": "Test cases are available athttps://github.com/nitika-goel/lockable-token.", "Implementation": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1175, "url": "https://eips.ethereum.org/EIPS/eip-1175", "title": "Wallet & shop standard for all tokens (erc20)", "authors": ["Jet Lim\u00a0(", "@Nitro888", ")"], "sections": {"ERC-1175: Wallet & shop standard for all tokens (erc20)": "Make wallets and shops created from certified contracts make erc20 tokens easy to use for commerce.", "": "Make wallets and shops created from certified contracts make erc20 tokens easy to use for commerce.", "All tokens go to heaven": "Make wallets and shops created from certified contracts make erc20 tokens easy to use for commerce.", "Simple Summary": "Make wallets and shops created from certified contracts make erc20 tokens easy to use for commerce.", "Abstract": "The mutual trust between the wallet and the shop created by the authenticated contract allows you to pay for and purchase items at a simple process.", "Motivation": "New standards with improvements have been released, but the majority of tokens currently being developed are erc20 tokens. So I felt I needed a proposal to use old tokens in commerce.\n To use various erc20 tokens for trading, you need a custom contract. However, a single wallet with a variety of tokens, and a mutually trusted store, can make transactions that are simple and efficient. The erc20 token is traded through two calls,approve (address _spender, uint256 _value)andtransferFrom (address _from, address _to, uint256 _value), but when using the wallet contract,paySafe (address _shop, uint256 _item)will be traded only in one call.\nAnd if you only reuse the store interface, you can also trade usingpayUnsafe (address _shop, uint256 _item).", "Specification": "", "WalletCenter": "Create wallet contract and add to list. Returns the address of new wallet.", "Methods": "Returns the account balance of Shop.", "Events": "Sample token contract address is0x393dd70ce2ae7b30501aec94727968c517f90d52", "Wallet": "Wallet must be created by wallet center.", "Shop": "Shop is created by wallet center or not. but Shop that created by wallet center is called safe shop.", "Implementation": "Sample token contract address is0x393dd70ce2ae7b30501aec94727968c517f90d52", "Appendix": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1178, "url": "https://eips.ethereum.org/EIPS/eip-1178", "title": "Multi-class Token Standard", "authors": ["Albert Chon\u00a0<", "achon@stanford.edu", ">"], "sections": {"ERC-1178: Multi-class Token Standard": "A standard interface for multi-class fungible tokens.", "": "A standard interface for multi-class fungible tokens.", "Simple Summary": "A standard interface for multi-class fungible tokens.", "Abstract": "This standard allows for the implementation of a standard API for multi-class fungible tokens (henceforth referred to as \u201cMCFTs\u201d) within smart contracts. This standard provides basic functionality to track and transfer ownership of MCFTs.", "Motivation": "Currently, there is no standard to support tokens that have multiple classes. In the real world, there are many situations in which defining distinct classes of the same token would be fitting (e.g. distinguishing between preferred/common/restricted shares of a company). Yet, such nuance cannot be supported in today\u2019s token standards. An ERC-20 token contract defines tokens that are all of one class while an ERC-721 token contract creates a class (defined by token_id) for each individual token. The ERC-1178 token standard proposes a new standard for creating multiple classes of tokens within one token contract.", "Specification": "name", "ERC-20 Compatibility (partial)": "name", "Basic Ownership": "approve", "Advanced Ownership and Exchange": "Allows holder of one token to allow another individual (or the smart contract itself) to approve the exchange of their tokens of one class for tokens of another class at their specified exchange rate (see sample implementation for more details). This is equivalent to posting a bid in a marketplace.", "Events": "Transfer", "Rationale": "The design of this project was motivated when I tried to create different classes of fungible ERC-721 tokens (an oxymoron) but ran into gas limits from having to create each tokens individually and maintain them in an efficient data structure for access. Using the maximum gas amount one can send with a transaction on Metamask (a popular web wallet), I was only able to create around 46 ERC-721 tokens before exhausting all gas. This experience motivated the creation of the multi-class fungible token standard.", "Current Limitations": "The design of this project was motivated when I tried to create different classes of fungible ERC-721 tokens (an oxymoron) but ran into gas limits from having to create each tokens individually and maintain them in an efficient data structure for access. Using the maximum gas amount one can send with a transaction on Metamask (a popular web wallet), I was only able to create around 46 ERC-721 tokens before exhausting all gas. This experience motivated the creation of the multi-class fungible token standard.", "Backwards Compatibility": "Adoption of the MCFT standard proposal would not pose backwards compatibility issues as it defines a new standard for token creation. This standard follows the semantics of ERC-721 as closely as possible, but can\u2019t be entirely compatible with it due to the fundamental differences between multi-class fungible and non-fungible tokens. For example, theownerOf,takeOwnership, andtokenOfOwnerByIndexmethods in the ERC-721 token standard cannot be implemented in this standard. Furthermore, the function arguments tobalanceOf,approve, andtransferdiffer as well.", "Implementation": "A sample implementation can be foundhere", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1203, "url": "https://eips.ethereum.org/EIPS/eip-1203", "title": "ERC-1203 Multi-Class Token Standard (ERC-20 Extension)", "authors": ["Jeff Huang\u00a0<", "jeffishjeff@gmail.com", ">", "Min Zu\u00a0<", "crawlregister@gmail.com", ">"], "sections": {"ERC-1203: ERC-1203 Multi-Class Token Standard (ERC-20 Extension)": "A standard interface for multi-class tokens (MCTs).", "": "A standard interface for multi-class tokens (MCTs).", "Simple Summary": "A standard interface for multi-class tokens (MCTs).", "Abstract": "The following standard allows for the implementation of a standard API for MCTs within smart contracts. This standard provides basic functionality to track, transfer, and convert MCTs.", "Motivation": "This standard is heavily inspired by ERC-20 Token Standard and ERC-721 Non-Fungible Token Standard. However, whereas these standards are chiefly concerned with representation of items/value in a single class, fungible or note, this proposed standard focus on that of a more complexed, multi-class system. It is fair to think of MCTs as a hybrid of fungible tokens (FT) and non-fungible tokens (NFTs), that is tokens are fungible within the same class but non-fungible with that from a different class. And conversions between classes may be optionally supported.", "Specification": "Please seeERC-20 Token Standardfor detailed specifications. Do note that these methods and events only work on the \u201cdefault\u201d class of an MCT.", "ERC-20 Methods and Events (fully compatible)": "Please seeERC-20 Token Standardfor detailed specifications. Do note that these methods and events only work on the \u201cdefault\u201d class of an MCT.", "Tracking and Transferring": "totalSupply", "Conversion and Dilution": "fullyDilutedTotalSupply", "Rationale": "This standard purposely extends ERC-20 Token Standard so that new MCTs following or existing ERC-20 tokens extending this standard are fully compatible with current wallets and exchanges. In addition, new methods and events are kept as closely to ERC-20 conventions as possible for ease of adoption.", "Backwards Compatibility": "This EIP is fully compatible with the mandatory methods of ERC20 Token Standard so long as the implementation includes a \u201clowest common denominator\u201d class, which may be class B common/gold coin/money in the abstract/virtual/physical examples above respectively. Where it is not possible to implement such class, then the implementation should specify a default class for tracking or transferring unless otherwise specified, e.g. US dollar is transferred unless other currency is explicitly specified.", "Test Cases": "The repository atjeffishjeff/ERC-1203contains thesample test cases.", "Implementation": "The repository atjeffishjeff/ERC-1203contains thesample implementation.", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1207, "url": "https://eips.ethereum.org/EIPS/eip-1207", "title": "DAuth Access Delegation Standard", "authors": ["Xiaoyu Wang\u00a0(", "@wxygeek", ")", "Bicong Wang\u00a0(", "@Wangbicong", ")"], "sections": {"ERC-1207: DAuth Access Delegation Standard": "DAuth is a standard interface for accessing authorization delegation between smart contracts and users.", "": "DAuth is a standard interface for accessing authorization delegation between smart contracts and users.", "DAuth Access Delegation Standard": "DAuth is a standard interface for accessing authorization delegation between smart contracts and users.", "Simple Summary": "DAuth is a standard interface for accessing authorization delegation between smart contracts and users.", "Abstract": "The DAuth protocol defines a set of standard API allowing identity delegations between smart contracts without the user\u2019s private key.  Identity delegations include accessing and operating a user\u2019s data and assets contained in the delegated contracts.", "Motivation": "The inspiration for designing DAuth comes from OAuth protocol that is extensively used in web applications. But unlike the centralized authorization of OAuth, DAuth works in a  distributed manner, thus providing much more reliability and generality.", "Specification": "", "Rationale": "Current Limitations", "Backwards Compatibility": "This EIP introduces no backward compatibility issues. In the future, the new version protocol has to keep these interfaces.", "Implementation": "Following is the DAuth Interface implementation. Furthermore, the example implementations of EIP20 Interface and ERC-DAuth Interface are also provided. Developers can easily implement their own contracts with ERC-DAuth Interface and other EIP.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1261, "url": "https://eips.ethereum.org/EIPS/eip-1261", "title": "Membership Verification Token (MVT)", "authors": ["Chaitanya Potti\u00a0(", "@chaitanyapotti", ")", "Partha Bhattacharya\u00a0(", "@pb25193", ")"], "sections": {"ERC-1261: Membership Verification Token (MVT)": "A standard interface for Membership Verification Token(MVT).", "": "A standard interface for Membership Verification Token(MVT).", "Simple Summary": "A standard interface for Membership Verification Token(MVT).", "Abstract": "The following standard allows for the implementation of a standard API for Membership Verification Token within smart contracts(called entities). This standard provides basic functionality to track membership of individuals in certain on-chain \u2018organizations\u2019. This allows for several use cases like automated compliance, and several forms of governance and membership structures.", "Motivation": "A standard interface allows any user, applications to work with any MVT on Ethereum. We provide for simple ERC-1261 smart contracts. Additional applications are discussed below.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Caveats": "The 0.4.24 Solidity interface grammar is not expressive enough to document the ERC-1261 standard. A contract which complies with ERC-1261 MUST also abide by the following:", "Rationale": "There are many potential uses of Ethereum smart contracts that depend on tracking membership. Examples of existing or planned MVT systems are Vault, a DAICO platform, and Stream, a security token framework. Future uses include the implementation of direct democracy, in-game memberships and badges, licence and travel document issuance, electronic voting machine trails, software licencing and many more.", "Backwards Compatibility": "We have adoptednameandsymbolsemantics from the ERC-20 specification.", "Test Cases": "Membership Verification Token ERC-1261 Token includes test cases written using Truffle.", "Implementations": "Membership Verification Token ERC1261 \u2013 a reference implementation", "References": "Standards", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1319, "url": "https://eips.ethereum.org/EIPS/eip-1319", "title": "Smart Contract Package Registry Interface", "authors": ["Piper Merriam\u00a0<", "piper@ethereum.org", ">", "Christopher Gewecke\u00a0<", "christophergewecke@gmail.com", ">", "g. nicholas d'andrea\u00a0<", "nick.dandrea@consensys.net", ">", "Nick Gheorghita\u00a0(", "@njgheorghita", ")"], "sections": {"ERC-1319: Smart Contract Package Registry Interface": "A standard interface for smart contract package registries.", "": "A standard interface for smart contract package registries.", "Simple Summary": "A standard interface for smart contract package registries.", "Abstract": "This EIP specifies an interface for publishing to and retrieving assets from smart contract package registries. It is a companion EIP to1123which defines a standard for smart contract package manifests.", "Motivation": "The goal is to establish a framework that allows smart contract publishers to design and deploy code registries with arbitrary business logic while exposing a set of common endpoints that tooling can use to retrieve assets for contract consumers.", "Specification": "The specification describes a small read/write API whose components are mandatory. It allows registries to manage versioned releases using the conventions ofsemverwithout imposing this as a requirement. It assumes registries will share the following structure and conventions:", "Examples": "Package Names / Release Versions", "Write API Specification": "The write API consists of a single method,release. It passes the registry the package name, a\nversion identifier for the release, and a URI specifying the location of a manifest which\ndetails the contents of the release.", "Events": "MUST be triggered whenreleaseis successfully called.", "Read API Specification": "The read API consists of a set of methods that allows tooling to extract all consumable data from a registry.", "Rationale": "The proposal hopes to accomplish the following:", "Backwards Compatibility": "No existing standard exists for package registries. The package registry currently deployed by EthPM would not comply with the standard since it implements only one of the method signatures described in the specification.", "Implementation": "A reference implementation of this proposal is in active development at the EthPM organization on GitHubhere.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1337, "url": "https://eips.ethereum.org/EIPS/eip-1337", "title": "Subscriptions on the blockchain", "authors": ["Kevin Owocki\u00a0<", "kevin@gitcoin.co", ">", "Andrew Redden\u00a0<", "andrew@blockcrushr.com", ">", "Scott Burke\u00a0<", "scott@blockcrushr.com", ">", "Kevin Seagraves\u00a0<", "k.s.seagraves@gmail.com", ">", "Luka Kacil\u00a0<", "luka.kacil@gmail.com", ">", "\u0160tefan \u0160imec\u00a0<", "stefan.simec@gmail.com", ">", "Piotr Kosi\u0144ski\u00a0(", "@kosecki123", ")", "ankit raj\u00a0<", "tradeninja7@gmail.com", ">", "John Griffin\u00a0<", "john@atchai.com", ">", "Nathan Creswell\u00a0<", "nathantr@gmail.com", ">"], "sections": {"ERC-1337: Subscriptions on the blockchain": "Monthly subscriptions are a key monetization channel for legacy web, and arguably they are the most healthy monetization channel for businesses on the legacy web (especially when compared to ad/surveillance) based models.  They are arguably more healthy than a token based economic system (depending upon the vesting model of the ICO) because", "": "Monthly subscriptions are a key monetization channel for legacy web, and arguably they are the most healthy monetization channel for businesses on the legacy web (especially when compared to ad/surveillance) based models.  They are arguably more healthy than a token based economic system (depending upon the vesting model of the ICO) because", "Simple Summary": "Monthly subscriptions are a key monetization channel for legacy web, and arguably they are the most healthy monetization channel for businesses on the legacy web (especially when compared to ad/surveillance) based models.  They are arguably more healthy than a token based economic system (depending upon the vesting model of the ICO) because", "Abstract": "To enable replay-able transactions users sign a concatenated bytes hash that is composed of the input data needed to execute the transaction. This data is stored off chain by the recipient of the payment and is transmitted to the customers smart contract for execution alongside a provided signature.", "Motivation": "Recurring payments are the bedrock of SaSS and countless other businesses, a robust specification for defining this interaction will enable a broad spectrum of revenue generation and business models.", "Specification": "EIP-1337 Contracts should be compiled with a contract that references all the enumerations that are required for operation", "Rationale": "Merchants who accept credit-cards do so by storing a token that is retrieved from a third party processor(stripe, paypal, etc), this token is used to grant access to pull payment from the cx\u2019s credit card provider and move funds to the merchant account. \nHaving users sign input data acts in a similliar fashion and enables that merchant to store the signature of the concatenated bytes hash and input data used to generate the hash and pass them off to the contract holding the subscription logic, thus enabling a workflow that is similliar to what exists in the present day legacy web.", "Backwards Compatibility": "N/A", "Test Cases": "TBD", "Implementation": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1386, "url": "https://eips.ethereum.org/EIPS/eip-1386", "title": "Attestation management contract", "authors": ["Weiwu Zhang\u00a0<", "a@colourful.land", ">", "James Sangalli\u00a0<", "j.l.sangalli@gmail.com", ">"], "sections": {"ERC-1386: Attestation management contract": "Very often, we will need to use Attestations like \u201cAlice lives in Australia\u201d on the blockchain; that is issued by a valid issuer off chain for privacy reasons and is revokable inside a smart contract.", "": "Very often, we will need to use Attestations like \u201cAlice lives in Australia\u201d on the blockchain; that is issued by a valid issuer off chain for privacy reasons and is revokable inside a smart contract.", "Introduction": "Very often, we will need to use Attestations like \u201cAlice lives in Australia\u201d on the blockchain; that is issued by a valid issuer off chain for privacy reasons and is revokable inside a smart contract.", "Purpose": "This ERC provides an interface for attestation issuers to manage their attestation signing keys and the attestations that are issued off chain for actions such as revocation and validation.", "Example use cases": "Let\u2019s say that our friend, Alice, wants to buy a bottle of wine to consume with her friends. She wants to do the order online and have it delivered to her home address whilst paying for it with Ether.", "Draft interface": "Please clickhereto see a draft implementation of this interface", "Related ERC\u2019s": "#1388 #1387", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1387, "url": "https://eips.ethereum.org/EIPS/eip-1387", "title": "Merkle Tree Attestations with Privacy enabled", "authors": ["Weiwu Zhang\u00a0<", "a@colourful.land", ">", "James Sangalli\u00a0<", "j.l.sangalli@gmail.com", ">"], "sections": {"ERC-1387: Merkle Tree Attestations with Privacy enabled": "It\u2019s often needed that an Ethereum smart contract must verify a claim (I live in Australia) attested by a valid attester.", "": "It\u2019s often needed that an Ethereum smart contract must verify a claim (I live in Australia) attested by a valid attester.", "Introduction": "It\u2019s often needed that an Ethereum smart contract must verify a claim (I live in Australia) attested by a valid attester.", "Purpose": "This ERC provides an interface and reference implementation for smart contracts that need users to provide an attestation and validate it.", "Draft implementation": "Hereis an example implementation of the MerkleTreeAttestationInterfaceHereis an example service which would use such a merkle tree attestation", "Relevant implementation examples": "Hereis an example implementation of the MerkleTreeAttestationInterfaceHereis an example service which would use such a merkle tree attestation", "Related ERC\u2019s": "#1388 #1386", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1388, "url": "https://eips.ethereum.org/EIPS/eip-1388", "title": "Attestation Issuers Management List", "authors": ["Weiwu Zhang\u00a0<", "a@colourful.land", ">", "James Sangalli\u00a0<", "j.l.sangalli@gmail.com", ">"], "sections": {"ERC-1388: Attestation Issuers Management List": "In smart contracts, we will need methods to handle cryptographic attestations to a users identifier or abilities. Let\u2019s say we have a real estate agent, KiwiRealtors, that provides an \u201cexpression of interest\u201d function though a smart contract and requires the users to provide an attestation that they are a resident of New Zealand or Australia, as a legal requirement. This has actually happened in the New Zealand property market and it is the perfect example of a need to handle such attestations.", "": "In smart contracts, we will need methods to handle cryptographic attestations to a users identifier or abilities. Let\u2019s say we have a real estate agent, KiwiRealtors, that provides an \u201cexpression of interest\u201d function though a smart contract and requires the users to provide an attestation that they are a resident of New Zealand or Australia, as a legal requirement. This has actually happened in the New Zealand property market and it is the perfect example of a need to handle such attestations.", "Introduction": "In smart contracts, we will need methods to handle cryptographic attestations to a users identifier or abilities. Let\u2019s say we have a real estate agent, KiwiRealtors, that provides an \u201cexpression of interest\u201d function though a smart contract and requires the users to provide an attestation that they are a resident of New Zealand or Australia, as a legal requirement. This has actually happened in the New Zealand property market and it is the perfect example of a need to handle such attestations.", "Purpose": "This ERC provides a smart contract interface for anyone to manage a list of attestation issuers. A smart contract would explicitly trust a list, and therefore all attestations issued by the issuers on the list.", "Draft implementation": "Clickhereto see an example implementation of this ERC", "Related ERC\u2019s": "#1387 #1386", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1417, "url": "https://eips.ethereum.org/EIPS/eip-1417", "title": "Poll Standard", "authors": ["Chaitanya Potti\u00a0(", "@chaitanyapotti", ")", "Partha Bhattacharya\u00a0(", "@pb25193", ")"], "sections": {"ERC-1417: Poll Standard": "A standard interface for Polls to be used with EIP-1261 (MVT).", "": "A standard interface for Polls to be used with EIP-1261 (MVT).", "Note to Readers": "A standard interface for Polls to be used with EIP-1261 (MVT).", "Simple Summary": "A standard interface for Polls to be used with EIP-1261 (MVT).", "Abstract": "The following standard allows for the implementation of a standard API for polls to be used with MVTs (referEIP-1261). The standard provides basic functionality to vote, unvote, tally votes, get voter turnout, and a lot more. The poll standard attempts to modularize blockchain voting by breaking down a poll into 4 crucial building blocks: voterbase qualification, vote weight calculation, vote consequences, and vote tallying. By creating a common interface for polls that have different kinds of building blocks, the poll standard makes it possible to make interactive front end applications which can seamlessly get data from a poll contract in order to bring transparency into consensus and decision making on the blockchain.", "Motivation": "A standard interface allows any user or applications to work with any Poll contract on Ethereum. We provide for simple ERC-1417 smart contracts. Additional applications are discussed below.", "Benefits": "Polls are useful in any context of collective decision making, which include but aren\u2019t limited to:", "Use-cases:": "Polls are useful in any context of collective decision making, which include but aren\u2019t limited to:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Caveats": "The 0.4.24 Solidity interface grammar is not expressive enough to document the ERC-1417 standard. A contract which complies with ERC-1417 MUST also abide by the following:", "Rationale": "As the poll standard is built with the intention of creating a system that allows for more transparency and accessibility of governance data, the design choices in the poll standard are driven by this motivator. In this section we go over some of the major design choices, and why these choices were made:", "Test Cases": "Voting Standard includes test cases written using Truffle.", "Implementations": "Voting Standard \u2013 a reference implementation", "References": "Standards", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1438, "url": "https://eips.ethereum.org/EIPS/eip-1438", "title": "dApp Components (avatar) & Universal Wallet", "authors": ["Jet Lim\u00a0(", "@Nitro888", ")"], "sections": {"ERC-1438: dApp Components (avatar) & Universal Wallet": "Contracts are open source based. And most developers use the public contracts at the start of the project to modify or simply include them. This is project-oriented centralized development and I think it is a waste of resources. Therefore, we propose to make dApp or contracts component-ready for use in other services.", "": "Contracts are open source based. And most developers use the public contracts at the start of the project to modify or simply include them. This is project-oriented centralized development and I think it is a waste of resources. Therefore, we propose to make dApp or contracts component-ready for use in other services.", "Simple Summary": "Contracts are open source based. And most developers use the public contracts at the start of the project to modify or simply include them. This is project-oriented centralized development and I think it is a waste of resources. Therefore, we propose to make dApp or contracts component-ready for use in other services.", "Abstract": "There have been suggestions for modified tokens based on erc20, but since many tokens have already been built on erc20, it is necessary to increase the utilization of already developed erc20 tokens. Therefore, we propose a universal wallet that can use erc20 tokens universally. We also propose a component dApp that allows you to create and save your avatar (& social badge system), and use it immediately in other services. All of the dApps suggested in this document are based on decentralized development and use that anyone can create and participate in.", "Motivation": "While many projects are under development in an open source way, they are simply adding and deploy with open sources to their projects. This means that you are developing a centralized service that uses your own dApp-generated information on your own. In order to improve the block chain ecosystem, all resources created by dApp and placed in the public block chain must be reusable in another dApp. This means that you can enhance your service by exchanging the generated information with other dApp. Likewise, ERC20 Tokens require Universal Wallet standards to be easy to use for direct transactions.", "Seeds for improvement of the blockchain ecosystem.": "", "Specification": "The avatar\u2019s information & assets are stored in the event log part of the block chain.", "1. Avatar": "The avatar\u2019s information & assets are stored in the event log part of the block chain.", "2. Universal Wallet": "", "Test Cases": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1444, "url": "https://eips.ethereum.org/EIPS/eip-1444", "title": "Localized Messaging with Signal-to-Text", "authors": ["Brooklyn Zelenka\u00a0(", "@expede", ")", "Jennifer Cooper\u00a0(", "@jenncoop", ")"], "sections": {"ERC-1444: Localized Messaging with Signal-to-Text": "A method of converting machine codes to human-readable text in any language and phrasing.", "": "A method of converting machine codes to human-readable text in any language and phrasing.", "Simple Summary": "A method of converting machine codes to human-readable text in any language and phrasing.", "Abstract": "An on-chain system for providing user feedback by converting machine-efficient codes into human-readable strings in any language or phrasing. The system does not impose a list of languages, but rather lets users create, share, and use the localizated text of their choice.", "Motivation": "There are many cases where an end user needs feedback or instruction from a smart contract. Directly exposing numeric codes does not make for good UX or DX. If Ethereum is to be a truly global system usable by experts and lay persons alike, systems to provide feedback on what happened during a transaction are needed in as many languages as possible.", "Specification": "Two types of contract:LocalizationPreferences, andLocalizations.", "Contract Architecture": "Two types of contract:LocalizationPreferences, andLocalizations.", "Localization": "A contract that holds a simple mapping of codes to their text representations.", "LocalizationPreferences": "A proxy contract that allows users to set their preferredLocalization. Text lookup is delegated to the user\u2019s preferred contract.", "String Format": "All strings MUST be encoded asUTF-8.", "Templates": "Template strings are allowed, and MUST follow theANSI Cprintfconventions.", "Rationale": "bytes32is very efficient since it is the EVM\u2019s base word size. Given the enormous number of elements (card(A) > 1.1579 \u00d7 1077), it can embed nearly any practical signal, enum, or state. In cases where an application\u2019s key is longer thanbytes32, hashing that long key can map that value into the correct width.", "bytes32Keys": "bytes32is very efficient since it is the EVM\u2019s base word size. Given the enormous number of elements (card(A) > 1.1579 \u00d7 1077), it can embed nearly any practical signal, enum, or state. In cases where an application\u2019s key is longer thanbytes32, hashing that long key can map that value into the correct width.", "Local vs Globals and Singletons": "This spec has opted to notforcea single global registry, and rather allow any contract and use case deploy their own system. This allows for more flexibility, and does not restrict the community for opting to use singletonLocalizationPreferencecontracts for common use cases, shareLocalizations between different proxys, delegate translations betweenLocalizations, and so on.", "Off Chain Storage": "A very viable alternative is to store text off chain, with a pointer to the translations on-chain, and emit or return abytes32code for another party to do the lookup. It is difficult to guarantee that off-chain resources will be available, and requires coordination from some other system like a web server to do the code-to-text matching. This is also not compatible withrevertmessages.", "ASCII vs UTF-8 vs UTF-16": "UTF-8 is the most widely used encoding at time of writing. It contains a direct embedding of ASCII, while providing characters for most natural languages, emoji, and special characters.", "When No Text is Found": "Returning a blank string to the requestor fully defeats the purpose of a localization system. The two options for handling missing text are:", "Decentralized Text Crowdsourcing": "In order for Ethereum to gain mass adoption, users must be able to interact with it in the language, phrasing, and level of detail that they are most comfortable with. Rather than imposing a fixed set of translations as in a traditional, centralized application, this EIP provides a way for anyone to create, curate, and use translations. This empowers the crowd to supply culturally and linguistically diverse messaging, leading to broader and more distributed access to information.", "printf-style Format Strings": "C-styleprintftemplates have been the de facto standard for some time. They have wide compatibility across most languages (either in standard or third-party libraries). This makes it much easier for the consuming program to interpolate strings with low developer overhead.", "Interpolation Strategy": "Please note that it is highly advisable to return the template stringas is, with arguments as multiple return values or fields in anevent, leaving the actual interpolation to be done off chain.", "Unspecified Behaviour": "This spec does not specify:", "Implementation": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1450, "url": "https://eips.ethereum.org/EIPS/eip-1450", "title": "ERC-1450 A compatible security token for issuing and trading SEC-compliant securities", "authors": ["John Shiple\u00a0(", "@johnshiple", ")", "Howard Marks\u00a0<", "howard@startengine.com", ">", "David Zhang\u00a0<", "david@startengine.com", ">"], "sections": {"ERC-1450: ERC-1450 A compatible security token for issuing and trading SEC-compliant securities": "ERC-1450is anERC-20compatible token that enables issuing tokens representing securities that are required to comply with one or more of the followingSecurities Act Regulations: Regulation Crowdfunding, Regulation D, and Regulation A.", "": "ERC-1450is anERC-20compatible token that enables issuing tokens representing securities that are required to comply with one or more of the followingSecurities Act Regulations: Regulation Crowdfunding, Regulation D, and Regulation A.", "ERC-1450 - A compatible security token for issuing and trading SEC-compliant securities": "ERC-1450is anERC-20compatible token that enables issuing tokens representing securities that are required to comply with one or more of the followingSecurities Act Regulations: Regulation Crowdfunding, Regulation D, and Regulation A.", "Simple Summary": "ERC-1450is anERC-20compatible token that enables issuing tokens representing securities that are required to comply with one or more of the followingSecurities Act Regulations: Regulation Crowdfunding, Regulation D, and Regulation A.", "Abstract": "ERC-1450facilitates the recording of ownership and transfer of securities sold in compliance with theSecurities Act Regulations CF, D and A. The issuance and trading of securities is subject to the Securities Exchange Commission (SEC) and specific U.S. state blue sky laws and regulations.", "Motivation": "With the advent of theJOBS Actin 2012 and the launch of Regulation Crowdfunding and the amendments to Regulation A and Regulation D in 2016, there has been an expansion in the exemptions available to Issuers and Investors to sell and purchase securities that have not been \u201cregistered\u201d with the SEC under the Securities Act of 1933.", "Specification": "ERC-1450extendsERC-20.", "ERC-1450": "ERC-1450requires that only the Issuer can create a token representing the security that only the RTA manages. Instantiating theERC-1450requires theOwnedandIssuerControlledmodifiers, and only the Issuer should execute theERC-1450constructor for a compliant token.ERC-1450extends the generalOwnablemodifier to describe a specific subset of owners that automate and decentralize compliance through the contract modifiersOwnedandIssuerControlledand the function modifiersonlyOwnerandonlyIssuerTransferAgent. TheOwnedcontract modifier instantiates theonlyOwnermodifier for functions. TheIssuerControlledmodifier instantiates theonlyIssuerTransferAgentmodifier for functions.", "Issuers and RTAs": "For compliance reasons, theERC-1450constructor must specify the issuer (theowner), the RTA (transferAgent), the security\u2019sname, and the security\u2019ssymbol.", "ERC-20 Extension": "ERC-20tokens provide the following functionality:", "Securities Exchange Commission Requirements": "The SEC has very strict requirements as to the specific roles that are allowed to perform specific actions. Specifically, only the RTA maymintandtransferFromsecurities.", "Managing Investor Information": "Special care and attention must be taken to ensure that the personally identifiable information of Investors is never exposed or revealed to the public.", "Issuers who lost access to their address or private keys": "There is no recourse if the Issuer loses access to their address to an existing instance of their securities. Special care and efforts must be made by the Issuer to secure and safely store their address and associated private key. The Issuer can reassign ownership to another Issuer but not in the case where the Issuer loses their private key.", "Registered Transfer Agents who lost access to their address or private keys": "If the RTA loses access, the RTA can create a new Ethereum address, and the Issuer can execute thesetTransferAgentfunction to reassign the RTA.", "Handling Investors (security owners) who lost access to their addresses or private keys": "Investors may \u201close\u201d their credentials for a number of reasons: they simply \u201clost\u201d their credentials, they were hacked or the victim of fraud, they committed securities-related fraud, or a life event (like death) occurred. Because the RTA manages the Issuer\u2019s securities, the RTA may authorize ownership related changes of securities (as long as they are properly notarized and verified).", "Rationale": "The are currently no token standards that facilitate compliance with SEC regulations. The closest token isERC-884 (Delaware General Corporations Law (DGCL) compatible share token)which states that SEC requirements are out of scope.EIP-1404 (Simple Restricted Token Standard)does not go far enough to address SEC requirements around re-issuing securities to Investors.", "Backwards Compatibility": "ERC-1450maintains compatibility with ERC-20 tokens with the following stipulations:", "Test Cases": "Test cases are available athttps://github.com/StartEngine/ldgr_smart_contracts/tree/master/test.", "Implementations": "A reference implementation is available athttps://github.com/StartEngine/ldgr_smart_contracts.", "Copyright Waiver": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1462, "url": "https://eips.ethereum.org/EIPS/eip-1462", "title": "Base Security Token", "authors": ["Maxim Kupriianov\u00a0<", "mk@atlant.io", ">", "Julian Svirsky\u00a0<", "js@atlant.io", ">"], "sections": {"ERC-1462: Base Security Token": "An extension to ERC-20 standard token that provides compliance with securities regulations and legal enforceability.", "": "An extension to ERC-20 standard token that provides compliance with securities regulations and legal enforceability.", "Simple Summary": "An extension to ERC-20 standard token that provides compliance with securities regulations and legal enforceability.", "Abstract": "This EIP defines a minimal set of additions to the default token standard such asERC-20, that allows for compliance with domestic and international legal requirements. Such requirements include KYC (Know Your Customer) and AML (Anti Money Laundering) regulations, and the ability to lock tokens for an account, and restrict them from transfer due to a legal dispute. Also the ability to attach additional legal documentation, in order to set up a dual-binding relationship between the token and off-chain legal entities.", "Motivation": "There are several security token standards that have been proposed recently. Examples includeERC-1400, alsoERC-1450. We have concerns about each of them, mostly because the scope of each of these EIPs contains many project-specific or market-specific details. Since many EIPs are coming from the respective backing companies, they capture many niche requirements that are excessive for a general case.", "Specification": "The ERC-20 token provides the following basic features:", "Transfer Checking Functions": "We introduce four new functions that should be used to check that the actions are allowed for the provided inputs. The implementation details of each function are left for the token issuer, it is the issuer\u2019s responsibility to add all necessary checks that will validate an operation in accordance with KYC/AML policies and legal requirements set for a specific token asset.", "Documentation Functions": "We also introduce two new functions that should be used for document management purposes. FunctionattachDocumentadds a reference pointing to an off-chain document, with specified name, URI and contents hash. The hashing algorithm is not specified within this standard, but the resulting hash must not be longer than 32 bytes. FunctionlookupDocumentgets the referenced document by its name.", "Rationale": "This EIP targets both ERC-20 and ERC-777 based tokens, although the most emphasis is given to ERC-20 due to its widespread adoption. However, this extension is designed to be compatible with the forthcoming ERC-777 standard, as well.", "Backwards Compatibility": "This EIP is fully backwards compatible as its implementation extends the functionality of ERC-20 and ERC-777 tokens.", "Implementation": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1484, "url": "https://eips.ethereum.org/EIPS/eip-1484", "title": "Digital Identity Aggregator", "authors": ["Anurag Angara\u00a0<", "anurag.angara@gmail.com", ">", "Andy Chorlian\u00a0<", "andychorlian@gmail.com", ">", "Shane Hampton\u00a0<", "shanehampton1@gmail.com", ">", "Noah Zinsmeister\u00a0<", "noahwz@gmail.com", ">"], "sections": {"ERC-1484: Digital Identity Aggregator": "A protocol for aggregating digital identity information that\u2019s broadly interoperable with existing, proposed, and hypothetical future digital identity standards.", "": "A protocol for aggregating digital identity information that\u2019s broadly interoperable with existing, proposed, and hypothetical future digital identity standards.", "Simple Summary": "A protocol for aggregating digital identity information that\u2019s broadly interoperable with existing, proposed, and hypothetical future digital identity standards.", "Abstract": "This EIP proposes an identity management and aggregation framework on the Ethereum blockchain. It allows entities to claim anIdentityvia a singularIdentity Registrysmart contract, associate it with Ethereum addresses in a variety of meaningful ways, and use it to interact with smart contracts. This enables arbitrarily complex identity-related functionality. Notably (among other features) ERC-1484Identities: are self-sovereign, can natively supportERC-725andERC-1056identities, areDID compliant, and can be fully powered bymeta-transactions.", "Motivation": "Emerging identity standards and related frameworks proposed by the Ethereum community (including ERCs/EIPs725,735,780,1056, etc.) define and instrumentalize digital identity in a variety of ways. As existing approaches mature, new standards emerge, and isolated, non-standard approaches to identity develop, coordinating on identity will become increasingly burdensome for blockchain users and developers, and involve the unnecessary duplication of work.", "Definitions": "A digital identity in this proposal can be viewed as an omnibus account, containing more information about an identity than any individual identity application could. This omnibus identity is resolvable to an unlimited number of sub-identities calledResolvers. This allows an atomic entity, theIdentity, to be resolvable to abstract data structures, theResolvers.ResolversrecognizeIdentitiesby any of theirAssociated Addresses, or by theirEIN.", "Specification": "A digital identity in this proposal can be viewed as an omnibus account, containing more information about an identity than any individual identity application could. This omnibus identity is resolvable to an unlimited number of sub-identities calledResolvers. This allows an atomic entity, theIdentity, to be resolvable to abstract data structures, theResolvers.ResolversrecognizeIdentitiesby any of theirAssociated Addresses, or by theirEIN.", "Identity Registry": "TheIdentity Registrycontains functionality to create newIdentitiesand for existingIdentitiesto manage theirAssociated Addresses,Providers, andResolvers. It is important to note that this registry fundamentally requires transactions for every aspect of building out anIdentity. However, recognizing the importance of accessibility to dApps and identity applications, we empowerProvidersto build outIdentitieson the behalf of users, without requiring users to pay gas costs. An example of this pattern, often referred to as a meta transactions, can beseen in the reference implementation.", "Address Management": "The address management function consists of trustlessly connecting multiple user-ownedAssociated Addressesto anIdentity. It does not give special status to any particularAssociated Address, rather leaving this (optional) specification to identity applications built on top of the protocol - for instance,management,action,claimandencryptionkeys denominated in the ERC-725 standard, oridentifiersanddelegatesas denominated in ERC-1056. This allows a user to access common identity data from multiple wallets while still:", "Provider Management": "While the protocol allows users to directly call identity management functions, it also aims to be more robust and future-proof by allowingProviders, typically smart contracts, to perform identity management functions on a user\u2019s behalf. AProviderset by anIdentitycan perform address management and resolver management functions by passing a user\u2019sEINin function calls.", "Resolver Management": "AResolveris any smart contract that encodes information which resolves to anIdentity. We remain agnostic about the specific information that can be encoded in a resolver and the functionality that this enables. The existence ofResolversis primarily what makes this ERC an identityprotocolrather than an identityapplication.Resolversresolve abstract data in smart contracts to an atomic entity, theIdentity.", "Recovery": "If users lose control over anAssociated Address, theRecovery Addressprovides a fallback mechanism. UponIdentitycreation, aRecovery Addressis passed as a parameter by the creator. Recovery functionality is triggered in three scenarios:", "Rationale": "We find that at a protocol layer, identities should not rely on specific claim or attestation structures, but should instead be a part of a trustless framework upon which arbitrarily sophisticated claim and attestation structures may be built.", "Implementation": "The reference implementation for ERC-1484 may be found inNoahZinsmeister/ERC-1484.", "Events": "MUST be triggered when anIdentityis created.", "Solidity Interface": "Identitiesestablished under this standard consist of existing Ethereum addresses; accordingly, there are no backwards compatibility issues. Deployed, non-upgradeable smart contracts that wish to becomeResolversforIdentitieswill need to write wrapper contracts that resolve addresses toEIN-denominatedIdentities.", "Backwards Compatibility": "Identitiesestablished under this standard consist of existing Ethereum addresses; accordingly, there are no backwards compatibility issues. Deployed, non-upgradeable smart contracts that wish to becomeResolversforIdentitieswill need to write wrapper contracts that resolve addresses toEIN-denominatedIdentities.", "Additional References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1491, "url": "https://eips.ethereum.org/EIPS/eip-1491", "title": "Human Cost Accounting Standard (Like Gas but for humans)", "authors": ["Iamnot Chris\u00a0(", "@cohabo", ")"], "sections": {"ERC-1491: Human Cost Accounting Standard (Like Gas but for humans)": "A standard interface for Human Capital Accounting tokens.", "": "A standard interface for Human Capital Accounting tokens.", "Simple Summary": "A standard interface for Human Capital Accounting tokens.", "Abstract": "The following standard allows for the implementation of a standard API for HUCAP tokens within smart contracts. This standard provides basic functionality to discover, track and transfer the motivational hierarchy of human resources. While blockchain architecture has succeeded in the financialisation of integrity by way of transparency; correspondingly real world outcomes will be proportional to the degree of individualisation of capital by way of knowledge.", "Motivation": "The Ethereum protocol architecture has a deterministic world-view bounded to the random reality of the human domain that supplies the intentions and logic. The yellow paper formally defines the EVM as a state machine with only deterministic parameters and state transition operators. Oracle requests to another on-chain contract, and/or off-chain HTTP lookups still make for multiple deterministic transactions.", "Specification": "[WIP]", "Rationale": "[WIP]", "Backwards Compatibility": "[WIP]", "Test Cases": "[WIP]", "Implementation": "[WIP]", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1504, "url": "https://eips.ethereum.org/EIPS/eip-1504", "title": "Upgradable Smart Contract", "authors": ["Kaidong Wu\u00a0<", "wukd94@pku.edu.cn", ">", "Chuqiao Ren\u00a0<", "cr025@bucknell.edu", ">", "Ruthia He\u00a0<", "rujiahe@gmail.com", ">", "Yun Ma\u00a0<", "mayun@pku.edu.cn", ">", "Xuanzhe Liu\u00a0<", "liuxuanzhe@pku.edu.cn", ">"], "sections": {"ERC-1504: Upgradable Smart Contract": "A standard interface/guideline that makes a smart contract upgradable.", "": "A standard interface/guideline that makes a smart contract upgradable.", "Simple Summary": "A standard interface/guideline that makes a smart contract upgradable.", "Abstract": "Ethereum smart contracts have suffered a number of security issues in the past few years. The cost of fixing such a bug in smart contract is significant; for example, the consequences of The DAO attack in June 2016 caused tremendous financial loss and the hard fork of Ethereum blockchain.", "Motivation": "Smart contract is immutable after deployment. If any security risk is identified or program bug is detected, developers always have to destruct the old contract, deploy a new one and potentially migrate the data (hard fork) to the new contract. In some cases, deploying a smart contract with bugs and potential security vulnerabilities can cause a significant amount of financial loss.", "Specification": "The upgradable contract consists of three parts:", "Handler contract and Handler interface": "Functions of the Handler contract vary with requirements, so developers would better design interfaces for Handler contracts to limit them and make sure external applications are always supported.", "Data Contract": "Below is the specification of Data contract. There are three parts in the Data contract:", "Upgrader Contract (Optional)": "Handler contract can be upgraded by calling setHandler() of Data contract. If the owner wants to collect ideas from users, an Upgrader contract will help him/her manage voting and upgrading.", "Caveats": "Since the Upgrader contract inERC-1504has a simple voting mechanism, it is prone to all the limitations that the voting contract is facing:", "Rationale": "A smart contract is actually a kind of software, which provides some kind of services. From the perspective of software engineering, a service consists ofresourcesthat abstract the data andoperationsthat abstract the process logic on the data. The requirement of upgrading is mostly on the logic part. Therefore, in order to make a smart contract upgradable, we divide it into two parts:", "Data Contract and Handler Contract": "A smart contract is actually a kind of software, which provides some kind of services. From the perspective of software engineering, a service consists ofresourcesthat abstract the data andoperationsthat abstract the process logic on the data. The requirement of upgrading is mostly on the logic part. Therefore, in order to make a smart contract upgradable, we divide it into two parts:", "Upgrader Contract and Voting Mechanism": "In order to prevent centralization and protect the interests of the community and stakeholders, we also design a voting mechanism in the Upgrader contract. Upgrader contract contains addresses of Data contract and two Handler contracts, and collects votes from pre-defined voters to upgrade the Handler contract when the pre-set condition is fulfilled.", "Gas and Complexity (regarding the enumeration extension)": "Using an upgrader will cost some gas. If the Handler contract is upgraded by the owner, it just costs gas that a contract call will cost, which is usually significantly lower than creating and deploying a new contract.", "Community Consensus": "Thank you to those who helped on review and revise the proposal:", "Implementations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1523, "url": "https://eips.ethereum.org/EIPS/eip-1523", "title": "Standard for Insurance Policies as ERC-721 Non Fungible Tokens", "authors": ["Christoph Mussenbrock\u00a0(", "@christoph2806", ")"], "sections": {"ERC-1523: Standard for Insurance Policies as ERC-721 Non Fungible Tokens": "A standard interface for insurance policies, based on ERC 721.", "": "A standard interface for insurance policies, based on ERC 721.", "Simple Summary": "A standard interface for insurance policies, based on ERC 721.", "Abstract": "The following standard allows for the implementation of a standard API for insurance policies within smart contracts.\nInsurance policies are financial assets which are unique in some aspects, as they are connected to a customer, a specific risk, or have other unique properties like premium, period, carrier, underwriter etc.\nNevertheless, there are many potential applications where insurance policies can be traded, transferred or otherwise treated as an asset.\nThe ERC 721 standard already provides the standard and technical means to handle policies as a specific class of non fungible tokens.\ninsurance In this proposal, we define a minimum metadata structure with properties which are common to the greatest possible class of policies.", "Motivation": "For a decentralized insurance protocol, a standard for insurance policies is crucial for interoperability of the involved services and application.\nIt allows policies to be bundled, securitized, traded in a uniform and flexible way by many independent actors like syndicates, brokers, and insurance companies.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Additional parameters for the metadata JSON Schema": "Parameters which are mandatoryMUSTbe included in the metadata JSON. Other parametersMAYbe included. However, the proposed optional parametersSHOULDbe used for the intended purpose, so e.g. if the premium amount would be included in the metadata, the parameter nameSHOULDbe \u201cpremium\u201d.\nAll parametersMAYbe plain text orMAYalso be URIs pointing to resources which contain the respective information, and whichMAYbe protected by an authentication mechanism.", "Rationale": "Insurance policies form an important class of financial assets, and it is natural to express those assets as a class of non-fungible tokens which adhere to the established ERC-721 standard.\nWe propose a standard for the accompanying metadata structures which are needed to uniquely define an insurance policy. Standardization is key because we expect decentralized insurance to receive widespread adoption and it is crucial to establish a unified standard to enable composability and the creation of universal toolsets. \nWe therefore propose a standardized naming scheme for the different parameters describing an insurance policy. We propose three mandatory parameters which need to be included in every NFT and further parameters whichMAYbe used, and for which we only standardize the naming conventions.", "Mandatory parameters": "While policies can have a multitude of possible properties, it is common that policies are issued by some entity, which is basically the entity responsible for paying out claims.\nSecond, an insurance policy is typically related to a specific risk. Some risks are unique, but there are cases where many policies share the same risk\n(e.g. all flight delay policies for the same flight).\nIn general, the relation of policies to risks is a many-to-one relation with the special case of a one-to-one relation.\nThird, a policy has a lifecycle of different statuses. Therefore the NFT \nWe believe that those four properties are necessary to describe a policy. For many applications, those properties may be even sufficient.", "Optional parameters": "Most policies need more parameters to characterize the risk and other features, like premium, period etc. The naming conventions are listed in the above table.\nHowever, any implementationMAYchose to implement more properties.", "On-chain vs. off-chain metadata": "For some applications it will be sufficient to store the metadata in an off-chain repository or database which can be addressed by the tokenURI resource locator.\nFor more advanced applications, it can be desirable to have metadata available on-chain. \nTherefore, we require that thetokenURIMUSTpoint to a JSON with the above structure, while the implementation of thepolicyMetadatafunction isOPTIONAL.", "Backwards Compatibility": "Copyright and related rights waived viaCC0.", "Test Cases": "Copyright and related rights waived viaCC0.", "Implementation": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1577, "url": "https://eips.ethereum.org/EIPS/eip-1577", "title": "contenthash field for ENS", "authors": ["Dean Eigenmann\u00a0<", "dean@ens.domains", ">", "Nick Johnson\u00a0<", "nick@ens.domains", ">"], "sections": {"ERC-1577: contenthash field for ENS": "This EIP introduces the newcontenthashfield for ENS resolvers, allowing for a better defined system of mapping names to network and content addresses. Additionally thecontentandmultihashfields are deprecated.", "": "This EIP introduces the newcontenthashfield for ENS resolvers, allowing for a better defined system of mapping names to network and content addresses. Additionally thecontentandmultihashfields are deprecated.", "Abstract": "This EIP introduces the newcontenthashfield for ENS resolvers, allowing for a better defined system of mapping names to network and content addresses. Additionally thecontentandmultihashfields are deprecated.", "Motivation": "Multiple applications includingMetamaskand mobile clients such asStatushave begun resolving ENS names to content hosted on distributed systems such asIPFSandSwarm. Due to the various ways content can be stored and addressed, a standard is required so these applications know how to resolve names and that domain owners know how their content will be resolved.", "Specification": "The fieldcontenthashis introduced, which permits a wide range of protocols to be supported by ENS names. Resolvers supporting this field MUST returntruewhen thesupportsInterfacefunction is called with argument0xbc1c58d1.", "Example": "Input data:", "Swarm": "Input data:", "Fallback": "In order to support names that have an IPFS or Swarm hash in theircontentfield, a grace period MUST be implemented offering those name holders time to update their names. If a resolver does not support themultihashinterface, it MUST be checked whether they support thecontentinterface. If they do, the value of that field SHOULD be treated in a context dependent fashion and resolved. This condition MUST be enforced until at least March 31st, 2019.", "Implementation": "To supportcontenthash, a new resolver has been developed and can be foundhere, you can also find this smart contract deployed on:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1581, "url": "https://eips.ethereum.org/EIPS/eip-1581", "title": "Non-wallet usage of keys derived from BIP-32 trees", "authors": ["Michele Balistreri\u00a0(", "@bitgamma", ")"], "sections": {"ERC-1581: Non-wallet usage of keys derived from BIP-32 trees": "BIP32 defines a way to generate hierarchical trees of keys which can be derived from a common master key. BIP32 andBIP44defines the usage of these keys as wallets. In this EIP we describe the usage of such keys outside the scope of the blockchain defining a logical tree for key usage which can coexist (and thus share the same master) with existing BIP44 compatible wallets.", "A derivation path structure for BIP32 trees to generate key pairs not meant to hold crypto assets.": "BIP32 defines a way to generate hierarchical trees of keys which can be derived from a common master key. BIP32 andBIP44defines the usage of these keys as wallets. In this EIP we describe the usage of such keys outside the scope of the blockchain defining a logical tree for key usage which can coexist (and thus share the same master) with existing BIP44 compatible wallets.", "Abstract": "BIP32 defines a way to generate hierarchical trees of keys which can be derived from a common master key. BIP32 andBIP44defines the usage of these keys as wallets. In this EIP we describe the usage of such keys outside the scope of the blockchain defining a logical tree for key usage which can coexist (and thus share the same master) with existing BIP44 compatible wallets.", "Motivation": "Applications interacting with the blockchain often make use of additional, non-blockchain technologies to perform the task they are designed for. For privacy and security sensitive mechanisms, sets of keys are needed. Reusing keys used for wallets can prove to be insecure, while keeping completely independent keys make backup and migration of the full set of credentials more complex. Defining a separate (from BIP44 compliant wallets) derivation branch allows combining the security of independent keys with the convenience of having a single piece of information which needs to be backup or migrated.", "Specification": "We define the following levels in BIP32 path:", "Path levels": "We define the following levels in BIP32 path:", "Purpose/Coin Type/Subpurpose": "This part is constant and set tom / 43' / 60' / 1581', meaning BIP 43 -> Ethereum -> This EIP.", "Key type": "Describes the purpose for which the key is being used. Key types should be generic. \u201cInstant messaging\u201d is a good example whereas \u201cWhisper\u201d is not. The reason is that you want to be able to use the same identity across different services. Key types are defined at: TBD", "Key index": "The key index is a field of variable length identifying a specific key. In its simplest case, it is a number from 0 to 2^31-1. If a larger identifier is desired (for example representing a hash or a GUID), the value must be split\nacross several BIP32 nesting levels, most significant bit first and left aligned, bit-padded with 0s if needed. All levels, except the last one must used hardened key derivation. The last level must use public derivation. This means that every level can carry 31-bit of the identifier to represent.", "Rationale": "The structure proposed above follows the BIP43 generic structure and is similar to the widely adopted BIP44 specification.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1592, "url": "https://eips.ethereum.org/EIPS/eip-1592", "title": "Address and ERC20-compliant transfer rules", "authors": ["Cyril Lapinte\u00a0<", "cyril.lapinte@mtpelerin.com", ">", "Laurent Aapro\u00a0<", "laurent.aapro@mtpelerin.com", ">"], "sections": {"ERC-1592: Address and ERC20-compliant transfer rules": "We propose a standard and an interface to define transfer rules, in the context of ERC20 tokens and possibly beyond.", "": "We propose a standard and an interface to define transfer rules, in the context of ERC20 tokens and possibly beyond.", "Simple Summary": "We propose a standard and an interface to define transfer rules, in the context of ERC20 tokens and possibly beyond.", "Abstract": "This standard proposal should answer the following challenges:", "Motivation": "ERC20 was designed as a standard interface allowing any token on Ethereum to be handled by other applications: from wallets to decentralized exchanges. This has been extremely powerful, but future developments in the industry of tokenization are bringing new challenges. For example it is already hard to know exactly why an ERC20 transfer failed, and it will become even harder when many tokens add their own transfer rules to the mix; we propose that it should be trivial to determine before a tx is sent, whether the transfer should turn out valid or invalid, and why (unless conditions change in the meantime obviously). On the other hand, if the rules were changed, it should also be easily detected, so that the interacting party knows it must adjust its expectations or model.", "Specification": "We define below an interface for a rule. Rules are meant to be as simple as possible, to limit gas expenditure, since that logic will be executed on every transfer. Another reason for keeping rules simple and short, and strive for atomicity, is to facilitate both composition and interpretation of rejected transfers. By knowing which rule was triggered, we obtain a clear picture of the reason for rejection.", "Rule interface": "IRuleinterface should provide a way to validate if an address or a transfer is valid.", "WithRules interface": "WithRulesinterface describes the integration of rules to a rule engine.\nDevelopers may choose to not implement this interface if their code will only deal with one rule, or if it is not desirable to update the rules.", "WithRules implementation": "We also propose a simple implementation of the rule engine, availablehere. It has been kept minimal both to save on gas costs on each transfer, and to reduce the deployment cost overhead for the derived smart contract.", "Integration": "To use rules within a token is as easy as having the token inherit from WithRules, then writing rules according to the IRule interface and deploying each rule individually. The token owner can then usedefineRules()to attach all rules in the chosen order, within a single transaction.", "History": "Historical links related to this standard:", "Copyright": "Copyright and related rights waived viaCC0.\nExternal references outside this repository will have their own specific copyrights.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1613, "url": "https://eips.ethereum.org/EIPS/eip-1613", "title": "Gas stations network", "authors": ["Yoav Weiss\u00a0<", "yoav@tabookey.com", ">", "Dror Tirosh\u00a0<", "dror@tabookey.com", ">", "Alex Forshtat\u00a0<", "alex@tabookey.com", ">"], "sections": {"ERC-1613: Gas stations network": "Make smart contracts (e.g. dapps) accessible to non-ether users by allowing contracts to accept \u201ccollect-calls\u201d, paying for incoming calls. \nLet contracts \u201clisten\u201d on publicly accessible channels (e.g. web URL or a whisper address). \nIncentivize nodes to run \u201cgas stations\u201d to facilitate this. \nRequire no network changes, and minimal contract changes.", "": "Make smart contracts (e.g. dapps) accessible to non-ether users by allowing contracts to accept \u201ccollect-calls\u201d, paying for incoming calls. \nLet contracts \u201clisten\u201d on publicly accessible channels (e.g. web URL or a whisper address). \nIncentivize nodes to run \u201cgas stations\u201d to facilitate this. \nRequire no network changes, and minimal contract changes.", "Simple Summary": "Make smart contracts (e.g. dapps) accessible to non-ether users by allowing contracts to accept \u201ccollect-calls\u201d, paying for incoming calls. \nLet contracts \u201clisten\u201d on publicly accessible channels (e.g. web URL or a whisper address). \nIncentivize nodes to run \u201cgas stations\u201d to facilitate this. \nRequire no network changes, and minimal contract changes.", "Abstract": "Communicating with dapps currently requires paying ETH for gas, which limits dapp adoption to ether users. \nTherefore, contract owners may wish to pay for the gas to increase user acquisition, or let their users pay for gas with fiat money. \nAlternatively, a 3rd party may wish to subsidize the gas costs of certain contracts. \nSolutions such as described inEIP-1077could allow transactions from addresses that hold no ETH.", "Motivation": "The system consists of aRelayHubsingleton contract, participating contracts inheriting theRelayRecipientcontract, a decentralized network ofRelaynodes, a.k.a. Gas Stations, \nand user applications (e.g. mobile or web) interacting with contracts via relays.", "Specification": "The system consists of aRelayHubsingleton contract, participating contracts inheriting theRelayRecipientcontract, a decentralized network ofRelaynodes, a.k.a. Gas Stations, \nand user applications (e.g. mobile or web) interacting with contracts via relays.", "Rationale": "The rationale for the gas stations network design is a combination of two sets of requirements: Easy adoption, and robustness.", "Backwards Compatibility": "The gas stations network is implemented as smart contracts and external entities, and does not require any network changes.", "Implementation": "A working implementation of thegas stations networkis being developed byTabooKey. It consists ofRelayHub,RelayRecipient,web3 hooks, an implementation of a gas station insidegeth, and sample dapps using the gas stations network.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1616, "url": "https://eips.ethereum.org/EIPS/eip-1616", "title": "Attribute Registry Standard", "authors": ["0age\u00a0(", "@0age", ")", "Santiago Palladino\u00a0(", "@spalladino", ")", "Leo Arias\u00a0(", "@elopio", ")", "Alejo Salles\u00a0(", "@fiiiu", ")", "Stephane Gosselin\u00a0(", "@thegostep", ")"], "sections": {"ERC-1616: Attribute Registry Standard": "EIP-1616 provides a basic interface for querying a registry for attribute metadata assigned to Ethereum accounts.", "": "EIP-1616 provides a basic interface for querying a registry for attribute metadata assigned to Ethereum accounts.", "Simple Summary": "EIP-1616 provides a basic interface for querying a registry for attribute metadata assigned to Ethereum accounts.", "Abstract": "This EIP contains the following core ideas:", "Motivation": "This EIP is motivated by the need for contracts and external accounts to be able to verify information about a given address from a single trusted sourcewithout concerning themselves with the particular details of how the information was obtained, and to do so in as simple a manner as possible. It is also motivated by the desire to promote broadcross-compatibility and composabilitybetween attribute registries, a property which is amplified by both the simplicity of the interface as well as by the guarantees on uniqueness provided by the proposed standard.", "Specification": "The Attribute Registry interface contains four functions, outlined as follows:", "View Functions": "The view functions detailed below MUST be implemented.", "Rationale": "This standard extends the applicability of metadata assignment to those use cases that are not adequately represented by EIP-735, EIP-780, or similar proposals. Namely, it enforces the constraint of one attribute value per attribute ID per address, as opposed to one value per ID per addressper issuer.", "Backwards Compatibility": "There are no backwards compatibility concerns.", "Test Cases": "Targeted test cases with 100% code coverage can be found atthis repository. Seeherefor tests on a more complex contract that implements the application registry interface.", "Implementation": "The basic implementation that follows can be found atthis repository(seeherefor an example of a more complex implementing contract):", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1620, "url": "https://eips.ethereum.org/EIPS/eip-1620", "title": "Money Streaming", "authors": ["Paul Berg\u00a0(", "@PaulRBerg", ")"], "sections": {"ERC-1620: Money Streaming": "Money streaming represents the idea of continuous payments over a finite period of time. Block numbers are used as a proxy of time to continuously update balances.", "": "Money streaming represents the idea of continuous payments over a finite period of time. Block numbers are used as a proxy of time to continuously update balances.", "Simple Summary": "Money streaming represents the idea of continuous payments over a finite period of time. Block numbers are used as a proxy of time to continuously update balances.", "Abstract": "The following describes a standard whereby time is measured using block numbers and streams are mappings in a master contract.", "Motivation": "This standardised interface aims to change the way we think about long-term financial commitments. Thanks to blockchains, payments need not be sent in chunks (e.g. monthly salaries), as there is much less overhead in paying-as-you-go. Money as a function of time would better align incentives in a host of scenarios.", "Use Cases": "This is just a preliminary list of use cases. There are other spooky ideas interesting to explore, such as time-dependent disincetivisation, but, for brevity, we have not included them here.", "Crowdsales": "RICOs, or Reversible ICOs, were introduced at Devcon4 by @frozeman. The idea is to endow investors with more power and safety guarantees by allowing them to \u201creverse\u201d the investment based on the evolution of the project. We previously discussed a similar concept called SICOs, or Streamable ICOs, in this researchthread.", "Specification": "The structure of astreamshould be as follows:", "Structs": "The structure of astreamshould be as follows:", "Methods": "Returns available funds for the given stream id and address.", "Events": "MUST be triggered whencreateis successfully called.", "Rationale": "This specification was designed to serve as an entry point to the quirky concept of money as a function of time and it is definitely not set in stone. Several other designs, including payment channels and Plasma chains were also considered, but they were eventually deemed dense in assumptions unnecessary for an initial version.", "GCD": "When setting up a stream, a payer and a payee may want to make the total streaming duration a multiple of the \u201cgreatest common denominator\u201d (GCD) of the chain they operate on; that is, the average block time. This is not imperative in the smart contracts per se, but there needs to be an off-chain process to map streams to real world time units in order to create a sound and fair payment mechanism.", "Block Times": "Because there is uncertainty regarding block times, streams may not be settled on the blockchain as initially planned. Let$dbe the total streaming duration measured in seconds,$tthe average block time before the stream started and$t'the actual average block time over$dafter the stream started. We distinguish two undesirable scenarios:", "Sidechains": "It could be more efficient to implement this standard on independent sidechains likePOA NetworkorxDai- thanks to their rather predictable nature. Admittedly, security is traded for scalability, but proper cryptoeconomic stakes could alleviate potential problems.", "Oracles": "The proposed specification uses block numbers to proxy time, but this need not be the only method. Albeit it would imply different trust assumptions, oracles could be used to provide a feed of timestamps. Coupled with the aforementioned idea of stream-specific sidechains, oracles could efficiently solve the problems outlined inBlock Times.", "Multi-Hop Streams": "Future or upgraded versions of this standard may describe \u201cmulti-hop\u201d streams. If:", "Implementation": "Many thanks to @mmilton41 for countless brainstorming sessions. We have been doing research on the topic of money streaming for quite a while within the context of @ChronosProtocol. In August this year, we published the first version of our white paper describing a Plasma approach. However, in the meantime, we realised that it would be much morefunand easier to start small on Ethereum itself and sidechains likexDai.", "Additional References": "Many thanks to @mmilton41 for countless brainstorming sessions. We have been doing research on the topic of money streaming for quite a while within the context of @ChronosProtocol. In August this year, we published the first version of our white paper describing a Plasma approach. However, in the meantime, we realised that it would be much morefunand easier to start small on Ethereum itself and sidechains likexDai.", "Final Notes": "Many thanks to @mmilton41 for countless brainstorming sessions. We have been doing research on the topic of money streaming for quite a while within the context of @ChronosProtocol. In August this year, we published the first version of our white paper describing a Plasma approach. However, in the meantime, we realised that it would be much morefunand easier to start small on Ethereum itself and sidechains likexDai.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1633, "url": "https://eips.ethereum.org/EIPS/eip-1633", "title": "Re-Fungible Token Standard (RFT)", "authors": ["Billy Rennekamp\u00a0(", "@okwme", ")", "Dan Long\u00a0<", "dan@artblx.com", ">", "Kiryl Yermakou\u00a0<", "kiryl@artblx.com", ">", "Nate van der Ende\u00a0<", "nate@artblx.com", ">"], "sections": {"ERC-1633: Re-Fungible Token Standard (RFT)": "ERC-20extension for proportional ownership of anERC-721token.", "": "ERC-20extension for proportional ownership of anERC-721token.", "Simple Summary": "ERC-20extension for proportional ownership of anERC-721token.", "Abstract": "The intention of this proposal, the Re-Fungible Token Standard, is to extend the ERC-20 Token Standard and utilize ERC-165 Standard Interface Detection in order to represent the shared ownership of an ERC-721 Non-Fungible Token. The ERC-20 Token Standard was modified as little as possible in order to allow this new class of token to operate in all of the ways and locations which are familiar to assets that follow the original ERC-20 specification. While there are many possible variations of this specification that would enable many different capabilities and scenarios for shared ownership, this proposal is focused on the minimal commonalities to enable as much flexibility as possible for various further extensions. This proposal makes it possible to verify, from the contract level or from an external query, whether a fungible token represents a form of shared ownership of a non-fungible token. The inclusion of ERC-165 makes it possible to verify, from the contract level or from an external query, whether a non-fungible token is owned by ERC-20 token representing shared ownership.", "Motivation": "Shared ownership occurs across many industries and for many reasons. As more assets are registered, regulated and/or represented by the ERC-721 Non-Fungible Token Standard there will be more instances where the need for shared ownership of these assets will arise. For example, ARTBLX Inc. is working towards facilitating a protocol for collective ownership of physical, digital and conceptual artworks. The fungible tokens created from this process will have a value attached to the non-fungible tokens which they represent. This will be useful for price discovery of the underlying asset, liquidity for shared owners and as a new class of asset which can be used as collateral for loans or other financial instruments like stable coins. Providing an interface to this special class of fungible tokens is necessary to allow third parties to recognize them as a special class of fungible token and to recognize when a non-fungible token is collectively owned. This might be useful in the case of a wallet who would want to utilize the metadata of the underlying NFT to show additional info next to an RFT, or on an exchange who might want to make that sort of info similarly available, or an NFT marketplace who may want to direct customers to a relevant exchange who wish to purchase shares in a NFT which is owned by an RFT. Anywhere an ERC-20 is applicable it would be useful for a user to know whether that token represents a shared NFT, and what attributes that NFT may have.", "Specification": "At a minimum, third parties need two things: 1) to be able to distinguish re-fungible tokens from other token standards and 2) to determine when a non-fungible token is collectively owned. These two scenarios can be encountered from the perspective of initial contact with the non-fungible token or from the perspective of initial contact with the re-fungible token.", "Rationale": "Most of the decisions made around the design of this standard were done in the hopes of keeping it as flexible as possible for as many use cases as possible. This includes making the standard 100% backwards compatible with ERC-20 Token Standard and able to interact with any previously deployed or future ERC-721 non-fungible token. This allows for each project to determine their own system for minting, burning and governing their re-fungible tokens depending on their specific use case.", "Backwards Compatibility": "The Re-Fungible Token Standard is 100% backwards compatible with ERC-20 Token Standard. It is a small extension to the original specification and meant to be further extended for more specific use cases. Keeping the standard compatible with ERC-20 is important to allow for this token to benefit from the ecosystem that has grown around supporting the ubiquitous ERC-20 Token Standard.", "Implementation": "TBD", "Security Considerations": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1710, "url": "https://eips.ethereum.org/EIPS/eip-1710", "title": "URL Format for Web3 Browsers", "authors": ["Bruno Barbieri\u00a0(", "@brunobar79", ")"], "sections": {"ERC-1710: URL Format for Web3 Browsers": "A standard way of representing web3 browser URLs for decentralized applications.", "": "A standard way of representing web3 browser URLs for decentralized applications.", "Simple Summary": "A standard way of representing web3 browser URLs for decentralized applications.", "Abstract": "Since most normal web browsers (specifically on mobile devices) can not run decentralized applications correctly because of the lack of web3 support, it is necessary to differentiate them from normal urls, so they can be opened in web3 browsers if available.", "Motivation": "Lots of dApps that are trying to improve their mobile experience are currently (deep)linking to specific mobile web3 browsers which are currently using their own url scheme.", "Specification": "Web3 browser URLs contain \u201cdapp\u201d in their schema (protocol) part and are constructed as follows:", "Syntax": "Web3 browser URLs contain \u201cdapp\u201d in their schema (protocol) part and are constructed as follows:", "Semantics": "chain_idis optional and it is a parameter for the browser to automatically select the corresponding chain ID as specified inEIP-155before opening the dApp.", "Rationale": "The proposed format attempts to solve the problem of vendor specific protocols for web3 browsers, avoiding conflicts with the existing \u2018ethereum:\u2019 URL scheme while also adding an extra feature:chain_idwhich will help dApps to be accessed with the right network preselected, optionally extracting away that complexity from end users.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1753, "url": "https://eips.ethereum.org/EIPS/eip-1753", "title": "Smart Contract Interface for Licences", "authors": ["Lucas Cullen\u00a0(", "@BitcoinBrisbane", ")", "Kai Yeung\u00a0(", "@CivicKai", ")", "Anna Crowley\u00a0<", "annaelizabethcrowley@gmail.com", ">", "Caroline Marshall\u00a0<", "caroline.marshall888@gmail.com", ">", "Katrina Donaghy\u00a0<", "katrina@civicledger.com", ">"], "sections": {"ERC-1753: Smart Contract Interface for Licences": "This Ethereum Improvement Proposal (EIP) proposes an Ethereum standard for the issuance of licences, permits and grants (Licences).", "": "This Ethereum Improvement Proposal (EIP) proposes an Ethereum standard for the issuance of licences, permits and grants (Licences).", "Abstract": "This Ethereum Improvement Proposal (EIP) proposes an Ethereum standard for the issuance of licences, permits and grants (Licences).", "Motivation": "Governments are responsible for the issuance and management of Licences. However, maintaining and sharing this data can be complicated and inefficient. The granting of Licences usually requires the filing of paper-based application forms, manual oversight of applicable legislation and data entry into registries, as well as the issuance of paper based Licences. If individuals wish to sight information on Licence registries, they often need to be present at the government office and complete further paper-based enquiry forms in order to access that data (if available publicly).", "Specification": "NOTES:", "Methods": "NOTES:", "Rationale": "The use of smart contracts to apply for, renew, suspend and revoke Licences will free up much needed government resources and allow for the more efficient management of Licences. The EIP also seeks to improve the end user experience of the Licence system. In an era of open government, there is also an increased expectation that individuals will be able to easily access Licence registries, and that the process will be transparent and fair.", "Test Cases": "A real world example of a Licence is a permit required to camp in a national park in Australia (e.g. Kakadu national park in the Northern Territory of Australia) under the Environment Protection and Biodiversity Conservation Regulations 2000 (Cth) (EPBC Act) and the Environment Protection and Biodiversity Conservation Regulations 2000 (the Regulations). Pursuant to the EPBC Act and the Regulations, the Director of National Parks oversees a camping permit system, which is intended to help regulate certain activities in National Parks. Permits allowing access to National Parks can be issued to legal or natural persons if the applicant has met certain conditions.", "Implementation": "The issuance and ownership of a Licence can be digitally represented on the Ethereum blockchain.", "Interface": "Copyright and related rights waived viaCC0.", "Solidity Example": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1761, "url": "https://eips.ethereum.org/EIPS/eip-1761", "title": "Scoped Approval Interface", "authors": ["Witek Radomski\u00a0<", "witek@enjin.io", ">", "Andrew Cooke\u00a0<", "ac0dem0nk3y@gmail.com", ">", "James Therien\u00a0<", "james@enjin.io", ">", "Eric Binet\u00a0<", "eric@enjin.io", ">"], "sections": {"ERC-1761: Scoped Approval Interface": "A standard interface to permit restricted approval in token contracts by defining \u201cscopes\u201d of one or more Token IDs.", "": "A standard interface to permit restricted approval in token contracts by defining \u201cscopes\u201d of one or more Token IDs.", "Simple Summary": "A standard interface to permit restricted approval in token contracts by defining \u201cscopes\u201d of one or more Token IDs.", "Abstract": "This interface is designed for use with token contracts that have an \u201cID\u201d domain, such as ERC-1155 or ERC-721. This enables restricted approval of one or more Token IDs to a specific \u201cscope\u201d. When considering a smart contract managing tokens from multiple different domains, it makes sense to limit approvals to those domains. Scoped approval is a generalization of this idea. Implementors can define scopes as needed.", "Motivation": "It may be desired to restrict approval in some applications. Restricted approval can prevent losses in cases where users do not audit the contracts they\u2019re approving. No standard API is supplied to manage scopes as this is implementation specific. Some implementations may opt to offer a fixed number of scopes, or assign a specific set of scopes to certain types. Other implementations may open up scope configuration to its users and offer methods to create scopes and assign IDs to them.", "Specification": "This schema allows for localization.{id}and{locale}should be replaced with the appropriate values by clients.", "Scope Metadata JSON Schema": "This schema allows for localization.{id}and{locale}should be replaced with the appropriate values by clients.", "Localization": "Metadata localization should be standardized to increase presentation uniformity across all languages. As such, a simple overlay method is proposed to enable localization. If the metadata JSON file contains alocalizationattribute, its content may be used to provide localized values for fields that need it. Thelocalizationattribute should be a sub-object with three attributes:uri,defaultandlocales. If the string{locale}exists in any URI, it MUST be replaced with the chosen locale by all client software.", "Rationale": "The initial design was proposed as an extension to ERC-1155:Discussion Thread - Comment 1. After some discussion:Comment 2and suggestions by the community to implement this approval mechanism in an external contractComment 3, it was decided that as an interface standard, this design would allow many different token standards such as ERC-721 and ERC-1155 to implement scoped approvals without forcing the system into all implementations of the tokens.", "Metadata JSON": "The Scope Metadata JSON Schema was added in order to support human-readable scope names and descriptions in more than one language.", "References": "Standards", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1775, "url": "https://eips.ethereum.org/EIPS/eip-1775", "title": "App Keys, application specific wallet accounts", "authors": ["Vincent Eli\u00a0(", "@Bunjin", ")", "Dan Finlay\u00a0(", "@DanFinlay", ")"], "sections": {"ERC-1775: App Keys, application specific wallet accounts": "Among others cryptographic applications, scalability and privacy solutions for ethereum blockchain require that an user performs a significant amount of signing operations. It may also require her to watch some state and be ready to sign data automatically (e.g. sign a state or contest a withdraw). The way wallets currently implement accounts poses several obstacles to the development of a complete web3.0 experience both in terms of UX, security and privacy.", "": "Among others cryptographic applications, scalability and privacy solutions for ethereum blockchain require that an user performs a significant amount of signing operations. It may also require her to watch some state and be ready to sign data automatically (e.g. sign a state or contest a withdraw). The way wallets currently implement accounts poses several obstacles to the development of a complete web3.0 experience both in terms of UX, security and privacy.", "Simple Summary": "Among others cryptographic applications, scalability and privacy solutions for ethereum blockchain require that an user performs a significant amount of signing operations. It may also require her to watch some state and be ready to sign data automatically (e.g. sign a state or contest a withdraw). The way wallets currently implement accounts poses several obstacles to the development of a complete web3.0 experience both in terms of UX, security and privacy.", "Abstract": "In a wallet, an user often holds most of her funds in her main accounts. These accounts require a significant level of security and should not be delegated in any way, this significantly impacts the design of cryptographic applications if a user has to manually confirm every action. Also often an user uses the same accounts across apps, which is a privacy and potentially also a security issue.", "Motivation": "Wallets developers have agreed on an HD derivation path for ethereum accounts using BIP32, BIP44, SLIP44,(see the discussion here). Web3 wallets have implemented in a roughly similar way the rpc eth api.EIP-1102introduced privacy through non automatic opt-in of a wallet account into an app increasing privacy.", "Specification": "An app is a website (or other) that would like to request from a wallet to access a cryptographic key specifically derived for this usage. It can be any form of cryptography/identity relying application, Ethereum based but not only.", "Applications": "An app is a website (or other) that would like to request from a wallet to access a cryptographic key specifically derived for this usage. It can be any form of cryptography/identity relying application, Ethereum based but not only.", "Private App Key generation algorithm": "We now propose an algorithm to generate application keys that:", "Rationale": "While this does not explicit cover cases of sharing these app keys between pages on its own, this need can be met by composition:", "Sharing application keys across domains:": "While this does not explicit cover cases of sharing these app keys between pages on its own, this need can be met by composition:", "Privacy and the funding trail": "If all an application needs to do with its keys is to sign messages and it does not require funding, then this EIP allows for privacy through the use of distinct keys for each application with a simple deterministic standard compatible across wallets.", "Backwards Compatibility": "From a wallet point of view, there does not seem to be compatibility issues since these are separate accounts from those that were used previously by wallets and they are supposed to be used along-side in synergy.", "Implementation": "Here is an early implementation of app keys for standard (non HW) MetaMask accounts.\nhttps://github.com/MetaMask/eth-simple-keyring/blob/6d12bd9d73adcccbe0b0c7e32a99d279085e2934/index.js#L139-L152", "Example use cases": "MetaMask team, Christian Lundkvist, Counterfactual team, Liam Horne, Erik Bryn, Richard Moore, Jeff Coleman.", "Acknowledgements": "MetaMask team, Christian Lundkvist, Counterfactual team, Liam Horne, Erik Bryn, Richard Moore, Jeff Coleman.", "References": "Copyright and related rights waived viaCC0.", "HD and mnemonics": "Copyright and related rights waived viaCC0.", "Previous proposals and discussions related to app keys": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1812, "url": "https://eips.ethereum.org/EIPS/eip-1812", "title": "Ethereum Verifiable Claims", "authors": ["Pelle Braendgaard\u00a0(", "@pelle", ")"], "sections": {"ERC-1812: Ethereum Verifiable Claims": "Reusable Verifiable Claims usingEIP 712 Signed Typed Data.", "": "Reusable Verifiable Claims usingEIP 712 Signed Typed Data.", "Ethereum Verifiable Claims": "Reusable Verifiable Claims usingEIP 712 Signed Typed Data.", "Simple Summary": "Reusable Verifiable Claims usingEIP 712 Signed Typed Data.", "Abstract": "A new method for Off-Chain Verifiable Claims built onEIP-712. These Claims can be issued by any user with a EIP 712 compatible web3 provider. Claims can be stored off chain and verified on-chain by Solidity Smart Contracts, State Channel Implementations or off-chain libraries.", "Motivation": "Reusable Off-Chain Verifiable Claims provide an important piece of integrating smart contracts with real world organizational requirements such as meeting regulatory requirements such as KYC, GDPR, Accredited Investor rules etc.", "Prior Art": "Verified Identity Claims such as those proposed byuPortandW3C Verifiable Claims Working Groupform an important part of building up reusable identity claims.", "Specification": "Claims can be generalized like this:", "Claims": "Claims can be generalized like this:", "Claims data structure": "Each claim should be typed based on its specific use case, which EIP 712 lets us do effortlessly. But there are 3 minimal attributes required of the claims structure.", "Presenting a Verifiable Claim": "When defining Verifiable Claims formats a Verifying Contract should be created with a publicverify()view function. This makes it very easy for other smart contracts to verify a claim correctly.", "Key Delegation": "In most simple cases the issuer of a Claim is the signer of the data. There are cases however where signing should be delegated to an intermediary key.", "Claim Types": "A Binary claim is something that doesn\u2019t have a particular value. It either is issued or not.", "Value Claims": "Value claims can be used to make a claim about the subject containing a specific readable value.", "Hashed Claims": "Hashed claims can be used to make a claim about the subject containing the hash of a claim value. Hashes should use ethereum standardkeccak256hashing function.", "EIP 712 Domain": "The EIP 712 Domain specifies what kind of message that is to be signed and is used to differentiate between signed data types. The content MUST contain the following:", "Revocation": "Both Issuers and Subjects should be allowed to revoke Verifiable Claims. Revocations can be handled through a simple on-chain registry.", "Creation of Verifiable Claims Domains": "Creating specific is Verifiable Claims Domains is out of the scope of this EIP.   The Example Code has a few examples.", "Rationale": "Signed Typed Data provides a strong foundation for Verifiable Claims that can be used in many different kinds of applications built on both Layer 1 and Layer 2 of Ethereum.", "Rationale for using not using a single EIP 712 Domain": "EIP712 supports complex types and domains in itself, that we believe are perfect building blocks for building Verifiable Claims for specific purposes.", "Test Cases": "There is a repo with a few example verifiers and consuming smart contracts written in Solidity:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1822, "url": "https://eips.ethereum.org/EIPS/eip-1822", "title": "Universal Upgradeable Proxy Standard (UUPS)", "authors": ["Gabriel Barros\u00a0<", "gabriel@terminal.co", ">", "Patrick Gallagher\u00a0<", "blockchainbuddha@gmail.com", ">"], "sections": {"ERC-1822: Universal Upgradeable Proxy Standard (UUPS)": "Standard upgradeable proxy contract.", "": "Standard upgradeable proxy contract.", "Simple Summary": "Standard upgradeable proxy contract.", "Abstract": "The following describes a standard for proxy contracts which is universally compatible with all contracts, and does not create incompatibility between the proxy and business-logic contracts. This is achieved by utilizing a unique storage position in the proxy contract to store the Logic Contract\u2019s address. A compatibility check ensures successful upgrades. Upgrading can be performed unlimited times, or as determined by custom logic. In addition, a method for selecting from multiple constructors is provided, which does not inhibit the ability to verify bytecode.", "Motivation": "", "Terminology": "", "Specification": "The Proxy Contract proposed here should be deployedas is, and used as a drop-in replacement for any existing methods of lifecycle management of contracts. In addition to the Proxy Contract, we propose the Proxiable Contract interface/base which establishes a pattern for the upgrade which does not interfere with existing business rules. The logic for allowing upgrades can be implemented as needed.", "Proxy Contract": "The proposed fallback function follows the common pattern seen in other Proxy Contract implementations such asZeppelinorGnosis.", "Proxiable Contract": "The Proxiable Contract is included in the Logic Contract, and provides the functions needed to perform an upgrade. The compatibility checkproxiableprevents irreparable updates during an upgrade.", "Pitfalls when using a proxy": "The following common best practices should be employed for all Logic Contracts when using a proxy contract.", "Separating Variables from Logic": "Careful consideration should be made when designing a new Logic Contract to prevent incompatibility with the existing storage of the Proxy Contract after an upgrade. Specifically, the order in which variables are instantiated in the new contract should not be modified, and any new variables should be added after all existing variables from the previous Logic Contract", "Restricting dangerous functions": "The compatibility check in the Proxiable Contract is a safety mechanism to prevent upgrading to a Logic Contract which does not implement the Universal Upgradeable Proxy Standard. However, as occurred in the parity wallet hack, it is still possible to perform irreparable damage to the Logic Contract itself.", "Examples": "In this example, we show the standard ownership example, and restrict theupdateCodeAddressto only the owner.", "Owned": "In this example, we show the standard ownership example, and restrict theupdateCodeAddressto only the owner.", "ERC-20 Token": "Copyright and related rights waived viaCC0.", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1844, "url": "https://eips.ethereum.org/EIPS/eip-1844", "title": "ENS Interface Discovery", "authors": ["Nick Johnson\u00a0(", "@arachnid", ")"], "sections": {"ERC-1844: ENS Interface Discovery": "Defines a method of associating contract interfaces with ENS names and addresses, and of discovering those interfaces.", "": "Defines a method of associating contract interfaces with ENS names and addresses, and of discovering those interfaces.", "Simple Summary": "Defines a method of associating contract interfaces with ENS names and addresses, and of discovering those interfaces.", "Abstract": "This EIP specifies a method for exposing interfaces associated with an ENS name or an address (typically a contract address) and allowing applications to discover those interfaces and interact with them. Interfaces can be implemented either by the target contract (if any) or by any other contract.", "Motivation": "EIP 165 supports interface discovery - determining if the contract at a given address supports a requested interface. However, in many cases it\u2019s useful to be able to discover functionality associated with a name or an address that is implemented by other contracts.", "Specification": "A new profile for ENS resolvers is defined, consisting of the following method:", "Rationale": "A naive approach to this problem would involve adding this method directly to the target contract. However, doing this has several shortcomings:", "Backwards Compatibility": "There are no backwards compatibility issues.", "Test Cases": "TBD", "Implementation": "The PublicResolver in theensdomains/resolversrepository implements this interface.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1900, "url": "https://eips.ethereum.org/EIPS/eip-1900", "title": "dType - Decentralized Type System for EVM", "authors": ["Loredana Cirstea\u00a0(", "@loredanacirstea", ")", "Christian Tzurcanu\u00a0(", "@ctzurcanu", ")"], "sections": {"ERC-1900: dType - Decentralized Type System for EVM": "The EVM and related languages such as Solidity need consensus on an extensible Type System in order to further evolve into the Singleton Operating System (The World Computer).", "": "The EVM and related languages such as Solidity need consensus on an extensible Type System in order to further evolve into the Singleton Operating System (The World Computer).", "Simple Summary": "The EVM and related languages such as Solidity need consensus on an extensible Type System in order to further evolve into the Singleton Operating System (The World Computer).", "Abstract": "We are proposing a decentralized Type System for Ethereum, to introduce data definition (and therefore ABI) consistency. This ERC focuses on defining an on-chain Type Registry (nameddType) and a common interface for creating types, based onstructs.", "Motivation": "In order to build a network of interoperable protocols on Ethereum, we need data standardization, to ensure a smooth flow of on-chain information. Off-chain, the Type Registry will allow a better analysis of blockchain data (e.g. for blockchain explorers) and creation of smart contract development tools for easily using existing types in a new smart contract.", "Specification": "The Type Registry can have a governance protocol for its CRUD operations. However, this, and other permission guards are not covered in this proposal.", "Type Definition and Metadata": "The dType registry should support the registration of Solidity\u2019s elementary and complex types. In addition, it should also support contract events definitions. In this EIP, the focus will be on describing the minimal on-chain type definition and metadata needed for registering Solidity user-defined types.", "Rationale": "The Type Registry must store the minimum amount of information for rebuilding the type ABI definition. This allows us to:", "Backwards Compatibility": "This proposal does not affect extant Ethereum standards or implementations. It uses the present experimental version of ABIEncoderV2.", "Test Cases": "Will be added.", "Implementation": "An in-work implementation can be found at https://github.com/pipeos-one/dType/tree/master/contracts/contracts.\nThis proposal will be updated with an appropriate implementation when consensus is reached on the specifications.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1921, "url": "https://eips.ethereum.org/EIPS/eip-1921", "title": "dType Functions Extension", "authors": ["Loredana Cirstea\u00a0(", "@loredanacirstea", ")", "Christian Tzurcanu\u00a0(", "@ctzurcanu", ")"], "sections": {"ERC-1921: dType Functions Extension": "In the context of dType, the Decentralized Type System described inEIP-1900, we are proposing to add support for registering functions (with a preference forpureandview) in the dType Registry.", "": "In the context of dType, the Decentralized Type System described inEIP-1900, we are proposing to add support for registering functions (with a preference forpureandview) in the dType Registry.", "Simple Summary": "In the context of dType, the Decentralized Type System described inEIP-1900, we are proposing to add support for registering functions (with a preference forpureandview) in the dType Registry.", "Abstract": "This proposal is part of a series of EIPs focused on expanding the concept of a Decentralized Type System, as explained inEIP-1900.\nThe current EIP specifies the data definitions and interfaces needed to support registering individual smart contract functions, as entries in the dType Registry.", "Motivation": "In order to evolve the EVM into a Singleton Operating System, we need a way to register, find and address contract functions that we want to run in an automated way.\nThis implies having access to all the data needed to run the function inside the EVM.", "Specification": "This specification targetspureandviewfunctions.", "Implementation Suggestions": "In the dType registry implementation,outputscan be stored in amapping:", "Rationale": "The suggestion to treat eachpureorviewfunction as a separate entity instead of having a contract-based approach allows us to:", "Backwards Compatibility": "This proposal does not affect extant Ethereum standards or implementations. Registering functions for existing contract deployments should be fully supported.", "Test Cases": "Will be added.", "Implementation": "In-work implementation examples can be found at https://github.com/pipeos-one/dType.\nThis proposal will be updated with an appropriate implementation when consensus is reached on the specifications.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1922, "url": "https://eips.ethereum.org/EIPS/eip-1922", "title": "zk-SNARK Verifier Standard", "authors": ["Michael Connor\u00a0<", "michael.connor@uk.ey.com", ">", "Chaitanya Konda\u00a0<", "chaitanya.konda@uk.ey.com", ">", "Duncan Westland\u00a0<", "duncan.westland@uk.ey.com", ">"], "sections": {"ERC-1922: zk-SNARK Verifier Standard": "A standard interface for \u201cVerifier\u201d contracts which verify zk-SNARKs.", "": "A standard interface for \u201cVerifier\u201d contracts which verify zk-SNARKs.", "Simple Summary": "A standard interface for \u201cVerifier\u201d contracts which verify zk-SNARKs.", "Abstract": "The following standard allows for the implementation of a standard contract API for the verification of zk-SNARKs (\u201cZero-Knowledge Succinct Non-Interactive Arguments of Knowledge\u201d), also known as \u201cproofs\u201d, \u201carguments\u201d, or \u201ccommitments\u201d.", "Motivation": "zk-SNARKs are a promising area of interest for the Ethereum community. Key applications of zk-SNARKs include:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Interface": "\u26a0\ufe0f TODO: Add a specific reference to libsnark here, explaining the choice of variable names.", "Rationale": "\u26a0\ufe0f TODO: Add a specific reference to libsnark here, explaining the choice of variable names.", "Taxonomy": "\u26a0\ufe0f TODO: Add a specific reference to libsnark here, explaining the choice of variable names.", "Functions": "Theverifyfunction forms the crux this standard. The parameters are intended to be as generic as possible, to allow for verification of any zk-SNARK:", "Backwards Compatibility": "Truffle tests of example implementations are included in the test case repository.", "Test Cases": "Truffle tests of example implementations are included in the test case repository.", "Implementations": "Detailed example implementations and Truffle tests of these example implementations are included in this repository.", "References": ":warning: TODO: Update references and confirm that each reference is cited (parenthetical documentation not necessary) in the text.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1923, "url": "https://eips.ethereum.org/EIPS/eip-1923", "title": "zk-SNARK Verifier Registry Standard", "authors": ["Michael Connor\u00a0<", "michael.connor@uk.ey.com", ">", "Chaitanya Konda\u00a0<", "chaitanya.konda@uk.ey.com", ">", "Duncan Westland\u00a0<", "duncan.westland@uk.ey.com", ">"], "sections": {"ERC-1923: zk-SNARK Verifier Registry Standard": "A standard interface for a \u201cVerifier Registry\u201d\u2019\u201d contract, through which all zk-SNARK verification activity can be registered.", "": "A standard interface for a \u201cVerifier Registry\u201d\u2019\u201d contract, through which all zk-SNARK verification activity can be registered.", "Simple Summary": "A standard interface for a \u201cVerifier Registry\u201d\u2019\u201d contract, through which all zk-SNARK verification activity can be registered.", "Abstract": "The following standard allows for the implementation of a standard contract API for the registration of zk-SNARKs (\u201cZero-Knowledge Succinct Non-Interactive Arguments of Knowledge\u201d), also known as \u201cproofs\u201d, \u201carguments\u201d, or \u201ccommitments\u201d.", "Motivation": "zk-SNARKs are a promising area of interest for the Ethereum community. Key applications of zk-SNARKs include:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Interface": "\u26a0\ufe0f TODO: Add Rationale section.", "Rationale": "\u26a0\ufe0f TODO: Add Rationale section.", "Backwards Compatibility": "\u26a0\ufe0f TODO: Add Backwards Compatibility section.", "Test Cases": "Truffle tests of example implementations are included in this Repo.", "Implementations": "Detailed example implementations and Truffle tests of these example implementations are included in this Repo.", "References": "\u26a0\ufe0f TODO: Update references and confirm that each reference is cited (parenthetical documentation not necessary) in the text.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1948, "url": "https://eips.ethereum.org/EIPS/eip-1948", "title": "Non-fungible Data Token", "authors": ["Johann Barbie\u00a0(", "@johannbarbie", ")", "Ben Bollen\u00a0<", "ben@ost.com", ">", "pinkiebell\u00a0(", "@pinkiebell", ")"], "sections": {"ERC-1948: Non-fungible Data Token": "Some NFT use-cases require to have dynamic data associated with a non-fungible token that can change during its lifetime. Examples for dynamic data:", "": "Some NFT use-cases require to have dynamic data associated with a non-fungible token that can change during its lifetime. Examples for dynamic data:", "Simple Summary": "Some NFT use-cases require to have dynamic data associated with a non-fungible token that can change during its lifetime. Examples for dynamic data:", "Abstract": "Non-fungible tokens (NFTs) are extended with the ability to store dynamic data. A 32 bytes data field is added and a read function allows to access it. The write function allows to update it, if the caller is the owner of the token. An event is emitted every time the data updates and the previous and new value is emitted in it.", "Motivation": "The proposal is made to standardize on tokens with dynamic data. Interactions with bridges for side-chains like xDAI or Plasma chains will profit from the ability to use such tokens. Protocols that build on data tokens likedistributed breedingwill be enabled.", "Specification": "An extension ofERC-721interface with the following functions and events is suggested:", "Rationale": "The suggested data field in the NFT is used either for storing data directly, like a counter or address. If more data is required the implementer should fall back to authenticated data structures, like merkle- or patricia-trees.", "Backwards Compatibility": "\ud83e\udd37\u200d\u2642\ufe0f No related proposals are known to the author, hence no backwards compatibility to consider.", "Test Cases": "Simple happy test:", "Implementation": "An example implementation of the interface in solidity would look like this:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1973, "url": "https://eips.ethereum.org/EIPS/eip-1973", "title": "Scalable Rewards", "authors": ["Lee Raj\u00a0(", "@lerajk", ")", "Qin Jian\u00a0(", "@qinjian", ")"], "sections": {"ERC-1973: Scalable Rewards": "A mintable token rewards interface that mints \u2018n\u2019 tokens per block which are distributed equally among the \u2018m\u2019 participants in the DAPP\u2019s ecosystem.", "": "A mintable token rewards interface that mints \u2018n\u2019 tokens per block which are distributed equally among the \u2018m\u2019 participants in the DAPP\u2019s ecosystem.", "Simple Summary": "A mintable token rewards interface that mints \u2018n\u2019 tokens per block which are distributed equally among the \u2018m\u2019 participants in the DAPP\u2019s ecosystem.", "Abstract": "The mintable token rewards interface allows DApps to build a token economy where token rewards are distributed equally among the active participants. The tokens are minted based on per block basis that are configurable (E.g. 10.2356 tokens per block, 0.1 token per block, 1350 tokens per block) and the mint function can be initiated by any active participant. The token rewards distributed to each participant is dependent on the number of participants in the network. At the beginning, when the network has low volume, the tokens rewards per participant is high but as the network scales the token rewards decreases dynamically.", "Specification": "token amount per participant in the ecosytem or TPP (token per participant): TPP = (token amount to mint / total active participants)", "Definitions": "token amount per participant in the ecosytem or TPP (token per participant): TPP = (token amount to mint / total active participants)", "Rationale": "Currently, there is no standard for a scalable reward distribution mechanism. In order to create a sustainable cryptoeconomic environment within DAPPs, incentives play a large role. However, without a scalable way to distribute rewards to tens of thousands of participants, most DAPPs lack a good incentive structure. The ones with a sustainable cryptoeconomic environment depend heavily on centralized servers or a group of selective nodes to trigger the smart contracts. But, in order to keep an application truly decentralized, the reward distribution mechanism must depend on the active participants itself and scale as the number of participants grow. This is what this EIP intends to accomplish.", "Backwards Compatibility": "Not Applicable.", "Test Cases": "WIP, will be added.", "Implementation": "WIP, a proper implementation will be added later.A sample example is below:", "Copyright": "Copyright and related rights waived via CC0.", "References": "Please cite this document as:", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1996, "url": "https://eips.ethereum.org/EIPS/eip-1996", "title": "Holdable Token", "authors": ["Julio Faura\u00a0<", "julio@adhara.io", ">", "Fernando Paris\u00a0<", "fer@io.builders", ">", "Daniel Lehrner\u00a0<", "daniel@io.builders", ">"], "sections": {"ERC-1996: Holdable Token": "An extension to the ERC-20 standard token that allows tokens to be put on hold. This guarantees a future transfer and makes the held tokens unavailable for transfer in the mean time. Holds are similar to escrows in that are firm and lead to final settlement.", "": "An extension to the ERC-20 standard token that allows tokens to be put on hold. This guarantees a future transfer and makes the held tokens unavailable for transfer in the mean time. Holds are similar to escrows in that are firm and lead to final settlement.", "Simple Summary": "An extension to the ERC-20 standard token that allows tokens to be put on hold. This guarantees a future transfer and makes the held tokens unavailable for transfer in the mean time. Holds are similar to escrows in that are firm and lead to final settlement.", "Actors": "An account which has been approved by an account to create holds on its behalf.", "Abstract": "A hold specifies a payer, a payee, a maximum amount, a notary and an expiration time. When the hold is created, the specified token balance from the payer is put on hold. A held balance cannot be transferred until the hold is either executed or released. The hold can only be executed by the notary, which triggers the transfer of the tokens from the payer to the payee. If a hold is released, either by the notary at any time, or by anyone after the expiration, no transfer is carried out and the amount is available again for the payer.", "Motivation": "A hold has to be used in different scenarios where a immediate transfer between accounts is not possible or has to be guaranteed beforehand:", "Specification": "Creates a hold on behalf of the msg.sender in favor of the payee. It specifies a notary who is responsible to either execute or release the hold. The function must revert if the operation ID has been used before.", "Functions": "Creates a hold on behalf of the msg.sender in favor of the payee. It specifies a notary who is responsible to either execute or release the hold. The function must revert if the operation ID has been used before.", "Events": "Emitted when a hold has been created.", "Rationale": "This standards provides a functionality, to guarantee future payments, which is needed for many business cases where transfers have to be guaranteed.", "Backwards Compatibility": "This EIP is fully backwards compatible as its implementation extends the functionality of ERC-20.", "Implementation": "The GitHub repositoryIoBuilders/holdable-tokencontains the reference implementation.", "Contributors": "This proposal has been collaboratively implemented byadhara.ioandio.builders.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2009, "url": "https://eips.ethereum.org/EIPS/eip-2009", "title": "Compliance Service", "authors": ["Daniel Lehrner\u00a0<", "daniel@io.builders", ">"], "sections": {"ERC-2009: Compliance Service": "This EIP proposes a service for decentralized compliance checks for regulated tokens.", "": "This EIP proposes a service for decentralized compliance checks for regulated tokens.", "Simple Summary": "This EIP proposes a service for decentralized compliance checks for regulated tokens.", "Actors": "An account which has been approved by a token to update the tokens accumulated.", "Abstract": "A regulated token needs to comply with several legal requirements, especiallyKYCandAML. If the necessary checks have to be made off-chain the token transfer becomes centralized. Further the transfer in this case takes longer to complete as it can not be done in one transaction, but requires a second confirmation step. The goal of this proposal is to make this second step unnecessary by providing a service for compliance checks.", "Motivation": "Currently there is no proposal on how to accomplish decentralized compliance checks.ERC-1462proposes a basic set of functions to check iftransfer,mintandburnare allowed for a user, but not how those checks should be implemented. This EIP proposes a way to implement them fully on-chain while being generic enough to leave the actual implementation of the checks up to the implementers, as these may vary a lot between different tokens.", "Specification": "The checks must be verified in their corresponding actions. The action must only be successful if the check return anAllowedstatus code. In any other case the functions must revert.", "Mandatory checks": "The checks must be verified in their corresponding actions. The action must only be successful if the check return anAllowedstatus code. In any other case the functions must revert.", "Status codes": "If an action is allowed0x11(Allowed) or an issuer-specific code with equivalent but more precise meaning must be returned. If the action is not allowed the status must be0x10(Disallowed) or an issuer-specific code with equivalent but more precise meaning.", "Functions": "Checks if thetransferfunction is allowed to be executed with the given parameters.", "Events": "Must be emitted after a token has been added.", "Rationale": "The usage of a token id instead of the address has been chosen to give tokens the possibility to update their smart contracts and keeping all their associated accumulated. If the address would be used, a migration process would needed to be done after a smart contract update.", "Backwards Compatibility": "As the EIP is not using any existing EIP there are no backwards compatibilities to take into consideration.", "Implementation": "The GitHub repositoryIoBuilders/compliance-servicecontains the work in progress implementation.", "Contributors": "This proposal has been collaboratively implemented byadhara.ioandio.builders.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2018, "url": "https://eips.ethereum.org/EIPS/eip-2018", "title": "Clearable Token", "authors": ["Julio Faura\u00a0<", "julio@adhara.io", ">", "Fernando Paris\u00a0<", "fer@io.builders", ">", "Daniel Lehrner\u00a0<", "daniel@io.builders", ">"], "sections": {"ERC-2018: Clearable Token": "An account which processes, executes or rejects a clearable transfer.", "": "An account which processes, executes or rejects a clearable transfer.", "Simple Summary": "An account which processes, executes or rejects a clearable transfer.", "Actors": "An account which processes, executes or rejects a clearable transfer.", "Abstract": "The clearing process turns the promise of a transfer into the actual movement of money from one account to another. A clearing agent decides if the transfer can be executed or not. The amount which should be transferred is not deducted from the balance of the payer, but neither is it available for another transfer and therefore ensures, that the execution of the transfer will be successful when it is executed.", "Motivation": "A regulated token needs to comply with all the legal requirements, especiallyKYCandAML. Some of these checks may not be able to be done on-chain and therefore a transfer may not be completed in one step. Currently there is no EIP to make such off-chain checks possible. This proposal allows a user to order a transfer, which can be checked by a clearing agent off-chain. Depending on the result of it, the clearing agent will either execute or cancel the transfer. To provide more information why a transfer is cancelled, the clearing agent can add a reason why it is not executed.", "Specification": "Orders a clearable transfer on behalf of the msg.sender in favor ofto. A clearing agent is responsible to either execute or reject the transfer. The function must revert if the operation ID has been used before.", "Functions": "Orders a clearable transfer on behalf of the msg.sender in favor ofto. A clearing agent is responsible to either execute or reject the transfer. The function must revert if the operation ID has been used before.", "Events": "Must be emitted when a clearable transfer is ordered.", "Rationale": "This EIP usesEIP-1996to hold the money after a transfer is ordered. A clearing agent, whose implementation is not part of this proposal, acts as a predefined notary to decide if the transfer complies with the rules of the token or not.", "Backwards Compatibility": "This EIP is fully backwards compatible as its implementation extends the functionality ofEIP-1996.", "Implementation": "The GitHub repositoryIoBuilders/clearable-tokencontains the reference implementation.", "Contributors": "This proposal has been collaboratively implemented byadhara.ioandio.builders.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2019, "url": "https://eips.ethereum.org/EIPS/eip-2019", "title": "Fundable Token", "authors": ["Fernando Paris\u00a0<", "fer@io.builders", ">", "Julio Faura\u00a0<", "julio@adhara.io", ">", "Daniel Lehrner\u00a0<", "daniel@io.builders", ">"], "sections": {"ERC-2019: Fundable Token": "An extension to theERC-20standard token that allows Token wallet owners to request a wallet to be funded, by calling the smart contract and attaching a fund instruction string.", "": "An extension to theERC-20standard token that allows Token wallet owners to request a wallet to be funded, by calling the smart contract and attaching a fund instruction string.", "Simple Summary": "An extension to theERC-20standard token that allows Token wallet owners to request a wallet to be funded, by calling the smart contract and attaching a fund instruction string.", "Actors": "The person or company who owns the wallet, and will order a token fund request into the wallet.", "Abstract": "Token wallet owners (or approved addresses) can order tokenization requests through  blockchain. This is done by calling theorderFundororderFundFrommethods, which initiate the workflow for the token contract operator to either honor or reject the fund request. In this case, fund instructions are provided when submitting the request, which are used by the operator to determine the source of the funds to be debited in order to do fund the token wallet (through minting).", "Motivation": "Nowadays most of the token issuing/funding request, based on any fiat based payment method  need a previous centralized transaction, to be able to get the desired tokens issued on requester\u2019s wallet.\nIn the aim of trying to bring all the needed steps into decentralization, exposing all the needed steps of token lifecycle and payment transactions, a funding request can allow wallet owner to initiate the funding request via  blockchain.\nKey benefits:", "Specification": "Wallet owner, authorizes a given address to be fund orderer.", "Functions": "Wallet owner, authorizes a given address to be fund orderer.", "Events": "Emitted when an token wallet owner orders a funding request.", "Rationale": "This standards provides a functionality to allow token holders to start funding requests in a decentralized way.", "Backwards Compatibility": "This EIP is fully backwards compatible as its implementation extends the functionality ofERC-20.", "Implementation": "The GitHub repositoryIoBuilders/fundable-tokencontains the work in progress implementation.", "Contributors": "This proposal has been collaboratively implemented byadhara.ioandio.builders.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2020, "url": "https://eips.ethereum.org/EIPS/eip-2020", "title": "E-Money Standard Token", "authors": ["Julio Faura\u00a0<", "julio@adhara.io", ">", "Fernando Paris\u00a0<", "fer@io.builders", ">", "Daniel Lehrner\u00a0<", "daniel@io.builders", ">"], "sections": {"ERC-2020: E-Money Standard Token": "The E-Money Standard Token aims to enable the issuance of regulated electronic money on blockchain networks, and its practical usage in real financial applications.", "": "The E-Money Standard Token aims to enable the issuance of regulated electronic money on blockchain networks, and its practical usage in real financial applications.", "Simple Summary": "The E-Money Standard Token aims to enable the issuance of regulated electronic money on blockchain networks, and its practical usage in real financial applications.", "Actors": "An account, which has been approved by an account to perform an action on the behalf of another account.", "Abstract": "Financial institutions work today with electronic systems, which hold account balances in databases on core banking systems. In order for an institution to be allowed to maintain records of client balances segregated and available for clients, such institution must be regulated under a known legal framework and must possess a license to do so. Maintaining a license under regulatory supervision entails ensuring compliance (i.e. performing KYC on all clients and ensuring good AML practices before allowing transactions) and demonstrating technical and operational solvency through periodic audits, so clients depositing funds with the institution can rest assured that their money is safe.", "Motivation": "There are only a number of potential regulatory license frameworks that allow institutions to issue and hold money balances for customers (be it retail corporate or institutional types). The most important and practical ones are three:", "Specification": "The checks must be verified in their corresponding actions. The action must only be successful if the check return anAllowedstatus code. In any other case the functions must revert.", "Mandatory checks": "The checks must be verified in their corresponding actions. The action must only be successful if the check return anAllowedstatus code. In any other case the functions must revert.", "Status codes": "If an action is allowed0x11(Allowed), or an issuer-specific code with equivalent but more precise meaning must be returned. If the action is not allowed the status must be0x10(Disallowed), or an issuer-specific code with equivalent but more precise meaning.", "Functions": "Returns the currency that backs the token. The value must be a code defined inISO 4217.", "Rationale": "This EIP unifiesERC-1996,ERC-2018,ERC-2019andERC-2021and adds the checks for the compliance on top of it. By this way the separate EIPs are otherwise independent of each other, and the E-Money Standard Token offers a solution for all necessary functionality of regulated electronic money.", "Backwards Compatibility": "This EIP is fully backwards compatible as its implementation extends the functionality ofERC-1996,ERC-2018,ERC-2019,ERC-2021andERC-1066.", "Implementation": "The GitHub repositoryIoBuilders/em-tokencontains the work in progress implementation.", "Contributors": "This proposal has been collaboratively implemented byadhara.ioandio.builders.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2021, "url": "https://eips.ethereum.org/EIPS/eip-2021", "title": "Payoutable Token", "authors": ["Fernando Paris\u00a0<", "fer@io.builders", ">", "Julio Faura\u00a0<", "julio@adhara.io", ">", "Daniel Lehrner\u00a0<", "daniel@io.builders", ">"], "sections": {"ERC-2021: Payoutable Token": "An extension to theERC-20standard token that allows Token wallet owners to request payout from their wallet, by calling the smart contract and attaching a payout instruction string.", "": "An extension to theERC-20standard token that allows Token wallet owners to request payout from their wallet, by calling the smart contract and attaching a payout instruction string.", "Simple Summary": "An extension to theERC-20standard token that allows Token wallet owners to request payout from their wallet, by calling the smart contract and attaching a payout instruction string.", "Actors": "The person or company who owns the wallet, and will order payout.", "Abstract": "Token wallet owners (or approved addresses) can order payout requests through  blockchain. This is done by calling theorderPayoutFromororderPayoutFrommethods, which initiate the workflow for the token contract operator to either honor or reject the payout request. In this case, payout instructions are provided when submitting the request, which are used by the operator to determine the destination of the funds.", "Motivation": "Nowadays most of the token payout requests, need a previous centralized transaction, to be able to define the payout destination to be able to execute the payout (burn transaction).\nIn the aim of trying to bring all the needed steps into decentralization, exposing all the needed steps of token lifecycle and payment transactions, a payout request can allow wallet owner to initiate the payout order via blockchain.\nKey benefits:", "Specification": "Wallet owner, allows a given address to be payout orderer.", "Functions": "Wallet owner, allows a given address to be payout orderer.", "Events": "Emitted when an token wallet owner orders a payout request.", "Rationale": "This standards provides a functionality to allow token holders to start payout requests in a decentralized way.", "Backwards Compatibility": "This EIP is fully backwards compatible as its implementation extends the functionality ofERC-20and [ERC-1996].", "Implementation": "The GitHub repositoryIoBuilders/payoutable-tokencontains the reference implementation.", "Contributors": "This proposal has been collaboratively implemented byadhara.ioandio.builders.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2157, "url": "https://eips.ethereum.org/EIPS/eip-2157", "title": "dType Storage Extension - Decentralized Type System for EVM", "authors": ["Loredana Cirstea\u00a0(", "@loredanacirstea", ")", "Christian Tzurcanu\u00a0(", "@ctzurcanu", ")"], "sections": {"ERC-2157: dType Storage Extension - Decentralized Type System for EVM": "This ERC is an extension of ERC-1900, proposing an optional storage extension for dType, a decentralized type system, specifying a general ABI for all storage contracts that contain type instances.", "": "This ERC is an extension of ERC-1900, proposing an optional storage extension for dType, a decentralized type system, specifying a general ABI for all storage contracts that contain type instances.", "Simple Summary": "This ERC is an extension of ERC-1900, proposing an optional storage extension for dType, a decentralized type system, specifying a general ABI for all storage contracts that contain type instances.", "Abstract": "The storage extension will enable easy navigation and retrieval of type data that is intended to be of public use. This is possible through standardizing the ABI of the dType storage contracts, with the effect of having a deterministic path to a type instance record. This standardization enables a more effective on-chain and off-chain use of data and opens up possibilities for decentralized applications, enabling developers to build on top of public global data.", "Motivation": "Currently, Ethereum does not have standardization of data addressability. This might not be needed for data that is meant to be quasi-private, however, it is needed for data that is meant for public consumption. ERC-1900 has started standardizing data types for increasing interoperability between projects, but this is not enough if we want to build a global ecosystem. Deterministic data addressability will enable anyone to build upon the same public data sets, off-chain or on-chain.", "Specification": "ERC-1900 defines acontractAddressfield in the type metadata. For the limited purpose of ERC-1900, this field contains the value of the Ethereum type library in which the type definition exists. For the purpose of this ERC, thecontractAddresswill contain the Etherereum address of aTypeRootContract.", "TypeRootContract": "ERC-1900 defines acontractAddressfield in the type metadata. For the limited purpose of ERC-1900, this field contains the value of the Ethereum type library in which the type definition exists. For the purpose of this ERC, thecontractAddresswill contain the Etherereum address of aTypeRootContract.", "TypeStorageContract": "This contract will use the type library to define the internal data stored in it. Each record will be a type instance, addressable by a primary identifier. The primary identifier is calculated by the type library\u2019sgetIdentifierfunction, based on the type instance values.", "Rationale": "We are now thinking about a building block as a smart contract with an encapsulated object that contains state changing functions that are only understood from within. This is more akin to Object-Oriented Programming and poses interoperability and scalability issues. Not necessarily for an individual project, but for a global Ethereum OS. This is why we are proposing to separate data from business logic and data structure definitions.", "Backwards Compatibility": "This proposal does not affect existent Ethereum standards or implementations. It uses the present experimental version of ABIEncoderV2.", "Test Cases": "Will be added.", "Implementation": "An in-work implementation can be found at https://github.com/pipeos-one/dType/tree/master/contracts/contracts.\nThis proposal will be updated with an appropriate implementation when consensus is reached on the specifications.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2193, "url": "https://eips.ethereum.org/EIPS/eip-2193", "title": "dType Alias Extension - Decentralized Type System", "authors": ["Loredana Cirstea\u00a0(", "@loredanacirstea", ")", "Christian Tzurcanu\u00a0(", "@ctzurcanu", ")"], "sections": {"ERC-2193: dType Alias Extension - Decentralized Type System": "We are proposing Alias\u200a-\u200aa semantic standard for identifying on-chain resources by human-readable qualifiers, supporting any type of data.", "": "We are proposing Alias\u200a-\u200aa semantic standard for identifying on-chain resources by human-readable qualifiers, supporting any type of data.", "Simple Summary": "We are proposing Alias\u200a-\u200aa semantic standard for identifying on-chain resources by human-readable qualifiers, supporting any type of data.", "Abstract": "The dType Alias is a system for providing human-readable resource identifiers to on-chain content. A resource identifier is based on the type of data (identifier provided by dType,EIP-1900) and the data content (identifier provided by a dType Storage Contract,EIP-2157). It is a universal way of addressing content, supporting any type of data.", "Motivation": "There are standards that currently address the need for attaching human-readable identifiers to Ethereum accounts, such asEIP-137. These standards are an attempt to bring domain names to Ethereum, following the same format as DNS:subdomain.domain.tld. This leaf -> root format is unintuitive and contradicts the semantic meaning that.has in programming languages, which is a root -> leaf connection (e.g. in OOP, when accessing an object\u2019s property). A more intuitive and widely used approach is a root->leaf format, used in file browsers, hierarchical menus, and even in other decentralized systems, which give unique identifiers to resources (e.g.0x56.Currency.TCoininLibra.", "Specification": "The dType registry will provide domain and subdomain names for the resource type. Subdomains can be attributed recursively, to dType types which contain other complex types in their composition.", "Rationale": "Current attempts to solve content addressability, such asEIP-137, only target Ethereum accounts. These are based on inherited concepts from HTTP and DNS, which are not machine friendly.", "Backwards Compatibility": "Will be added.", "Test Cases": "Will be added.", "Implementation": "An in-work implementation can be found at https://github.com/pipeos-one/dType/blob/master/contracts/contracts/Alias.sol.\nThis proposal will be updated with an appropriate implementation when consensus is reached on the specifications.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2304, "url": "https://eips.ethereum.org/EIPS/eip-2304", "title": "Multichain address resolution for ENS", "authors": ["Nick Johnson\u00a0<", "nick@ens.domains", ">"], "sections": {"ERC-2304: Multichain address resolution for ENS": "This EIP introduces new overloads for theaddrfield for ENS resolvers, which permit resolution of addresses for other blockchains via ENS.", "": "This EIP introduces new overloads for theaddrfield for ENS resolvers, which permit resolution of addresses for other blockchains via ENS.", "Abstract": "This EIP introduces new overloads for theaddrfield for ENS resolvers, which permit resolution of addresses for other blockchains via ENS.", "Motivation": "With the increasing uptake of ENS by multi-coin wallets, wallet authors have requested the ability to resolve addresses for non-Ethereum chains inside ENS. This specification standardises a way to enter and retrieve these addresses in a cross-client fashion.", "Specification": "A new accessor function for resolvers is specified:", "Recommended accessor functions": "The following function provides the recommended interface for changing the addresses stored for a node. Resolvers SHOULD implement this interface for setting addresses unless their needs dictate a different interface.", "Address Encoding": "In general, the native binary representation of the address should be used, without any checksum commonly used in the text representation.", "Example": "An example implementation of a resolver that supports this EIP is provided here:", "Implementation": "An implementation of this interface is provided in theensdomains/resolversrepository.", "Backwards Compatibility": "If the resolver supports theaddr(bytes32)interface defined in EIP137, the resolver MUST treat this as a special case of this new specification in the following ways:", "Tests": "The table below specifies test vectors for valid address encodings for each cryptocurrency described above.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2333, "url": "https://eips.ethereum.org/EIPS/eip-2333", "title": "BLS12-381 Key Generation", "authors": ["Carl Beekhuizen (@CarlBeek)\u00a0<", "carl@ethereum.org", ">"], "sections": {"ERC-2333: BLS12-381 Key Generation": "This EIP is a method based on a tree structure for deriving BLS private keys from a single source of entropy while providing a post-quantum cryptographic fallback for each key.", "": "This EIP is a method based on a tree structure for deriving BLS private keys from a single source of entropy while providing a post-quantum cryptographic fallback for each key.", "Simple Summary": "This EIP is a method based on a tree structure for deriving BLS private keys from a single source of entropy while providing a post-quantum cryptographic fallback for each key.", "Abstract": "This standard is a method for deriving a tree-hierarchy of BLS12-381 keys based on an entropy seed. Starting with the aforementioned seed, a tree of keys is built out using only the parent node\u2019s private key and the index of the desired child. This allows for a practically limitless number of keys to be derived for many different purposes while only requiring knowledge of a single ancestor key in the tree. This allows for keys, or families thereof, to be provisioned for different purposes by further standards.", "A note on purpose": "This specification is designed not only to be an Ethereum 2.0 standard, but one that is adopted by the wider community who have adoptedBLS signatures over BLS12-381. It is therefore important also to consider the needs of the wider industry along with those specific to Ethereum. As a part of these considerations, it is the intention of the author that this standard eventually migrate to a more neutral repository in the future.", "Motivation": "The curve BLS12-381 used for BLS signatures within Ethereum 2.0 (alongside many other projects) mandates a new key derivation scheme. The most commonly used scheme for key derivation within Ethereum 1.x isBIP32(also known as HD derivation) which deems keys greater than the curve order invalid. Based on the order of the private key subgroup of BLS12-381 and the size of the entropy utilised, more than 54% of keys generated by BIP32 would be invalid. (secp256k1 keys derived by BIP32 are invalid with probability less than 1 in 2-127.)", "Deficiencies of the existing mechanism": "The curve BLS12-381 used for BLS signatures within Ethereum 2.0 (alongside many other projects) mandates a new key derivation scheme. The most commonly used scheme for key derivation within Ethereum 1.x isBIP32(also known as HD derivation) which deems keys greater than the curve order invalid. Based on the order of the private key subgroup of BLS12-381 and the size of the entropy utilised, more than 54% of keys generated by BIP32 would be invalid. (secp256k1 keys derived by BIP32 are invalid with probability less than 1 in 2-127.)", "Establishing a multi-chain standard early on": "By establishing a standard before the first users begin to generate their keys, the hope is that a single standard is highly pervasive and therefore can be assumed to be the method by which the majority of keys are provided. This is valuable for two reasons, firstly in order for a post-quantum backup mechanism to be effective, there needs to be an enshrined mechanism whereby users can switch to a post-quantum signature scheme with pre-shared public keys (something this EIP provides at 0 extra storage cost). Secondly, this unifies the inter- and intra-chain ecosystem by having common tooling ideally allowing users to switch between key-management systems.", "A post-quantum backup": "This key derivation scheme has a Lamport key pair which is generated as a intermediate step in the key generation process. This key pair can be used to provide a Lamport signature which is a useful backup in the event of BLS12-381 no longer being considered secure (in the event of quantum computing making a sudden advancement, for example). The idea is the Lamport signature will act as a bridge to a new signature scheme which is deemed to be secure.", "Specification": "Keys are defined in terms of a tree structure where a key is determined by the tree\u2019s seed and a tree path. This is very useful as one can start with a single source of entropy and build out a practically unlimited number of keys. The specification can be broken into two sub-components: generating the master key, and constructing a child key from its parent. The master key is used as the root of the tree and then the tree is built in layers on top of this root.", "Version": "Due to the evolving BLS signatures CFRG draft (currently v4), theKeyGenfunction was updated, meaning thathkdf_mod_rno longer reflected what appeared in the BLS standard. This EIP was updated on the 17th of September 2020 to reflect this new method for deriving keys,if you are implementing this EIP, please make sure your version is up to date.", "The Tree Structure": "The key tree is defined purely through the relationship between a child-node and its ancestors. Starting with the root of the tree, themaster key, a child node can be derived by knowing the parent\u2019s private key and the index of the child. The tree is broken up into depths which are indicated by/and the master node is described asm. The first child of the master node is therefore described asm / 0andm / 0\u2019s siblings arem / ifor all0 <= i < 2**32.", "Key derivation": "Every key generated via the key derivation process derives a child key via a set of intermediate Lamport keys. The idea behind the Lamport keys is to provide a post-quantum backup in case BLS12-381 is no longer deemed secure. At a high level, the key derivation process works by using the parent node\u2019s privkey as an entropy source for the Lamport private keys which are then hashed together into a compressed Lamport public key, this public key is then hashed into BLS12-381\u2019s private key group.", "derive_child_SK": "The child key derivation function takes in the parent\u2019s private key and the index of the child and returns the child private key.", "derive_master_SK": "The child key derivation function takes in the parent\u2019s private key and the index of the child and returns the child private key. The seed should ideally be derived from a mnemonic, with the intention being thatBIP39 mnemonics, with the associatedmnemonic_to_seed methodbe used.", "Rationale": "Lamport signatures are used as the backup mechanism because of their relative simplicity for a post-quantum signature scheme. Lamport signatures are very easy both to explain and implement as the sole cryptographic dependency is a secure hash function. This is important as it minimises the complexity of implementing this standard as well as the compute time for deriving a key. Lamport signatures have very large key sizes which make them impractical for many use cases, but this is not deemed to be an issue in this case as this scheme is only meant to be a once-off event to migrate to a new scheme.", "Lamport signatures": "Lamport signatures are used as the backup mechanism because of their relative simplicity for a post-quantum signature scheme. Lamport signatures are very easy both to explain and implement as the sole cryptographic dependency is a secure hash function. This is important as it minimises the complexity of implementing this standard as well as the compute time for deriving a key. Lamport signatures have very large key sizes which make them impractical for many use cases, but this is not deemed to be an issue in this case as this scheme is only meant to be a once-off event to migrate to a new scheme.", "SHA256": "SHA256 is used as the hash function throughout this standard as it is the hash function chosen by theIETF BLS signature proposed standard. Using a single hash function for everything decreases the number of cryptographic primitives required to implement the entire BLS standardised key-stack while reducing the surface for flaws in the overall system.", "hkdf_mod_r()": "The functionhkdf_mod_r()in this standard is the same as theKeyGenfunction described in theproposed standardand therefore the private key obtained fromKeyGenis equal to that obtained fromhkdf_mod_rfor the same seed bytes. This means that common engineering can be done when implementing this function. Additionally because of its inclusion in an IETF standard, it has had much scrutiny by many cryptographers and cryptanalysts, thereby lending credence to its safety as a key derivation mechanism.", "Only using hardened keys": "Widely accepted standards that existed before this one (BIP32andBIP44) utilise the notion of hardened and non-hardened keys whereas this specification only offers the former. Non-hardened keys are primarily useful in a UTXO system in which having one\u2019s balance spilt amongst many accounts does not present much additionally complexity, but such keys are much less useful outside of this context. Further complicating matters is the problem of deriving non-hardened keys using a post-quantum signature scheme as non-hardened keys are made possible by the very group arithmetic quantum computers gain an advantage over.", "Backwards Compatibility": "There are no major backwards compatibility issues brought upon by this EIP as it is not designed for use within Ethereum 1.0 as it currently stands. That said, this standard is not compatible with BIP32/ BIP44 style paths as paths specified by these systems make use of non-hardened keys, something that does not exist within this standard.", "Test Cases": "This test case can be extended to test the entire mnemonic-to-child_SKstack, assumingBIP39is used as the mnemonic generation mechanism. Using the following parameters, the above seed can be calculated:", "Test Case 0": "This test case can be extended to test the entire mnemonic-to-child_SKstack, assumingBIP39is used as the mnemonic generation mechanism. Using the following parameters, the above seed can be calculated:", "Test Case 1": "Copyright and related rights waived viaCC0.", "Test Case 2": "Copyright and related rights waived viaCC0.", "Test Case 3": "Copyright and related rights waived viaCC0.", "Test Vector with Intermediate values": "Copyright and related rights waived viaCC0.", "Implementation": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2334, "url": "https://eips.ethereum.org/EIPS/eip-2334", "title": "BLS12-381 Deterministic Account Hierarchy", "authors": ["Carl Beekhuizen (@CarlBeek)\u00a0<", "carl@ethereum.org", ">"], "sections": {"ERC-2334: BLS12-381 Deterministic Account Hierarchy": "This EIP defines the purpose of a given key, or family thereof, within a tree of keys. When combined withEIP-2333, the combination of a seed and knowledge of the desired purpose of a key is sufficient to determine a key pair.", "": "This EIP defines the purpose of a given key, or family thereof, within a tree of keys. When combined withEIP-2333, the combination of a seed and knowledge of the desired purpose of a key is sufficient to determine a key pair.", "Simple Summary": "This EIP defines the purpose of a given key, or family thereof, within a tree of keys. When combined withEIP-2333, the combination of a seed and knowledge of the desired purpose of a key is sufficient to determine a key pair.", "Abstract": "A standard for allocating keys generated byEIP-2333to a specific purpose. It defines apathwhich is a string that parses into the indices to be used when traversing the tree of keys thatEIP-2333generates.", "A note on purpose": "This specification is designed not only to be an Ethereum 2.0 standard, but one that is adopted by the wider community who have adoptedBLS signatures over BLS12-381. It is therefore important also to consider the needs of the wider industry along with those specific to Ethereum. As a part of these considerations, it is the intention of the author that this standard eventually migrate to a more neutral repository in the future.", "Motivation": "Ethereum 2.0 alongside many other projects will use BLS signatures over BLS12-381, anIETF proposed standard. This new scheme requires a new key derivation mechanism, which is established withinEIP-2333. This new scheme is incompatible with the current form of this specification (BIP44) due to the: exclusive use of hardened keys, the increased number of keys per level, not usingBIP32for key derivation. It is therefore necessary to establish a newpathfor traversing theEIP-2333key-tree.", "Specification": "The path traversed through the tree of keys is defined by integers (which indicate the sibling index) separated by/which denote ancestor relations. There are 4 levels (plus the master node) in the path and at least 4 (5 including the master node) MUST be used.", "Path": "The path traversed through the tree of keys is defined by integers (which indicate the sibling index) separated by/which denote ancestor relations. There are 4 levels (plus the master node) in the path and at least 4 (5 including the master node) MUST be used.", "Purpose": "Thepurposeis set to12381which is the name of the new curve (BLS12-381). In order to be in compliance with this standard, theEIP-2333MUST be implemented as the KDF and therefore, the purpose12381MAY NOT be used unless this is the case.", "Coin Type": "Thecoin_typehere reflects the coin number for an individual coin thereby acting as a means of separating the keys used for different chains.", "Account": "accountis a field that provides the ability for a user to have distinct sets of keys for different purposes, if they so choose. This is the level at which different accounts for a single user SHOULD to be implemented.", "Use": "This level is designed to provide a set of related keys that can be used for any purpose. The idea being that a single account has many uses which are related yet should remain separate for security reasons. It is required to support this level in the tree, although, for many purposes it will remain0.", "Eth2 Specific Parameters": "A new coin type is chosen for Eth2 keys to help ensure a clean separation between Eth2 and Eth1 keys. Although the distinction between Eth1 ETH and Eth2 ETH is subtle, they are distinct entities and there are services which only distinguish between coins by their coin name (eg.ENS\u2019 multichain address resolution).3600is chosen specifically because it is the square of the Eth1\u2019scoin_type(3600==60^2) thereby signaling that it is second instantiation of Ether the currency.", "Rationale": "purpose,coin_type, andaccountare widely-adopted terms as perBIP43andBIP44and therefore reusing these terms and their associated meanings makes sense.", "Backwards Compatibility": "BIP43andBIP44are the commonly used standards for this purpose within Ethereum 1.0, however they have not beenAcceptedas standards as yet. Due to the use of a new KDF withinEIP-2333, a new path standard is required. This EIP implements this, with minor changes.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2335, "url": "https://eips.ethereum.org/EIPS/eip-2335", "title": "BLS12-381 Keystore", "authors": ["Carl Beekhuizen (@CarlBeek)\u00a0<", "carl@ethereum.org", ">"], "sections": {"ERC-2335: BLS12-381 Keystore": "A JSON format for the storage and interchange of BLS12-381 private keys.", "": "A JSON format for the storage and interchange of BLS12-381 private keys.", "Simple Summary": "A JSON format for the storage and interchange of BLS12-381 private keys.", "Abstract": "A keystore is a mechanism for storing private keys. It is a JSON file that encrypts a private key and is the standard for interchanging keys between devices as until a user provides their password, their key is safe.", "A note on purpose": "This specification is designed not only to be an Ethereum 2.0 standard, but one that is adopted by the wider community who have adopted the BLS12-381 signature standard. It is therefore important also to consider the needs of the wider industry along with those specific to Ethereum. As a part of these considerations, it is the intention of the author that this standard eventually migrate to a more neutral repository in the future.", "Motivation": "The secure storage and exchange of keys is a vital component of the user experience as people are expected to hold their own keys. It allows users to control access to individual keys and their use by applications.", "Specification": "The process of decrypting the secret held within a keystore can be broken down into 3 sub-processes: obtaining the decryption key, verifying the password and decrypting the secret. Each process has its own functions which can be selected from as well as parameters required for the function all of which are specified within the keystore file itself.", "Password requirements": "The password is a string of arbitrary unicode characters. The password is first converted to its NFKD representation, then the control codes (specified below) are stripped from the password and finally it is UTF-8 encoded.", "Modules": "This standard makes use of the notion of amodulewhich serves to represent, in an abstract sense, the different \u00a0cryptographic constructions and corresponding parameters for each component of the keystore. The idea being that components can be swapped out without affecting the rest of the specification should the need arise.", "Decryption key": "The decryption key is an intermediate key which is used both to verify the user-supplied password is correct, as well as for the final secret decryption. This key is simply derived from the password, thefunction, and theparamsspecified by thekdfmodule as per the keystore file.", "Password verification": "The password verification step verifies that the password is correct with respect to thechecksum.message,cipher.message, andkdf. This is done by appending thecipher.messageto the 2nd 16 bytes of the decryption key, obtaining its SHA256 hash and verifying whether it matches thechecksum.message.", "Secret decryption": "Thecipher.functionencrypts the secret using the decryption key, thus to decrypt it, the decryption key along with thecipher.functionandcipher.paramsmust be used. If thedecryption_keyis longer than the key size required by the cipher, it is truncated to the correct number of bits. In the case of aes-128-ctr, only the first 16 bytes of thedecryption_keyare used as the AES key.", "Description": "This field is an optional field to help explain the purpose and identify a particular keystores in a user-friendly manner. While this field can, and should, be used to help distinguish keystores from one-another, thedescriptionis not necessarily unique.", "PubKey": "Thepubkeyis the public key associated with the private key secured within the keystore. It is stored here to improve user experience and security which is achieved by not requiring users to enter their password just to obtain their public keys. This field is required if the secret being stored within the keystore is a private key. The encoding of thepubkeyis specified in the in the appropriate signature standard (eg.BLS12-381 signature standard), but can be seen as a byte-string in the abstract and should be directly compatible with the appropriate signature library.", "Path": "Thepathindicates where in the key-tree a key originates from. It is a string defined byEIP-2334, if no path is known or the path is not relevant, the empty string,\"\"indicates this. Thepathcan specify an arbitrary depth within the tree and the deepest node within the tree indicates the depth of the key stored within this file.", "UUID": "Theuuidprovided in the keystore is a randomly generated UUID as specified byRFC 4122. It is used as a 128-bit proxy for referring to a particular set of keys or account.", "Version": "Theversionis set to4.", "JSON schema": "The keystore, at its core, is constructed with modules which allow for the configuration of the cryptographic constructions used password hashing, password verification and secret decryption. Each module is composed of:function,params, andmessagewhich corresponds with which construction is to be used, what the configuration for the construction is, and what the input is.", "Rationale": "The rationale behind the design of this specification is largely the same as that behind theEthereum 1 keystore definitionexcept for the lack of support for Keccak (explained inmotivation above) and the notion of modules.", "Backwards Compatibility": "This specification is not backwards compatible with theexisting keystore standarddue to the lack of Keccak256 checksums as explained above. While this format is capable of supporting Keccak checksums via the Checksum module, it would defeat the purpose of this standard to include it as this standard could no longer be considered neutral with respect to other projects in the industry.", "Test Cases": "Password\"\ud835\udd31\ud835\udd22\ud835\udd30\ud835\udd31\ud835\udd2d\ud835\udd1e\ud835\udd30\ud835\udd30\ud835\udd34\ud835\udd2c\ud835\udd2f\ud835\udd21\ud83d\udd11\"Encoded Password:0x7465737470617373776f7264f09f9491Secret0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f", "Scrypt Test Vector": "Password\"\ud835\udd31\ud835\udd22\ud835\udd30\ud835\udd31\ud835\udd2d\ud835\udd1e\ud835\udd30\ud835\udd30\ud835\udd34\ud835\udd2c\ud835\udd2f\ud835\udd21\ud83d\udd11\"Encoded Password:0x7465737470617373776f7264f09f9491Secret0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f", "PBKDF2 Test Vector": "Password\"\ud835\udd31\ud835\udd22\ud835\udd30\ud835\udd31\ud835\udd2d\ud835\udd1e\ud835\udd30\ud835\udd30\ud835\udd34\ud835\udd2c\ud835\udd2f\ud835\udd21\ud83d\udd11\"Encoded Password:0x7465737470617373776f7264f09f9491Secret0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f", "Implementation": "Implementations exist in the following languages:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2386, "url": "https://eips.ethereum.org/EIPS/eip-2386", "title": "Ethereum 2 Hierarchical Deterministic Walletstore", "authors": ["Jim McDonald\u00a0<", "Jim@mcdee.net", ">"], "sections": {"ERC-2386: Ethereum 2 Hierarchical Deterministic Walletstore": "A JSON format for the storage and retrieval of Ethereum 2 hierarchical deterministic (HD) wallet definitions.", "": "A JSON format for the storage and retrieval of Ethereum 2 hierarchical deterministic (HD) wallet definitions.", "Simple Summary": "A JSON format for the storage and retrieval of Ethereum 2 hierarchical deterministic (HD) wallet definitions.", "Abstract": "Ethereum has the concept of keystores: pieces of data that define a key (seeEIP-2335for details).  This adds the concept of walletstores: stores that define wallets and how keys in said wallets are created.", "Motivation": "Hierarchical deterministic wallets create keys from aseedand apath.  The seed needs to be accessible to create new keys, however it should also be protected to the same extent as private keys to stop it from becoming an easy attack vector.  The path, or at least the variable part of it, needs to be stored to ensure that keys are not duplicated.  Providing a standard method to do this can promote interoperability between wallets and similar software.", "Specification": "The elements of a hierarchical deterministic walletstore are as follows:", "UUID": "Theuuidprovided in the walletstore is a randomly-generated type 4 UUID as specified byRFC 4122. It is intended to be used as a 128-bit proxy for referring to a particular wallet, used to uniquely identify wallets.", "Name": "Thenameprovided in the walletstore is a UTF-8 string.  It is intended to serve as the user-friendly accessor.  The only restriction on the name is that it MUST NOT start with the underscore (_) character.", "Version": "Theversionprovided is the version of the walletstore.", "Type": "Thetypeprovided is the type of wallet.  This informs mechanisms such as key generation.", "Crypto": "Thecryptoprovided is the secure storage of a secret for wallets that require this information.  For hierarchical deterministic wallets this is the seed from which they calculate individual private keys.", "Next Account": "Thenextaccountprovided is the index to be supplied to the pathm/12381/60/<index>/0when creating a new private key from the seed.  The path followsEIP-2334.", "JSON schema": "The walletstore follows a similar format to that of the keystore described inEIP-2335.", "Rationale": "A standard for walletstores, similar to that for keystores, provides a higher level of compatibility between wallets and allows for simpler wallet and key interchange between them.", "Test Cases": "Password'testpassword'Seed0x147addc7ec981eb2715a22603813271cce540e0b7f577126011eb06249d9227c", "Test Vector": "Password'testpassword'Seed0x147addc7ec981eb2715a22603813271cce540e0b7f577126011eb06249d9227c", "Implementation": "A Go implementation of the hierarchical deterministic wallet can be found athttps://github.com/wealdtech/go-eth2-wallet-hd.", "Security Considerations": "The seed stored in thecryptosection of the wallet can be used to generate any key along the derived path.  As such, the security of all keys generated by HD wallets is reduced to the security of the passphrase and strength of the encryption used to protect the seed, regardless of the security of the passphrase and strength of the encryption used to protect individual keystores.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2390, "url": "https://eips.ethereum.org/EIPS/eip-2390", "title": "Geo-ENS", "authors": ["James Choncholas\u00a0(", "@james-choncholas", ")"], "sections": {"ERC-2390: Geo-ENS": "GeoENS brings geographic split horizon capabilities to ENS. It\u2019s GeoDNS for ENS!", "": "GeoENS brings geographic split horizon capabilities to ENS. It\u2019s GeoDNS for ENS!", "Simple Summary": "GeoENS brings geographic split horizon capabilities to ENS. It\u2019s GeoDNS for ENS!", "Abstract": "This EIP specifies an ENS resolver interface for geographically split horizon DNS.\nGeographic split horizon DNS returns resource records that are specific to an end\nuser\u2019s location.\nThis technique is commonly used by CDNs to direct traffic to content caches nearest users.\nGeographic split horizon resolution is primarily geared towards ENS\nresolvers storing DNS resource recordsEIP-1185, although the technique could be\nused on other interfaces like IPFS content hash storageEIP-1062.", "Motivation": "There are many use cases for traditional GeoDNS systems, like Amazon\u2019s Route53,\nin the centralized web.\nThese use cases include proximity-based load balancing and serving content\nspecific to the geographic location of the query.\nUnfortunately the ENS specification does not provide a mechanism for\ngeo-specific resolution.\nENS can respond to queries with IP addresses (as described inEIP-1185)\nhowever there is no way to respond to geo-specific queries.\nThis EIP proposes a standard to give the ENS system geo-proximal awareness\nto serve a similar purpose as GeoDNS.", "Specification": "This EIP proposes a new interface to ENS resolvers such that geo-spacial information\ncan be recorded and retrieved from the blockchain.\nThe interface changes are described below for \u201caddress resolvers\u201d described in EIP137\nhowever the idea applies to any record described in EIP1185 and EIP1062, namely DNS\nResolvers, Text Resolvers, ABI Resolvers, etc.", "What is a geohash?": "AGeohashis an interleaving of latitude and longitude bits, whose\nlength determines it\u2019s precision.\nGeohashes are typically encoded in base 32 characters.", "function setGeoAddr(bytes32 node, string calldata geohash, address addr) external authorised(node)": "Sets a resource (contract address, IP, ABI, TEXT, etc.) by node and geohash.\nGeohashes must be unique per address and are exactly 8 characters long.\nThis leads to an accuracy of +-20 meters.\nWrite default initialized resource value,address(0), to remove a resource from the resolver.", "function geoAddr(bytes32 node, string calldata geohash) external view returns (address[] memory ret)": "Query the resolver contract for a specific node and location.\nAll resources (contract addresses, IP addresses, ABIs, TEXT records, etc.) matching\nthe node and prefix geohash provided are returned.\nThis permits querying by exact geohash of 8 characters to return the content at that location,\nor querying by geographic bounding box described by a geohash of less than 8 character precision.", "Rationale": "The proposed implementation uses a sparseQuadtreetrie as an index for\nresource records as it has low storage overhead and good search performance.\nThe leaf nodes of the tree store resource records while non-leaves represent one geohash character.\nEach node in the tree at depth d corresponds to a geohash of precision d.\nThe tree has depth 8 because the maximum precision of a geohash is 8 characters.\nThe tree has fanout 32 because the radix of a geohash character is 32.\nThe path to get to a leaf node always has depth 8 and the leaf contains the content (like IP address)\nof the geohash represented by the path to the leaf.\nThe tree is sparse as 71% of the Earth\u2019s surface is covered by water.\nThe tree facilitates common traversal algorithms (DFS, BFS) to return\nlists of resource records within a geographic bounding box.", "Backwards Compatibility": "This EIP does not introduce issues with backwards compatibility.", "Test Cases": "See https://github.com/james-choncholas/resolvers/blob/master/test/TestPublicResolver.js", "Implementation": "This address resolver, written in Solidity, implements the specifications outlined above.\nThe same idea presented here can be applied to other resolver interfaces as specified in EIP137.\nNote that geohashes are passed and stored using 64 bit unsigned integers.\nUsing integers instead of strings for geohashes is more performant, especially in thegeomapmapping.\nFor comparison purposes, see https://github.com/james-choncholas/geoens/tree/master/contracts/StringOwnedGeoENSResolver.sol for the inefficient string implementation.", "Security Considerations": "This contract has similar functionality to ENS Resolvers - refer there for security considerations.\nAdditionally, this contract has a dimension of data privacy.\nUsers query via the geoAddr function specifying a geohash of less than 8 characters\nwhich defines the query region.\nUsers who run light clients leak the query region to their connected full-nodes.\nUsers who rely on nodes run by third parties (like Infura) will also leak\nthe query region.\nUsers who run their own full node or have access to a trusted full node do\nnot leak any location data.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2400, "url": "https://eips.ethereum.org/EIPS/eip-2400", "title": "Transaction Receipt URI", "authors": ["Ricardo Guilherme Schmidt\u00a0(", "@3esmit", ")", "Eric Dvorsak\u00a0(", "@yenda", ")"], "sections": {"ERC-2400: Transaction Receipt URI": "A transaction hash is not very meaningful on its own, because it looks just like any other hash, and it might lack important information for reading a transaction.", "URI format for submitted transactions with complete information for transaction decoding": "A transaction hash is not very meaningful on its own, because it looks just like any other hash, and it might lack important information for reading a transaction.", "Abstract": "A transaction hash is not very meaningful on its own, because it looks just like any other hash, and it might lack important information for reading a transaction.", "Motivation": "Interoperability between ethereum clients, allowing different systems to agree on a standard way of representing submitted transactions hashes, optionally with necessary information for decoding transaction details.", "Use-cases": "Transaction Receipt URIs embedded in QR-codes, hyperlinks in web-pages, emails or chat messages provide for robust cross-application signaling between very loosely coupled applications. A standardized URI format allows for instant invocation of the user\u2019s preferred transaction explorer application. Such as:", "Specification": "Transaction receipt URLs contain \u201cethereum\u201d in their schema (protocol) part and are constructed as follows:", "Syntax": "Transaction receipt URLs contain \u201cethereum\u201d in their schema (protocol) part and are constructed as follows:", "Semantics": "transaction_hashis mandatory. The hash must be looked up in the correspondingchain_idtransaction history, if not found it should be looked into the pending transaction queue and rechecked until is found. If not found anequivalent error as \u201ctransaction not found error\u201d should be shown instead of the transaction. When the transaction is pending, it should keep checking until the transaction is included in a block and becomes \u201cunrevertable\u201d (usually 12 blocks after transaction is included).", "Rationale": "The goal of this standard envolves only the transport of submitted transactions, and therefore transaction data must be loaded from blockchain or pending transaction queue, which also serves as a validation of the transaction existence.", "Backwards Compatibility": "Future upgrades that are partially or fully incompatible with this proposal must use a prefix other thantx-that is separated by a dash (-) character from whatever follows it.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2470, "url": "https://eips.ethereum.org/EIPS/eip-2470", "title": "Singleton Factory", "authors": ["Ricardo Guilherme Schmidt\u00a0(", "@3esmit", ")"], "sections": {"ERC-2470: Singleton Factory": "Some DApps needs one, and only one, instance of an contract, which have the same address on any chain.", "": "Some DApps needs one, and only one, instance of an contract, which have the same address on any chain.", "Simple Summary": "Some DApps needs one, and only one, instance of an contract, which have the same address on any chain.", "Abstract": "Some contracts are designed to be Singletons which have the same address no matter what chain they are, which means that should exist one instance for all, such asEIP-1820andEIP-2429. These contracts are usually deployed using a method known asNick\u2019s method, so anyone can deploy those contracts on any chain and they have a deterministic address.\nThis standard proposes the creation of a CREATE2 factory using this method, so other projects requiring this feature can use this factory in any chain with the same setup, even in development chains.", "Motivation": "Code reuse, using the factory becomes easier to deploy singletons.", "Specification": "Below is the raw transaction which MUST be used to deploy the smart contract on any chain.", "[ERC-2470] Singleton Factory": "Below is the raw transaction which MUST be used to deploy the smart contract on any chain.", "Deployment Transaction": "Below is the raw transaction which MUST be used to deploy the smart contract on any chain.", "Deployment Method": "This contract is going to be deployed using the keyless deployment method\u2014also known asNick\u2019s method\u2014which relies on a single-use address.\n(SeeNick\u2019s articlefor more details). This method works as follows:", "Single-use Factory Deployment Account": "", "Factory Contract Address": "", "ABI for SingletonFactory:": "SingletonFactory does not allow sending value on create2, this was done to prevent different results on the created object. \nSingletonFactory allows user defined salt to facilitate the creation of vanity addresses for other projects. If vanity address is not necessary, saltbytes(0)should be used.\nContracts that are constructed by the SingletonFactory MUST not usemsg.senderin their constructor, all variables must came through initialization data. This is intentional, as if allowing a callback after creation to aid initialization state would lead to contracts with same address (but different chains) to have the same address but different initial state.\nThe resulting address can be calculated in chain by any contract using this formula:address(keccak256(bytes1(0xff), 0xce0042B868300000d44A59004Da54A005ffdcf9f, _salt, keccak256(_code)) << 96)or in javascript using https://github.com/ethereumjs/ethereumjs-util/blob/master/docs/README.md#const-generateaddress2.", "Rationale": "SingletonFactory does not allow sending value on create2, this was done to prevent different results on the created object. \nSingletonFactory allows user defined salt to facilitate the creation of vanity addresses for other projects. If vanity address is not necessary, saltbytes(0)should be used.\nContracts that are constructed by the SingletonFactory MUST not usemsg.senderin their constructor, all variables must came through initialization data. This is intentional, as if allowing a callback after creation to aid initialization state would lead to contracts with same address (but different chains) to have the same address but different initial state.\nThe resulting address can be calculated in chain by any contract using this formula:address(keccak256(bytes1(0xff), 0xce0042B868300000d44A59004Da54A005ffdcf9f, _salt, keccak256(_code)) << 96)or in javascript using https://github.com/ethereumjs/ethereumjs-util/blob/master/docs/README.md#const-generateaddress2.", "Backwards Compatibility": "Does not apply as there are no past versions of Singleton Factory being used.", "Test Cases": "TBD", "Implementation": "https://github.com/3esmit/ERC2470", "Security Considerations": "Some contracts can possibly not support being deployed on any chain, or require a different address per chain, that can be safely done by using comparison inEIP-1344in constructor.\nAccount contracts are singletons in the point of view of each user, when wallets want to signal what chain id is intended,EIP-1191should be used. \nContracts deployed on factory must not usemsg.senderin constructor, instead use constructor parameters, otherwise the factory would end up being the controller/only owner of those.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2477, "url": "https://eips.ethereum.org/EIPS/eip-2477", "title": "Token Metadata Integrity", "authors": ["Kristijan Sedlak\u00a0(", "@xpepermint", ")", "William Entriken\u00a0<", "github.com@phor.net", ">", "Witek Radomski\u00a0<", "witek@enjin.io", ">"], "sections": {"ERC-2477: Token Metadata Integrity": "This specification defines a mechanism by which clients may verify that a fetched token metadata document has been delivered without unexpected manipulation.", "": "This specification defines a mechanism by which clients may verify that a fetched token metadata document has been delivered without unexpected manipulation.", "Simple Summary": "This specification defines a mechanism by which clients may verify that a fetched token metadata document has been delivered without unexpected manipulation.", "Abstract": "An interfaceERC2477with two functionstokenURIIntegrityandtokenURISchemaIntegrityare specified for smart contracts and a narrative is provided to explain how this improves the integrity of the token metadata documents.", "Motivation": "Tokens are being used in many applications to represent, trace and provide access to assets off-chain. These assets include in-game digital items in mobile apps, luxury watches and products in our global supply chain, among many other creative uses.", "Design": "Approach A:A token contract may reference metadata by using its URL. This provides no integrity protection because  the referenced metadata and/or schema could change at any time if the hosted content is mutable. This is the world before EIP-2477:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Smart contracts": "Smart contracts implementing the ERC-2477 standard MUST implement theERC2477interface.", "Metadata": "A metadata document MAY conform to this schema to provide referential integrity to its schema document.", "Clients": "A client implementing the ERC-2477 standard MUST support at least thesha256hash algorithm and MAY support other algorithms.", "Caveats": "Function and parameter naming", "Rationale": "Function and parameter naming", "Backwards Compatibility": "Both ERC-721 and ERC-1155 provide compatible token metadata specifications that use URIs and JSON schemas. The ERC-2477 standard is compatible with both, and all specifications are additive. Therefore, there are no backward compatibility regressions.", "Test Cases": "Following is a token metadata document which is simultaneously compatible with ERC-721, ERC-1155 and ERC-2477 standards.", "Implementation": "0xcert Framework supports ERC-2477.", "Reference": "Normative standard references", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2494, "url": "https://eips.ethereum.org/EIPS/eip-2494", "title": "Baby Jubjub Elliptic Curve", "authors": ["Barry WhiteHat\u00a0(", "@barryWhiteHat", ")", "Marta Bell\u00e9s\u00a0(", "@bellesmarta", ")", "Jordi Baylina\u00a0(", "@jbaylina", ")"], "sections": {"ERC-2494: Baby Jubjub Elliptic Curve": "This proposal defines Baby Jubjub, an elliptic curve designed to work inside zk-SNARK circuits in Ethereum.", "": "This proposal defines Baby Jubjub, an elliptic curve designed to work inside zk-SNARK circuits in Ethereum.", "Simple Summary": "This proposal defines Baby Jubjub, an elliptic curve designed to work inside zk-SNARK circuits in Ethereum.", "Abstract": "Two of the main issues behind why blockchain technology is not broadly used by individuals and industry are scalability and privacy guarantees. With a set of cryptographic tools called zero-knowledge proofs (ZKP) it is possible to address both of these problems. More specifically, the most suitable protocols for blockchain are called zk-SNARKs (zero-knowledge Succinct Non-interactive ARguments of Knowledge), as they are non-interactive, have succinct proof size and sublinear verification time. These types of protocols allow proving generic computational statements that can be modelled with arithmetic circuits defined over a finite field (also called zk-SNARK circuits).", "Motivation": "Azero knowledge proof(ZKP) is a protocol that enables one party, the prover, to convince another, the verifier, that a statement is true without revealing any information beyond the veracity of the statement.Non-Interactive ZKPs(NIZK) are a particular type of zero-knowledge proofs in which the prover can generate the proof without interaction with the verifier. NIZK protocols are very suitable for Ethereum applications, because they allow a smart contract to act as a verifier. This way, anyone can generate a proof and send it as part of a transaction to the smart contract, which can perform some action depending on whether the proof is valid or not. In this context, the most preferable NIZK arezk-SNARK(Zero-knowledge Succinct Non Interactive ARgument of Knowledge), a set of non-interactive zero-knowledge protocols that have succinct proof size and sublinear verification time. The importance of these protocols is double: on the one hand, they help improve privacy guarantees, and on the other, they are a possible solution to scalability issues (e.g. seezk-Rollupproject).", "Specification": "LetF_rbe the prime finite field withrelements, where", "Definitions": "LetF_rbe the prime finite field withrelements, where", "Order": "Baby Jubjub has order", "Generator Point": "The pointG = (x,y)with coordinates", "Base Point": "The pointB = (x,y)with coordinates", "Arithmetic": "LetP1 = (x1, y1)andP2 = (x2, y2)be two arbitrary points of Baby Jubjub. ThenP1 + P2 = (x3, y3)is calculated in the following way:", "Rationale": "The search for Baby Jubjub was motivated by the need for an elliptic curve that allows the implementation of elliptic-curve cryptography inF_r-arithmetic circuits. The curve choice was based on three main factors: type of curve, generation process and security criteria. This section describes how these factors were addressed.", "Backwards Compatibility": "Baby Jubjub is a twisted Edwards elliptic curve birational to different curves. So far, the curve has mainly been used in its original form, in Montomgery form, and in another (different representation) twisted Edwards form \u2013 which we call the reduced twisted Edwards form.", "Forms of the Curve": "All generators and base points are written in the form (x,y).", "Conversion of Points": "Following formulas allow to convert points from one form of the curve to another. We will denote the coordinates", "Security Considerations": "This section specifies the safety checks done on Baby Jubjub. The choices of security parameters are based onSafeCurves criteria, and supporting evidence that Baby Jubjub satisfies the following requisites can be foundhere.", "Test Cases": "Test 1 (Addition)", "Implementation": "Arithmetic of Baby Jubjub and some cryptographic primitives using the curve have already been implemented in different languages. Here are a few such implementations:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2520, "url": "https://eips.ethereum.org/EIPS/eip-2520", "title": "Multiple contenthash records for ENS", "authors": ["Filip \u0160tamcar\u00a0(", "@filips123", ")"], "sections": {"ERC-2520: Multiple contenthash records for ENS": "ENS support for multiplecontenthashrecords on a single ENS name.", "": "ENS support for multiplecontenthashrecords on a single ENS name.", "Simple Summary": "ENS support for multiplecontenthashrecords on a single ENS name.", "Motivation": "Many applications are resolving ENS names to content hosted on distributed systems. To do this, they usecontenthashrecord from ENS domain to know how to resolve names and which distributed system should be used.", "Specification": "Setting and getting functionsMUSThave the same public interface as specified in EIP 1577. Additionally, theyMUSTalso have new public interfaces introduced by this EIP:", "Rationale": "The proposed implementation was chosen because it is simple to implement and supports all important requested features. However, it doesn\u2019t support multiple records for the same type and priority order, as they don\u2019t give much advantage and are harder to implement properly.", "Backwards Compatibility": "The EIP is backwards-compatible with EIP 1577, the only differences are additional overloaded methods. Old applications will still be able to function correctly, as they will receive the defaultcontenthashrecord.", "Implementation": "TBD", "Security Considerations": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2525, "url": "https://eips.ethereum.org/EIPS/eip-2525", "title": "ENSLogin", "authors": ["Hadrien Croubois\u00a0(", "@amxx", ")"], "sections": {"ERC-2525: ENSLogin": "This presents a method to improve a universal method of login to the ethereum blockchain, leveraging the metadata storage provided by the ENS. We consider a user to be logged in when we have anEIP-1193provider that can sign transaction and messages on his behalf. This method is inspired byAlex Van de Sande\u2019s workandWeb3Connect. In the future, the approach described here-after should be extended to work with any blockchain.", "": "This presents a method to improve a universal method of login to the ethereum blockchain, leveraging the metadata storage provided by the ENS. We consider a user to be logged in when we have anEIP-1193provider that can sign transaction and messages on his behalf. This method is inspired byAlex Van de Sande\u2019s workandWeb3Connect. In the future, the approach described here-after should be extended to work with any blockchain.", "1. Abstract": "This presents a method to improve a universal method of login to the ethereum blockchain, leveraging the metadata storage provided by the ENS. We consider a user to be logged in when we have anEIP-1193provider that can sign transaction and messages on his behalf. This method is inspired byAlex Van de Sande\u2019s workandWeb3Connect. In the future, the approach described here-after should be extended to work with any blockchain.", "2. Motivation": "Multiple wallet solutions can be used to interact with the Ethereum blockchain. Some (metamask, gnosis, \u2026) are compatible as they inject a standardized wallet object in the browser without requiring any effort from the Dapp developers, but they require an effort on the user side (user has to install the plugin). Other solutions (Portis, Authereum, Torus, Universal Login, \u2026) propose a more seamless flow to non-crypto-aware users but require an integration effort from the Dapp developers. Hardware wallet (ledger, trezor, keepkey, \u2026) also require integration effort from the Dapp developers.", "3. Description": "The ENSLogin works as follow:", "3.1. Overview": "The ENSLogin works as follow:", "3.2. Details": "TODO(maybe move that part to section 6.1):\nAddSLIP 44compliant blockchain description to the config for better multichain support. This will require a additional fieldENS networkto know which ethereum network to use for resolution when the targeted blockchain/network is not ethereum (could also be used for cross chain resolution on ethereum, for example xDAI login with metadata stored on mainnet)", "3.3. Decentralization": "Unlike solution like Web3Connect, ENSLogin proposes a modular approach that is decentralized by nature.\nThe code needed for a Dapp to use ENSLogin (hereafter referred to as the SDK) only contains lookup mechanism for the ethereum blockchain and the data storages solutions. The solution is limited by the protocols (https / ipfs / \u2026) that the SDK can interact with. Beyond that, any wallet-provider that follows the expected structure and that is available through one of the supported protocol is automatically compatible with all the Dapps proposing ENSLogin support. There is no need to go through a centralized approval process. Furthermore, deployed SDK do not need to be upgraded to benefit from the latest wallet updates. The only permissioned part of the protocol is in the ENS control of the users over the metadata that describes their wallet-provider implementation. Users could also rely on the fallback mechanism to have the wallet-provider update it for them.", "3.4. Incentives": "We believe ENSLogin\u2019s biggest strength is the fact that it aligns the incentives of Dapp developers and wallet-providers to follow this standard.", "3.5. Drawbacks": "While ENSLogin allows dapps to support any wallet for logging in, dapps still must choose which wallets they suggest to users for registration. This can be done through a component like Web3Connect or BlockNative\u2019s", "4. Prototype": "TODO", "5. Support by the community": "*use the metamask module", "5.1. Adoption": "*use the metamask module", "6. Possible evolutions": "TODO", "6.1. Multichain support": "TODO", "7. FAQ": "ENSLogin only has access to what is recorded on the ENS, namely your address and the provider you use. Private key management is a is handled by the provider and is outside ENSLogin\u2019s scope. Some might store the key on disk. Other might rely on custodial keys stored on a remote (hopefully secure) server. Others might use a dedicated hardware component to handle signature and never directly have access to the private key.", "7.1. Can anyone connect with my login? Where are my private keys stored?": "ENSLogin only has access to what is recorded on the ENS, namely your address and the provider you use. Private key management is a is handled by the provider and is outside ENSLogin\u2019s scope. Some might store the key on disk. Other might rely on custodial keys stored on a remote (hopefully secure) server. Others might use a dedicated hardware component to handle signature and never directly have access to the private key.", "7.2. How do I get an ENS Login?": "TODO(this might need a separate ERC)", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2544, "url": "https://eips.ethereum.org/EIPS/eip-2544", "title": "ENS Wildcard Resolution", "authors": ["Nick Johnson\u00a0(", "@arachnid", ")", "0age\u00a0(", "@0age", ")"], "sections": {"ERC-2544: ENS Wildcard Resolution": "The Ethereum Name Service Specification (EIP-137) establishes a two-step name resolution process. First, an ENS client performs the namehash algorithm on the name to determine the associated \u201cnode\u201d, and supplies that node to the ENS Registry contract to determine the resolver. Then, if a resolver has been set on the Registry, the client supplies that same node to the resolver contract, which will return the associated address or other record.", "Adds support for \"wildcard\" resolution of subdomains in ENS.": "The Ethereum Name Service Specification (EIP-137) establishes a two-step name resolution process. First, an ENS client performs the namehash algorithm on the name to determine the associated \u201cnode\u201d, and supplies that node to the ENS Registry contract to determine the resolver. Then, if a resolver has been set on the Registry, the client supplies that same node to the resolver contract, which will return the associated address or other record.", "Abstract": "The Ethereum Name Service Specification (EIP-137) establishes a two-step name resolution process. First, an ENS client performs the namehash algorithm on the name to determine the associated \u201cnode\u201d, and supplies that node to the ENS Registry contract to determine the resolver. Then, if a resolver has been set on the Registry, the client supplies that same node to the resolver contract, which will return the associated address or other record.", "Motivation": "Many applications such as wallet providers, exchanges, and dapps have expressed a desire to issue ENS names for their users via custom subdomains on a shared parent domain. However, the cost of doing so is currently prohibitive for large user bases, as a distinct record must be set on the ENS Registry for each subdomain.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Pseudocode": "The proposed implementation supports wildcard resolution in a manner that minimizes the impact to existing systems. It also reuses existing algorithms and procedures to the greatest possible extent, thereby easing the burden placed on authors and maintainers of various ENS clients.", "Rationale": "The proposed implementation supports wildcard resolution in a manner that minimizes the impact to existing systems. It also reuses existing algorithms and procedures to the greatest possible extent, thereby easing the burden placed on authors and maintainers of various ENS clients.", "Backwards Compatibility": "Existing ENS clients that are compliant with EIP-137 will fail to resolve wildcard records and refuse to interact with them, while those compliant with EIP-2544 will continue to correctly resolve, or reject, existing ENS records. Resolvers wishing to implement the newresolvefunction for non-wildcard use-cases (eg, where the resolver is set directly on the name being resolved) should consider what to return to legacy clients that call the individual resolution functions for maximum compatibility.", "Security Considerations": "While compliant ENS clients will continue to refuse to resolve records without a resolver, there is still the risk that an improperly-configured client will refer to an incorrect resolver, or will not reject interactions with the null address when a resolver cannot be located.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2569, "url": "https://eips.ethereum.org/EIPS/eip-2569", "title": "Saving and Displaying Image Onchain for Universal Tokens", "authors": ["Hua Zhang\u00a0(", "@dgczhh", ")", "Yuefei Tan\u00a0(", "@whtyfhas", ")", "Derek Zhou\u00a0(", "@zhous", ")", "Ran Xing\u00a0(", "@lemontreeran", ")"], "sections": {"ERC-2569: Saving and Displaying Image Onchain for Universal Tokens": "This set of interfaces allow a smart contract to save an SVG image in Ethereum and to retrieve an SVG image from Ethereum for fungible tokens, non-fungible tokens and tokens based on standards that will be developed in the future.", "A set of interfaces to save an SVG image in Ethereum, and to retrieve the image file from Ethereum for universal tokens.": "This set of interfaces allow a smart contract to save an SVG image in Ethereum and to retrieve an SVG image from Ethereum for fungible tokens, non-fungible tokens and tokens based on standards that will be developed in the future.", "Abstract": "This set of interfaces allow a smart contract to save an SVG image in Ethereum and to retrieve an SVG image from Ethereum for fungible tokens, non-fungible tokens and tokens based on standards that will be developed in the future.", "Motivation": "The ERC-721 token standard is a popular standard to define a non-fungible token in Ethereum. This standard is widely used to specify a crypto gift, crypto medal, crypto collectible etc. The most famous use case is thecryptokitty.", "Specification": "An EIP-2569 compatible contract MUST have a method with the signature getTokenImageSvg(uint256) view returns (string memory) and a method with the signature setTokenImageSvg(uint256 tokenId, string memory imagesvg) internal.", "Rationale": "After Bitcoin was created people have found ways to keep information permanent and tamper-resistant by encoding text messages they want to preserve permanently and tamper-resistantly in blockchain transactions. However existing applications only do this for text information and there are no solutions to keep an image permanent and tamper-resistant.", "Backwards Compatibility": "There are no backward compatibility issues.", "Reference Implementation": "tokenId: a token index in an ERC-721 token or a token type/index in an ERC-1155 token. It is a uint256 variable.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2615, "url": "https://eips.ethereum.org/EIPS/eip-2615", "title": "Non-Fungible Token with mortgage and rental functions", "authors": ["Kohshi Shiba\u00a0<", "kohshi.shiba@gmail.com", ">"], "sections": {"ERC-2615: Non-Fungible Token with mortgage and rental functions": "This standard proposes an extension to ERC721 Non-Fungible Tokens (NFTs) to support rental and mortgage functions. These functions are necessary for NFTs to emulate real property, just like those in the real world.", "": "This standard proposes an extension to ERC721 Non-Fungible Tokens (NFTs) to support rental and mortgage functions. These functions are necessary for NFTs to emulate real property, just like those in the real world.", "Simple Summary": "This standard proposes an extension to ERC721 Non-Fungible Tokens (NFTs) to support rental and mortgage functions. These functions are necessary for NFTs to emulate real property, just like those in the real world.", "Abstract": "This standard is an extension of ERC721. It proposes additional roles, the right of tenants to enable rentals, and the right of lien.", "Motivation": "It has been challenging to implement rental and mortgage functions with the ERC721 standard because it only has one role defined (which is the Owner).", "Specification": "This standard proposes three user roles: theLien Holder, theOwner, and theUser. Their rights are as follows:", "ERC-2615 Interface": "Extensions here are provided to help developers build with this standard.", "ERC-2615 Receiver": "Extensions here are provided to help developers build with this standard.", "ERC-2615 Extensions": "Extensions here are provided to help developers build with this standard.", "How rentals and mortgages work": "This standard does not deal with token or value transfer. Other logic (outside the scope of this standard) must be used to orchestrate these transfers and to implement validation of payment.", "Mortgage functions": "The following diagram demonstrates the mortgaging functionality.", "Rental functions": "The following diagram demonstrates the rental functionality.", "Rationale": "There have been some attempts to achieve rentals or mortgages with ERC721. However, as I noted before, it has been challenging to achieve. I will explain the reasons and advantages of this standard below.", "No security lockup for rentals": "To achieve trustless rental of NFTs with ERC721, it has been necessary to deposit funds as security. This is required to prevent malicious activity from tenants, as it is impossible to take back ownership once it is transferred.", "No ownership escrow when taking out a mortgage": "In order to take out a mortgage on NFTs, it has been necessary to transfer the NFTs to a contract as collateral. This is required to prevent the potential default risk of the mortgage.", "Easy integration": "Because of the above reasons, a great deal of effort is required to implement rental and mortgage functions with ERC721. Adopting this standard is a much easier way to integrate rental and mortgage functionality.", "No money/token transactions within tokens": "A NFT itself does not handle lending or rental functions directly. This standard is open-source, and there is no platform lockup. Developers can integrate it without having to worry about those risks.", "Backward compatibility": "As mentioned in the specifications section, this standard can be fully ERC721 compatible by adding an extension function set.", "Test Cases": "When running the tests, you need to create a test network with Ganache-CLI:", "Implementation": "Github Repository.", "Security Considerations": "Since the external contract will control lien or tenant rights, flaws within the external contract directly lead to the standard\u2019s unexpected behavior.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2645, "url": "https://eips.ethereum.org/EIPS/eip-2645", "title": "Hierarchical Deterministic Wallet for Layer-2", "authors": ["Tom Brand\u00a0<", "tom@starkware.co", ">", "Louis Guthmann\u00a0<", "louis@starkware.co", ">"], "sections": {"ERC-2645: Hierarchical Deterministic Wallet for Layer-2": "In the context of Computation Integrity Proof (CIP) Layer-2 solutions such as ZK-Rollups, users are required to sign messages on new elliptic curves optimized for those environments. We leverage existing work on Key Derivation (BIP32,BIP39andBIP44) to define an efficient way to securely produce CIP L2s private keys, as well as creating domain separation between Layer-2 applications.", "": "In the context of Computation Integrity Proof (CIP) Layer-2 solutions such as ZK-Rollups, users are required to sign messages on new elliptic curves optimized for those environments. We leverage existing work on Key Derivation (BIP32,BIP39andBIP44) to define an efficient way to securely produce CIP L2s private keys, as well as creating domain separation between Layer-2 applications.", "Simple Summary": "In the context of Computation Integrity Proof (CIP) Layer-2 solutions such as ZK-Rollups, users are required to sign messages on new elliptic curves optimized for those environments. We leverage existing work on Key Derivation (BIP32,BIP39andBIP44) to define an efficient way to securely produce CIP L2s private keys, as well as creating domain separation between Layer-2 applications.", "Abstract": "We provide a Derivation Path allowing a user to derive hierarchical keys for Layer-2 solutions depending on the zk-technology, the application, the user\u2019s Layer-1 address, as well as an efficient grinding method to enforce the private key distribution within the curve domain. The propose Derivation Path is defined as follow", "Motivation": "In the context of Computation Integrity Proof (CIP) Layer-2 solutions such as ZK-Rollups, users are required to sign messages on new elliptic curves optimized for those environments. Extensive work has been done to make it secure on Bitcoin viaBIP32,BIP39andBIP44. These protocols are the standard for wallets in the entire industry, independent of the underlying blockchain. As Layer-2 solutions are taking off, it is a necessary requirement to maintain the same standard and security in this new space.", "Specification": "Starkware keys are derived with the followingBIP43-compatible derivation path, with direct inspiration fromBIP44:", "Rationale": "This EIP specifies two aspects of keys derivation in the context of Hierarchical Wallets:", "Backwards Compatibility": "This standard complies with BIP43.", "Security Considerations": "This EIP has been defined to maintain separation of keys while providing foolproof logic on key derivation.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2680, "url": "https://eips.ethereum.org/EIPS/eip-2680", "title": "Ethereum 2 wallet layout", "authors": ["Jim McDonald\u00a0<", "Jim@mcdee.net", ">"], "sections": {"ERC-2680: Ethereum 2 wallet layout": "A standard layout and naming format for walletstore and keystore for both hierarchical (e.g. filesystem, Amazon S3) and non-hierarchical (key/value) storage systems.", "": "A standard layout and naming format for walletstore and keystore for both hierarchical (e.g. filesystem, Amazon S3) and non-hierarchical (key/value) storage systems.", "Simple Summary": "A standard layout and naming format for walletstore and keystore for both hierarchical (e.g. filesystem, Amazon S3) and non-hierarchical (key/value) storage systems.", "Abstract": "Ethereum wallets have no standards for their layout in persistent storage, making different wallet implementations incompatible.  This defines a standard for the placement of Ethereum walletstores and keystores, making it possible for different software to work with the same wallets and keys.", "Motivation": "A standard layout for wallets and accounts allows interoperability between validators.  This benefits users, as they can move from one validator software to another (and back) without requiring movement of files.  This is important because any movement of files containing keys involves danger of either deleting them or duplicating them, both of which could cause loss of access to funds.", "Specification": "There are four elements for a wallet that need to be addressed.  These are defined below.", "Base location": "The base location is required to be well-known, either pre-defined or defined by the storage system\u2019s connection parameters.", "Wallet container": "The wallet container holds the walletstore and related keystores.", "Walletstore": "The walletstore element contains the walletstore and is held within the wallet container.  It is identified by the wallet\u2019s UUID.  It MUST be a string following the syntactic structure as laid out insection 3 of RFC 4122.", "Keystore": "The keystore element contains the keystore for a given key and is held within the wallet container.  It is identified by the key\u2019s UUID.  It MUST be a string following the syntactic structure as laid out insection 3 of RFC 4122.", "Hierarchical store example": "Hierarchical stores are a common way to store and organize information.  The most common example is the filesystem, but a number of object-based stores such as Amazon S3 also provide hierarchical naming.", "Non-hierarchical store example": "Non-hierarchical stores use a simplified approach where the wallet UUID and key UUIDs are concatenated using the \u2018:\u2019 character.  Using the same example wallet and key UUIDs as above would result in objects with the following keys:", "Protecting against concurrent write access": "TBD", "Iterating over wallets": "In the case of hierarchical stores and iteration-capable non-hierarchical stores iteration over wallets is a matter of iterating over the files in the root container.", "Iterating over accounts": "In the case of hierarchical stores iteration over accounts is a matter of iterating over the files in the wallet container.", "Index format": "The index format is the same for both wallets and accounts, following a standard JSON schema.", "Rationale": "A standard for walletstores, similar to that for keystores, provides a higher level of compatibility between wallets and allows for simpler wallet and key interchange between them.", "Implementation": "A Go implementation of the filesystem layout can be found athttps://github.com/wealdtech/go-eth2-wallet-filesystem.", "Security Considerations": "Locations for wallet stores are defined to be within each user\u2019s personal space, reducing the possibility of accidental exposure of information.  It is, however, still possible for permissions to be set such that this data is world-readable, and applications implementing this EIP should attempt to set, and reset, permissions to ensure that only the relevant user has access to the information.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2746, "url": "https://eips.ethereum.org/EIPS/eip-2746", "title": "Rules Engine Standard", "authors": ["Aaron Kendall\u00a0(", "@jaerith", ")", "Juan Blanco\u00a0(", "@juanfranblanco", ")"], "sections": {"ERC-2746: Rules Engine Standard": "An interface for using a smart contract as a rules engine.  A single deployed contract can register a data domain, create sets of rules that perform actions on that domain, and then invoke a set as an atomic transaction.", "": "An interface for using a smart contract as a rules engine.  A single deployed contract can register a data domain, create sets of rules that perform actions on that domain, and then invoke a set as an atomic transaction.", "Simple Summary": "An interface for using a smart contract as a rules engine.  A single deployed contract can register a data domain, create sets of rules that perform actions on that domain, and then invoke a set as an atomic transaction.", "Abstract": "This standard proposes an interface that will allow the creation of hierarchal sets of rules (i.e., RuleTrees) that can be invoked to evaluate and manipulate a registered data domain.  At the time of this draft, all intentions to insert additional functionality onto the blockchain requires the coding and creation of a newly deployed contract.  However, this standard will allow users to deploy a contract just once, one which will then allow them to create (and invoke) pipelines of commands within that contract.", "Motivation": "At the time of this draft, all development for Ethereum requires writing the code that forms smart contracts and then deploying those contracts to Ethereum.  In order to create a proper contract, many considerations must be taken into account when designing and implementing the code, especially in terms of efficiency (i.e., gas cost) and security.  Even the simplest contracts require a certain amount of vigilance and examination, before and after deployment. These requirements pertain to all cases, even for simple cases of examining a value and/or altering it.", "Specification": "For the clarification of terminology, an Attribute is a registered data point within the data domain, representing data that exists either in the rules engine contract or elsewhere.  A Rule is an predefined action that occurs upon a single data point (i.e., Attribute) in the predefined data domain.  For example, a Rule could check whether the Attribute \u2018TokenAmt\u2019 has a value less than the RHL (i.e., right-hand value) of 10.   A RuleSet is a collection of Rules, where their collection invocation creates a boolean result that determines the navigational flow of execution between RuleSets.  A RuleTree is a collection of RuleSets that are organized within a hierarchy, where RuleSets can contain other RuleSets.", "Considerations": "An argument could be made for interface functions that allow a RuleTree\u2019s owner to include others users as executors of the RuleTree.", "Example": "A company wishes to deploy a contract with data points and functionality that are predefined and/or under the control of an administrator, and it aims to build a no-code client that will allow less-technical users to define actions within the rules engine contract.  In this example, the company wants one of its users to write the rules in a proprietary markup language, in order for the calculation of a VAT to be determined.  For the sake of transparency,these rulesare published onto IPFS, so that they are accessible to auditors and possibly government officials.  The no-code client will then know how to parse the rules from the markup and communicate with the rules engine contract, establishing the RuleTree to be invoked later by the company\u2019s user(s) or off-chain programs.", "Rationale": "The data points are abstracted in order to let the implementation provide the mechanism for retrieving/populating the data.  Data can be held by an internal data structure, another contract\u2019s method, or any number of other options.", "Attributes": "The data points are abstracted in order to let the implementation provide the mechanism for retrieving/populating the data.  Data can be held by an internal data structure, another contract\u2019s method, or any number of other options.", "Events": "The events specified will help the caller of the RuleTree after execution, so that they may ascertain the navigational flow of RuleSet execution within the RuleTree and so that they may understand which RuleSets failed.", "Right-Hand Value": "In the function addRule(), the data type for the right-hand value is \u2018string\u2019 since the rule\u2019s action depends on its type, meaning that the value must be provided in a generic form.  In the case of a Rule that performs numerical operations, the provided value could be transformed into a number when stored in the Rule.", "Implementation": "The Wonka implementation supports this proposed interface and also implements all of the additional considerations mentioned above.", "Security Considerations": "The deployer of the contract should be the owner and administrator, allowing for the addition of Attributes and RuleTrees.  Since a RuleTree is owned by a particular EOA (or contract address), the only accounts that should be able to execute the RuleTree should be its owner or the contract\u2019s owner/administrator.  If Attributes are defined to exist as data within other contracts, the implementation must take into account the possibility that RuleTree owners must have the security to access the data in those contracts.", "References": "Standards", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2767, "url": "https://eips.ethereum.org/EIPS/eip-2767", "title": "Contract Ownership Governance", "authors": ["Soham Zemse\u00a0(", "@zemse", ")", "Nick Mudge\u00a0(", "@mudgen", ")"], "sections": {"ERC-2767: Contract Ownership Governance": "A standard for Governance contracts that holds the administrative ownership of other smart contracts with voting power distributed asERC-20tokens.", "": "A standard for Governance contracts that holds the administrative ownership of other smart contracts with voting power distributed asERC-20tokens.", "Simple Summary": "A standard for Governance contracts that holds the administrative ownership of other smart contracts with voting power distributed asERC-20tokens.", "Abstract": "The following standard defines the implementation of a standard API for a Governance smart contract based onERC-20. ExistingERC-173compatible contracts can upgrade from private key wallet ownership to a Governance smart contract. Adhering to a standard API enables general tools to populate governance information of various projects, thus increasing transparency.", "Motivation": "Traditionally, many contracts that require that they be owned or controlled in some way useERC-173which standardized the use of ownership in the smart contracts. For example to withdraw funds or perform administrative actions.", "Specification": "A Governance contract that is compliant withERC-2767shall implement the following interfaces:", "ERC-20Governance Token": "AnERC-2767Governance Contract should reference an address throughtoken()that implementsERC-20interface.token()is allowed to return self address (address(this)), ifERC-20functionalities are implemented in the same contract (one can consider checking out Diamond StandardERC-2535to optimise contract size).", "ERC-165Interface Identification": "AnERC-2767Governance Contract should also implementERC-165. This helps general tools to identify whether a contract is aERC-2767Governance contract.", "Rationale": "The goals of this EIP have been the following:", "Backwards Compatibility": "Smart contracts that areERC-173compliant can transfer their ownership to a Governance contract. This enables such contracts to become compatible withERC-2767Governance.", "Implementation": "The reference implementations are available in thisrepository. Publicly audited implementations will be included in future.", "Security Considerations": "Implementers are free to choose between On-chain and Off-chain consensus. Exact specification is out of scope for this standard (open for other EIPs to standardize). However, this section mentions points that implementers can consider.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2770, "url": "https://eips.ethereum.org/EIPS/eip-2770", "title": "Meta-Transactions Forwarder Contract", "authors": ["Alex Forshtat\u00a0(", "@forshtat", ")", "Dror Tirosh\u00a0(", "@drortirosh", ")"], "sections": {"ERC-2770: Meta-Transactions Forwarder Contract": "Standardized contract interface for extensible meta-transaction forwarding.", "": "Standardized contract interface for extensible meta-transaction forwarding.", "Simple Summary": "Standardized contract interface for extensible meta-transaction forwarding.", "Abstract": "This proposal defines an external API of an extensible Forwarder whose responsibility is to validate transaction\nsignatures on-chain and expose the signer to the destination contract, that is expected to accommodate all use-cases.\nThe ERC-712 structure of the forwarding request can be extended allowing wallets to display readable data even\nfor types not known during the Forwarder contract deployment.", "Motivation": "There is a growing interest in making it possible for Ethereum contracts to\naccept calls from externally owned accounts that do not have ETH to pay for\ngas.", "Specification": "The Forwarder contract operates by accepting a signed typed data together with it\u2019s ERC-712 signature,\nperforming signature verification of incoming data, appending the signer address to the data field and\nperforming a call to the target.", "Forwarder data type registration": "Request struct MUST contain the following fields in this exact order:", "Signature verification": "The following method performs an ERC-712 signature check on a request:", "Command execution": "In order for the Forwarder to perform an operation, the following method is to be called:", "ERC-712 and \u2018suffixData\u2019 parameter": "suffixDatafield must provide a valid \u2018tail\u2019 of an ERC-712 typed data.\nFor instance, in order to sign on theExtendedRequeststruct, the data will be a concatenation of the following chunks:", "Accepting Forwarded calls": "In order to support calls performed via the Forwarder, the Recipient contract must read the signer address from the\nlast 20 bytes ofmsg.data, as described in ERC-2771.", "Rationale": "Further relying onmsg.senderto authenticate end users by their externally-owned accounts is taking the Ethereum dapp ecosystem to a dead end.", "Security Considerations": "All contracts introducing support for the Forwarded requests thereby authorize this contract to perform any operation under any account.\nIt is critical that this contract has no vulnerabilities or centralization issues.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2848, "url": "https://eips.ethereum.org/EIPS/eip-2848", "title": "My Own Messages (MOM)", "authors": ["Giuseppe Bertone\u00a0(", "@Neurone", ")"], "sections": {"ERC-2848: My Own Messages (MOM)": "My Own Messages (MOM) is a standard to create your very own public, always updated, unstoppable, verifiable, message board.", "": "My Own Messages (MOM) is a standard to create your very own public, always updated, unstoppable, verifiable, message board.", "Simple Summary": "My Own Messages (MOM) is a standard to create your very own public, always updated, unstoppable, verifiable, message board.", "Abstract": "My Own Messages (MOM) use Ethereum as a certification layer for commands and multihash of your messages. It don\u2019t use smart contracts but simple self-send transactions with specific payload attached.", "Motivation": "As adeveloperorpool\u2019s owner, I\u2019d like to send messages to my users in a decentralized way. They must be able to easily verify my role in the smart contract context (owner, user, and so on) and they must be able to do it without relying on external, insecure and hackable social media sites (Facebook, Twitter, you name it). Also, I\u2019d like to read messages from my userbase, in the same secure and verifiable manner.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d,  \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described inRFC 2119when, and only when, they appear in all capitals as shown here.", "MOM transactions": "ClientsMUSTassume thatinvalid MOM transactions don\u2019t exist. If a transaction does not strictly follow the MOM standard, clientsMUSTignore it and theyMUST NOTconsider it a MOM transaction at all.", "Rationale": "Ethereum isaccount based, so it\u2019s good to be identified as a single source of information.", "Why not using a smart contract?": "MOM wants to be useful, easy to implement and read, error proof, fast and cheap, but:", "Why not storing messages directly on-chain?": "There\u2019s no benefit to storestaticmessages on-chain, if they are not related to some smart contract\u2019s state or if they don\u2019t represent exchange of value. The cost of storing data on-chain is also very high.", "Why not storing op codes inside the message?": "While cost effectiveness is a very important feature in a blockchain related standard, there\u2019s also a compromise to reach with usability and usefulness.", "Why multihash?": "Multihashis flexible, future-proof and there are already tons of library supporting it. Ethereum must be easily integrable with many different platforms and architectures, so MOM standard follows that idea.", "Backwards Compatibility": "You can already find few transactions over the Ethereum network that use a pattern similar to this EIP. Sometimes it\u2019s done to invalidate a previous transaction in memory pool, using the same nonce but with more gas price, so that transaction is mined cancelling the previous one still in the memory pool. This kind of transactions can be easily ignored if created before the approval of this EIP or just checking if the payload follows the correct syntax.", "Test Cases": "A MOM-compliant client can be found and tested onGitHub.", "Implementation": "You can use an already working MOM JavaScript package onGitHub Packagesornpmjs. The package is already used by the MOM client above, and you can use it in your \u00d0Apps too with:", "Security Considerations": "MOM is very simple and it has no real security concerns by itself. The standard already considers valid only transactions with0value and wherefromandtoaddresses are equals.", "Parsing commands": "MOM standard involves parsing payloads generated by potentially malicious clients, so attention must be made to avoid unwanted code execution.", "Messages": "Default content-type of a message following the MOM standard is Markdown text in UTF8 without BOM. It is highly recommended to disallow the reading of any not-text content-type, unless expressly acknowledged by the user.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2876, "url": "https://eips.ethereum.org/EIPS/eip-2876", "title": "Deposit contract and address standard", "authors": ["Jonathan Underwood\u00a0(", "@junderw", ")"], "sections": {"ERC-2876: Deposit contract and address standard": "This ERC defines a simple contract interface for managing deposits. It also defines a new address format that encodes the extra data passed into the interface\u2019s main deposit function.", "": "This ERC defines a simple contract interface for managing deposits. It also defines a new address format that encodes the extra data passed into the interface\u2019s main deposit function.", "Simple Summary": "This ERC defines a simple contract interface for managing deposits. It also defines a new address format that encodes the extra data passed into the interface\u2019s main deposit function.", "Abstract": "An ERC-2876 compatibledeposit systemcan accept ETH payments from multiple depositors without the need for managing multiple keys or requiring use of a hot wallet.", "Motivation": "Centralized exchanges and merchants (Below: \u201capps\u201d) require an address format for accepting deposits. Currently the address format used refers to an account (external or contract), but this creates a problem. It requires that apps create a new account for every invoice / user. If the account is external, that means the app must have the deposit addresses be hot wallets, or have increased workload for cold wallet operators (as each deposit account will create 1 value tx to sweep). If the account is contract, generating an account costs at least 60k gas for a simple proxy, which is cost-prohibitive.", "Specification": "In order to add the 8 byte \u201cid\u201d data, we need to encode it along with the 20 byte\naccount address. The 8 bytes are appended to the 20 byte address.", "Definitions": "In order to add the 8 byte \u201cid\u201d data, we need to encode it along with the 20 byte\naccount address. The 8 bytes are appended to the 20 byte address.", "Deposit Address Format": "In order to add the 8 byte \u201cid\u201d data, we need to encode it along with the 20 byte\naccount address. The 8 bytes are appended to the 20 byte address.", "The Contract Interface": "A contract that follows this ERC:", "Depositing Value to the Contract from a Wallet": "The contract interface and address format combination has one notable drawback, which was brought up in discussion. This ERC can only handle deposits for native value (ETH) and not other protocols such as ERC-20. However, this is not considered a problem, because it is best practice to logically AND key-wise separate wallets for separate currencies in any exchange/merchant application for accounting reasons and also for security reasons. Therefore, using this method for the native value currency (ETH) and another method for ERC-20 tokens etc. is acceptable. Any attempt at doing something similar for ERC-20 would require modifying the ERC itself (by adding the id data as a new input argument to the transfer method etc.) which would grow the scope of this ERC too large to manage. However, if this address format catches on, it would be trivial to add the bytes8 id to any updated protocols (though adoption might be tough due to network effects).", "Rationale": "The contract interface and address format combination has one notable drawback, which was brought up in discussion. This ERC can only handle deposits for native value (ETH) and not other protocols such as ERC-20. However, this is not considered a problem, because it is best practice to logically AND key-wise separate wallets for separate currencies in any exchange/merchant application for accounting reasons and also for security reasons. Therefore, using this method for the native value currency (ETH) and another method for ERC-20 tokens etc. is acceptable. Any attempt at doing something similar for ERC-20 would require modifying the ERC itself (by adding the id data as a new input argument to the transfer method etc.) which would grow the scope of this ERC too large to manage. However, if this address format catches on, it would be trivial to add the bytes8 id to any updated protocols (though adoption might be tough due to network effects).", "Backwards Compatibility": "An address generated with the deposit address format will not be considered a valid address for applications that don\u2019t support it. If the user is technical enough, they can get around lack of support by verifying the checksum themselves, creating the needed data field by hand, and manually input the data field. (assuming the wallet app allows for arbitrary data input on transactions) A tool could be hosted on github for users to get the needed 20 byte address and msg.data field from a deposit address.", "Test Cases": "A sample implementation with an example contract and address generation (in the tests) is located here:", "Implementation": "A sample implementation with an example contract and address generation (in the tests) is located here:", "Security Considerations": "In general, contracts that implement the contract interface should forward funds received to the deposit(bytes8) function to their cold wallet account. This address SHOULD be hard coded as a constant OR take advantage of theimmutablekeyword in solidity versions>=0.6.5.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2917, "url": "https://eips.ethereum.org/EIPS/eip-2917", "title": "Staking Reward Calculation", "authors": ["Tony Carson\u00a0<", "tony.carsonn@gmail.com", ">", "Mehmet Sabir Kiraz\u00a0<", "m.kiraz@gmail.com", ">", "S\u00fcleyman Karda\u015f\u00a0<", "skardas@gmail.com", ">"], "sections": {"ERC-2917: Staking Reward Calculation": "ERC2917 is a new standardization for on-chain calculation of staking reward.", "": "ERC2917 is a new standardization for on-chain calculation of staking reward.", "Simple Summary": "ERC2917 is a new standardization for on-chain calculation of staking reward.", "Abstract": "Based on the product of effective collateral and time, ERC2917 calculates the reward a user can get at any time, and realize the real decentralized DeFi. Here below is the formula for the calculation of reward for a user U:", "Motivation": "One of the main drawbacks of many DeFi projects is the reward distribution mechanism within the smart contract. In fact, there are two main mechanisms are adopted so far.", "Specification": "Every ERC-2917 compliant contract must implement the ERC2917 and ERC20 interfaces (if necessary):", "InterestRatePerBlockChanged": "This emit when interests amount per block is changed by the owner of the contract. It emits with the old interests amount and the new interests amount.", "ProductivityIncreased": "It emits with the user\u2019s address and the value after the change.", "ProductivityDecreased": "It emits with the user\u2019s address and the value after the change.", "interestsPerBlock": "It returns the amount of interests currently producing per each block.", "changeInterestRatePerBlock": "Note the best practice will be restrict the gross product provider\u2019s contract address to call this.", "getProductivity": "It returns user\u2019s productivity and overall productivity. It returns 0 if user has no productivity proved in the contract.", "increaseProductivity": "It increases a user\u2019s productivity.", "decreaseProductivity": "It decreases a user\u2019s productivity.", "take": "It returns the interests that callee will get at current block height.", "takeWithBlock": "Similar to take(), but with the block height joined to calculate return.", "mint": "it mints the amount of interests will transfer to callee\u2019s address. It returns the amount of interests minted.", "Rationale": "TBD", "Implementation": "The implementation code is on the github:", "Security Considerations": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2942, "url": "https://eips.ethereum.org/EIPS/eip-2942", "title": "EthPM URI Specification", "authors": ["Nick Gheorghita\u00a0(", "@njgheorghita", ")", "Piper Merriam\u00a0(", "@pipermerriam", ")", "g. nicholas d'andrea\u00a0(", "@gnidan", ")", "Benjamin Hauser\u00a0(", "@iamdefinitelyahuman", ")"], "sections": {"ERC-2942: EthPM URI Specification": "A custom URI scheme to identify an EthPM registry, package, release, or specific contract asset within a release.", "": "A custom URI scheme to identify an EthPM registry, package, release, or specific contract asset within a release.", "Simple Summary": "A custom URI scheme to identify an EthPM registry, package, release, or specific contract asset within a release.", "Abstract": "When interacting with the EthPM ecosystem, users and tooling can benefit from a URI scheme to identify EthPM assets. Being able to specify a package, registry, or release with a single string makes simplifies the steps required to install, publish, or distribute EthPM packages.", "Specification": "scheme://registry_address[:chain_id][/package_name[@package_version[/json_pointer]]]", "Rationale": "Most interactions within the EthPM ecosystem benefit from a single-string representation of EthPM assets; from installing a package, to identifying a registry, to distributing a package. A single string that can faithfully represent any kind of EthPM asset, across the mainnet or testnets, reduces the mental overload for new users, minimizes configuration requirements for frameworks, and simplifies distribution of packages for package authors.", "Test Cases": "A JSON file for testing various URIs can be found in theethpm-specrepository fixtures.", "Implementation": "The EthPM URI scheme has been implemented in the following libraries:", "Security Considerations": "In most cases, an EthPM URI points to an immutable asset, giving full security that the target asset has not been modified. However, in the case where an EthPM URI uses an ENS name as its registry address, it is possible that the ENS name has been redirected to a new registry, in which case the guarantee of immutability no longer exists.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2980, "url": "https://eips.ethereum.org/EIPS/eip-2980", "title": "Swiss Compliant Asset Token", "authors": ["Gianluca Perletti\u00a0(", "@Perlets9", ")", "Alan Scarpellini\u00a0(", "@alanscarpellini", ")", "Roberto Gorini\u00a0(", "@robertogorini", ")", "Manuel Olivi\u00a0(", "@manvel79", ")"], "sections": {"ERC-2980: Swiss Compliant Asset Token": "This new standard is anERC-20compatible token with restrictions that comply with the following Swiss laws: theStock Exchange Act, theBanking Act, theFinancial Market Infrastructure Act, theAct on Collective Investment Schemesand theAnti-Money Laundering Act. TheFinancial Services Actand theFinancial Institutions Actmust also be considered. The solution achieved meet also the European jurisdiction.", "An interface for asset tokens, compliant with Swiss Law and compatible with [ERC-20](./eip-20.md).": "This new standard is anERC-20compatible token with restrictions that comply with the following Swiss laws: theStock Exchange Act, theBanking Act, theFinancial Market Infrastructure Act, theAct on Collective Investment Schemesand theAnti-Money Laundering Act. TheFinancial Services Actand theFinancial Institutions Actmust also be considered. The solution achieved meet also the European jurisdiction.", "Abstract": "This new standard is anERC-20compatible token with restrictions that comply with the following Swiss laws: theStock Exchange Act, theBanking Act, theFinancial Market Infrastructure Act, theAct on Collective Investment Schemesand theAnti-Money Laundering Act. TheFinancial Services Actand theFinancial Institutions Actmust also be considered. The solution achieved meet also the European jurisdiction.", "Motivation": "In its ICO guidance dated February 16, 2018, FINMA (Swiss Financial Market Supervisory Authority) defines asset tokens as tokens representing assets and/or relative rights (FINMA ICO Guidelines). It explicitly mentions that asset tokens are analogous to and can economically represent shares, bonds, or derivatives. The long list of relevant financial market laws mentioned above reveal that we need more methods than with Payment and Utility Token.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "ERC-2980 (Token Contract)": "The ERC-2980 extendsERC-20. Due to the indivisible nature of asset tokens, the decimals number MUST be zero.", "Whitelist and Frozenlist": "The accomplishment of the Swiss Law requirements is achieved by the use of two distinct lists of address: the Whitelist and the Frozenlist.\nAddresses can be added to one or the other list at any time by operators with special privileges, called Issuers, and described below.\nAlthough these lists may look similar, they differ for the following reasons: the Whitelist members are the only ones who can receive tokens from other addresses. There is no restriction on the possibility that these addresses can transfer the tokens already in their ownership.\nThis can occur when an address, present in the Whitelist, is removed from this list, without however being put in the Frozenlist and remaining in possession of its tokens.\nOn the other hand, the addresses assigned to the Frozenlist, as suggested by the name itself, have to be considered \u201cfrozen\u201d, so they cannot either receive tokens or send tokens to anyone.", "Issuers": "A key role is played by the Issuer. This figure has the permission to manage Whitelists and Frozenlists, to revoke tokens and reassign them and to transfer the role to another address. No restrictions on the possibility to have more than one Issuer per contract. Issuers are nominated by the Owner of the contract, who also is in charge of remove the role. The possibility of nominating the Owner itself as Issuer at the time of contract creation (or immediately after) is not excluded.", "Revoke and Reassign": "Revoke and Reassign methods allow Issuers to move tokens from addresses, even if they are in the Frozenlist. The Revoke method transfers the entire balance of the target address to the Issuer who invoked the method. The Reassign method transfers the entire balance of the target address to another address. These rights for these operations MUST be allowed only to Issuers.", "Rationale": "There are currently no token standards that expressly facilitate conformity to securities law and related regulations. EIP-1404 (Simple Restricted Token Standard) it\u2019s not enough to address FINMA requirements around re-issuing securities to Investors.\nIn Swiss law, an issuer must eventually enforce the restrictions of their token transfer with a \u201cfreeze\u201d function. The token must be \u201crevocable\u201d, and we need to apply a white-list method for AML/KYC checks.", "Backwards Compatibility": "This EIP does not introduce backward incompatibilities and is backward compatible with the older ERC-20 token standard.\nThis standard allows the implementation of ERC-20 functions transfer, transferFrom, approve and allowance alongside to make a token fully compatible with ERC-20.\nThe token MAY implement decimals() for backward compatibility with ERC-20. If implemented, it MUST always return 0.", "Security Considerations": "The security considerations mainly concern the role played by the Issuers. This figure, in fact, is not generally present in common ERC-20 tokens but has very powerful rights that allow him to move tokens without being in possession and freeze other addresses, preventing them from transferring tokens. It must be the responsibility of the owner to ensure that the addresses that receive this charge remain in possession of it only for the time for which they have been designated to do so, thus preventing any abuse.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3000, "url": "https://eips.ethereum.org/EIPS/eip-3000", "title": "Optimistic enactment governance standard", "authors": ["Jorge Izquierdo\u00a0(", "@izqui", ")", "Fabien Marino\u00a0(", "@bonustrack", ")"], "sections": {"ERC-3000: Optimistic enactment governance standard": "Interface for scheduling, executing and challenging contract executions based on off-chain approval", "": "Interface for scheduling, executing and challenging contract executions based on off-chain approval", "Simple Summary": "Interface for scheduling, executing and challenging contract executions based on off-chain approval", "Abstract": "ERC-3000 presents a basic on-chain spec for contracts to optimistically enact governance decisions made off-chain.", "Specification": "Some data structures are defined which are later used in the standard interfaces:", "Data structures": "Some data structures are defined which are later used in the standard interfaces:", "Interface and events": "Given the data structures above, by taking advantage of the Solidity ABI encoder v2, we define four required functions and two optional functions as the interface for contracts to comply with ERC-3000.", "Rationale": "The authors believe that it is very important that this standard leaves the other open to any resolver mechanism to be implemented and adopted.", "Security Considerations": "The standard allows for the resolver for challenges to be configured, and even have different resolvers for coexisting scheduled payloads. Choosing the right resolver requires making the right tradeoff between security, time to finality, implementation complexity, and external dependencies.", "Implementations": "Copyright and related rights waived viaCC0.", "1. Aragon Govern": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3005, "url": "https://eips.ethereum.org/EIPS/eip-3005", "title": "Batched meta transactions", "authors": ["Matt\u00a0(", "@defifuture", ")"], "sections": {"ERC-3005: Batched meta transactions": "Defines an extension function for ERC-20 (and other fungible token standards), which allows receiving and processing a batch of meta transactions.", "": "Defines an extension function for ERC-20 (and other fungible token standards), which allows receiving and processing a batch of meta transactions.", "Simple Summary": "Defines an extension function for ERC-20 (and other fungible token standards), which allows receiving and processing a batch of meta transactions.", "Abstract": "This EIP defines a new function calledprocessMetaBatch()that extends any fungible token standard, and enables batched meta transactions coming from many senders in one on-chain transaction.", "Motivation": "Meta transactions have proven useful as a solution for Ethereum accounts that don\u2019t have any ether, but hold ERC-20 tokens and would like to transfer them (gasless transactions).", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d,  \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Meta transaction data": "In order to successfully validate and transfer tokens, theprocessMetaBatch()function MUST process the following data about a meta transaction:", "processMetaBatch()function input data": "TheprocessMetaBatch()function MUST receive the following data:", "Meta transaction data hash": "The pseudocode for creating a hash of meta transaction data is the following:", "Validation rules": "TheprocessMetaBatch()function MUST have the following interface:", "processMetaBatch()function interface": "TheprocessMetaBatch()function MUST have the following interface:", "Meta transaction nonce": "The token smart contract must keep track of a meta transaction nonce for each token holder.", "Token transfers": "Token transfers in the reference implementation could alternatively be done by calling the_transfer()function (part of the OpenZeppelin ERC-20 implementation), but it would increase the gas usage and it would also revert the whole batch if some meta transaction was invalid (the current implementation just skips it).", "Implementation": "Thereference implementationadds a couple of functions to the existing ERC-20 token standard:", "processMetaBatch()": "TheprocessMetaBatch()function is responsible for receiving and processing a batch of meta transactions that change token balances.", "nonceOf()": "Nonces are needed due to the replay protection (seeReplay attacksunderSecurity Considerations).", "Rationale": "Alternative implementations (like GSN) use multiple smart contracts to enable meta transactions, although this increases gas usage. This implementation (EIP-3005) intentionally keeps everything within one function which reduces complexity and gas cost.", "All-in-one": "Alternative implementations (like GSN) use multiple smart contracts to enable meta transactions, although this increases gas usage. This implementation (EIP-3005) intentionally keeps everything within one function which reduces complexity and gas cost.", "Function parameters": "As you can see, theprocessMetaBatch()function in the reference implementation takes the following parameters:", "The alternative way of passing meta transaction data into the function": "The reference implementation takes parameters as arrays. There\u2019s a separate array for each meta transaction data category (the ones that cannot be deduced or extracted from other sources).", "Why is nonce not one of the parameters in the reference implementation?": "Meta nonce is used for constructing a signed hash (see themsgHashline where akeccak256hash is constructed - you\u2019ll find a nonce there).", "Can EIP-2612 nonces mapping be re-used?": "The EIP-2612 (permit()function) also requires a nonce mapping. At this point, I\u2019m not sure yet if this mapping should bere-usedin case a smart contract implements both EIP-3005 and EIP-2612.", "Backwards Compatibility": "The code implementation of batched meta transactions is backwards compatible with any fungible token standard, for example, ERC-20 (it only extends it with one function).", "Test Cases": "Link to tests:https://github.com/defifuture/erc20-batched-meta-transactions/tree/master/test.", "Security Considerations": "Here is a list of potential security issues and how are they addressed in this implementation.", "Forging a meta transaction": "The solution against a relayer forging a meta transaction is for a user to sign the meta transaction with their private key.", "Replay attacks": "TheprocessMetaBatch()function is secure against two types of a replay attack:", "Signature validation": "Signing a meta transaction and validating the signature is crucial for this whole scheme to work.", "Malicious relayer forcing a user into over-spending": "A malicious relayer could delay sending some user\u2019s meta transaction until the user would decide to make the token transaction on-chain.", "Front-running attack": "A malicious relayer could scout the Ethereum mempool to steal meta transactions and front-run the original relayer.", "A malicious (or too impatient) user sending a meta transaction with the same nonce through multiple relayers at once": "A user that is either malicious or just impatient could submit a meta transaction with the same nonce (for the same token contract) to various relayers. Only one of them would get the relayer fee (the first one on-chain), while the others would get an invalid meta transaction.", "Too big due block number": "The relayer could trick the meta transaction sender into adding too big due block number - this means a block by which the meta transaction must be processed. The block number could be far in the future, for example, 10 years in the future. This means that the relayer would have 10 years to submit the meta transaction.", "Copyright": "Copyright and related rights are waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3009, "url": "https://eips.ethereum.org/EIPS/eip-3009", "title": "Transfer With Authorization", "authors": ["Peter Jihoon Kim\u00a0(", "@petejkim", ")", "Kevin Britz\u00a0(", "@kbrizzle", ")", "David Knott\u00a0(", "@DavidLKnott", ")"], "sections": {"ERC-3009: Transfer With Authorization": "A contract interface that enables transferring of fungible assets via a signed authorization.", "": "A contract interface that enables transferring of fungible assets via a signed authorization.", "Simple Summary": "A contract interface that enables transferring of fungible assets via a signed authorization.", "Abstract": "A set of functions to enable meta-transactions and atomic interactions withERC-20token contracts via signatures conforming to theEIP-712typed message signing specification.", "Motivation": "There is an existing spec,EIP-2612, that also allows meta-transactions, and it is encouraged that a contract implements both for maximum compatibility. The two primary differences between this spec and EIP-2612 are that:", "Specification": "Optional:", "Event": "Optional:", "Use with web3 providers": "The signature for an authorization can be obtained using a web3 provider with theeth_signTypedData{_v4}method.", "Rationale": "One might say transaction ordering is one reason why sequential nonces are preferred. However, sequential nonces do not actually help achieve transaction ordering for meta transactions in practice:", "Unique Random Nonce, Instead of Sequential Nonce": "One might say transaction ordering is one reason why sequential nonces are preferred. However, sequential nonces do not actually help achieve transaction ordering for meta transactions in practice:", "Valid After and Valid Before": "New contracts benefit from being able to directly utilize EIP-3009 in order to create atomic transactions, but existing contracts may still rely on the conventional ERC-20 allowance pattern (approve/transferFrom).", "EIP-712": "New contracts benefit from being able to directly utilize EIP-3009 in order to create atomic transactions, but existing contracts may still rely on the conventional ERC-20 allowance pattern (approve/transferFrom).", "Backwards Compatibility": "New contracts benefit from being able to directly utilize EIP-3009 in order to create atomic transactions, but existing contracts may still rely on the conventional ERC-20 allowance pattern (approve/transferFrom).", "Test Cases": "SeeEIP3009.test.ts.", "Implementation": "EIP3009.sol", "Security Considerations": "UsereceiveWithAuthorizationinstead oftransferWithAuthorizationwhen calling from other smart contracts. It is possible for an attacker watching the transaction pool to extract the transfer authorization and front-run thetransferWithAuthorizationcall to execute the transfer without invoking the wrapper function. This could potentially result in unprocessed, locked up deposits.receiveWithAuthorizationprevents this by performing an additional check that ensures that the caller is the payee. Additionally, if there are multiple contract functions accepting receive authorizations, the app developer could dedicate some leading bytes of the nonce could as the identifier to prevent cross-use.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3135, "url": "https://eips.ethereum.org/EIPS/eip-3135", "title": "Exclusive Claimable Token", "authors": ["Zhenyu Sun\u00a0(", "@Ungigdu", ")"], "sections": {"ERC-3135: Exclusive Claimable Token": "This standard defines a token which can be claimed only by token issuer with payer\u2019s signature.", "": "This standard defines a token which can be claimed only by token issuer with payer\u2019s signature.", "Simple Summary": "This standard defines a token which can be claimed only by token issuer with payer\u2019s signature.", "Abstract": "This EIP defines a set of additions to the default token standard such as ERC-20, that allows online/offline service providers establish micropayment channels with any number of users by signing and verifying messages about the consumption of token off chain. Using this mechanism will reduce interactions with blockchain to minimal for both participants, thus saving gas and improve performance.", "Motivation": "There are two main purposes of this EIP, one is to reduce interactions with blockchain, the second is to link Ethereum to real-world payment problems.", "Specification": "the pseudo code generating an ECDSA signature:", "signature": "the pseudo code generating an ECDSA signature:", "verification process": "the verification contains check about both signature and token_consumption", "About withdraw": "The withdraw function is slightly different based on business models", "Rationale": "This EIP targets on ERC-20 tokens due to its widespread adoption. However, this extension is designed to be compatible with other token standard.", "Backwards Compatibility": "This EIP is fully backwards compatible as its implementation extends the functionality ofERC-20.", "Implementation": "By restricting claim function to issuer, there is no race condition on chain layer. However double spending problem may occur when the issuer use multiple verifiers and payer signs many payment messages simultaneously. Some of those messages may get chance to be checked valid though only the message with the largest consumption can be claimed. This problem can be fixed by introducing an echo server which accepts messages from verifiers, returns the message sequentially with largest consumption and biggest epoch number. If a verifier gets an answer different from the message he send, it updates the message from echo server as the last message it receives along with local storage of the status about this payer. Then the verifier asks the payer again for a new message.", "Security Considerations": "By restricting claim function to issuer, there is no race condition on chain layer. However double spending problem may occur when the issuer use multiple verifiers and payer signs many payment messages simultaneously. Some of those messages may get chance to be checked valid though only the message with the largest consumption can be claimed. This problem can be fixed by introducing an echo server which accepts messages from verifiers, returns the message sequentially with largest consumption and biggest epoch number. If a verifier gets an answer different from the message he send, it updates the message from echo server as the last message it receives along with local storage of the status about this payer. Then the verifier asks the payer again for a new message.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3224, "url": "https://eips.ethereum.org/EIPS/eip-3224", "title": "Described Data", "authors": ["Richard Moore\u00a0(", "@ricmoo", ")", "Nick Johnson\u00a0(", "@arachnid", ")"], "sections": {"ERC-3224: Described Data": "Human-readable descriptions for machine executable operations,\ndescribed in higher level machine readable data, so that wallets\ncan provide meaningful feedback to the user describing the\naction the user is about to perform.", "Contract method to compute human-readable descriptions for signable data.": "Human-readable descriptions for machine executable operations,\ndescribed in higher level machine readable data, so that wallets\ncan provide meaningful feedback to the user describing the\naction the user is about to perform.", "Abstract": "Human-readable descriptions for machine executable operations,\ndescribed in higher level machine readable data, so that wallets\ncan provide meaningful feedback to the user describing the\naction the user is about to perform.", "Motivation": "When using an Ethereum Wallet (e.g. MetaMask, Clef, Hardware\nWallets) users must accept and authorize signing messages or\nsending transactions.", "Specification": "Thedescription stringanddescribed dataare generated\nsimultaneously by evaluating the contract\n(i.e. thedescriber), passing thedescriber inputsto the \nmethod:", "New JSON-RPC Methods": "Clients which manage private keys should expose additional\nmethods for interacting with the related accounts.", "Signing Described Messages": "Compute thedescription stringanddescribed databy\nevaluating the call todescriber, with thedescriberInputpassed to the ABI encoded call toeipXXXDescription(bytes). TheVALUEduring execution must\nbe 0.", "Sending Described Transactions": "Compute thedescription stringanddescribed databy\nevaluating the call to thedescriberto, with thedescriberInputpassed  to the ABI encoded call toeipXXXDescription(bytes).", "Signing Described Transaction": "Compute thedescription stringanddescribed databy\nevaluating the call to thedescriberto, with thedescriberInputpassed  to the ABI encoded call toeipXXXDescription(bytes).", "Description Strings": "Adescription stringmust begin with a mime-type followed\nby a semi-colon (;). This EIP specifies only thetext/plainmime-type, but future EIPs may specify additional types to\nenable more rich processing, such astext/markdownso that\naddresses can be linkable within clients or to enable\nmulti-locale options, similar to multipart/form-data.", "Rationale": "There have been many attempts to solve this problem, many of\nwhich attempt to examine the encoded transaction data or\nmessage data directly.", "Meta Description": "There have been many attempts to solve this problem, many of\nwhich attempt to examine the encoded transaction data or\nmessage data directly.", "Entangling the Contract Address": "To prevent data being signed from one contract being used\nagainst another, the contract address is entanlged into\nboth the transaction (implicitly via thetofield) and\nin messages by the EIP-191 versions specific data.", "Alternatives": "All signatures for messages are generated usingEIP-191which had a previously compatible version byte of0x00, so\nthere should be no concerns with backwards compatibility.", "Backwards Compatibility": "All signatures for messages are generated usingEIP-191which had a previously compatible version byte of0x00, so\nthere should be no concerns with backwards compatibility.", "Test Cases": "All test cases operate against the published and verified contracts:", "Messages": "Example: login with signed message", "Transactions": "All transaction test cases use the ropsten network (chainId: 3)\nand for all unspecified properties use 0.", "Reference Implementation": "@TODO (consider adding it as one or more files in../assets/eip-####/)", "Security Considerations": "Wallets must be careful when displaying text provided by\ncontracts and proper efforts must be taken to sanitize\nit, for example, be sure to consider:", "Escaping Text": "Wallets must be careful when displaying text provided by\ncontracts and proper efforts must be taken to sanitize\nit, for example, be sure to consider:", "Distinguished Signed Data": "Applications implementing this EIP to sign message data should\nensure there are no collisions within the data which could\nresult in ambiguously signed data.", "Enumeration": "If an abort occurs during signing, the response from this call\nshould match the response from a declined signing request;\notherwise this could be used for enumeration attacks, etc. A\nrandom interactive-scale delay should also be added, otherwise\na < 10ms response could be interpreted as an error.", "Replayablility": "Transactions contain an explicit nonce, but signed messages do\nnot.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3234, "url": "https://eips.ethereum.org/EIPS/eip-3234", "title": "Batch Flash Loans", "authors": ["Alberto Cuesta Ca\u00f1ada\u00a0(", "@albertocuestacanada", ")", "Fiona Kobayashi\u00a0(", "@fifikobayashi", ")", "fubuloubu\u00a0(", "@fubuloubu", ")", "Austin Williams\u00a0(", "@onewayfunction", ")"], "sections": {"ERC-3234: Batch Flash Loans": "This ERC provides standard interfaces and processes for multiple-asset flash loans.", "": "This ERC provides standard interfaces and processes for multiple-asset flash loans.", "Simple Summary": "This ERC provides standard interfaces and processes for multiple-asset flash loans.", "Motivation": "Flash loans of multiple assets, or batch flash loans, are a common offering of flash lenders, and have a strong use case in the simultaneous refinance of several positions between platforms. At the same time, batch flash loans are more complicated to use than single asset flash loans (ER3156). This divergence of use cases and user profiles calls for independent, but consistent, standards for single asset flash loans and batch flash loans.", "Specification": "A batch flash lending feature integrates two smart contracts using a callback pattern. These are called the LENDER and the RECEIVER in this EIP.", "Lender Specification": "AlenderMUST implement the IERC3234BatchFlashLender interface.", "Receiver Specification": "Areceiverof flash loans MUST implement the IERC3234BatchFlashBorrower interface:", "Rationale": "The interfaces described in this ERC have been chosen as to cover the known flash lending use cases, while allowing for safe and gas efficient implementations.", "Security Considerations": "The arguments ofonBatchFlashLoanare expected to reflect the conditions of the flash loan, but cannot be trusted unconditionally. They can be divided in two groups, that require different checks before they can be trusted to be genuine.", "Verification of callback arguments": "The arguments ofonBatchFlashLoanare expected to reflect the conditions of the flash loan, but cannot be trusted unconditionally. They can be divided in two groups, that require different checks before they can be trusted to be genuine.", "Flash lending security considerations": "The safest approach is to implement an approval foramount+feebefore thebatchFlashLoanis executed.", "Flash minting external security considerations": "The typical quantum of tokens involved in flash mint transactions will give rise to new innovative attack vectors.", "Flash minting internal security considerations": "The coupling of flash minting with business specific features in the same platform can easily lead to unintended consequences.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3386, "url": "https://eips.ethereum.org/EIPS/eip-3386", "title": "ERC-721 and ERC-1155 to ERC-20 Wrapper", "authors": ["Calvin Koder\u00a0(", "@ashrowz", ")"], "sections": {"ERC-3386: ERC-721 and ERC-1155 to ERC-20 Wrapper": "A standard interface for contracts that create generic ERC-20 tokens which derive from a pool of unique ERC-721/ERC-1155 tokens.", "": "A standard interface for contracts that create generic ERC-20 tokens which derive from a pool of unique ERC-721/ERC-1155 tokens.", "Simple Summary": "A standard interface for contracts that create generic ERC-20 tokens which derive from a pool of unique ERC-721/ERC-1155 tokens.", "Abstract": "This standard outlines a smart contract interface to wrap identifiable tokens with fungible tokens. This allows for derivativeERC-20tokens to be minted by locking the baseERC-721non-fungible tokens andERC-1155multi tokens into a pool. The derivative tokens can be burned to redeem base tokens out of the pool. These derivatives have no reference to the unique id of these base tokens, and should have a proportional rate of exchange with the base tokens. As representatives of the base tokens, these generic derivative tokens can be traded and otherwise utilized according to ERC-20, such that the unique identifier of each base token is irrelevant.", "Motivation": "The ERC-20 token standard is the most widespread and liquid token standard on Ethereum. ERC-721 and ERC-1155 tokens on the other hand can only be transferred by their individual ids, in whole amounts. Derivative tokens allow for exposure to the base asset while benefiting from contracts which utilize ERC-20 tokens. This allows for the base tokens to be fractionalized, traded and pooled generically on AMMs, collateralized, and be used for any other ERC-20 type contract. Several implementations of this proposal already exist without a common standard.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described inRFC 2119.", "Rationale": "The ERC-721/ERC-1155 tokens which are pooled are called {Base} tokens. Alternative names include:", "Naming": "The ERC-721/ERC-1155 tokens which are pooled are called {Base} tokens. Alternative names include:", "Minting": "Minting requires the transfer of the {Base} tokens into the {Pool} in exchange for {Derivative} tokens. The {Base} tokens deposited in this way MUST NOT be transferred again except through the burning functions. This ensures the value of the {Derivative} tokens is representative of the value of the {Base} tokens.", "Burning": "Burning requires the transfer of {Base} tokens out of the {Pool} in exchange for burning {Derivative} tokens. The burn functions are distinguished by the quantity and quality of {Base} tokens redeemed.", "Pricing": "Prices should not be necessarily fixed. therefore, Mint/Burn events MUST include the ERC-20_valueminted/burned.", "Inheritance": "The {Wrapper} MAY inherit from {ERC20}, in order to directly callsuper.mintandsuper.burn.\nIf the {Wrapper} does not inherit from {ERC20}, the {Derivative} contract MUST be limited such that the {Wrapper} has the sole power tomint,burn, and otherwise change the supply of tokens.", "Approval": "All of the underlying transfer methods are not tied to the {Wrapper}, but rather call the ERC-20/721/1155 transfer methods. Implementations of this standard MUST:", "Backwards Compatibility": "Most existing implementations inherit from ERC-20, using functionsmintandburn.\nEvents:", "Reference Implementation": "ERC-3386 Reference Implementation", "Security Considerations": "Wrapper contracts are RECOMMENDED to inherit from burnable ERC-20 tokens. If they are not, the supply of the {Derivative} tokens MUST be controlled by the Wrapper. Similarly, price implementations MUST ensure that the supply of {Base} tokens is reflected by the {Derivative} tokens.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3440, "url": "https://eips.ethereum.org/EIPS/eip-3440", "title": "ERC-721 Editions Standard", "authors": ["Nathan Ginnever\u00a0(", "@nginnever", ")"], "sections": {"ERC-3440: ERC-721 Editions Standard": "This standard addresses an extension to theERC-721 specificationby allowing signatures on NFTs representing works of art. This provides improved provenance by creating functionality for an artist to designate an original and signed limited-edition prints of their work.", "": "This standard addresses an extension to theERC-721 specificationby allowing signatures on NFTs representing works of art. This provides improved provenance by creating functionality for an artist to designate an original and signed limited-edition prints of their work.", "Simple Summary": "This standard addresses an extension to theERC-721 specificationby allowing signatures on NFTs representing works of art. This provides improved provenance by creating functionality for an artist to designate an original and signed limited-edition prints of their work.", "Abstract": "ERC-3440 is an ERC-721 extension specifically designed to make NFTs more robust for works of art. This extends the original ERC-721 spec by providing the ability to designate the original and limited-edition prints with a specialized enumeration extension similar to theoriginal 721 extensionbuilt-in. The key improvement of this extension is allowing artists to designate the limited nature of their prints and provide a signed piece of data that represents their unique signature to a given token Id, much like an artist would sign a print of their work.", "Motivation": "Currently the link between a NFT and the digital work of art is only enforced in the token metadata stored in the sharedtokenURIstate of a NFT. While the blockchain provides an immutable record of history back to the origin of an NFT, often the origin is not a key that an artist maintains as closely as they would a hand written signature.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "A major role of NFTs is to display uniqueness in digital art. Provenance is a desired feature of works of art, and this standard will help improve a NFT by providing a better way to verify uniqueness. Taking this extra step by an artist to explicitly sign tokens provides a better connection between the artists and their work on the blockchain. Artists can now retain their private key and sign messages in the future showing that the same signature is present on a unique NFT.", "Backwards Compatibility": "This proposal combines already available 721 extensions and is backwards compatible with the ERC-721 standard.", "Test Cases": "An example implementation including tests can be foundhere.", "Reference Implementation": "This extension gives an artist the ability to designate an original edition, set the maximum supply of editions as well as print the editions and uses thetokenURIextension to supply a link to the art work. To minimize the risk of an artist changing this value after selling an original piece this function can only happen once. Ensuring that these functions can only happen once provides consistency with uniqueness and verifiability. Due to this, the reference implementation handles these features in the constructor function. An edition may only be signed once, and care should be taken that the edition is signed correctly before release of the token/s.", "Security Considerations": "This extension gives an artist the ability to designate an original edition, set the maximum supply of editions as well as print the editions and uses thetokenURIextension to supply a link to the art work. To minimize the risk of an artist changing this value after selling an original piece this function can only happen once. Ensuring that these functions can only happen once provides consistency with uniqueness and verifiability. Due to this, the reference implementation handles these features in the constructor function. An edition may only be signed once, and care should be taken that the edition is signed correctly before release of the token/s.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3450, "url": "https://eips.ethereum.org/EIPS/eip-3450", "title": "Standardized Shamir Secret Sharing Scheme for BIP-39 Mnemonics", "authors": ["Daniel Streit\u00a0(", "@danielstreit", ")"], "sections": {"ERC-3450: Standardized Shamir Secret Sharing Scheme for BIP-39 Mnemonics": "A standardized algorithm for applying Shamir\u2019s Secret Sharing Scheme to BIP-39 mnemonics.", "": "A standardized algorithm for applying Shamir\u2019s Secret Sharing Scheme to BIP-39 mnemonics.", "Simple Summary": "A standardized algorithm for applying Shamir\u2019s Secret Sharing Scheme to BIP-39 mnemonics.", "Abstract": "A standardized approach to splitting a BIP-39 mnemonic intoNBIP-39 mnemonics, called shares, so thatTshares are required to recover the original mnemonic and no information about the original mnemonic, other than its size, is leaked with less thanTshares.", "Motivation": "We\u2019d like to make it easier for less-technical users to store keys securely.", "Specification": "Shamir\u2019s Secret Sharing Scheme is a cryptographic method to split a secret intoNunique parts, where anyTof them are required to reconstruct the secret.", "Shamir\u2019s Secret Sharing Scheme": "Shamir\u2019s Secret Sharing Scheme is a cryptographic method to split a secret intoNunique parts, where anyTof them are required to reconstruct the secret.", "BIP-39 Mnemonics": "BIP-39 is a common standard for storing entropy as a list of words. It is easier to work with for human interactions than raw binary or hexadecimal representations of entropy.", "Applying Shamir\u2019s Scheme to BIP-39 Mnemonics": "To ensure that the shares are valid BIP-39 mnemonics, we:", "Share Format": "A share represents a point on the curve described by the underlying polynomial used to split the secret. It includes two pieces of data:", "Creating Shares": "Inputs: BIP-39 mnemonic, number of shares (N), threshold (T)", "Recovering the Mnemonic": "To recover the original mnemonic, we interpolate a polynomialffrom the given set of shares (or points on the polynomial) and evaluatef(0).", "Rationale": "The field GF(256) was chosen, because the field arithmetic is easy to implement in any programming language and many implementations are already available since it is used in the AES cipher. Although using GF(256) requires that we convert the mnemonic to its underlying entropy as a byte-vector, this is also easy to implement and many implementations of it exist in a variety of programming languages.", "Choice of Field": "The field GF(256) was chosen, because the field arithmetic is easy to implement in any programming language and many implementations are already available since it is used in the AES cipher. Although using GF(256) requires that we convert the mnemonic to its underlying entropy as a byte-vector, this is also easy to implement and many implementations of it exist in a variety of programming languages.", "Valid Share Mnemonics and Share IDs": "The shares produced by the specification include an ID, in addition to the BIP-39 mnemonic.", "Validation on Recovery": "We decidednotto include a validation mechanism on recovering the original mnemonic. This leaks less information to a potential attacker. There is no indication they\u2019ve gotten the requisite number of shares until they\u2019ve obtainedT+ 1 shares.", "Test Cases": "Coming soon.", "Security Considerations": "The shares produced by the specification include an ID in addition to the BIP-39 mnemonic. This raises two security concerns:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3561, "url": "https://eips.ethereum.org/EIPS/eip-3561", "title": "Trust Minimized Upgradeability Proxy", "authors": ["Sam Porter\u00a0(", "@SamPorter1984", ")"], "sections": {"ERC-3561: Trust Minimized Upgradeability Proxy": "Removing trust from upgradeability proxy is necessary for anonymous developers. In order to accomplish this, instant and potentially malicious upgrades must be prevented. This EIP introduces additional storage slots for upgradeability proxy which are assumed to decrease trust in interaction with upgradeable smart contracts. Defined by the admin implementation logic can be made an active implementation logic only after Zero Trust Period allows.", "proxy with a delay before specified upgrade goes live": "Removing trust from upgradeability proxy is necessary for anonymous developers. In order to accomplish this, instant and potentially malicious upgrades must be prevented. This EIP introduces additional storage slots for upgradeability proxy which are assumed to decrease trust in interaction with upgradeable smart contracts. Defined by the admin implementation logic can be made an active implementation logic only after Zero Trust Period allows.", "Abstract": "Removing trust from upgradeability proxy is necessary for anonymous developers. In order to accomplish this, instant and potentially malicious upgrades must be prevented. This EIP introduces additional storage slots for upgradeability proxy which are assumed to decrease trust in interaction with upgradeable smart contracts. Defined by the admin implementation logic can be made an active implementation logic only after Zero Trust Period allows.", "Motivation": "Anonymous developers who utilize upgradeability proxies typically struggle to earn the trust of the community.", "Specification": "The specification is an addition to the standardEIP-1967transparent proxy design.\nThe specification focuses on the slots it adds. All admin interactions with trust minimized proxy must emit an event to make admin actions trackable, and all admin actions must be guarded withonlyAdmin()modifier.", "Next Logic Contract Address": "Storage slot0x19e3fabe07b65998b604369d85524946766191ac9434b39e27c424c976493685(obtained asbytes32(uint256(keccak256('eip3561.proxy.next.logic')) - 1)).\nDesirable implementation logic address must be first defined as next logic, before it can function as actual logic implementation stored in EIP-1967IMPLEMENTATION_SLOT.\nAdmin interactions with next logic contract address correspond with these methods and events:", "Upgrade Block": "Storage slot0xe3228ec3416340815a9ca41bfee1103c47feb764b4f0f4412f5d92df539fe0ee(obtained asbytes32(uint256(keccak256('eip3561.proxy.next.logic.block')) - 1)).\nOn/after this block next logic contract address can be set to EIP-1967IMPLEMENTATION_SLOTor, in other words,upgrade()can be called. Updated automatically according to Zero Trust Period, shown asearliestArrivalBlockin the eventNextLogicDefined.", "Propose Block": "Storage slot0x4b50776e56454fad8a52805daac1d9fd77ef59e4f1a053c342aaae5568af1388(obtained asbytes32(uint256(keccak256('eip3561.proxy.propose.block')) - 1)).\nDefines after/on which blockproposingnext logic is possible. Required for convenience, for example can be manually set to a year from given time. Can be set to maximum number to completely seal the code.\nAdmin interactions with this slot correspond with this method and event:", "Zero Trust Period": "Storage slot0x7913203adedf5aca5386654362047f05edbd30729ae4b0351441c46289146720(obtained asbytes32(uint256(keccak256('eip3561.proxy.zero.trust.period')) - 1)).\nZero Trust Period in amount of blocks, can only be set higher than previous value. While it is at default value(0), the proxy operates exactly as standard EIP-1967 transparent proxy. After zero trust period is set, all above specification is enforced.\nAdmin interactions with this slot should correspond with this method and event:", "Implementation Example": "An argument \u201cjust don\u2019t make such contracts upgadeable at all\u201d fails when it comes to complex systems which do or do not heavily rely on human factor, which might manifest itself in unprecedented ways. It might be impossible to model some systems right on first try. Using decentralized governance for upgrade management coupled with EIP-1967 proxy might become a serious bottleneck for certain protocols before they mature and data is at hand.", "Rationale": "An argument \u201cjust don\u2019t make such contracts upgadeable at all\u201d fails when it comes to complex systems which do or do not heavily rely on human factor, which might manifest itself in unprecedented ways. It might be impossible to model some systems right on first try. Using decentralized governance for upgrade management coupled with EIP-1967 proxy might become a serious bottleneck for certain protocols before they mature and data is at hand.", "Security Considerations": "Users must ensure that a trust-minimized proxy they interact with does not allow overflows, ideally represents the exact copy of the code in implementation example above, and also they must ensure that Zero Trust Period length is reasonable(at the very least two weeks if upgrades are usually being revealed beforehand, and in most cases at least a month).", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3569, "url": "https://eips.ethereum.org/EIPS/eip-3569", "title": "Sealed NFT Metadata Standard", "authors": ["Sean Papanikolas\u00a0(", "@pizzarob", ")"], "sections": {"ERC-3569: Sealed NFT Metadata Standard": "The Sealed NFT Metadata Extension provides a mechanism to immortalize NFT metadata in a cost-effective manner.", "": "The Sealed NFT Metadata Extension provides a mechanism to immortalize NFT metadata in a cost-effective manner.", "Simple Summary": "The Sealed NFT Metadata Extension provides a mechanism to immortalize NFT metadata in a cost-effective manner.", "Abstract": "This standard accomplishes three things; it provides a way for potential collectors to verify that the NFT metadata will not change, allows creators to immortalize metadata for multiple tokens at one time, and allows metadata for many NFTs to be read and cached from one file. A creator can call thesealfunction for a range of one or many sequential NFTs. Included as an argument is a URI which points to a decentralized storage service like IPFS and will be stored in the smart contract. The URI will return a JSON object in which the keys are token IDs and the values are either a string which is a URI pointing to a metadata file stored on a decentralized file system, or raw metadata JSON for each token ID. The token ID(s) will then be marked as sealed in the smart contract and cannot be sealed again. Thesealfunction can be called after NFT creation, or during the NFT creation process.", "Motivation": "In the original ERC-721 standard, the metadata extension specifies atokenURIfunction which returns a URI for a single token ID. This may be hosted on IPFS or might be hosted on a centralized server. There\u2019s no guarantee that the NFT metadata will not change. This is the same for the ERC-1155 metadata extension. In addition to that - if you want to update the metadata for many NFTs you would need to do so in O(n) time, which as we know is not financially feasible at scale. By allowing for a decentralized URI to point to a JSON object of many NFT IDs we can solve this issue by providing metadata for many tokens at one time rather than one at a time. We can also provide methods which give transparency into whether the NFT has be explicitly \u201csealed\u201d and that the metadata is hosted on a decentralized storage space.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Sealed Metadata JSON Format": "The sealed metadata JSON file MAY contain metadata for many different tokens. The top level keys of the JSON object MUST be token IDs.", "Rationale": "Rationale for rule not explicitly requiring that sealed URI be hosted on decentralized filestorage", "Backwards Compatibility": "There is no backwards compatibility with existing standards. This is an extension which could be added to existing NFT standards.", "Security Considerations": "There are no security considerations related directly to the implementation of this standard.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3589, "url": "https://eips.ethereum.org/EIPS/eip-3589", "title": "Assemble assets into NFTs", "authors": ["Zhenyu Sun\u00a0(", "@Ungigdu", ")", "Xinqi Yang\u00a0(", "@xinqiyang", ")"], "sections": {"ERC-3589: Assemble assets into NFTs": "This standard defines a ERC-721 token called assembly token which can represent a combination of assets.", "": "This standard defines a ERC-721 token called assembly token which can represent a combination of assets.", "Simple Summary": "This standard defines a ERC-721 token called assembly token which can represent a combination of assets.", "Abstract": "The ERC-1155 multi-token contract defines a way to batch transfer tokens, but those tokens must be minted by the ERC-1155 contract itself. This EIP is an ERC-721 extension with ability to assemble assets such as ether, ERC-20 tokens, ERC-721 tokens and ERC-1155 tokens into one ERC-721 token whose token id is also the asset\u2019s signature. As assets get assembled into one, batch transfer or swap can be implemented very easily.", "Motivation": "As NFT arts and collectors rapidly increases, some collectors are not satisfied with traditional trading methods. When two collectors want to swap some of their collections, currently they can list their NFTs on the market and notify the other party to buy, but this is inefficient and gas-intensive. Instead, some collectors turn to social media or chat group looking for a trustworthy third party to swap NFTs for them. The third party takes NFTs from both collector A and B, and transfer A\u2019s collections to B and B\u2019s to A. This is very risky.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "There are many reasons why people want to pack their NFTs together. For example, a collector want to pack a set of football players into a football team; a collector has hundreds of of NFTs with no categories to manage them; a collector wants to buy a full collection of NFTs or none of them. They all need a way a assemble those NFTs together.", "Backwards Compatibility": "This proposal combines already available 721 extensions and is backwards compatible with the ERC-721 standard.", "Implementation": "Before usingmintorsafeMintfunctions, user should be aware that some implementations of tokens are pausable. If one of the assets get paused after assembled into one NFT, theburnfunction may not be executed successfully. Platforms using this standard should make support lists or block lists to avoid this situation.", "Security Considerations": "Before usingmintorsafeMintfunctions, user should be aware that some implementations of tokens are pausable. If one of the assets get paused after assembled into one NFT, theburnfunction may not be executed successfully. Platforms using this standard should make support lists or block lists to avoid this situation.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3722, "url": "https://eips.ethereum.org/EIPS/eip-3722", "title": "Poster", "authors": ["Auryn Macmillan\u00a0(", "@auryn-macmillan", ")"], "sections": {"ERC-3722: Poster": "A ridiculously simple general purpose social media smart contract.\nIt takes two strings (contentandtag) as parameters and emits those strings, along with msg.sender, as an event. That\u2019s it.\nThe EIP also includes a proposed standard json format for a Twitter-like application, where eachpost()call can include multiple posts and/or operations. The assumption being that application state will be constructed off-chain via some indexer.", "A ridiculously simple general purpose social media smart contract.": "A ridiculously simple general purpose social media smart contract.\nIt takes two strings (contentandtag) as parameters and emits those strings, along with msg.sender, as an event. That\u2019s it.\nThe EIP also includes a proposed standard json format for a Twitter-like application, where eachpost()call can include multiple posts and/or operations. The assumption being that application state will be constructed off-chain via some indexer.", "Poster": "A ridiculously simple general purpose social media smart contract.\nIt takes two strings (contentandtag) as parameters and emits those strings, along with msg.sender, as an event. That\u2019s it.\nThe EIP also includes a proposed standard json format for a Twitter-like application, where eachpost()call can include multiple posts and/or operations. The assumption being that application state will be constructed off-chain via some indexer.", "Abstract": "A ridiculously simple general purpose social media smart contract.\nIt takes two strings (contentandtag) as parameters and emits those strings, along with msg.sender, as an event. That\u2019s it.\nThe EIP also includes a proposed standard json format for a Twitter-like application, where eachpost()call can include multiple posts and/or operations. The assumption being that application state will be constructed off-chain via some indexer.", "Motivation": "Poster is intended to be used as a base layer for decentralized social media. It can be deployed to the same address (via the singleton factory) on just about any EVM compatible network. Any Ethereum account can make posts to the deployment of Poster on its local network.", "Specification": "There was some discussion around whether or not an post ID should also be emitted, whether the content should be a string or bytes, and whether or not anything at all should actually be emitted.", "Contract": "There was some discussion around whether or not an post ID should also be emitted, whether the content should be a string or bytes, and whether or not anything at all should actually be emitted.", "ABI": "There was some discussion around whether or not an post ID should also be emitted, whether the content should be a string or bytes, and whether or not anything at all should actually be emitted.", "Standard json format for Twitter-like posts": "There was some discussion around whether or not an post ID should also be emitted, whether the content should be a string or bytes, and whether or not anything at all should actually be emitted.", "Rationale": "There was some discussion around whether or not an post ID should also be emitted, whether the content should be a string or bytes, and whether or not anything at all should actually be emitted.", "Reference Implementation": "Poster has been deployed at0x000000000000cd17345801aa8147b8D3950260FFon multiple networks using theSingleton Factory. If it is not yet deployed on your chosen network, you can use the Singleton Factory to deploy an instance of Poster at the same address on just about any EVM compatible network using these parameters:", "Security Considerations": "Given the ridiculously simple implementation of Poster, there does not appear to be any real security concerns at the contract level.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 3754, "url": "https://eips.ethereum.org/EIPS/eip-3754", "title": "A Vanilla Non-Fungible Token Standard", "authors": ["Simon Tian\u00a0(", "@simontianx", ")"], "sections": {"ERC-3754: A Vanilla Non-Fungible Token Standard": "In this standard, a non-fungible token stands as atomic existence and encourages\nlayers of abstraction built on top of it. Ideal for representing concepts like\nrights, a form of abstract ownership. Such right can take the form of NFT options,\noracle membership, virtual coupons, etc., and can then be made liquid because of\nthis tokenization.", "NFTs for representing abstract ownership": "In this standard, a non-fungible token stands as atomic existence and encourages\nlayers of abstraction built on top of it. Ideal for representing concepts like\nrights, a form of abstract ownership. Such right can take the form of NFT options,\noracle membership, virtual coupons, etc., and can then be made liquid because of\nthis tokenization.", "Abstract": "In this standard, a non-fungible token stands as atomic existence and encourages\nlayers of abstraction built on top of it. Ideal for representing concepts like\nrights, a form of abstract ownership. Such right can take the form of NFT options,\noracle membership, virtual coupons, etc., and can then be made liquid because of\nthis tokenization.", "Motivation": "Non-fungible tokens are popularized by theERC-721NFT standard\nfor representing \u201cownership over digital or physical assets\u201d. Over the course of\ndevelopment, reputable NFT projects are about crypto-assets, digital collectibles,\netc. The proposed standard aims to single out a special type of NFTs that are\nideal for representing abstract ownership such as rights. Examples include the\nright of making a function call to a smart contract, an NFT option that gives\nthe owner the right, but not obligation, to purchase an ERC-721 NFT, and the prepaid\nmembership (time-dependent right) of accessing to data feeds provided by oracles\nwithout having to pay the required token fees. An on-chain subscription business\nmodel can then be made available by this standard. The conceptual clarity of an\nNFT is hence improved by this standard.", "Specification": "The NFTs defined in theERC-721standard are already largely\naccepted and known as representing ownership of digital assets, and the NFTs by\nthis standard aim to be accepted and known as representing abstract ownership.\nThis is achieved by allowing and encouraging layers of abstract utilities built\non top of them. Ownership of such NFTs is equivalent with having the rights to\nperform functions assigned to such tokens. Transfer of such rights is also made\neasier because of this tokenization. To further distinguish this standard\nfromERC-721, data fields and functions related toURIare\nexcluded.", "Rationale": "The NFTs defined in theERC-721standard are already largely\naccepted and known as representing ownership of digital assets, and the NFTs by\nthis standard aim to be accepted and known as representing abstract ownership.\nThis is achieved by allowing and encouraging layers of abstract utilities built\non top of them. Ownership of such NFTs is equivalent with having the rights to\nperform functions assigned to such tokens. Transfer of such rights is also made\neasier because of this tokenization. To further distinguish this standard\nfromERC-721, data fields and functions related toURIare\nexcluded.", "Backwards Compatibility": "There is no further backwards compatibility required.", "Reference Implementation": "https://github.com/simontianx/ERC3754", "Security Considerations": "The security is enhanced from ERC721, given tokens are minted without having to\nprovideURIs. Errors in dealing withURIs can be avoided.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 3772, "url": "https://eips.ethereum.org/EIPS/eip-3772", "title": "Compressed Integers", "authors": ["Soham Zemse\u00a0(", "@zemse", ")"], "sections": {"ERC-3772: Compressed Integers": "This document specifies compression ofuint256to smaller data structures likeuint64,uint96,uint128, for optimizing costs for storage. The smaller data structure (represented ascintx) is divided into two parts, in the first one we storesignificantbits and in the other number of leftshifts needed on the significant bits to decompress. This document also includes two specifications for decompression due to the nature of compression being lossy, i.e. it causes underflow.", "Using lossy compression on uint256 to improve gas costs, ideally by a factor up to 4x.": "This document specifies compression ofuint256to smaller data structures likeuint64,uint96,uint128, for optimizing costs for storage. The smaller data structure (represented ascintx) is divided into two parts, in the first one we storesignificantbits and in the other number of leftshifts needed on the significant bits to decompress. This document also includes two specifications for decompression due to the nature of compression being lossy, i.e. it causes underflow.", "Abstract": "This document specifies compression ofuint256to smaller data structures likeuint64,uint96,uint128, for optimizing costs for storage. The smaller data structure (represented ascintx) is divided into two parts, in the first one we storesignificantbits and in the other number of leftshifts needed on the significant bits to decompress. This document also includes two specifications for decompression due to the nature of compression being lossy, i.e. it causes underflow.", "Motivation": "In this specification, the structure for representing a compressed value is represented usingcintx, where x is the number of bits taken by the entire compressed value. On the implementation level, anuintxcan be used for storing acintxvalue.", "Specification": "In this specification, the structure for representing a compressed value is represented usingcintx, where x is the number of bits taken by the entire compressed value. On the implementation level, anuintxcan be used for storing acintxvalue.", "Compression": "The rightmost, or least significant, 8 bits incintxare reserved for storing the shift and the rest available bits are used to store the significant bits starting from the first1bit inuintx.", "Decompression": "Two decompression methods are defined: a normaldecompressand adecompressRoundingUp.", "Rationale": "There are no known backward-incompatible issues.", "Backwards Compatibility": "There are no known backward-incompatible issues.", "Reference Implementation": "On the implementation leveluint64may be used directly, or with custom types introduced in 0.8.9.", "Security Considerations": "The following security considerations are discussed:", "1. Effects due to lossy compression": "When a value is compressed, it causes underflow, i.e. some less significant bits are sacrificed. This results in acintxvalue whose decompressed value is less than or equal to the actualuint256value.", "2. Losing precision due to incorrect use ofcintx": "This is an example where dev errors while using compression can be a problem.", "3. Compressing something other than moneyuint256s.": "Compressed Integers is intended to only compress money amount. Technically there are about 1077values that auint256can store but most of those values have a flat distribution i.e. the probability is 0 or extremely negligible. (What is a probability that a user would be depositing 1000T DAI or 1T ETH to a contract? In normal circumstances it doesn\u2019t happen, unless someone has full access to the mint function). Only the amounts that people work with have a non-zero distribution ($0.001 DAI to $1T or 1015to 1030in uint256). 50 bits are enough to represent this information, just to round it we use 56 bits for precision.", "4. Compressing Stable vs Volatile money amounts": "Since we have a dynamicuint8 shiftvalue that can move around. So even if you wanted to represent 1 Million SHIBA INU tokens or 0.0002 WBTC (both $10 as of this writing), cint64 will pick its top 56 significant bits which will take care of the value representation.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4341, "url": "https://eips.ethereum.org/EIPS/eip-4341", "title": "Ordered NFT Batch Standard", "authors": ["Simon Tian\u00a0(", "@simontianx", ")"], "sections": {"ERC-4341: Ordered NFT Batch Standard": "This standard introduces a smart contract interface that can represent a batch\nof non-fungible tokens of which the ordering information shall be retained and\nmanaged. Such information is particularly useful iftokenIds are encoded with\nthe sets ofunicodesfor logographic characters and emojis. As a result, NFTs\ncan be utilized as carriers of meanings.", "The ordering information of multiple NFTs is retained and managed": "This standard introduces a smart contract interface that can represent a batch\nof non-fungible tokens of which the ordering information shall be retained and\nmanaged. Such information is particularly useful iftokenIds are encoded with\nthe sets ofunicodesfor logographic characters and emojis. As a result, NFTs\ncan be utilized as carriers of meanings.", "Abstract": "This standard introduces a smart contract interface that can represent a batch\nof non-fungible tokens of which the ordering information shall be retained and\nmanaged. Such information is particularly useful iftokenIds are encoded with\nthe sets ofunicodesfor logographic characters and emojis. As a result, NFTs\ncan be utilized as carriers of meanings.", "Motivation": "Non-fungible tokens are widely accepted as carriers of crypto-assets, hence in bothERC-721andERC-1155, the ordering information of \nmultiple NFTs is discarded. However, as proposed inEIP-3754, \nnon-fungible tokens are thought of as basic units on a blockchain and can carry \nabstract meanings with unicodedtokenIds. Transferring such tokens is transmitting \nan ordered sequence of unicodes, thus effectively transmitting phrases or meanings \non a blockchain.", "Specification": "InERC-1155andERC-721, NFTs are used to represent\ncrypto-assets, and in this standard together withEIP-3754, NFTs\nare equipped with utilities. In this standard, the ordering information of a batch\nof NFTs is retained and managed through a constructphrase.", "Rationale": "InERC-1155andERC-721, NFTs are used to represent\ncrypto-assets, and in this standard together withEIP-3754, NFTs\nare equipped with utilities. In this standard, the ordering information of a batch\nof NFTs is retained and managed through a constructphrase.", "Phrase": "Aphraseis usually made of a handful of basic characters or an orderred sequence\nof unicodes and is able to keep the ordering information in a batch of tokens.\nTechnically, it is stored in an array of unsigned integers, and is not supposed\nto be disseminated. A phrase does not increase or decrease the amount of any NFT\nin anyway. A phrase cannot be transferred, however, it can be retrieved and\ndecoded to restore the original sequence of unicodes. The phrase information\nis kept in storage and hence additional storage thanERC-1155is required.", "Backwards Compatibility": "EIP-3754is the pre-requisite to this standard.", "Reference Implementation": "https://github.com/simontianx/ERC4341", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4353, "url": "https://eips.ethereum.org/EIPS/eip-4353", "title": "Interface for Staked Tokens in NFTs", "authors": ["Rex Creed\u00a0(", "@aug2uag", ")", "Dane Scarborough\u00a0<", "dane@nftapps.us", ">"], "sections": {"ERC-4353: Interface for Staked Tokens in NFTs": "EIP-721tokens can be deposited or staked in NFTs for a variety of reasons including escrow, rewards, benefits, and others. There is currently no means of retrieving the number of tokens staked and/or bound to an NFT. This proposal outlines a standard that may be implemented by all wallets and marketplaces easily to correctly retrieve the staked token amount of an NFT.", "This interface enables access to publicly viewable staking data of an NFT.": "EIP-721tokens can be deposited or staked in NFTs for a variety of reasons including escrow, rewards, benefits, and others. There is currently no means of retrieving the number of tokens staked and/or bound to an NFT. This proposal outlines a standard that may be implemented by all wallets and marketplaces easily to correctly retrieve the staked token amount of an NFT.", "Abstract": "EIP-721tokens can be deposited or staked in NFTs for a variety of reasons including escrow, rewards, benefits, and others. There is currently no means of retrieving the number of tokens staked and/or bound to an NFT. This proposal outlines a standard that may be implemented by all wallets and marketplaces easily to correctly retrieve the staked token amount of an NFT.", "Motivation": "Without staked token data, the actual amount of staked tokens cannot be conveyed from token owners to other users, and cannot be displayed in wallets, marketplaces, or block explorers. The ability to identify and verify an exogenous value derived from the staking process may be critical to the aims of an NFT holder.", "Specification": "The suggested and intended implementation of this standard is to stake tokens at the time of minting an NFT, and not implementing any outbound transfer of tokens outside ofburn. Therefore, only to stake at minting and withdraw only at burning.", "Suggested flow:": "The suggested and intended implementation of this standard is to stake tokens at the time of minting an NFT, and not implementing any outbound transfer of tokens outside ofburn. Therefore, only to stake at minting and withdraw only at burning.", "Staking at mint and locking tokens in NFT": "The suggested and intended implementation of this standard is to stake tokens at the time of minting an NFT, and not implementing any outbound transfer of tokens outside ofburn. Therefore, only to stake at minting and withdraw only at burning.", "Rationale": "This standard is completely agnostic to how tokens are deposited or handled by the NFT. It is, therefore, the choice and responsibility of the author to encode and communicate the encoding of their tokenomics to purchasees of their token and/or to make their contracts viewable by purchasees.", "Backward Compatibility": "TBD", "Test Cases": "The purpose of this standard is to simply and publicly identify whether an NFT claims to have staked tokens.", "Security Considerations": "The purpose of this standard is to simply and publicly identify whether an NFT claims to have staked tokens.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4393, "url": "https://eips.ethereum.org/EIPS/eip-4393", "title": "Micropayments for NFTs and Multi Tokens", "authors": ["Jules Lai\u00a0(", "@julesl23", ")"], "sections": {"ERC-4393: Micropayments for NFTs and Multi Tokens": "This standard outlines a smart contract interface for tipping to non-fungible and multi tokens. Holders of the tokens are able to withdraw the tips asEIP-20rewards.", "An interface for tip tokens that allows tipping to holders of NFTs and multi tokens": "This standard outlines a smart contract interface for tipping to non-fungible and multi tokens. Holders of the tokens are able to withdraw the tips asEIP-20rewards.", "Abstract": "This standard outlines a smart contract interface for tipping to non-fungible and multi tokens. Holders of the tokens are able to withdraw the tips asEIP-20rewards.", "Motivation": "A cheap way to send tips to any type of NFT or multi token. This can be achieved by gas optimising the tip token contract and sending the tips in batches using thetipBatchfunction from the interface.", "Specification": "This standard proposal outlines a generalised way to allow tipping via implementation of anITipTokeninterface. The interface is intentionally kept to a minimum in order to allow for maximum use cases.", "Tipping and rewards to holders": "A user first deposits a compatible EIP-20 to the tip token contract that is then held (less any agreed fee) in escrow, in exchange for tip tokens. These tip tokens can then be sent by the user to NFTs and multi tokens (that have been approved by the tip token contract for tipping) to be redeemed for the original EIP-20 deposits on withdrawal by the holders as rewards.", "Tip Token transfer and value calculations": "Tip token values are exchanged with EIP-20 deposits and vice-versa. It is left to the tip token implementer to decide on the price of a tip token and hence how much tip to mint in exchange for the EIP-20 deposited. One possibility is to have fixed conversion rates per geographical region so that users from poorer countries are able to send the same number of tips as those from richer nations for the same level of appreciation for content/assets etc. Hence, not skewed by average wealth when it comes to analytics to discover what NFTs are actually popular, allowing creators to have a level playing field.", "Royalty distribution": "EIP-1155 allows for shared holders of a token id. Imagine a scenario where an article represented by an NFT was written by multiple contributors. Here, each contributor is a holder and the fractional sharing percentage between them can be represented by the balance that each holds in the EIP-1155 token id. So for two holders A and B of EIP-1155 token 1, if holder A\u2019s balance is 25 and holder B\u2019s is 75 then any tip sent to token 1 would distribute 25% of the reward pending to holder A and the remaining 75% pending to holder B.", "Caveats": "To keep theITipTokeninterface simple and general purpose, each tip token contract MUST use one EIP-20 compatible deposit type at a time. If tipping is required to support many EIP-20 deposits then each tip token contract MUST be deployed separately per EIP-20 compatible type required. Thus, if tipping is required from both ETH and BTC wrapper EIP-20 deposits then the tip token contract is deployed twice. The tip token contract\u2019s constructor is REQUIRED to pass in the address of the EIP-20 token supported for the deposits for the particular tip token contract. Or in the case for upgradeable tip token contracts, an initialize method is REQUIRED to pass in the EIP-20 token address.", "Minimising Gas Costs": "By caching tips off-chain and then batching them up to call thetipBatchmethod of the ITipToken interface then essentially the cost of initialising transactions is paid once rather than once per tip. Plus, further gas savings can be made off-chain if multiple tips sent by the same user to the same NFT token are accumulated together and sent as one entry in the batch.", "Rationale": "ITipToken interface uses a minimal number of functions, in order to keep its use as general purpose as possible, whilst there being enough to guide implementation that fulfils its purpose for micropayments to NFT holders.", "Simplicity": "ITipToken interface uses a minimal number of functions, in order to keep its use as general purpose as possible, whilst there being enough to guide implementation that fulfils its purpose for micropayments to NFT holders.", "Use of NFTs": "Each NFT is a unique non-fungible token digital asset stored on the blockchain that are uniquely identified by its address and token id. It\u2019s truth burnt using cryptographic hashing on a secure blockchain means that it serves as an anchor for linking with a unique digital asset, service or other contractual agreement. Such use cases may include (but only really limited by imagination and acceptance):", "New Business Models": "To take the music use case for example. Traditionally since the industry transitioned from audio distributed on physical medium such as CDs, to an online digital distribution model via streaming, the music industry has been controlled by oligopolies that served to help in the transition. They operate a fixed subscription model and from that they set the amount of royalty distribution to content creators; such as the singers, musicians etc. Using tip tokens represent an additional way for fans of music to reward the content creators. Each song or track is represented by an NFT and fans are able to tip the song (hence the NFT) that they like, and in turn the content creators of the NFT are able to receive the EIP-20 rewards that the tips were bought for. A fan led music industry with decentralisation and tokenisation is expected to bring new revenue, and bring fans and content creators closer together.", "Guaranteed audit trail": "As the Ethereum ecosystem continues to grow, many dapps are relying on traditional databases and explorer API services to retrieve and categorize data. This EIP standard guarantees that event logs emitted by the smart contract MUST provide enough data to create an accurate record of all current tip token and EIP-20 reward balances. A database or explorer can provide indexed and categorized searches of every tip token and reward sent to NFT holders from the events emitted by any tip token contract that implements this standard. Thus, the state of the tip token contract can be reconstructed from the events emitted alone.", "Backwards Compatibility": "A tip token contract can be fully compatible with EIP-20 specification and inherit some functions such as transfer if the tokens are allowed to be sent directly to other users. Note that balanceOf has been adopted and MUST be the number of tips held by a user\u2019s address. If inheriting from, for example, OpenZeppelin\u2019s implementation of EIP-20 token then their contract is responsible for maintaining the balance of tip token. Therefore, tip token balanceOf function SHOULD simply directly call the parent (super) contract\u2019s balanceOf function.", "Security Considerations": "Though it is RECOMMENDED that users\u2019 deposits are kept locked in the tip token contract or external escrow account, and SHOULD NOT be used for anything but the rewards for holders, this cannot be enforced. This standard stipulates that the rewards MUST be available for when holders withdraw their rewards from the pool of deposits.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- withdrawal: Log entry in system_logs for tracking withdrawals under EIP-4895 .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4430, "url": "https://eips.ethereum.org/EIPS/eip-4430", "title": "Described Transactions", "authors": ["Richard Moore\u00a0(", "@ricmoo", ")", "Nick Johnson\u00a0(", "@arachnid", ")"], "sections": {"ERC-4430: Described Transactions": "Use a contract method to providevirtual functionswhich can generate\na human-readable description at the same time as the machine-readable\nbytecode, allowing the user to agree to the human-readable component\nin a UI while the machine can execute the bytecode once accepted.", "A technique for contracts to provide a human-readable description of a transaction's side-effects.": "Use a contract method to providevirtual functionswhich can generate\na human-readable description at the same time as the machine-readable\nbytecode, allowing the user to agree to the human-readable component\nin a UI while the machine can execute the bytecode once accepted.", "Abstract": "Use a contract method to providevirtual functionswhich can generate\na human-readable description at the same time as the machine-readable\nbytecode, allowing the user to agree to the human-readable component\nin a UI while the machine can execute the bytecode once accepted.", "Motivation": "When using an Ethereum Wallet (e.g. MetaMask, Clef, Hardware Wallets)\nusers must accept a transaction before it can be submitted (or the user\nmay decline).", "Specification": "Thedescription(a string) and the matchingexeccode(bytecode)\nare generated simultaneously by evaluating the method on a contract:", "Rationale": "There have been many attempts to solve this problem, many of which attempt\nto examine the encoded transaction data or message data directly.", "Meta Description": "There have been many attempts to solve this problem, many of which attempt\nto examine the encoded transaction data or message data directly.", "Entangling the Contract Address": "To prevent signed data being used across contracts, the contract address\nis entanlged into both the transaction implicitly via thetofield.", "Alternatives": "This does not affect backwards compatibility.", "Backwards Compatibility": "This does not affect backwards compatibility.", "Reference Implementation": "I will add deployed examples by address and chain ID.", "Security Considerations": "Wallets must be careful when displaying text provided by contracts and proper\nefforts must be taken to sanitize it, for example, be sure to consider:", "Escaping Text": "Wallets must be careful when displaying text provided by contracts and proper\nefforts must be taken to sanitize it, for example, be sure to consider:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4494, "url": "https://eips.ethereum.org/EIPS/eip-4494", "title": "Permit for ERC-721 NFTs", "authors": ["Simon Fremaux\u00a0(", "@dievardump", ")", "William Schwab\u00a0(", "@wschwab", ")"], "sections": {"ERC-4494: Permit for ERC-721 NFTs": "The \u201cPermit\u201d approval flow outlined inERC-2612has proven a very valuable advancement in UX by creating gasless approvals for ERC20 tokens. This EIP extends the pattern to ERC-721 NFTs. This EIP borrows heavily from ERC-2612.", "ERC-712-singed approvals for ERC-721 NFTs": "The \u201cPermit\u201d approval flow outlined inERC-2612has proven a very valuable advancement in UX by creating gasless approvals for ERC20 tokens. This EIP extends the pattern to ERC-721 NFTs. This EIP borrows heavily from ERC-2612.", "Abstract": "The \u201cPermit\u201d approval flow outlined inERC-2612has proven a very valuable advancement in UX by creating gasless approvals for ERC20 tokens. This EIP extends the pattern to ERC-721 NFTs. This EIP borrows heavily from ERC-2612.", "Motivation": "The permit structure outlined inERC-2612allows for a signed message (structured as outlined inERC-712) to be used in order to create an approval. Whereas the normal approval-based pull flow generally involves two transactions, one to approve a contract and a second for the contract to pull the asset, which is poor UX and often confuses new users, a permit-style flow only requires signing a message and a transaction. Additional information can be found inERC-2612.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "Thepermitfunction is sufficient for enabling asafeTransferFromtransaction to be made without the need for an additional transaction.", "Backwards Compatibility": "There are already some ERC-721 contracts implementing apermit-style architecture, most notably Uniswap v3.", "Test Cases": "Basic test cases for the reference implementation can be foundhere.", "Reference Implementation": "A reference implementation has been set uphere.", "Security Considerations": "Extra care should be taken when creating transfer functions in whichpermitand a transfer function can be used in one function to make sure that invalid permits cannot be used in any way. This is especially relevant for automated NFT platforms, in which a careless implementation can result in the compromise of a number of user assets.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4521, "url": "https://eips.ethereum.org/EIPS/eip-4521", "title": "721/20-compatible transfer", "authors": ["Ross Campbell\u00a0(", "@z0r0z", ")"], "sections": {"ERC-4521: 721/20-compatible transfer": "ERC-721, the popular standard for non-fungible tokens (NFTs), includes send functions, such astransferFrom()andsafeTransferFrom(), but does not include a backwards-compatibletransfer()found in fungible ERC-20 tokens. This standard provides references to add such atransfer().", "Recommends a simple extension to make NFTs compatible with apps and contracts that handle fungibles.": "ERC-721, the popular standard for non-fungible tokens (NFTs), includes send functions, such astransferFrom()andsafeTransferFrom(), but does not include a backwards-compatibletransfer()found in fungible ERC-20 tokens. This standard provides references to add such atransfer().", "Abstract": "ERC-721, the popular standard for non-fungible tokens (NFTs), includes send functions, such astransferFrom()andsafeTransferFrom(), but does not include a backwards-compatibletransfer()found in fungible ERC-20 tokens. This standard provides references to add such atransfer().", "Motivation": "This standard proposes a simple extension to allow NFTs to work with contracts designed to manage ERC-20s and many consumer wallets which expect to be able to execute a tokentransfer(). For example, if an NFT is inadvertently sent to a contract that typically handles ERC-20, that NFT will be locked. It should also simplify the task for contract programmers if they can rely ontransfer()to both handle ERC-20 and NFTs.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "Replicating ERC-20transfer()with just a minor change to accurately reflect that a uniquetokenIdrather than fungible sum is being sent is desirable for code simplicity and to make integration easier.", "Backwards Compatibility": "This EIP does not introduce any known backward compatibility issues.", "Reference Implementation": "A reference implementation of an ERC-4521transfer():", "Security Considerations": "Implementers must be sure to include the relevant returnboolvalue for an ERC-4521 in order to conform with existing contracts that use ERC-20 interfaces, otherwise, NFTs may be locked unless asafeTransferis used in such contracts.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4524, "url": "https://eips.ethereum.org/EIPS/eip-4524", "title": "Safer ERC-20", "authors": ["William Schwab\u00a0(", "@wschwab", ")"], "sections": {"ERC-4524: Safer ERC-20": "This standard extendsERC-20tokens withEIP-165, and adds familiar functions fromERC-721andERC-1155ensuring receiving contracts have implemented proper functionality.", "Extending ERC-20 with ERC165 and adding safeTransfer (like ERC-721 and ERC-1155)": "This standard extendsERC-20tokens withEIP-165, and adds familiar functions fromERC-721andERC-1155ensuring receiving contracts have implemented proper functionality.", "Abstract": "This standard extendsERC-20tokens withEIP-165, and adds familiar functions fromERC-721andERC-1155ensuring receiving contracts have implemented proper functionality.", "Motivation": "EIP-165adds (among other things) the ability to tell if a target recipient explicitly signals compatibility with an ERC. This is already used in the EIPs for NFTs,ERC-721andERC-1155. In addition, EIP-165 is a valuable building block for extensions on popular standards to signal implementation, a trend we\u2019ve seen in a number of NFT extensions. This EIP aims to bring these innovations back to ERC-20.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "This EIP is meant to be minimal and straightforward. Adding EIP-165 to ERC-20 is useful for a number of applications, and outside of a minimal amount of code increasing contract size, carries no downside. ThesafeTransferandsafeTransferFromfunctions are well recognized from ERC-721 and ERC-1155, and therefore keeping identical naming conventions is reasonable, and the benefits of being able to check for implementation before transferring are as useful for ERC-20 tokens as they are for ERC-721 and ERC-1155.", "Backwards Compatibility": "There are no issues with backwards compatibility in this EIP, as the full suite of ERC-20 functions is unchanged.", "Test Cases": "Test cases have been provided in the implementation repohere.", "Reference Implementation": "A sample repo demonstrating an implementation of this EIP has been createdhere. It is (as of this writing) in a Dapptools environment, for details on installing and running Dapptools see the Dapptools repo.", "Security Considerations": "onERC20Receivedis a callback function. Callback functions have been exploited in the past as a reentrancy vector, and care should be taken to make sure implementations are not vulnerable.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4527, "url": "https://eips.ethereum.org/EIPS/eip-4527", "title": "QR Code transmission protocol for wallets", "authors": ["Aaron Chen\u00a0(", "@aaronisme", ")", "Sora Lee\u00a0(", "@soralit", ")", "ligi\u00a0(", "@ligi", ")", "Dan Miller\u00a0(", "@danjm", ")", "AndreasGassmann\u00a0(", "@andreasgassmann", ")", "xardass\u00a0(", "@xardass", ")", "Lixin Liu\u00a0(", "@BitcoinLixin", ")"], "sections": {"ERC-4527: QR Code transmission protocol for wallets": "The purpose of this EIP is to provide a process and data transmission protocol via QR Code between offline signers and watch-only wallets.", "QR Code data transmission protocol between wallets and offline signers.": "The purpose of this EIP is to provide a process and data transmission protocol via QR Code between offline signers and watch-only wallets.", "Abstract": "The purpose of this EIP is to provide a process and data transmission protocol via QR Code between offline signers and watch-only wallets.", "Motivation": "There is an increasing number of users whom like to use complete offline signers to manage their private keys, signers like hardware wallets and mobile phones in offline mode. In order to sign transactions or data, these offline signers have to rely on a watch-only wallet since it would prepare the data to be signed. Currently, there are 4 possible data transmission methods between offline signers and watch-only wallets: QR Code, USB, Bluetooth, and file transfer. The QR Code data transmission method have the following advantages when compared to the other three methods mentioned above:", "Specification": "Offline signer: An offline signer is a device or application which holds the user\u2019s private keys and does not have network access.", "Process": "In order to work with offline signers, the watch-only wallet should follow the following process.", "Data Transmission Protocol": "Since a single QR Code can only contain a limited amount of data, animated QR Codes should be utilized for data transmission. TheBlockchainCommonshave published a series of data transmission protocol called Uniform Resources (UR). It provides a basic method to encode data into animated QR Codes. This EIP will use UR and extend its current definition.", "Setting up the watch-only wallet with the offline signer": "In order to allow a watch-only wallet to collect information from the Ethereum blockchain, the offline signer would need to provide the public keys to the watch-only wallet in which the wallet will use them to query the necessary information from the Ethereum blockchain.", "Sending the unsigned data from the watch-only wallet to the offline signer": "To send the unsigned data from a watch-only wallet to an offline signer, the new UR typeeth-sign-requestwill be introduced to encode the signing request.", "The signature provided by offline signers to watch-only wallets": "After the data is signed, the offline signer should send the signature back to the watch-only wallet. The new UR type calledeth-signatureis introduced here to encode this data.", "Rationale": "This EIP uses some existing UR types likecrypto-keypathandcrypto-hdkeyand also introduces some new UR types likeeth-sign-requestandeth-signature. Here are the reasons we choose UR for the QR Code data transmission protocol:", "UR provides a solid foundation for QR Code data transmission": "Currently, UR has provided some existing types likecrypto-keypathandcrypto-hdkeyso it is quite easy to add a new type and definitions for new usages.", "UR provides existing helpful types and scalability for new usages": "Currently, UR has provided some existing types likecrypto-keypathandcrypto-hdkeyso it is quite easy to add a new type and definitions for new usages.", "UR has an active air-gapped wallet community.": "Currently, the UR has an activeairgapped wallet communitywhich continues to improve the UR forward.", "Backwards Compatibility": "Currently, there is no existing protocol to define data transmissions via QR Codes so there are no backward compatibility issues that needs to be addressed now.", "Test Cases": "The test cases can be found on theur-registry-ethpackage released by the Keystone team.", "Reference Implementation": "The reference implementation can be found on theur-registry-ethpackage released by the Keystone team.", "Security Considerations": "The offline signer should decode all the data frometh-sign-requestand show them to the user for confirmation prior to signing. It is recommended to provide an address field in theeth-sign-request. If provided, the offline signer should verify the address being the same one as the address associated with the signing key.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4546, "url": "https://eips.ethereum.org/EIPS/eip-4546", "title": "Wrapped Deposits", "authors": ["Justice Hudson\u00a0(", "@jchancehud", ")"], "sections": {"ERC-4546: Wrapped Deposits": "The wrapped deposit contract handles deposits of assets (Ether,ERC-20,ERC-721) on behalf of a user. A user must only approve a spend limit once and then an asset may be deposited to any number of different applications that support deposits from the contract.", "A singleton contract for managing asset deposits.": "The wrapped deposit contract handles deposits of assets (Ether,ERC-20,ERC-721) on behalf of a user. A user must only approve a spend limit once and then an asset may be deposited to any number of different applications that support deposits from the contract.", "Abstract": "The wrapped deposit contract handles deposits of assets (Ether,ERC-20,ERC-721) on behalf of a user. A user must only approve a spend limit once and then an asset may be deposited to any number of different applications that support deposits from the contract.", "Motivation": "The current user flow for depositing assets in dapps is unnecessarily expensive and insecure. To deposit an ERC-20 asset a user must either:", "Specification": "The wrapped deposit contract SHOULD be deployed at an identifiable address (e.g.0x1111119a9e30bceadf9f939390293ffacef93fe9). The contract MUST be non-upgradable with no ability for state variables to be changed.", "Rationale": "Having a single contract that processes all token transfers allows users to submit a single approval per token to deposit to any number of contracts. The user does not have to trust receiving contracts with token spend approvals and receiving contracts have their complexity reduced by not having to implement token transfers themselves.", "Backwards Compatibility": "This EIP is not backward compatible. Any contract planning to use this deposit system must implement specific functions to accept deposits. Existing contracts that are upgradeable can add support for this EIP retroactively by implementing one or more accept deposit functions.", "Reference Implementation": "The wrapped deposit implementation should be as small as possible to reduce the risk of bugs. The contract should be small enough that an engineer can read and understand it in a few minutes.", "Security Considerations": "The wrapped deposit implementation should be as small as possible to reduce the risk of bugs. The contract should be small enough that an engineer can read and understand it in a few minutes.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4671, "url": "https://eips.ethereum.org/EIPS/eip-4671", "title": "Non-Tradable Tokens Standard", "authors": ["Omar Aflak\u00a0(", "@omaraflak", ")", "Pol-Malo Le Bris", "Marvin Martin\u00a0(", "@MarvinMartin24", ")"], "sections": {"ERC-4671: Non-Tradable Tokens Standard": "A non-tradable token, or NTT, represents inherently personal possessions (material or immaterial), such as university diplomas, online training certificates, government issued documents (national id, driving license, visa, wedding, etc.), labels, and so on.", "A standard interface for non-tradable tokens, aka badges or souldbound NFTs.": "A non-tradable token, or NTT, represents inherently personal possessions (material or immaterial), such as university diplomas, online training certificates, government issued documents (national id, driving license, visa, wedding, etc.), labels, and so on.", "Abstract": "A non-tradable token, or NTT, represents inherently personal possessions (material or immaterial), such as university diplomas, online training certificates, government issued documents (national id, driving license, visa, wedding, etc.), labels, and so on.", "Motivation": "We have seen in the past smart contracts being used to deliver university diplomas or driving licenses, for food labeling or attendance to events, and much more. All of these implementations are different, but they have a common ground: the tokens arenon-tradable.", "Specification": "A NTT contract is seen as representingone type of certificatedelivered byone authority. For instance, one NTT contract for the French National Id, another for Ethereum EIP creators, and so on\u2026", "Non-Tradable Token": "A NTT contract is seen as representingone type of certificatedelivered byone authority. For instance, one NTT contract for the French National Id, another for Ethereum EIP creators, and so on\u2026", "NTT Store": "Non-tradable tokens are meant to be fetched by third-parties, which is why there needs to be a convenient way for users to expose some or all of their tokens. We achieve this result using a store which must implement the following interface.", "Rationale": "A decision was made to keep the data off-chain (viatokenURI()) for two main reasons:", "On-chain vs Off-chain": "A decision was made to keep the data off-chain (viatokenURI()) for two main reasons:", "Reference Implementation": "You can find an implementation of this standard in../assets/eip-4671.", "Security Considerations": "One security aspect is related to thetokenURImethod which returns the metadata linked to a token. Since the standard represents inherently personal possessions, users might want to encrypt the data in some cases e.g. national id cards. Moreover, it is the responsibility of the contract creator to make sure the URI returned by this method is available at all times.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4675, "url": "https://eips.ethereum.org/EIPS/eip-4675", "title": "Multi-Fractional Non-Fungible Tokens", "authors": ["David Kim\u00a0(", "@powerstream3604", ")"], "sections": {"ERC-4675: Multi-Fractional Non-Fungible Tokens": "This standard outlines a smart contract interface eligible to represent any number of fractionalized non-fungible tokens. Existing projects utilizing standards likeEIP-1633conventionally deploy separateEIP-20compatible token contracts to fractionalize the non-fungible token into EIP-20 tokens. In contrast, this ERC allows each token ID to represent a token type representing(fractionalizing) the non-fungible token.", "Fractionalize multiple NFTs using a single contract": "This standard outlines a smart contract interface eligible to represent any number of fractionalized non-fungible tokens. Existing projects utilizing standards likeEIP-1633conventionally deploy separateEIP-20compatible token contracts to fractionalize the non-fungible token into EIP-20 tokens. In contrast, this ERC allows each token ID to represent a token type representing(fractionalizing) the non-fungible token.", "Abstract": "This standard outlines a smart contract interface eligible to represent any number of fractionalized non-fungible tokens. Existing projects utilizing standards likeEIP-1633conventionally deploy separateEIP-20compatible token contracts to fractionalize the non-fungible token into EIP-20 tokens. In contrast, this ERC allows each token ID to represent a token type representing(fractionalizing) the non-fungible token.", "Motivation": "The conventional fractionalization process of fractionalizing a NFT to FT requires deployment of a FT token contract representing the ownership of NFT. This leads to inefficient bytecode usage on Ethereum Blockchain and limits functionalities since each token contract is separated into its own permissioned address.\nWith the rise of multiple NFT projects needing to fractionalize NFT to FT, new type of token standard is needed to back up them.", "Specification": "To receive Non-Fungible Token onsafe Transferthe contract should includeonERC721Received().\nIncludingonERC721Received()is needed to be compatible with Safe Transfer Rules.", "Rationale": "Metadata", "Backwards Compatibility": "To make this standard compatible with existing standards, this standardevent&functionnames are identical with ERC-20 token standard with some moreevents&functionsto add token type dynamically.", "Test Cases": "Reference Implementation of MFNFT Token includes test cases written using hardhat. (Test coverage : 100%)", "Reference Implementation": "MFNFT - Implementation", "Security Considerations": "To fractionalize an already minted NFT, it is evident that ownership of NFT should be given to token contracts before fractionalization.\nIn the case of fractionalizing NFT, the token contract should thoroughly verify the ownership of NFT before fractionalizing it to prevent tokens from being a separate tokens with the NFT.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4799, "url": "https://eips.ethereum.org/EIPS/eip-4799", "title": "Non-Fungible Token Ownership Designation Standard", "authors": ["David Buckman\u00a0(", "@davidbuckman", ")", "Isaac Buckman\u00a0(", "@isaacbuckman", ")"], "sections": {"ERC-4799: Non-Fungible Token Ownership Designation Standard": "The following defines a standard interface for designating ownership of an NFT to someone while the NFT is held in escrow by a smart contract. The standard allows for the construction of a directed acyclic graph of NFTs, where the designated owner of every NFT in a given chain is the terminal address of that chain. This enables the introduction of additional functionality to pre-existing NFTs, without having to give up the authenticity of the original. In effect, this means that all NFTs are composable and can be rented, used as collateral, fractionalized, and more.", "A standardized interface for designating ownership of an NFT": "The following defines a standard interface for designating ownership of an NFT to someone while the NFT is held in escrow by a smart contract. The standard allows for the construction of a directed acyclic graph of NFTs, where the designated owner of every NFT in a given chain is the terminal address of that chain. This enables the introduction of additional functionality to pre-existing NFTs, without having to give up the authenticity of the original. In effect, this means that all NFTs are composable and can be rented, used as collateral, fractionalized, and more.", "Abstract": "The following defines a standard interface for designating ownership of an NFT to someone while the NFT is held in escrow by a smart contract. The standard allows for the construction of a directed acyclic graph of NFTs, where the designated owner of every NFT in a given chain is the terminal address of that chain. This enables the introduction of additional functionality to pre-existing NFTs, without having to give up the authenticity of the original. In effect, this means that all NFTs are composable and can be rented, used as collateral, fractionalized, and more.", "Motivation": "Many NFTs aim to provide their holders with some utility - utility that can come in many forms. This can be the right to inhabit an apartment, access to tickets to an event, an airdrop of tokens, or one of the infinitely many other potential applications. However, in their current form, NFTs are limited by the fact that the only verifiable wallet associated with an NFT is the owner, so clients that want to distribute utility are forced to do so to an NFT\u2019s listed owner. This means that any complex ownership agreements must be encoded into the original NFT contract - there is no mechanism by which an owner can link the authenticity of their original NFT to any external contract.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "To maximize the future compatibility of the wrapping contract, we first defined a canonical NFT interface. We createdIERC4799NFT, an interface implicitly implemented by virtually all popular NFT contracts, including all deployed contracts that areERC-721compliant. This interface represents the essence of an NFT: a mapping from a token identifier to the address of a singular owner, represented by the functionownerOf.", "Backwards Compatibility": "TheIERC4799NFTinterface is backwards compatible withIERC721, asIERC721implicitly extendsIERC4799NFT. This means that the ERC-4799 standard, which wraps NFTs that implementERC4799NFT, is fully backwards compatible with ERC-721.", "Reference Implementation": "The primary security concern is that of malicious actors creating excessively long or cyclical chains of ownership, leading applications that attempt to query for the designated owner of a given token to run out of gas and be unable to function. To address this, clients are expected to always query considering amaxDepthparameter, cutting off computation after a certain number of chain traversals.", "Security Considerations": "The primary security concern is that of malicious actors creating excessively long or cyclical chains of ownership, leading applications that attempt to query for the designated owner of a given token to run out of gas and be unable to function. To address this, clients are expected to always query considering amaxDepthparameter, cutting off computation after a certain number of chain traversals.", "Long/Cyclical Chains of Ownership": "The primary security concern is that of malicious actors creating excessively long or cyclical chains of ownership, leading applications that attempt to query for the designated owner of a given token to run out of gas and be unable to function. To address this, clients are expected to always query considering amaxDepthparameter, cutting off computation after a certain number of chain traversals.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4885, "url": "https://eips.ethereum.org/EIPS/eip-4885", "title": "Subscription NFTs and Multi Tokens", "authors": ["Jules Lai\u00a0(", "@julesl23", ")"], "sections": {"ERC-4885: Subscription NFTs and Multi Tokens": "The following standard allows for the implementation of a standard API for subscribing to non-fungible and multi tokens.EIP-20tokens are deposited in exchange for subscription tokens that give the right to use said non-fungible and multi tokens for a specified time limited or unlimited period.", "An interface for subscription tokens that gives holders subscriptions to NFTs and multi tokens": "The following standard allows for the implementation of a standard API for subscribing to non-fungible and multi tokens.EIP-20tokens are deposited in exchange for subscription tokens that give the right to use said non-fungible and multi tokens for a specified time limited or unlimited period.", "Abstract": "The following standard allows for the implementation of a standard API for subscribing to non-fungible and multi tokens.EIP-20tokens are deposited in exchange for subscription tokens that give the right to use said non-fungible and multi tokens for a specified time limited or unlimited period.", "Motivation": "This standard offers a flexible, general purpose way to subscribe to the use of assets or services offered byEIP-721orEIP-1155contracts. From here on in, for the sake of simplicity, these contracts will be known as NFTs; the provider is the issuer of said NFTs and the subscriber(s) uses them.", "Specification": "The subscriber deposits EIP-20 to receive an NFT and subscription. Subscription tokens balance automatically decreases linearly over the lifetime of usage of the NFT, and use of the NFT is disabled once the subscription token balance falls to zero. The subscriber can top up the balance to extend the lifetime of the subscription by depositing EIP-20 tokens in exchange for more subscription tokens.", "Subscription token balances": "An example implementation mints an amount of subscription token that totals to one subscription token per day of the subscription period length paid for by the subscriber; for example a week would be for seven subscription tokens. The subscription token balance then decreases automatically at a rate of one token per day continuously and linearly over time until zero. ThebalanceOffunction can be implemented lazily by calculating the amount of subscription tokens left only when it is called as a view function, thus has no gas cost.", "Subscription token price": "Subscription token price paid per token per second can be calculated from theDepositevent parameters asdepositAmount/ (subscriptionTokenAmount*subscriptionPeriod)", "NFT metadata": "The NFT\u2019s metadata can store information of the asset/service offered to the subscriber by the provider for the duration of the subscription. This MAY be the terms and conditions of the agreed subscription service offered by the provider to the subscriber. It MAY also be the metadata of the NFT asset if this is offered directly. This standard is kept purposely general to cater for many different use cases of NFTs.", "Subscription expiry": "When the subscription token balance falls to zero for a subscriber (signifying that the subscription has expired) then it is up to the implementer on how to handle this for their particular use case. For example, a provider may stop streaming media service to a subscriber. For an NFT that represents an image stored off-chain, perhaps the NFT\u2019surifunction no longer returns back a link to its metadata.", "Caveats": "With some traditional subscription models based on fiat currencies, the subscribers\u2019 saved payment credentials are used to automatically purchase to extend the subscription period, at or just before expiry. This feature is not possible in this proposal specification as recurring payments will have to have allowance approved for signed by a subscriber for each payment when using purely cryptocurrencies.", "Rationale": "The subscription itself has value when it is exchanged for a deposit. This proposal enables subscriptions to be \u2018tokenised\u2019 thus secondary markets can exist where the subscription tokens can be bought and sold. For example, a fan might want to sell their season ticket, that gives access to live sporting events, on to another fan. This would not be as easily possible if there was only a date expiry extension feature added to NFTs.\nAn implementer can simply implement the rest of the EIP-20 functions for subscription tokens to be traded. It is left to the implementer to decide if the subscription service offered is non-fungible or fungible. If non-fungible then buying the subscription tokens would simply give the same period left to expiration. If fungible and the purchaser already had an existing subscription for the same service then their total subscription period can be extended by the amount of subscription tokens bought.", "Tokenisation of subscriptions": "The subscription itself has value when it is exchanged for a deposit. This proposal enables subscriptions to be \u2018tokenised\u2019 thus secondary markets can exist where the subscription tokens can be bought and sold. For example, a fan might want to sell their season ticket, that gives access to live sporting events, on to another fan. This would not be as easily possible if there was only a date expiry extension feature added to NFTs.\nAn implementer can simply implement the rest of the EIP-20 functions for subscription tokens to be traded. It is left to the implementer to decide if the subscription service offered is non-fungible or fungible. If non-fungible then buying the subscription tokens would simply give the same period left to expiration. If fungible and the purchaser already had an existing subscription for the same service then their total subscription period can be extended by the amount of subscription tokens bought.", "Cater for current and future uses of NFTs": "This proposal purposely keepstokenIdandurioptional in thesubcribeToNFTmethod to keep the specification general purpose. Some use cases such as pre-computed image NFT collections don\u2019t require a different \u2018uri\u2019, just a differenttokenIdfor each NFT. However, in other use cases such as those that require legal contracts between both parties, individualurilinks are probably required as the NFT\u2019s metadata may require information from both parties to be stored on immutable storage.", "Giving back users control": "Traditional subscription models, particularly with streaming services, control of the subscription model is totally with that of the central service provider. This proposal gives decentralised services a standard way to give control back to their users. Hence each user is able to develop their own subscription eco system and administer it towards one that suits theirs and their subscribers\u2019 needs.", "Backwards Compatibility": "A subscription token contract can be fully compatible with EIP-20 specification to allow, for example, transfers from one subscriber to another subscriber or user. EIP-20 methodsname,symbolandbalanceOfare already part of the specification of this proposal, and it is left to the implementer to choose whether to implement the rest of EIP-20\u2019s interface by considering their own use case.", "Security Considerations": "It is normal for service providers to receive subscriber payments upfront before the subscriber gets to use the service. Indeed this proposal via thedepositmethod follows this remit. It would therefore be possible that a service provider sets up, receives the deposits and then does not provide or provides the service poorly to its subscribers. This happens in the traditional world too and this proposal does not cover how to resolve this.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4886, "url": "https://eips.ethereum.org/EIPS/eip-4886", "title": "Proxy Ownership Register", "authors": ["Omnus Sunmo\u00a0(", "@omnus", ")"], "sections": {"ERC-4886: Proxy Ownership Register": "A proxy protocol that allows users to nominate a proxy address to act on behalf of another wallet address, together with a delivery address for new assets. Smart contracts and applications making use of the protocol can take a proxy address and lookup holding information for the nominator address. This has a number of practical applications, including allowing users to store valuable assets safely in a cold wallet and interact with smart contracts using a proxy address of low value. The assets in the nominator are protected as all contract interactions take place with the proxy address. This eliminates a number of exploits seen recently where users\u2019 assets are drained through a malicious contract interaction. In addition, the register holds a delivery address, allowing new assets to be delivered directly to a cold wallet address.", "A proxy ownership register allowing trustless proof of ownership between Ethereum addresses, with delegated asset delivery": "A proxy protocol that allows users to nominate a proxy address to act on behalf of another wallet address, together with a delivery address for new assets. Smart contracts and applications making use of the protocol can take a proxy address and lookup holding information for the nominator address. This has a number of practical applications, including allowing users to store valuable assets safely in a cold wallet and interact with smart contracts using a proxy address of low value. The assets in the nominator are protected as all contract interactions take place with the proxy address. This eliminates a number of exploits seen recently where users\u2019 assets are drained through a malicious contract interaction. In addition, the register holds a delivery address, allowing new assets to be delivered directly to a cold wallet address.", "Abstract": "A proxy protocol that allows users to nominate a proxy address to act on behalf of another wallet address, together with a delivery address for new assets. Smart contracts and applications making use of the protocol can take a proxy address and lookup holding information for the nominator address. This has a number of practical applications, including allowing users to store valuable assets safely in a cold wallet and interact with smart contracts using a proxy address of low value. The assets in the nominator are protected as all contract interactions take place with the proxy address. This eliminates a number of exploits seen recently where users\u2019 assets are drained through a malicious contract interaction. In addition, the register holds a delivery address, allowing new assets to be delivered directly to a cold wallet address.", "Motivation": "To make full use of Ethereum users often need to prove their ownership of existing assets. For example:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Definitions": "There are two main parts to the register - a nomination and a proxy record:", "EPS Specification": "There are two main parts to the register - a nomination and a proxy record:", "Solidity Interface Definition": "Nomination Exists", "Rationale": "The rationale for this EIP was to provide a way for all existing and future Ethereum assets to be have a \u2018beneficial owner\u2019 (the proxy) that is different to the address custodying the asset. The use of a register to achieve this ensures that changes to existing tokens are not required. The register stores a trustless proof, signed by both the nominator and proxy, that can be relied upon as a true representation of asset ownership.", "Backwards Compatibility": "The EIP is fully backwards compatible.", "Test Cases": "The full SDLC for this proposal has been completed and it is operation at 0xfa3D2d059E9c0d348dB185B32581ded8E8243924 on mainnet, ropsten and rinkeby. The contract source code is validated and available on etherscan. The full unit test suite is available in../assets/eip-4886/, as is the source code and example implementations.", "Reference Implementation": "Please see../assets/eip-4886/contracts", "Security Considerations": "The core intention of the EIP is to improve user security by better safeguarding assets and allowing greater use of cold wallet storage.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4931, "url": "https://eips.ethereum.org/EIPS/eip-4931", "title": "Generic Token Upgrade Standard", "authors": ["John Peterson\u00a0(", "@John-peterson-coinbase", ")", "Roberto Bayardo\u00a0(", "@roberto-bayardo", ")", "David N\u00fa\u00f1ez\u00a0(", "@cygnusv", ")"], "sections": {"ERC-4931: Generic Token Upgrade Standard": "The following standard allows for the implementation of a standard API forERC-20token upgrades. This standard specifies an interface that supports the conversion of tokens from one contract (called the \u201csource token\u201d) to those from another (called the \u201cdestination token\u201d), as well as several helper methods to provide basic information about the token upgrade (i.e. the address of the source and destination token contracts, the ratio that source will be upgraded to destination, etc.).", "Create a standard interface for upgrading ERC20 token contracts.": "The following standard allows for the implementation of a standard API forERC-20token upgrades. This standard specifies an interface that supports the conversion of tokens from one contract (called the \u201csource token\u201d) to those from another (called the \u201cdestination token\u201d), as well as several helper methods to provide basic information about the token upgrade (i.e. the address of the source and destination token contracts, the ratio that source will be upgraded to destination, etc.).", "Abstract": "The following standard allows for the implementation of a standard API forERC-20token upgrades. This standard specifies an interface that supports the conversion of tokens from one contract (called the \u201csource token\u201d) to those from another (called the \u201cdestination token\u201d), as well as several helper methods to provide basic information about the token upgrade (i.e. the address of the source and destination token contracts, the ratio that source will be upgraded to destination, etc.).", "Motivation": "Token contract upgrades typically require each asset holder to exchange their old tokens for new ones using a bespoke interface provided by the developers. This standard interface will allow asset holders as well as centralized and decentralized exchanges to conduct token upgrades more efficiently since token contract upgrade scripts will be essentially reusable. Standardization will reduce the security overhead involved in verifying the functionality of the upgrade contracts. It will also provide asset issuers clear guidance on how to effectively implement a token upgrade.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Token Upgrade Interface Contract": "Returns the address of the original (source) token that will be upgraded.", "Rationale": "There have been several notable ERC20 upgrades (Ex. Golem: GNT -> GLM) where the upgrade functionality is written directly into the token contracts. We view this as a suboptimal approach to upgrades since it tightly couples the upgrade with the existing tokens. This EIP promotes the use of a third contract to facilitate the token upgrade to decouple the functionality of the upgrade from the functionality of the token contracts. Standardizing the upgrade functionality will allow asset holders and exchanges to write simplified reusable scripts to conduct upgrades which will reduce the overhead of conducting upgrades in the future. The interface aims to be intentionally broad leaving much of the specifics of the upgrade to the implementer, so that the token contract implementations do not interfere with the upgrade process. Finally, we hope to create a greater sense of security and validity for token upgrades by enforcing strict means of disposing of the source tokens during the upgrade. This is achieved by the specification of theupgrademethod. The agreed upon norm is that burnable tokens shall be burned. Otherwise, tokens shall be effectively burned by being sent to the0x00address. When downgrade Optional Ext. is implemented, the default is instead to lock source tokens in the upgrade contract to avoid a series of consecutive calls toupgradeanddowngradefrom artificially inflating the supply of either token (source or destination).", "Backwards Compatibility": "There are no breaking backwards compatibility issues. There are previously implemented token upgrades that likely do not adhere to this standard. In these cases, it may be relevant for the asset issuers to communicate that their upgrade is not EIP-4931 compliant.", "Reference Implementation": "The main security consideration is ensuring the implementation of the interface handles the source tokens during the upgrade in such a way that they are no longer accessible. Without careful handling, the validity of the upgrade may come into question since source tokens could potentially be upgraded multiple times. This is why EIP-4931 will strictly enforce the use ofburnfor source tokens that are burnable. For non-burnable tokens, the accepted method is to send the source tokens to the0x00address. When the downgrade Optional Ext. is implemented, the constraint will be relaxed, so that the source tokens can be held by the upgrade contract.", "Security Considerations": "The main security consideration is ensuring the implementation of the interface handles the source tokens during the upgrade in such a way that they are no longer accessible. Without careful handling, the validity of the upgrade may come into question since source tokens could potentially be upgraded multiple times. This is why EIP-4931 will strictly enforce the use ofburnfor source tokens that are burnable. For non-burnable tokens, the accepted method is to send the source tokens to the0x00address. When the downgrade Optional Ext. is implemented, the constraint will be relaxed, so that the source tokens can be held by the upgrade contract.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4944, "url": "https://eips.ethereum.org/EIPS/eip-4944", "title": "Contract with Exactly One Non-fungible Token", "authors": ["V\u00edctor Mu\u00f1oz\u00a0(", "@victormunoz", ")", "Josep Lluis de la Rosa\u00a0(", "@peplluis7", ")", "Andres El-Fakdi\u00a0(", "@Bluezfish", ")"], "sections": {"ERC-4944: Contract with Exactly One Non-fungible Token": "The following describes standard functions for anERC-721compatible contract with a total supply of one.\nThis allows an NFT to be associated uniquely with a single contract address.", "An ERC-721 compatible single-token NFT": "The following describes standard functions for anERC-721compatible contract with a total supply of one.\nThis allows an NFT to be associated uniquely with a single contract address.", "Abstract": "The following describes standard functions for anERC-721compatible contract with a total supply of one.\nThis allows an NFT to be associated uniquely with a single contract address.", "Motivation": "If the ERC-721 was modified to mint only 1 token (per contract), then the contract address could be identified uniquely with that minted token (instead of the tuple contract address + token id, as ERC-721 requires).\nThis change would enable automatically all the capabilities of composable tokensERC-998(own other ERC-721 orERC-20) natively without adding any extra code, just forbidding to mint more than one token per deployed contract.\nThen the NFT minted with this contract could operate with his \u201cbudget\u201d (the ERC-20 he owned) and also trade with the other NFTs he could own. Just like an autonomous agent, that could decide what to do with his properties (sell his NFTs, buy other NFTs, etc).", "Specification": "The constructor should mint the unique token of the contract, and then the mint function should add a restriction to avoid further minting.", "Rationale": "The main motivation is to keep the contract compatible with current ERC-721 platforms.", "Backwards Compatibility": "There are no backwards compatibility issues.", "Reference Implementation": "Add the variable_mintedin the contract:", "Security Considerations": "No security issues found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4950, "url": "https://eips.ethereum.org/EIPS/eip-4950", "title": "Entangled Tokens", "authors": ["V\u00edctor Mu\u00f1oz\u00a0(", "@victormunoz", ")", "Josep Lluis de la Rosa\u00a0(", "@peplluis7", ")", "Easy Innova\u00a0(", "@easyinnova", ")"], "sections": {"ERC-4950: Entangled Tokens": "This EIP defines an interface for delegating control of a smart contract wallet to pairs of users using entangledERC-721non-fungible tokens.", "ERC-721 extension with two tokens minted that are tied together": "This EIP defines an interface for delegating control of a smart contract wallet to pairs of users using entangledERC-721non-fungible tokens.", "Abstract": "This EIP defines an interface for delegating control of a smart contract wallet to pairs of users using entangledERC-721non-fungible tokens.", "Motivation": "The motivation is to provide an easy way to share a wallet through NFTs, so that the act of buying an NFT (in a marketplace) gives the buyer the privilege to have access to a given wallet. This wallet could have budget in many tokens, or even be the owner of other NFTs.", "Specification": "An entangled token contract implementsERC-721with the additional restriction that it only ever mints exactly two tokens at contract deployment: one with atokenIdof0, the other with atokenIdof1. The entangled token contract also implements a smart contract wallet that can be operated by the owners of those two tokens.", "Rationale": "We decide to extendERC-721(ERC-1155could be also possible) because the main purpose of this is to be compatible with current marketplaces platforms. This entangled NFTs will be listed in a marketplace, and the user who buys it will have then the possibility to transact with the wallet properties (fungible and non fungible tokens).", "Backwards Compatibility": "No backwards compatibility issues.", "Reference Implementation": "Mint two tokens, and only two, at the contract constructor, and set themintedproperty to true:", "Security Considerations": "There are no security considerations.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 4974, "url": "https://eips.ethereum.org/EIPS/eip-4974", "title": "Ratings", "authors": ["Daniel Tedesco\u00a0(", "@dtedesco1", ")"], "sections": {"ERC-4974: Ratings": "This standard defines a standardized interface for assigning and managing numerical ratings on the Ethereum blockchain. This allows ratings to be codified within smart contracts and recognized by other applications, enabling a wide range of new use cases for tokens.", "An interface for assigning and managing numerical ratings": "This standard defines a standardized interface for assigning and managing numerical ratings on the Ethereum blockchain. This allows ratings to be codified within smart contracts and recognized by other applications, enabling a wide range of new use cases for tokens.", "Abstract": "This standard defines a standardized interface for assigning and managing numerical ratings on the Ethereum blockchain. This allows ratings to be codified within smart contracts and recognized by other applications, enabling a wide range of new use cases for tokens.", "Motivation": "Traditionally, blockchain applications have focused on buying and selling digital assets. However, the asset-centric model has often been detrimental to community-based blockchain projects, as seen in the pay-to-play dynamics of many EVM-based games and DAOs in 2021.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "Ratings SHALL be at the sole discretion of the contract operator. This party may be a sports team coach or a multisig DAO wallet. We decide not to specify how governance occurs, but onlythatgovernance occurs. This allows for a wider range of potential use cases than optimizing for particular decision-making forms.", "Rating Assignment": "Ratings SHALL be at the sole discretion of the contract operator. This party may be a sports team coach or a multisig DAO wallet. We decide not to specify how governance occurs, but onlythatgovernance occurs. This allows for a wider range of potential use cases than optimizing for particular decision-making forms.", "Choice of int8": "It\u2019s signed: Reviewers should be able to give neutral and negative ratings for the wallets and contracts they interact with. This is especially important for decentralized applications that may be subject to malicious actors.", "Rating Changes": "Ratings SHOULD allow rating updates by contract operators. If Bob has contributed greatly to the community, but then is caught stealing from Alice, the community may decide this should lower Bob\u2019s standing and influence in the community. Again, while this does not ensure an ethical standard within the community, it opens the door.", "Interface Detection": "We chose Standard Interface Detection (EIP-165) to expose the interfaces that a compliant smart contract supports.", "Metadata Choices": "We have requirednameanddescriptionfunctions in the metadata extension.namecommon among major standards for blockchain-based primitives. We included adescriptionfunction that may be helpful for games or other applications with multiple ratings systems.", "Drawbacks": "One potential drawback of using this standard is that ratings are subjective and may not always accurately reflect the true value or quality of a contract or wallet. However, the standard provides mechanisms for updating and removing ratings, allowing for flexibility and evolution over time.", "Backwards Compatibility": "We have adopted thenamesemantics from the EIP-20 and EIP-721 specifications.", "Reference Implementation": "A reference implementation of this standard can be found in the assets folder.", "Security Considerations": "One potential security concern with this standard is the risk of malicious actors assigning false or misleading ratings to contracts or wallets. This could be used to manipulate voting weights in a DAO, or to deceive users into making poor decisions based on inaccurate ratings.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4987, "url": "https://eips.ethereum.org/EIPS/eip-4987", "title": "Held token interface", "authors": ["Devin Conley\u00a0(", "@devinaconley", ")"], "sections": {"ERC-4987: Held token interface": "The proposed standard defines a lightweight interface to expose functional ownership and balances of held tokens. A held token is a token owned by a contract. This standard may be implemented by smart contracts which holdEIP-20,EIP-721, orEIP-1155tokens and is intended to be consumed by both on-chain and off-chain systems that rely on ownership and balance verification.", "Interface to query ownership and balance of held tokens": "The proposed standard defines a lightweight interface to expose functional ownership and balances of held tokens. A held token is a token owned by a contract. This standard may be implemented by smart contracts which holdEIP-20,EIP-721, orEIP-1155tokens and is intended to be consumed by both on-chain and off-chain systems that rely on ownership and balance verification.", "Abstract": "The proposed standard defines a lightweight interface to expose functional ownership and balances of held tokens. A held token is a token owned by a contract. This standard may be implemented by smart contracts which holdEIP-20,EIP-721, orEIP-1155tokens and is intended to be consumed by both on-chain and off-chain systems that rely on ownership and balance verification.", "Motivation": "As different areas of crypto (DeFi, NFTs, etc.) converge and composability improves, there will more commonly be a distinction between the actual owner (likely a contract) and the functional owner (likely a user) of a token. Currently, this results in a conflict between mechanisms that require token deposits and systems that rely on those tokens for ownership or balance verification.", "Specification": "Smart contracts implementing theERC20held token standard MUST implement all of the functions in theIERC20Holderinterface.", "Rationale": "This interface is designed to be extremely lightweight and compatible with any existing token contract. Any token holder contract likely already stores all relevant information, so this standard is purely adding a common interface to expose that data.", "Backwards Compatibility": "Importantly, the proposed specification is fully compatible with all existing EIP-20, EIP-721, and EIP-1155 token contracts.", "Reference Implementation": "A full example implementation includinginterfaces, a vaulttoken holder, and aconsumer, can be found atassets/eip-4987/.", "Security Considerations": "Consumers of this standard should be cautious when using ownership information from unknown contracts. A bad actor could implement the interface, but report invalid or malicious information with the goal of manipulating a governance system, game, membership program, etc.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5005, "url": "https://eips.ethereum.org/EIPS/eip-5005", "title": "Zodiac Modular Accounts", "authors": ["Auryn Macmillan\u00a0(", "@auryn-macmillan", ")", "Kei Kreutler\u00a0(", "@keikreutler", ")"], "sections": {"ERC-5005: Zodiac Modular Accounts": "This EIP standardizes interfaces for composable and interoperable tooling for programmable Ethereum accounts. These interfaces separate contract accounts (\u201cavatars\u201d) from their authentication and execution logic (\u201cguards\u201d and \u201cmodules\u201d). Avatars implement theIAvatarinterface, and guards implement theIGuardinterface. Modules may take any form.", "Composable interoperable programmable accounts": "This EIP standardizes interfaces for composable and interoperable tooling for programmable Ethereum accounts. These interfaces separate contract accounts (\u201cavatars\u201d) from their authentication and execution logic (\u201cguards\u201d and \u201cmodules\u201d). Avatars implement theIAvatarinterface, and guards implement theIGuardinterface. Modules may take any form.", "Abstract": "This EIP standardizes interfaces for composable and interoperable tooling for programmable Ethereum accounts. These interfaces separate contract accounts (\u201cavatars\u201d) from their authentication and execution logic (\u201cguards\u201d and \u201cmodules\u201d). Avatars implement theIAvatarinterface, and guards implement theIGuardinterface. Modules may take any form.", "Motivation": "Currently, most programmable accounts (like DAO tools and frameworks) are built as monolithic systems where the authorization and execution logic are coupled, either within the same contract or in a tightly integrated system of contracts. This needlessly inhibits the flexibility of these tools and encourages platform lock-in via high switching costs.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "The interface defined in this standard is designed to be mostly compatible with most popular programmable accounts in use right now, to minimize the need for changes to existing tooling.", "Backwards Compatibility": "No backward compatibility issues are introduced by this standard.", "Security Considerations": "There are some considerations that module developers and users should take into account:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5018, "url": "https://eips.ethereum.org/EIPS/eip-5018", "title": "Filesystem-like Interface for Contracts", "authors": ["Qi Zhou\u00a0(", "@qizhou", ")"], "sections": {"ERC-5018: Filesystem-like Interface for Contracts": "The following standardizes an API for directories and files within smart contracts, similar to traditional filesystems.\nThis standard provides basic functionality to read/write binary objects of any size, as well as allow reading/writing chunks of the object if the object is too large to fit in a single transaction.", "An interface to provide access to binary objects similar to filesystems.": "The following standardizes an API for directories and files within smart contracts, similar to traditional filesystems.\nThis standard provides basic functionality to read/write binary objects of any size, as well as allow reading/writing chunks of the object if the object is too large to fit in a single transaction.", "Abstract": "The following standardizes an API for directories and files within smart contracts, similar to traditional filesystems.\nThis standard provides basic functionality to read/write binary objects of any size, as well as allow reading/writing chunks of the object if the object is too large to fit in a single transaction.", "Motivation": "A standard interface allows any binary objects on EVM-based blockchain to be re-used by other dApps.", "Specification": "Writes binarydatato the filenamein the directory by an account with write permission.", "Directory": "Writes binarydatato the filenamein the directory by an account with write permission.", "Rationale": "One issue of uploading the web contents to the blockchain is that the web contents may be too large to fit into a single transaction. As a result, the standard provides chunk-based operations so that uploading a content can be split into several transactions. Meanwhile, the read operation can be done in a single transaction, i.e., with a single Web3 URL defined in EIP-4804.", "Interactions Between Unchunked/Chunked Functions": "readmethod should return the concatenated chunked data written bywriteChunkmethod. The following gives some examples of the interactions:", "Backwards Compatibility": "No backwards compatibility issues were identified.", "Security Considerations": "No security considerations were found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5050, "url": "https://eips.ethereum.org/EIPS/eip-5050", "title": "Interactive NFTs with Modular Environments", "authors": ["Alexi\u00a0(", "@alexi", ")"], "sections": {"ERC-5050: Interactive NFTs with Modular Environments": "This standard defines a broadly applicable action messaging protocol for the transmission of user-initiated actions between tokens. Modular statefulness is achieved with optional state controller contracts (i.e. environments) that manage shared state, and provide arbitration and settlement of the action process.", "Action messaging and discovery protocol for interactions on and between NFTs": "This standard defines a broadly applicable action messaging protocol for the transmission of user-initiated actions between tokens. Modular statefulness is achieved with optional state controller contracts (i.e. environments) that manage shared state, and provide arbitration and settlement of the action process.", "Abstract": "This standard defines a broadly applicable action messaging protocol for the transmission of user-initiated actions between tokens. Modular statefulness is achieved with optional state controller contracts (i.e. environments) that manage shared state, and provide arbitration and settlement of the action process.", "Motivation": "Tokenized item standards such asEIP-721andEIP-1155serve as the objects of the Ethereum computing environment. A growing number of projects are seeking to build interactivity and\u201cdigital physics\u201dinto NFTs, especially in the contexts of gaming and decentralized identity. A standard action messaging protocol will allow this physics layer to be developed in the same open, Ethereum-native way as the objects they operate on.", "Benefits": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Action Naming": "Actions SHOULD use dot-separation for namespacing (e.g.\"spells.cast\"specifies the\"cast\"action with namespace\"spells\"), and arrow-separation for sequence specification (e.g.\"settle>build\"indicating\"settle\"must be received before\"build\").", "How State Contracts Work": "Actions do not require that a state contract be used. Actions can be transmitted from one token contract (Object) to another, or from a user to a single token contract. In these cases, the sending and receiving contracts each control their own state.", "Extensions": "Some contracts may have custom user interfaces that facilitate interaction.", "Rationale": "The critical features of this interactive token standard are that it 1) creates a common way to define, advertise, and conduct object interaction, 2) enables optional, brokered statefulness withusefulvalidity assurances at minimum gas overhead, 3) is easy for developers to implement, and 4) is easy for end-users to use.", "Action Names & Selectors": "Actions are advertised using human-readable strings, and processed using function selectors (bytes4(keccack256(action_key))). Human-readable strings allow end-users to easily interpret functionality, while function selectors allow efficient comparison operations on arbitrarily long action keys. This scheme also allows for simple namespacing and sequence specification.", "Validation": "Validation of the initiating contract via a hash of the action data was satisfactory to nearly everyone surveyed and was the most gas efficient verification solution explored. We recognize that this solution does not allow the receiving and state contracts to validate the initiatinguseraccount beyond usingtx.origin, which is vulnerable to phishing attacks.", "State Contracts": "Moving state logic into dedicated, parameterized contracts makes state an action primitive and prevents state management from being obscured within the contracts. Specifically, it allows users to decide which \u201cenvironment\u201d to commit the action in, and allows the initiating and receiving contracts to share state data without requiring them to communicate.", "Gas and Complexity (regarding action chaining)": "Action handling within each contract can be arbitrarily complex, and there is no way to eliminate the possibility that certain contract interactions will run out of gas. However, developers SHOULD make every effort to minimize gas usage in their action handler methods, and avoid the use of for-loops.", "Backwards Compatibility": "Non-upgradeable, already deployed token contracts will not be compatible with this standard unless a proxy registry extension is used.", "Reference Implementation": "A reference implementation is included in../assets/eip-5050with a simple stateless exampleExampleToken2Token.sol, and a stateful exampleExampleStateContract.sol", "Security Considerations": "The core security consideration of this protocol is action validation. Actions are passed from one contract to another, meaning it is not possible for the receiving contract to natively verify that the caller of the initiating contract matches theaction.fromaddress. One of the most important contributions of this protocol is that it provides an alternative to using signed messages, which require users to perform two operations for every action committed.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5058, "url": "https://eips.ethereum.org/EIPS/eip-5058", "title": "Lockable Non-Fungible Tokens", "authors": ["Tyler\u00a0(", "@radiocaca", ")", "Alex\u00a0(", "@gojazdev", ")", "John\u00a0(", "@sfumato00", ")"], "sections": {"ERC-5058: Lockable Non-Fungible Tokens": "We propose to extend theEIP-721standard with a secure locking mechanism. The NFT owners approve the operator to lock the NFT throughsetLockApprovalForAll()orlockApprove(). The approved operator locks the NFT throughlock(). The locked NFTs cannot be transferred until the end of the locking period. An immediate use case is to allow NFTs to participate in smart contracts without leaving the wallets of their owners.", "Lockable EIP-721 tokens": "We propose to extend theEIP-721standard with a secure locking mechanism. The NFT owners approve the operator to lock the NFT throughsetLockApprovalForAll()orlockApprove(). The approved operator locks the NFT throughlock(). The locked NFTs cannot be transferred until the end of the locking period. An immediate use case is to allow NFTs to participate in smart contracts without leaving the wallets of their owners.", "Abstract": "We propose to extend theEIP-721standard with a secure locking mechanism. The NFT owners approve the operator to lock the NFT throughsetLockApprovalForAll()orlockApprove(). The approved operator locks the NFT throughlock(). The locked NFTs cannot be transferred until the end of the locking period. An immediate use case is to allow NFTs to participate in smart contracts without leaving the wallets of their owners.", "Motivation": "NFTs, enabled byEIP-721, have exploded in demand. The total market value and the ecosystem continue to grow with more and more blue chip NFTs, which are approximately equivalent to popular intellectual properties in a conventional sense. Despite the vast success, something is left to be desired. Liquidity has always been one of the biggest challenges for NFTs. Several attempts have been made to tackle the liquidity challenge: NFTFi and BendDAO, to name a few. Utilizing the currently prevalent EIP-721 standard, these projects require participating NFTs to be transferred to the projects\u2019 contracts, which poses inconveniences and risks to the owners:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "An NFT owner can give another trusted operator the right to lock his NFT through the approve functions. ThelockApprove()function only approves for the specified NFT, whereassetLockApprovalForAll()approves for all NFTs of the collection under the wallet. When a user participates in an NFTFi project, the project contract callslock()to lock the user\u2019s NFT. Locked NFTs cannot be transferred, but the NFTFi project contract can use the unlock functionunlock()to unlock the NFT.", "NFT lock approvals": "An NFT owner can give another trusted operator the right to lock his NFT through the approve functions. ThelockApprove()function only approves for the specified NFT, whereassetLockApprovalForAll()approves for all NFTs of the collection under the wallet. When a user participates in an NFTFi project, the project contract callslock()to lock the user\u2019s NFT. Locked NFTs cannot be transferred, but the NFTFi project contract can use the unlock functionunlock()to unlock the NFT.", "NFT lock/unlock": "Authorized project contracts have permission to lock NFT with thelockmethod. Locked NFTs cannot be transferred until the lock time expires. The project contract also has permission to unlock NFT in advance through theunlockfunction. Note that only the address of the locked NFT has permission to unlock that NFT.", "NFT lock period": "When locking an NFT, one must specify the lock expiration block number, which must be greater than the current block number. When the current block number exceeds the expiration block number, the NFT is automatically released and can be transferred.", "Bound NFT": "Bound NFT is an extension of this EIP, which implements the ability to mint a boundNFT during the NFT locking period. The boundNFT is identical to the locked NFT metadata and can be transferred. However, a boundNFT only exists during the NFT locking period and will be destroyed after the NFT is unlocked.\nBoundNFT can be used to lend, as a staking credential for the contract. The credential can be locked in the contract, but also to the user. In NFT leasing, boundNFT can be rented to users because boundNFT is essentially equivalent to NFT. This consensus, if accepted by all projects, boundNFT will bring more creativity to NFT.", "Bound NFT Factory": "Bound NFT Factory is a common boundNFT factory, similar to Uniswap\u2019sEIP-20pairs factory. It uses the create2 method to create a boundNFT contract address for any NFT deterministic. BoundNFT contract that has been created can only be controlled by the original NFT contract.", "Backwards Compatibility": "This standard is compatible with EIP-721.", "Test Cases": "Test cases written using hardhat can be foundhere", "Reference Implementation": "You can find an implementation of this standard in theassetsfolder.", "Security Considerations": "After being locked, the NFT can not be transferred, so before authorizing locking rights to other project contracts, you must confirm that the project contract can unlock NFT. Otherwise there is a risk of NFT being permanently locked. It is recommended to give a reasonable locking period in use for projects. NFT can be automatically unlocked, which can reduce the risk to a certain extent.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- create2: A new opcode introduced in EIP-86 that allows contract creation with a specific address based on a combination of sender, salt, and initialization code .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5094, "url": "https://eips.ethereum.org/EIPS/eip-5094", "title": "URL Format for Ethereum Network Switching", "authors": ["Luc van Kampen\u00a0(", "@lucemans", ")", "Jakob Helgesson\u00a0(", "@svemat01", ")", "Joshua Hendrix\u00a0(", "@thejoshuahendrix", ")"], "sections": {"ERC-5094: URL Format for Ethereum Network Switching": "This standard includes all needed information for adding a network to a wallet via URL, by including parameters such aschainId,rpc_url,chain_nameand others, such that the network configuration is provided through the URL itself.", "A way of representing various network configurations as URLs.": "This standard includes all needed information for adding a network to a wallet via URL, by including parameters such aschainId,rpc_url,chain_nameand others, such that the network configuration is provided through the URL itself.", "Abstract": "This standard includes all needed information for adding a network to a wallet via URL, by including parameters such aschainId,rpc_url,chain_nameand others, such that the network configuration is provided through the URL itself.", "Motivation": "As observed with the use ofEIP-681and its implementation in current mobile wallets, transactions can be made, approved, viewed, and used. However, if the wallet is instructed to perform a transaction on a chain they have not yet been configured before, the operation tends to fail.", "Specification": "Network Switching URLs contain \u201cethereum\u201d in their schema (protocol) part and are constructed as follows:", "Syntax": "Network Switching URLs contain \u201cethereum\u201d in their schema (protocol) part and are constructed as follows:", "Semantics": "chain_idis mandatory and denotes the decimal chain ID, such that we have the identifier of the network we would like to add.", "Rationale": "In furtherance of the Ethereum URL saga, network configuration is a needed addition to the possibility of Ethereum URLs. This would improve functionality for URLs, and offer non-mainnet users a way to connect without needing to configure their wallet by hand.", "Security Considerations": "URLs can be malformed to deceive users. Users SHOULD confirm source of URL before using any links. As well as checking source and transaction details before confirming any transactions. Applications SHOULD display network config, prior to network addition, such that users can confirm the validity of the network configuration being added.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5095, "url": "https://eips.ethereum.org/EIPS/eip-5095", "title": "Principal Token", "authors": ["Julian Traversa\u00a0(", "@JTraversa", ")", "Robert Robbins\u00a0(", "@robrobbins", ")", "Alberto Cuesta Ca\u00f1ada\u00a0(", "@alcueca", ")"], "sections": {"ERC-5095: Principal Token": "Principal tokens represent ownership of an underlyingEIP-20token at a future timestamp.", "Principal tokens (zero-coupon tokens) are redeemable for a single underlying EIP-20 token at a future timestamp.": "Principal tokens represent ownership of an underlyingEIP-20token at a future timestamp.", "Abstract": "Principal tokens represent ownership of an underlyingEIP-20token at a future timestamp.", "Motivation": "Principal tokens lack standardization which has led to a difficult to navigate development space and diverse implementation\nschemes.", "Specification": "All Principal Tokens (PTs) MUST implementEIP-20to represent ownership of future underlying redemption.\nIf a PT is to be non-transferrable, it MAY revert on calls totransferortransferFrom.\nTheEIP-20operationsbalanceOf,transfer,totalSupply, etc. operate on the Principal Token balance.", "Definitions:": "The address of the underlying token used by the Principal Token for accounting, and redeeming.", "Methods": "The address of the underlying token used by the Principal Token for accounting, and redeeming.", "Events": "fromhas exchangedprincipalAmountof Principal Tokens forunderlyingAmountof underlying, and transferred that underlying toto.", "Rationale": "The Principal Token interface is designed to be optimized for integrators with a core minimal interface alongside optional interfaces to enable backwards compatibility. Details such as accounting and management of underlying are intentionally not specified, as Principal Tokens are expected to be treated as black boxes on-chain and inspected off-chain before use.", "Backwards Compatibility": "This EIP is fully backward compatible with theEIP-20specification and has no known compatibility issues with other standards.\nFor production implementations of Principal Tokens which do not use EIP-5095, wrapper adapters can be developed and used, or wrapped tokens can be implemented.", "Reference Implementation": "Fully permissionless use cases could fall prey to malicious implementations which only conform to the interface in this EIP but not the specification, failing to implement proper custodial functionality but offering the ability to purchase Principal Tokens through secondary markets.", "Security Considerations": "Fully permissionless use cases could fall prey to malicious implementations which only conform to the interface in this EIP but not the specification, failing to implement proper custodial functionality but offering the ability to purchase Principal Tokens through secondary markets.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5131, "url": "https://eips.ethereum.org/EIPS/eip-5131", "title": "SAFE Authentication For ENS", "authors": ["Wilkins Chung (@wwhchung)\u00a0<", "wilkins@manifold.xyz", ">", "Jalil Wahdatehagh\u00a0(", "@jwahdatehagh", ")", "Cry\u00a0(", "@crydoteth", ")", "Sillytuna\u00a0(", "@sillytuna", ")", "Cyberpnk\u00a0(", "@CyberpnkWin", ")"], "sections": {"ERC-5131: SAFE Authentication For ENS": "This EIP links one or more signing wallets via Ethereum Name Service Specification (EIP-137) to prove control and asset ownership of a main wallet.", "Using ENS Text Records to facilitate safer and more convenient signing operations.": "This EIP links one or more signing wallets via Ethereum Name Service Specification (EIP-137) to prove control and asset ownership of a main wallet.", "Abstract": "This EIP links one or more signing wallets via Ethereum Name Service Specification (EIP-137) to prove control and asset ownership of a main wallet.", "Motivation": "Proving ownership of an asset to a third party application in the Ethereum ecosystem is common. Users frequently sign payloads of data to authenticate themselves before gaining access to perform some operation. However, this method\u2013akin to giving the third party root access to one\u2019s main wallet\u2013is both insecure and inconvenient.", "Problems with existing methods and solutions": "Unfortunately, we\u2019ve seen many cases where users have accidentally signed a malicious payload. The result is almost always a significant loss of assets associated with the signing address.", "Proposal: Use the Ethereum Name Service (EIP-137)": "Rather than \u2018re-invent the wheel\u2019, this proposal aims to use the widely adopted Ethereum Name Service in conjunction with the ENS Text Records feature (EIP-634) in order to achieve a safer and more convenient way to sign and authenticate, and provide \u2018read only\u2019 access to a main wallet via one or more secondary wallets.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Setting up one or manyauthAddressrecords on a single ENS domain": "ThemainAddressMUST have an ENS resolver record and reverse record configured.\nIn order to automatically discover the linked account, theauthAddressSHOULD have an ENS resolver record and reverse record configured.", "AuthenticatingmainAddressviaauthAddress": "Control ofmainAddressand ownership ofmainAddressassets is proven if any associatedauthAddressis themsg.senderor has signed the message.", "Revocation ofauthAddress": "To revoke permission ofauthAddress, delete theeip5131:<authKey>TEXT record ofmainENSor update it to point to a newauthAddress.", "Rationale": "The proposed specification makes use of EIP-137 rather than introduce another registry paradigm. The reason for this is due to the existing wide adoption of EIP-137 and ENS.", "Usage of EIP-137": "The proposed specification makes use of EIP-137 rather than introduce another registry paradigm. The reason for this is due to the existing wide adoption of EIP-137 and ENS.", "One-to-Many Authentication Relationship": "This proposed specification allows for a one (mainAddress) to many (authAddress) authentication relationship.  i.e. onemainAddresscan authorize manyauthAddressto authenticate, but anauthAddresscan only authenticate itself or a singlemainAddress.", "Reference Implementation": "In typescript, the validation function, using ethers.js would be as follows:", "Client/Server Side": "In typescript, the validation function, using ethers.js would be as follows:", "Contract side": "If your application operates a secure backend server, you could run the client/server code above, then use the result in conjunction with specs likeEIP-1271:Standard Signature Validation Method for Contractsfor a cheap and secure way to validate that the message signer is indeed authenticated for the main address.", "Security Considerations": "The core purpose of this EIP is to enhance security and promote a safer way to authenticate wallet control and asset ownership when the main wallet is not needed and assets held by the main wallet do not need to be moved. Consider it a way to do \u2018read only\u2019 authentication.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5139, "url": "https://eips.ethereum.org/EIPS/eip-5139", "title": "Remote Procedure Call Provider Lists", "authors": ["Sam Wilson\u00a0(", "@SamWilsn", ")"], "sections": {"ERC-5139: Remote Procedure Call Provider Lists": "This proposal specifies a JSON schema for describing lists of remote procedure call (RPC) providers for Ethereum-like chains, including their supportedEIP-155CHAIN_ID.", "Format for lists of RPC providers for Ethereum-like chains.": "This proposal specifies a JSON schema for describing lists of remote procedure call (RPC) providers for Ethereum-like chains, including their supportedEIP-155CHAIN_ID.", "Abstract": "This proposal specifies a JSON schema for describing lists of remote procedure call (RPC) providers for Ethereum-like chains, including their supportedEIP-155CHAIN_ID.", "Motivation": "The recent explosion of alternate chains, scaling solutions, and other mostly Ethereum-compatible ledgers has brought with it many risks for users. It has become commonplace to blindly add new RPC providers usingEIP-3085without evaluating their trustworthiness. At best, these RPC providers may be accurate, but track requests; and at worst, they may provide misleading information and frontrun transactions.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "List Validation & Schema": "List consumers (like wallets) MUST validate lists against the provided schema. List consumers MUST NOT connect to RPC providers present only in an invalid list.", "Versioning": "List versioning MUST follow theSemantic Versioning 2.0.0(SemVer) specification.", "Publishing": "Provider lists SHOULD be published to an Ethereum Name Service (ENS) name usingEIP-1577\u2019scontenthashmechanism on mainnet.", "Priority": "Provider entries MAY contain apriorityfield. Apriorityvalue of zero SHALL indicate the highest priority, with increasingpriorityvalues indicating decreasing priority. Multiple providers MAY be assigned the same priority. All providers without apriorityfield SHALL have equal priority. Providers without apriorityfield SHALL always have a lower priority than any provider with apriorityfield.", "List Subtypes": "Provider lists are subdivided into two categories: root lists, and extension lists. A root list contains a list of providers, while an extension list contains a set of modifications to apply to another list.", "Rationale": "This specification has two layers (provider, then chain id) instead of a flatter structure so that wallets can choose to query multiple independent providers for the same query and compare the results.", "Security Considerations": "Ultimately it is up to the end user to decide on what list to subscribe to. Most users will not change from the default list maintained by their wallet. Since wallets already have access to private keys, giving them additional control over RPC providers seems like a small increase in risk.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5143, "url": "https://eips.ethereum.org/EIPS/eip-5143", "title": "Slippage Protection for Tokenized Vault", "authors": ["Hadrien Croubois\u00a0(", "@amxx", ")"], "sections": {"ERC-5143: Slippage Protection for Tokenized Vault": "The following standard extends theEIP-4626Tokenized Vault standard with functions dedicated to the safe interaction between EOAs and the vault when price is subject to slippage.", "An extension of EIP-4626 supporting improved EOA interactions.": "The following standard extends theEIP-4626Tokenized Vault standard with functions dedicated to the safe interaction between EOAs and the vault when price is subject to slippage.", "Abstract": "The following standard extends theEIP-4626Tokenized Vault standard with functions dedicated to the safe interaction between EOAs and the vault when price is subject to slippage.", "Motivation": "EIP-4626security considerations section states that:", "Specification": "This ERC is an extension of EIP-4626. Any contract implementing it MUST also implement EIP-4626.", "Methods": "Overloaded version of ERC-4626\u2019sdeposit.", "Rationale": "This ERC\u2019s functions do not replace ERC-4626 equivalent mechanisms. They are additional (overloaded) methods designed to protect EOAs interacting with the vault.", "Alternative approaches": "This ERC aims at solving the security concerns (describes in the motivation section) at the vault level. For completeness, we have to mention that these issues can also be addressed using a generic ERC-4626 router, similar to how Uniswap V2 & V3 use a router to provide good user workflows on top of the Uniswap pairs. The router approach is possibly more versatile and leaves more room for evolutions (the router can be replaced at any point) but it also leads to more expensive operations because the router needs to take temporary custody of the tokens going into the vault.", "Reference Implementation": "Given an existing ERC-4626 implementation", "Security Considerations": "This ERC addresses one of the security consideration raised by ERC-4626. Other considerations still apply.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5185, "url": "https://eips.ethereum.org/EIPS/eip-5185", "title": "NFT Updatable Metadata Extension", "authors": ["Christophe Le Bars\u00a0(", "@clbrge", ")"], "sections": {"ERC-5185: NFT Updatable Metadata Extension": "This specification defines a standard way to allow controlled NFTs\u2019 metadata updates along predefined formulas. Updates of the original metadata are restricted and defined by a set of recipes and the sequence and results of these recipes are deterministic and fully verifiable with on-chain metadata updates event. The proposal depends on and extends theEIP-721andEIP-1155.", "An interface extension for ERC-721/ERC-1155 controlled metadata updates": "This specification defines a standard way to allow controlled NFTs\u2019 metadata updates along predefined formulas. Updates of the original metadata are restricted and defined by a set of recipes and the sequence and results of these recipes are deterministic and fully verifiable with on-chain metadata updates event. The proposal depends on and extends theEIP-721andEIP-1155.", "Abstract": "This specification defines a standard way to allow controlled NFTs\u2019 metadata updates along predefined formulas. Updates of the original metadata are restricted and defined by a set of recipes and the sequence and results of these recipes are deterministic and fully verifiable with on-chain metadata updates event. The proposal depends on and extends theEIP-721andEIP-1155.", "Motivation": "Storing voluminous NFT metadata on-chain is often neither practical nor cost-efficient.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Engines": "Only one engine is currently defined in this extension proposal.", "Rationale": "There have been numerous interesting uses ofEIP-721andEIP-1155smart contracts that associate for each token essential and significant metadata. While some projects (e.g. EtherOrcs) have experimented successfully to manage these metadata on-chain, that experimental solution will always be limited by the cost and speed of generating and storing JSON on-chain. Symmetrically, while storing the JSON metadata at URI endpoint controlled by traditional servers permit limitless updates the metadata for each NFT, it is somehow defeating in many uses cases, the whole purpose of using a trustless blockchain to manage NFT: indeed users may want or demand more permanence and immutability from the metadata associated with their NFT.", "Reference Implementation": "We have been experimenting with this generic Metadata update proposal using the JSONata transformation language.", "Transformation engines": "We have been experimenting with this generic Metadata update proposal using the JSONata transformation language.", "Security Considerations": "A malicious recipe in the original metadata might be constructed as a DDoS vector for third parties marketplaces and tools that calculate NFT updated JSON metadata. They are encouraged to properly encapsulate software in charge of these calculations and put limits for the engine updates processing.", "Backwards Compatibility": "The proposal is fully compatible with bothEIP-721andEIP-1155. Third-party applications that don\u2019t support this EIP will still be able to use the original metadata for each NFT.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5187, "url": "https://eips.ethereum.org/EIPS/eip-5187", "title": "Extend EIP-1155 with rentable usage rights", "authors": ["DerivStudio\u00a0(", "@DerivStudio", ")"], "sections": {"ERC-5187: Extend EIP-1155 with rentable usage rights": "This standard is an extension ofEIP-1155. It proposes to introduce separable, rentable, and transferable usage rights (in the form of NFT-IDs), enabling the property owner (the only NFT holder) to rent out the NFT to multiple users (ID holders) at the same time for different terms, and be withdrawn by smart contract upon expiration.", "Separate ownership and usage rights of EIP-1155 to allow users to use NFTs for an allotted time and return them to owners after expiration.": "This standard is an extension ofEIP-1155. It proposes to introduce separable, rentable, and transferable usage rights (in the form of NFT-IDs), enabling the property owner (the only NFT holder) to rent out the NFT to multiple users (ID holders) at the same time for different terms, and be withdrawn by smart contract upon expiration.", "Abstract": "This standard is an extension ofEIP-1155. It proposes to introduce separable, rentable, and transferable usage rights (in the form of NFT-IDs), enabling the property owner (the only NFT holder) to rent out the NFT to multiple users (ID holders) at the same time for different terms, and be withdrawn by smart contract upon expiration.", "Motivation": "The well-acceptedEIP-721and EIP-1155 standards focused on the ownership of unique assets, quite sensible in the time of NFTs being used primarily as arts and collectibles, or, you can say, as private property rights.", "First Step: \u201cExpirable\u201d NFTs": "The advent of private ownership in the real world has promoted the vigorous development of the modern economy, and we believe that the usage right will be the first detachable right widely applied in the blockchain ecosystem. As NFTs are increasingly applied in rights, finance, games, and the Metaverse, the value of NFT is no longer simply the proof of ownership, but with limitless practice use scenarios. For example, artists may wish to rent out their artworks to media or audiences within specific periods, and game guilds may wish to rent out game items to new players to reduce their entry costs.", "Then, Make Everything Transferable": "The way we achieve leasing is to separate ownership and usage rights, and beyond that, we focus more on making them freely priced and traded after separation, which is impossible to happen in the traditional financial field. Imagine the below scenarios: i) as a landlord, you can sell your house in rental to others without affecting the tenancy, and your tenants will then pay rent to the new landlord; ii) as a tenant, you can sublet the house to others without the consent of the landlord, and even the one sublets can continue subletting the house until the lease term is close the last tenant can apply for a renewal of the lease. All of this can happen in the blockchain world, and that\u2019s the beauty of blockchain. Without permission, without trust, code is the law.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "Implementing the proposal to create rentable NFTs has two main benefits.", "Backwards Compatibility": "As mentioned at the beginning, this is an extension of EIP-1155. Therefore, it is fully backward compatible with EIP-1155.", "Security Considerations": "Needs discussion.", "Copyright": "Disclaimer of copyright and related rights throughCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5218, "url": "https://eips.ethereum.org/EIPS/eip-5218", "title": "NFT Rights Management", "authors": ["James Grimmelmann\u00a0(", "@grimmelm", ")", "Yan Ji\u00a0(", "@iseriohn", ")", "Tyler Kell\u00a0(", "@relyt29", ")"], "sections": {"ERC-5218: NFT Rights Management": "The following standard defines an API for managing NFT licenses. This standard provides basic functionality to create, transfer, and revoke licenses, and to determine the current licensing state of an NFT. The standard does not define the legal details of the license. Instead, it provides a structured framework for recording licensing details.", "An interface for creating copyright licenses that transfer with an NFT.": "The following standard defines an API for managing NFT licenses. This standard provides basic functionality to create, transfer, and revoke licenses, and to determine the current licensing state of an NFT. The standard does not define the legal details of the license. Instead, it provides a structured framework for recording licensing details.", "Abstract": "The following standard defines an API for managing NFT licenses. This standard provides basic functionality to create, transfer, and revoke licenses, and to determine the current licensing state of an NFT. The standard does not define the legal details of the license. Instead, it provides a structured framework for recording licensing details.", "Motivation": "TheERC-721standard defines an API to track and transfer ownership of an NFT. When an NFT is to represent some off-chain asset, however, we would need some legally effective mechanism totetherthe on-chain asset (NFT) to the off-chain property. One important case of off-chain property is creative work such as an image or music file. Recently, most NFT projects involving creative works have used licenses to clarify what legal rights are granted to the NFT owner. But these licenses are almost always off-chain and the NFTs themselves do not indicate what licenses apply to them, leading to uncertainty about rights to use the work associated with the NFT. It is not a trivial task to avoid all the copyright vulnerabilities in NFTs, nor have existing EIPs addressed rights management of NFTs beyond the simple cases of direct ownership (seeERC-721) or rental (seeERC-4907).", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "This EIP aims to allow tracing all licenses to an NFT to facilitate right management. The ERC-721 standard only logs the property but not the legal rights tethered to NFTs. Even when logging the license via the optional ERC-721 Metadata extension, sublicenses are not traceable, which doesn\u2019t comply with the transparency goals of Web3. Some implementations attempt to get around this limitation by minting NFTs to represent a particular license, such as the BAYC #6068 Royalty-Free Usage License. This is not an ideal solution because the linking between different licenses to an NFT is ambiguous. An auditor has to investigate all NFTs in the blockchain and inspect the metadata which hasn\u2019t been standardized in terms of sublicense relationship. To avoid these problems, this EIP logs all licenses to an NFT in a tree data structure, which is compatible with ERC-721 and allows efficient traceability.", "Backwards Compatibility": "This standard is compatible with the current ERC-721 standards: a contract can inherit from both ERC-721 and ERC-5218 at the same time.", "Test Cases": "Test cases are availablehere.", "Reference Implementation": "A reference implementation maintains the following data structures:", "Security Considerations": "Implementors of theIERC5218standard must consider thoroughly the permissions they give tolicenseHolderandrevoker. If the license is ever to be transferred to a different license holder, therevokersmart contract should not hardcode thelicenseHolderaddress to avoid undesirable scenarios.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5252, "url": "https://eips.ethereum.org/EIPS/eip-5252", "title": "Account-bound Finance", "authors": ["Hyungsuk Kang\u00a0(", "@hskang9", ")", "Viktor Pernjek\u00a0(", "@smuxx", ")"], "sections": {"ERC-5252: Account-bound Finance": "This EIP proposes a form of smart contract design pattern and a new type of account abstraction on how one\u2019s finance should be managed, ensuring transparency of managing investments and protection with self-sovereignty even from its financial operators. This EIP enables greater self-sovereignty of one\u2019s assets using a personal finance contract for each individual. The separation between an investor\u2019s funds and the operation fee is clearly specified in the personal smart contract, so investors can ensure safety from arbitrary loss of funds by the operating team\u2019s control.", "An ERC-5114 extension that aids in preventing arbitrary loss of funds": "This EIP proposes a form of smart contract design pattern and a new type of account abstraction on how one\u2019s finance should be managed, ensuring transparency of managing investments and protection with self-sovereignty even from its financial operators. This EIP enables greater self-sovereignty of one\u2019s assets using a personal finance contract for each individual. The separation between an investor\u2019s funds and the operation fee is clearly specified in the personal smart contract, so investors can ensure safety from arbitrary loss of funds by the operating team\u2019s control.", "Abstract": "This EIP proposes a form of smart contract design pattern and a new type of account abstraction on how one\u2019s finance should be managed, ensuring transparency of managing investments and protection with self-sovereignty even from its financial operators. This EIP enables greater self-sovereignty of one\u2019s assets using a personal finance contract for each individual. The separation between an investor\u2019s funds and the operation fee is clearly specified in the personal smart contract, so investors can ensure safety from arbitrary loss of funds by the operating team\u2019s control.", "Motivation": "Decentralized finance (DeFi) faces a trust issue. Smart contracts are often proxies, with the actual logic of the contract hidden away in a separate logic contract. Many projects include a multi-signature \u201cwallet\u201d with unnecessarily-powerful permissions. And it is not possible to independently verify that stablecoins have enough real-world assets to continue maintaining their peg, creating a large loss of funds (such as happened in the official bankruptcy announcement of Celsius and UST de-pegging and anchor protocol failure). One should not trust exchanges or other third parties with one\u2019s own investments with the operators\u2019 clout in Web3.0.", "Offchain-identity vs Soul-bound token on credentials": "This EIP provides a better alternative to off-chain identity solutions which take over the whole system because their backends eventually rely on the trust of the operator, not cryptographic proof (e.g. Proof-of-work, Proof-of-stake, etc). Off-chain identity as credentials are in direct opposition to the whole premise of crypto. Soulbound tokens are a better, verifiable credential, and data stored off-chain is only to store token metadata.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Interaction": "The interaction pattern consists of 4 components for interaction; manager, factory, finance, account-bound token, and extension.", "Governance": "The governance pattern consists of 2 components; influencer and governor.", "Rationale": "The gas cost of using multiple contracts (as opposed to a single one) actually saves gas long-run if the clone factory pattern is applied. One contract storing users\u2019 states globally means each user is actually paying for the storage cost of other users after interacting with the contract. This, for example, means that MakerDAO\u2019s contract operating cost is sometimes over 0.1 ETH, limitimg users\u2019 minimum deposit for CDP in order to save gas costs. To solve inefficient n-times charging gas cost interaction for future users, one contract per user is used.", "Gas saving for end user": "The gas cost of using multiple contracts (as opposed to a single one) actually saves gas long-run if the clone factory pattern is applied. One contract storing users\u2019 states globally means each user is actually paying for the storage cost of other users after interacting with the contract. This, for example, means that MakerDAO\u2019s contract operating cost is sometimes over 0.1 ETH, limitimg users\u2019 minimum deposit for CDP in order to save gas costs. To solve inefficient n-times charging gas cost interaction for future users, one contract per user is used.", "Backwards Compatibility": "This EIP has no known backward compatibility issues.", "Reference Implementation": "Reference implementationis a simple deposit account contract asFinancecontract and its contribution value \u03b1 is measured with deposit amount with ETH.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5298, "url": "https://eips.ethereum.org/EIPS/eip-5298", "title": "ENS Trust to hold NFTs under ENS name", "authors": ["Zainan Victor Zhou\u00a0(", "@xinbenlv", ")"], "sections": {"ERC-5298: ENS Trust to hold NFTs under ENS name": "This EIP standardizes an interface for smart contracts to hold ofEIP-721andEIP-1155tokens on behalf of ENS domains.", "An interface for a smart contract acting as a \"trust\" that holds tokens by ENS name.": "This EIP standardizes an interface for smart contracts to hold ofEIP-721andEIP-1155tokens on behalf of ENS domains.", "Abstract": "This EIP standardizes an interface for smart contracts to hold ofEIP-721andEIP-1155tokens on behalf of ENS domains.", "Motivation": "Currently, if someone wants to receive a token, they have to set up a wallet address. This EIP decouples NFT ownership from wallet addresses.", "Specification": "No backward compatibility issues were found.", "Rationale": "No backward compatibility issues were found.", "Backwards Compatibility": "No backward compatibility issues were found.", "Test Cases": "Needs discussion.", "Reference Implementation": "Needs discussion.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5334, "url": "https://eips.ethereum.org/EIPS/eip-5334", "title": "EIP-721 User And Expires And Level Extension", "authors": ["Yan\u00a0(", "@yan253319066", ")"], "sections": {"ERC-5334: EIP-721 User And Expires And Level Extension": "AnEIP-721extension that adds an additional role (user) which can be granted to addresses, and a time where the role is automatically revoked (expires) and (level) . Theuserrole represents permission to \u201cuse\u201d the NFT, but not the ability to transfer it or set users.", "Add a time-limited role with restricted permissions to EIP-721 tokens.": "AnEIP-721extension that adds an additional role (user) which can be granted to addresses, and a time where the role is automatically revoked (expires) and (level) . Theuserrole represents permission to \u201cuse\u201d the NFT, but not the ability to transfer it or set users.", "Abstract": "AnEIP-721extension that adds an additional role (user) which can be granted to addresses, and a time where the role is automatically revoked (expires) and (level) . Theuserrole represents permission to \u201cuse\u201d the NFT, but not the ability to transfer it or set users.", "Motivation": "Some NFTs have certain utilities. For example, virtual land can be \u201cused\u201d to build scenes, and NFTs representing game assets can be \u201cused\u201d in-game. In some cases, the owner and user may not always be the same. There may be an owner of the NFT that rents it out to a \u201cuser\u201d. The actions that a \u201cuser\u201d should be able to take with an NFT would be different from the \u201cowner\u201d (for instance, \u201cusers\u201d usually shouldn\u2019t be able to sell ownership of the NFT).\u00a0 In these situations, it makes sense to have separate roles that identify whether an address represents an \u201cowner\u201d or a \u201cuser\u201d and manage permissions to perform actions accordingly.", "Clear Rights Assignment": "With Dual \u201cowner\u201d and \u201cuser\u201d roles, it becomes significantly easier to manage what lenders and borrowers can and cannot do with the NFT (in other words, their rights).\u00a0Additionally, owners can control who the user is and it\u2019s easy for other projects to assign their own rights to either the owners or the users.", "Simple On-chain Time Management": "Once a rental period is over, the user role needs to be reset and the \u201cuser\u201d has to lose access to the right to use the NFT. This is usually accomplished with a second on-chain transaction but that is gas inefficient and can lead to complications because it\u2019s imprecise. With theexpiresfunction, there is no need for another transaction because the \u201cuser\u201d is invalidated automatically after the duration is over.", "Easy Third-Party Integration": "In the spirit of permission less interoperability, this standard makes it easier for third-party protocols to manage NFT usage rights without permission from the NFT issuer or the NFT application. Once a project has adopted the additionaluserrole andexpiresandlevel, any other project can directly interact with these features and implement their own type of transaction. For example, a PFP NFT using this standard can be integrated into both a rental platform where users can rent the NFT for 30 days AND, at the same time, a mortgage platform where users can use the NFT while eventually buying ownership of the NFT with installment payments. This would all be done without needing the permission of the original PFP project.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Contract Interface": "Solidity Interface with NatSpec & OpenZeppelin v4 Interfaces (also available atIERC5334.sol):", "Rationale": "TBD", "Backwards Compatibility": "As mentioned in the specifications section, this standard can be fully EIP-721 compatible by adding an extension function set.", "Reference Implementation": "A reference implementation of this standard can be found in the assets folder.", "Security Considerations": "This EIP standard can completely protect the rights of the owner, the owner can change the NFT user and expires and level at any time.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5409, "url": "https://eips.ethereum.org/EIPS/eip-5409", "title": "EIP-1155 Non-Fungible Token extension", "authors": ["Ronan Sandford\u00a0(", "@wighawag", ")"], "sections": {"ERC-5409: EIP-1155 Non-Fungible Token extension": "This standard is an extension ofEIP-1155. It proposes an additional function,ownerOf, which allows EIP-1155 tokens to support Non-Fungibility (unique owners). By implementing this extra function, EIP-1155 tokens can benefit fromEIP-721\u2019s core functionality without implementing the (less efficient) EIP-721 specification in the same contract.", "Allow EIP-1155 to represent Non-Fungible Tokens (tokens who have a unique owner)": "This standard is an extension ofEIP-1155. It proposes an additional function,ownerOf, which allows EIP-1155 tokens to support Non-Fungibility (unique owners). By implementing this extra function, EIP-1155 tokens can benefit fromEIP-721\u2019s core functionality without implementing the (less efficient) EIP-721 specification in the same contract.", "Abstract": "This standard is an extension ofEIP-1155. It proposes an additional function,ownerOf, which allows EIP-1155 tokens to support Non-Fungibility (unique owners). By implementing this extra function, EIP-1155 tokens can benefit fromEIP-721\u2019s core functionality without implementing the (less efficient) EIP-721 specification in the same contract.", "Motivation": "Currently, EIP-1155 does not allow an external caller to detect whether a token is truly unique (can have only one owner) or fungible. This is because EIP-1155 do not expose a mechanism to detect whether a token will have its supply remain to be \u201c1\u201d. Furthermore, it does not let an external caller retrieve the owner directly on-chain.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Contract Interface": "TheownerOf(uint256 tokenId)function MAY be implemented aspureorview.", "Rationale": "ownerOfdoes not throw when a token does not exist (or does not have an owner). This simplifies the handling of such a case. Since it would be a security risk to assume all EIP-721 implementation would throw, it should not break compatibility with contract handling EIP-721 when dealing with this EIP-1155 extension.", "Backwards Compatibility": "This EIP is fully backward compatible with EIP-1155.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5437, "url": "https://eips.ethereum.org/EIPS/eip-5437", "title": "Security Contact Interface", "authors": ["Zainan Zhou\u00a0(", "@xinbenlv", ")"], "sections": {"ERC-5437: Security Contact Interface": "An interface for security notice using asymmetric encryption. The interface exposes a asymmetric encryption key and a destination of delivery.", "An interface for security notice using asymmetric encryption": "An interface for security notice using asymmetric encryption. The interface exposes a asymmetric encryption key and a destination of delivery.", "Abstract": "An interface for security notice using asymmetric encryption. The interface exposes a asymmetric encryption key and a destination of delivery.", "Motivation": "Currently there is no consistent way to specify an official channel for security researchers to report security issues to smart contract maintainers.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "Currently, existing solutions such as OpenZeppelin use plaintext in source code", "Backwards Compatibility": "Currently, existing solutions such as OpenZeppelin use plaintext in source code", "Security Considerations": "Implementors should properly follow security practices required by the encryption scheme to ensure the security of the chosen communication channel. Some best practices are as follows:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5501, "url": "https://eips.ethereum.org/EIPS/eip-5501", "title": "Rental & Delegation NFT - EIP-721 Extension", "authors": ["Jan Smr\u017ea\u00a0(", "@smrza", ")", "David R\u00e1bel\u00a0(", "@rabeles11", ")", "Tom\u00e1\u0161 Jan\u010da\u00a0<", "tomas.janca@jtbstorage.eu", ">", "Jan Bure\u0161\u00a0(", "@JohnyX89", ")", "DOBBYLABS\u00a0(", "@DOBBYLABS", ")"], "sections": {"ERC-5501: Rental & Delegation NFT - EIP-721 Extension": "The following standard proposes an additionaluserrole forEIP-721. This role grants the permission to use the NFT with no ability to transfer or set users. It has an expiry and a flag if the token is borrowed or not.Ownercan delegate the NFT for usage to hot wallets or lend the NFT. If the token is borrowed, not even the owner can change the user until the status expires or both parties agree to terminate. This way, it is possible to keep both roles active at the same time.", "Adds a conditional time-limited user role to EIP-721. This role can be delegated or borrowed.": "The following standard proposes an additionaluserrole forEIP-721. This role grants the permission to use the NFT with no ability to transfer or set users. It has an expiry and a flag if the token is borrowed or not.Ownercan delegate the NFT for usage to hot wallets or lend the NFT. If the token is borrowed, not even the owner can change the user until the status expires or both parties agree to terminate. This way, it is possible to keep both roles active at the same time.", "Abstract": "The following standard proposes an additionaluserrole forEIP-721. This role grants the permission to use the NFT with no ability to transfer or set users. It has an expiry and a flag if the token is borrowed or not.Ownercan delegate the NFT for usage to hot wallets or lend the NFT. If the token is borrowed, not even the owner can change the user until the status expires or both parties agree to terminate. This way, it is possible to keep both roles active at the same time.", "Motivation": "Collectibles, gaming assets, metaverse, event tickets, music, video, domains, real item representation are several among many NFT use cases. WithEIP-721only the owner can reap the benefits. However, with most of the utilities it would be beneficial to distinguish between the token owner and its user. For instance music or movies could be rented. Metaverse lands could be delegated for usage.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "The main factors influencing this standard are:", "Name": "The name for the additional role has been chosen to fit the purpose and to keep compatibility with EIP-4907.", "Ownership retention": "Many collections offer their owners airdrops or free minting of various tokens. This is essentially broken if the owner is lending a token by staking it into a contract (unless the contract is implementing a way to claim at least airdropped tokens). Applications can also provide different access and benefits to owner and user roles in their ecosystem.", "Balance and Enumerable extensions": "These have been chosen as OPTIONAL extensions due to the complexity of implementation based on the fact that balance is less once user status expires and there is no immediate on-chain transaction to evaluate that. In bothuserBalanceOfandtokenOfUserByIndexfunctions there must be a way to determine whether or not user status has expired.", "Terminable extension": "If the owner mistakenly sets a user with borrow status and expires to a large value they would essentially be blocked from setting the user ever again. The problem is addressed by this extension if both parties agree to terminate the user status.", "Security": "Once applications adopt the user role, it is possible to delegate ownership to hot wallet and interact with them with no fear of connecting to malicious websites.", "Backwards Compatibility": "This standard is compatible with currentEIP-721by adding an extension function set. The new functions introduced are similar to existing functions in EIP-721 which guarantees easy adoption by developers and applications. This standard also shares similarities toEIP-4907considering user role and its expiry which means applications will be able to determine the user if either of the standards is used.", "Test Cases": "Test cases can be found in the reference implementation:", "Reference Implementation": "The reference implementation is available here:", "Security Considerations": "Developers implementing this standard and applications must consider all the permissions they give to users and owners. Since owner and user are both active roles at the same time, double-spending problem must be avoided. Balance extension must be implemented in such a way which will not cause any gas problems. Marketplaces should let users know if a token listed for sale is borrowed or not.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5505, "url": "https://eips.ethereum.org/EIPS/eip-5505", "title": "EIP-1155 asset backed NFT extension", "authors": ["liszechung\u00a0(", "@liszechung", ")"], "sections": {"ERC-5505: EIP-1155 asset backed NFT extension": "To propose an extension of smart contract interfaces for asset-backed, fractionalized projects using theEIP-1155standard such that total acquisition will become possible. This proposal focuses on physical asset, where total acquisition should be able to happen.", "Extends EIP-1155 to support crucial operations for asset-backed NFTs": "To propose an extension of smart contract interfaces for asset-backed, fractionalized projects using theEIP-1155standard such that total acquisition will become possible. This proposal focuses on physical asset, where total acquisition should be able to happen.", "Abstract": "To propose an extension of smart contract interfaces for asset-backed, fractionalized projects using theEIP-1155standard such that total acquisition will become possible. This proposal focuses on physical asset, where total acquisition should be able to happen.", "Motivation": "Fractionalized, asset backed NFTs face difficulty when someone wants to acquire the whole asset. For example, if someone wants to bring home a fractionalized asset, he needs to buy all NFT pieces so he will become the 100% owner. However he could not do so as it is publicly visible that someone is trying to perform a total acquisition in an open environment like Ethereum. Sellers will take advantage to set unreasonable high prices which hinders the acquisition. Or in other cases, NFTs are owned by wallets with lost keys, such that the ownership will never be a complete one. We need a way to enable potential total acquisition.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "Native ETH is supported by via Wrapped EtherEIP-20.\nAfter forcedSale is set, the remaining NFTs metadata should be updated to reflect the NFTs are at most valued at the previously set TWAP price.", "Security Considerations": "The major security risks considered include", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5516, "url": "https://eips.ethereum.org/EIPS/eip-5516", "title": "Soulbound Multi-owner Tokens", "authors": ["Lucas Mart\u00edn Grasso Ramos\u00a0(", "@LucasGrasso", ")", "Matias Arazi\u00a0(", "@MatiArazi", ")"], "sections": {"ERC-5516: Soulbound Multi-owner Tokens": "This EIP proposes a standard interface for non-fungible double signature Soulbound multi-tokens. Previous account-bound token standards face the issue of users losing their account keys or having them rotated, thereby losing their tokens in the process. This EIP provides a solution to this issue that allows for the recycling of SBTs.", "An interface for non-transferable, Multi-owner NFTs binding to Ethereum accounts": "This EIP proposes a standard interface for non-fungible double signature Soulbound multi-tokens. Previous account-bound token standards face the issue of users losing their account keys or having them rotated, thereby losing their tokens in the process. This EIP provides a solution to this issue that allows for the recycling of SBTs.", "Abstract": "This EIP proposes a standard interface for non-fungible double signature Soulbound multi-tokens. Previous account-bound token standards face the issue of users losing their account keys or having them rotated, thereby losing their tokens in the process. This EIP provides a solution to this issue that allows for the recycling of SBTs.", "Motivation": "This EIP was inspired by the main characteristics of theEIP-1155token and by articles in which benefits and potential use cases of Soulbound/Accountbound Tokens (SBTs) were presented. \nThis design also allows for batch token transfers, saving on transaction costs. Trading of multiple tokens can be built on top of this standard and it removes the need to approve individual token contracts separately. It is also easy to describe and mix multiple fungible or non-fungible token types in a single contract.", "Characteristics": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Applications": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "We believe that Soulbound Tokens serve as a specialized subset of existingEIP-1155tokens. The advantage of such a design is the seamless compatibility of SBTs with existing NFT services. Service providers can treat SBTs like NFTs and do not need to make drastic changes to their existing codebase.", "SBT as an extension of EIP-1155": "We believe that Soulbound Tokens serve as a specialized subset of existingEIP-1155tokens. The advantage of such a design is the seamless compatibility of SBTs with existing NFT services. Service providers can treat SBTs like NFTs and do not need to make drastic changes to their existing codebase.", "Double-Signature": "The Double-Signature functionality was implemented to prevent the receipt of unwanted tokens. It symbolizes a handshake between the token receiver and sender, implying thatbothparties agree on the token transfer.", "Metadata.": "TheEIP-1155Metadata Interface was implemented for further compatibility withEIP-1155.", "Guaranteed log trace": "Quoted fromEIP-1155", "Exception handling": "Given the non-transferability property of SBTs, if a user\u2019s keys to an account get compromised or rotated, such user may lose the ability to associate themselves with the token.", "Multi-token": "The multi-token functionality permits the implementation of multiple token types in the same contract. Furthermore, all emitted tokens are stored in the same contract, preventing redundant bytecode from being deployed to the blockchain. It also facilitates transfer to token issuers, since all issued tokens are stored and can be accessed under the same contract address.", "ThebatchTransferfunction": "This EIP supports transfers to multiple recipients. This eases token transfer to a large number of addresses, making it more gas-efficient and user-friendly.", "Backwards Compatibility": "This proposal is only partially compatible with EIP-1155, because it makes tokens non-transferable after the first transfer.", "Reference Implementation": "You can find an implementation of this standard in../assets/EIP-5516.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5539, "url": "https://eips.ethereum.org/EIPS/eip-5539", "title": "Revocation List Registry", "authors": ["Philipp Bolte\u00a0(", "@strumswell", ")", "Lauritz Leifermann\u00a0(", "@lleifermann", ")", "Dennis von der Bey\u00a0(", "@DennisVonDerBey", ")"], "sections": {"ERC-5539: Revocation List Registry": "This EIP proposes a set of methods and standards for a role-based registry of indicators aimed for usage in revocations.", "Registry of revocation lists for revoking arbitrary data.": "This EIP proposes a set of methods and standards for a role-based registry of indicators aimed for usage in revocations.", "Abstract": "This EIP proposes a set of methods and standards for a role-based registry of indicators aimed for usage in revocations.", "Motivation": "Revocation is a universally needed construct both in the traditional centralized and decentralized credential attestation. This EIP aims to provide an interface to standardize a decentralized approach to managing and resolving revocation states in a contract registry.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Definitions": "MUSTimplement a function that returns the revocation status of a particular revocation key in a namespace\u2019s revocation list. ItMAYalso respect the revocation lists revocation status.", "Revocation Management": "MUSTimplement a function that returns the revocation status of a particular revocation key in a namespace\u2019s revocation list. ItMAYalso respect the revocation lists revocation status.", "Revocation List Management": "####OPTIONALimplements a function that returns the revocation status of a particular revocation list in a namespace.", "Owner management": "OPTIONALimplement a function to change the revocation status of a revocation list. If a revocation list is revoked, all keys in it are considered revoked.", "Delegation management": "OPTIONALimplements a function to add a delegate to an owner\u2019s revocation list in a namespace.", "Events": "MUSTbe emitted whenchangeStatus,changeStatusSigned,changeStatusDelegated,changeStatusDelegatedSigned,changeStatusesInList,changeStatusesInListSigned,changeStatusesInListDelegated, orchangeStatusesInListDelegatedSignedwas successfully executed.", "Meta Transactions": "The signature of signed transactions could potentially be replayed on different chains or deployed versions of the registry implementing this ERC. This security consideration is addressed by the usage ofEIP-712", "Rationale": "This provides every Ethereum address a reserved space, without the need to actively claim it in the contract. Initially addresses only have owner access in their own namespace.", "Why the concept of namespaces?": "This provides every Ethereum address a reserved space, without the need to actively claim it in the contract. Initially addresses only have owner access in their own namespace.", "Why does a namespace always represent the initial owner address?": "The change of an owner of a list shouldn\u2019t break the link to a revocation key in it, as already existing off-chain data may depend on it.", "Backwards Compatibility": "No backward compatibility issues were found.", "Security Considerations": "The signature of signed transactions could potentially be replayed on different chains or deployed versions of the registry implementing this ERC. This security consideration is addressed by the usage ofEIP-712", "Rights Management": "The different roles and their inherent permissions are meant to prevent changes from unauthorized entities. The revocation list owner should always be in complete control over its revocation list and who has writing access to it.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5553, "url": "https://eips.ethereum.org/EIPS/eip-5553", "title": "Representing IP and its Royalty Structure", "authors": ["Roy Osherove\u00a0(", "@royosherove", ")"], "sections": {"ERC-5553: Representing IP and its Royalty Structure": "This proposal introduces a generic way to represent intellectual property on chain, along with a refined royalty representation mechanism and associated metadata link. This standard is not associated with a specific type of IP and could represent many types of IP, such as musical IP, videos, books, images, and more.\nThe standard is kept very generic to allow the industry to evolve new ecosystems that can all rely on the same basic standard at their core.", "A way of representing intellectual property and its respective royalty structure on chain": "This proposal introduces a generic way to represent intellectual property on chain, along with a refined royalty representation mechanism and associated metadata link. This standard is not associated with a specific type of IP and could represent many types of IP, such as musical IP, videos, books, images, and more.\nThe standard is kept very generic to allow the industry to evolve new ecosystems that can all rely on the same basic standard at their core.", "Abstract": "This proposal introduces a generic way to represent intellectual property on chain, along with a refined royalty representation mechanism and associated metadata link. This standard is not associated with a specific type of IP and could represent many types of IP, such as musical IP, videos, books, images, and more.\nThe standard is kept very generic to allow the industry to evolve new ecosystems that can all rely on the same basic standard at their core.", "Motivation": "There is no accepted standard mechanism to license intellectual property or to represent it, except using traditional NFTs. However, regular NFTs only represent a collectible item use case and cannot easily represent more complicated use cases of licensing IP for different types of uses.\nWe can enable such licensing mechanisms if we can:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "royaltyPortionTokens() function": "This function MUST return an array of addresses related toEIP-20tokens that MUST represent royalty portions to different types of interested parties. These royalty portion tokens represent a more granular and streamlined way to declare royalty splits for multiple collaboration participants for the creation of the IP.", "metadataURI() function": "This function MUST return the URI to a metadata file containing any required metadata for the IP or an empty string. Each IP type MAY implement its metadata standard, defined separately. The file MUST be hosted in IPFS, Arweave, or other decentralized content-addressable systems in which the file\u2019s contents are not changeable without changing the URI.", "changeMetadataURI() function": "This function allows changing the metadata URI to point to a new version of the metadata file. Calling this function MUST trigger the eventMetadataChangedin case of success.", "ledger() function": "This function MUST return the registry or registrar contract address or an EOA account that initialized the IP and associated royalty tokens. An IP representation MAY be registered in multiple places by different actors for different purposes. This function enables market participants to discover which registry mechanism is the parent of the IP and might have special access rights to manage the IP.", "Rationale": "Current royalty implementations deal only with a single type of royalty payment: NFT sales. They also only allow a single type of royalty - i.e., Music NFTs cannot pay different people in different scenarios.\nIn other words, currently, a royalty split works the same way no matter what type of purchase or license deal has happened for all parties involved.", "Returning an array of EIP-20 tokens presents a more robust royalty portions structure/": "Current royalty implementations deal only with a single type of royalty payment: NFT sales. They also only allow a single type of royalty - i.e., Music NFTs cannot pay different people in different scenarios.\nIn other words, currently, a royalty split works the same way no matter what type of purchase or license deal has happened for all parties involved.", "Separating the IP contract from the collectible and licensing NFTs enables scaling licensing types": "By separating the canonical version of the IP from its various licensed uses (NFT purchase, streaming, usage of art and more.), this EIP introduces a path for an ecosystem of various license types and payment distributions to evolve.\nIn other words, when people use this scheme, they will not start by creating a music NFT or art NFT; they start by creating the IP Representation and then create types of licenses or collectibles for it, each as its own sellable NFT.", "A single pointer to the IP\u2019s metadata": "The IPR points to metadata housed in IPFS or Arweave and allows changing it and keeping track of the changes in a simple and standard way. Today the only metadata standard is NFT metadata extension, but it is impossible to know to which standard the document adheres. With different IP types, different metadata standards for different IP types can be formulated and have a simple, easy place to discover attached metadata.", "Reference Implementation": "There might be potential security challenges of attackers persuading holders of royalty portion tokens to send them those tokens and gaining royalty portion in various IPRs. However, these are not specific to royalties and are a common issue with EIP-20 tokens.", "Security Considerations": "There might be potential security challenges of attackers persuading holders of royalty portion tokens to send them those tokens and gaining royalty portion in various IPRs. However, these are not specific to royalties and are a common issue with EIP-20 tokens.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5554, "url": "https://eips.ethereum.org/EIPS/eip-5554", "title": "NFT Legal Use, Repurposing, and Remixing", "authors": ["Isaac Patka\u00a0(", "@ipatka", ")", "COALA Licensing Taskforce\u00a0<", "info@coala.org", ">"], "sections": {"ERC-5554: NFT Legal Use, Repurposing, and Remixing": "This EIP extends any other token standard to provide:", "An interface for describing and enforcing the legal use and remix of an NFT. On-chain registry of rights, attribution and derivative links.": "This EIP extends any other token standard to provide:", "Abstract": "This EIP extends any other token standard to provide:", "Motivation": "NFTs still face legal uncertainty, and many now realize that the rights associated with an NFT are just as important as the NFT itself. Our goal is to help the ecosystem reach clear consensus and broad understanding of what purchasers of NFTs are acquiring in terms of copyright or other rights.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Token based Attribution/ Remix": "On chain derivative works and reproductions", "Event based attribution": "For commercial exploitation or other off-chain uses of a creative work, this EIP defines events to be emitted to track the use of the work.", "Required fields": "Copyright owner per tokenID. Could just be the tokenID owner in a simple use case, or something else if desired by the creator.", "Rationale": "We expand here upon the Motivation section to justify every decision made with regard to the specs of the standard:", "Examples": "Vigd\u00eds creates a PFP collection of Bored Koalas, which is subject to standard copyright restrictions: no one has the right to reproduce, distribute, communicate, commercialize or remix these works. However, she wants to give specific permissions to those who hold a NFT from the collection. She mints the collection with this EIP, introducing a conditional license that allows for the current token holder to display the Bored Koala associated with each NFT and commercialize it for the purpose of merchandising only.", "Backwards Compatibility": "The interface defined in this standard is backward compatible with most NFT standards used in the Ethereum ecosystem as of this writing.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5559, "url": "https://eips.ethereum.org/EIPS/eip-5559", "title": "Cross Chain Write Deferral Protocol", "authors": ["Paul Gauvreau\u00a0(", "@0xpaulio", ")", "Nick Johnson\u00a0(", "@arachnid", ")"], "sections": {"ERC-5559: Cross Chain Write Deferral Protocol": "The following standard provides a mechanism in which smart contracts can request various tasks to be resolved by an external handler. This provides a mechanism in which protocols can reduce the gas fees associated with storing data on mainnet by deferring the handling of it to another system/network. These external handlers act as an extension to the core L1 contract.", "The cross chain write deferral protocol provides a mechanism to defer the storage & resolution of mutations to off-chain handlers": "The following standard provides a mechanism in which smart contracts can request various tasks to be resolved by an external handler. This provides a mechanism in which protocols can reduce the gas fees associated with storing data on mainnet by deferring the handling of it to another system/network. These external handlers act as an extension to the core L1 contract.", "Abstract": "The following standard provides a mechanism in which smart contracts can request various tasks to be resolved by an external handler. This provides a mechanism in which protocols can reduce the gas fees associated with storing data on mainnet by deferring the handling of it to another system/network. These external handlers act as an extension to the core L1 contract.", "Motivation": "EIP-3668provides a mechanism by which off-chain lookups can be defined inside smart contracts in a transparent manner. In addition, it provides a scheme in which the resolved data can be verified on-chain. However, there lacks a standard by which mutations can be requested through the native contract, to be performed on the off-chain data. Furthermore, with the increase in L2 solutions, smart contract engineers have additional tools that can be used to reduce the storage and transaction costs of performing mutations on the Ethereum mainnet.", "Specification": "There are two main handler classifications: L2 Contract and Off-Chain Database. These are determined based off of where the handler is deployed. The handler classifications are used to better define the different security guarantees and requirements associated with its deployment.", "Overview": "There are two main handler classifications: L2 Contract and Off-Chain Database. These are determined based off of where the handler is deployed. The handler classifications are used to better define the different security guarantees and requirements associated with its deployment.", "Data Stored in an L1": "In the case in which no reversion occurs, data is stored in the L1 contract when the transaction is executed.", "Data Stored in an L2": "The call or transaction to the L1 contract reverts with theStorageHandledByL2(chainId, contractAddress)error.", "Data Stored in an Off-Chain Database": "The call or transaction to the L1 contract reverts with theStorageHandledByOffChainDatabase(sender, url, data)error.", "Data Stored in an L2 & an Off-Chain Database": "The call or transaction to the L1 contract reverts with theStorageHandledByL2(chainId, contractAddress)error.", "Events": "When making changes to core variables of the handler, the corresponding event MUST be emitted. This increases the transparency associated with different managerial actions. Core variables includechainIdandcontractAddressfor L2 solutions andurlfor Off-Chain Database solutions. The events are outlined below in the WriteDeferral Interface.", "Write Deferral Interface": "Below is a basic interface that defines and describes all of the reversion types and their corresponding parameters.", "Use of transactions with storage-deferral reversions": "In some cases the contract might conditionally defer and handle mutations, in which case a transaction may be required. It is simple to use this method for sending transactions that may result in deferral reversions, as a client should receive the corresponding reversion whilepreflightingthe transaction.", "Rationale": "EIP-3668adopted the idea of using arevertto convey call information. It was proposed as a simple mechanism in which any pre-existing interface or function signature could be satisfied while maintain a mechanism to instruct and trigger an off-chain lookup.", "Use ofrevertto convey call information": "EIP-3668adopted the idea of using arevertto convey call information. It was proposed as a simple mechanism in which any pre-existing interface or function signature could be satisfied while maintain a mechanism to instruct and trigger an off-chain lookup.", "Use of multiple reversion & handler types to better define security guarantees": "By further defining the class of the handler, it gives the developer increased granularity to define the characteristics and different guarantees associated storing the data off-chain. In addition, different handlers require different parameters and verification mechanisms. This is very important for the transparency of the protocol, as they store data outside of the native ethereum ecosystem. Common implementations of this protocol could include storing non-operational data in L2 solutions and off-chain databases to reduce gas fees, while maintaining open interoperability.", "Backwards Compatibility": "Existing contracts that do not wish to use this specification are unaffected. Clients can add support for Cross Chain Write Deferrals to all contract calls without introducing any new overhead or incompatibilities.", "Security Considerations": "Deferred mutations should never resolve to mainnet ethereum. Such attempts to defer the mutation back to ETH could include hijacking attempts in which the contract developer is trying to get the user to sign and send a malicious transaction. Furthermore, when a transaction is deferred to an L2 system, it must use the originalcalldata, this prevents against potentially malicious contextual changes in the transaction.", "Fingerprinting attacks": "As all deferred mutations will include themsg.senderparameter indata, it is possible thatStorageHandledByOffChainDatabasereversions could fingerprint wallet addresses and the corresponding IP address used to make the HTTP request. The impact of this is application-specific and something the user should understand is a risk associated with off-chain handlers. To minimize the security impact of this, we make the following recommendations:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5560, "url": "https://eips.ethereum.org/EIPS/eip-5560", "title": "Redeemable NFTs", "authors": ["Olivier Fernandez\u00a0(", "@fernandezOli", ")", "Fr\u00e9d\u00e9ric Le Coidic\u00a0(", "@FredLC29", ")", "Julien B\u00e9ranger\u00a0(", "@julienbrg", ")"], "sections": {"ERC-5560: Redeemable NFTs": "The EIP is a Redeemable NFT extension which adds aredeemfunction toEIP-721. It can be implemented when an NFT issuer wants his/her NFT to be redeemed for a physical object.", "Makes an NFT redeemable for a physical object": "The EIP is a Redeemable NFT extension which adds aredeemfunction toEIP-721. It can be implemented when an NFT issuer wants his/her NFT to be redeemed for a physical object.", "Abstract": "The EIP is a Redeemable NFT extension which adds aredeemfunction toEIP-721. It can be implemented when an NFT issuer wants his/her NFT to be redeemed for a physical object.", "Motivation": "An increasing amount of NFT issuers such as artists, fine art galeries, auction houses, brands and others want to offer a physical object to the holder of a given NFT. This standard allows EIP-721 NFTs to signal reedemability.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "When the NFT contract is deployed, theisRedeemable()function returnstrueby default.", "Redeemevent": "When theredeem()function is triggered, the following eventMUSTbe emitted:", "Backwards Compatibility": "This standard is compatible with EIP-721.", "Reference Implementation": "Here\u2019s an example of an EIP-721 that includes the Redeemable extension:", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5633, "url": "https://eips.ethereum.org/EIPS/eip-5633", "title": "Composable Soulbound NFT, EIP-1155 Extension", "authors": ["HonorLabs\u00a0(", "@honorworldio", ")"], "sections": {"ERC-5633: Composable Soulbound NFT, EIP-1155 Extension": "This standard is an extension ofEIP-1155. It proposes a smart contract interface that can represent any number of soulbound and non-soulbound NFT types. Soulbound is the property of a token that prevents it from being transferred between accounts. This standard allows for each token ID to have its own soulbound property.", "Add composable soulbound property to EIP-1155 tokens": "This standard is an extension ofEIP-1155. It proposes a smart contract interface that can represent any number of soulbound and non-soulbound NFT types. Soulbound is the property of a token that prevents it from being transferred between accounts. This standard allows for each token ID to have its own soulbound property.", "Abstract": "This standard is an extension ofEIP-1155. It proposes a smart contract interface that can represent any number of soulbound and non-soulbound NFT types. Soulbound is the property of a token that prevents it from being transferred between accounts. This standard allows for each token ID to have its own soulbound property.", "Motivation": "The soulbound NFTs similar to World of Warcraft\u2019s soulbound items are attracting more and more attention in the Ethereum community. In a real world game like World of Warcraft, there are thousands of items, and each item has its own soulbound property. For example, the amulate Necklace of Calisea is of soulbound property, but another low level amulate is not. This proposal provides a standard way to represent soulbound NFTs that can coexist with non-soulbound ones. It is easy to design a composable NFTs for an entire collection in a single contract.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "If all tokens in a contract are soulbound by default,isSoulbound(uint256 id)should return true by default during implementation.", "Backwards Compatibility": "This standard is fully EIP-1155 compatible.", "Test Cases": "Test cases are included intest.js.", "Reference Implementation": "SeeERC5633.sol.", "Security Considerations": "There are no security considerations related directly to the implementation of this standard.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5635, "url": "https://eips.ethereum.org/EIPS/eip-5635", "title": "NFT Licensing Agreements", "authors": ["Timi\u00a0(", "@0xTimi", ")", "0xTriple7\u00a0(", "@ysqi", ")"], "sections": {"ERC-5635: NFT Licensing Agreements": "This EIP standardizes an NFT licensing oracle to store (register) and retrieve (discover) granted licensing agreements for non-fungible token (NFT) derivative works, which are also NFTs but are created using properties of some other underlying NFTs.", "An oracle for retrieving NFT licensing agreements": "This EIP standardizes an NFT licensing oracle to store (register) and retrieve (discover) granted licensing agreements for non-fungible token (NFT) derivative works, which are also NFTs but are created using properties of some other underlying NFTs.", "Abstract": "This EIP standardizes an NFT licensing oracle to store (register) and retrieve (discover) granted licensing agreements for non-fungible token (NFT) derivative works, which are also NFTs but are created using properties of some other underlying NFTs.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "Licensing credentials from a dNFT\u2019s contract can be retrieved withauthorizedBy, which specifies the details of a licensing agreement, which may include the oNFT. Those credentials may be verified with aregistryservice.", "Two stages: Licensing and Discovery": "Taking the moment when the dNFT is minted as the cut-off point, the stage before is called theLicensingstage, and the subsequent stage is called theDiscoverystage. The interfaceIERC5635Licensingis for theLicensingstage, and the interfacesIERC5635DNFTandIERC5635Registryare for theDiscoverystage.", "Design decision: beneficiary of licensing agreement": "As soon as someone sells their NFT, the full licensed rights are passed along to the new owner without any encumbrances, so that the beneficiary should be the new owner.", "Difference between CantBeEvil Licenses and Licensing Agreements.": "CantBeEvil licenses are creator-holder licenses which indicate what rights the NFTs\u2019 holder are granted from the creator. Meanwhile, licensing agreements is a contract between a licensor and licensee. So, CantBeEvil licenses cannot be used as a licensing agreement.", "Design decision: Relationship between different approval levels": "The approved address canlicense()the licensing agreement todNFTon behalf of the holder of anoNFT. We define two levels of approval like that:", "Backwards Compatibility": "This standard is compatible withEIP-721,EIP-1155, andEIP-2981.", "Reference Implementation": "Needs discussion.", "Examples": "Needs discussion.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5643, "url": "https://eips.ethereum.org/EIPS/eip-5643", "title": "Subscription NFTs", "authors": ["cygaar\u00a0(", "@cygaar", ")"], "sections": {"ERC-5643: Subscription NFTs": "This standard is an extension ofEIP-721. It proposes an additional interface for NFTs to be used as recurring, expirable subscriptions. The interface includes functions to renew and cancel the subscription.", "Add subscription-based functionality to EIP-721 tokens": "This standard is an extension ofEIP-721. It proposes an additional interface for NFTs to be used as recurring, expirable subscriptions. The interface includes functions to renew and cancel the subscription.", "Abstract": "This standard is an extension ofEIP-721. It proposes an additional interface for NFTs to be used as recurring, expirable subscriptions. The interface includes functions to renew and cancel the subscription.", "Motivation": "NFTs are commonly used as accounts on decentralized apps or membership passes to communities, events, and more. However, it is currently rare to see NFTs like these that have a finite expiration date. The \u201cpermanence\u201d of the blockchain often leads to memberships that have no expiration dates and thus no required recurring payments. However, for many real-world applications, a paid subscription is needed to keep an account or membership valid.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "This standard aims to make on-chain subscriptions as simple as possible by adding the minimal required functions and events for implementing on-chain subscriptions. It is important to note that in this interface, the NFT itself represents ownership of a subscription, there is no facilitation of any other fungible or non-fungible tokens.", "Subscription Management": "Subscriptions represent agreements to make advanced payments in order to receive or participate in something. In order to facilitate these agreements, a user must be able to renew or cancel their subscriptions hence therenewSubscriptionandcancelSubscriptionfunctions. It also important to know when a subscription expires - users will need this information to know when to renew, and applications need this information to determine the validity of a subscription NFT. TheexpiresAtfunction provides this functionality. Finally, it is possible that a subscription may not be renewed once expired. TheisRenewablefunction gives users and applications that information.", "Easy Integration": "Because this standard is fully EIP-721 compliant, existing protocols will be able to facilitate the transfer of subscription NFTs out of the box. With only a few functions to add, protocols will be able to fully manage a subscription\u2019s expiration, determine whether a subscription is expired, and see whether it can be renewed.", "Backwards Compatibility": "This standard can be fully EIP-721 compatible by adding an extension function set.", "Test Cases": "The following tests require Foundry.", "Reference Implementation": "Implementation:ERC5643.sol", "Security Considerations": "This EIP standard does not affect ownership of an NFT and thus can be considered secure.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5719, "url": "https://eips.ethereum.org/EIPS/eip-5719", "title": "Signature replacement interface", "authors": ["Agustin Aguilar\u00a0(", "@Agusx1211", ")"], "sections": {"ERC-5719: Signature replacement interface": "Smart contract wallet signed messages can become stale, meaning a signature that once was valid could become invalid at any point.", "Non-interactive replacing of smart contract wallet signatures that became stale due to configuration changes.": "Smart contract wallet signed messages can become stale, meaning a signature that once was valid could become invalid at any point.", "Abstract": "Smart contract wallet signed messages can become stale, meaning a signature that once was valid could become invalid at any point.", "Motivation": "In contrast to EOA signatures,EIP-1271signatures are not necessarily idempotent; they can become invalid at any point in time. This poses a challenge to protocols that rely on signatures remaining valid for extended periods of time.", "Specification": "The wallet contract MUST implement the following function:", "Client process for replacing a signature": "A client is an entity that holds a signature and intends to validate it, either for off-chain or on-chain use. To use the smart contract wallet signature, the client MUST perform the following actions:", "Rationale": "A URI is chosen because it can accommodate centralized and decentralized solutions. For example, a server can implement live re-encoding for Merkle proofs, or an IPFS link could point to a directory with all the pre-computed signature mutations.", "Backwards Compatibility": "Existing wallets that do not implement thegetAlternativeSignaturemethod can still sign messages without any changes; if any signatures become invalidated, clients will drop them on step (3).", "Security Considerations": "Some applications use signatures as secrets; these applications would risk leaking such secrets if the EIP exposes the signatures.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5744, "url": "https://eips.ethereum.org/EIPS/eip-5744", "title": "Latent Fungible Token", "authors": ["Cozy Finance\u00a0(", "@cozyfinance", ")", "Tony Sheng\u00a0(", "@tonysheng", ")", "Matt Solomon\u00a0(", "@mds1", ")", "David Laprade\u00a0(", "@davidlaprade", ")", "Payom Dousti\u00a0(", "@payomdousti", ")", "Chad Fleming\u00a0(", "@chad-js", ")", "Franz Chen\u00a0(", "@Dendrimer", ")"], "sections": {"ERC-5744: Latent Fungible Token": "The following standard is an extension ofEIP-20that enables tokens to become fungible after some initial non-fungible period.\nOnce minted, tokens are non-fungible until they reach maturity.\nAt maturity, they become fungible and can be transferred, traded, and used in any way that a standard EIP-20 token can be used.", "An interface for tokens that become fungible after a period of time.": "The following standard is an extension ofEIP-20that enables tokens to become fungible after some initial non-fungible period.\nOnce minted, tokens are non-fungible until they reach maturity.\nAt maturity, they become fungible and can be transferred, traded, and used in any way that a standard EIP-20 token can be used.", "Abstract": "The following standard is an extension ofEIP-20that enables tokens to become fungible after some initial non-fungible period.\nOnce minted, tokens are non-fungible until they reach maturity.\nAt maturity, they become fungible and can be transferred, traded, and used in any way that a standard EIP-20 token can be used.", "Motivation": "Example use cases include:", "Specification": "All latent fungible tokens MUST implement EIP-20 to represent the token.\nThebalanceOfandtotalSupplyreturn quantities for all tokens, not just the matured, fungible tokens.\nA new method calledbalanceOfMaturedMUST be added to the ABI.\nThis method returns the balance of matured tokens for a given address:", "Rationale": "Themintsmethod is optional because the ID is optional. In some use cases such as vesting where a user may have a maximum of one mint, an ID is not required.", "Backwards Compatibility": "This proposal is fully backward compatible with the EIP-20 standard and has no known compatibility issues with other standards.", "Security Considerations": "Iterating over large arrays of mints is not recommended, as this is very expensive and may cause the protocol, or just a user\u2019s interactions with it, to be stuck if this exceeds the block gas limit and reverts. There are some ways to mitigate this, with specifics dependent on the implementation.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5753, "url": "https://eips.ethereum.org/EIPS/eip-5753", "title": "Lockable Extension for EIP-721", "authors": ["Filipp Makarov\u00a0(", "@filmakarov", ")"], "sections": {"ERC-5753: Lockable Extension for EIP-721": "This standard is an extension ofEIP-721. It introduces lockable NFTs. The locked asset can be used in any way except by selling and/or transferring it. The owner or operator can lock the token. When a token is locked, the unlocker address (an EOA or a contract) is set. Only the unlocker is able tounlockthe token.", "Interface for disabling token transfers (locking) and re-enabling them (unlocking).": "This standard is an extension ofEIP-721. It introduces lockable NFTs. The locked asset can be used in any way except by selling and/or transferring it. The owner or operator can lock the token. When a token is locked, the unlocker address (an EOA or a contract) is set. Only the unlocker is able tounlockthe token.", "Abstract": "This standard is an extension ofEIP-721. It introduces lockable NFTs. The locked asset can be used in any way except by selling and/or transferring it. The owner or operator can lock the token. When a token is locked, the unlocker address (an EOA or a contract) is set. Only the unlocker is able tounlockthe token.", "Motivation": "With NFTs, digital objects become digital goods, which are verifiably ownable, easily tradable, and immutably stored on the blockchain. That\u2019s why it\u2019s very important to continuously improve UX for non-fungible tokens, not just inherit it from one of the fungible tokens.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Contract Interface": "ThesupportsInterfacemethod MUST returntruewhen called with0x72b68110.", "Rationale": "This approach proposes a solution that is designed to be as minimal as possible. It only allows to lock the item (stating who will be able to unlock it) and unlock it when needed if a user has permission to do it.", "Backwards Compatibility": "This standard is compatible with currentEIP-721standards.", "Reference Implementation": "There are no security considerations related directly to the implementation of this standard for the contract that managesEIP-721tokens.", "Security Considerations": "There are no security considerations related directly to the implementation of this standard for the contract that managesEIP-721tokens.", "Considerations for the contracts that work with lockable tokens": "Copyright and related rights waived viaCC0", "Copyright": "Copyright and related rights waived viaCC0", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5805, "url": "https://eips.ethereum.org/EIPS/eip-5805", "title": "Voting with delegation", "authors": ["Hadrien Croubois\u00a0(", "@Amxx", ")", "Francisco Giordano\u00a0(", "@frangio", ")"], "sections": {"ERC-5805: Voting with delegation": "Many DAOs (decentralized autonomous organizations) rely on tokens to represent one\u2019s voting power. In order to perform this task effectively, the token contracts need to include specific mechanisms such as checkpoints and delegation. The existing implementations are not standardized. This ERC proposes to standardize the way votes are delegated from one account to another, and the way current and past votes are tracked and queried. The corresponding behavior is compatible with many token types, including but not limited toERC-20andERC-721. This ERC also considers the diversity of time tracking functions, allowing the voting tokens (and any contract associated with it) to track the votes based onblock.number,block.timestamp, or any other non-decreasing function.", "An interface for voting weight tracking, with delegation support": "Many DAOs (decentralized autonomous organizations) rely on tokens to represent one\u2019s voting power. In order to perform this task effectively, the token contracts need to include specific mechanisms such as checkpoints and delegation. The existing implementations are not standardized. This ERC proposes to standardize the way votes are delegated from one account to another, and the way current and past votes are tracked and queried. The corresponding behavior is compatible with many token types, including but not limited toERC-20andERC-721. This ERC also considers the diversity of time tracking functions, allowing the voting tokens (and any contract associated with it) to track the votes based onblock.number,block.timestamp, or any other non-decreasing function.", "Abstract": "Many DAOs (decentralized autonomous organizations) rely on tokens to represent one\u2019s voting power. In order to perform this task effectively, the token contracts need to include specific mechanisms such as checkpoints and delegation. The existing implementations are not standardized. This ERC proposes to standardize the way votes are delegated from one account to another, and the way current and past votes are tracked and queried. The corresponding behavior is compatible with many token types, including but not limited toERC-20andERC-721. This ERC also considers the diversity of time tracking functions, allowing the voting tokens (and any contract associated with it) to track the votes based onblock.number,block.timestamp, or any other non-decreasing function.", "Motivation": "Beyond simple monetary transactions, decentralized autonomous organizations are arguably one of the most important use cases of blockchain and smart contract technologies. Today, many communities are organized around a governance contract that allows users to vote. Among these communities, some represent voting power using transferable tokens (ERC-20,ERC-721, other). In this context, the more tokens one owns, the more voting power one has. Governor contracts, such as Compound\u2019sGovernorBravo, read from these \u201cvoting token\u201d contracts to get the voting power of the users.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Methods": "Compliant contracts SHOULD implement ERC-6372 (Contract clock) to announce the clock that is used for vote tracking.", "Events": "delegatorchanges the delegation of its assets fromfromDelegatetotoDelegate.", "Solidity interface": "Letclockbe the current clock.", "Expected properties": "Letclockbe the current clock.", "Rationale": "Delegation allows token holders to trust a delegate with their vote while keeping full custody of their token. This means that only a small-ish number of delegates need to pay gas for voting. This leads to better representation of small token holders by allowing their votes to be cast without requiring them to pay expensive gas fees. Users can take over their voting power at any point, and delegate it to someone else, or to themselves.", "Backwards Compatibility": "Compound and OpenZeppelin already provide implementations of voting tokens. The delegation-related methods are shared between the two implementations and this ERC. For the vote lookup, this ERC uses OpenZeppelin\u2019s implementation (with return type uint256) as Compound\u2019s implementation causes significant restrictions of the acceptable values (return type is uint96).", "Security Considerations": "Before doing a lookup, one should check the return value ofclock()and make sure that the parameters of the lookup are consistent. Performing a lookup using a timestamp argument on a contract that uses block numbers will very likely cause a revert. On the other end, performing a lookup using a block number argument on a contract that uses timestamps will likely return 0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5827, "url": "https://eips.ethereum.org/EIPS/eip-5827", "title": "Auto-renewable allowance extension", "authors": ["zlace\u00a0(", "@zlace0x", ")", "zhongfu\u00a0(", "@zhongfu", ")", "edison0xyz\u00a0(", "@edison0xyz", ")"], "sections": {"ERC-5827: Auto-renewable allowance extension": "This extension adds a renewable allowance mechanism toERC-20allowances, in which arecoveryRatedefines the amount of token per second that the allowance regains towards the initial maximum approvalamount.", "Extension to enable automatic renewals on allowance approvals": "This extension adds a renewable allowance mechanism toERC-20allowances, in which arecoveryRatedefines the amount of token per second that the allowance regains towards the initial maximum approvalamount.", "Abstract": "This extension adds a renewable allowance mechanism toERC-20allowances, in which arecoveryRatedefines the amount of token per second that the allowance regains towards the initial maximum approvalamount.", "Motivation": "Currently, ERC-20 tokens support allowances, with which token owners can allow a spender to spend a certain amount of tokens on their behalf. However, this is not ideal in circumstances involving recurring payments (e.g. subscriptions, salaries, recurring direct-cost-averaging purchases).", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Additional interfaces": "Token Proxy", "Rationale": "Renewable allowances can be implemented with discrete resets per time cycle. However, a continuousrecoveryRateallows for more flexible use cases not bound by reset cycles and can be implemented with simpler logic.", "Backwards Compatibility": "Existing ERC-20 token contracts can delegate allowance enforcement to a proxy contract that implements this specification.", "Reference Implementation": "An minimal implementation is includedhere", "Security Considerations": "This EIP introduces a stricter set of constraints compared to ERC-20 with unlimited allowances. However, when_recoveryRateis set to a large value, large amounts can still be transferred over multiple transactions.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5850, "url": "https://eips.ethereum.org/EIPS/eip-5850", "title": "Complex Numbers stored in `bytes32` types", "authors": ["Paul Edge\u00a0(", "@genkifs", ")"], "sections": {"ERC-5850: Complex Numbers stored in `bytes32` types": "This EIP proposes a natural way for complex numbers to be stored in and retrieved from thebytes32data-type.  It splits the storage space exactly in half and, most importantly, assigns the real number part to the least significant 16 bytes and the imaginary number part to the most significant 16 bytes.", "Store real and imaginary parts of complex numbers in the least significant and most significant 16 bytes respectively of a `bytes32` type.": "This EIP proposes a natural way for complex numbers to be stored in and retrieved from thebytes32data-type.  It splits the storage space exactly in half and, most importantly, assigns the real number part to the least significant 16 bytes and the imaginary number part to the most significant 16 bytes.", "Abstract": "This EIP proposes a natural way for complex numbers to be stored in and retrieved from thebytes32data-type.  It splits the storage space exactly in half and, most importantly, assigns the real number part to the least significant 16 bytes and the imaginary number part to the most significant 16 bytes.", "Motivation": "Complex numbers are an essential tool for many mathematical and scientific calculations.  For example, Fourier Transforms, Characteristic functions, AC Circuits and Navier-Stokes equations all require the concept.", "Specification": "A complex number would be defined asbytes32and a cartesian representation would be initalized with thecnNewfunction and converted back withRealIm, both given below.", "Rationale": "An EIP is required as this proposal defines a complex numbers storage/type standard for multiple apps to use.", "Backwards Compatibility": "There is no impact on other uses of thebytes32datatype.", "Security Considerations": "If complex numbers are manipulated inbytes32form then overflow checks must be performed manually during the manipulation.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5851, "url": "https://eips.ethereum.org/EIPS/eip-5851", "title": "On-Chain Verifiable Credentials", "authors": ["Yu Liu\u00a0(", "@yuliu-debond", ")", "Junyi Zhong\u00a0(", "@Jooeys", ")"], "sections": {"ERC-5851: On-Chain Verifiable Credentials": "This proposal introduces a method of certifying that a particular address meets a claim, and a method of verifying those certifications using on-chain metadata. Claims are assertions or statements made about a subject having certain properties that may be met conditions (for example:age >= 18), and are certified by issuers using a Soundbound Token (SBT).", "Interface for contracts that manage verifiable claims and identifiers as Soulbound tokens.": "This proposal introduces a method of certifying that a particular address meets a claim, and a method of verifying those certifications using on-chain metadata. Claims are assertions or statements made about a subject having certain properties that may be met conditions (for example:age >= 18), and are certified by issuers using a Soundbound Token (SBT).", "Abstract": "This proposal introduces a method of certifying that a particular address meets a claim, and a method of verifying those certifications using on-chain metadata. Claims are assertions or statements made about a subject having certain properties that may be met conditions (for example:age >= 18), and are certified by issuers using a Soundbound Token (SBT).", "Motivation": "On-chain issuance of verifiable attestations are essential for use-case like:", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Definitions": "Claims MUST be exposed in the following structures:", "Metadata Standard": "Claims MUST be exposed in the following structures:", "Interface specification": "TBD", "Rationale": "TBD", "Backwards Compatibility": "Test cases for the minimal reference implementation can be foundherefor using transaction verification regarding whether the users hold the tokens or not. Use Remix IDE to compile and test the contracts.", "Test Cases": "Test cases for the minimal reference implementation can be foundherefor using transaction verification regarding whether the users hold the tokens or not. Use Remix IDE to compile and test the contracts.", "Reference Implementation": "Theinterfaceis divided into two separate implementations:", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 5883, "url": "https://eips.ethereum.org/EIPS/eip-5883", "title": "Token Transfer by Social Recovery", "authors": ["Erhard Dinhobl\u00a0(", "@mrqc", ")", "Kevin Riedl\u00a0(", "@wsdt", ")"], "sections": {"ERC-5883: Token Transfer by Social Recovery": "This EIP standardizes a mechanism of a social recovery where a token may be transferred from an inaccessible account to a new account, given enough approvals from other identities. This approval is not purely technical, but rather needs human intervention. These humans are - based on the Soul Bound Token proposal - called Souls. When enough Souls give their approval (which is a Yes/No decision) and a threshold is reached, a token is transferred from an old to a new identity.", "On-Chain Social Recovery taking users' reputation into account & using a nearest-neighbour approach.": "This EIP standardizes a mechanism of a social recovery where a token may be transferred from an inaccessible account to a new account, given enough approvals from other identities. This approval is not purely technical, but rather needs human intervention. These humans are - based on the Soul Bound Token proposal - called Souls. When enough Souls give their approval (which is a Yes/No decision) and a threshold is reached, a token is transferred from an old to a new identity.", "Abstract": "This EIP standardizes a mechanism of a social recovery where a token may be transferred from an inaccessible account to a new account, given enough approvals from other identities. This approval is not purely technical, but rather needs human intervention. These humans are - based on the Soul Bound Token proposal - called Souls. When enough Souls give their approval (which is a Yes/No decision) and a threshold is reached, a token is transferred from an old to a new identity.", "Motivation": "It is a known problem that the private key of an account can be lost. If that key is lost it\u2019s not possible to recover the tokens owned by that account. The holder loses those tokens forever. In addition to directly harming the token holder, the entire  ecosystem of the token itself is affected: the more tokens that are lost the less tokens are available for the natural growth and planned evolution of that ecosystem.", "Specification": "The math behind it:", "Rationale": "The formula proposed was deemed very resilient and provides a coherent incentivation structure to actually see value in the on-chain score. The formula adds weights based on scores based on time which further contributes to the fairness of the metric.", "Security Considerations": "1) We currently do not see any mechanism of preventing a user of getting a lot of rewards. Sure, a high reward is bound to a lot of investment but the person who wants to get that reward amount and has a enough money will reach it. The only thing which could be improved is that we somehow find a mechanism really identify users bound to an address. We thought about having a kind of a hashing mechanism which hashes a real world object which could be fuzzy (for sure!) and generates a hash out of it which is the same based on the fuzzy set.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5902, "url": "https://eips.ethereum.org/EIPS/eip-5902", "title": "Smart Contract Event Hooks", "authors": ["Simon Brown\u00a0(", "@orbmis", ")"], "sections": {"ERC-5902: Smart Contract Event Hooks": "This EIP proposes a standard for creating \u201chooks\u201d that allow a smart contract function to be called automatically in response to a trigger fired by another contract, by using a public relayer network as a messaging bus.", "Format that allows contracts to semi-autonoumously respond to events emitted by other contracts": "This EIP proposes a standard for creating \u201chooks\u201d that allow a smart contract function to be called automatically in response to a trigger fired by another contract, by using a public relayer network as a messaging bus.", "Abstract": "This EIP proposes a standard for creating \u201chooks\u201d that allow a smart contract function to be called automatically in response to a trigger fired by another contract, by using a public relayer network as a messaging bus.", "Motivation": "There exists a number of use cases that require some off-chain party to monitor the chain and respond to on-chain events by broadcasting a transaction.  Such cases usually require some off-chain process to run alongside an Ethereum node in order to subscribe to events emitted by smart contract, and then execute some logic in response and subsequently broadcast a transaction to the network.  This requires an Ethereum node and an open websocket connection to some long-running process that may only be used infrequently, resulting in a sub-optimal use of resources.", "Collateralised Lending Protocols": "Collateralised lending protocols or stablecoins can emit events whenever they receive price oracle updates, which would allow borrowers to automatically \u201ctop-up\u201d their open positions to avoid liquidation.", "Automated Market Makers": "AMM liquidity pools could fire a hook event whenever liquidity is added or removed.  This could allow a subscriber smart contracts to add or remove liquidity once the total pool liquidity reaches a certain point.", "DAO Voting": "Hook events can be emitted by a DAO governance contract to signal that a proposal has been published, voted on, carried or vetoed, and would allow any subscriber contract to automatically respond accordingly. For example, to execute some smart contract function whenever a specific proposal has passed, such as an approval for payment of funds.", "Scheduled Function Calls": "A scheduler service can be created whereby a subscriber can register for a scheduled funtion call, this could be done using unix cron format and the service can fire events from a smart contract on separate threads.  Subscriber contracts can subscriber to the respective threads in order to subscribe to certain schedules (e.g. daily, weekly, hourly etc.), and could even register customer cron schedules.", "Recurring Payments": "A service provider can fire Hook events that will allow subscriber contracts to automatically pay their service fees on a regular schedule.  Once the subscriber contracts receive a hook event, they can call a function on the service provider\u2019s contract to transfer funds due.", "Coordination via Delegation": "Hook event payloads can contain any arbitrary data, this means you can use things like the Delegatable framework to sign off-chain delegations which can faciliate a chain of authorized entities to publish valid Hook events.  You can also use things like BLS threshold signatures, to facilitate multiple off-chain publishers to authorize the firing of a Hook.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Registering a Publisher": "Both the publisher and subscriber contractsMUSTregister in a specific register contract, similarly to how smart contracts register an interface in theERC-1820contract.  The registry contractMUSTmust use a deterministic deployment mechanism, i.e. using a factory contract and a specific salt.", "Updating a Hook": "Publishers may want to update the details associated with a Hook event, or indeed remove support for a Hook event completely.  The registry contractMUSTimplement theupdatePublisherfunction to allow for an existing publisher contract to be updated in the registry.  The registry contractMUSTemit aPublisherUpdatedevent to indicate that the publisher contract was updated.", "Removing a Hook": "To remove a previously registered Hook, the functionremoveHookfunction must be called on the Registry contract, with the same parameters as theupdateHookfunction. The registry contractMUSTemit aHookRemovedevent with the same parameters as passed to the \u2018removeHook\u2019 function and themsg.sendervalue.", "Registering a Subscriber": "To register a subscriber to a hook, theregisterSubscriberfunctionMUSTbe called on the registry contract with the following parameters:", "Updating a Subscription": "To update a subscription, theupdateSubscriberfunctionMUSTbe called with the same set of parameters as theregisterSubscriberfunction.  This might be done in order to cancel a subscription, or to change the subscription fee. Note that theupdateSubscriberfunctionMUSTmaintain the samemsg.senderthat theregisterSubscriberfunction was called with.", "Removing a Subscription": "To remove a previously registered subscription, the functionremoveSubscriberMUSTbe called on the Registry contract, with the same parameters as theupdateSubscriberfunction, but without thefeeparameter (i.e. publisher and subscriber contract addresses and thread id). The fee will be subsequently set to 0 to indicate that the subscriber no longer wants updates for this subscription.  The registry contractMUSTemit aSubscriptionRemovedevent with publisher contract address, subscriber contract address and the thread id as topics.", "Publishing an Event": "A publisher contractSHOULDemit a hook event from at least one function. The emitted eventMUSTbe calledHookandMUSTcontain the following parameters:", "Relayers": "Relayers are independent parties that listen toHookevents on publisher smart contracts.  Relayers retrieve a list of subscribers for different hooks from the registry, and listen for hook events being fired on the publisher contracts.  Once a hook event has been fired by a publisher smart contract, relayers can decide to relay the hook event\u2019s payload to the subscriber contracts by broadcasting a transaction that executes the subscriber contract\u2019sverifyHookfunction.  Relayers are incentivised to do this because it is expected that the subscriber contract will remunerate them with ETH, or some other asset.", "Verifying a Hook Event": "TheverifyHookfunction of the subscriber contractsSHOULDinclude logic to ensure that they are retrieving authentic events. In the case where the Hook event contains a signature, then subscriber contractsSHOULDcreate a hash of the required parameters, andSHOULDverify that the signature in the hook event is valid against the derived hash and the publisher\u2019s public key (see the reference implemenetation for an example).  The hook functionSHOULDalso verify the nonce of the hook event and record it internally, in order to prevent replay attacks.", "Interfaces": "IRegistry.sol", "Rationale": "The rationale for this design is that it allows smart contract developers to write contract logic that listens and responds to events fired in other smart contracts, without requiring them to run some dedicated off-chain process to achieve this.  This best suits any simple smart contract logic that runs relatively infrequently in response to events in other contracts.", "Security Considerations": "It is imperative that subscriber contracts trust the publisher contracts not to fire events that hold no intrinsic interest or value for them, as it is possible that malicious publisher contracts can publish a large number of events that will in turn drain the ETH from the subscriber contracts.", "Griefing Attacks": "It is imperative that subscriber contracts trust the publisher contracts not to fire events that hold no intrinsic interest or value for them, as it is possible that malicious publisher contracts can publish a large number of events that will in turn drain the ETH from the subscriber contracts.", "Front-running Attacks": "It is advised not to rely on signatures alone to validate Hook events. It is important for publishers and subscribers of hooks to be aware that it is possible for a relayer to relay hook events before they are published, by examining the publisher\u2019s transaction in the mempool before it actually executes in the publisher\u2019s smart contract.  The normal flow is for a \u201ctrigger\u201d transaction to call a function in the publisher smart contract, which in turn fires an event which is then picked up by relayers.  Competitive relayers will observe that it is possible to pluck the signature and payload from the trigger transaction in the public mempool and simply relay it to subscriber contracts before the trigger transaction has been actually included in a block.  In fact, it is possible that the subscriber contracts process the event before the trigger transaction is processed, based purely on gas fee dynamics.  This can mitigated against by subscriber contracts calling theverifyEventHookfunction on the publisher contract when they receive a Hook event.", "Relayer Competition": "By broadcasting transactions to a segregated mempool, relayers protect themselves from front-running by generalized MEV bots, but their transactions can still fail due to competition from other relayers.  If two or more relayers decide to start relaying hook events from the same publisher to the same subscribers, then the relay transactions with the highest gas price will be executed before the others.  This will result in the other relayer\u2019s transactions potentially failing on-chain, by being included later in the same block.  For now, there are certain transaction optimization services that will prevent transactions from failing on-chain, which will offer a solution to this problem, though this is out-of-scope for this document.", "Optimal Fees": "The fees that are paid to relayers are at the discretion of the subscribers, but it can be non-trivial to set fees to their optimal level, especially when considering volatile gas fees and competition between relayers.  This will result in subscribers setting fees to a perceived \u201csafe\u201d level, which they are confident will incentivize relayers to relay Hook events.  This will inevitably lead to poor price discovery and subscribers over-paying for updates.", "Without an Auction": "In order to cultivate and maintain a reliable relayer market without the use of an auction mechanism, subscriber contracts would need to implement logic to either rebate any gas fees up to a specified limit, (while still allowing for execution of hook updates under normal conditions).", "Relayer Transaction Batching": "Another important consideration is with batching of Hook events. Relayers are logically incentivized to batch Hook updates to save on gas, seeing as gas savings amount to 21,000 * n where n is the number of hooks being processed in a block by a single relayer.  If a relayer decides to batch multiple Hook event updates to various subscriber contracts into a single transaction, via a multi-call proxy contract, then they increase the risk of the entire batch failing on-chain if even one of the transactions in the batch fails on-chain.  For example, if relayer A batches x number of Hook updates, and relayer B batches y number of Hook updates, it is possible that relayer A\u2019s batch is included in the same block in front of relayer B\u2019s batch, and if both batches contain at least one duplicate, (i.e. the same Hook event to the same subscriber), then this will cause relayer B\u2019s batch transaction to revert on-chain.  This is an important consideration for relayers, and suggests that relayers should have access to some sort of bundle simulation service to identify conflicting transactions before they occur.", "Replay Attacks": "When using signature verification, it is advised to use theEIP-712standard in order to prevent cross network replay attacks, where the same contract deployed on more than one network can have its hook events pushed to subscribers on other networks, e.g. a publisher contract on Polygon can fire a hook event that could be relayed to a subscriber contract on Gnosis Chain.  Whereas the keys used to sign the hook events should ideally be unique, in reality this may not always be the case.", "Cross-chain Messaging": "There is also the possibility to leverage thechainIdfor more than preventing replay attacks, but also for accepting messages from other chains.  In this use-case the subscriber contracts should register on the same chain that the subscriber contract is deployed on, and should set thechainIdto the chain it wants to receive hook events from.", "Copyright": "Copyright and related rights waived via CC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6047, "url": "https://eips.ethereum.org/EIPS/eip-6047", "title": "ERC-721 Balance indexing via Transfer event", "authors": ["Zainan Victor Zhou\u00a0(", "@xinbenlv", ")"], "sections": {"ERC-6047: ERC-721 Balance indexing via Transfer event": "This EIP extendsERC-721to allow the tracking and indexing of NFTs by mandating that a pre-existing event be emitted during contract creation.", "Mandates emitting the Transfer event for ERC-721 NFTs during contract creation": "This EIP extendsERC-721to allow the tracking and indexing of NFTs by mandating that a pre-existing event be emitted during contract creation.", "Abstract": "This EIP extendsERC-721to allow the tracking and indexing of NFTs by mandating that a pre-existing event be emitted during contract creation.", "Motivation": "ERC-721requires aTransferevent to be emitted whenever a transfer or mint (i.e. transfer from0x0) or burn (i.e. transfer to0x0) occurs, EXCEPT for during contract creation. Due to this exception, contracts can mint NFTs during contract creation without the event being emitted. Unlike ERC-721, theERC-1155standard mandates events to be emitted regardless of whether such minting occurs during or outside of contract creation. This allows an indexing service or any off-chain service to reliably capture and account for token creation.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "Using the existingTransferevent instead of creating a new event (e.g.Creation) allows this EIP to be backward compatible with existing indexers.E", "Backwards Compatibility": "All contracts compliant with this EIP are compliant with ERC-721. However, not all contracts compliant with ERC-721 are compliant with this EIP.", "Security Considerations": "No new security concerns.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6268, "url": "https://eips.ethereum.org/EIPS/eip-6268", "title": "Untransferability Indicator for EIP-1155", "authors": ["Yuki Aoki\u00a0(", "@yuki-js", ")"], "sections": {"ERC-6268: Untransferability Indicator for EIP-1155": "This EIP standardizes an interface indicatingEIP-1155-compatible token non-transferability usingEIP-165feature detection.", "An extension of EIP-1155 for indicating the transferability of the token.": "This EIP standardizes an interface indicatingEIP-1155-compatible token non-transferability usingEIP-165feature detection.", "Abstract": "This EIP standardizes an interface indicatingEIP-1155-compatible token non-transferability usingEIP-165feature detection.", "Motivation": "Soulbound Tokens (SBT) are non-transferable tokens. WhileEIP-5192standardizes non-fungible SBTs, a standard for Soulbound semi-fungible or fungible tokens does not yet exist. The introduction of a standard non-transferability indicator that is agnostic to fungibility promotes the usage of Souldbound semi-fungible or fungible tokens.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "Needs discussion.", "Backwards Compatibility": "This proposal is fully backward compatible withEIP-1155.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6353, "url": "https://eips.ethereum.org/EIPS/eip-6353", "title": "Charity token", "authors": ["Aubay\u00a0<", "blockchain-team@aubay.com", ">", "BOCA Jeabby\u00a0(", "@bjeabby1507", ")", "EL MERSHATI Laith\u00a0(", "@lth-elm", ")", "KEMP Elia\u00a0(", "@eliakemp", ")"], "sections": {"ERC-6353: Charity token": "An extension toEIP-20that can automatically send an additional percentage of each transfer to a third party, and that provides an interface for retrieving this information. This can allow token owners to make donations to a charity with every transfer. This can also be used to allow automated savings programs.", "Extension of EIP-20 token that can be partially donated to a charity project": "An extension toEIP-20that can automatically send an additional percentage of each transfer to a third party, and that provides an interface for retrieving this information. This can allow token owners to make donations to a charity with every transfer. This can also be used to allow automated savings programs.", "Abstract": "An extension toEIP-20that can automatically send an additional percentage of each transfer to a third party, and that provides an interface for retrieving this information. This can allow token owners to make donations to a charity with every transfer. This can also be used to allow automated savings programs.", "Motivation": "There are charity organizations with addresses on-chain, and there are token holders who want to make automated donations. Having a standardized way of collecting and managing these donations helps users and user interface developers. Users can make an impact with their token and can contribute to achieving sustainable blockchain development. Projects can easily retrieve charity donations addresses and rate for a givenEIP-20token, token holders can compare minimum rate donation offers allowed by token contract owners. This standard provides functionality that allows token holders to donate easily.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Functions": "Add address to whitelist and set the rate to the default rate.", "Rationale": "This EIP chooses to whitelist charity addresses by using an array and keeping track of the \u201cactive\u201d status with a mappingwhitelistedRateto allow multiple choice of recipient and for transparence. The donation address can also be a single address chosen by the owner of the contract and modified by period.", "Backwards Compatibility": "This implementation is an extension of the functionality ofEIP-20, it introduces new functionality retaining the core interfaces and functionality of theEIP-20standard. There is a small backwards compatibility issue, indeed if an account has insufficient balance, it\u2019s possible for the transfer to fail.", "Test Cases": "Tests can be found incharity.js.", "Reference Implementation": "The reference implementation of the standard can be found undercontracts/folder.", "Security Considerations": "There are no additional security considerations compared to EIP-20.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6384, "url": "https://eips.ethereum.org/EIPS/eip-6384", "title": "Human-readable offline signatures", "authors": ["Tal Be'ery\u00a0<", "tal@zengo.com", ">", "RoiV\u00a0(", "@DeVaz1", ")"], "sections": {"ERC-6384: Human-readable offline signatures": "This EIP introduces theevalEIP712Bufferfunction, which takes anEIP-712buffer and returns a human-readable text description.", "A method for retrieving a human-readable description of EIP-712 typed and structured data.": "This EIP introduces theevalEIP712Bufferfunction, which takes anEIP-712buffer and returns a human-readable text description.", "Abstract": "This EIP introduces theevalEIP712Bufferfunction, which takes anEIP-712buffer and returns a human-readable text description.", "Motivation": "The use case of Web3 off-chain signatures intended to be used within on-chain transaction is gaining traction and being used in multiple leading protocols (e.g. OpenSea) and standardsEIP-2612, mainly as it offers a fee-less experience.\nAttackers are known to actively and successfully abuse such off-chain signatures, leveraging the fact that users are blindly signing off-chain messages, since they are not humanly readable.\nWhileEIP-712originally declared in its title that being \u201dhumanly readable\u201d is one of its goals, it did not live up to its promise eventually and EIP-712 messages are not understandable by an average user.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Function\u2019s inputs": "The inputs of the function:", "Function\u2019s output(s)": "The output of the function is an array of strings. The wallet SHOULD display them to its end-users. The wallet MAY choose to augment the returned strings with additional data. (e.g. resolve contract addresses to their name)", "Support for EIP-712 messages that are not meant to be used on-chain": "IfverifyingContractis not included in the EIP-712 domain separator, wallets MUST NOT retrieve a human-readable description using this EIP. In this case, wallets SHOULD fallback to their original EIP-712 display.", "Rationale": "Currently, the best choice for users is to rely on some 3rd party solutions that get the proposed message as input and explain its intended meaning to the user. This approach is:", "Alternative solutions": "Currently, the best choice for users is to rely on some 3rd party solutions that get the proposed message as input and explain its intended meaning to the user. This approach is:", "Backwards Compatibility": "For non-supporting contracts the wallets will default to showing whatever they are showing today.\nNon-supporting wallets will not call this function and will default to showing whatever they are showing today.", "Reference Implementation": "A reference implementation can be foundhere.\nThis toy example shows how anEIP-20contract supporting this EIP implements an EIP-712 support for \u201ctransferWithSig\u201d functionality (a non-standard variation on Permit, as the point of this EIP is to allow readability to non-standard EIP-712 buffers).\nTo illustrate the usability of this EIP to some real world use case, a helper function for the actual OpenSea\u2019s SeaPort EIP-712 is implemented too inhere.", "Security Considerations": "The attack is facilitated by a rogue web2 interface (\u201cdapp\u201d) that provides bad parameters for an EIP-712 formatted message that is intended to be consumed by a legitimate contract. Therefore, the message is controlled by attackers and cannot be trusted, however the contract is controlled by a legitimate party and can be trusted.", "The threat model:": "The attack is facilitated by a rogue web2 interface (\u201cdapp\u201d) that provides bad parameters for an EIP-712 formatted message that is intended to be consumed by a legitimate contract. Therefore, the message is controlled by attackers and cannot be trusted, however the contract is controlled by a legitimate party and can be trusted.", "Analysis of the proposed solution": "The explanation is controlled by the relevant contract which is controlled by a legitimate party. The attacker must specify the relevant contract address, as otherwise it will not be accepted by it. Therefore, the attacker cannot create false explanations using this method.\nPlease note that if the explanation was part of the message to sign it would have been under the control of the attacker and hence irrelevant for security purposes.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6464, "url": "https://eips.ethereum.org/EIPS/eip-6464", "title": "Multi-operator, per-token ERC-721 approvals.", "authors": ["Cristian Espinoza\u00a0(", "@crisgarner", ")", "Simon Fremaux\u00a0(", "@dievardump", ")", "David Huber\u00a0(", "@cxkoda", ")", "and Arran Schlosberg\u00a0(", "@aschlosberg", ")"], "sections": {"ERC-6464: Multi-operator, per-token ERC-721 approvals.": "ERC-721did not foresee the approval of multiple operators to manage a specific token on behalf of its owner. This lead to the establishment ofsetApprovalForAll()as the predominant way to authorise operators, which affords the approved address control over all assets and creates an unnecessarily broad security risk that has already been exploited in a multitude of phishing attacks. The presented EIP extends ERC-721 by introducing a fine-grained, on-chain approval mechanism that allows owners to authorise multiple, specific operators on a per-token basis; this removes unnecessary access permissions and shrinks the surface for exploits to a minimum. The provided reference implementation further enables cheap revocation of all approvals on a per-owner or per-token basis.", "Extends ERC-721 to allow token owners to approve multiple operators to control their assets on a per-token basis.": "ERC-721did not foresee the approval of multiple operators to manage a specific token on behalf of its owner. This lead to the establishment ofsetApprovalForAll()as the predominant way to authorise operators, which affords the approved address control over all assets and creates an unnecessarily broad security risk that has already been exploited in a multitude of phishing attacks. The presented EIP extends ERC-721 by introducing a fine-grained, on-chain approval mechanism that allows owners to authorise multiple, specific operators on a per-token basis; this removes unnecessary access permissions and shrinks the surface for exploits to a minimum. The provided reference implementation further enables cheap revocation of all approvals on a per-owner or per-token basis.", "Abstract": "ERC-721did not foresee the approval of multiple operators to manage a specific token on behalf of its owner. This lead to the establishment ofsetApprovalForAll()as the predominant way to authorise operators, which affords the approved address control over all assets and creates an unnecessarily broad security risk that has already been exploited in a multitude of phishing attacks. The presented EIP extends ERC-721 by introducing a fine-grained, on-chain approval mechanism that allows owners to authorise multiple, specific operators on a per-token basis; this removes unnecessary access permissions and shrinks the surface for exploits to a minimum. The provided reference implementation further enables cheap revocation of all approvals on a per-owner or per-token basis.", "Motivation": "The NFT standard defined in ERC-721 allows token owners to \u201capprove\u201d arbitrary addresses to control their tokens\u2014the approved addresses are known as \u201coperators\u201d. Two types of approval were defined:", "Goals": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Non-goals": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "This extension was written to allow for the smallest change possible to the original ERC-721 spec while still providing a mechanism to grant, revoke and track approvals of multiple operators on a per-token basis.", "Draft notes to be expanded upon": "This extension was written to allow for the smallest change possible to the original ERC-721 spec while still providing a mechanism to grant, revoke and track approvals of multiple operators on a per-token basis.", "Backwards Compatibility": "This extension was written to allow for the smallest change possible to the original ERC-721 spec while still providing a mechanism to grant, revoke and track approvals of multiple operators on a per-token basis.", "Reference Implementation": "TODO: add internal link to assets directory when the implementation is in place.", "Security Considerations": "TODO: Interplay withsetApprovalForAll().", "Threat model": "TODO: Interplay withsetApprovalForAll().", "Mitigations": "TODO: Interplay withsetApprovalForAll().", "Other risks": "TODO: Interplay withsetApprovalForAll().", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 6506, "url": "https://eips.ethereum.org/EIPS/eip-6506", "title": "P2P Escrowed Governance Incentives", "authors": ["Josh Weintraub\u00a0(", "@jhweintraub", ")"], "sections": {"ERC-6506: P2P Escrowed Governance Incentives": "The following EIP defines the interface for a contract that facilitates the exchange of a governance-incentive for users to vote in a designated direction on a DAO-proposal while escrowing funds until the vote can be verified.", "Interface for building contracts that escrow funds based on an account taking action in a DAO": "The following EIP defines the interface for a contract that facilitates the exchange of a governance-incentive for users to vote in a designated direction on a DAO-proposal while escrowing funds until the vote can be verified.", "Abstract": "The following EIP defines the interface for a contract that facilitates the exchange of a governance-incentive for users to vote in a designated direction on a DAO-proposal while escrowing funds until the vote can be verified.", "Motivation": "While a ton of effort has gone into building bribe systems for DAOs like Curve, Frax, Convex, etc., not a lot of focus has been put on how bribes on other, more general DAO votes, may affect outcomes. Bribes are a lucrative market on many popular DAO\u2019s, and it stands to reason that people are willing to accept them for voting on other proposals, especially if they have no personal stake in the outcome. There are however, problems with current systems:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Optional Implementation Details": "Below are three potential implementation examples of the above system for different aspects.", "Methods": "While this EIP defines a structincentive,bytes memoryshould be used whenever possible. Given as each DAO will have its own implementation details, interfaces, and signature data, this should then be decoded usingabi.decode()and interpreted according to those known specifications.", "Events": "incentivizerhas bribedrecipientamountoftokenfor some information.", "Rationale": "This design was motivated by a few factors:", "Potential Ethical Issues": "Potential ethical issues have been raised about the prospect of potentially encouraging users to accept monetary payment for their vote. This is the wrong frame of reference. The question is not whether it is ethical to encourage users to send/solicit, but rather the consequences of doing nothing. Returning to the flashbots example, the question is not whether MEV is ethical, but reprecussions of allowing it to flourish without pushback.", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "This standard is intended to work with existing governance systems. Any potential issue with existing governance may represent a potential attack on this as well. This includes voting-weight manipulation, vote forgery, verification discrepancies etc. All systems in which this EIP is integrated with should be properly audited for maximum security, as any issues may result in improper distribution of these governance incentives.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 67, "url": "https://eips.ethereum.org/EIPS/eip-67", "title": "URI Scheme with Metadata, Value and Bytecode", "authors": ["Alex Van de Sande\u00a0(", "@alexvansande", ")"], "sections": {"ERC-67: URI Scheme with Metadata, Value and Bytecode": "This proposal (inspired by BIP 21) defines a format for encoding a transaction into a URI, including a recipient, number of ethers (possibly zero), and optional bytecode.", "Format for encoding transactions into a URI": "This proposal (inspired by BIP 21) defines a format for encoding a transaction into a URI, including a recipient, number of ethers (possibly zero), and optional bytecode.", "Abstract": "This proposal (inspired by BIP 21) defines a format for encoding a transaction into a URI, including a recipient, number of ethers (possibly zero), and optional bytecode.", "Motivation": "Imagine these scenarios:", "Specification": "If we follow the bitcoin standard, the result would be:", "Example 1": "Clicking this link would open a transaction that would try to send5 unicornsto addressdeadbeef. The user would then simply approve, based on each wallet UI.", "Example 2": "This is the same function as above, to send 5 unicorns from he sender todeadbeef, but now with a more readable function, which the client converts to bytecode.", "Rationale": "TODO", "Security Considerations": "TODO", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 875, "url": "https://eips.ethereum.org/EIPS/eip-875", "title": "Simpler NFT standard with batching and native atomic swaps", "authors": ["Weiwu Zhang\u00a0<", "a@colourful.land", ">", "James Sangalli\u00a0<", "j.l.sangalli@gmail.com", ">"], "sections": {"ERC-875: Simpler NFT standard with batching and native atomic swaps": "A simple non fungible token standard that allows batching tokens into lots and settling p2p atomic transfers in one transaction. You can test out an example implementation on rinkeby here: https://rinkeby.etherscan.io/address/0xffab5ce7c012bc942f5ca0cd42c3c2e1ae5f0005 and view the repo here: https://github.com/alpha-wallet/ERC-Example", "": "A simple non fungible token standard that allows batching tokens into lots and settling p2p atomic transfers in one transaction. You can test out an example implementation on rinkeby here: https://rinkeby.etherscan.io/address/0xffab5ce7c012bc942f5ca0cd42c3c2e1ae5f0005 and view the repo here: https://github.com/alpha-wallet/ERC-Example", "Summary": "A simple non fungible token standard that allows batching tokens into lots and settling p2p atomic transfers in one transaction. You can test out an example implementation on rinkeby here: https://rinkeby.etherscan.io/address/0xffab5ce7c012bc942f5ca0cd42c3c2e1ae5f0005 and view the repo here: https://github.com/alpha-wallet/ERC-Example", "Purpose": "While other standards allow the user to transfer a non-fungible token, they require one transaction per token, this is heavy on gas and partially responsible for clogging the ethereum network. There are also few definitions for how to do a simple atomic swap.", "Rinkeby example": "This standard has been implemented in an example contract on rinkeby: https://rinkeby.etherscan.io/address/0xffab5ce7c012bc942f5ca0cd42c3c2e1ae5f0005", "Specification": "returns the name of the contract e.g. CarLotContract", "function name() constant returns (string name)": "returns the name of the contract e.g. CarLotContract", "function symbol() constant returns (string symbol)": "Returns a short string of the symbol of the in-fungible token, this should be short and generic as each token is non-fungible.", "function balanceOf(address _owner) public view returns (uint256[] balance)": "Returns an array of the users balance.", "function transfer(address _to, uint256[] _tokens) public;": "Transfer your unique tokens to an address by adding an array of the token indices. This compares favourable to ERC721 as you can transfer a bulk of tokens in one go rather than one at a time. This has a big gas saving as well as being more convenient.", "function transferFrom(address _from, address _to, uint256[] _tokens) public;": "Transfer a variable amount of tokens from one user to another. This can be done from an authorised party with a specified key e.g. contract owner.", "Optional functions": "Returns the total amount of tokens in the given contract, this should be optional as assets might be allocated and issued on the fly. This means that supply is not always fixed.", "function totalSupply() constant returns (uint256 totalSupply);": "Returns the total amount of tokens in the given contract, this should be optional as assets might be allocated and issued on the fly. This means that supply is not always fixed.", "function ownerOf(uint256 _tokenId) public view returns (address _owner);": "Returns the owner of a particular token, I think this should be optional as not every token contract will need to track the owner of a unique token and it costs gas to loop and map the token id owners each time the balances change.", "function trade(uint256 expiryTimeStamp, uint256[] tokenIndices, uint8 v, bytes32 r, bytes32 s) public payable": "A function which allows a user to sell a batch of non-fungible tokens without paying for the gas fee (only the buyer has to) in a p2p atomic swap. This is achieved by signing an attestation containing the amount of tokens to sell, the contract address, an expiry timestamp, the price and a prefix containing the ERC spec name and chain id. A buyer can then pay for the deal in one transaction by attaching the appropriate ether to satisfy the deal.", "Interface": "Please visit thisrepoto see an example implementation", "Example implementation": "Please visit thisrepoto see an example implementation", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1123, "url": "https://eips.ethereum.org/EIPS/eip-1123", "title": "Revised Ethereum Smart Contract Packaging Standard", "authors": ["g. nicholas d\u2019andrea\u00a0(", "@gnidan", ")", "Piper Merriam\u00a0(", "@pipermerriam", ")", "Nick Gheorghita\u00a0(", "@njgheorghita", ")", "Danny Ryan\u00a0(", "@djrtwo", ")"], "sections": {"ERC-1123: Revised Ethereum Smart Contract Packaging Standard": "This ERC has been abandoned in favor of the EthPM V3 smart contract packaging standard defined inERC-2678", "": "This ERC has been abandoned in favor of the EthPM V3 smart contract packaging standard defined inERC-2678", "Simple Summary": "A data format describing a smart contract software package.", "Abstract": "This EIP defines a data format forpackage manifestdocuments,\nrepresenting a package of one or more smart contracts, optionally\nincluding source code and any/all deployed instances across multiple\nnetworks. Package manifests are minified JSON objects, to be distributed\nvia content addressable storage networks, such as IPFS.", "Motivation": "This standard aims to encourage the Ethereum development ecosystem\ntowards software best practices around code reuse. By defining an open,\ncommunity-driven package data format standard, this effort seeks to\nprovide support for package management tools development by offering a\ngeneral-purpose solution that has been designed with observed common\npractices in mind.", "Specification": "This document defines the specification for an EthPM package manifest. A\npackage manifest provides metadata about aPackage, and\nin most cases should provide sufficient information about the packaged\ncontracts and its dependencies to do bytecode verification of its\ncontracts.", "Guiding Principles": "This specification makes the following assumptions about the document\nlifecycle.", "Conventions": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d,\n\u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this\ndocument are to be interpreted as described in RFC 2119.", "RFC2119": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d,\n\u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this\ndocument are to be interpreted as described in RFC 2119.", "Prefixed vs Unprefixed": "Aprefixedhexadecimal value begins with0x.Unprefixedvalues have no prefix. Unless otherwise\nspecified, all hexadecimal valuesshouldbe represented with the0xprefix.", "Document Format": "The canonical format is a single JSON object. Packagesmustconform\nto the following serialization rules.", "Document Specification": "The following fields are defined for the package. Custom fieldsmaybe included. Custom fieldsshouldbe prefixed withx-to prevent\nname collisions with future versions of the specification.", "EthPM Manifest Version:manifest_version": "Themanifest_versionfield defines the specification version that this\ndocument conforms to. Packagesmustinclude this field.", "Package Name:package_name": "Thepackage_namefield defines a human readable name for this package.\nPackagesmustinclude this field. Package namesmustbegin with\na lowercase letter and be comprised of only lowercase letters, numeric\ncharacters, and the dash character-. Package namesmustnot\nexceed 214 characters in length.", "Package Meta:meta": "Themetafield defines a location for metadata about the package which\nis not integral in nature for package installation, but may be important\nor convenient to have on-hand for other reasons. This fieldshouldbe included in all Packages.", "Version:version": "Theversionfield declares the version number of this release. This\nvaluemustbe included in all Packages. This valueshouldconform to thesemverversion\nnumbering specification.", "Sources:sources": "Thesourcesfield defines a source tree thatshouldcomprise the\nfull source tree necessary to recompile the contracts contained in this\nrelease. Sources are declared in a key/value mapping.", "Contract Types:contract_types": "Thecontract_typesfield holds theContract\nTypeswhich have been included in this release.Packagesshouldonly include contract types that\ncan be found in the source files for this package. Packagesshould\nnotinclude contract types from dependencies. Packagesshould notinclude abstract contracts in the contract types section of a release.", "Deployments:deployments": "Thedeploymentsfield holds the information for the chains on which\nthis release hasContract Instancesas well\nas theContract Typesand other deployment\ndetails for those deployed contract instances. The set of chains defined\nby the*BIP122 URI <#bip122-uris>*keys for this objectmustbe\nunique.", "Build Dependencies:build_dependencies": "Thebuild_dependenciesfield defines a key/value mapping of EthereumPackagesthat this project depends on.", "Definitions": "Definitions for different objects used within the Package. All objects\nallow custom fields to be included. Custom fieldsshouldbe prefixed\nwithx-to prevent name collisions with future versions of the\nspecification.", "TheLink ReferenceObject": "ALink Referenceobject has the following\nkey/value pairs. All link references are assumed to be associated with\nsome correspondingBytecode.", "TheLink ValueObject": "Describes a singleLink Value.", "TheBytecodeObject": "A bytecode object has the following key/value pairs.", "ThePackage MetaObject": "ThePackage Metaobject is defined to have the following key/value\npairs.", "TheContract TypeObject": "AContract Typeobject is defined to have the following key/value\npairs.", "TheContract InstanceObject": "AContract Instance Objectrepresents a single deployedContract\nInstanceand is defined to have the following\nkey/value pairs.", "TheCompiler InformationObject": "Thecompilerfield defines the compiler information that was used\nduring compilation of thisContract Instance.\nThis fieldshouldbe present in all contract instances that locally\ndeclareruntime_bytecode.", "BIP122 URIs": "BIP122 URIs are used to define a blockchain via a subset of theBIP-122spec.", "Rationale": "The following use cases were considered during the creation of this\nspecification.", "Glossary": "The JSON representation of the application binary interface. See the\nofficialspecificationfor more information.", "ABI": "The JSON representation of the application binary interface. See the\nofficialspecificationfor more information.", "Address": "A public identifier for an account on a particular chain", "Bytecode": "The set of EVM instructions as produced by a compiler. Unless otherwise\nspecified this should be assumed to be hexadecimal encoded, representing\na whole number of bytes, andprefixedwith0x.", "Chain Definition": "This definition originates fromBIP122\nURI.", "Content Addressable URI": "Any URI which contains a cryptographic hash which can be used to verify\nthe integrity of the content found at the URI.", "Contract Alias": "This is a name used to reference a specificContract\nType. Contract aliasesmustbe unique within a\nsinglePackage.", "Contract Instance": "A contract instance a specific deployed version of aContract\nType.", "Contract Instance Name": "A name which refers to a specificContract\nInstanceon a specific chain from the\ndeployments of a singlePackage. This namemustbe\nunique across all other contract instances for the given chain. The name\nmust conform to the regular expression[a-zA-Z][a-zA-Z0-9_]{0,255}", "Contract Name": "The name found in the source code that defines a specificContract\nType. These namesmustconform to the regular\nexpression[a-zA-Z][-a-zA-Z0-9_]{0,255}.", "Contract Type": "Refers to a specific contract in the package source. This term can be\nused to refer to an abstract contract, a normal contract, or a library.\nTwo contracts are of the same contract type if they have the same\nbytecode.", "Identifier": "Refers generally to a named entity in thePackage.", "Link Reference": "A location within a contract\u2019s bytecode which needs to be linked. A link\nreference has the following properties.", "Link Value": "A link value is the value which can be inserted in place of aLink\nReference", "Linking": "The act of replacingLink ReferenceswithLink\nValueswithin someBytecode.", "Package": "Distribution of an application\u2019s source or compiled bytecode along with\nmetadata related to authorship, license, versioning, et al.", "Package Manifest": "A machine-readable description of a package (SeeSpecificationfor information about the format\nfor package manifests.)", "Prefixed": "Bytecodestring with leading0x.", "Unprefixed": "NotPrefixed.", "Backwards Compatibility": "This specification supports backwards compatibility by use of themanifest_versionproperty. This\nspecification corresponds to version2as the value for that field.", "Implementations": "This submission aims to coincide with development efforts towards\nwidespread implementation in commonly-used development tools.", "Further Work": "This EIP addresses only the data format for package descriptions.\nExcluded from the scope of this specification are:", "Acknowledgements": "The authors of this document would like to thank the original authors ofEIP-190,ETHPrizefor their funding\nsupport, all communitycontributors,\nand the Ethereum community at large.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1154, "url": "https://eips.ethereum.org/EIPS/eip-1154", "title": "Oracle Interface", "authors": ["Alan Lu\u00a0(", "@cag", ")"], "sections": {"ERC-1154: Oracle Interface": "A standard interface for oracles.", "": "A standard interface for oracles.", "Simple Summary": "A standard interface for oracles.", "Abstract": "In order for ethereum smart contracts to interact with off-chain systems, oracles must be used. These oracles report values which are normally off-chain, allowing smart contracts to react to the state of off-chain systems. A distinction and a choice is made between push and pull based oracle systems. Furthermore, a standard interface for oracles is described here, allowing different oracle implementations to be interchangeable.", "Motivation": "The Ethereum ecosystem currently has many different oracle implementations available, but they do not provide a unified interface. Smart contract systems would be locked into a single set of oracle implementations, or they would require developers to write adapters/ports specific to the oracle system chosen in a given project.", "Specification": "receiveResultMUST revert if themsg.senderis not an oracle authorized to provide theresultfor thatid.", "Rationale": "The specs are currently very similar to what is implemented by ChainLink (which can use any arbitrarily-named callback) and Oraclize (which uses__callback).", "Alternate Pull-based Interface": "Here are alternate specs loosely based on Gnosis prediction market contracts v1. Reality Check also exposes a similar endpoint (getFinalAnswer).", "Push vs Pull": "Note that push-based interfaces may be adapted into pull-based interfaces. Simply deploy an oracle consumer which stores the result received and implementsresultForaccordingly.", "Implementation": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- revert: All calls to this opcode must emit a log with revert data.\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1538, "url": "https://eips.ethereum.org/EIPS/eip-1538", "title": "Transparent Contract Standard", "authors": ["Nick Mudge\u00a0<", "nick@perfectabstractions.com", ">"], "sections": {"ERC-1538: Transparent Contract Standard": "Replaced byEIP-2535 Diamond Standard.", "": "Replaced byEIP-2535 Diamond Standard.", "Simple Summary": "This standard provides a contract architecture that makes upgradeable contracts flexible, unlimited in size, and transparent.", "Abstract": "A transparent contract is a proxy contract design pattern that provides the following:", "Motivation": "A fundamental benefit of Ethereum contracts is that their code is immutable, thereby acquiring trust by trustlessness. People do not have to trust others if it is not possible for a contract to be changed.", "Middle Ground": "Transparent contracts provide a middle ground between immutable trustless contracts that can\u2019t be improved and upgradeable contracts that can\u2019t be trusted.", "Purposes": "This standard is for use cases that benefit from the following:", "Benefits & Use Cases": "This standard is for use cases that benefit from the following:", "New Software Possibilities": "This standard enables a form of contract version control software to be written.", "Specification": "A transparent contract delegates or forwards function calls to it to other contracts usingdelegatecode.", "General Summary": "A transparent contract delegates or forwards function calls to it to other contracts usingdelegatecode.", "Terms": "A contract is a transparent contract if it implements the following design points:", "Design Points": "A contract is a transparent contract if it implements the following design points:", "Example": "Here is an example of an implementation of a transparent contract. Please note that the example below is anexample only.  It is not the standard. A contract is a transparent contract when it implements and complies with the design points listed above.", "ERC1538 Interface": "The text format for the_functionSignaturesparameter is simply a string of function signatures. For example:\"myFirstFunction()mySecondFunction(string)\"This format is easy to parse and is concise.", "Function Signatures String Format": "The text format for the_functionSignaturesparameter is simply a string of function signatures. For example:\"myFirstFunction()mySecondFunction(string)\"This format is easy to parse and is concise.", "Removing Functions": "Functions are removed by passingaddress(0)as the first argument to theupdateContractfunction. The list of functions that are passed in are removed.", "Source Code Verification": "The transparent contract source code and the source code for the delegate contracts should be verified in a provable way by a third party source such as etherscan.io.", "Function Selector Clash": "A function selector clash occurs when a function is added to a contract that hashes to the same four-byte hash as an existing function. This is unlikely to occur but should be prevented in the implementation of theupdateContractfunction. See thereference implementation of ERC1538to see an example of how function clashes can be prevented.", "ERC1538Query": "Optionally, the function signatures of a transparent contract can be stored in an array in the transparent contract and queried to get what functions the transparent contract supports and what their delegate contract addresses are.", "How To Deploy A Transparent Contract": "See thereference implementationfor examples of these contracts.", "Wrapper Contract for Delegate Contracts that Depend on Other Delegate Contracts": "In some cases some delegate contracts may need to call external/public functions that reside in other delegate contracts. A convenient way to solve this problem is to create a contract that contains empty implementations of functions that are needed and import and extend this contract in delegate contracts that call functions from other delegate contracts. This enables delegate contracts to compile without having to provide implementations of the functions that are already given in other delegate contracts. This is a way to save gas, prevent reaching the max contract size limit, and prevent duplication of code. This strategy was given by @amiromayer.See his comment for more information.Another way to solve this problem is to use assembly to call functions provided by other delegate contracts.", "Decentralized Authority": "It is possible to extend this standard to add consensus functionality such as an approval function that multiple different people call to approve changes before they are submitted with theupdateContractfunction. Changes only go into effect when the changes are fully approved. TheCommitMessageand ` FunctionUpdate` events should only be emitted when changes go into effect.", "Security": "The owners(s) of an upgradeable contract have the ability to alter, add or remove data from the contract\u2019s data storage. Owner(s) of a contract can also execute any arbitrary code in the contract on behalf of any address. Owners(s) can do these things by adding a function to the contract that they call to execute arbitrary code. This is an issue for upgradeable contracts in general and is not specific to transparent contracts.", "General": "The owners(s) of an upgradeable contract have the ability to alter, add or remove data from the contract\u2019s data storage. Owner(s) of a contract can also execute any arbitrary code in the contract on behalf of any address. Owners(s) can do these things by adding a function to the contract that they call to execute arbitrary code. This is an issue for upgradeable contracts in general and is not specific to transparent contracts.", "Unchangeable Functions": "\u201cUnchangeable functions\u201d are functions defined in a transparent contract itself and not in a delegate contract. The owner(s) of a transparent contract are not able to replace these functions. The use of unchangeable functions is limited because in some cases they can still be manipulated if they read or write data to the storage of the transparent contract. Data read from the transparent contract\u2019s storage could have been altered by the owner(s) of the contract. Data written to the transparent contract\u2019s storage can be undone or altered by the owner(s) of the contract.", "Transparency": "Contracts that implement this standard emit an event every time a function is added, replaced or removed. This enables people and software to monitor the changes to a contract. If any bad acting function is added to a contract then it can be seen. To comply with this standard all source code of a transparent contract and delegate contracts must be publicly available and verified.", "Rationale": "TheupdateContractfunction takes astringlist of functions signatures as an argument instead of abytes4[]array of function selectors for three reasons:", "String of Function Signatures Instead of bytes4[] Array of Function Selectors": "TheupdateContractfunction takes astringlist of functions signatures as an argument instead of abytes4[]array of function selectors for three reasons:", "Gas Considerations": "Delegating function calls does have some gas overhead. This is mitigated in two ways:", "Storage": "The standard does not specify how data is stored or organized by a transparent contract. But here are some suggestions:", "Becoming Immutable": "It is possible to make a transparent contract become immutable. This is done by calling theupdateContractfunction to remove theupdateContractfunction. With this gone it is no longer possible to add, replace and remove functions.", "Versions of Functions": "Software or a user can verify what version of a function is called by getting the delegate contract address of the function. This can be done by calling thedelegateAddressfunction from the ERC1538Query interface if it is implemented. This function takes a function signature as an argument and returns the delegate contract address where it is implemented.", "Best Practices, Tools and More Information": "Below is a growing list of articles concerning transparent contracts and their use.  If you have an article about transparent contracts you would like to share then please submit a comment to this issue about it to get it added.", "Inspiration": "This standard was inspired by ZeppelinOS\u2019s implementation ofUpgradeability with vtables.", "Backwards Compatibility": "This standard makes a contract compatible with future standards and functionality because new functions can be added and existing functions can be replaced or removed.", "Implementation": "A reference implementation of this standard is given in thetransparent-contracts-erc1538repository.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7897, "url": "https://eips.ethereum.org/EIPS/eip-7897", "title": "Wallet-Linked Services for Smart Accounts", "authors": ["Francesco Sullo\u00a0(", "@sullof", ")"], "sections": {"ERC-7897: Wallet-Linked Services for Smart Accounts": "This proposal defines a registry for generic services linked to smart accounts, with a special focus onERC-4337wallets, where services are  contracts extending a wallet\u2019s functionality, owned by the wallet itself. It leveragesERC-1167minimal proxies and deterministic addressing to enable permissionless innovation while maintaining backward compatibility with existingERC-4337wallets. To reach its goal, it takes the concept introduced withERC-6551andERC-7656standards that work for NFTs, and applies it to wallets.", "Define a registry for modular services linked to ERC-4337 wallets.": "This proposal defines a registry for generic services linked to smart accounts, with a special focus onERC-4337wallets, where services are  contracts extending a wallet\u2019s functionality, owned by the wallet itself. It leveragesERC-1167minimal proxies and deterministic addressing to enable permissionless innovation while maintaining backward compatibility with existingERC-4337wallets. To reach its goal, it takes the concept introduced withERC-6551andERC-7656standards that work for NFTs, and applies it to wallets.", "Abstract": "This proposal defines a registry for generic services linked to smart accounts, with a special focus onERC-4337wallets, where services are  contracts extending a wallet\u2019s functionality, owned by the wallet itself. It leveragesERC-1167minimal proxies and deterministic addressing to enable permissionless innovation while maintaining backward compatibility with existingERC-4337wallets. To reach its goal, it takes the concept introduced withERC-6551andERC-7656standards that work for NFTs, and applies it to wallets.", "Motivation": "ERC-4337(Account Abstraction) introduces programmable smart accounts. Existing proposals to extend wallet functionalities (e.g.,ERC-6900) focus on internal modules. This proposal generalizes the concept of service binding, allowing anyERC-4337wallet to attach external services (e.g., recovery, automation, compliance) without requiring changes to the wallet\u2019s core logic.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Registry Interface": "The interfaceIERC7897Registryis defined as follows:", "Deployment Requirements": "The registry MUST deploy each wallet-linked service as anERC-1167minimal proxy with immutable constant data appended to the bytecode.", "Recommended Service Interface": "Any contract created using anERC7897RegistrySHOULD implement theIERC7897Serviceinterface:", "Access Control": "Services SHOULD implement access control to restrict critical operations to the wallet owner. For example:", "Rationale": "The technical foundation ofERC-7897centers on the extension and generalization of contract types that can be associated withERC-4337wallets. Key decisions include:", "Reference Implementation": "Wallet-linked services MUST be controlled by theERC-4337wallet owner to prevent unauthorized access. Implementers SHOULD include safeguards against malicious or unverified implementations.", "Security Considerations": "Wallet-linked services MUST be controlled by theERC-4337wallet owner to prevent unauthorized access. Implementers SHOULD include safeguards against malicious or unverified implementations.", "Ownership and Control": "Wallet-linked services MUST be controlled by theERC-4337wallet owner to prevent unauthorized access. Implementers SHOULD include safeguards against malicious or unverified implementations.", "Upgradeability Risks": "If a service is upgradable, ensure secure upgrade mechanisms to prevent unauthorized changes. For example:", "Reentrancy and Cross-Contract Interactions": "Services interacting with external protocols SHOULD follow best practices to prevent reentrancy attacks.", "User Education": "Clear user interfaces and warnings SHOULD be provided to reduce phishing and social engineering risks.", "Testing": "Implementers SHOULD thoroughly test the registry and services on testnets to ensure correctness and security before deploying to mainnet.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- account abstraction: Allows contracts to be the top-level accounts that pay fees and initiate transactions, enabling new wallet designs, signature schemes, and fee structures.\n- interfaces: contract interface specifications (ABIs) that a wallet needs to reliably decode calldata in requests\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1, "url": "https://eips.ethereum.org/EIPS/eip-1", "title": "EIP Purpose and Guidelines", "authors": ["Martin Becze\u00a0<", "mb@ethereum.org", ">", "Hudson Jameson\u00a0<", "hudson@ethereum.org", ">", "et al."], "sections": {"EIP-1: EIP Purpose and Guidelines": "EIP stands for Ethereum Improvement Proposal. An EIP is a design document providing information to the Ethereum community, or describing a new feature for Ethereum or its processes or environment. The EIP should provide a concise technical specification of the feature and a rationale for the feature. The EIP author is responsible for building consensus within the community and documenting dissenting opinions.", "": "EIP stands for Ethereum Improvement Proposal. An EIP is a design document providing information to the Ethereum community, or describing a new feature for Ethereum or its processes or environment. The EIP should provide a concise technical specification of the feature and a rationale for the feature. The EIP author is responsible for building consensus within the community and documenting dissenting opinions.", "What is an EIP?": "EIP stands for Ethereum Improvement Proposal. An EIP is a design document providing information to the Ethereum community, or describing a new feature for Ethereum or its processes or environment. The EIP should provide a concise technical specification of the feature and a rationale for the feature. The EIP author is responsible for building consensus within the community and documenting dissenting opinions.", "EIP Rationale": "We intend EIPs to be the primary mechanisms for proposing new features, for collecting community technical input on an issue, and for documenting the design decisions that have gone into Ethereum. Because the EIPs are maintained as text files in a versioned repository, their revision history is the historical record of the feature proposal.", "EIP Types": "There are three types of EIP:", "Special requirements for Core EIPs": "If aCoreEIP mentions or proposes changes to the EVM (Ethereum Virtual Machine), it should refer to the instructions by their mnemonics and define the opcodes of those mnemonics at least once. A preferred way is the following:", "EIP Work Flow": "Parties involved in the process are you, the champion orEIP author, theEIP editors, and theEthereum Core Developers.", "Shepherding an EIP": "Parties involved in the process are you, the champion orEIP author, theEIP editors, and theEthereum Core Developers.", "Core EIPs": "For Core EIPs, given that they require client implementations to be consideredFinal(see \u201cEIPs Process\u201d below), you will need to either provide an implementation for clients or convince clients to implement your EIP.", "EIP Process": "The following is the standardization process for all EIPs in all tracks:", "What belongs in a successful EIP?": "Each EIP should have the following parts:", "EIP Formats and Templates": "EIPs should be written inmarkdownformat. There is atemplateto follow.", "EIP Header Preamble": "Each EIP must begin with anRFC 822style header preamble, preceded and followed by three hyphens (---). This header is also termed\u201cfront matter\u201d by Jekyll. The headers must appear in the following order.", "authorheader": "Theauthorheader lists the names, email addresses or usernames of the authors/owners of the EIP. Those who prefer anonymity may use a username only, or a first name and a username. The format of theauthorheader value must be:", "discussions-toheader": "While an EIP is a draft, adiscussions-toheader will indicate the URL where the EIP is being discussed.", "typeheader": "Thetypeheader specifies the type of EIP: Standards Track, Meta, or Informational. If the track is Standards please include the subcategory (core, networking, interface, or ERC).", "categoryheader": "Thecategoryheader specifies the EIP\u2019s category. This is required for standards-track EIPs only.", "createdheader": "Thecreatedheader records the date that the EIP was assigned a number. Both headers should be in yyyy-mm-dd format, e.g. 2001-08-14.", "requiresheader": "EIPs may have arequiresheader, indicating the EIP numbers that this EIP depends on. If such a dependency exists, this field is required.", "Linking to External Resources": "Other than the specific exceptions listed below, links to external resourcesSHOULD NOTbe included. External resources may disappear, move, or change unexpectedly.", "Execution Client Specifications": "Links to the Ethereum Execution Client Specifications may be included using normal markdown syntax, such as:", "Consensus Layer Specifications": "Links to specific commits of files within the Ethereum Consensus Layer Specifications may be included using normal markdown syntax, such as:", "Networking Specifications": "Links to specific commits of files within the Ethereum Networking Specifications may be included using normal markdown syntax, such as:", "World Wide Web Consortium (W3C)": "Links to a W3C \u201cRecommendation\u201d status specification may be included using normal markdown syntax. For example, the following link would be allowed:", "Web Hypertext Application Technology Working Group (WHATWG)": "Links to WHATWG specifications may be included using normal markdown syntax, such as:", "Internet Engineering Task Force (IETF)": "Links to an IETF Request For Comment (RFC) specification may be included using normal markdown syntax, such as:", "Bitcoin Improvement Proposal": "Links to Bitcoin Improvement Proposals may be included using normal markdown syntax, such as:", "National Vulnerability Database (NVD)": "Links to the Common Vulnerabilities and Exposures (CVE) system as published by the National Institute of Standards and Technology (NIST) may be included, provided they are qualified by the date of the most recent change, using the following syntax:", "Digital Object Identifier System": "Links qualified with a Digital Object Identifier (DOI) may be included using the following syntax:", "Linking to other EIPs": "References to other EIPs should follow the formatEIP-NwhereNis the EIP number you are referring to.  Each EIP that is referenced in an EIPMUSTbe accompanied by a relative markdown link the first time it is referenced, andMAYbe accompanied by a link on subsequent references.  The linkMUSTalways be done via relative paths so that the links work in this GitHub repository, forks of this repository, the main EIPs site, mirrors of the main EIP site, etc.  For example, you would link to this EIP as./eip-1.md.", "Auxiliary Files": "Images, diagrams and auxiliary files should be included in a subdirectory of theassetsfolder for that EIP as follows:assets/eip-N(whereNis to be replaced with the EIP number). When linking to an image in the EIP, use relative links such as../assets/eip-1/image.png.", "Transferring EIP Ownership": "It occasionally becomes necessary to transfer ownership of EIPs to a new champion. In general, we\u2019d like to retain the original author as a co-author of the transferred EIP, but that\u2019s really up to the original author. A good reason to transfer ownership is because the original author no longer has the time or interest in updating it or following through with the EIP process, or has fallen off the face of the \u2018net (i.e. is unreachable or isn\u2019t responding to email). A bad reason to transfer ownership is because you don\u2019t agree with the direction of the EIP. We try to build consensus around an EIP, but if that\u2019s not possible, you can always submit a competing EIP.", "EIP Editors": "The current EIP editors are", "EIP Editor Responsibilities": "For each new EIP that comes in, an editor does the following:", "Style Guide": "Thetitlefield in the preamble:", "Titles": "Thetitlefield in the preamble:", "Descriptions": "Thedescriptionfield in the preamble:", "EIP numbers": "When referring to an EIP with acategoryofERC, it must be written in the hyphenated formERC-XwhereXis that EIP\u2019s assigned number. When referring to EIPs with any othercategory, it must be written in the hyphenated formEIP-XwhereXis that EIP\u2019s assigned number.", "RFC 2119 and RFC 8174": "EIPs are encouraged to followRFC 2119andRFC 8174for terminology and to insert the following at the beginning of the Specification section:", "History": "This document was derived heavily fromBitcoin\u2019s BIP-0001written by Amir Taaki which in turn was derived fromPython\u2019s PEP-0001. In many places text was simply copied and modified. Although the PEP-0001 text was written by Barry Warsaw, Jeremy Hylton, and David Goodger, they are not responsible for its use in the Ethereum Improvement Process, and should not be bothered with technical questions specific to Ethereum or the EIP. Please direct all comments to the EIP editors.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5069, "url": "https://eips.ethereum.org/EIPS/eip-5069", "title": "EIP Editor Handbook", "authors": ["Pooja Ranjan\u00a0(", "@poojaranjan", ")", "Gavin John\u00a0(", "@Pandapip1", ")", "Sam Wilson\u00a0(", "@SamWilsn", ")", "et al."], "sections": {"EIP-5069: EIP Editor Handbook": "We, the Ethereum Improvement Proposal (EIP) Editors, maintain a repository of documents related to the Ethereum protocol and its ecosystem. Consider us botharchivistsmaking sure the community as a whole does not lose its history, and apublishermaking sure interested parties can stay up-to-date with the latest proposals.", "Organizational structure, decision making process, and other EIP Editor odds and ends.": "We, the Ethereum Improvement Proposal (EIP) Editors, maintain a repository of documents related to the Ethereum protocol and its ecosystem. Consider us botharchivistsmaking sure the community as a whole does not lose its history, and apublishermaking sure interested parties can stay up-to-date with the latest proposals.", "Introduction": "We, the Ethereum Improvement Proposal (EIP) Editors, maintain a repository of documents related to the Ethereum protocol and its ecosystem. Consider us botharchivistsmaking sure the community as a whole does not lose its history, and apublishermaking sure interested parties can stay up-to-date with the latest proposals.", "Mission": "Our mission is to serve the broad Ethereum community, both present and future, by:", "What we Do": "Our mission is to serve the broad Ethereum community, both present and future, by:", "What we Don\u2019t": "On the other hand, we donot:", "Structure": "We, the Editors, consist of some number of EIP Editors and one Keeper of Consensus (or just Keeper for short) elected by and from the EIP Editors.", "EIP Editors": "We, the Editors, consist of some number of EIP Editors and one Keeper of Consensus (or just Keeper for short) elected by and from the EIP Editors.", "Membership": "Anyone may apply to join as an EIP Editor. Specific eligibility requirements are left to individual current EIP Editors, but the general requirements are:", "Making Decisions": "For decisions that are unlikely to be controversial\u2014especially for decisions affecting a single proposal\u2014an EIP Editor may choose whatever option they deem appropriate in accordance with our mission.", "Informally": "For decisions that are unlikely to be controversial\u2014especially for decisions affecting a single proposal\u2014an EIP Editor may choose whatever option they deem appropriate in accordance with our mission.", "Formally": "Electing a Keeper, adding/removing EIP Editors, and any possibly-controversial decisions must all be made using variations of this formal process.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- eip editor handbook: Outlines the responsibilities and processes of Ethereum Improvement Proposal (EIP) editors, including how decisions are made, the election of a Keeper of Consensus, and editor membership guidelines.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 4, "url": "https://eips.ethereum.org/EIPS/eip-4", "title": "EIP Classification", "authors": ["Joseph Chow\u00a0(", "@ethers", ")"], "sections": {"EIP-4: EIP Classification": "This document describes a classification scheme for EIPs, adapted fromBIP 123.", "": "This document describes a classification scheme for EIPs, adapted fromBIP 123.", "Abstract": "This document describes a classification scheme for EIPs, adapted fromBIP 123.", "Motivation": "Ethereum is a system involving a number of different standards. Some standards are absolute requirements for interoperability while others can be considered optional, giving implementors a choice of whether to support them.", "Specification": "Standards EIPs are placed in one of four layers:", "1. Consensus Layer": "The consensus layer defines cryptographic commitment structures. Its purpose is ensuring that anyone can locally evaluate whether a particular state and history is valid, providing settlement guarantees, and assuring eventual convergence.", "Soft Forks": "In a soft fork, some structures that were valid under the old rules are no longer valid under the new rules. Structures that were invalid under the old rules continue to be invalid under the new rules.", "Hard Forks": "In a hard fork, structures that were invalid under the old rules become valid under the new rules.", "2. Networking Layer": "The networking layer specifies the Ethereum wire protocol (eth) and the Light Ethereum Subprotocol (les).  RLPx is excluded and tracked in the [https://github.com/ethereum/devp2p devp2p repository].", "3. API/RPC Layer": "The API/RPC layer specifies higher level calls accessible to applications. Support for these EIPs is not required for basic network interoperability but might be expected by some client applications.", "4. Applications Layer": "The applications layer specifies high level structures, abstractions, and conventions that allow different applications to support similar features and share data.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- devp2p: A networking protocol for Ethereum. EIP-8 introduces forward compatibility requirements for devp2p implementations .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 606, "url": "https://eips.ethereum.org/EIPS/eip-606", "title": "Hardfork Meta: Homestead", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-606: Hardfork Meta: Homestead": "This specifies the changes included in the hard fork named Homestead.", "": "This specifies the changes included in the hard fork named Homestead.", "Abstract": "This specifies the changes included in the hard fork named Homestead.", "Specification": "Copyright and related rights waived viaCC0.", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 607, "url": "https://eips.ethereum.org/EIPS/eip-607", "title": "Hardfork Meta: Spurious Dragon", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-607: Hardfork Meta: Spurious Dragon": "This specifies the changes included in the hard fork named Spurious Dragon.", "": "This specifies the changes included in the hard fork named Spurious Dragon.", "Abstract": "This specifies the changes included in the hard fork named Spurious Dragon.", "Specification": "Copyright and related rights waived viaCC0.", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 608, "url": "https://eips.ethereum.org/EIPS/eip-608", "title": "Hardfork Meta: Tangerine Whistle", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-608: Hardfork Meta: Tangerine Whistle": "This specifies the changes included in the hard fork named Tangerine Whistle (EIP 150).", "": "This specifies the changes included in the hard fork named Tangerine Whistle (EIP 150).", "Abstract": "This specifies the changes included in the hard fork named Tangerine Whistle (EIP 150).", "Specification": "Copyright and related rights waived viaCC0.", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 609, "url": "https://eips.ethereum.org/EIPS/eip-609", "title": "Hardfork Meta: Byzantium", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-609: Hardfork Meta: Byzantium": "This specifies the changes included in the hard fork named Byzantium.", "": "This specifies the changes included in the hard fork named Byzantium.", "Abstract": "This specifies the changes included in the hard fork named Byzantium.", "Specification": "Copyright and related rights waived viaCC0.", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 779, "url": "https://eips.ethereum.org/EIPS/eip-779", "title": "Hardfork Meta: DAO Fork", "authors": ["Casey Detrio\u00a0(", "@cdetrio", ")"], "sections": {"EIP-779: Hardfork Meta: DAO Fork": "This documents the changes included in the hard fork named \u201cDAO Fork\u201d. Unlike other hard forks, the DAO Fork did not change the protocol; all EVM opcodes, transaction format, block structure, and so on remained the same. Rather, the DAO Fork was an \u201cirregular state change\u201d that transferred ether balances from a list of accounts (\u201cchild DAO\u201d contracts) into a specified account (the \u201cWithdrawDAO\u201d contract).", "": "This documents the changes included in the hard fork named \u201cDAO Fork\u201d. Unlike other hard forks, the DAO Fork did not change the protocol; all EVM opcodes, transaction format, block structure, and so on remained the same. Rather, the DAO Fork was an \u201cirregular state change\u201d that transferred ether balances from a list of accounts (\u201cchild DAO\u201d contracts) into a specified account (the \u201cWithdrawDAO\u201d contract).", "Abstract": "This documents the changes included in the hard fork named \u201cDAO Fork\u201d. Unlike other hard forks, the DAO Fork did not change the protocol; all EVM opcodes, transaction format, block structure, and so on remained the same. Rather, the DAO Fork was an \u201cirregular state change\u201d that transferred ether balances from a list of accounts (\u201cchild DAO\u201d contracts) into a specified account (the \u201cWithdrawDAO\u201d contract).", "Specification": "See references [1] and [2] for the original, full specification. It is summarized here for convenience.", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- dao fork: Describes an irregular state change at block 1,920,000, which transferred ether from the DAO and related accounts to a WithdrawDAO contract following the infamous DAO hack.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1013, "url": "https://eips.ethereum.org/EIPS/eip-1013", "title": "Hardfork Meta: Constantinople", "authors": ["Nick Savers\u00a0(", "@nicksavers", ")"], "sections": {"EIP-1013: Hardfork Meta: Constantinople": "This meta-EIP specifies the changes included in the Ethereum hardfork named Constantinople.", "": "This meta-EIP specifies the changes included in the Ethereum hardfork named Constantinople.", "Abstract": "This meta-EIP specifies the changes included in the Ethereum hardfork named Constantinople.", "Specification": "Copyright and related rights waived viaCC0.", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1679, "url": "https://eips.ethereum.org/EIPS/eip-1679", "title": "Hardfork Meta: Istanbul", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Afri Schoedon\u00a0(", "@5chdn", ")"], "sections": {"EIP-1679: Hardfork Meta: Istanbul": "This meta-EIP specifies the changes included in the Ethereum hardfork named Istanbul.", "": "This meta-EIP specifies the changes included in the Ethereum hardfork named Istanbul.", "Abstract": "This meta-EIP specifies the changes included in the Ethereum hardfork named Istanbul.", "Specification": "Copyright and related rights waived viaCC0.", "Activation": "Copyright and related rights waived viaCC0.", "Included EIPs": "Copyright and related rights waived viaCC0.", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1716, "url": "https://eips.ethereum.org/EIPS/eip-1716", "title": "Hardfork Meta: Petersburg", "authors": ["Afri Schoedon\u00a0(", "@5chdn", ")", "Marius van der Wijden\u00a0(", "@MariusVanDerWijden", ")"], "sections": {"EIP-1716: Hardfork Meta: Petersburg": "This meta-EIP specifies the changes included in the Ethereum hardfork that removesEIP-1283fromConstantinople.", "": "This meta-EIP specifies the changes included in the Ethereum hardfork that removesEIP-1283fromConstantinople.", "Abstract": "This meta-EIP specifies the changes included in the Ethereum hardfork that removesEIP-1283fromConstantinople.", "Specification": "IfPetersburgandConstantinopleare applied at the same block,Petersburgtakes precedence: with the net effect of EIP-1283 beingdisabled.", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2387, "url": "https://eips.ethereum.org/EIPS/eip-2387", "title": "Hardfork Meta: Muir Glacier", "authors": ["James Hancock\u00a0(", "@madeoftin", ")"], "sections": {"EIP-2387: Hardfork Meta: Muir Glacier": "This meta-EIP specifies the changes included in the Ethereum hard fork named Muir Glacier. This hard fork addresses the impending Ice Age on Ethereum Mainnet and includes a commitment to solving the problems with the ice age more permanently.", "": "This meta-EIP specifies the changes included in the Ethereum hard fork named Muir Glacier. This hard fork addresses the impending Ice Age on Ethereum Mainnet and includes a commitment to solving the problems with the ice age more permanently.", "Abstract": "This meta-EIP specifies the changes included in the Ethereum hard fork named Muir Glacier. This hard fork addresses the impending Ice Age on Ethereum Mainnet and includes a commitment to solving the problems with the ice age more permanently.", "Motivation": "Ethereum achieves a consistent block time due to its\u2019 difficulty retargeting algorithm. If a block-time is higher than 20 seconds, it reduces the difficulty, and if a block time is lower than 10 seconds, it increases the difficulty. This mechanism reaches typically an equilibrium of around 13-14 seconds. Included within this mechanism is something we refer to as the Difficulty Bomb or the Ice Age. It artificially adds to the difficulty in such a way that the retargeting mechanism, at some point, can not adapt to the increase, and we see increased block times throughout the network. The ice age increments every 100,000 blocks. It at first is barely noticeable, but once it is visible, there is a drastic effect on block-times in the network.", "Specification": "I want to address the rationale for the intention of the Iceage and the implementation of the Iceage separately.", "Activation": "I want to address the rationale for the intention of the Iceage and the implementation of the Iceage separately.", "Included EIPs": "I want to address the rationale for the intention of the Iceage and the implementation of the Iceage separately.", "Rationale": "I want to address the rationale for the intention of the Iceage and the implementation of the Iceage separately.", "POA Testnets": "Muir Glacier never activates on PoA chains \u2013 thus will have zero impact onforkid.", "Note on Issuance Reduction": "Previous Hardforks to address the Ice Age have also included reductions in the block reward from 5 Eth to 3 Eth to 2 Eth, respectively. In this case, there is no change in issuance, and the block reward remains 2 Eth per block.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 5757, "url": "https://eips.ethereum.org/EIPS/eip-5757", "title": "Process for Approving External Resources", "authors": ["Sam Wilson\u00a0(", "@SamWilsn", ")"], "sections": {"EIP-5757: Process for Approving External Resources": "Ethereum improvement proposals (EIPs) occasionally link to resources external to this repository. This document sets out the requirements for origins that may be linked to, and the process for approving a new origin.", "Requirements and process for allowing new origins of external resources": "Ethereum improvement proposals (EIPs) occasionally link to resources external to this repository. This document sets out the requirements for origins that may be linked to, and the process for approving a new origin.", "Abstract": "Ethereum improvement proposals (EIPs) occasionally link to resources external to this repository. This document sets out the requirements for origins that may be linked to, and the process for approving a new origin.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Definitions": "Permissible originsMUSTprovide a method of uniquely identifying a particular revision of a resource. Examples of such methods may include git commit hashes, version numbers, or publication dates.", "Requirements for Origins": "Permissible originsMUSTprovide a method of uniquely identifying a particular revision of a resource. Examples of such methods may include git commit hashes, version numbers, or publication dates.", "Origin Removal": "Any approved origin that ceases to satisfy the above requirementsMUSTbe removed fromEIP-1. If a removed origin later satisfies the requirements again, it MAY be re-approved by following the process described inOrigin Approval.", "Origin Approval": "Should the editors determine that an origin meets the requirements above, EIP-1MUSTbe updated to include:", "Rationale": "If it is impossible to uniquely identify a version of a resource, it becomes impractical to track changes, which makes it difficult to ensure immutability.", "Unique Identifiers": "If it is impossible to uniquely identify a version of a resource, it becomes impractical to track changes, which makes it difficult to ensure immutability.", "Availability": "If it is possible to implement a standard without a linked resource, then the linked resource is unnecessary. If it is impossible to implement a standard without a linked resource, then that resource must be available for implementers.", "Free Access": "The Ethereum ecosystem is built on openness and free access, and the EIP process should follow those principles.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 6049, "url": "https://eips.ethereum.org/EIPS/eip-6049", "title": "Deprecate SELFDESTRUCT", "authors": ["William Entriken\u00a0(", "@fulldecent", ")"], "sections": {"EIP-6049: Deprecate SELFDESTRUCT": "This EIP deprecates theSELFDESTRUCTopcode and warns against its use. A breaking change to this functionality is likely to come in the future.", "Deprecate SELFDESTRUCT by discouraging its use and warning about a potential future behavior change.": "This EIP deprecates theSELFDESTRUCTopcode and warns against its use. A breaking change to this functionality is likely to come in the future.", "Abstract": "This EIP deprecates theSELFDESTRUCTopcode and warns against its use. A breaking change to this functionality is likely to come in the future.", "Motivation": "Discussions about how to changeSELFDESTRUCTare ongoing. But there is a strong consensus thatsomethingwill change.", "Specification": "Documentation of theSELFDESTRUCTopcode is updated to warn against its use and to note that a breaking change may be forthcoming.", "Rationale": "As time goes on, the cost of doing something increases, because any change toSELFDESTRUCTwill be a breaking change.", "Backwards Compatibility": "This EIP updates non-normative text in the Yellow Paper. No changes to clients is applicable.", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- deprecate selfdestruct: Officially deprecates the SELFDESTRUCT opcode by discouraging its use and signaling that its behavior might change in the future.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7329, "url": "https://eips.ethereum.org/EIPS/eip-7329", "title": "ERC/EIP Repository split", "authors": ["Lightclient\u00a0(", "@lightclient", ")", "Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-7329: ERC/EIP Repository split": "Describes the motivation and rational for splitting the EIP repositories into an\nEIP repository, targeting core ethereum changes and an ERC repository, targeting\napplication layer specifications.", "Split the ERC specifications out of the EIP repository into a new repository, so that only core protocol EIPs remain": "Describes the motivation and rational for splitting the EIP repositories into an\nEIP repository, targeting core ethereum changes and an ERC repository, targeting\napplication layer specifications.", "Abstract": "Describes the motivation and rational for splitting the EIP repositories into an\nEIP repository, targeting core ethereum changes and an ERC repository, targeting\napplication layer specifications.", "Motivation": "Long ago when the EIPs repository was created, there was a vision of a single\nhome for all standards related to Ethereum. The community was small and most\npeople were interacting at every level of the ecosystem. It made sense to\ncombine application standards with core consensus changes.", "Specification": "This specification only details with the initial mechanism of the split. The\nparticulars of how each repository will govern itself is out of scope for this\nEIP, as it is the motivating point of this EIP that the divergent needs of the\ncommunity will require highly divergent methods.", "Rationale": "There are two major communities served by the EIP process that are highly\ndivergent and very differentiated in their needs.", "Alternative: Working Groups": "One repeated concern of editors is that they often lack the technical experience\nto adequately judge if an EIP is complete and sound. Considering that EIPs\ncovers wide variety of topics such as elliptic curve cryptography, VM\nperformance, DeFi market dynamics, compression protocols, NFT Royalties, and\nconsensus protocols it is impossible for a single editor to provide sensible\nfeedback on every one of those topics.", "Alternative: Specialized Editors": "This alternative has already been implemented with the introduction of theeip-editors.ymlfile. This allows for different groups of editors to review\ndifferent types of EIPs.", "Alternative: Pain unrelated to process divergences": "This is a catch-all for a number of proposals, from allowing discord links in\ndiscussion-to to allowing more freedom in external links.", "Alternative: Replace EIP Editors with AI Chatbots": "Nobody wins in this proposal. We would instead end up debating training sets,\ncompeting implementations, and whether to use commercial providers. And\nthat\u2019s if things go well.", "Alternatives are not Mutually Exclusive": "It is critical to note that most of the discussed alternatives all have merits\nand address important pain points. The adoption of a split should not be viewed\nas a rejection of those alternatives. To quote a famous internet meme \u201cWhy Not\nBoth?\u201d", "Objection: This splits the ethereum community": "One objection is that splitting the repository would result in the community no\nlonger being able to say \u201cwe are all of us Ethereum Magicians.\u201d", "Objection: This should be anEIP-1proposal": "Since this is directly impacting the ERC process it should be documented\ninEIP-1first.", "Objection: Structural changes to a repository and process changes do not need to be bundled.": "It is possible to split the structure of the repositories separately from any\nEIP process changes related to this. Bundling the changes is unnecessary and\nsuch structure and process changes should be handled independently.", "Backwards Compatibility": "Old ERC links pointing to the old urlhttps://eips.ethereum.org/will continue\nto work. Redirect instructions will be put into place to redirect to the new ERC\nrepos for their corresponding location.", "Old Links": "Old ERC links pointing to the old urlhttps://eips.ethereum.org/will continue\nto work. Redirect instructions will be put into place to redirect to the new ERC\nrepos for their corresponding location.", "Stray Proposals": "ERC community members may continue to post new ERCs in the EIP proposal. Editors\nwill be able to redirect them to the new repository. ERCs that do not respond to\neditor requests would not be merged anyway.", "Security Considerations": "This proposal only addresses the EIP and ERC proposal process and is not\nexpected to expose any new attack surfaces by virtue of its adoption.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- erc/eip repository split: Proposes separating ERC specifications into a new repository, leaving the EIP repository focused on core protocol changes.\n- magic: A constant value set as 0xef0100 used in the CREATE_DELEGATE instruction.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7568, "url": "https://eips.ethereum.org/EIPS/eip-7568", "title": "Hardfork Meta Backfill - Berlin to Shapella", "authors": ["Tim Beiko\u00a0(", "@timbeiko", ")"], "sections": {"EIP-7568: Hardfork Meta Backfill - Berlin to Shapella": "Following Muir Glacier hard fork, Meta EIPs were abandoned in favor of other ways to track changes included in Ethereum network upgrades. This EIP aggregates the specifications for these upgrades, which themselves list the specific changes included. Specifically, it covers the Beacon Chain launch (Serenity Phase 0), Berlin, London, Altair, Arrow Glacier, Gray Glacier, The Merge (Paris + Bellatrix) and Shapella (Shanghai + Capella).", "Pointers to specifications used for the network upgrades from Berlin to Shapella.": "Following Muir Glacier hard fork, Meta EIPs were abandoned in favor of other ways to track changes included in Ethereum network upgrades. This EIP aggregates the specifications for these upgrades, which themselves list the specific changes included. Specifically, it covers the Beacon Chain launch (Serenity Phase 0), Berlin, London, Altair, Arrow Glacier, Gray Glacier, The Merge (Paris + Bellatrix) and Shapella (Shanghai + Capella).", "Abstract": "Following Muir Glacier hard fork, Meta EIPs were abandoned in favor of other ways to track changes included in Ethereum network upgrades. This EIP aggregates the specifications for these upgrades, which themselves list the specific changes included. Specifically, it covers the Beacon Chain launch (Serenity Phase 0), Berlin, London, Altair, Arrow Glacier, Gray Glacier, The Merge (Paris + Bellatrix) and Shapella (Shanghai + Capella).", "Motivation": "For many years, Ethereum used Meta EIPs to document network upgrades. Recently, consensus has formed around using them again. This EIP aggregates the network upgrades who did not have Meta EIPs and links out to their specifications.", "Specification": "The network upgrades below are listed in order of activation. Upgrades to Ethereum\u2019s execution layer are marked \u201c[EL]\u201d, and those to Ethereum\u2019s consensus layer are marked \u201c[CL]\u201d.", "Beacon Chain Launch - Serenity Phase 0 [CL]": "The full specifications for the Beacon Chain at launch can be found in thev1.0.0release of theethereum/consensus-specsrepository. Additionally,EIP-2982provides context on the Beacon Chain design and rationale for its mainnet parametrization.", "Berlin [EL]": "The set of EIPs included in Berlin were originally specified inEIP-2070, but then moved to theberlin.mdfile of theethereum/execution-specsrepository.", "London [EL]": "The set of EIPs included in London are specified in thelondon.mdfile of theethereum/execution-specsrepository.", "Altair [CL]": "The full specifications for the Altair network upgrade can be found in thev1.1.0release of theethereum/consensus-specsrepository.", "Arrow Glacier [EL]": "The set of EIPs included in Arrow Glacier are specified in thearrow-glacier.mdfile of theethereum/execution-specsrepository.", "Gray Glacier [EL]": "The set of EIPs included in Gray Glacier are specified in thegray-glacier.mdfile of theethereum/execution-specsrepository.", "The Merge": "The Merge was the first upgrade to require coordination between the execution and consensus layers. The consensus layer first activated the Bellatrix upgrade, which was followed by the activation of Paris on the execution layer.", "Shapella": "The Shapella upgrade was the first upgrade to activate at the same time on both the execution and consensus layers. To enable this, the upgrade activation mechanism on the execution layer was changed to use timestamps instead of blocks. This is described inEIP-6953andEIP-6122.", "Rationale": "The EIP repository is well known within the Ethereum community, and Meta EIPs have historically been useful to clearly list the EIPs included in a specific network upgrade.", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- serenity phase 0: The initial phase of Ethereum 2.0, introducing the beacon chain and proof-of-stake consensus without affecting Ethereum mainnet. It lays the foundation for future Ethereum upgrades, including sharding and validator mechanics.\n- hardfork meta backfill: Aggregates specifications for Ethereum network upgrades between the Berlin and Shapella hardforks, listing the included EIPs."}
{"eip": 7569, "url": "https://eips.ethereum.org/EIPS/eip-7569", "title": "Hardfork Meta - Dencun", "authors": ["Tim Beiko\u00a0(", "@timbeiko", ")"], "sections": {"EIP-7569: Hardfork Meta - Dencun": "This Meta EIP lists the EIPs included in the Dencun network upgrade across both Ethereum\u2019s execution and consensus layers.", "EIPs included in the Deneb/Cancun Ethereum network upgrade.": "This Meta EIP lists the EIPs included in the Dencun network upgrade across both Ethereum\u2019s execution and consensus layers.", "Abstract": "This Meta EIP lists the EIPs included in the Dencun network upgrade across both Ethereum\u2019s execution and consensus layers.", "Specification": "EIPs 4788, 4844, 7044, 7045 and 7514 require changes to Ethereum\u2019s consensus layer. These are specified in thedenebfolder of theethereum/consensus-specsrepository.", "Included EIPs": "EIPs 4788, 4844, 7044, 7045 and 7514 require changes to Ethereum\u2019s consensus layer. These are specified in thedenebfolder of theethereum/consensus-specsrepository.", "Full Specifications": "EIPs 4788, 4844, 7044, 7045 and 7514 require changes to Ethereum\u2019s consensus layer. These are specified in thedenebfolder of theethereum/consensus-specsrepository.", "Activation": "Note: rows in the table above will be filled as activation times are decided by client teams.", "Rationale": "This Meta EIP provides a global view of all changes included in the Dencun network upgrade, as well as links to full specification.", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- hardfork meta - dencun: Lists the EIPs included in the Deneb/Cancun network upgrade across both Ethereum's execution and consensus layers.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7587, "url": "https://eips.ethereum.org/EIPS/eip-7587", "title": "Reserve Precompile Address Range for RIPs", "authors": ["Carl Beekhuizen\u00a0(", "@carlbeek", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")", "Danny Ryan\u00a0(", "@djrtwo", ")", "Tim Beiko\u00a0(", "@timbeiko", ")"], "sections": {"EIP-7587: Reserve Precompile Address Range for RIPs": "This EIP reserves precompile ranges to ensure there are no conflicts with those used by the Rollup Improvement Proposal (RIP) process.", "Reserve precompile address range for use by the RIP process": "This EIP reserves precompile ranges to ensure there are no conflicts with those used by the Rollup Improvement Proposal (RIP) process.", "Abstract": "This EIP reserves precompile ranges to ensure there are no conflicts with those used by the Rollup Improvement Proposal (RIP) process.", "Motivation": "As L2s begin to deploy RIPs, it is necessary to reserve an address range for use by the RIP process so as to ensure there are no conflicts between precompile addresses used by RIPs and EIPs.", "Specification": "The address range between0x0000000000000000000000000000000000000100and0x00000000000000000000000000000000000001ffis reserved for use by the RIP process.", "Rationale": "By reserving an address range for RIPs, it allows the RIP process to maintain its own registry of precompiles that are not (necessarily) deployed on L1 mainnet, the EIP process is freed from having to maintain a registry of RIP precompiles while still having 255 addresses for its own use.", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "Nil.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- reserve precompile address range for rips: Reserves a precompile address range for the Rollup Improvement Proposal (RIP) process to avoid conflicts with Ethereum precompiles.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7600, "url": "https://eips.ethereum.org/EIPS/eip-7600", "title": "2025-04-01", "authors": ["Hardfork Meta - Pectra"], "sections": {"EIP-7600: Hardfork Meta - Pectra": "This Meta EIP lists the EIPs formally Scheduled for Inclusion in the Prague/Electra network upgrade.", "EIPs included in the Prague/Electra Ethereum network upgrade.": "This Meta EIP lists the EIPs formally Scheduled for Inclusion in the Prague/Electra network upgrade.", "Abstract": "This Meta EIP lists the EIPs formally Scheduled for Inclusion in the Prague/Electra network upgrade.", "Specification": "A formal definition forScheduled for Inclusioncan be found inEIP-7723.", "EIPs Scheduled for Inclusion": "EIP-6110, EIP-7002 EIP-7251, EIP-7549, EIP-7685 and EIP-7691 require changes to Ethereum\u2019s consensus layer. While the EIPs present an overview of these changes, the full specifications can be found in thespecs/electraandspecs/_featuresdirectories of theethereum/consensus-specsrepository.", "Full Specifications": "EIP-6110, EIP-7002 EIP-7251, EIP-7549, EIP-7685 and EIP-7691 require changes to Ethereum\u2019s consensus layer. While the EIPs present an overview of these changes, the full specifications can be found in thespecs/electraandspecs/_featuresdirectories of theethereum/consensus-specsrepository.", "Activation": "Note: rows in the table above will be filled as activation times are decided by client teams.", "Rationale": "This Meta EIP provides a global view of all changes included in the Prague/Electra network upgrade, as well as links to full specification.", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- eip-6110: Consensus layer client behavior regarding pre-merge blocks and deposit logs"}
{"eip": 7723, "url": "https://eips.ethereum.org/EIPS/eip-7723", "title": "2025-04-01", "authors": ["Network Upgrade Inclusion Stages"], "sections": {"EIP-7723: Network Upgrade Inclusion Stages": "Define the stages that EIPs go through in the process of planning network upgrades:Proposed for Inclusion,Considered for Inclusion,Scheduled for Inclusion,Declined for InclusionandIncluded.", "Overview of the various stages Core EIPs go through before their activation in network upgrades.": "Define the stages that EIPs go through in the process of planning network upgrades:Proposed for Inclusion,Considered for Inclusion,Scheduled for Inclusion,Declined for InclusionandIncluded.", "Abstract": "Define the stages that EIPs go through in the process of planning network upgrades:Proposed for Inclusion,Considered for Inclusion,Scheduled for Inclusion,Declined for InclusionandIncluded.", "Motivation": "This EIP proposes definitions for the various stages EIPs go through when planning network upgrades. It also provides context and guidelines around when and how EIPs should be moved from one stage to the next.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Upgrade Meta EIPs": "AnyoneMAYdraft a Meta EIP to list EIPs for a network upgrade. This Meta EIPSHOULDinclude four categories in its specification section:Proposed for Inclusion,Declined for Inclusion,Considered for InclusionandScheduled for Inclusion. Even if a category is empty, itSHOULDbe included in the initial draft for clarity.", "Upgrade Devnets": "When preparing a network upgrade, client developers typically implement EIPs first on an ephemeral test network (upgrade devnet) to verify client interoperability, before deploying to long-lived test networks. These upgrade devnets follow a naming convention ofupgradeName-devnet-version(e.g.pectra-devnet-0for the first upgrade devnet of the Pectra network upgrade,dencun-devnet-1for the second upgrade devnet of the Dencun update, etc).", "Proposed for Inclusion": "To propose an EIP for inclusion, someoneMUSTopen a pull request to add it to theProposed for Inclusionsection of the Upgrade Meta EIP. Reasonable pull requestsSHOULDbe merged in a timely fashion by the Upgrade Meta EIP author.", "Considered for Inclusion": "Once client developers have reviewed an EIP which wasProposed for Inclusion, theyMAYmove it to theConsidered for Inclusionstage. Once a decision is made by client teams to move an EIP toConsidered for Inclusion, the Upgrade Meta EIPSHOULDbe updated to reflect this.", "Declined for Inclusion": "At any time during the network upgrade planning process, client developersMAYmove EIPs from any other stage to theDeclined for Inclusionstage if client teams are against including the EIP in the network upgrade. Once a decision is made by client teams to move an EIP toDeclined for Inclusion, the Upgrade Meta EIPSHOULDbe updated to reflect this.", "Scheduled for Inclusion": "When client teams agree to implement a Core EIP in thenextUpgrade Devnet, the EIPSHOULDmove to theScheduled for Inclusionstage, and the Upgrade Meta EIPSHOULDbe updated to reflect this. Non-Core EIPsSHOULDmove toScheduled for Inclusionwhen client teams agree to immediately prioritize their implementation.", "Included": "After network upgrade activation, all included Core EIPs and activated non-Core EIPsMUSTbe moved toIncludedin the Meta EIP. All other status listsMUSTbe removed from the Meta EIP.", "Rationale": "Formalizing theProposed for Inclusion,Considered for Inclusion,Scheduled for Inclusion,Declined for InclusionandIncludedstages provides better legibility to both protocol maintainers and the broader Ethereum community.", "Backwards Compatibility": "This EIP does not directly change the Ethereum protocol. It formalizes parts of the current network upgrade planning process.", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7692, "url": "https://eips.ethereum.org/EIPS/eip-7692", "title": "EVM Object Format (EOFv1) Meta", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")", "Piotr Dobaczewski\u00a0(", "@pdobacz", ")", "Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-7692: EVM Object Format (EOFv1) Meta": "This Meta EIP lists the EIPs which belong to the EVM Object Format (EOF) proposal, in its first version (EOFv1), also known as the \u201cMega EOF\u201d.", "List of EIPs belonging to the EOFv1 proposal": "This Meta EIP lists the EIPs which belong to the EVM Object Format (EOF) proposal, in its first version (EOFv1), also known as the \u201cMega EOF\u201d.", "Abstract": "This Meta EIP lists the EIPs which belong to the EVM Object Format (EOF) proposal, in its first version (EOFv1), also known as the \u201cMega EOF\u201d.", "Specification": "Introduced in eof-devnet-0", "EIPs Included": "Introduced in eof-devnet-0", "Rationale": "Refer to the individual EIPs.", "Security Considerations": "Discussed in the individual EIPs.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7808, "url": "https://eips.ethereum.org/EIPS/eip-7808", "title": "Reserve Tx-Type Range for RIPs", "authors": ["Carl Beekhuizen\u00a0(", "@carlbeek", ")", "Yoav Weiss\u00a0(", "@yoavw", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")"], "sections": {"EIP-7808: Reserve Tx-Type Range for RIPs": "This EIP reserves atransaction-typerange for use by the Rollup Improvement Proposal (RIP) process to ensure there are no conflicts.", "Reserve transaction type range for use by the RIP process": "This EIP reserves atransaction-typerange for use by the Rollup Improvement Proposal (RIP) process to ensure there are no conflicts.", "Abstract": "This EIP reserves atransaction-typerange for use by the Rollup Improvement Proposal (RIP) process to ensure there are no conflicts.", "Motivation": "For L2s to use new transactrion types, it is necessary to reserve a transaction-type range for use by the RIP process so as to ensure there are no conflicts between transaction types used by RIPs and EIPs.", "Specification": "The transaction-type (as specified inEIP-2718) range from0x40to0x7f(inclusive of both) is reserved for use by the RIP process.", "Rationale": "By reserving a transaction-type range for RIPs, it allows the RIP process to maintain its own registry of transaction types that are not (necessarily) in use on L1 mainnet, the EIP process is then freed from having to maintain a registry of RIP tx-types while still having 64 tx-types for its own use.", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "Nil.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- transaction-type range for rips: A reserved range (0x40 to 0x7f) for transaction types used by the Rollup Improvement Proposal process.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7872, "url": "https://eips.ethereum.org/EIPS/eip-7872", "title": "Max blob flag for local builders", "authors": ["Francesco D'Amato\u00a0<", "francesco.damato@ethereum.org", ">", "Kevaundray Wedderburn\u00a0(", "@kevaundray", ")", "Toni Wahrst\u00e4tter\u00a0(", "@nerolation", ")", "Alex Stokes\u00a0(", "@ralexstokes", ")", "Ben Adams\u00a0(", "@benaadams", ")", "Gajinder Singh\u00a0(", "@g11tech", ")", "Dustin\u00a0(", "@tersec", ")"], "sections": {"EIP-7872: Max blob flag for local builders": "This EIP adds a flag to the block builder in order to allow them to include a client configured maximum amount of blobs.", "Adds a flag to set the maximum number of blobs a local builder will put in a block": "This EIP adds a flag to the block builder in order to allow them to include a client configured maximum amount of blobs.", "Abstract": "This EIP adds a flag to the block builder in order to allow them to include a client configured maximum amount of blobs.", "Motivation": "Currently a builder will include all blobs in their local mempool, up to the maximum amount that the protocol requires. If a builder has low bandwidth, they may include too many blobs\nand subsequently end up not being able to convince the network that the blobs are available.", "Specification": "Note: By defaultUSER_CONFIGURED_MAX_BLOBS_PER_BLOCKmay be set to the maximum in the current fork.", "Rationale": "By adding a flag for the local block builder, they are able to specify how many blobs they can include in a block.", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "N/A", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7607, "url": "https://eips.ethereum.org/EIPS/eip-7607", "title": "Hardfork Meta - Fusaka", "authors": ["Tim Beiko\u00a0(", "@timbeiko", ")"], "sections": {"EIP-7607: Hardfork Meta - Fusaka": "This Meta EIP lists the EIPs formally Proposed, Considered for & Scheduled for Inclusion in the Fulu/Osaka network upgrade.", "EIPs included in the Fulu/Osaka Ethereum network upgrade.": "This Meta EIP lists the EIPs formally Proposed, Considered for & Scheduled for Inclusion in the Fulu/Osaka network upgrade.", "Abstract": "This Meta EIP lists the EIPs formally Proposed, Considered for & Scheduled for Inclusion in the Fulu/Osaka network upgrade.", "Specification": "Definitions forScheduled for Inclusion,Considered for InclusionandProposed for Inclusioncan be found inEIP-7723.", "EIPs Scheduled for Inclusion": "Note: rows in the table above will be filled as activation times are decided by client teams.", "Considered for Inclusion": "Note: rows in the table above will be filled as activation times are decided by client teams.", "Declined for Inclusion": "Note: rows in the table above will be filled as activation times are decided by client teams.", "Activation": "Note: rows in the table above will be filled as activation times are decided by client teams.", "Rationale": "This Meta EIP provides a global view of all changes included in the Fusaka network upgrade, as well as links to full specification.", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- hardfork meta - fusaka: Lists the EIPs included in the Fulu/Osaka Ethereum network upgrade.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7768, "url": "https://eips.ethereum.org/EIPS/eip-7768", "title": "No-Ether transactions with free-for-all tips", "authors": ["William Entriken\u00a0(", "@fulldecent", ")"], "sections": {"EIP-7768: No-Ether transactions with free-for-all tips": "A technique is introduced where an externally-owned account having no Ether can send transactions and pay tips using a new \u201cfree-for-all\u201d bucket and using their ownorigin.tx. This requires no client changes and is compatible with existing ecosystem parts.", "Externally-owned account having no Ether can send transactions and pay tips using a new \"free-for-all\" bucket": "A technique is introduced where an externally-owned account having no Ether can send transactions and pay tips using a new \u201cfree-for-all\u201d bucket and using their ownorigin.tx. This requires no client changes and is compatible with existing ecosystem parts.", "Abstract": "A technique is introduced where an externally-owned account having no Ether can send transactions and pay tips using a new \u201cfree-for-all\u201d bucket and using their ownorigin.tx. This requires no client changes and is compatible with existing ecosystem parts.", "Motivation": "There is much interest in third-party-pay transactions on Ethereum and competing networks.", "Specification": "For example, if consideration is sent to the free-for-all address, this would typically be the last in her series of transactions.", "End user process": "For example, if consideration is sent to the free-for-all address, this would typically be the last in her series of transactions.", "Block preparer process": "This approach requires that the end user must be able to send consideration the block proposer without knowing who they are, and the block proposer must be able to realize this consideration.", "Free-for-all bucket": "This approach requires that the end user must be able to send consideration the block proposer without knowing who they are, and the block proposer must be able to realize this consideration.", "Rationale": "This approach can be useful for end users that do not want to or are not able to add Ether to their account.", "Alternatives considered": "\u2026", "Backwards Compatibility": "\u2026", "Security Considerations": "\u2026", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7919, "url": "https://eips.ethereum.org/EIPS/eip-7919", "title": "Pureth Meta", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Gajinder Singh\u00a0(", "@g11tech", ")"], "sections": {"EIP-7919: Pureth Meta": "This Meta EIP lists the EIPs which belong to the Pureth proposal.", "List of EIPs belonging to the Pureth proposal": "This Meta EIP lists the EIPs which belong to the Pureth proposal.", "Abstract": "This Meta EIP lists the EIPs which belong to the Pureth proposal.", "Motivation": "It is currently not feasible to consume Ethereum data for a given account to efficiently reconstruct the account activity, without relying on a trusted API gateway. This is a problem for:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "PURGE: LOG Reform": "Certain EVM operations can change the ETH balance, without an appropriate log being emitted. For example, a SELFDESTRUCT can send an arbitrary ETH balance to an arbitrary account, e.g., as part of a smart contract based wallet. To monitor such operations, the application would have to use tracing APIs on every single transaction of every single block. Adding logs for ETH transfers enables the use of existingeth_getLogsinfrastructure to obtain a fully accurate account history.", "PURGE: Remove old tx types": "Moving logs to SSZ affects the receipts structure, which are defined by the various transaction types. Therefore, changing the receipts breaks backwards compatibility. By introducing a new transaction type, a new receipt type can be introduced. Basing that new transaction type on SSZ also enables proofs for individual parts of calldata.", "PURGE: Serialization harmonization": "While the proposed changes do not affect applications that use a trusted API gateway via JSON-RPC, they represent breaking changes for applications that verify Ethereum data today. To avoid recurring breaking changes, the rest of the execution block is also transitioned to SSZ at the same time. This will likely require cooperating with popular applications that rely on assumptions about the block header layout.", "Simple Serialize (SSZ) requirements": "The EIPs require adding production-grade Simple Serialize (SSZ) libraries to all execution client implementations. Further, new SSZ data types are required to achieve forward compatibility while maintaining reasonable efficiency.", "Rationale": "See individual EIPs.", "Security Considerations": "See individual EIPs.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- selfdestruct: A renamed opcode from SUICIDE, introduced in EIP-6, to avoid negative connotations .\n- calldata: Data passed as part of an instruction call or memory expansion operation, which must be within 24576 bytes in size before EIP-170.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785."}
{"eip": 7927, "url": "https://eips.ethereum.org/EIPS/eip-7927", "title": "History Expiry Meta", "authors": ["Piper Merriam\u00a0(", "@pipermerriam", ")"], "sections": {"EIP-7927: History Expiry Meta": "This Meta-EIP documents the activation process and plan for history expiry as well as providing links to other EIPs that are related.", "Meta EIP for History Expiry changes happening in conjunction with Pectra": "This Meta-EIP documents the activation process and plan for history expiry as well as providing links to other EIPs that are related.", "Abstract": "This Meta-EIP documents the activation process and plan for history expiry as well as providing links to other EIPs that are related.", "Motivation": "EIP-4444documents the motivation for history expiry itself.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Mainnet Activation": "Mainnet activation of history expiry will occur shortly (a few days or weeks) after the activation of thePectrahard fork. The short delay is to ensure that all deposit logs from before the fork have been processed before clients begin dropping history.", "Testnet Activation": "Testing of history expiry will occur on the Sepolia testnet. Execution clients may begin dropping pre-merge Sepolia history on 2025-05-01.", "Devnet Activation": "Execution clients may test dropping of history on devnets for all history prior to blockTODO-WHAT-BLOCK-NUMBER?.", "Rationale": "Consensus Layer clients have a dependency on pre-merge deposit logs.EIP-6110will remove this dependency when the Pectra fork is activated.", "Why wait for Pectra": "Consensus Layer clients have a dependency on pre-merge deposit logs.EIP-6110will remove this dependency when the Pectra fork is activated.", "Why drop Sepolia history": "The Sepolia history drop is intended as a testing ground for the mainnet activation.", "Why drop Devnet history": "The Devnet history drop is intended to test prior to Sepolia to avoid any breakage on the Sepolia network.", "Won\u2019t this break JSON-RPC": "History Expiry doesn\u2019t require clients to remove this data. It only allows them to. Clients that wish to preserve this history in their client for JSON-RPC use cases are free to do so.", "Where will Pre-Merge history be stored": "Pre-merge data is available in the e2store archival format. A public list of these archives can be found in theeth-clientshistorical data endpoints list which can be found on theeth-clientswebsite.", "Backwards Compatibility": "Clients of the DevP2Pethprotocol will need to upgrade to the neweth/69version specified inEIP-7642", "DevP2Pethprotocol": "Clients of the DevP2Pethprotocol will need to upgrade to the neweth/69version specified inEIP-7642", "Pre-Merge Deposit Logs": "Consensus Layer clients have had a historical dependency on the deposit logs from pre-merge blocks. Dropping history would make these logs inaccessible to the Consensus Layer client. This issue is mitigated byEIP-6110", "Serving Pre-Merge JSON-RPC": "Execution clients that choose to drop history will no longer be capable of serving JSON-RPC requests for pre-merge requests for the following endpoints without sourcing the data from an alternate data source.", "Security Considerations": "Execution layer clients will no longer be able to implement a full historical sync of history from the DevP2Pethprotocol.  Clients that wish to retain this functionality will need to source the pre-merge blocks from an alternate source.  Clients SHOULD ensure that they continue to correctly validate block data sourced from alternate locations.", "Full History Sync": "Execution layer clients will no longer be able to implement a full historical sync of history from the DevP2Pethprotocol.  Clients that wish to retain this functionality will need to source the pre-merge blocks from an alternate source.  Clients SHOULD ensure that they continue to correctly validate block data sourced from alternate locations.", "Partial History Sync": "Execution layer clients that do a partial sync will need to adjust their syncing algorithms to only go back to the merge block as opposed to the previous behavior of tracing all the way back to genesis.  Clients SHOULD ensure that their sync algorithms and other functionality are able to handle this data no longer being locally available.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- devp2p: A networking protocol for Ethereum. EIP-8 introduces forward compatibility requirements for devp2p implementations .\n- genesis: Log entry in system_logs for initial balances at network genesis ."}
{"eip": 233, "url": "https://eips.ethereum.org/EIPS/eip-233", "title": "Formal process of hard forks", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-233: Formal process of hard forks": "To describe the formal process of preparing and activating hard forks.", "": "To describe the formal process of preparing and activating hard forks.", "Abstract": "To describe the formal process of preparing and activating hard forks.", "Motivation": "Today discussions about hard forks happen at various forums and sometimes in ad-hoc ways.", "Specification": "A Meta EIP should be created and merged as aDraftas soon as a new hard fork is planned.", "Timeline": "Once a timeline with key dates is agreed upon for other crucial dates. The basic outline of a hardfork timeline should include:", "EIP Inclusion Process": "Anyone that wishes to propose a Core EIP for the hard fork should make a PR against the Meta EIP representing the hard fork. The EIP must be published as at leastDraft. It enters theProposed EIPssection, along with at least one person who is a point of contact for wanting to include the EIP.", "Template": "A template for theIstanbul Hardfork Meta 1679is included below (source file on GitHub):", "Rationale": "A meta EIP for coordinating the hard fork should help in visibility and traceability of the scope of changes as well as provide a simple name and/or number for referring to the proposed fork.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- istanbul hardfork: A meta-EIP that specifies the changes included in the Istanbul hardfork, incorporating various EIPs aimed at improving performance, security, and cost-efficiency of Ethereum.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 867, "url": "https://eips.ethereum.org/EIPS/eip-867", "title": "Standardized Ethereum Recovery Proposals", "authors": ["Dan Phifer\u00a0<", "dp@musiconomi.com", ">", "James Levy\u00a0<", "james@taptrust.com", ">", "Reuben Youngblom\u00a0<", "reuben@taptrust.com", ">"], "sections": {"EIP-867: Standardized Ethereum Recovery Proposals": "Provide a standardized format for Ethereum Recovery Proposals (ERPs), which relate to recovery of certain classes of lost funds.  Individual ERPs will follow the same process as any EIP, but will be formatted and evaluated in a standard way to ensure consistency and transparency.", "": "Provide a standardized format for Ethereum Recovery Proposals (ERPs), which relate to recovery of certain classes of lost funds.  Individual ERPs will follow the same process as any EIP, but will be formatted and evaluated in a standard way to ensure consistency and transparency.", "Simple Summary": "Provide a standardized format for Ethereum Recovery Proposals (ERPs), which relate to recovery of certain classes of lost funds.  Individual ERPs will follow the same process as any EIP, but will be formatted and evaluated in a standard way to ensure consistency and transparency.", "Abstract": "This proposal identifies a common solution method that can be used to address certain classes of lost funds on the Ethereum blockchain.  In particular, it is intended to address cases where there is no disagreement about the right outcome between directly affected parties, enabling timely and low-risk solutions to many issues that have already occurred or are likely to occur again as Ethereum grows.", "Motivation": "The issue of fund recovery on the Ethereum blockchain is often controversial. Frozen fund recovery proposals are almost never successful due to the relatively ad-hoc nature of such requests and the subjectivity that is often required to evaluate the merits. This EIP attempts to remove these barriers by providing both a standardized format for fund recovery EIPs and an objective standard by which to measure future proposals.", "Specification": "This EIP describes a common format to be used for a subclass of EIPs, referred to as ethereum recovery proposals (ERPs), that propose an irregular state change required to address a fund recovery scenario that cannot be addressed using the standard protocol.  Each ERP will reference this EIP will follow the guidelines set out here.", "Justification": "A concise description of why this action is both reasonable (cannot be accomplished without an irregular state change) and unlikely to be challenged by adirectlyaffected party.", "Verification Script": "A machine-readable script that outputs a single State Change Object. This script should be implemented so that it is easily audited by a reviewer. Verification scripts should be javascript files that may use theweb3.jslibrary.", "State Change Object": "The State Change Object is a standard format that will be interpretable by all Ethereum clients.", "State Change Actions": "A State Change action is a JSON object that includes a \u201ctype\u201d field and a set of \u201cdata\u201d fields, where the contents of the data fields are dependent on the type and must follow the schema defined for that type.  This allows clients to support a limited set of operations initially and add more based on a subsequent EIP if needed.  Support for the following action types should be implemented by clients upon adoption of this EIP:", "Appendix (Optional)": "The appendix can include additional supporting evidence or attachments that will help reviewers understand or verify the claims made in the ERP.", "ERP Approval Process": "ERPs are a subclass of EIPs and will, therefore, follow the same approval process.", "Testing": "The ERP authors are currently seeking feedback from client teams about the proper testing procedures", "Ethereum Client Implementation": "Clients that choose to adopt the proposal outlined in this EIP will implement a module that scans a designated directory for SCO files (each time the client process launches) to construct a mapping between target blocks and SCO file names.  When starting work on a new block, clients should first consult the set of SCO target blocks discovered and determine if there are any recovery actions required for the current block.", "Limitations of this EIP": "This EIP is focused on standardizing how recovery proposals can be formatted, to optimize readability and eliminate or minimize as much as possible the potential for mistakes or intentional abuses.", "Rationale": "The primary consideration for the approach described above was to minimize the amount of risk associated with recovery actions that would otherwise not have a viable solution.  A secondary consideration was to standardize the format used in the proposals for recovery actions.", "Implementation": "A reference implementation has been written for the EthereumJ platform. See the pull requesthere.", "ERP Examples": "This section will include examples and SCO resource files, as well as a brief tutorial on how to test using a private testnet.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 1588, "url": "https://eips.ethereum.org/EIPS/eip-1588", "title": "Hardfork Meta: Ethereum ProgPoW", "authors": ["Ikmyeong Na\u00a0(", "@naikmyeong", ")"], "sections": {"EIP-1588: Hardfork Meta: Ethereum ProgPoW": "This meta-EIP specifies the changes included in the alternative Ethereum hardfork named Ethereum ProgPoW.", "": "This meta-EIP specifies the changes included in the alternative Ethereum hardfork named Ethereum ProgPoW.", "Abstract": "This meta-EIP specifies the changes included in the alternative Ethereum hardfork named Ethereum ProgPoW.", "Specification": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- progpow: A new Proof-of-Work algorithm designed to be ASIC-resistant by utilizing more parts of commodity GPUs, minimizing the efficiency gap between general-purpose hardware and specialized ASICs.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 1872, "url": "https://eips.ethereum.org/EIPS/eip-1872", "title": "Ethereum Network Upgrade Windows", "authors": ["Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-1872: Ethereum Network Upgrade Windows": "A proposal to define a limited number of annual time windows in which network\nupgrades (aka hard forks) should be performed within. Policies for scheduling\nnetwork upgrades outside these windows are also described.", "": "A proposal to define a limited number of annual time windows in which network\nupgrades (aka hard forks) should be performed within. Policies for scheduling\nnetwork upgrades outside these windows are also described.", "Simple Summary": "A proposal to define a limited number of annual time windows in which network\nupgrades (aka hard forks) should be performed within. Policies for scheduling\nnetwork upgrades outside these windows are also described.", "Abstract": "Four different weeks, spaced roughly evenly throughout the year, are targeted\nfor network upgrades to be launched. Regular network upgrades should announce\ntheir intention to launch in a particular window early in their process and\nchoose a block number four to six weeks prior to that window. If a network\nupgrade is cancelled then it would be rescheduled for the next window. Not all\nwindows will be used. Priority upgrades outside the roadmap may be scheduled in\nthe third week of any month, but such use is discouraged. Critical upgrades are\nscheduled as needed.", "Motivation": "The aim of this EIP is to provide some level of regularity and predictability to\nthe Ethereum network upgrade/hard fork process. This will allow service\nproviders such as exchanges and node operators a predictable framework to\nschedule activities around. This also provides a framework to regularize the\ndelivery of network upgrades.", "Specification": "Scheduling is defined for three categories of network upgrades. First areRoadmapnetwork upgrades that include deliberate protocol improvements. Next\narePrioritynetwork updates, where there are technical reasons that\nnecessitate a prompt protocol change but these reasons do not present a systemic\nrisk to the protocol or the ecosystem. Finally,Criticalnetwork upgrades are\nto address issues that present a systemic risk to the protocol or the ecosystem.", "Roadmap Network Upgrades": "Roadmap network upgrades are network upgrades that are deliberate and measured\nto improve the protocol and ecosystem. Historical examples are Homestead,\nByzantium, and Constantinople.", "Priority Network Upgrades": "Priority network upgrades are reserved for upgrades that require more urgency\nthan a roadmap network upgrade yet do not present a systemic risk to the network\nor the ecosystem. To date there have been no examples of a priority upgrade.\nPossible examples may include roadmap upgrades that need to occur in multiple\nupgrades or for security risks that have a existing mitigation in place that\nwould be better served by a network upgrade. Another possible reason may be to\ndefuse the difficulty bomb due to postponed roadmap upgrades.", "Critical Network Upgrades": "Critical network upgrades are network upgrades that are designed to address\nsystemic risks to the protocol or to the ecosystem. Historical examples include\nDao Fork, Tangerine Whistle, and Spurious Dragon.", "Network Upgrade Block Number Choice": "When choosing an activation block the number can be used to communicate the role\nof a particular network in the Ethereum Ecosystem. Networks that serve as a\nvalue store or are otherwise production grade have different stability concerns\nthan networks that serve as technology demonstration or are explicitly\ndesignated for testing.", "Rationale": "The rationale for defining launch windows is to give business running Ethereum\ninfrastructure a predictable schedule for when upgrades may or may not occur.\nKnowing when a upgrade is not going to occur gives the businesses a clear time\nframe within which to perform internal upgrades free from external changes. It\nalso provides a timetable for developers and IT professionals to schedule time\noff against.", "Backwards Compatibility": "Except for the specific launch windows the previous network upgrades would have\ncomplied with these policies. Homestead, Byzantium, and Constantinople would\nhave been Roadmap Network Upgrades. There were no Priority Network Upgrades,\nalthough Spurious Dragon would have been a good candidate. Dao Fork was a\nCritical Network Upgrade in response to TheDao. Tangerine Whistle and Spurious\nDragon were critical upgrades in response to the Shanghai Spam Attacks.\nConstantinople Fix (as it is termed in the reference tests) was in response to\nthe EIP-1283 security issues.", "Implementation": "The windows in this EIP are expected to start after the Istanbul Network\nupgrade, which is the next planned Roadmap upgrade. Istanbul is currently slated\nfor mainnet launch on 2019-10-16, which is compatible with the schedule in this\nEIP.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- dao fork: Describes an irregular state change at block 1,920,000, which transferred ether from the DAO and related accounts to a WithdrawDAO contract following the infamous DAO hack.\n- network upgrade windows: Defines four annual time windows for scheduling network upgrades (hard forks) to provide predictability.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2378, "url": "https://eips.ethereum.org/EIPS/eip-2378", "title": "EIPs Eligible for Inclusion", "authors": ["James Hancock\u00a0(", "@MadeofTin", ")"], "sections": {"EIP-2378: EIPs Eligible for Inclusion": "As part of an EIP centric forking model, this EIP tracks the first step in the approval process for any EIP to be included in a fork or upgrade. Specifically, the stage where the Core Developers vet the concept of an EIP and give a \u201cgreen light\u201d sufficient for EIP authors to move forward in development.", "": "As part of an EIP centric forking model, this EIP tracks the first step in the approval process for any EIP to be included in a fork or upgrade. Specifically, the stage where the Core Developers vet the concept of an EIP and give a \u201cgreen light\u201d sufficient for EIP authors to move forward in development.", "Simple Summary": "As part of an EIP centric forking model, this EIP tracks the first step in the approval process for any EIP to be included in a fork or upgrade. Specifically, the stage where the Core Developers vet the concept of an EIP and give a \u201cgreen light\u201d sufficient for EIP authors to move forward in development.", "Abstract": "The pipeline for Core EIPs, per the EIP-Centric upgrade model, is as follows.", "Motivation": "Development of clear specifications and pull requests to existing Ethereum Clients is a large investment of time and resources. The state ofEligible for Inclusionis a signal from the Ethereum Core Developers to an EIP Author validiating the idea behind an EIP and  confirms investing their time further pursing it is worthwhile.", "Specification": "EIP Number", "Rationale": "EIP Number", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- eips eligible for inclusion: Tracks the status of EIPs that have been vetted by the core developers and marked as eligible for inclusion in future forks or upgrades.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2657, "url": "https://eips.ethereum.org/EIPS/eip-2657", "title": "Ephemeral Testnet Yolo", "authors": ["James Hancock\u00a0(", "@madeoftin", ")"], "sections": {"EIP-2657: Ephemeral Testnet Yolo": "Disclaimer: This is for testing basic infrastructure. It will be nuked. It is not for deploying dapps, nor does it define what will go into mainnet. For information on network upgrades, please follow the relevant meta EIPs and ongoing discussion on Ethereum/pm.", "": "Disclaimer: This is for testing basic infrastructure. It will be nuked. It is not for deploying dapps, nor does it define what will go into mainnet. For information on network upgrades, please follow the relevant meta EIPs and ongoing discussion on Ethereum/pm.", "Abstract": "The specification for Ephemeral Testnet Yolo. Clients who wish to sync need to implement the following features into their client. It is for testing basic infrastructure and will be nuked.", "Specification": "Name: Yolo\nID:YOLO-v1", "Timeline": "YOLO-v1\n|Client| Signal | Spec | Merged | Syncing |\n|\u2014\u2014\u2014\u2014\u2013|\u2014\u2014\u2013|\u2014\u2014|\u2014\u2014\u2013|\u2014\u2014\u2014|\n| Besu         | x      | x    |        |         |\n| EthereumJS   | x      |      |        |         |\n| Geth         | x      | x    | x      | x       |\n| Nethermind   | x      | x    |        |         |\n| OpenEthereum | x      | x    |        |         |\n| Trinity      |        |      |        |         |", "Client Consensus -> Implementation": "YOLO-v1\n|Client| Signal | Spec | Merged | Syncing |\n|\u2014\u2014\u2014\u2014\u2013|\u2014\u2014\u2013|\u2014\u2014|\u2014\u2014\u2013|\u2014\u2014\u2014|\n| Besu         | x      | x    |        |         |\n| EthereumJS   | x      |      |        |         |\n| Geth         | x      | x    | x      | x       |\n| Nethermind   | x      | x    |        |         |\n| OpenEthereum | x      | x    |        |         |\n| Trinity      |        |      |        |         |", "Syncing Instructions": "Geth", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- ephemeral testnet yolo: Specifies the Yolo ephemeral testnet, a short-lived network for testing infrastructure, not meant for dapp deployment or long-term use.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7577, "url": "https://eips.ethereum.org/EIPS/eip-7577", "title": "Versioning Scheme for EIPs", "authors": ["danceratopz\u00a0(", "@danceratopz", ")", "Ahmad Bitar\u00a0(", "@smartprogrammer93", ")"], "sections": {"EIP-7577: Versioning Scheme for EIPs": "This EIP introduces a versioning scheme forStandards TrackEIPs by applyingSemantic Versioning 2.0.0based on changes made to the EIP\u2019s Specification section once its status has changed fromDrafttoReview.", "Use a versioning scheme for EIPs based on changes made to their Specification section.": "This EIP introduces a versioning scheme forStandards TrackEIPs by applyingSemantic Versioning 2.0.0based on changes made to the EIP\u2019s Specification section once its status has changed fromDrafttoReview.", "Abstract": "This EIP introduces a versioning scheme forStandards TrackEIPs by applyingSemantic Versioning 2.0.0based on changes made to the EIP\u2019s Specification section once its status has changed fromDrafttoReview.", "Motivation": "EIP specifications often receive increasing modifications as more people review them, which is generally the case as client teams start implementing the specifications and the community gains a better understanding of their interaction with the rest of the protocol. These changes can be difficult to track. In particular, as EVM reference tests are often not maintained (and generally not released) by client teams or the EIP\u2019s authors, it can be difficult to ascertain whether a release of reference tests is sufficient, or even valid, to test the latest version of an EIP\u2019s specifications or the specification as currently implemented by a client.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "Making the version available in the EIP\u2019s metadata header allows for programmatic parsing of the version number by tooling used in reference tests or by client teams. Currently, the execution-spec-tests repository, which contains consensus tests for Ethereum execution clients, implements a rudimentary EIP version checker: EIP spec tests are required to declare the EIP\u2019s markdown file digest SHA that the test implementation was based on. The current value of the digest SHA is then polled via the Github API to verify that no changes have occurred since the test implementation. While this provides a warning to test implementers that the EIP has changed, it is clearly of limited use.", "Case Study": "This section explores how the versioning scheme would be applied to an existing EIPs recently under active development at the time of writing as an example.", "Backwards Compatibility": "It is not necessary to retroactively add a CHANGELOG or versions for versions of the EIP prior to the introduction of this EIP. Upon the next change to the EIP\u2019s Specification section, the author MUST introduce a CHANGELOG section and a version number that follows the semantic versioning scheme outlined above.", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- versioning scheme for eips: Introduces a semantic versioning scheme for EIPs, allowing clearer tracking of specification changes after they move to the \"Review\" status.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 7773, "url": "https://eips.ethereum.org/EIPS/eip-7773", "title": "Hardfork Meta - Amsterdam", "authors": ["Tim Beiko\u00a0(", "@timbeiko", ")"], "sections": {"EIP-7773: Hardfork Meta - Amsterdam": "This Meta EIP lists the EIPs formally Proposed, Considered for & Scheduled for Inclusion in the Amsterdam network upgrade.", "EIPs included in the Amsterdam Ethereum network upgrade.": "This Meta EIP lists the EIPs formally Proposed, Considered for & Scheduled for Inclusion in the Amsterdam network upgrade.", "Abstract": "This Meta EIP lists the EIPs formally Proposed, Considered for & Scheduled for Inclusion in the Amsterdam network upgrade.", "Specification": "Definitions forScheduled for Inclusion,Considered for InclusionandProposed for Inclusioncan be found inEIP-7723.", "EIPs Scheduled for Inclusion": "Note: rows in the table above will be filled as activation times are decided by client teams.", "Considered for Inclusion": "Note: rows in the table above will be filled as activation times are decided by client teams.", "Proposed for Inclusion": "Note: rows in the table above will be filled as activation times are decided by client teams.", "Activation": "Note: rows in the table above will be filled as activation times are decided by client teams.", "Rationale": "This Meta EIP provides a global view of all changes included in the Amsterdam network upgrade, as well as links to full specification.", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2070, "url": "https://eips.ethereum.org/EIPS/eip-2070", "title": "Hardfork Meta: Berlin", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-2070: Hardfork Meta: Berlin": "This meta-EIP specifies the changes included in the Ethereum hardfork named Berlin.", "": "This meta-EIP specifies the changes included in the Ethereum hardfork named Berlin.", "Abstract": "This meta-EIP specifies the changes included in the Ethereum hardfork named Berlin.", "Specification": "In the current stage of coordination, the changes are tracked and discussed in theeth1.0-specsrepository.\nFor an accurate status please refer to theberlin.mdfile.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7199, "url": "https://eips.ethereum.org/EIPS/eip-7199", "title": "Linter Scope", "authors": ["Zainan Victor Zhou\u00a0(", "@xinbenlv", ")"], "sections": {"EIP-7199: Linter Scope": "Currently in practice EIP linter tools (EIPW, for example) will block a Pull Request for lint errors even if that lint errors was not introduced in that Pull Request.\nThis EIP make it explicit that lint errors for untouched lines shall be considered ignoreable except for status change.", "Relax the policy for updating EIP.": "Currently in practice EIP linter tools (EIPW, for example) will block a Pull Request for lint errors even if that lint errors was not introduced in that Pull Request.\nThis EIP make it explicit that lint errors for untouched lines shall be considered ignoreable except for status change.", "Abstract": "Currently in practice EIP linter tools (EIPW, for example) will block a Pull Request for lint errors even if that lint errors was not introduced in that Pull Request.\nThis EIP make it explicit that lint errors for untouched lines shall be considered ignoreable except for status change.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "This policy allows micro contributions for anyone who just want to fix a typo or change a section of a section in a large EIP.", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- linter scope: Suggests a policy where EIP lint errors on unchanged lines should not block pull requests, improving the contribution process.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7675, "url": "https://eips.ethereum.org/EIPS/eip-7675", "title": "Retroactively Included EIPs", "authors": ["Tim Beiko\u00a0(", "@timbeiko", ")"], "sections": {"EIP-7675: Retroactively Included EIPs": "This Meta EIP lists Core EIPs introducing changes to Ethereum\u2019s consensus which were activated independently of an Ethereum hard fork due to their backward compatible nature. These EIPs generally introduce constraints to underspecified protocol rules  or clarify how certain edge cases should be handled.", "Core EIPs activated independently of an Ethereum hard fork.": "This Meta EIP lists Core EIPs introducing changes to Ethereum\u2019s consensus which were activated independently of an Ethereum hard fork due to their backward compatible nature. These EIPs generally introduce constraints to underspecified protocol rules  or clarify how certain edge cases should be handled.", "Abstract": "This Meta EIP lists Core EIPs introducing changes to Ethereum\u2019s consensus which were activated independently of an Ethereum hard fork due to their backward compatible nature. These EIPs generally introduce constraints to underspecified protocol rules  or clarify how certain edge cases should be handled.", "Motivation": "To maintain consensus across all nodes, backward incompatible changes to Ethereum must be activated synchronously. Given the coordination required for this, changes are usually bundled together in network upgrades. A Meta EIP is typically used to list the changes included in a network upgrade, as well as its activation time.", "Specification": "All EIPs listed above are considered activated as of Ethereum\u2019s genesis block. Note that EIP-7523 distinguishes pre- and post-merge behavior on the Ethereum mainnet.", "Retroactively Activated EIPs": "All EIPs listed above are considered activated as of Ethereum\u2019s genesis block. Note that EIP-7523 distinguishes pre- and post-merge behavior on the Ethereum mainnet.", "Activation": "All EIPs listed above are considered activated as of Ethereum\u2019s genesis block. Note that EIP-7523 distinguishes pre- and post-merge behavior on the Ethereum mainnet.", "Rationale": "This Meta EIP provides a global view of all changes included in the Ethereum protocol without an explicit network upgrade, as well as links to full specification.", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- retroactively included eips: Lists EIPs introducing backward-compatible consensus changes that were activated independently of network upgrades, such as nonce limits and rejecting transactions from EOAs with deployed code.\n- genesis: Log entry in system_logs for initial balances at network genesis .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2228, "url": "https://eips.ethereum.org/EIPS/eip-2228", "title": "Canonicalize the name of network ID 1 and chain ID 1", "authors": ["William Entriken\u00a0(", "@fulldecent", ")"], "sections": {"EIP-2228: Canonicalize the name of network ID 1 and chain ID 1": "The Ethereum network with network ID 1 and chain ID 1 is named Ethereum Mainnet.", "": "The Ethereum network with network ID 1 and chain ID 1 is named Ethereum Mainnet.", "Simple Summary": "The Ethereum network with network ID 1 and chain ID 1 is named Ethereum Mainnet.", "Abstract": "The name for the Ethereum network with network ID 1 and chain ID 1 shall be Ethereum Mainnet or just Mainnet. This is a proper noun.", "Motivation": "The Ethereum network with network ID 1 and chain ID 1 is referenced using several conflicting names across EIPs, client implementations, and information published on the internet at large. In several locations, even documents written by the same author use inconsistent names to refer to the Ethereum network with network ID 1 and chain ID 1. Names in use at the time of this writing include:", "Specification": "The network name for network ID 1 and chain ID 1 shall be Ethereum Mainnet, or just Mainnet if the context is known to be discussing Ethereum networks. This IS a proper noun. Several examples are given below which differentiate between usage of the name of the network versus a descriptive reference to the network.", "Trademark note": "\u201cEthereum\u201d is trademarked by the Ethereum Foundation. For more information on your obligations when mentioning \u201cEthereum\u201d, and possibly \u201cEthereum Mainnet\u201d, see:", "Rationale": "Choosing common word use promotes interoperability of implementations and increases customer awareness. Also, it adds a sense of professionalism when customers see the same word and word styling (i.e. capitalization of letters) across different implementations.", "Backwards Compatibility": "No specification is made on whether Dapp, dapp, dApp, etc. is preferred.", "Test Cases": "No specification is made on whether Dapp, dapp, dApp, etc. is preferred.", "Examples referencing the name of the network \u2705": "No specification is made on whether Dapp, dapp, dApp, etc. is preferred.", "Examples referencing the network in a descriptive way \u2705": "This shows that \u201cmain\u201d is used as a descriptive word, but Mainnet is the specific network which is having network ID 1 and chain ID 1.", "Examples of other correct word usage \u2705": "This shows that \u201cmain\u201d is used as a descriptive word, but Mainnet is the specific network which is having network ID 1 and chain ID 1.", "Examples of poor word choice (avoid this) \u274c": "This is referring to a \u201cmain\u201d network which is context-dependent. If you were reading this text on a page about Ethereum Classic, they would be referring to network ID 2 and chain ID 62. Therefore this word usage is less crisp. Do NOT use wording like this.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2982, "url": "https://eips.ethereum.org/EIPS/eip-2982", "title": "Serenity Phase 0", "authors": ["Danny Ryan\u00a0(", "@djrtwo", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-2982: Serenity Phase 0": "This EIP specifies Phase 0 of Serenity (eth2), a multi-phased upgrade to the consensus mechanism for Ethereum mainnet. In Phase 0, the existing PoW chain and mechanics are entirely unaffected, while a PoS chain \u2013 the beacon chain \u2013 is built in parallel to serve as the core of the upgraded consensus. In subsequent phases, the beacon chain is enhanced to support and secure the consensus of a number of parallel shard chains, ultimately incorporating current Ethereum mainnet as one of those shards.", "Phase 0 of the release schedule of Serenity, a series of updates to Ethereum a scalable, proof-of-stake consensus": "This EIP specifies Phase 0 of Serenity (eth2), a multi-phased upgrade to the consensus mechanism for Ethereum mainnet. In Phase 0, the existing PoW chain and mechanics are entirely unaffected, while a PoS chain \u2013 the beacon chain \u2013 is built in parallel to serve as the core of the upgraded consensus. In subsequent phases, the beacon chain is enhanced to support and secure the consensus of a number of parallel shard chains, ultimately incorporating current Ethereum mainnet as one of those shards.", "Abstract": "This EIP specifies Phase 0 of Serenity (eth2), a multi-phased upgrade to the consensus mechanism for Ethereum mainnet. In Phase 0, the existing PoW chain and mechanics are entirely unaffected, while a PoS chain \u2013 the beacon chain \u2013 is built in parallel to serve as the core of the upgraded consensus. In subsequent phases, the beacon chain is enhanced to support and secure the consensus of a number of parallel shard chains, ultimately incorporating current Ethereum mainnet as one of those shards.", "Motivation": "Eth2 aims to fulfill the original vision of Ethereum to support an efficient, global-scale, general-purpose transactional platform while retaining high cryptoeconomic security and decentralization.", "Scaling through sharding": "As the Ethereum network and the applications built upon it have seen increasing usage over the past 5 years, blocks have become regularly full and the gas price market continues to climb. Simple increases to the block gas-limit of the current Ethereum chain are unable to account for the increase in demand of the system without inducing an unsustainably high resource burden (in the form of bandwidth, computational, and disk resources) on consumer nodes. To retain decentralization while scaling up the Ethereum network, another path must be taken.", "Decentralization and economic finality through proof-of-stake": "Since the early days of Ethereum, proof-of-stake has been a long-awaited desideratum for the following:", "Specification": "Phase 0 is designed to requireno breaking consensus changesto existing Ethereum mainnet. Instead, this is the bootstrapping a new PoS consensus that can, once stable, supplant the current PoW consensus.", "Parameters": "Note:Eth2 has many more Phase 0 configuration parameters but the majority are left out of this EIP for brevity.", "Validator deposit contract": "In Phase 0, eth2 uses a contract deployed on Ethereum mainnet \u2013 the Deposit Contract \u2013 atDEPOSIT_CONTRACT_ADDRESSto onboard validators into the PoS consensus of the beacon chain.", "Beacon chain and validator mechanics": "Users who choose to participate in eth2 consensus deposit ETH collateral into the deposit contract in order to be inducted into the beacon chain validator set. From there, these validators are responsible for constructing thebeacon chain(note that these consensus participants in PoS are akin to miners in PoW).", "Issuance": "To incentivize validators to deposit ether collateral and participate in the eth2 consensus, we propose that rewards (in the form of Ethereum\u2019s native asset, ether) be regularly issued to consensus participants. Due to the beacon chain operating in parallel to the existing PoW chain in early phases of eth2, this issuance isin addition toany PoW rewards until the existing chain is merged into eth2 as a shard.", "Initial punitive parameters": "For PoS protocols to be crypto-economically secure, in-protocol penalties are required. Small offline penalties incentivize validator liveness, whereas (potentially) much larger penalties provide protocol security in the event of tail-risk scenarios.", "Rationale": "The Ethereum roadmap uses a mixed layer 1 / layer 2 approach. We focus on serving a particular type of layer 2 (rollups) because it\u2019s the only kind of layer 2 that both inherits the security of layer 1 and provides scaling of general-purpose applications. However, rollups come at a cost: they require some on-chain dataper transaction, and so a blockchain with really high capacity rollups must be able to handle a still quite high amount of data bandwidth. So make this more feasible, we are implementing on scalable data layer technologies, particularly data availability sampling.", "Principles": "The Ethereum roadmap uses a mixed layer 1 / layer 2 approach. We focus on serving a particular type of layer 2 (rollups) because it\u2019s the only kind of layer 2 that both inherits the security of layer 1 and provides scaling of general-purpose applications. However, rollups come at a cost: they require some on-chain dataper transaction, and so a blockchain with really high capacity rollups must be able to handle a still quite high amount of data bandwidth. So make this more feasible, we are implementing on scalable data layer technologies, particularly data availability sampling.", "The Layer 1 vs Layer 2 Tradeoff": "The Ethereum roadmap uses a mixed layer 1 / layer 2 approach. We focus on serving a particular type of layer 2 (rollups) because it\u2019s the only kind of layer 2 that both inherits the security of layer 1 and provides scaling of general-purpose applications. However, rollups come at a cost: they require some on-chain dataper transaction, and so a blockchain with really high capacity rollups must be able to handle a still quite high amount of data bandwidth. So make this more feasible, we are implementing on scalable data layer technologies, particularly data availability sampling.", "Why proof of stake": "In short:", "Why Casper": "There are currently three major schools of proof of stake consensus algorithm:", "Sharding - or, why do we hate supernodes?": "The main alternative to sharding for layer-1 scaling is the use of supernodes - simply requiring every consensus node to have a powerful server so that it can individually process every transaction. Supernode-based scaling is convenient because it is simple to implement: it works just the same way blockchains do now, except that more software-engineering work is required to build things in a way that is more parallelizable.", "Security models": "It\u2019s commonly assumed that blockchains depend on an \u201chonest majority\u201d assumption for their security: that >=50% of participants will faithfully follow a prescribed protocol, even forgoing opportunities to defect for their own personal interest. In reality, (i) an honest majority model is unrealistic, with participants being \u201clazy\u201d and signing off on blocks without validating them (seethe validator\u2019s dilemma paperand the Bitcoin SPV mining fork) being a very common form of defection, but fortunately (ii) blockchains maintain many or all of their security properties under much harsher models, and it\u2019s really important to preserve those extra guarantees.", "Why are the Casper incentives set the way they are?": "During each epoch, every validator is expected to make an \u201cattestation\u201d, a signature that expresses that validator\u2019s opinion on what the head of the chain is. There is a reward for having one\u2019s attestation included, with four components (called \u201cduties\u201d):", "BLS Signatures": "BLS signatures are used because of their aggregation-friendliness: any two signatures $S_1$ and $S_2$ of a message $M$ signed by keys $k_1$ and $k_2$ (corresponding pubkeys $K_1 = G * k_1$ and $K_2 = G * k_2$ where $G$ is the generator of the elliptic curve) can simply be aggregated by elliptic curve point addition: $S_1 + S_2$, which verifies against the public key $K_1 + K_2$. This allows many thousands of signatures to be aggregated, with the marginal cost of one signature being one bit of data (to express that a particular public key is present in the aggregate signature) and one elliptic curve addition for computation.", "Why 32 ETH validator sizes?": "Any BFT consensus algorithm with accountable fault tolerance (ie. if two conflicting blocks get finalized you can identify which 1/3 of nodes were responsible) must have all validators participate, and furthermore for technical reasons you need two rounds of every validator participating to finalize a message.", "Random sampling": "The seed used for randomness is updated every block by \u201cmixing in\u201d (ie.seed <- xor(seed, new_data)) a value that must be revealed by the proposer of the block. Just like proof of custody subkeys, a validator\u2019s values are all pre-determined once the validator has deposited, third parties cannot compute subkeys but can verify subkeys that are revealed voluntarily (this mechanism is sometimes called RANDAO).", "LMD GHOST fork choice rule": "The beacon chain uses an LMD GHOST fork choice rule.", "The proof of custody game": "For each 9-day period, each validator has the ability to privately generate a \u201cperiod subkey\u201d. The validator\u2019s public key uniquely determines their period subkey for every period, so once a validator has deposited they have no further freedom to choose what their subkeys are. No one can compute any given validator\u2019s subkey except the validator themselves, but once a validator reveals a subkey voluntarily, anyone can verify its correctness (this is all done via BLS magic, and if quantum-safety is required in the future it can be done with hash-based commitments).", "SSZ": "The SimpleSerialize suite contains the following algorithms:", "The validator lifecycle": "A validator deposits by sending a transaction that calls a function on the deposit contract on the eth1 chain (eventually, a way to deposit from inside eth2 will also be added). A deposit specifies:", "Fork mechanism": "TheForkdata structure contains (i) the current \u201cfork ID\u201d, (ii) the previous fork ID and (iii) the switchover slot. The fork ID at the current height influences the valid signatures of all messages; hence, a message signed with one fork ID is invalid to a verification function using any other fork ID.", "Backwards Compatibility": "Although this EIP does not introduce any immediate changes to the current Ethereum mainnet, this EIP lays the groundwork for future backwards incompatibilities through the introduction of the new eth2 consensus mechanism in which Ethereum will be integrated in subsequent phases. To secure this mechanism, users move ether into the beacon chain and additional ether is issued. This EIP is a commitment to this path being canonical, as well as directly informing the future and roadmap of Ethereum mainnet.", "Security Considerations": "Eth2 is a major overhaul of the Ethereum\u2019s core consensus from PoW to a sharded PoS. There are inherent risks in this migration but there is extensive research literature analyzing security and trade-offs.The following only represents a high level selection of the resources available:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- serenity phase 0: The initial phase of Ethereum 2.0, introducing the beacon chain and proof-of-stake consensus without affecting Ethereum mainnet. It lays the foundation for future Ethereum upgrades, including sharding and validator mechanics.\n- magic: A constant value set as 0xef0100 used in the CREATE_DELEGATE instruction.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding."}
{"eip": 6953, "url": "https://eips.ethereum.org/EIPS/eip-6953", "title": "Network Upgrade Activation Triggers", "authors": ["Tim Beiko\u00a0(", "@timbeiko", ")"], "sections": {"EIP-6953: Network Upgrade Activation Triggers": "This EIP outlines the various network upgrade activation triggers used on Ethereum over time, from the proof-of-work era to the first post-merge network upgrade, Shanghai/Capella, across both the execution and consensus layers.", "Exhaustive list of network upgrade activation mechanisms": "This EIP outlines the various network upgrade activation triggers used on Ethereum over time, from the proof-of-work era to the first post-merge network upgrade, Shanghai/Capella, across both the execution and consensus layers.", "Abstract": "This EIP outlines the various network upgrade activation triggers used on Ethereum over time, from the proof-of-work era to the first post-merge network upgrade, Shanghai/Capella, across both the execution and consensus layers.", "Motivation": "This EIP aims to provide users and developers with a single source of truth for understanding the various upgrade activation patterns used throughout Ethereum\u2019s history. It does not aim to be a comprehensive, ongoing record, of upgrades and their activations mechanism. Readers should assume that future upgrades use the mechanism described in thePost Merge Upgradessection, unless this EIP is superseded by another one.", "Specification": "During the proof-of-work era, network upgrades on Ethereum were triggered based on specific block numbers. The following upgrades followed this pattern:", "Proof-of-Work Network Upgrades": "During the proof-of-work era, network upgrades on Ethereum were triggered based on specific block numbers. The following upgrades followed this pattern:", "Beacon Chain Launch": "The Beacon Chain was launched following a set of conditions detailed inEIP-2982. The launch was activated once all the following conditions were met:", "Beacon Chain Upgrades": "Beacon Chain upgrades are activated at specific epochs. The following upgrades followed this pattern:", "The Merge: Paris Upgrade": "The Paris upgrade, the execution layer portion of \u201cThe Merge,\u201d was triggered by a proof-of-work Total Difficulty value of58750000000000000000000, as specified inEIP-3675. Note that the activation of the Bellatrix upgrade on the Beacon Chain was a pre-requisite for the Paris upgrade to successfully activate on the proof-of-work chain.", "Post-Merge Upgrades": "After The Merge, network upgrades are triggered at an epoch on the consensus layer (CL), which ideally maps to an historical roots accumulator boundary (i.e., a multiple of 8192 slots). The epoch\u2019s corresponding timestamp, rather than a block number, is then used on the execution layer (EL) as the activation trigger. The following upgrades followed this pattern:", "Rationale": "Blocks and epochs serve as natural trigger points for upgrades, as they represent the levels at which state transitions occur on Ethereum.", "Blocks and Epochs": "Blocks and epochs serve as natural trigger points for upgrades, as they represent the levels at which state transitions occur on Ethereum.", "Terminal Total Difficulty": "For the Terminal Total Difficulty mechanism, the rationale can be found inEIP-3675.", "Timestamps": "Due to the possibility of missed slots on the Beacon Chain, the execution layer cannot rely solely on block numbers to trigger upgrades in sync with the consensus layer.", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- network upgrade activation triggers: Lists and categorizes the various methods used to trigger network upgrades in Ethereum, including block numbers, total difficulty, and timestamps.\n- slot: The SLOT precompile returns the current slot number as an 8-byte unsigned long in big-endian encoding."}
{"eip": 7840, "url": "https://eips.ethereum.org/EIPS/eip-7840", "title": "2025-04-01", "authors": ["Add blob schedule to EL config files"], "sections": {"EIP-7840: Add blob schedule to EL config files": "Add a new object to client configuration filesblobSchedulewhich lists the\ntarget blob count per block and max blob count per block for each fork.", "Include a per-fork blob parameters in client configuration files": "Add a new object to client configuration filesblobSchedulewhich lists the\ntarget blob count per block and max blob count per block for each fork.", "Abstract": "Add a new object to client configuration filesblobSchedulewhich lists the\ntarget blob count per block and max blob count per block for each fork.", "Motivation": "Extend client configuration files with the objectblobSchedule, which has the\nfollowing shape:", "Specification": "Extend client configuration files with the objectblobSchedule, which has the\nfollowing shape:", "Rationale": "Although maintaining the target and max blob only in the consensus client is\ndesirable, we acknowledge the reality that execution clients need these values\nfor various activities. For example, theeth_feeHistoryRPC method returns a\nfieldblobGasUsedRatiothat does require the max, even though the core\nprotocol doesn\u2019t specifically need such value. Passing this value over the\nengine API every block seem overkill so we believe a configuration value is a\ngood middle ground. Additionally, thebaseFeeUpdateFractionparameter was added to adjust the responsiveness of blob gas pricing per fork.", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "No security considerations found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- basefeeupdatefraction: The fraction by which base fees are updated when updating the blob capacity.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2294, "url": "https://eips.ethereum.org/EIPS/eip-2294", "title": "Explicit bound to Chain ID size", "authors": ["Zainan Victor Zhou\u00a0(", "@xinbenlv", ")", "Alex Beregszaszi\u00a0(", "@axic", ")", "Bryant Eisenbach\u00a0(", "@fubuloubu", ")"], "sections": {"EIP-2294: Explicit bound to Chain ID size": "This EIP informationally defines the \u201cSafe Range\u201d and \u201cMax Range\u201d of ChainId based on a few known restrictions such asEIP-155and major wallet and JSON-RPC representation of ChainId.", "Adds a maximum value to the Chain ID parameter to avoid potential encoding issues that may occur when using large values of the parameter.": "This EIP informationally defines the \u201cSafe Range\u201d and \u201cMax Range\u201d of ChainId based on a few known restrictions such asEIP-155and major wallet and JSON-RPC representation of ChainId.", "Abstract": "This EIP informationally defines the \u201cSafe Range\u201d and \u201cMax Range\u201d of ChainId based on a few known restrictions such asEIP-155and major wallet and JSON-RPC representation of ChainId.", "Motivation": "We declared the following chainID range", "Specification": "We declared the following chainID range", "Rationale": "TheMAX_CHAIN_IDis calculated to avoid overflow when performing uint64 math. For reference, a value of 0 or less is also disallowed.", "Beyond \u201cMax Range\u201d, the EIP-155 will overflow as discussed below": "TheMAX_CHAIN_IDis calculated to avoid overflow when performing uint64 math. For reference, a value of 0 or less is also disallowed.", "Backwards Compatibility": "This EIP introduces a change that affects previous implementations of this feature. However, as of time of writing(2022-10-18) no known chain makes use of a value outside of the suggested bounds, there should not be an issue in adopting this limit on the size of this parameter, therefore the impact should be non-existent.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7870, "url": "https://eips.ethereum.org/EIPS/eip-7870", "title": "Hardware and Bandwidth Recommendations", "authors": ["Parithosh Jayanthi\u00a0(", "@parithosh", ")", "Kevaundray Wedderburn\u00a0(", "@kevaundray", ")", "Josh Rudolf\u00a0(", "@jrudolf", ")", "Dankrad Feist\u00a0(", "@dankrad", ")", "Justin Traglia\u00a0(", "@jtraglia", ")", "Ignacio Hagopian\u00a0(", "@jsign", ")", "George Kadianakis\u00a0(", "@asn-d6", ")", "Fredrik Svantes\u00a0(", "@fredriksvantes", ")", "Carl Beekhuizen\u00a0(", "@carlbeek", ")", "Toni Wahrst\u00e4tter\u00a0(", "@nerolation", ")"], "sections": {"EIP-7870: Hardware and Bandwidth Recommendations": "This proposal specifies hardware and bandwidth recommendations for different types of Ethereum nodes:", "System recommendations for Validators and Full nodes": "This proposal specifies hardware and bandwidth recommendations for different types of Ethereum nodes:", "Abstract": "This proposal specifies hardware and bandwidth recommendations for different types of Ethereum nodes:", "Motivation": "Clear system specifications are crucial for:", "Specification": "Node operators typically run both anExecution Layer (EL)client and aConsensus Layer (CL)client on the same machine. The specifications below assume the combined resource usage of both.", "Roles and Their Recommended Specifications": "Node operators typically run both anExecution Layer (EL)client and aConsensus Layer (CL)client on the same machine. The specifications below assume the combined resource usage of both.", "Rationale": "This EIP is informational and requires no protocol changes. We recommend that future EIPs include an assessment of their impact on these hardware recommendations.", "Storage": "This EIP is informational and requires no protocol changes. We recommend that future EIPs include an assessment of their impact on these hardware recommendations.", "Memory": "This EIP is informational and requires no protocol changes. We recommend that future EIPs include an assessment of their impact on these hardware recommendations.", "CPU": "This EIP is informational and requires no protocol changes. We recommend that future EIPs include an assessment of their impact on these hardware recommendations.", "Bandwidth": "This EIP is informational and requires no protocol changes. We recommend that future EIPs include an assessment of their impact on these hardware recommendations.", "Quick Reference Summary": "This EIP is informational and requires no protocol changes. We recommend that future EIPs include an assessment of their impact on these hardware recommendations.", "Backwards Compatibility": "This EIP is informational and requires no protocol changes. We recommend that future EIPs include an assessment of their impact on these hardware recommendations.", "Security Considerations": "N/A", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- consensus layer: One of four layers of the Ethereum system standards. It ensures that a particular state and history are valid and provides settlement guarantees. It includes both soft forks and hard forks .\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7783, "url": "https://eips.ethereum.org/EIPS/eip-7783", "title": "Add Controlled Gas Limit Increase Strategy", "authors": ["Giulio Rebuffo\u00a0(", "@Giulio2002", ")"], "sections": {"EIP-7783: Add Controlled Gas Limit Increase Strategy": "This proposal describes the introduction in clients of a controlled gas limit increase strategy to determine the gas limit of a specific block and set as default with conservative parameters, while keeping the possibility to change it in the future to a fixed value.", "Adds a controlled gas limit increase strategy.": "This proposal describes the introduction in clients of a controlled gas limit increase strategy to determine the gas limit of a specific block and set as default with conservative parameters, while keeping the possibility to change it in the future to a fixed value.", "Abstract": "The EIP proposes the introduction of a new gas limit management mechanism that automatically increases the block gas limit over time. The incremental growth is controlled by a fixed rate, ensuring predictable network scaling while preventing sudden surges in block sizes. This strategy is meant to be used as a default setting, with the option to switch to a fixed gas limit if needed (or different parameters).", "Motivation": "There are different approaches to implement a controlled gas limit increase strategy. The following are three possible strategies that can be used:", "Predictable Gas Limit Growth": "There are different approaches to implement a controlled gas limit increase strategy. The following are three possible strategies that can be used:", "Gradual Increase with Deactivation Safeguard": "There are different approaches to implement a controlled gas limit increase strategy. The following are three possible strategies that can be used:", "Specification": "There are different approaches to implement a controlled gas limit increase strategy. The following are three possible strategies that can be used:", "Linear Gas Limit Increase Strategy": "Add a new \u201cGas Limit\u201d selection strategy that takes in Block NumberNand spits out the Gas LimitGLfor that block. The strategy is as follows:", "Stepwise Linear Gas Limit Increase Strategy": "Add a new \u201cGas Limit\u201d selection strategy that takes in Block NumberNand spits out the Gas LimitGLfor that block. The strategy is as follows:", "Exponential Gas Limit Increase Strategy": "Add a new \u201cGas Limit\u201d selection strategy that takes in Block NumberNand spits out the Gas LimitGLfor that block. The strategy is as follows:", "Rationale": "No Hard Fork Required", "Predictable Growth": "No Hard Fork Required", "Controlled Limit with Deactivation Block": "No Hard Fork Required", "Backwards Compatibility": "No Hard Fork Required", "Security Considerations": "Copyright and related rights waived via CC0 1.0 Universal.", "Copyright": "Copyright and related rights waived via CC0 1.0 Universal.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- controlled gas limit increase strategy: Introduces a controlled gas limit increase mechanism, gradually raising the gas limit by a fixed rate to scale network capacity predictably.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 7790, "url": "https://eips.ethereum.org/EIPS/eip-7790", "title": "Controlled Gas Limit Increase Guidelines", "authors": ["Giulio Rebuffo\u00a0(", "@Giulio2002", ")", "Ben Adams\u00a0(", "@benaadams", ")"], "sections": {"EIP-7790: Controlled Gas Limit Increase Guidelines": "This proposal specifies specific parameters for the controlled gas limit increase strategy outlined inEIP-7783, including block number to start the increase, initial gas limit, rate of increase per block, and gas limit cap.", "Suggests specific parameters for the controlled gas limit increase strategy introduced.": "This proposal specifies specific parameters for the controlled gas limit increase strategy outlined inEIP-7783, including block number to start the increase, initial gas limit, rate of increase per block, and gas limit cap.", "Abstract": "This proposal provides parameter recommendations for implementing the controlled gas limit increase strategy inEIP-7783.", "Motivation": "The motivation for this proposal is to define practical and balanced parameters for Ethereum\u2019s gas limit increase strategy to achieve predictable and stable network scaling. WhileEIP-7783defines the mechanism, there is still a need to establish the values needed for its implementation based on real-world conditions.", "Specification": "The parameters for the controlled gas limit increase strategy are:", "Proposed Parameters": "The parameters for the controlled gas limit increase strategy are:", "Rationale": "The chosen block number (21792420) provides ample time to discuss and implement the gas limit increase strategy, additionally, it allows to happen with or slightly before the pectra hard fork.", "Starting Block Number": "The chosen block number (21792420) provides ample time to discuss and implement the gas limit increase strategy, additionally, it allows to happen with or slightly before the pectra hard fork.", "Initial Gas Limit": "The initial gas limit is set to match the current default gas limit of30_000_000.", "Rate of Increase": "A rate of6gas per block is chosen to triple the gas limit in approximately 47 months, which is equivalent to almost 2 years.", "Gas Limit Cap": "These parameters do not require any protocol changes or hard forks. They are fully backward compatible with the current Ethereum network architecture.", "Backwards Compatibility": "These parameters do not require any protocol changes or hard forks. They are fully backward compatible with the current Ethereum network architecture.", "Security Considerations": "Copyright and related rights waived via CC0 1.0 Universal.", "Copyright": "Copyright and related rights waived via CC0 1.0 Universal.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- gas limit cap: Sets an in-protocol cap for the gas limit at 30,000,000, preventing block proposers from increasing the gas limit beyond this threshold.\n- controlled gas limit increase strategy: Introduces a controlled gas limit increase mechanism, gradually raising the gas limit by a fixed rate to scale network capacity predictably.\n- controlled gas limit increase guidelines: Provides specific parameters for a controlled and gradual increase in the Ethereum gas limit, aiming to ensure stable and predictable network scalability by outlining the start block, rate of increase, and gas cap."}
{"eip": 7892, "url": "https://eips.ethereum.org/EIPS/eip-7892", "title": "Blob Parameter Only Hardforks", "authors": ["Mark Mackey\u00a0(", "@ethDreamer", ")"], "sections": {"EIP-7892: Blob Parameter Only Hardforks": "This EIP introducesBlob Parameter Only (BPO) Hardforks, a lightweight mechanism for incrementally scaling Ethereum\u2019s blob capacity through targeted hard forks that modify only blob-related parameters:blob target,blob limit, andbaseFeeUpdateFraction. Unlike traditional hard forks, which require extensive coordination and introduce broader protocol changes, BPO forks enable rapid, low-overhead scaling of blob capacity in response toreal-world demand and network conditions.", "Defines a mechanism for scaling Ethereum\u2019s blob capacity via specialized hard forks that modify only blob-related parameters.": "This EIP introducesBlob Parameter Only (BPO) Hardforks, a lightweight mechanism for incrementally scaling Ethereum\u2019s blob capacity through targeted hard forks that modify only blob-related parameters:blob target,blob limit, andbaseFeeUpdateFraction. Unlike traditional hard forks, which require extensive coordination and introduce broader protocol changes, BPO forks enable rapid, low-overhead scaling of blob capacity in response toreal-world demand and network conditions.", "Abstract": "This EIP introducesBlob Parameter Only (BPO) Hardforks, a lightweight mechanism for incrementally scaling Ethereum\u2019s blob capacity through targeted hard forks that modify only blob-related parameters:blob target,blob limit, andbaseFeeUpdateFraction. Unlike traditional hard forks, which require extensive coordination and introduce broader protocol changes, BPO forks enable rapid, low-overhead scaling of blob capacity in response toreal-world demand and network conditions.", "Motivation": "Ethereum\u2019s scaling strategy relies on Layer 2 (L2) solutions for transaction execution while using Ethereum as adata availability (DA) layer. However, the demand for DA has increased rapidly, and the current approach of only modifying blob parameters in large, infrequent hard forks isnot agile enoughto keep up with L2 growth.", "Specification": "BPO forks are a special class of hard fork whichonly modifies any of the followingblob-related parameters:", "Requirements": "Full hard forks require extensive coordination, testing, and implementation changes beyond parameter adjustments. For example, in Lighthouse, a typical hard fork implementation requires thousands of lines of boilerplate before any protocol changes occur. BPO forks streamline this process by avoiding the need for this boilerplate code.", "Rationale": "Full hard forks require extensive coordination, testing, and implementation changes beyond parameter adjustments. For example, in Lighthouse, a typical hard fork implementation requires thousands of lines of boilerplate before any protocol changes occur. BPO forks streamline this process by avoiding the need for this boilerplate code.", "Why not just use regular hardforks?": "Full hard forks require extensive coordination, testing, and implementation changes beyond parameter adjustments. For example, in Lighthouse, a typical hard fork implementation requires thousands of lines of boilerplate before any protocol changes occur. BPO forks streamline this process by avoiding the need for this boilerplate code.", "Why specify parameters in the node configuration instead of code?": "Allowing blob parameters to be configured externally enables rapid experimentation, testing, and adjustments without requiring code changes across client implementations. Testing teams can investigate different parameters with minimal involvement from client implementers.", "Why not create an on-chain voting mechanism for blob parameters?": "BPO forks introduce no backwards compatibility concerns.", "Backwards Compatibility": "BPO forks introduce no backwards compatibility concerns.", "Security Considerations": "No security risks have been identified.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- blob parameter only (bpo): A mechanism for scaling Ethereum's blob capacity through targeted hard forks that modify only blob-related parameters.\n- blob target: The maximum amount of data allowed in blobs on a given block.\n- blob limit: The total number of blocks that can be stored as blobs before the network is full."}
{"eip": 1470, "url": "https://eips.ethereum.org/EIPS/eip-1470", "title": "Smart Contract Weakness Classification (SWC)", "authors": ["Gerhard Wagner\u00a0(", "@thec00n", ")"], "sections": {"EIP-1470: Smart Contract Weakness Classification (SWC)": "This EIP proposes a classification scheme for security weaknesses in Ethereum smart contracts.", "": "This EIP proposes a classification scheme for security weaknesses in Ethereum smart contracts.", "Simple Summary": "This EIP proposes a classification scheme for security weaknesses in Ethereum smart contracts.", "Abstract": "The SWC is a smart contract specific software weakness classification scheme for developers, tool vendors and security practitioners. The SWC is loosely aligned to the terminologies and structure used in theCommon Weakness Enumeration - CWEscheme while overlaying a wide range of weakness variants that are specific to smart contracts.", "Motivation": "In the software security industry, it is a widely accepted practice to use a common terminology and to classify security related bugs and errors with a standardized scheme. While this has not stopped vulnerabilities from appearing in software, it has helped communities focusing on web applications, network protocols, IOT devices and various other fields to educate users and developers to understand the nature of security related issues in their software. It has also allowed the security community to quickly understand vulnerabilities that occur in production systems to perform root cause analysis or triage findings from various security analysis sources. In recent years various organizations and companies also published vulnerability data to find the most widespread security issues based on collected vulnerability data. Two examples that are widely used and referred to are theSANS TOP 25 Most Dangerous Software Errorsand theOWASP TOP 10. None of those publications would have been possible without a common classification scheme.", "Rationale": "While recognizing the current gap, the SWC does not aim to reinvent the wheel in regards to classification of security weaknesses. It rather proposes to build on top of what has worked well in other parts of the software security community -  specifically the Common Weakness Enumeration (CWE), a list of software vulnerability types that stands out in terms of adoption and breadth of coverage. While CWE does not describe any weaknesses specific to smart contracts, it does describe related weaknesses at higher abstraction layers. This EIP proposes to create smart contract specific variants while linking back to the larger spectrum of software errors and mistakes listed in the CWE that different platforms and technologies have in common.", "Specification": "Before discussing the SWC specification it is important to describe the terminology used:", "Implementation": "The Smart Contract Weakness Classification registry located in thisGitHub repositoryuses the SWC scheme proposed in this EIP. A GitHub Pages rendered version is also availablehere.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- smart contract weakness classification (swc): Introduces a classification scheme for security weaknesses in Ethereum smart contracts, aligned with the Common Weakness Enumeration (CWE) scheme.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks.\n- from: Commitments to properties computed from the original RLP representation."}
{"eip": 2069, "url": "https://eips.ethereum.org/EIPS/eip-2069", "title": "Recommendation for using YAML ABI in ERCs/EIPs", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-2069: Recommendation for using YAML ABI in ERCs/EIPs": "Recommendation for including contract ABI descriptions in EIPs and ERCs as YAML.", "": "Recommendation for including contract ABI descriptions in EIPs and ERCs as YAML.", "Simple Summary": "Recommendation for including contract ABI descriptions in EIPs and ERCs as YAML.", "Motivation": "In the past, most ERCs/EIPs included an ABI description purely as a Solidity contract and/or interface. This has several drawbacks:", "Specification": "TheStandard Contract ABIis usually represented as a JSON object.  This works well and several tools \u2013 including compilers and clients \u2013 support it to handle data encoding.", "Rationale": "The aim was to chose a representation which is well supported by tools and supports comments. While inventing a more concise description language seems like a good idea, it felt as an unnecessary layer of complexity.", "Backwards Compatibility": "This has no effect on backwards compatibility.", "Test Cases": "TBA", "Implementation": "yamabiis a Javascript tool to convert between the above YAML and the more widely used JSON format.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- yaml abi: Recommends using YAML for ABI descriptions in EIPs and ERCs, allowing comments and improving readability compared to JSON.\n- json: A format chosen for its ubiquity, machine and human readability, and a standardized canonical form via RFC-8785.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
{"eip": 2458, "url": "https://eips.ethereum.org/EIPS/eip-2458", "title": "Updates and Updated-by Header", "authors": ["Edson Ayllon\u00a0(", "@edsonayllon", ")"], "sections": {"EIP-2458: Updates and Updated-by Header": "Adds EIP header optionsupdatesandupdated-byto frontmatter ofactiveEIPs for use as needed.", "": "Adds EIP header optionsupdatesandupdated-byto frontmatter ofactiveEIPs for use as needed.", "Simple Summary": "Adds EIP header optionsupdatesandupdated-byto frontmatter ofactiveEIPs for use as needed.", "Abstract": "EIP headersupdatesandupdated-byare used for updatingactiveEIPs. This is to make the improvement process of EIPs more modular, and have updates to existingactiveEIPs receive similar exposures to EIPs which replace existingfinalEIPs.", "Motivation": "Currently, EIP1 specifies EIP headers:updated,replaces, andsuperseded-by. Headersreplacesandsuperseded-byindicates when an entire EIP is being replaced by another EIP, indicating when an EIP is now historical, and is updated by a new standard.", "Specification": "updated-byis reserved for EIPs inactivestatus. For an EIP in statusactive, updates to that EIP, which update the headerupdated, should be started by opening a new EIP to start vetting for that update. When anactiveEIP receives a new entry to headerupdated, an associatedupdated-byEIP listing should be included, where that newly listed EIP has reachedfinalstatus.", "updated-by": "updated-byis reserved for EIPs inactivestatus. For an EIP in statusactive, updates to that EIP, which update the headerupdated, should be started by opening a new EIP to start vetting for that update. When anactiveEIP receives a new entry to headerupdated, an associatedupdated-byEIP listing should be included, where that newly listed EIP has reachedfinalstatus.", "updates": "updatesis reserved for EIPs updating EIPs inactivestatus. An EIP listed asupdatesis implied to also berequires; onlyupdatesis needed for those EIP listings. Having an EIP listingupdatesdoes not necessarily mean that referenced EIP must reference back with anupdated-bylisting.", "Rationale": "updatesandupdated-byapply only to EIPs inactivestatus as updates to EIPs infinalstatus are already handled by EIP headerssuperseded-byandreplaces.", "Backwards Compatibility": "These EIP headers are optional and do not introduce compatibility issues.", "Implementation": "An implementation is adding a header option.", "Security Considerations": "This standard is informational and does not introduce technical security issues.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip", "context": "Related Ethereum Concepts:\n- updates and updated-by header: Adds the updates and updated-by headers to track updates to active EIPs and indicate which EIPs modify other EIPs.\n- n: The fixed capacity imposed by existing List types, which can lead to inefficient hashing and unnecessary bounds checks."}
