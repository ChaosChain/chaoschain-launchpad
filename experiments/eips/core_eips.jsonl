{"eip": 2, "url": "https://eips.ethereum.org/EIPS/eip-2", "title": "Homestead Hard-fork Changes", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-2: Homestead Hard-fork Changes": "Homestead.", "": "Homestead.", "Meta reference": "Homestead.", "Parameters": "Ifblock.number >= HOMESTEAD_FORK_BLKNUM, do the following:", "Specification": "Ifblock.number >= HOMESTEAD_FORK_BLKNUM, do the following:", "Rationale": "Currently, there is an excess incentive to create contracts via transactions, where the cost is 21,000, rather than contracts, where the cost is 32,000. Additionally, with the help of suicide refunds, it is currently possible to make a simple ether value transfer using only 11,664 gas; the code for doing this is as follows:", "Implementation": "This is implemented in Python here:", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 5, "url": "https://eips.ethereum.org/EIPS/eip-5", "title": "Gas Usage for `RETURN` and `CALL*`", "authors": ["Christian Reitwiessner\u00a0<", "c@ethdev.com", ">"], "sections": {"EIP-5: Gas Usage for `RETURN` and `CALL*`": "This EIP makes it possible to call functions that return strings and other dynamically-sized arrays.\nCurrently, when another contract / function is called from inside the Ethereum Virtual Machine,\nthe size of the output has to be specified in advance. It is of course possible to give a larger\nsize, but gas also has to be paid for memory that is not written to, which makes returning\ndynamically-sized data both costly and inflexible to the extent that it is actually unusable.", "": "This EIP makes it possible to call functions that return strings and other dynamically-sized arrays.\nCurrently, when another contract / function is called from inside the Ethereum Virtual Machine,\nthe size of the output has to be specified in advance. It is of course possible to give a larger\nsize, but gas also has to be paid for memory that is not written to, which makes returning\ndynamically-sized data both costly and inflexible to the extent that it is actually unusable.", "Abstract": "This EIP makes it possible to call functions that return strings and other dynamically-sized arrays.\nCurrently, when another contract / function is called from inside the Ethereum Virtual Machine,\nthe size of the output has to be specified in advance. It is of course possible to give a larger\nsize, but gas also has to be paid for memory that is not written to, which makes returning\ndynamically-sized data both costly and inflexible to the extent that it is actually unusable.", "Specification": "The gas and memory semantics forCALL,CALLCODEandDELEGATECALL(called later asCALL*)\nare changed in the following way (CREATEdoes not write to memory and is thus unaffected):", "Motivation": "In general, it is good practise to reserve a certain memory area for the output of a call,\nbecause letting a subroutine write to arbitrary areas in memory might be dangerous. On the\nother hand, it is often hard to know the output size of a call prior to performing the call:\nThe data could be in the storage of another contract which is generally inaccessible and\ndetermining its size would require another call to that contract.", "Rationale": "This way of dealing with the problem requires a minimal change to the Ethereum Virtual Machine.\nOther means of achieving a similar goal would have changed the opcodes themselves or\nthe number of their arguments. Another possibility would have been to only change the\ngas mechanics ifoutput_sizeis equal to2**256-1. Since the main difficulty in the\nimplementation is that memory has to be enlarged at two points in the code aroundCALL,\nthis would not have been a simplification.", "Backwards Compatibility": "This proposal changes the semantics of contracts because contracts can access the gas counter\nand the size of memory.", "Implementation": "VM implementers should take care not to grow the memory until the end of the call and after a check that sufficient\ngas is still available. Typical uses of the EIP include \u201creserving\u201d2**256-1bytes of memory for the output.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7, "url": "https://eips.ethereum.org/EIPS/eip-7", "title": "DELEGATECALL", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-7: DELEGATECALL": "Homestead", "": "Homestead", "Hard Fork": "Homestead", "Parameters": "Add a new opcode,DELEGATECALLat0xf4, which is similar in idea toCALLCODE, except that it propagates the sender and value from the parent scope to the child scope, i.e. the call created has the same sender and value as the original call.", "Overview": "Add a new opcode,DELEGATECALLat0xf4, which is similar in idea toCALLCODE, except that it propagates the sender and value from the parent scope to the child scope, i.e. the call created has the same sender and value as the original call.", "Specification": "DELEGATECALL:0xf4, takes 6 operands:", "Rationale": "Propagating the sender and value from the parent scope to the child scope makes it much easier for a contract to store another address as a mutable source of code and \u2018\u2018pass through\u2019\u2019 calls to it, as the child code would execute in essentially the same environment (except for reduced gas and increased callstack depth) as the parent.", "Possible arguments against": "Please cite this document as:", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 100, "url": "https://eips.ethereum.org/EIPS/eip-100", "title": "Change difficulty adjustment to target mean block time including uncles", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-100: Change difficulty adjustment to target mean block time including uncles": "Currently, the formula to compute the difficulty of a block includes the following logic:", "": "Currently, the formula to compute the difficulty of a block includes the following logic:", "Specification": "Currently, the formula to compute the difficulty of a block includes the following logic:", "Rationale": "This new formula ensures that the difficulty adjustment algorithm targets a constant average rate of blocks produced including uncles, and so ensures a highly predictable issuance rate that cannot be manipulated upward by manipulating the uncle rate. A formula that accounts for the exact number of included uncles:", "References": "Please cite this document as:", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 140, "url": "https://eips.ethereum.org/EIPS/eip-140", "title": "REVERT instruction", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Nikolai Mushegian\u00a0<", "nikolai@nexusdev.us", ">"], "sections": {"EIP-140: REVERT instruction": "TheREVERTinstruction provides a way to stop execution and revert state changes, without consuming all provided gas and with the ability to return a reason.", "": "TheREVERTinstruction provides a way to stop execution and revert state changes, without consuming all provided gas and with the ability to return a reason.", "Simple Summary": "TheREVERTinstruction provides a way to stop execution and revert state changes, without consuming all provided gas and with the ability to return a reason.", "Abstract": "TheREVERTinstruction will stop execution, roll back all state changes done so far and provide a pointer to a memory section, which can be interpreted as an error code or message. While doing so, it will not consume all the remaining gas.", "Motivation": "Currently this is not possible. There are two practical ways to revert a transaction from within a contract: running out of gas or executing an invalid instruction. Both of these options will consume all remaining gas. Additionally, reverting an EVM execution means that all changes, including LOGs, are lost and there is no way to convey a reason for aborting an EVM execution.", "Specification": "On blocks withblock.number >= BYZANTIUM_FORK_BLKNUM, theREVERTinstruction is introduced at0xfd. It expects two stack items, the top item is thememory_offsetfollowed bymemory_length. It does not produce any stack elements because it stops execution.", "Backwards Compatibility": "This change has no effect on contracts created in the past unless they contain0xfdas an instruction.", "Test Cases": "should:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 141, "url": "https://eips.ethereum.org/EIPS/eip-141", "title": "Designated invalid EVM instruction", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-141: Designated invalid EVM instruction": "An instruction is designated to remain as an invalid instruction.", "": "An instruction is designated to remain as an invalid instruction.", "Abstract": "An instruction is designated to remain as an invalid instruction.", "Motivation": "The invalid instruction can be used as a distinct reason to abort execution.", "Specification": "The opcode0xfeis theINVALIDinstruction. It can be used to abort the execution (i.e. duplicates as anABORTinstruction).", "Backwards Compatibility": "This instruction was never used and therefore has no effect on past contracts.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 145, "url": "https://eips.ethereum.org/EIPS/eip-145", "title": "Bitwise shifting instructions in EVM", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")"], "sections": {"EIP-145: Bitwise shifting instructions in EVM": "Native bitwise shifting instructions are introduced, which are more efficient processing wise on the host and are cheaper to use by a contract.", "To Provide native bitwise shifting with cost on par with other arithmetic operations.": "Native bitwise shifting instructions are introduced, which are more efficient processing wise on the host and are cheaper to use by a contract.", "Abstract": "Native bitwise shifting instructions are introduced, which are more efficient processing wise on the host and are cheaper to use by a contract.", "Motivation": "EVM is lacking bitwise shifting operators, but supports other logical and arithmetic operators. Shift operations can be implemented via arithmetic operators, but that has a higher cost and requires more processing time from the host. ImplementingSHLandSHRusing arithmetic cost each 35 gas, while the proposed instructions take 3 gas.", "Specification": "The following instructions are introduced:", "0x1b:SHL(shift left)": "TheSHLinstruction (shift left) pops 2 values from the stack, firstarg1and thenarg2, and pushes on the stackarg2shifted to the left byarg1number of bits. The result is equal to", "0x1c:SHR(logical shift right)": "TheSHRinstruction (logical shift right) pops 2 values from the stack, firstarg1and thenarg2, and pushes on the stackarg2shifted to the right byarg1number of bits with zero fill. The result is equal to", "0x1d:SAR(arithmetic shift right)": "TheSARinstruction (arithmetic shift right) pops 2 values from the stack, firstarg1and thenarg2, and pushes on the stackarg2shifted to the right byarg1number of bits with sign extension. The result is equal to", "Rationale": "Instruction operands were chosen to fit the more natural use case of shifting a value already on the stack. This means the operand order is swapped compared to most arithmetic instructions.", "Backwards Compatibility": "The newly introduced instructions have no effect on bytecode created in the past.", "Test Cases": "Client support:", "SHL(shift left)": "Client support:", "SHR(logical shift right)": "Client support:", "SAR(arithmetic shift right)": "Client support:", "Implementation": "Client support:", "Tests": "Sources:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 150, "url": "https://eips.ethereum.org/EIPS/eip-150", "title": "Gas cost changes for IO-heavy operations", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-150: Gas cost changes for IO-heavy operations": "Tangerine Whistle.", "": "Tangerine Whistle.", "Meta reference": "Tangerine Whistle.", "Parameters": "Ifblock.number >= FORK_BLKNUM, then:", "Specification": "Ifblock.number >= FORK_BLKNUM, then:", "Rationale": "Recent denial-of-service attacks have shown that opcodes that read the state tree are under-priced relative to other opcodes. There are software changes that have been made, are being made and can be made in order to mitigate the situation; however, the fact will remain that such opcodes will be by a substantial margin the easiest known mechanism to degrade network performance via transaction spam. The concern arises because it takes a long time to read from disk, and is additionally a risk to future sharding proposals as the \u201cattack transactions\u201d that have so far been most successful in degrading network performance would also require tens of megabytes to provide Merkle proofs for. This EIP increases the cost of storage reading opcodes to address this concern. The costs have been derived from an updated version of the calculation table used to generate the 1.0 gas costs: https://docs.google.com/spreadsheets/d/15wghZr-Z6sRSMdmRmhls9dVXTOpxKy8Y64oy9MvDZEQ/edit#gid=0; the rules attempt to target a limit of 8 MB of data that needs to be read in order to process a block, and include an estimate of 500 bytes for a Merkle proof for SLOAD and 1000 for an account.", "References": "Please cite this document as:", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 152, "url": "https://eips.ethereum.org/EIPS/eip-152", "title": "Add BLAKE2 compression function `F` precompile", "authors": ["Tjaden Hess\u00a0<", "tah83@cornell.edu", ">", "Matt Luongo\u00a0(", "@mhluongo", ")", "Piotr Dyraga\u00a0(", "@pdyraga", ")", "James Hancock\u00a0(", "@MadeOfTin", ")"], "sections": {"EIP-152: Add BLAKE2 compression function `F` precompile": "This EIP will enable the BLAKE2b hash function and other higher-round 64-bit BLAKE2 variants to run cheaply on the EVM, allowing easier interoperability between Ethereum and Zcash as well as other Equihash-based PoW coins.", "": "This EIP will enable the BLAKE2b hash function and other higher-round 64-bit BLAKE2 variants to run cheaply on the EVM, allowing easier interoperability between Ethereum and Zcash as well as other Equihash-based PoW coins.", "Simple Summary": "This EIP will enable the BLAKE2b hash function and other higher-round 64-bit BLAKE2 variants to run cheaply on the EVM, allowing easier interoperability between Ethereum and Zcash as well as other Equihash-based PoW coins.", "Abstract": "This EIP introduces a new precompiled contract which implements the compression functionFused in the BLAKE2 cryptographic hashing algorithm, for the purpose of allowing interoperability between the EVM and Zcash, as well as introducing more flexible cryptographic hash primitives to the EVM.", "Motivation": "Besides being a useful cryptographic hash function and SHA3 finalist, BLAKE2 allows for efficient verification of the Equihash PoW used in Zcash, making a BTC Relay - style SPV client possible on Ethereum. A single verification of an Equihash PoW verification requires 512 iterations of the hash function, making verification of Zcash block headers prohibitively expensive if a Solidity implementation of BLAKE2 is used.", "Specification": "We propose adding a precompiled contract at address0x09wrapping theBLAKE2Fcompression function.", "Example Usage in Solidity": "The precompile can be wrapped easily in Solidity to provide a more development-friendly interface toF.", "Gas costs and benchmarks": "Each operation will costGFROUND * roundsgas, whereGFROUND = 1. Detailed benchmarks are presented in the benchmarks appendix section.", "Rationale": "BLAKE2 is an excellent candidate for precompilation. BLAKE2 is heavily optimized for modern 64-bit CPUs, specifically utilizing 24 and 63-bit rotations to allow parallelism through SIMD instructions and little-endian arithmetic. These characteristics provide exceptional speed on native CPUs: 3.08 cycles per byte, or 1 gibibyte per second on an Intel i5.", "Backwards Compatibility": "There is very little risk of breaking backwards-compatibility with this EIP, the sole issue being if someone were to build a contract relying on the address at0x09being empty. The likelihood of this is low, and should specific instances arise, the address could be chosen to be any arbitrary value with negligible risk of collision.", "Test Cases": "An initial implementation of theFfunction in Go, adapted from the standard library, can be found in ourGolang BLAKE2 library fork. There\u2019s also an implementation of the precompile in our fork ofgo-ethereum.", "Implementation": "An initial implementation of theFfunction in Go, adapted from the standard library, can be found in ourGolang BLAKE2 library fork. There\u2019s also an implementation of the precompile in our fork ofgo-ethereum.", "References": "For reference, further discussion on this EIP also occurred in the following PRs and issues", "Appendix - benchmarks": "Assuming ecRecover precompile is perfectly priced, we executed a set of benchmarks comparing Blake2b F compression function precompile with ecRecover precompile. For benchmarks, we used 3.1 GHz Intel Core i7 64-bit machine.", "12 rounds": "An average gas price of F precompile call with 12 rounds compared to ecRecover should have been6.74153and it gives0.5618gas per round.", "1200 rounds": "An average gas price of F precompile call with 1200 rounds compared to ecRecover should have been436.1288and it gives0.3634gas per round.", "1 round": "An average gas price of F precompile call with 1 round compared to ecRecover should have been2.431701. However, in this scenario the call cost would totally overshadow the dynamic cost anyway.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 155, "url": "https://eips.ethereum.org/EIPS/eip-155", "title": "Simple replay attack protection", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-155: Simple replay attack protection": "Spurious Dragon", "": "Spurious Dragon", "Hard fork": "Spurious Dragon", "Parameters": "Ifblock.number >= FORK_BLKNUMandCHAIN_IDis available, then when computing the hash of a transaction for the purposes of signing, instead of hashing only six rlp encoded elements(nonce, gasprice, startgas, to, value, data), youSHOULDhash nine rlp encoded elements(nonce, gasprice, startgas, to, value, data, chainid, 0, 0).  If you do, then thevof the signatureMUSTbe set to{0,1} + CHAIN_ID * 2 + 35where{0,1}is the parity of theyvalue of the curve point for whichris the x-value in the secp256k1 signing process.  If you choose to only hash 6 values, thenvcontinues to be set to{0,1} + 27as previously.", "Specification": "Ifblock.number >= FORK_BLKNUMandCHAIN_IDis available, then when computing the hash of a transaction for the purposes of signing, instead of hashing only six rlp encoded elements(nonce, gasprice, startgas, to, value, data), youSHOULDhash nine rlp encoded elements(nonce, gasprice, startgas, to, value, data, chainid, 0, 0).  If you do, then thevof the signatureMUSTbe set to{0,1} + CHAIN_ID * 2 + 35where{0,1}is the parity of theyvalue of the curve point for whichris the x-value in the secp256k1 signing process.  If you choose to only hash 6 values, thenvcontinues to be set to{0,1} + 27as previously.", "Example": "Consider a transaction withnonce = 9,gasprice = 20 * 10**9,startgas = 21000,to = 0x3535353535353535353535353535353535353535,value = 10**18,data=''(empty).", "Rationale": "This would provide a way to send transactions that work on Ethereum without working on ETC or the Morden testnet. ETC is encouraged to adopt this EIP but replacingCHAIN_IDwith a different value, and all future testnets, consortium chains and alt-etherea are encouraged to adopt this EIP replacingCHAIN_IDwith a unique value.", "List of Chain ID\u2019s:": "Find more chain ID\u2019s onchainid.networkand contribute toethereum-lists/chains.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 158, "url": "https://eips.ethereum.org/EIPS/eip-158", "title": "State clearing", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-158: State clearing": "For all blocks whereblock.number >= FORK_BLKNUM(TBA):", "": "For all blocks whereblock.number >= FORK_BLKNUM(TBA):", "Specification": "For all blocks whereblock.number >= FORK_BLKNUM(TBA):", "Specification (1c)": "Do not implement point 2 above (ie. no new empty accounts can be created, but existing ones are not automatically destroyed unless their state is actuallychanged). Instead, during each block starting from (and including) N and ending when there are no null accounts left, select the 1000 null accounts that are left-most in order of sha3(address), and delete them (ordering by hash is necessary so as to allow the accounts to be easily found by iterating the tree).", "Rationale": "This removes a large number of empty accounts that have been put in the state at very low cost due to flaws in earlier versions of the Ethereum protocol, thereby greatly reducing state size and hence both reducing the hard disk load of a full client and reducing the time for a fast sync. Additionally, it simplifies the protocol in the long term, as once all \u201cempty\u201d objects are cleared out there is no longer any meaningful distinction between an account being empty and being nonexistent, and indeed one can simply view nonexistence as a compact representation of emptiness.", "References": "Please cite this document as:", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 160, "url": "https://eips.ethereum.org/EIPS/eip-160", "title": "EXP cost increase", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-160: EXP cost increase": "Spurious Dragon", "": "Spurious Dragon", "Hard fork": "Spurious Dragon", "Parameters": "Ifblock.number >= FORK_BLKNUM, increase the gas cost of EXP from 10 + 10 per byte in the exponent to 10 + 50 per byte in the exponent.", "Specification": "Ifblock.number >= FORK_BLKNUM, increase the gas cost of EXP from 10 + 10 per byte in the exponent to 10 + 50 per byte in the exponent.", "Rationale": "Benchmarks suggest that EXP is currently underpriced by a factor of about 4\u20138.", "References": "Please cite this document as:", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 161, "url": "https://eips.ethereum.org/EIPS/eip-161", "title": "State trie clearing (invariant-preserving alternative)", "authors": ["Gavin Wood\u00a0(", "@gavofyork", ")"], "sections": {"EIP-161: State trie clearing (invariant-preserving alternative)": "Spurious Dragon", "": "Spurious Dragon", "Hard fork": "Spurious Dragon", "Parameters": "a. Account creation transactions and theCREATEoperation SHALL, prior to the execution of the initialisation code,incrementthenonceover and above its normal starting value byone(for normal networks, this will be simply 1, however test-nets with non-zero default starting nonces will be different).", "Specification": "a. Account creation transactions and theCREATEoperation SHALL, prior to the execution of the initialisation code,incrementthenonceover and above its normal starting value byone(for normal networks, this will be simply 1, however test-nets with non-zero default starting nonces will be different).", "Rationale": "Same as #158 except that several edge cases are avoided since we do not break invariants:", "Addendum (2017-08-15)": "On 2016-11-24, a consensus bug occurred due to two implementations having different behavior in the case of state reverts.[3] The specification was amended to clarify that empty account deletions are reverted when the state is reverted.", "References": "Please cite this document as:", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 170, "url": "https://eips.ethereum.org/EIPS/eip-170", "title": "Contract code size limit", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-170: Contract code size limit": "Spurious Dragon", "": "Spurious Dragon", "Hard fork": "Spurious Dragon", "Parameters": "Ifblock.number >= FORK_BLKNUM, then if contract creation initialization returns data with length ofmore thanMAX_CODE_SIZEbytes, contract creation fails with an out of gas error.", "Specification": "Ifblock.number >= FORK_BLKNUM, then if contract creation initialization returns data with length ofmore thanMAX_CODE_SIZEbytes, contract creation fails with an out of gas error.", "Rationale": "Currently, there remains one slight quadratic vulnerability in Ethereum: when a contract is called, even though the call takes a constant amount of gas, the call can trigger O(n) cost in terms of reading the code from disk, preprocessing the code for VM execution, and also adding O(n) data to the Merkle proof for the block\u2019s proof-of-validity. At current gas levels, this is acceptable even if suboptimal. At the higher gas levels that could be triggered in the future, possibly very soon due to dynamic gas limit rules, this would become a greater concern\u2014not nearly as serious as recent denial of service attacks, but still inconvenient especially for future light clients verifying proofs of validity or invalidity. The solution is to put a hard cap on the size of an object that can be saved to the blockchain, and do so non-disruptively by setting the cap at a value slightly higher than what is feasible with current gas limits.", "References": "Please cite this document as:", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 196, "url": "https://eips.ethereum.org/EIPS/eip-196", "title": "Precompiled contracts for addition and scalar multiplication on the elliptic curve alt_bn128", "authors": ["Christian Reitwiessner\u00a0<", "chris@ethereum.org", ">"], "sections": {"EIP-196: Precompiled contracts for addition and scalar multiplication on the elliptic curve alt_bn128": "Precompiled contracts for elliptic curve operations are required in order to perform zkSNARK verification within the block gas limit.", "": "Precompiled contracts for elliptic curve operations are required in order to perform zkSNARK verification within the block gas limit.", "Simple Summary": "Precompiled contracts for elliptic curve operations are required in order to perform zkSNARK verification within the block gas limit.", "Abstract": "This EIP suggests to add precompiled contracts for addition and scalar multiplication on a specific pairing-friendly elliptic curve. This can in turn be combined withEIP-197to verify zkSNARKs in Ethereum smart contracts. The general benefit of zkSNARKs for Ethereum is that it will increase the privacy for users (because of the Zero-Knowledge property) and might also be a scalability solution (because of the succinctness and efficient verifiability property).", "Motivation": "Current smart contract executions on Ethereum are fully transparent, which makes them unsuitable for several use-cases that involve private information like the location, identity or history of past transactions. The technology of zkSNARKs could be a solution to this problem. While the Ethereum Virtual Machine can make use of zkSNARKs in theory, they are currently too expensive\nto fit the block gas limit. Because of that, this EIP proposes to specify certain parameters for some elementary primitives that enable zkSNARKs so that they can be implemented more efficiently and the gas cost be reduced.", "Specification": "Ifblock.number >= BYZANTIUM_FORK_BLKNUM, add precompiled contracts for point addition (ADD)  and scalar multiplication (MUL) on the elliptic curve \u201calt_bn128\u201d.", "Encoding": "Field elements and scalars are encoded as 32 byte big-endian numbers. Curve points are encoded as two field elements(x, y), where the point at infinity is encoded as(0, 0).", "Exact semantics": "Invalid input: For both contracts, if any input point does not lie on the curve or any of the field elements (point coordinates) is equal or larger than the field modulus p, the contract fails. The scalar can be any number between0and2**256-1.", "Gas costs": "The specific curvealt_bn128was chosen because it is particularly well-suited for zkSNARKs, or, more specifically their verification building block of pairing functions. Furthermore, by choosing this curve, we can use synergy effects with ZCash and re-use some of their components and artifacts.", "Rationale": "The specific curvealt_bn128was chosen because it is particularly well-suited for zkSNARKs, or, more specifically their verification building block of pairing functions. Furthermore, by choosing this curve, we can use synergy effects with ZCash and re-use some of their components and artifacts.", "Backwards Compatibility": "As with the introduction of any precompiled contract, contracts that already use the given addresses will change their semantics. Because of that, the addresses are taken from the \u201creserved range\u201d below 256.", "Test Cases": "Inputs to test:", "Implementation": "Implementation of these primitives are available here:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 197, "url": "https://eips.ethereum.org/EIPS/eip-197", "title": "Precompiled contracts for optimal ate pairing check on the elliptic curve alt_bn128", "authors": ["Vitalik Buterin\u00a0<", "vitalik@ethereum.org", ">", "Christian Reitwiessner\u00a0<", "chris@ethereum.org", ">"], "sections": {"EIP-197: Precompiled contracts for optimal ate pairing check on the elliptic curve alt_bn128": "Precompiled contracts for elliptic curve pairing operations are required in order to perform zkSNARK verification within the block gas limit.", "": "Precompiled contracts for elliptic curve pairing operations are required in order to perform zkSNARK verification within the block gas limit.", "Simple Summary": "Precompiled contracts for elliptic curve pairing operations are required in order to perform zkSNARK verification within the block gas limit.", "Abstract": "This EIP suggests to add precompiled contracts for a pairing function on a specific pairing-friendly elliptic curve. This can in turn be combined withEIP-196to verify zkSNARKs in Ethereum smart contracts. The general benefit of zkSNARKs for Ethereum is that it will increase the privacy for users (because of the Zero-Knowledge property) and might also be a scalability solution (because of the succinctness and efficient verifiability property).", "Motivation": "Current smart contract executions on Ethereum are fully transparent, which makes them unsuitable for several use-cases that involve private information like the location, identity or history of past transactions. The technology of zkSNARKs could be a solution to this problem. While the Ethereum Virtual Machine can make use of zkSNARKs in theory, they are currently too expensive\nto fit the block gas limit. Because of that, this EIP proposes to specify certain parameters for some elementary primitives that enable zkSNARKs so that they can be implemented more efficiently and the gas cost be reduced.", "Specification": "For blocks whereblock.number >= BYZANTIUM_FORK_BLKNUM, add a precompiled contracts for a bilinear function on groups on the elliptic curve \u201calt_bn128\u201d. We will define the precompiled contract in terms of a discrete logarithm. The discrete logarithm is of course assumed to be hard to compute, but we will give an equivalent specification that makes use of elliptic curve pairing functions which can be efficiently computed below.", "Definition of the groups": "The groupsG_1andG_2are cyclic groups of prime orderq = 21888242871839275222246405745257275088548364400416034343698204186575808495617.", "Encoding": "Elements ofF_pare encoded as 32 byte big-endian numbers. An encoding value ofpor larger is invalid.", "Gas costs": "The gas costs of the precompiled contract are80 000 * k + 100 000, wherekis the number of\npoints or, equivalently, the length of the input divided by 192.", "Rationale": "The specific curvealt_bn128was chosen because it is particularly well-suited for zkSNARKs, or, more specifically their verification building block of pairing functions. Furthermore, by choosing this curve, we can use synergy effects with ZCash and re-use some of their components and artifacts.", "Backwards Compatibility": "As with the introduction of any precompiled contract, contracts that already use the given addresses will change their semantics. Because of that, the addresses are taken from the \u201creserved range\u201d below 256.", "Test Cases": "To be written.", "Implementation": "The precompiled contract can be implemented using elliptic curve pairing functions, more specifically, an optimal ate pairing on the alt_bn128 curve, which can be implemented efficiently. In order to see that, first note that a pairing functione: G_1 x G_2 -> G_Tfulfills the following properties (G_1andG_2are written additively,G_Tis written multiplicatively):", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 198, "url": "https://eips.ethereum.org/EIPS/eip-198", "title": "Big integer modular exponentiation", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-198: Big integer modular exponentiation": "At address 0x00\u2026\u202605, add a precompile that expects input in the following format:", "": "At address 0x00\u2026\u202605, add a precompile that expects input in the following format:", "Parameters": "At address 0x00\u2026\u202605, add a precompile that expects input in the following format:", "Specification": "At address 0x00\u2026\u202605, add a precompile that expects input in the following format:", "Rationale": "This allows for efficient RSA verification inside of the EVM, as well as other forms of number theory-based cryptography. Note that adding precompiles for addition and subtraction is not required, as the in-EVM algorithm is efficient enough, and multiplication can be done through this precompile viaa * b = ((a + b)**2 - (a - b)**2) / 4.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 211, "url": "https://eips.ethereum.org/EIPS/eip-211", "title": "New opcodes: RETURNDATASIZE and RETURNDATACOPY", "authors": ["Christian Reitwiessner\u00a0<", "chris@ethereum.org", ">"], "sections": {"EIP-211: New opcodes: RETURNDATASIZE and RETURNDATACOPY": "A mechanism to allow returning arbitrary-length data inside the EVM has been requested for quite a while now. Existing proposals always had very intricate problems associated with charging gas. This proposal solves the same problem while at the same time, it has a very simple gas charging mechanism and requires minimal changes to the call opcodes. Its workings are very similar to the way calldata is handled already; after a call, return data is kept inside a virtual buffer from which the caller can copy it (or parts thereof) into memory. At the next call, the buffer is overwritten. This mechanism is 100% backwards compatible.", "": "A mechanism to allow returning arbitrary-length data inside the EVM has been requested for quite a while now. Existing proposals always had very intricate problems associated with charging gas. This proposal solves the same problem while at the same time, it has a very simple gas charging mechanism and requires minimal changes to the call opcodes. Its workings are very similar to the way calldata is handled already; after a call, return data is kept inside a virtual buffer from which the caller can copy it (or parts thereof) into memory. At the next call, the buffer is overwritten. This mechanism is 100% backwards compatible.", "Simple Summary": "A mechanism to allow returning arbitrary-length data inside the EVM has been requested for quite a while now. Existing proposals always had very intricate problems associated with charging gas. This proposal solves the same problem while at the same time, it has a very simple gas charging mechanism and requires minimal changes to the call opcodes. Its workings are very similar to the way calldata is handled already; after a call, return data is kept inside a virtual buffer from which the caller can copy it (or parts thereof) into memory. At the next call, the buffer is overwritten. This mechanism is 100% backwards compatible.", "Abstract": "Please see summary.", "Motivation": "In some situations, it is vital for a function to be able to return data whose length cannot be anticipated before the call. In principle, this can be solved without alterations to the EVM, for example by splitting the call into two calls where the first is used to compute only the size. All of these mechanisms, though, are very expensive in at least some situations. A very useful example of such a worst-case situation is a generic forwarding contract; a contract that takes call data, potentially makes some checks and then forwards it as is to another contract. The return data should of course be transferred in a similar way to the original caller. Since the contract is generic and does not know about the contract it calls, there is no way to determine the size of the output without adapting the called contract accordingly or trying a logarithmic number of calls.", "Specification": "Ifblock.number >= BYZANTIUM_FORK_BLKNUM, add two new opcodes and amend the semantics of any opcode that creates a new call frame (likeCALL,CREATE,DELEGATECALL, \u2026) called call-like opcodes in the following. It is assumed that the EVM (to be more specific: an EVM call frame) has a new internal buffer of variable size, called the return data buffer. This buffer is created empty for each new call frame. Upon executing any call-like opcode, the buffer is cleared (its size is set to zero). After executing a call-like opcode, the complete return data (or failure data, seeEIP-140) of the call is stored in the return data buffer (of the caller), and its size changed accordingly. As an exception,CREATEandCREATE2are considered to return the empty buffer in the success case and the failure data in the failure case. If the call-like opcode is executed but does not really instantiate a call frame (for example due to insufficient funds for a value transfer or if the called contract does not exist), the return data buffer is empty.", "Rationale": "Other solutions that would allow returning dynamic data were considered, but they all had to deduct the gas from the call opcode and thus were both complicated to implement and specify (5/8). Since this proposal is very similar to the way calldata is handled, it fits nicely into the concept. Furthermore, the eWASM architecture already handles return data in exactly the same way.", "Backwards Compatibility": "This proposal introduces two new opcodes and stays fully backwards compatible apart from that.", "Test Cases": "Copyright and related rights waived viaCC0.", "Implementation": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 214, "url": "https://eips.ethereum.org/EIPS/eip-214", "title": "New opcode STATICCALL", "authors": ["Vitalik Buterin\u00a0<", "vitalik@ethereum.org", ">", "Christian Reitwiessner\u00a0<", "chris@ethereum.org", ">"], "sections": {"EIP-214: New opcode STATICCALL": "To increase smart contract security, this proposal adds a new opcode that can be used to call another contract (or itself) while disallowing any modifications to the state during the call (and its subcalls, if present).", "": "To increase smart contract security, this proposal adds a new opcode that can be used to call another contract (or itself) while disallowing any modifications to the state during the call (and its subcalls, if present).", "Simple Summary": "To increase smart contract security, this proposal adds a new opcode that can be used to call another contract (or itself) while disallowing any modifications to the state during the call (and its subcalls, if present).", "Abstract": "This proposal adds a new opcode that can be used to call another contract (or itself) while disallowing any modifications to the state during the call (and its subcalls, if present). Any opcode that attempts to perform such a modification (see below for details) will result in an exception instead of performing the modification.", "Motivation": "Currently, there is no restriction about what a called contract can do, as long as the computation can be performed with the amount of gas provided. This poses certain difficulties about smart contract engineers; after a regular call, unless you know the called contract, you cannot make any assumptions about the state of the contracts. Furthermore, because you cannot know the order of transactions before they are confirmed by miners, not even an outside observer can be sure about that in all cases.", "Specification": "Introduce a newSTATICflag to the virtual machine. This flag is set tofalseinitially. Its value is always copied to sub-calls with an exception for the new opcode below.", "Rationale": "This allows contracts to make calls that are clearly non-state-changing, reassuring developers and reviewers that re-entrancy bugs or other problems cannot possibly arise from that particular call; it is a pure function that returns an output and does nothing else. This may also make purely functional HLLs easier to implement.", "Backwards Compatibility": "This proposal adds a new opcode but does not modify the behaviour of other opcodes and thus is backwards compatible for old contracts that do not use the new opcode and are not called via the new opcode.", "Test Cases": "To be written.", "Implementation": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 225, "url": "https://eips.ethereum.org/EIPS/eip-225", "title": "Clique proof-of-authority consensus protocol", "authors": ["P\u00e9ter Szil\u00e1gyi\u00a0<", "peterke@gmail.com", ">"], "sections": {"EIP-225: Clique proof-of-authority consensus protocol": "Clique is a proof-of-authority consensus protocol. It shadows the design of Ethereum mainnet, so it can be added to any client with minimal effort.", "": "Clique is a proof-of-authority consensus protocol. It shadows the design of Ethereum mainnet, so it can be added to any client with minimal effort.", "Abstract": "Clique is a proof-of-authority consensus protocol. It shadows the design of Ethereum mainnet, so it can be added to any client with minimal effort.", "Motivation": "Ethereum\u2019s first official testnet was Morden. It ran from July 2015 to about November 2016, when due to the accumulated junk and some testnet consensus issues between Geth and Parity, it was finally laid to rest in favor of a testnet reboot.", "Standardized proof-of-authority": "As reasoned above, proof-of-work cannot work securely in a network with no value. Ethereum has its long term goal of proof-of-stake based on Casper, but that is heavy research so we cannot rely on that any time soon to fix today\u2019s problems. One solution however is easy enough to implement, yet effective enough to fix the testnet properly, namely a proof-of-authority scheme.", "Design constraints": "There are two approaches to syncing a blockchain in general:", "Repurposing header fields for signing and voting": "The most obvious field that currently is used solely asfun metadatais the 32 byteextra-datasection in block headers. Miners usually place their client and version in there, but some fill it with alternative \u201cmessages\u201d. The protocol would extend this fieldtowith 65 bytes with the purpose of a secp256k1 miner signature. This would allow anyone obtaining a block to verify it against a list of authorized signers. It also makes theminersection in block headers obsolete (since the address can be derived from the signature).", "Attack vector: Malicious signer": "It may happen that a malicious user gets added to the list of signers, or that a signer key/machine is compromised. In such a scenario the protocol needs to be able to defend itself against reorganizations and spamming. The proposed solution is that given a list of N authorized signers, any signer may only mint 1 block out of every K. This ensures that damage is limited, and the remainder of the miners can vote out the malicious user.", "Attack vector: Censoring signer": "Another interesting attack vector is if a signer (or group of signers) attempts to censor out blocks that vote on removing them from the authorization list. To work around this, we restrict the allowed minting frequency of signers to 1 out of N/2. This ensures that malicious signers need to control at least 51% of signing accounts, at which case it\u2019s game over anyway.", "Attack vector: Spamming signer": "A final small attack vector is that of malicious signers injecting new vote proposals inside every block they mint. Since nodes need to tally up all votes to create the actual list of authorized signers, they need to track all votes through time. Without placing a limit on the vote window, this could grow slowly, yet unbounded. The solution is to place amovingwindow of W blocks after which votes are considered stale.A sane window might be 1-2 epochs.We\u2019ll call this an epoch.", "Attack vector: Concurrent blocks": "If the number of authorized signers are N, and we allow each signer to mint 1 block out of K, then at any point in time N-K+1 miners are allowed to mint. To avoid these racing for blocks, every signer would add a small random \u201coffset\u201d to the time it releases a new block. This ensures that small forks are rare, but occasionally still happen (as on the main net). If a signer is caught abusing it\u2019s authority and causing chaos, it can be voted out.", "Specification": "We define the following constants:", "Authorizing a block": "To authorize a block for the network, the signer needs to sign the block\u2019s sighash containingeverything except the signature itself. This means that this hash contains every field of the header (nonceandmixDigestincluded), and also theextraDatawith the exception of the 65 byte signature suffix. The fields are hashed in the order of their definition in the yellow paper. Note that this sighash differs from the final block hash which also includes the signature.", "Voting on signers": "Every epoch transition (genesis block included) acts as a stateless checkpoint, from which capable clients should be able to sync without requiring any previous state. This means epoch headersmust notcontain votes, all non settled votes are discarded, and tallying starts from scratch.", "Test Cases": "A reference implementation is part ofgo-ethereumand has been functioning as the consensus engine behind theRinkebytestnet since April, 2017.", "Implementation": "A reference implementation is part ofgo-ethereumand has been functioning as the consensus engine behind theRinkebytestnet since April, 2017.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 649, "url": "https://eips.ethereum.org/EIPS/eip-649", "title": "Metropolis Difficulty Bomb Delay and Block Reward Reduction", "authors": ["Afri Schoedon\u00a0(", "@5chdn", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-649: Metropolis Difficulty Bomb Delay and Block Reward Reduction": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) slowly accelerating. This EIP proposes to delay the difficulty bomb for approximately one and a half year and to reduce the block rewards with the Byzantium fork, the first part of the Metropolis fork.", "": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) slowly accelerating. This EIP proposes to delay the difficulty bomb for approximately one and a half year and to reduce the block rewards with the Byzantium fork, the first part of the Metropolis fork.", "Simple Summary": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) slowly accelerating. This EIP proposes to delay the difficulty bomb for approximately one and a half year and to reduce the block rewards with the Byzantium fork, the first part of the Metropolis fork.", "Abstract": "Starting withBYZANTIUM_FORK_BLKNUMthe client will calculate the difficulty based on a fake block number suggesting the client that the difficulty bomb is adjusting around 3 million blocks later than previously specified with the Homestead fork. Furthermore, block rewards will be adjusted to a base of 3 ETH, uncle and nephew rewards will be adjusted accordingly.", "Motivation": "The Casper development and switch to proof-of-stake is delayed, the Ethash proof-of-work should be feasible for miners and allow sealing new blocks every 15 seconds on average for another one and a half years. With the delay of the ice age, there is a desire to not suddenly also increase miner rewards. The difficulty bomb has been known about for a long time and now it\u2019s going to stop from happening. In order to maintain stability of the system, a block reward reduction that offsets the ice age delay would leave the system in the same general state as before. Reducing the reward also decreases the likelihood of a miner driven chain split as Ethereum approaches proof-of-stake.", "Specification": "For the purposes ofcalc_difficulty, simply replace the use ofblock.number, as used in the exponential ice age component, with the formula:", "Rationale": "This will delay the ice age by 42 million seconds (approximately 1.4 years), so the chain would be back at 30 second block times at the end of 2018. An alternate proposal was to add special rules to the difficulty calculation to effectivelypausethe difficulty between different blocks. This would lead to similar results.", "Backwards Compatibility": "This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation, as well as the block, uncle and nephew reward structure. Therefore, it should be included in a scheduled hardfork at a certain block number. It\u2019s suggested to include this EIP in the first of the two Metropolis hard-forks, theByzantiumfork.", "Test Cases": "Test cases exist in ethereum/tests#269.", "Implementation": "The following clients implemented EIP-649:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 658, "url": "https://eips.ethereum.org/EIPS/eip-658", "title": "Embedding transaction status code in receipts", "authors": ["Nick Johnson\u00a0<", "nick@ethereum.org", ">"], "sections": {"EIP-658: Embedding transaction status code in receipts": "This EIP replaces the intermediate state root field of the receipt with a status code indicating if the top-level call succeeded or failed.", "": "This EIP replaces the intermediate state root field of the receipt with a status code indicating if the top-level call succeeded or failed.", "Abstract": "This EIP replaces the intermediate state root field of the receipt with a status code indicating if the top-level call succeeded or failed.", "Motivation": "With the introduction of the REVERT opcode in EIP140, it is no longer possible for users to assume that a transaction failed iff it consumed all gas. As a result, there is no clear mechanism for callers to determine whether a transaction succeeded and the state changes contained in it were applied.", "Specification": "For blocks where block.number >= BYZANTIUM_FORK_BLKNUM, the intermediate state root is replaced by a status code, 0 indicating failure (due to any operation that can cause the transaction or top-level call to revert) and 1 indicating success.", "Rationale": "This constitutes a minimal possible change that permits fetching the success/failure state of transactions, preserving existing capabilities with minimum disruption or additional work for Metropolis.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 684, "url": "https://eips.ethereum.org/EIPS/eip-684", "title": "Revert creation in case of collision", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Renan Rodrigues de Souza\u00a0(", "@RenanSouza2", ")"], "sections": {"EIP-684: Revert creation in case of collision": "This EIP causes contract creation to throw an error when attempted at an address with pre-existing code. This prevents an attack consisting of deploying contract code and later changing the code arbitrarily by \u201ccreating\u201d an account at that existing address.", "Revert contract creation if address already has code": "This EIP causes contract creation to throw an error when attempted at an address with pre-existing code. This prevents an attack consisting of deploying contract code and later changing the code arbitrarily by \u201ccreating\u201d an account at that existing address.", "Abstract": "This EIP causes contract creation to throw an error when attempted at an address with pre-existing code. This prevents an attack consisting of deploying contract code and later changing the code arbitrarily by \u201ccreating\u201d an account at that existing address.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "One of the core tenants of smart contracts is that its code will not change. However with sufficient computing power an attacker can change the code stored in an address to any other code, steal funds or execute other malicious activity.", "Backwards Compatibility": "This is an execution layer upgrade, and so it requires a hard fork.", "Test Cases": "Given a genesis allocation of", "Security Considerations": "This EIP is a security upgrade: it enforces the imutability of deployed code.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1014, "url": "https://eips.ethereum.org/EIPS/eip-1014", "title": "Skinny CREATE2", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-1014: Skinny CREATE2": "Adds a new opcode (CREATE2) at0xf5, which takes 4 stack arguments: endowment, memory_start, memory_length, salt. Behaves identically toCREATE(0xf0), except usingkeccak256( 0xff ++ address ++ salt ++ keccak256(init_code))[12:]instead of the usual sender-and-nonce-hash as the address where the contract is initialized at.", "": "Adds a new opcode (CREATE2) at0xf5, which takes 4 stack arguments: endowment, memory_start, memory_length, salt. Behaves identically toCREATE(0xf0), except usingkeccak256( 0xff ++ address ++ salt ++ keccak256(init_code))[12:]instead of the usual sender-and-nonce-hash as the address where the contract is initialized at.", "Specification": "Adds a new opcode (CREATE2) at0xf5, which takes 4 stack arguments: endowment, memory_start, memory_length, salt. Behaves identically toCREATE(0xf0), except usingkeccak256( 0xff ++ address ++ salt ++ keccak256(init_code))[12:]instead of the usual sender-and-nonce-hash as the address where the contract is initialized at.", "Motivation": "Allows interactions to (actually or counterfactually in channels) be made with addresses that do not exist yet on-chain but can be relied on to only possibly eventually contain code that has been created by a particular piece of init code. Important for state-channel use cases that involve counterfactual interactions with contracts.", "Rationale": "Since address calculation depends on hashing theinit_code, it would leave clients open to DoS attacks if executions could repeatedly cause hashing of large pieces ofinit_code, since expansion of memory is paid for only once. This EIP uses the same cost-per-word as theSHA3opcode.", "Clarifications": "Theinit_codeis the code that, when executed, produces the runtime bytecode that will be placed into the state, and which typically is used by high level languages to implement a \u2018constructor\u2019.", "Examples": "Example 0", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1052, "url": "https://eips.ethereum.org/EIPS/eip-1052", "title": "EXTCODEHASH opcode", "authors": ["Nick Johnson\u00a0<", "arachnid@notdot.net", ">", "Pawe\u0142 Bylica\u00a0<", "pawel@ethereum.org", ">"], "sections": {"EIP-1052: EXTCODEHASH opcode": "This EIP specifies a new opcode, which returns the keccak256 hash of a contract\u2019s code.", "": "This EIP specifies a new opcode, which returns the keccak256 hash of a contract\u2019s code.", "Abstract": "This EIP specifies a new opcode, which returns the keccak256 hash of a contract\u2019s code.", "Motivation": "Many contracts need to perform checks on a contract\u2019s bytecode, but do not necessarily need the bytecode itself. For instance, a contract may want to check if another contract\u2019s bytecode is one of a set of permitted implementations, or it may perform analyses on code and whitelist any contract with matching bytecode if the analysis passes.", "Specification": "A new opcode,EXTCODEHASH, is introduced, with number0x3f. TheEXTCODEHASHtakes one argument from the stack, zeros the first 96 bits \nand pushes to the stack the keccak256 hash of the code of the account \nat the address being the remaining 160 bits.", "Rationale": "As described in the motivation section, this opcode is widely useful, and saves \non wasted gas in many cases.", "Backwards Compatibility": "There are no backwards compatibility concerns.", "Test Cases": "TBD", "Implementation": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1108, "url": "https://eips.ethereum.org/EIPS/eip-1108", "title": "Reduce alt_bn128 precompile gas costs", "authors": ["Antonio Salazar Cardozo\u00a0(", "@shadowfiend", ")", "Zachary Williamson\u00a0(", "@zac-williamson", ")"], "sections": {"EIP-1108: Reduce alt_bn128 precompile gas costs": "The elliptic curve arithmetic precompiles are currently overpriced. Re-pricing the precompiles would greatly assist a number of privacy solutions and scaling solutions on Ethereum.", "": "The elliptic curve arithmetic precompiles are currently overpriced. Re-pricing the precompiles would greatly assist a number of privacy solutions and scaling solutions on Ethereum.", "Simple Summary": "The elliptic curve arithmetic precompiles are currently overpriced. Re-pricing the precompiles would greatly assist a number of privacy solutions and scaling solutions on Ethereum.", "Abstract": "Changes in 2018 to the underlying library used by the official Go reference\nimplementation led to significant performance gains for theECADD,ECMUL,\nand pairing check precompiled contracts on thealt_bn128elliptic curve.", "Motivation": "Recently, the underlying library used by theofficial Go reference\nimplementationto implement theECADD(at address0x06),ECMUL(at address0x07), and pairing check (at\naddress0x08) precompiled contracts was shifted toCloudflare\u2019s bn256\nlibrary. Based on theinitial PR that\nintroduced this change,\nand corroborated ina later\nnote,\nthe computational cost ofECADD,ECMUL, and pairing checks (excepting the\nconstant) has dropped roughly an order of magnitude across the board.", "Specification": "Following is a table with the current gas cost and new gas cost:", "Rationale": "Fast elliptic curve cryptography is a keystone of a growing number of protocols built on top of Ethereum. To list a few:", "Existing protocols would benefit immensely from cheaper elliptic curve cryptography": "Fast elliptic curve cryptography is a keystone of a growing number of protocols built on top of Ethereum. To list a few:", "Cheaper elliptic curve cryptography can be used to trade storage for computation": "Solutions such as Rollup and Ignis can be used to batch groups of individual transactions into a zk-SNARK proof, with the on-chain state being represented by a small Merkle root, instead of multiple account balances.", "Parity and Geth already have fast algorithms that justify reduced gas costs": "This EIP does not require Parity or Geth to deploy new cryptographic libraries, as fast bn128 algorithms have already been integrated into these clients. This goal of proposing this EIP for Istanbul, is to supplementEIP-1829(arithmetic over generic elliptic curves), providing an immediate solution to the pressing problem of expensive cryptography, while more advanced solutions are developed, defined and deployed.", "Test Cases": "As no underlying algorithms are being changed, there are no additional test cases to specify.", "Implementation": "Both the Parity and Geth clients have already implemented cryptographic libraries that are fast enough to justify reducing the precompile gas costs. As a reference, here are a list of elliptic curve libraries, inC++,golangandrust, that support thebn128curve, and have run-times that are equal to or faster than the Parity benchmarks.", "Additional References": "@vbuterin independently proposed a similar reduction after this EIP was originally created, with similar rationale, asethereum/EIPs#1187.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1153, "url": "https://eips.ethereum.org/EIPS/eip-1153", "title": "Transient storage opcodes", "authors": ["Alexey Akhunov\u00a0(", "@AlexeyAkhunov", ")", "Moody Salem\u00a0(", "@moodysalem", ")"], "sections": {"EIP-1153: Transient storage opcodes": "This proposal introduces transient storage opcodes, which manipulate state that behaves identically to storage, except that transient storage is discarded after every transaction, andTSTOREis not subject to the gas stipend check as defined inEIP-2200. In other words, the values of transient storage are never deserialized from storage or serialized to storage. Thus transient storage is cheaper since it never requires disk access. Transient storage is accessible to smart contracts via 2 new opcodes,TLOADandTSTORE, where \u201cT\u201d stands for \u201ctransient:\u201d", "Add opcodes for manipulating state that behaves almost identically to storage but is discarded after every transaction": "This proposal introduces transient storage opcodes, which manipulate state that behaves identically to storage, except that transient storage is discarded after every transaction, andTSTOREis not subject to the gas stipend check as defined inEIP-2200. In other words, the values of transient storage are never deserialized from storage or serialized to storage. Thus transient storage is cheaper since it never requires disk access. Transient storage is accessible to smart contracts via 2 new opcodes,TLOADandTSTORE, where \u201cT\u201d stands for \u201ctransient:\u201d", "Abstract": "This proposal introduces transient storage opcodes, which manipulate state that behaves identically to storage, except that transient storage is discarded after every transaction, andTSTOREis not subject to the gas stipend check as defined inEIP-2200. In other words, the values of transient storage are never deserialized from storage or serialized to storage. Thus transient storage is cheaper since it never requires disk access. Transient storage is accessible to smart contracts via 2 new opcodes,TLOADandTSTORE, where \u201cT\u201d stands for \u201ctransient:\u201d", "Motivation": "Running a transaction in Ethereum can generate multiple nested frames of execution, each created byCALL(or similar) instructions. Contracts can be re-entered during the same transaction, in which case there are more than one frame belonging to one contract. Currently, these frames can communicate in two ways: via inputs/outputs passed viaCALLinstructions, and via storage updates. If there is an intermediate frame belonging to another untrusted contract, communication via inputs/outputs is not secure. Notable example is a reentrancy lock which cannot rely on the intermediate frame to pass through the state of the lock. Communication via storage (SSTORE/SLOAD) is costly. Transient storage is a dedicated and gas efficient solution to the problem of inter frame communication.", "Specification": "Two new opcodes are added to EVM,TLOAD(0x5c) andTSTORE(0x5d). (Note that previous drafts of this EIP specified the values0xb3and0xb4forTLOADandTSTORErespectively to avoid conflict with other EIPs. The conflict has since been removed.)", "Rationale": "Another option to solve the problem of inter-frame communication is repricing theSSTOREandSLOADopcodes to be cheaper for the transient storage use case. This has already been done as ofEIP-2200. However,EIP-3529reduced the maximum refund to only 20% of the transaction gas cost, which means the use of transient storage is severely limited.", "Backwards Compatibility": "This EIP requires a hard fork to implement.", "Test Cases": "A test suite for this EIP can be foundhere.", "Reference Implementation": "Because the transient storage must behave almost identically to storage within the context of a single transaction with regards to revert behavior, it is necessary to be able to revert to a previous state of transient storage within a transaction. At the same time reverts are exceptional cases and loads, stores and returns should be cheap.", "Security Considerations": "TSTOREpresents a new way to allocate memory on a node with linear cost. In other words, each TSTORE allows the developer to store 32 bytes for 100 gas, excluding any other required operations to prepare the stack. Given 30 million gas, the maximum amount of memory that can be allocated using TSTORE is:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1234, "url": "https://eips.ethereum.org/EIPS/eip-1234", "title": "Constantinople Difficulty Bomb Delay and Block Reward Adjustment", "authors": ["Afri Schoedon\u00a0(", "@5chdn", ")"], "sections": {"EIP-1234: Constantinople Difficulty Bomb Delay and Block Reward Adjustment": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) slowly accelerating. This EIP proposes to delay the difficulty bomb for approximately 12 months and to reduce the block rewards with the Constantinople fork, the second part of the Metropolis fork.", "": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) slowly accelerating. This EIP proposes to delay the difficulty bomb for approximately 12 months and to reduce the block rewards with the Constantinople fork, the second part of the Metropolis fork.", "Simple Summary": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) slowly accelerating. This EIP proposes to delay the difficulty bomb for approximately 12 months and to reduce the block rewards with the Constantinople fork, the second part of the Metropolis fork.", "Abstract": "Starting withCNSTNTNPL_FORK_BLKNUMthe client will calculate the difficulty based on a fake block number suggesting the client that the difficulty bomb is adjusting around 5 million blocks later than previously specified with the Homestead fork. Furthermore, block rewards will be adjusted to a base of 2 ETH, uncle and nephew rewards will be adjusted accordingly.", "Motivation": "The Casper development and switch to proof-of-stake is delayed, the Ethash proof-of-work should be feasible for miners and allow sealing new blocks every 15 seconds on average for another 12 months. With the delay of the ice age, there is a desire to not suddenly also increase miner rewards. The difficulty bomb has been known about for a long time and now it\u2019s going to stop from happening. In order to maintain stability of the system, a block reward reduction that offsets the ice age delay would leave the system in the same general state as before. Reducing the reward also decreases the likelihood of a miner driven chain split as Ethereum approaches proof-of-stake.", "Specification": "For the purposes ofcalc_difficulty, simply replace the use ofblock.number, as used in the exponential ice age component, with the formula:", "Rationale": "This will delay the ice age by 29 million seconds (approximately 12 months), so the chain would be back at 30 second block times in winter 2019. An alternate proposal was to add special rules to the difficulty calculation to effectivelypausethe difficulty between different blocks. This would lead to similar results.", "Backwards Compatibility": "This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation, as well as the block, uncle and nephew reward structure. Therefore, it should be included in a scheduled hardfork at a certain block number. It\u2019s suggested to include this EIP in the second Metropolis hard-fork,Constantinople.", "Test Cases": "Test cases shall be created once the specification is to be accepted by the developers or implemented by the clients.", "Implementation": "The implementation in it\u2019s logic does not differ fromEIP-649; an implementation for Parity-Ethereum is available inparity-ethereum#9187.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1283, "url": "https://eips.ethereum.org/EIPS/eip-1283", "title": "Net gas metering for SSTORE without dirty maps", "authors": ["Wei Tang\u00a0(", "@sorpaas", ")"], "sections": {"EIP-1283: Net gas metering for SSTORE without dirty maps": "This EIP proposes net gas metering changes forSSTOREopcode, enabling\nnew usages for contract storage, and reducing excessive gas costs\nwhere it doesn\u2019t match how most implementation works.", "": "This EIP proposes net gas metering changes forSSTOREopcode, enabling\nnew usages for contract storage, and reducing excessive gas costs\nwhere it doesn\u2019t match how most implementation works.", "Abstract": "This EIP proposes net gas metering changes forSSTOREopcode, enabling\nnew usages for contract storage, and reducing excessive gas costs\nwhere it doesn\u2019t match how most implementation works.", "Motivation": "This EIP proposes a way for gas metering on SSTORE (as an alternative\nfor EIP-1087 and EIP-1153), using information that is more universally\navailable to most implementations, and require as little change in\nimplementation structures as possible.", "Specification": "Definitions of terms are as below:", "Explanation": "The new gas cost scheme forSSTOREis divided into three different\ntypes:", "State Transition": "Below is a graph (by\n@Arachnid)\nshowing possible state transition of gas costs. We ignoreNo-opstate because that is trivial:", "Rationale": "This EIP mostly achieves what a transient storage tries to do\n(EIP-1087 and EIP-1153), but without the complexity of introducing the\nconcept of \u201cdirty maps\u201d, or an extra storage struct.", "Backwards Compatibility": "This EIP requires a hard fork to implement. No gas cost increase is\nanticipated, and many contracts will see gas reduction.", "Test Cases": "Below we provide 17 test cases. 15 of them covering consecutive twoSSTOREoperations are based on workby\n@chfast. Two additional\ncase with threeSSTOREoperations is used to test the case when a\nslot is reset and then set again.", "Appendix: Proof": "Because thestorage slot\u2019s original valueis defined as the value\nwhen a reversion happens on thecurrent transaction, it\u2019s easy to\nsee that call frames won\u2019t interfere SSTORE gas calculation. So\nalthough the below proof is discussed without call frames, it applies\nto all situations with call frames. We will discuss the case\nseparately fororiginal valuebeing zero and not zero, and useinductionto prove some properties of SSTORE gas cost.", "Original Value Being Zero": "Whenoriginal valueis 0, we want to prove that:", "Original Value Not Being Zero": "Whenoriginal valueis not 0, we want to prove that:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1344, "url": "https://eips.ethereum.org/EIPS/eip-1344", "title": "ChainID opcode", "authors": ["Richard Meissner\u00a0(", "@rmeissner", ")", "Bryant Eisenbach\u00a0(", "@fubuloubu", ")"], "sections": {"EIP-1344: ChainID opcode": "This EIP adds an opcode that returns the current chain\u2019s EIP-155 unique identifier.", "": "This EIP adds an opcode that returns the current chain\u2019s EIP-155 unique identifier.", "Abstract": "This EIP adds an opcode that returns the current chain\u2019s EIP-155 unique identifier.", "Motivation": "EIP-155proposes to use the chain ID to prevent replay attacks between different chains. It would be a great benefit to have the same possibility inside smart contracts when handling signatures, especially for Layer 2 signature schemes usingEIP-712.", "Specification": "Adds a new opcodeCHAINIDat 0x46, which uses 0 stack arguments. It pushes the current chain ID onto the stack. Chain ID is a 256-bit value. The operation costsG_baseto execute.", "Rationale": "The current approach proposed by EIP-712 is to specify the chain ID at compile time. Using this approach will result in problems after a hardfork, as well as human error that may lead to loss of funds or replay attacks on signed messages.\nBy adding the proposed opcode it will be possible to access the current chain ID and validate signatures based on that.", "Backwards Compatibility": "This EIP is fully backwards compatible with all chains which implement EIP-155 chain ID domain separator for transaction signing.", "References": "This was previously suggested as part ofEIP-901.", "Test Cases": "Test Cases added toethereum/tests", "Implementation": "A reference implementation for the Trinity Python client ishere.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1559, "url": "https://eips.ethereum.org/EIPS/eip-1559", "title": "Fee market change for ETH 1.0 chain", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Eric Conner\u00a0(", "@econoar", ")", "Rick Dudley\u00a0(", "@AFDudley", ")", "Matthew Slipper\u00a0(", "@mslipper", ")", "Ian Norden\u00a0(", "@i-norden", ")", "Abdelhamid Bakhta\u00a0(", "@abdelhamidbakhta", ")"], "sections": {"EIP-1559: Fee market change for ETH 1.0 chain": "A transaction pricing mechanism that includes fixed-per-block network fee that is burned and dynamically expands/contracts block sizes to deal with transient congestion.", "": "A transaction pricing mechanism that includes fixed-per-block network fee that is burned and dynamically expands/contracts block sizes to deal with transient congestion.", "Simple Summary": "A transaction pricing mechanism that includes fixed-per-block network fee that is burned and dynamically expands/contracts block sizes to deal with transient congestion.", "Abstract": "We introduce a newEIP-2718transaction type, with the format0x02 || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s]).", "Motivation": "Ethereum historically priced transaction fees using a simple auction mechanism, where users send transactions with bids (\u201cgasprices\u201d) and miners choose transactions with the highest bids, and transactions that get included pay the bid that they specify. This leads to several large sources of inefficiency:", "Specification": "Block validity is defined in the reference implementation below.\nTheGASPRICE(0x3a) opcodeMUSTreturn theeffective_gas_priceas defined in the reference implementation below.", "Backwards Compatibility": "Legacy Ethereum transactions will still work and be included in blocks, but they will not benefit directly from the new pricing system.  This is due to the fact that upgrading from legacy transactions to new transactions results in the legacy transaction\u2019sgas_priceentirely being consumed either by thebase_fee_per_gasand thepriority_fee_per_gas.", "Block Hash Changing": "The datastructure that is passed into keccak256 to calculate the block hash is changing, and all applications that are validating blocks are valid or using the block hash to verify block contents will need to be adapted to support the new datastructure (one additional item).  If you only take the block header bytes and hash them you should still correctly get a hash, but if you construct a block header from its constituent elements you will need to add in the new one at the end.", "GASPRICE": "Previous to this change,GASPRICErepresented both the ETH paid by the signer per gas for a transaction as well as the ETH received by the miner per gas.  As of this change,GASPRICEnow only represents the amount of ETH paid by the signer per gas, and the amount a miner was paid for the transaction is no longer accessible directly in the EVM.", "Security Considerations": "This EIP will increase the maximum block size, which could cause problems if miners are unable to process a block fast enough as it will force them to mine an empty block.  Over time, the average block size should remain about the same as without this EIP, so this is only an issue for short term size bursts.  It is possible that one or more clients may handle short term size bursts poorly and error (such as out of memory or similar) and client implementations should make sure their clients can appropriately handle individual blocks up to max size.", "Increased Max Block Size/Complexity": "This EIP will increase the maximum block size, which could cause problems if miners are unable to process a block fast enough as it will force them to mine an empty block.  Over time, the average block size should remain about the same as without this EIP, so this is only an issue for short term size bursts.  It is possible that one or more clients may handle short term size bursts poorly and error (such as out of memory or similar) and client implementations should make sure their clients can appropriately handle individual blocks up to max size.", "Transaction Ordering": "With most people not competing on priority fees and instead using a baseline fee to get included, transaction ordering now depends on individual client internal implementation details such as how they store the transactions in memory.  It is recommended that transactions with the same priority fee be sorted by time the transaction was received to protect the network from spamming attacks where the attacker throws a bunch of transactions into the pending pool in order to ensure that at least one lands in a favorable position.  Miners should still prefer higher gas premium transactions over those with a lower gas premium, purely from a selfish mining perspective.", "Miners Mining Empty Blocks": "It is possible that miners will mine empty blocks until such time as the base fee is very low and then proceed to mine half full blocks and revert to sorting transactions by the priority fee.  While this attack is possible, it is not a particularly stable equilibrium as long as mining is decentralized.  Any defector from this strategy will be more profitable than a miner participating in the attack for as long as the attack continues (even after the base fee reached 0).  Since any miner can anonymously defect from a cartel, and there is no way to prove that a particular miner defected, the only feasible way to execute this attack would be to control 50% or more of hashing power.  If an attacker had exactly 50% of hashing power, they would make no Ether from priority fee while defectors would make double the Ether from priority fees.  For an attacker to turn a profit, they need to have some amount over 50% hashing power, which means they can instead execute double spend attacks or simply ignore any other miners which is a far more profitable strategy.", "ETH Burn Precludes Fixed Supply": "By burning the base fee, we can no longer guarantee a fixed Ether supply.  This could result in economic instability as the long term supply of ETH will no longer be constant over time.  While a valid concern, it is difficult to quantify how much of an impact this will have.  If more is burned on base fee than is generated in mining rewards then ETH will be deflationary and if more is generated in mining rewards than is burned then ETH will be inflationary.  Since we cannot control user demand for block space, we cannot assert at the moment whether ETH will end up inflationary or deflationary, so this change causes the core developers to lose some control over Ether\u2019s long term quantity.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1884, "url": "https://eips.ethereum.org/EIPS/eip-1884", "title": "Repricing for trie-size-dependent opcodes", "authors": ["Martin Holst Swende\u00a0(", "@holiman", ")"], "sections": {"EIP-1884: Repricing for trie-size-dependent opcodes": "This EIP proposes repricing certain opcodes, to obtain a good balance between gas expenditure and resource consumption.", "": "This EIP proposes repricing certain opcodes, to obtain a good balance between gas expenditure and resource consumption.", "Simple Summary": "This EIP proposes repricing certain opcodes, to obtain a good balance between gas expenditure and resource consumption.", "Abstract": "The growth of the Ethereum state has caused certain opcodes to be more resource-intensive at this point than \nthey were previously. This EIP proposes to raise thegasCostfor those opcodes.", "Motivation": "An imbalance between the price of an operation and the resource consumption (CPU time, memory etc)\nhas several drawbacks:", "Specification": "At blockN,", "Rationale": "Here are two charts, taken from a full sync using Geth. The execution time was measured for every opcode, and aggregated for 10K blocks. These bar charts show the top 25 \u2018heavy\u2019 opcodes in the ranges 5M to 6M and 6M to 7M:", "SLOAD": "SLOADwas repriced atEIP-150, from50to200. \nThe following graph shows a go-ethereum full sync, where each data point represents\n 10K blocks. During those 10K blocks, the execution time for the opcode was aggregated.", "BALANCE": "BALANCE(a.k.aEXTBALANCE) is an operation which fetches data from the state trie. It was repriced atEIP-150from20to400.", "EXTCODEHASH": "EXTCODEHASHwas introduced in Constantinople, withEIP-1052. It was priced at400with the reasoning:", "Backwards Compatibility": "The changes require a hardfork. The changes have the following consequences:", "Test Cases": "Testcases that should be implemented:", "Implementation": "This EIP has not yet been implemented in any client. \nBoth these opcodes have been repriced before, and the client internals for managing reprices are already in place.", "SELFBALANCE": "This is the implementation for the new opcode in go-ethereum:", "Security considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2028, "url": "https://eips.ethereum.org/EIPS/eip-2028", "title": "Transaction data gas cost reduction", "authors": ["Alexey Akhunov\u00a0(", "@AlexeyAkhunov", ")", "Eli Ben Sasson\u00a0<", "eli@starkware.co", ">", "Tom Brand\u00a0<", "tom@starkware.co", ">", "Louis Guthmann\u00a0<", "louis@starkware.co", ">", "Avihu Levy\u00a0<", "avihu@starkware.co", ">"], "sections": {"EIP-2028: Transaction data gas cost reduction": "We propose to reduce the gas cost of Calldata (GTXDATANONZERO) from its current value of 68 gas per byte to 16 gas per byte, to be backed by mathematical modeling and empirical estimates. The mathematical model is the one used in the works of Sompolinsky and Zohar [1] and Pass, Seeman and Shelat [2], which relates network security to network delay. We shall (1) evaluate the theoretical impact of lower Calldata gas cost on network delay using this model, (2) validate the model empirically, and (3) base the proposed gas cost on our findings.", "": "We propose to reduce the gas cost of Calldata (GTXDATANONZERO) from its current value of 68 gas per byte to 16 gas per byte, to be backed by mathematical modeling and empirical estimates. The mathematical model is the one used in the works of Sompolinsky and Zohar [1] and Pass, Seeman and Shelat [2], which relates network security to network delay. We shall (1) evaluate the theoretical impact of lower Calldata gas cost on network delay using this model, (2) validate the model empirically, and (3) base the proposed gas cost on our findings.", "Simple Summary": "We propose to reduce the gas cost of Calldata (GTXDATANONZERO) from its current value of 68 gas per byte to 16 gas per byte, to be backed by mathematical modeling and empirical estimates. The mathematical model is the one used in the works of Sompolinsky and Zohar [1] and Pass, Seeman and Shelat [2], which relates network security to network delay. We shall (1) evaluate the theoretical impact of lower Calldata gas cost on network delay using this model, (2) validate the model empirically, and (3) base the proposed gas cost on our findings.", "Motivation": "There are a couple of main benefits to accepting this proposal and lowering gas cost of Calldata\nOn-Chain Scalability: Generally speaking, higher bandwidth of Calldata improves scalability, as more data can fit within a single block.", "Specification": "The gas per non-zero byte is reduced from 68 to 16. Gas cost of zero bytes is unchanged.", "Rationale": "Roughly speaking, reducing the gas cost of Calldata leads to potentially larger blocks, which increases the network delay associated with data transmission over the network. This is only part of the full network delay, other factors are block processing time (and storage access, as part of it). Increasing network delay affects security by lowering the cost of attacking the network, because at any given point in time fewer nodes are updated on the latest state of the blockchain.", "BetaLower Bound": "Notice thatlambda=>beta, because not all blocks that are found will enter the main chain (as is the case with uncles). In [1] it was shown that for a blockchain using the longest chain rule, one may boundbetafrom below bylambda/ (1+ D *lambda). This lower bound holds in the extremal case where the topology of the network is a clique in which the delay between each pair of nodes is D, the maximal possible delay. Recording both the lower and upper bounds onbetawe get", "Security of the network": "An attacker attempting to reorganize the main chain needs to generate blocks at a rate that is greater thanbeta.\nFixing the difficulty level of the PoW puzzle, the total hash rate in the system is correlated tolambda. Thus,beta/lambdais defined as theefficiencyof the system, as it measures the fraction of total hash power that is used to generate the main chain of the network.", "Thedelayparameter D": "The network delay depends on the location of the mining node within the network and on the current network topology (which changes dynamically), and consequently is somewhat difficult to measure directly.\nPreviously, Christian Decker and Roger Wattenhofer [3] showed that propagation time scales with blocksize,  and Vitalik Buterin showed that uncle rate, which is tightly related to efficiency (**) measure, also scales with block size [4].", "Test Cases": "To suggest the gas cost of calldata we shall conduct two types of tests:", "Reference Implementation": "ParityGeth", "References": "[1] Yonatan Sompolinsky, Aviv Zohar:Secure High-Rate Transaction Processing in Bitcoin. Financial Cryptography 2015: 507-527", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2200, "url": "https://eips.ethereum.org/EIPS/eip-2200", "title": "Structured Definitions for Net Gas Metering", "authors": ["Wei Tang\u00a0(", "@sorpaas", ")"], "sections": {"EIP-2200: Structured Definitions for Net Gas Metering": "This is an EIP that implements net gas metering. It\u2019s a combined\nversion ofEIP-1283andEIP-1706, with a structured definition so as\nto make it interoperable with other gas changes such asEIP-1884.", "": "This is an EIP that implements net gas metering. It\u2019s a combined\nversion ofEIP-1283andEIP-1706, with a structured definition so as\nto make it interoperable with other gas changes such asEIP-1884.", "Simple Summary": "This is an EIP that implements net gas metering. It\u2019s a combined\nversion ofEIP-1283andEIP-1706, with a structured definition so as\nto make it interoperable with other gas changes such asEIP-1884.", "Abstract": "This EIP provides a structured definition of net gas metering changes\nforSSTOREopcode, enabling new usages for contract storage, and\nreducing excessive gas costs where it doesn\u2019t match how most\nimplementation works.", "Motivation": "This EIP proposes a way for gas metering onSSTORE, using information\nthat is more universally available to most implementations, and\nrequire as little change in implementation structures as possible.", "Specification": "Define variablesSLOAD_GAS,SSTORE_SET_GAS,SSTORE_RESET_GASandSSTORE_CLEARS_SCHEDULE. The old and new values for those variables\nare:", "Rationale": "This EIP mostly achieves what a transient storage tries to do\n(EIP-1087andEIP-1153), but without the complexity of introducing the\nconcept of \u201cdirty maps\u201d, or an extra storage struct.", "Backwards Compatibility": "This EIP requires a hard fork to implement. No gas cost increase is\nanticipated, and many contracts will see gas reduction.", "Test Cases": "To be added.", "Implementation": "To be added.", "Appendix: Proof": "Because thestorage slot\u2019s original valueis defined as the value\nwhen a reversion happens on thecurrent transaction, it\u2019s easy to\nsee that call frames won\u2019t interfereSSTOREgas calculation. So\nalthough the below proof is discussed without call frames, it applies\nto all situations with call frames. We will discuss the case\nseparately fororiginal valuebeing zero and not zero, and useinductionto prove some properties ofSSTOREgas cost.", "Original Value Being Zero": "Whenoriginal valueis 0, we want to prove that:", "Original Value Not Being Zero": "Whenoriginal valueis not 0, we want to prove that:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2384, "url": "https://eips.ethereum.org/EIPS/eip-2384", "title": "Muir Glacier Difficulty Bomb Delay", "authors": ["Eric Conner\u00a0(", "@econoar", ")"], "sections": {"EIP-2384: Muir Glacier Difficulty Bomb Delay": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) and slowly accelerating. This EIP proposes to delay the difficulty bomb for another 4,000,000 blocks (~611 days).", "": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) and slowly accelerating. This EIP proposes to delay the difficulty bomb for another 4,000,000 blocks (~611 days).", "Simple Summary": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) and slowly accelerating. This EIP proposes to delay the difficulty bomb for another 4,000,000 blocks (~611 days).", "Abstract": "Starting withMUIR_GLACIER_FORK_BLKNUMthe client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 9 million blocks later than the Homestead fork, which is also 7 million blocks later than the Byzantium fork and 4 million blocks later than the Constantinople fork.", "Motivation": "The difficulty bomb started to become noticeable again on October 5th 2019 at block 8,600,000. Block times have been around 13.1s on average and now as of block 8,900,000 are around 14.3s. This will start to accelerate exponentially every 100,000 blocks. Estimating the added impact from the difficulty bomb on block times shows that we will see 20s block times near the end of December 2019 and 30s+ block times starting February 2020. This will start making the chain bloated and more costly to use. It\u2019s best to delay the difficulty bomb again to around the time of expected launch of the Eth2 finality gadget.", "Specification": "For the purposes ofcalc_difficulty, simply replace the use ofblock.number, as used in the exponential ice age component, with the formula:", "Rationale": "This will delay the ice age by 52 million seconds (approximately 611 days), so the chain would be back at 20 second block times around July 2021. It\u2019s important to note this pushes the ice age 4,000,000 blocks from ~block 8,800,000 NOT from when this EIP is activated in a fork.", "Backwards Compatibility": "This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation. Therefore, it should be included in a scheduled hardfork at a certain block number. It\u2019s suggested to include this EIP shortly after the Istanbul fork.", "Test Cases": "Test cases shall be created once the specification is to be accepted by the developers or implemented by the clients.", "Implementation": "The implementation in it\u2019s logic does not differ fromEIP-649orEIP-1234; an implementation for Parity-Ethereum is available inparity-ethereum#9187.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2565, "url": "https://eips.ethereum.org/EIPS/eip-2565", "title": "ModExp Gas Cost", "authors": ["Kelly Olson\u00a0(", "@ineffectualproperty", ")", "Sean Gulley\u00a0(", "@sean-sn", ")", "Simon Peffers\u00a0(", "@simonatsn", ")", "Justin Drake\u00a0(", "@justindrake", ")", "Dankrad Feist\u00a0(", "@dankrad", ")"], "sections": {"EIP-2565: ModExp Gas Cost": "Defines the gas cost of theModExp(0x00..05) precompile.", "": "Defines the gas cost of theModExp(0x00..05) precompile.", "Simple Summary": "Defines the gas cost of theModExp(0x00..05) precompile.", "Abstract": "To accurately reflect the real world operational cost of theModExpprecompile, this EIP specifies an algorithm for calculating the gas cost. This algorithm approximates the multiplication complexity cost and multiplies that by an approximation of the iterations required to execute the exponentiation.", "Motivation": "Modular exponentiation is a foundational arithmetic operation for many cryptographic functions including signatures, VDFs, SNARKs, accumulators, and more. Unfortunately, the ModExp precompile is currently over-priced, making these operations inefficient and expensive. By reducing the cost of this precompile, these cryptographic functions become more practical, enabling improved security, stronger randomness (VDFs), and more.", "Specification": "As ofFORK_BLOCK_NUMBER, the gas cost of calling the precompile at address0x0000000000000000000000000000000000000005will be calculated as follows:", "Rationale": "After benchmarking the ModExp precompile, we discovered that it is \u2018overpriced\u2019 relative to other precompiles. We also discovered that the current gas pricing formula could be improved to better estimate the computational complexity of various ModExp input variables. The following changes improve the accuracy of theModExppricing:", "1. Modify \u2018computational complexity\u2019 formula to better reflect the computational complexity": "The complexity function defined inEIP-198is as follow:", "2. Change the value of GQUADDIVISOR": "After changing the \u2018computational complexity\u2019 formula inEIP-198to the one defined here it is necessary to changeQGUADDIVSORto bring the gas costs inline with their runtime. By setting theQGUADDIVISORto3the cost of the ModExp precompile will have a higher cost (gas/second) than other precompiles such as ECRecover.", "3. Set a minimum gas cost to prevent abuse": "This prevents the precompile from underpricing small input values.", "Test Cases": "There are no changes to the underlying interface or arithmetic algorithms, so the existing test vectors can be reused. Below is a table with the updated test vectors:", "Implementations": "Geth", "Security Considerations": "The biggest security consideration for this EIP is creating a potential DoS vector by making ModExp operations too inexpensive relative to their computation time.", "References": "EIP-198", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2681, "url": "https://eips.ethereum.org/EIPS/eip-2681", "title": "Limit account nonce to 2^64-1", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-2681: Limit account nonce to 2^64-1": "Limit account nonce to be between0and2^64-1.", "": "Limit account nonce to be between0and2^64-1.", "Abstract": "Limit account nonce to be between0and2^64-1.", "Motivation": "Account nonces are currently specified to be arbitrarily long unsigned integers. Dealing with arbitrary length data in the state witnesses is not optimal, therefore this EIP will allow proofs to represent the nonce in a more optimized way.", "Specification": "Introduce two new restrictions retroactively from genesis:", "Rationale": "While this is a breaking change, no actual effect should be visible:", "Backwards Compatibility": "While this is a breaking change, no actual effect should be visible:", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2718, "url": "https://eips.ethereum.org/EIPS/eip-2718", "title": "Typed Transaction Envelope", "authors": ["Micah Zoltu\u00a0(", "@MicahZoltu", ")"], "sections": {"EIP-2718: Typed Transaction Envelope": "TransactionType || TransactionPayloadis a valid transaction andTransactionType || ReceiptPayloadis a valid transaction receipt whereTransactionTypeidentifies the format of the transaction and*Payloadis the transaction/receipt contents, which are defined in future EIPs.", "Defines a new transaction type that is an envelope for future transaction types.": "TransactionType || TransactionPayloadis a valid transaction andTransactionType || ReceiptPayloadis a valid transaction receipt whereTransactionTypeidentifies the format of the transaction and*Payloadis the transaction/receipt contents, which are defined in future EIPs.", "Abstract": "TransactionType || TransactionPayloadis a valid transaction andTransactionType || ReceiptPayloadis a valid transaction receipt whereTransactionTypeidentifies the format of the transaction and*Payloadis the transaction/receipt contents, which are defined in future EIPs.", "Motivation": "In the past, when we have wanted to add new transaction types we have had to ensure they were backward compatible with all other transactions, meaning that you could differentiate them based only on the encoded payload, and it was not possible to have a transaction that matched both types.\nThis was seen inEIP-155where the new value was bit-packed into one of the encoded fields.\nThere are multiple proposals in discussion that define new transaction types such as one that allows EOA accounts to execute code directly within their context, one that enables someone besidesmsg.senderto pay for gas, and proposals related to layer 1 multi-sig transactions.\nThese all need to be defined in a way that is mutually compatible, which quickly becomes burdensome to EIP authors and to clients who now have to follow complex rules for differentiating transaction type.", "Specification": "As ofFORK_BLOCK_NUMBER, the transaction root in the block headerMUSTbe the root hash ofpatriciaTrie(rlp(Index) => Transaction)where:", "Definitions": "As ofFORK_BLOCK_NUMBER, the transaction root in the block headerMUSTbe the root hash ofpatriciaTrie(rlp(Index) => Transaction)where:", "Transactions": "As ofFORK_BLOCK_NUMBER, the transaction root in the block headerMUSTbe the root hash ofpatriciaTrie(rlp(Index) => Transaction)where:", "Receipts": "As ofFORK_BLOCK_NUMBER, the receipt root in the block headerMUSTbe the root hash ofpatriciaTrie(rlp(Index) => Receipt)where:", "Rationale": "For the forseable future, 0x7f is plenty and it leaves open a number of options for extending the range such as using the high bit as a continuation bit.\nThis also prevents us from colliding with legacy transaction types, which always start with a byte>= 0xc0.", "TransactionType only goes up to 0x7f": "For the forseable future, 0x7f is plenty and it leaves open a number of options for extending the range such as using the high bit as a continuation bit.\nThis also prevents us from colliding with legacy transaction types, which always start with a byte>= 0xc0.", "SHOULDinstead ofMUSTfor the TransactionType being first byte of signed data": "While it is strongly recommended that all future transactions sign the first byte to ensure that there is no problem with signature reuse, the authors acknowledge that this may not always make sense or be possible.\nOne example where this isn\u2019t possible is wrapped legacy transactions that are signature compatible with the legacy signing scheme.\nAnother potential situation is one where transactions don\u2019t have a signature in the traditional sense and instead have some other mechanism for determining validity.", "TransactionType selection algorithm": "There was discussion about defining theTransactionTypeidentifier assignment/selection algorithm in this standard.\nWhile it would be nice to have a standardized mechanism for assignment, at the time of writing of this standard there is not a strong need for it so it was deemed out of scope.\nA future EIP may introduce a standard for TransactionType identifier assignment if it is deemed necessary.", "Opaque byte array rather than an RLP array": "By having the second byte on be opaque bytes, rather than an RLP (or other encoding) list, we can support different encoding formats for the transaction payload in the future such as SSZ, LEB128, or a fixed width format.", "ORIGIN and CALLER": "There was discussion about having ORIGIN and CALLER opcodes become dependent on the transaction type, so that each transaction type could define what those opcodes returned.\nHowever, there is a desire to make transaction type opaque to the contracts to discourage contracts treating different types of transactions differently.\nThere also were concerns over backward compatibility with existing contracts which make assumptions about ORIGIN and CALLER opcodes.\nGoing forward, we will assume that all transaction types will have an address that reasonably represents aCALLERof the first EVM frame andORIGINwill be the same address in all cases.\nIf a transaction type needs to supply additional information to contracts, they will need a new opcode.", "Backwards Compatibility": "Clients can differentiate between the legacy transactions and typed transactions by looking at the first byte.\nIf it starts with a value in the range[0, 0x7f]then it is a new transaction type, if it starts with a value in the range[0xc0, 0xfe]then it is a legacy transaction type.0xffis not realistic for an RLP encoded transaction, so it is reserved for future use as an extension sentinel value.", "Security Considerations": "When designing a new 2718 transaction type, it isSTRONGLYrecommended to include the transaction type as the first byte of the signed payload.  If you fail to do this, it is possible that your transaction may be signature compatible with transactions of another type which can introduce security vulnerabilities for users.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2929, "url": "https://eips.ethereum.org/EIPS/eip-2929", "title": "Gas cost increases for state access opcodes", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Martin Swende\u00a0(", "@holiman", ")"], "sections": {"EIP-2929: Gas cost increases for state access opcodes": "Increases gas cost forSLOAD,*CALL,BALANCE,EXT*andSELFDESTRUCTwhen used for the first time in a transaction.", "": "Increases gas cost forSLOAD,*CALL,BALANCE,EXT*andSELFDESTRUCTwhen used for the first time in a transaction.", "Simple Summary": "Increases gas cost forSLOAD,*CALL,BALANCE,EXT*andSELFDESTRUCTwhen used for the first time in a transaction.", "Abstract": "Increase the gas cost ofSLOAD(0x54) to 2100, and the*CALLopcode family (0xf1,f2,f4,fA),BALANCE0x31and theEXT*opcode family (0x3b,0x3c,0x3f) to 2600. Exempts (i) precompiles, and (ii) addresses and storage slots that have already been accessed in the same transaction, which get a decreased gas cost. Additionally reformsSSTOREmetering andSELFDESTRUCTto ensure \u201cde-facto storage loads\u201d inherent in those opcodes are priced correctly.", "Motivation": "Generally, the main function of gas costs of opcodes is to be an estimate of the time needed to process that opcode, the goal being for the gas limit to correspond to a limit on the time needed to process a block. However, storage-accessing opcodes (SLOAD, as well as the*CALL,BALANCEandEXT*opcodes) have historically been underpriced. In the 2016 Shanghai DoS attacks, once the most serious client bugs were fixed, one of the more durably successful strategies used by the attacker was to simply send transactions that access or call a large number of accounts.", "Specification": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Parameters": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Storage read changes": "When an address is either the target of a (EXTCODESIZE(0x3B),EXTCODECOPY(0x3C),EXTCODEHASH(0x3F) orBALANCE(0x31)) opcode or the target of a (CALL(0xF1),CALLCODE(0xF2),DELEGATECALL(0xF4),STATICCALL(0xFA)) opcode, the gas costs are computed as follows:", "SSTORE changes": "When callingSSTORE, check if the(address, storage_key)pair is inaccessed_storage_keys. If it is not, charge an additionalCOLD_SLOAD_COSTgas, and add the pair toaccessed_storage_keys. Additionally, modify the parameters defined inEIP-2200as follows:", "SELFDESTRUCT changes": "If the ETH recipient of aSELFDESTRUCTis not inaccessed_addresses(regardless of whether or not the amount sent is nonzero), charge an additionalCOLD_ACCOUNT_ACCESS_COSTon top of the existing gas costs, and add the ETH recipient to the set.", "Rationale": "The natural alternative path to changing gas costs to reflect witness sizes is to charge per byte of witness data. However, that would take a longer time to implement, hampering the goal of providing short-term security relief. Furthermore, following that path faithfully would lead to extremely high gas costs to transactions that touch contract code, as one would need to charge for all 24576 contract code bytes; this would be an unacceptably high burden on developers. It is better to wait forcode merklizationto start trying to properly account for gas costs of accessing individual chunks of code; from a short-term DoS prevention standpoint, accessing 24 kB from disk is not much more expensive than accessing 32 bytes from disk, so worrying about code size is not necessary.", "Opcode costs vs charging per byte of witness data": "The natural alternative path to changing gas costs to reflect witness sizes is to charge per byte of witness data. However, that would take a longer time to implement, hampering the goal of providing short-term security relief. Furthermore, following that path faithfully would lead to extremely high gas costs to transactions that touch contract code, as one would need to charge for all 24576 contract code bytes; this would be an unacceptably high burden on developers. It is better to wait forcode merklizationto start trying to properly account for gas costs of accessing individual chunks of code; from a short-term DoS prevention standpoint, accessing 24 kB from disk is not much more expensive than accessing 32 bytes from disk, so worrying about code size is not necessary.", "Adding the accessed_addresses / accessed_storage_keys sets": "The sets of already-accessed accounts and storage slots are added to avoid needlessly charging for things that can be cached (and in all performant implementations already are cached). Additionally, it removes the current undesirable status quo where it is needlessly unaffordable to do self-calls or call precompiles, and enables contract breakage mitigations that involve pre-fetching some storage key allowing a future execution to still take the expected amount of gas.", "SSTORE gas cost change": "The change to SSTORE is needed to avoid the possibility of a DoS attack that \u201cpokes\u201d a randomly chosen zero storage slot, changing it from 0 to 0 at a cost of 800 gas but requiring a de-facto storage load. TheSSTORE_RESET_GASreduction ensures that the total cost of SSTORE (which now requires paying theCOLD_SLOAD_COST) remains unchanged. Additionally, note that applications that doSLOADfollowed bySSTORE(eg.storage_variable += x)would actually get cheaper!", "Change SSTORE accounting only minimally": "The SSTORE gas costs continue to use Wei Tang\u2019s original/current/new approach, instead of being redesigned to use a dirty map, because Wei Tang\u2019s approach correctly accounts for the actual costs of changing storage, which only care about current vs final value and not intermediate values.", "How would gas consumption of average applications increase under this proposal?": "We can look atAlexey Akhunov\u2019s earlier workfor data on average-case blocks. In summary, average blocks have witness sizes of ~1000 kB, of which ~750 kB is Merkle proofs and not code. Assuming a conservative 2000 bytes per Merkle branch this implies ~375 accesses per block (SLOADs have a similar gas-increase-to-bytes ratio so there\u2019s no need to analyze them separately).", "Backwards Compatibility": "These gas cost increases may potentially break contracts that depend on fixed gas costs; see the security considerations section for details and arguments for why we expect the total risks to be low and how if desired they can be reduced further.", "Test Cases": "Some test cases can be found here: https://gist.github.com/holiman/174548cad102096858583c6fbbb0649a", "Implementation": "A WIP early-draft implementation for Geth can be found here: https://github.com/holiman/go-ethereum/tree/access_lists", "Security Considerations": "As with any gas cost increasing EIP, there are three possible cases where it could cause applications to break:", "Contract breakage mitigations": "A second way to look at the risks is to explore mitigations. First of all, the existence of anaccessed_addressesandaccessed_storage_keysmap (present in this EIP, absent in EIP-1884) already makes some cases recoverable: in any case where a contract A needs to send funds to some address B, where that address accepts funds from any source but leaves a storage-dependent log, one can recover by first sending a separate call to B to pull it into the cache, and then call A, knowing that the execution of B triggered by A will only charge 100 gas per SLOAD. This fact does not fix all situations, but it does reduce risks significantly.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2930, "url": "https://eips.ethereum.org/EIPS/eip-2930", "title": "Optional access lists", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Martin Swende\u00a0(", "@holiman", ")"], "sections": {"EIP-2930: Optional access lists": "Adds a transaction type which contains an access list, a list of addresses and storage keys that the transaction plans to access. Accesses outside the list are possible, but become more expensive.", "": "Adds a transaction type which contains an access list, a list of addresses and storage keys that the transaction plans to access. Accesses outside the list are possible, but become more expensive.", "Simple Summary": "Adds a transaction type which contains an access list, a list of addresses and storage keys that the transaction plans to access. Accesses outside the list are possible, but become more expensive.", "Abstract": "We introduce a newEIP-2718transaction type, with the format0x01 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, signatureYParity, signatureR, signatureS]).", "Motivation": "This EIP serves two functions:", "Specification": "TransactionType1.  SeeEIP-2718", "Definitions": "TransactionType1.  SeeEIP-2718", "Parameters": "As ofFORK_BLOCK_NUMBER, a newEIP-2718transaction is introduced withTransactionType1.", "Rationale": "This is done to encourage transactions to use the access list as much as possible, and because processing transactions is easier when their storage reads are predictable (because clients can pre-load the data from databases and/or ask for witnesses at the time the transaction is received, or at least load the data in parallel).", "Charging less for accesses in the access list": "This is done to encourage transactions to use the access list as much as possible, and because processing transactions is easier when their storage reads are predictable (because clients can pre-load the data from databases and/or ask for witnesses at the time the transaction is received, or at least load the data in parallel).", "Allowing duplicates": "This is done because it maximizes simplicity, avoiding questions of what to prevent duplication against: just between two addresses/keys in the access list, between the access list and the tx sender/recipient/newly created contract, other restrictions? Because gas is charged per item, there is no gain and only cost in including a value in the access list twice, so this should not lead to extra chain bloat in practice.", "Signature signs over the transaction type as well as the transaction data": "This is done to ensure that the transaction cannot be \u201cre-interpreted\u201d as a transaction of a different type.", "Backwards Compatibility": "This EIP does make it more gas-expensive to perform \u201cunexpected\u201d SLOADs and account accesses. Because gas is prepaid and so does not affect fixed-gas local calls, it does not break contracts in the way that previous gas cost increases would risk. However, it does make applications that heavily rely on storage access much less economically viable.", "Security Considerations": "Access lists are difficult to construct in real-time in many situations, and this is exacerbated in environments where there is a high time lag between transaction generation and signing or simplicity of the transaction generator is highly valued (eg. either or both may apply in hardware wallets).", "Access list generation": "Access lists are difficult to construct in real-time in many situations, and this is exacerbated in environments where there is a high time lag between transaction generation and signing or simplicity of the transaction generator is highly valued (eg. either or both may apply in hardware wallets).", "Transaction size bloating": "Average block size will increase as a result of access lists being used. However, the per-byte cost of access lists is1900 / 32 = 59.375for storage keys and2400 / 20 = 120for addresses, making it much more expensive than calldata; hence, worst-case block size will not increase. Additionally, increases in average block size will be partially compensated for by the ability to pre-fetch storage at time of receiving a transaction and/or load storage in parallel upon receiving a block.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3198, "url": "https://eips.ethereum.org/EIPS/eip-3198", "title": "BASEFEE opcode", "authors": ["Abdelhamid Bakhta\u00a0(", "@abdelhamidbakhta", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-3198: BASEFEE opcode": "Adds an opcode that gives the EVM access to the block\u2019s base fee.", "": "Adds an opcode that gives the EVM access to the block\u2019s base fee.", "Simple Summary": "Adds an opcode that gives the EVM access to the block\u2019s base fee.", "Abstract": "Add aBASEFEE (0x48)that returns the value of the base fee of the current block it is executing in.", "Motivation": "The intended use case would be for contracts to get the value of the base fee. This feature would enable or improve existing use cases, such as:", "Specification": "Add aBASEFEEopcode at(0x48), with gas costG_base.", "Rationale": "The value of the base fee is needed to process transactions. That means it\u2019s value is already available before running the EVM code.\nThe opcode does not add extra complexity and additional read/write operations, hence the choice ofG_basegas cost.", "Gas cost": "The value of the base fee is needed to process transactions. That means it\u2019s value is already available before running the EVM code.\nThe opcode does not add extra complexity and additional read/write operations, hence the choice ofG_basegas cost.", "Backwards Compatibility": "There are no known backward compatibility issues with this opcode.", "Test Cases": "Assuming current block base fee is7 wei.\nThis should push the value7(left padded byte32) to the stack.", "Nominal case": "Assuming current block base fee is7 wei.\nThis should push the value7(left padded byte32) to the stack.", "Security Considerations": "The value of the base fee is not sensitive and is publicly accessible in the block header. There are no known security implications with this opcode.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3529, "url": "https://eips.ethereum.org/EIPS/eip-3529", "title": "Reduction in refunds", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Martin Swende\u00a0(", "@holiman", ")"], "sections": {"EIP-3529: Reduction in refunds": "Remove gas refunds forSELFDESTRUCT, and reduce gas refunds forSSTOREto a lower level where the refunds are still substantial, but they are no longer high enough for current \u201cexploits\u201d of the refund mechanism to be viable.", "": "Remove gas refunds forSELFDESTRUCT, and reduce gas refunds forSSTOREto a lower level where the refunds are still substantial, but they are no longer high enough for current \u201cexploits\u201d of the refund mechanism to be viable.", "Simple Summary": "Remove gas refunds forSELFDESTRUCT, and reduce gas refunds forSSTOREto a lower level where the refunds are still substantial, but they are no longer high enough for current \u201cexploits\u201d of the refund mechanism to be viable.", "Motivation": "Gas refunds forSSTOREandSELFDESTRUCTwere originally introduced to motivate application developers to write applications that practice \u201cgood state hygiene\u201d, clearing storage slots and contracts that are no longer needed. However, the benefits of this technique have proven to be far lower than anticipated, and gas refunds have had multiple unexpected harmful consequences:", "Specification": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Parameters": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Rationale": "InEIP-2200, three cases for refunds were introduced:", "Backwards Compatibility": "Refunds are currently only appliedaftertransaction execution, so they cannot affect how much gas is available to any particular call frame during execution. Hence, removing them will not break the ability of any code to execute, though it will render some applications economically nonviable.", "Effect on storage clearing incentives": "A criticism of earlier refund removal EIPs (EIP-3298andEIP-3403) is that these EIPs fully remove the incentive to set a value to zero, encouraging users to not fully clear a storage slot if they expect even the smallest probability that they will want to use that storage slot again.", "Test Cases": "Note, there is a difference between \u2018hot\u2019 and \u2018cold\u2019 slots. This table shows the values as ofEIP-2929assuming that all touched storage slots were already \u2018hot\u2019 (the difference being a one-time cost of2100gas).", "EIP-2929 Gas Costs": "Note, there is a difference between \u2018hot\u2019 and \u2018cold\u2019 slots. This table shows the values as ofEIP-2929assuming that all touched storage slots were already \u2018hot\u2019 (the difference being a one-time cost of2100gas).", "With reduced refunds": "If refunds were to be partially removed, by changingSSTORE_CLEARS_SCHEDULEfrom 15000 to 4800 (and removing selfdestruct refund) this would be the comparative table.", "Security Considerations": "Refunds are not visible to transaction execution, so this should not have any impact on transaction execution logic.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3541, "url": "https://eips.ethereum.org/EIPS/eip-3541", "title": "Reject new contract code starting with the 0xEF byte", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")", "Alexey Akhunov\u00a0(", "@AlexeyAkhunov", ")", "Christian Reitwiessner\u00a0(", "@chriseth", ")", "Martin Swende\u00a0(", "@holiman", ")"], "sections": {"EIP-3541: Reject new contract code starting with the 0xEF byte": "Disallow new code starting with the0xEFbyte to be deployed. Code already existing in the account trie starting with0xEFbyte is not affected semantically by this change.", "": "Disallow new code starting with the0xEFbyte to be deployed. Code already existing in the account trie starting with0xEFbyte is not affected semantically by this change.", "Abstract": "Disallow new code starting with the0xEFbyte to be deployed. Code already existing in the account trie starting with0xEFbyte is not affected semantically by this change.", "Motivation": "Contracts conforming to the EVM Object Format (EOF) are going to be validated at deploy time. In order to guarantee that every EOF-formatted contract in the state is valid, we need to prevent already deployed (and not validated) contracts from being recognized as such format. This will be achieved by choosing a byte sequence for themagicthat doesn\u2019t exist in any of the already deployed contracts. To prevent the growth of the search space and to limit the analysis to the contracts existing before this fork, we disallow the starting byte of the format (the first byte of the magic).", "Specification": "Afterblock.number == HF_BLOCKnew contract creation (via create transaction,CREATEorCREATE2instructions) results in an exceptional abort if thecode\u2019s first byte is0xEF.", "Remarks": "Theinitcodeis the code executed in the context of thecreatetransaction,CREATE, orCREATE2instructions. Theinitcodereturnscode(via theRETURNinstruction), which is inserted into the account. See section 7 (\u201cContract Creation\u201d) in the Yellow Paper for more information.", "Rationale": "The0xEFbyte was chosen because it resemblesExecutableFormat.", "Test Cases": "Each test case below may be executed in 3 different contexts:", "Backwards Compatibility": "This is a breaking change given new code starting with the0xEFbyte will not be deployable, and contract creation will result in a failure. However, given bytecode is executed starting at its first byte, code deployed with0xEFas the first byte is not executable anyway.", "Security Considerations": "The authors are not aware of any security or DoS risks posed by this change.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3554, "url": "https://eips.ethereum.org/EIPS/eip-3554", "title": "Difficulty Bomb Delay to December 2021", "authors": ["James Hancock\u00a0(", "@madeoftin", ")"], "sections": {"EIP-3554: Difficulty Bomb Delay to December 2021": "Delays the difficulty bomb to show effect the first week of December 2021.", "": "Delays the difficulty bomb to show effect the first week of December 2021.", "Simple Summary": "Delays the difficulty bomb to show effect the first week of December 2021.", "Abstract": "Starting withFORK_BLOCK_NUMBERthe client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 9,700,000 blocks later than the actual block number.", "Motivation": "Targeting for the Shanghai upgrade and/or the Merge to occur before December 2021. Either the bomb can be readjusted at that time, or removed all together.", "Specification": "For the purposes ofcalc_difficulty, simply replace the use ofblock.number, as used in the exponential ice age component, with the formula:", "Rationale": "The following script predicts a .1 second delay to blocktime the first week of december and a 1 second delay by the end of the month. This gives reason to address because the effect will be seen, but not so much urgency we don\u2019t have space to work around if needed.", "Backwards Compatibility": "No known backward compatibility issues.", "Security Considerations": "Misjudging the effects of the difficulty can mean longer blocktimes than anticipated until a hardfork is released. Wild shifts in difficulty can affect this number severely. Also, gradual changes in blocktimes due to longer-term adjustments in difficulty can affect the timing of difficulty bomb epochs. This affects the usability of the network but unlikely to have security ramifications.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3607, "url": "https://eips.ethereum.org/EIPS/eip-3607", "title": "Reject transactions from senders with deployed code", "authors": ["Dankrad Feist\u00a0(", "@dankrad", ")", "Dmitry Khovratovich\u00a0(", "@khovratovich", ")", "Marius van der Wijden\u00a0(", "@MariusVanDerWijden", ")"], "sections": {"EIP-3607: Reject transactions from senders with deployed code": "Ethereum addresses are currently only 160 bits long. This means it is possible to create a collision between a contract account and an Externally Owned Account (EOA) using an estimated2**80computing operations, which is feasible now given a large budget (ca. 10 billion USD). The fix in this EIP prevents the worst possible attack, where a safe looking contract (e.g. a token wrapper or an AMM-type contract) is deployed to attract user funds, which can then be spent using the EOA key for the same address. The fix is to never allow to use an address that already has code deployed as an EOA address.", "Do not allow transactions for which `tx.sender` has any code deployed.": "Ethereum addresses are currently only 160 bits long. This means it is possible to create a collision between a contract account and an Externally Owned Account (EOA) using an estimated2**80computing operations, which is feasible now given a large budget (ca. 10 billion USD). The fix in this EIP prevents the worst possible attack, where a safe looking contract (e.g. a token wrapper or an AMM-type contract) is deployed to attract user funds, which can then be spent using the EOA key for the same address. The fix is to never allow to use an address that already has code deployed as an EOA address.", "Abstract": "Ethereum addresses are currently only 160 bits long. This means it is possible to create a collision between a contract account and an Externally Owned Account (EOA) using an estimated2**80computing operations, which is feasible now given a large budget (ca. 10 billion USD). The fix in this EIP prevents the worst possible attack, where a safe looking contract (e.g. a token wrapper or an AMM-type contract) is deployed to attract user funds, which can then be spent using the EOA key for the same address. The fix is to never allow to use an address that already has code deployed as an EOA address.", "Motivation": "By creating keys for2**80EOAs and simulating the deployment of2**80contracts from these EOAs (one each), one expects to find about one collision where an EOA has the same address as one contract.", "Generating address collisions": "By creating keys for2**80EOAs and simulating the deployment of2**80contracts from these EOAs (one each), one expects to find about one collision where an EOA has the same address as one contract.", "Background": "There is currently a discussion to move to 256-bit addresses on Ethereum, which would increase collision resistance to a complexity of2**128which is currently thought infeasible for the foreseeable future. However, with 160 bit addresses, the collision problem can be effectively solved now, as demonstrated above.", "Specification": "Any transaction wheretx.senderhas aCODEHASH != EMPTYCODEHASHMUST be rejected as invalid, whereEMPTYCODEHASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470.\nThe invalid transaction MUST be rejected by the client and not be included in a block.\nA block containing such a transaction MUST be considered invalid.", "Rationale": "We note that it was always the expected that a contract account\u2019s behaviour is constrained by the code in that contract \u2013 which means that the account\u2019s funds should not suddenly be spendable by some private key. It was just implicitly assumed in the past that a 160 bit address length is enough to provide collision resistance, and thus that this case could never occur. In that sense, this EIP should be seen as a clarification of protocol behaviour in a previously undefined case rather than an explicit upgrade of consensus rules.", "Backwards Compatibility": "It is unlikely that an attack like this has already occurred on the Ethereum mainnet, or we would very likely have heard of it. It is inconceivable that someone would use this as a \u201cfeature\u201d to make a contract an EOA at the same time, when they could simply do this by adding some methods to the contract instead of spending billions on building hardware to find hash collisions.", "Test Cases": "Given a genesis allocation of", "Reference Implementation": "The following check must be added to the state transition checks after checking that the nonce of the sender is correct.\nThe sender is the address recovered from the signature of the transaction.", "Security Considerations": "This EIP is a strict security upgrade: It simply makes some transactions that were formerly valid now invalid. There is no legitimate use for such transactions, so there should be no security downsides.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3651, "url": "https://eips.ethereum.org/EIPS/eip-3651", "title": "Warm COINBASE", "authors": ["William Morriss\u00a0(", "@wjmelements", ")"], "sections": {"EIP-3651: Warm COINBASE": "TheCOINBASEaddress shall be warm at the start of transaction execution, in accordance with the actual cost of reading that account.", "Starts the `COINBASE` address warm": "TheCOINBASEaddress shall be warm at the start of transaction execution, in accordance with the actual cost of reading that account.", "Abstract": "TheCOINBASEaddress shall be warm at the start of transaction execution, in accordance with the actual cost of reading that account.", "Motivation": "DirectCOINBASEpayments are becoming increasingly popular because they allow conditional payments, which provide benefits such as implicit cancellation of transactions that would revert.\nBut accessingCOINBASEis overpriced; the address is initially cold under the access list framework introduced inEIP-2929.\nThis gas cost mismatch can incentivize alternative payments besides ETH, such asERC-20, but ETH should be the primary means of paying for transactions on Ethereum.", "Specification": "At the start of transaction execution,accessed_addressesshall be initialized to also include the address returned byCOINBASE(0x41).", "Rationale": "The addresses currently initialized warm are the addresses that should already be loaded at the start of transaction validation.\nTheORIGINaddress is always loaded to check its balance against the gas limit and the gas price.\nThetx.toaddress is always loaded to begin execution.\nTheCOINBASEaddress should also be always be loaded because it receives the block reward and the transaction fees.", "Backwards Compatibility": "There are no known backward compatibility issues presented by this change.", "Security Considerations": "There are no known security considerations introduced by this change.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3675, "url": "https://eips.ethereum.org/EIPS/eip-3675", "title": "Upgrade consensus to Proof-of-Stake", "authors": ["Mikhail Kalinin\u00a0(", "@mkalinin", ")", "Danny Ryan\u00a0(", "@djrtwo", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-3675: Upgrade consensus to Proof-of-Stake": "This EIP deprecates Proof-of-Work (PoW) and supersedes it with the new Proof-of-Stake consensus mechanism (PoS) driven by the beacon chain. Information on the bootstrapping of the new consensus mechanism is documented inEIP-2982. Full specification of the beacon chain can be found in theethereum/consensus-specsrepository.", "Specification of the consensus mechanism upgrade on Ethereum Mainnet that introduces Proof-of-Stake": "This EIP deprecates Proof-of-Work (PoW) and supersedes it with the new Proof-of-Stake consensus mechanism (PoS) driven by the beacon chain. Information on the bootstrapping of the new consensus mechanism is documented inEIP-2982. Full specification of the beacon chain can be found in theethereum/consensus-specsrepository.", "Abstract": "This EIP deprecates Proof-of-Work (PoW) and supersedes it with the new Proof-of-Stake consensus mechanism (PoS) driven by the beacon chain. Information on the bootstrapping of the new consensus mechanism is documented inEIP-2982. Full specification of the beacon chain can be found in theethereum/consensus-specsrepository.", "Motivation": "The beacon chain network has been up and running since December 2020. Neither safety nor liveness failures were detected during this period of time. This long period of running without failure demonstrates the sustainability of the beacon chain system and its readiness to become a security provider for the Ethereum Mainnet.", "Specification": "Events having thePOS_prefix in the name (PoS events) are emitted by the new proof-of-stake consensus mechanism. They signify the corresponding assertion that has been made regarding a block specified by the event. The underlying logic of PoS events can be found in the beacon chain specification. On the occurrence of each PoS event the corresponding action that is specified by this EIPMUSTbe taken.", "Definitions": "Events having thePOS_prefix in the name (PoS events) are emitted by the new proof-of-stake consensus mechanism. They signify the corresponding assertion that has been made regarding a block specified by the event. The underlying logic of PoS events can be found in the beacon chain specification. On the occurrence of each PoS event the corresponding action that is specified by this EIPMUSTbe taken.", "Client software configuration": "The following set of parameters is a part of client software configuration andMUSTbe included into its binary distribution:", "PoW block processing": "PoW blocks that are descendants of any terminal PoW blockMUST NOTbe imported. This implies that a terminal PoW block will be the last PoW block in the canonical chain.", "Constants": "Beginning withTRANSITION_BLOCK, a number of previously dynamic block fields are deprecated by enforcing these values to instead be constants. Each block field listed in the table belowMUSTbe replaced with the corresponding constant value.", "Block structure": "Beginning withTRANSITION_BLOCK, a number of previously dynamic block fields are deprecated by enforcing these values to instead be constants. Each block field listed in the table belowMUSTbe replaced with the corresponding constant value.", "Block validity": "Beginning withTRANSITION_BLOCK, the block validity conditionsMUSTbe altered by the following:", "Block and ommer rewards": "Beginning withTRANSITION_BLOCK, block and ommer rewards are deprecated. Specifically, the following actionsMUSTbe taken:", "Fork choice rule": "If set,TERMINAL_BLOCK_HASHparameter affects the PoW heaviest chain rule in the following way:", "Network": "For the purposes of theEIP-2124fork identifier, nodes implementing this EIPMUSTset theFORK_NEXTparameter to theFORK_NEXT_VALUE.", "Rationale": "The changes specified in this EIP target a minimal requisite set of consensus and client software modifications to safely replace the existing proof-of-work consensus algorithm with the new proof-of-stake consensus represented by the already in-production beacon chain.", "Total difficulty triggering the upgrade": "SeeSecurity considerations.", "Parameterizing terminal block hash": "SeeSecurity considerations.", "Halting the import of PoW blocks": "SeeSecurity considerations.", "Replacing block fields with constants": "Deprecated block fields are replaced with constant values to ensure the block format remains backwards compatible. Preserving the block format aids existing smart contracts and services in providing uninterrupted service during and after this transition.", "Replacingdifficultywith0": "After deprecating the proof-of-work the notion of difficulty no longer exists and replacing the block headerdifficultyfield with0constant is semantically sound.", "Changing block validity rules": "The rule set enforcing the PoW seal validity is replaced with the corresponding PoS rules along with the consensus upgrade as the rationale behind this change.", "Removing block rewards": "Existing rewards for producing and sealing blocks are deprecated along with the PoW mechanism. The new PoS consensus becomes both responsible for sealing blocks and for issuing block rewards once this specification enters into effect.", "Supplanting fork choice rule": "The fork choice rule of the PoW mechanism becomes completely irrelevant after the upgrade and is replaced with the corresponding rule of the new PoS consensus mechanism.", "Remove ofPOS_CONSENSUS_VALIDATED": "In prior draft versions of this EIP, an additional POS event \u2013POS_CONSENSUS_VALIDATED\u2013 was required as a validation condition for blocks. This event gave the signal to either fully incorporate or prune the block from the block tree.", "EIP-2124 fork identifier": "The value ofFORK_NEXTin EIP-2124 refers to the block number of the next fork a given node knows about and0otherwise.", "Removing block gossip": "After the upgrade of the consensus mechanism only the beacon chain network will have enough information to validate a block. Thus, block gossip provided by theethnetwork protocol will become unsafe and is deprecated in favour of the block gossip existing in the beacon chain network.", "Restricting the length ofextraData": "TheextraDatafield is defined as a maximum of32bytes in the yellow paper. Thus mainnet and most PoW testnets cap the value at32bytes.extraDatafields of greater length are used by clique testnets and other networks to carry special signature/consensus schemes. This EIP restricts the length ofextraDatato32bytes because any network that is transitioning from another consensus mechanism to a beacon chain PoS consensus mechanism no longer needs extended or unboundedextraData.", "Backwards Compatibility": "This EIP introduces backward incompatibilities in block validity, block rewards and fork choice rule.", "EVM": "Although this EIP does not introduce any explicit changes to the EVM there are a couple of places where it may affect the logic of existing smart contracts.", "Test Cases": "See Security Considerations section ofEIP-2982.", "Security Considerations": "See Security Considerations section ofEIP-2982.", "Beacon chain": "See Security Considerations section ofEIP-2982.", "Transition process": "The transition process used to take this specification into effect is a more sophisticated version of a hardfork \u2013 the regular procedure of applying backwards incompatible changes in the Ethereum network. This process has multiple successive steps instead of the normal block-height point condition of simpler hardforks.", "Ancient blocks are no longer a requisite for a network security": "Keeping historical blocks starting from genesis is essential in the PoW network. A header of every block that belongs to a particular chain is required to justify the validity of this chain with respect to the PoW seal.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3855, "url": "https://eips.ethereum.org/EIPS/eip-3855", "title": "PUSH0 instruction", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Hugo De la cruz\u00a0(", "@hugo-dc", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")"], "sections": {"EIP-3855: PUSH0 instruction": "Introduce thePUSH0(0x5f) instruction, which pushes the constant value 0 onto the stack.", "Introduce a new instruction which pushes the constant value 0 onto the stack": "Introduce thePUSH0(0x5f) instruction, which pushes the constant value 0 onto the stack.", "Abstract": "Introduce thePUSH0(0x5f) instruction, which pushes the constant value 0 onto the stack.", "Motivation": "Many instructions expect offsets as inputs, which in a number of cases are zero. A good example is the return data parameters ofCALLs, which are set to zeroes in case the contract prefers usingRETURNDATA*. This is only one example, but there are many other reasons why a contract would need to push a zero value. They can achieve that today byPUSH1 0, which costs 3 gas at runtime, and is encoded as two bytes which means2 * 200gas deployment cost.", "Specification": "The instructionPUSH0is introduced at0x5f. It has no immediate data, pops no items from the stack, and places a single item with the value 0 onto the stack. The cost of this instruction is 2 gas (akabase).", "Rationale": "Thebasegas cost is used for instructions which place constant values onto the stack, such asADDRESS,ORIGIN, and so forth.", "Gas cost": "Thebasegas cost is used for instructions which place constant values onto the stack, such asADDRESS,ORIGIN, and so forth.", "Opcode": "0x5fmeans it is in a \u201ccontiguous\u201d space with the rest of thePUSHimplementations and potentially could share the implementation.", "Backwards Compatibility": "This EIP introduces a new opcode which did not exist previously. Already deployed contracts using this opcode could change their behaviour after this EIP.", "Test Cases": "The authors are not aware of any impact on security. Note that jumpdest-analysis is unaffected, asPUSH0has no immediate data bytes.", "Security Considerations": "The authors are not aware of any impact on security. Note that jumpdest-analysis is unaffected, asPUSH0has no immediate data bytes.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3860, "url": "https://eips.ethereum.org/EIPS/eip-3860", "title": "Limit and meter initcode", "authors": ["Martin Holst Swende\u00a0(", "@holiman", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Alex Beregszaszi\u00a0(", "@axic", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")"], "sections": {"EIP-3860: Limit and meter initcode": "We extendEIP-170by introducing a maximum size limit forinitcode(MAX_INITCODE_SIZE = 2 * MAX_CODE_SIZE = 49152).", "Limit the maximum size of initcode to 49152 and apply extra gas cost of 2 for every 32-byte chunk of initcode": "We extendEIP-170by introducing a maximum size limit forinitcode(MAX_INITCODE_SIZE = 2 * MAX_CODE_SIZE = 49152).", "Abstract": "We extendEIP-170by introducing a maximum size limit forinitcode(MAX_INITCODE_SIZE = 2 * MAX_CODE_SIZE = 49152).", "Motivation": "During contract creation the client has to perform jumpdest-analysis on theinitcodeprior to execution. The work performed scales linearly with the size of theinitcode. This work currently is not metered, nor is there a protocol enforced upper bound for the size.", "Specification": "WhereMAX_CODE_SIZEis defined byEIP-170as24576.", "Parameters": "WhereMAX_CODE_SIZEis defined byEIP-170as24576.", "Rules": "The value ofINITCODE_WORD_COSTis selected based on performance benchmarks of differing worst-cases per implementation. The baseline for the benchmarks is the performance ofKECCAK256hashing in geth 1.10.9, which matches the 70 Mgas/s gas limit target on a 4.0 GHz x86_64 CPU.", "Rationale": "The value ofINITCODE_WORD_COSTis selected based on performance benchmarks of differing worst-cases per implementation. The baseline for the benchmarks is the performance ofKECCAK256hashing in geth 1.10.9, which matches the 70 Mgas/s gas limit target on a 4.0 GHz x86_64 CPU.", "Gas cost constant": "The value ofINITCODE_WORD_COSTis selected based on performance benchmarks of differing worst-cases per implementation. The baseline for the benchmarks is the performance ofKECCAK256hashing in geth 1.10.9, which matches the 70 Mgas/s gas limit target on a 4.0 GHz x86_64 CPU.", "Gas cost per word (32-byte chunk)": "We have chosen the cost of 2 gas per word based on Geth\u2019s implementation and comparing withKECCAK256performance. This means the per byte cost is0.0625. While fractional gas costs are not permitted in the EVM, we can approximate it by charging per-word.", "Reason for size limit of initcode": "Estimating and creating worst case scenarios is easier with an upper bound in place, given one parameter for the search is greatly reduced. This allows for selecting a much more optimistic gas per byte.", "Effect of size limit of initcode": "In most, if not all cases when a new contract is being created, the resulting runtime code is copied from the initcode itself. For the basic case the2 * MAX_CODE_SIZElimit allowsMAX_CODE_SIZEfor runtime code and anotherMAX_CODE_SIZEfor contract constructor code. However, the limit may have practical implications for cases where multiple contracts are deployed in a single create transaction.", "Initcode cost for create transaction": "The initcode cost for create transaction data (0.0625 gas per byte) is negligible compared to the transaction data cost (4 or 16 gas per byte). Despite that, we decided to include it in the specification for consistency, and more importantly for forward compatibility.", "How to report initcode limit violation?": "We specified that initcode size limit violation forCREATE/CREATE2results in exceptional abort of the execution. This places it in the group of early out-of-gas checks, including: stack underflow, memory expansion, static call violation, initcode hashing cost, and initcode cost introduced by this EIP. They precede the later \u201clight\u201d checks: call depth and balance. The choice gives consistency to the order of checks and lowers implementation complexity (out-of-gas checks can be performed in any order).", "Backwards Compatibility": "This EIP requires a \u201cnetwork upgrade\u201d, since it modifies consensus rules.", "Test Cases": "Tests should include the following cases:", "Security Considerations": "For client implementations, this EIP makes attacks based on jumpdest-analysis less problematic, so should increase the robustness of clients.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 4345, "url": "https://eips.ethereum.org/EIPS/eip-4345", "title": "Difficulty Bomb Delay to June 2022", "authors": ["Tim Beiko\u00a0(", "@timbeiko", ")", "James Hancock\u00a0(", "@MadeOfTin", ")", "Thomas Jay Rush\u00a0(", "@tjayrush", ")"], "sections": {"EIP-4345: Difficulty Bomb Delay to June 2022": "Starting withFORK_BLOCK_NUMBERthe client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 10,700,000 blocks later than the actual block number.", "Delays the difficulty bomb to be noticeable in June 2022.": "Starting withFORK_BLOCK_NUMBERthe client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 10,700,000 blocks later than the actual block number.", "Abstract": "Starting withFORK_BLOCK_NUMBERthe client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 10,700,000 blocks later than the actual block number.", "Motivation": "Targeting for The Merge to occur before June 2022. If it is not ready by then, the bomb can be delayed further.", "Specification": "For the purposes ofcalc_difficulty, simply replace the use ofblock.number, as used in the exponential ice age component, with the formula:", "Rationale": "The following script predicts a ~0.1 second delay to block time by June 2022 and a ~0.5 second delay by July 2022. This gives reason to address because the effect will be seen, but not so much urgency we don\u2019t have space to work around if needed.", "Backwards Compatibility": "No known backward compatibility issues.", "Security Considerations": "Misjudging the effects of the difficulty can mean longer blocktimes than anticipated until a hardfork is released. Wild shifts in difficulty can affect this number severely. Also, gradual changes in blocktimes due to longer-term adjustments in difficulty can affect the timing of difficulty bomb epochs. This affects the usability of the network but unlikely to have security ramifications.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 4399, "url": "https://eips.ethereum.org/EIPS/eip-4399", "title": "Supplant DIFFICULTY opcode with PREVRANDAO", "authors": ["Mikhail Kalinin\u00a0(", "@mkalinin", ")", "Danny Ryan\u00a0(", "@djrtwo", ")"], "sections": {"EIP-4399: Supplant DIFFICULTY opcode with PREVRANDAO": "This EIP supplants the semantics of the return value of existingDIFFICULTY (0x44)opcode and renames the opcode toPREVRANDAO (0x44).", "Expose beacon chain randomness in the EVM by supplanting DIFFICULTY opcode semantics": "This EIP supplants the semantics of the return value of existingDIFFICULTY (0x44)opcode and renames the opcode toPREVRANDAO (0x44).", "Abstract": "This EIP supplants the semantics of the return value of existingDIFFICULTY (0x44)opcode and renames the opcode toPREVRANDAO (0x44).", "Motivation": "Applications may benefit from using the randomness accumulated by the beacon chain. Thus, randomness outputs produced by the beacon chain should be accessible in the EVM.", "Specification": "Beginning withTRANSITION_BLOCK, client softwareMUSTset the value of themixHash, i.e. the field with the number13(0-indexed) in a block header, to the latest RANDAO mix of the post beacon state of the previous block.", "Definitions": "Beginning withTRANSITION_BLOCK, client softwareMUSTset the value of themixHash, i.e. the field with the number13(0-indexed) in a block header, to the latest RANDAO mix of the post beacon state of the previous block.", "Block structure": "Beginning withTRANSITION_BLOCK, client softwareMUSTset the value of themixHash, i.e. the field with the number13(0-indexed) in a block header, to the latest RANDAO mix of the post beacon state of the previous block.", "EVM": "Beginning withTRANSITION_BLOCK, theDIFFICULTY (0x44)instructionMUSTreturn the value of themixHashfield.", "Renaming": "ThemixHashfieldSHOULDfurther be renamed toprevRandao.", "Rationale": "Including a RANDAO output in the block header provides a straightforward method of accessing it from inside of the EVM as block header data is already available in the EVM context.", "Including RANDAO output in the block header": "Including a RANDAO output in the block header provides a straightforward method of accessing it from inside of the EVM as block header data is already available in the EVM context.", "UsingmixHashfield instead ofdifficulty": "ThemixHashheader field is used instead ofdifficultyto avoid a class of hidden forkchoice bugs after the PoS upgrade.", "Reusing existing field instead of appending a new one": "ThemixHashfield is deprecated at the PoS upgrade and set to zero bytes array thereafter. Reusing an existing field as a place for the randomness output saves 32 bytes per block and effectively removes the deprecation of one of the fields induced by the upgrade.", "Reusing theDIFFICULTYopcode instead of introducing a new one": "See theMotivation.", "Renaming the field and the opcode": "The renaming should be done to make the field and the opcode names semantically sound.", "UsingTRANSITION_BLOCKrather than a block or slot number": "By utilizingTRANSITION_BLOCKto trigger the change in logic defined in this EIP rather than a block or slot number, this EIP is tightly coupled to the PoS upgrade defined byEIP-3675.", "Using2**64threshold to determine PoS blocks": "The probability of RANDAO value to fall into the range between0and2**64and, thus, to be mixed with PoW difficulty values, is drastically low. Though, proposed threshold might seem to have insufficient distance from difficulty values on Ethereum Mainnet (they are currently around2**54), it requires a thousand times increase of the hashrate to make this threshold insecure. Such an increase is considered impossible to occur before the upcoming consensus upgrade.", "Backwards Compatibility": "This EIP introduces backward incompatible changes to the execution and validation of EVM state transitions. As written, this EIP utilizesTRANSITION_BLOCKand is thus tightly coupled with the PoS upgrade introduced inEIP-3675. If this EIP is to be adopted, itMUSTbe scheduled at the same time as EIP-3675.", "Test Cases": "ThePREVRANDAO (0x44)opcode in PoS Ethereum (based on the beacon chain RANDAO implementation) is a source of randomness with different properties to the randomness supplied byBLOCKHASH (0x40)orDIFFICULTY (0x44)opcodes in the PoW network.", "Security Considerations": "ThePREVRANDAO (0x44)opcode in PoS Ethereum (based on the beacon chain RANDAO implementation) is a source of randomness with different properties to the randomness supplied byBLOCKHASH (0x40)orDIFFICULTY (0x44)opcodes in the PoW network.", "Biasability": "The beacon chain RANDAO implementation gives every block proposer 1 bit of influence power per slot. Proposer may deliberately refuse to propose a block on the opportunity cost of proposer and transaction fees to prevent beacon chain randomness (a RANDAO mix) from being updated in a particular slot.", "Predictability": "Obviously, historical randomness provided by any decentralized oracle is 100% predictable. On the contrary, the randomness that is revealed in the future is predictable up to a limited extent.", "Tips for application developers": "The following tips attempt to reduce predictability and biasability of randomness outputs returned byPREVRANDAO (0x44):", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 4788, "url": "https://eips.ethereum.org/EIPS/eip-4788", "title": "Beacon block root in the EVM", "authors": ["Alex Stokes\u00a0(", "@ralexstokes", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")", "Danny Ryan\u00a0(", "@djrtwo", ")", "Martin Holst Swende\u00a0(", "@holiman", ")", "lightclient\u00a0(", "@lightclient", ")"], "sections": {"EIP-4788: Beacon block root in the EVM": "Commit to the hash tree root of each beacon chain block in the corresponding execution payload header.", "Expose beacon chain roots in the EVM": "Commit to the hash tree root of each beacon chain block in the corresponding execution payload header.", "Abstract": "Commit to the hash tree root of each beacon chain block in the corresponding execution payload header.", "Motivation": "Roots of the beacon chain blocks are cryptographic accumulators that allow proofs of arbitrary consensus state.\nExposing these roots inside the EVM allows for trust-minimized access to the consensus layer.\nThis functionality supports a wide variety of use cases that improve trust assumptions of staking pools,\nrestaking constructions, smart contract bridges, MEV mitigations and more.", "Specification": "The high-level idea is that each execution block contains the parent beacon block\u2019s root. Even in the event of missed slots since the previous block root does not change,\nwe only need a constant amount of space to represent this \u201coracle\u201d in each execution block. To improve the usability of this oracle, a small history of block roots\nare stored in the contract.", "Background": "The high-level idea is that each execution block contains the parent beacon block\u2019s root. Even in the event of missed slots since the previous block root does not change,\nwe only need a constant amount of space to represent this \u201coracle\u201d in each execution block. To improve the usability of this oracle, a small history of block roots\nare stored in the contract.", "Block structure and validity": "Beginning at the execution timestampFORK_TIMESTAMP, execution clientsMUSTextend the header schema with an additional field: theparent_beacon_block_root.\nThis root consumes 32 bytes and is exactly thehash tree rootof the parent beacon block for the given execution block.", "Block processing": "At the start of processing any execution block whereblock.timestamp >= FORK_TIMESTAMP(i.e. before processing any transactions), callBEACON_ROOTS_ADDRESSasSYSTEM_ADDRESSwith the 32-byte input ofheader.parent_beacon_block_root, a gas limit of30_000_000, and0value. This will trigger theset()routine of the beacon roots contract. This is a system operation and therefore:", "Rationale": "TheBLOCKHASHopcode could be repurposed to provide the beacon root instead of some execution block hash.\nTo minimize code change, avoid breaking changes to smart contracts, and simplify deployment to mainnet, this EIP suggests leavingBLOCKHASHalone and adding new\nfunctionality with the desired semantics.", "Why not repurposeBLOCKHASH?": "TheBLOCKHASHopcode could be repurposed to provide the beacon root instead of some execution block hash.\nTo minimize code change, avoid breaking changes to smart contracts, and simplify deployment to mainnet, this EIP suggests leavingBLOCKHASHalone and adding new\nfunctionality with the desired semantics.", "Beacon block root instead of state root": "Block roots are preferred over state roots so there is a constant amount of work to do with each new execution block. Otherwise, skipped slots would require\na linear amount of work with each new payload. While skipped slots are quite rare on mainnet, it is best to not add additional load under what would already\nbe nonfavorable conditions.", "Why two ring buffers?": "The first ring buffer only tracksHISTORY_BUFFER_LENGTHworth of roots and so for all possible timestamp values would consume a constant amount of storage.\nHowever, this design opens the contract to an attack where a skipped slot that has the same value modulo the ring buffer length would return an old root value,\nrather than the most recent one.", "Size of ring buffers": "The ring buffer data structures are sized to hold 8191 roots from the consensus layer. Using a prime number as the ring buffer size ensures that no value is overwritten until the entire ring buffer has been saturated and thereafter, each value will be updated once per iteration. This also means that even if the slot times were to change, we would continue to use at most 8191 storage slots.", "Backwards Compatibility": "No issues.", "Test Cases": "N/A", "Reference Implementation": "N/A", "Security Considerations": "N/A", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 4844, "url": "https://eips.ethereum.org/EIPS/eip-4844", "title": "Shard Blob Transactions", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Dankrad Feist\u00a0(", "@dankrad", ")", "Diederik Loerakker\u00a0(", "@protolambda", ")", "George Kadianakis\u00a0(", "@asn-d6", ")", "Matt Garnett\u00a0(", "@lightclient", ")", "Mofi Taiwo\u00a0(", "@Inphi", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")"], "sections": {"EIP-4844: Shard Blob Transactions": "Introduce a new transaction format for \u201cblob-carrying transactions\u201d which contain a large amount of data that cannot be\naccessed by EVM execution, but whose commitment can be accessed.\nThe format is intended to be fully compatible with the format that will be used in full sharding.", "Shard Blob Transactions scale data-availability of Ethereum in a simple, forwards-compatible manner.": "Introduce a new transaction format for \u201cblob-carrying transactions\u201d which contain a large amount of data that cannot be\naccessed by EVM execution, but whose commitment can be accessed.\nThe format is intended to be fully compatible with the format that will be used in full sharding.", "Abstract": "Introduce a new transaction format for \u201cblob-carrying transactions\u201d which contain a large amount of data that cannot be\naccessed by EVM execution, but whose commitment can be accessed.\nThe format is intended to be fully compatible with the format that will be used in full sharding.", "Motivation": "Rollups are in the short and medium term, and possibly in the long term, the only trustless scaling solution for Ethereum.\nTransaction fees on L1 have been very high for months and there is greater urgency in doing anything required to help facilitate an ecosystem-wide move to rollups.\nRollups are significantly reducing fees for many Ethereum users: Optimism and Arbitrum frequently provide fees that are ~3-8x lower than the Ethereum base layer itself,\nand ZK rollups, which have better data compression and can avoid including signatures, have fees ~40-100x lower than the base layer.", "Specification": "Throughout this proposal we use cryptographic methods and classes defined in the correspondingconsensus 4844 specs.", "Parameters": "Throughout this proposal we use cryptographic methods and classes defined in the correspondingconsensus 4844 specs.", "Type aliases": "Throughout this proposal we use cryptographic methods and classes defined in the correspondingconsensus 4844 specs.", "Cryptographic Helpers": "Throughout this proposal we use cryptographic methods and classes defined in the correspondingconsensus 4844 specs.", "Helpers": "Approximatesfactor * e ** (numerator / denominator)using Taylor expansion:", "Blob transaction": "We introduce a new type ofEIP-2718transaction, \u201cblob transaction\u201d, where theTransactionTypeisBLOB_TX_TYPEand theTransactionPayloadis the RLP serialization of the followingTransactionPayloadBody:", "Header extension": "The current header encoding is extended with two new 64-bit unsigned integer fields:", "Gas accounting": "We introduce blob gas as a new type of gas. It is independent of normal gas and follows its own targeting rule, similar to EIP-1559.\nWe use theexcess_blob_gasheader field to store persistent data needed to compute the blob gas base fee. For now, only blobs are priced in blob gas.", "Opcode to get versioned hashes": "We add an instructionBLOBHASH(with opcodeHASH_OPCODE_BYTE) which readsindexfrom the top of the stack\nas big-endianuint256, and replaces it on the stack withtx.blob_versioned_hashes[index]ifindex < len(tx.blob_versioned_hashes), and otherwise with a zeroedbytes32value.\nThe opcode has a gas cost ofHASH_OPCODE_GAS.", "Point evaluation precompile": "Add a precompile atPOINT_EVALUATION_PRECOMPILE_ADDRESSthat verifies a KZG proof which claims that a blob\n(represented by a commitment) evaluates to a given value at a given point.", "Consensus layer validation": "On the consensus layer the blobs are referenced, but not fully encoded, in the beacon block body.\nInstead of embedding the full contents in the body, the blobs are propagated separately, as \u201csidecars\u201d.", "Execution layer validation": "On the execution layer, the block validity conditions are extended as follows:", "Networking": "Blob transactions have two network representations. During transaction gossip responses (PooledTransactions), the EIP-2718TransactionPayloadof the blob transaction is wrapped to become:", "Rationale": "This EIP introduces blob transactions in the same format in which they are expected to exist in the final sharding specification.\nThis provides a temporary but significant scaling relief for rollups by allowing them to initially scale to 0.375 MB per slot,\nwith a separate fee market allowing fees to be very low while usage of this system is limited.", "On the path to sharding": "This EIP introduces blob transactions in the same format in which they are expected to exist in the final sharding specification.\nThis provides a temporary but significant scaling relief for rollups by allowing them to initially scale to 0.375 MB per slot,\nwith a separate fee market allowing fees to be very low while usage of this system is limited.", "How rollups would function": "Instead of putting rollup block data in transaction calldata, rollups would expect rollup block submitters\nto put the data into blobs. This guarantees availability (which is what rollups need) but would be much cheaper than calldata.\nRollups need data to be available once, long enough to ensure honest actors can construct the rollup state, but not forever.", "Versioned hashes & precompile return data": "We use versioned hashes (rather than commitments) as references to blobs in the execution layer to ensure forward compatibility with future changes.\nFor example, if we need to switch to Merkle trees + STARKs for quantum-safety reasons, then we would add a new version,\nallowing the point evaluation precompile to work with the new format.\nRollups would not have to make any EVM-level changes to how they work;\nsequencers would simply have to switch over to using a new transaction type at the appropriate time.", "Base fee per blob gas update rule": "The base fee per blob gas update rule is intended to approximate the formulabase_fee_per_blob_gas = MIN_BASE_FEE_PER_BLOB_GAS * e**(excess_blob_gas / BLOB_BASE_FEE_UPDATE_FRACTION),\nwhereexcess_blob_gasis the total \u201cextra\u201d amount of blob gas that the chain has consumed relative to the \u201ctargeted\u201d number (TARGET_BLOB_GAS_PER_BLOCKper block).\nLike EIP-1559, it\u2019s a self-correcting formula: as the excess goes higher, thebase_fee_per_blob_gasincreases exponentially, reducing usage and eventually forcing the excess back down.", "Throughput": "The values forTARGET_BLOB_GAS_PER_BLOCKandMAX_BLOB_GAS_PER_BLOCKare chosen to correspond to a target of 3 blobs (0.375 MB) and maximum of 6 blobs (0.75 MB) per block. These small initial limits are intended to minimize the strain on the network created by this EIP and are expected to be increased in future upgrades as the network demonstrates reliability under larger blocks.", "Backwards Compatibility": "This EIP introduces a transaction type that has a distinct mempool version and execution-payload version,\nwith only one-way convertibility between the two. The blobs are in the network representation and not in the consensus representation;\ninstead, they are coupled with the beacon block. This means that there is now a part of a transaction that will not be accessible from the web3 API.", "Blob non-accessibility": "This EIP introduces a transaction type that has a distinct mempool version and execution-payload version,\nwith only one-way convertibility between the two. The blobs are in the network representation and not in the consensus representation;\ninstead, they are coupled with the beacon block. This means that there is now a part of a transaction that will not be accessible from the web3 API.", "Mempool issues": "Blob transactions have a large data size at the mempool layer, which poses a mempool DoS risk,\nthough not an unprecedented one as this also applies to transactions with large amounts of calldata.", "Test Cases": "Execution layer test cases for this EIP can be found in theeip4844_blobsof theethereum/execution-spec-testsrepository. Consensus layer test cases can be foundhere.", "Security Considerations": "This EIP increases the bandwidth requirements per beacon block by a maximum of ~0.75 MB.\nThis is 40% larger than the theoretical maximum size of a block today (30M gas / 16 gas per calldata byte = 1.875M bytes), and so it will not greatly increase worst-case bandwidth.\nPost-merge, block times are static rather than an unpredictable Poisson distribution, giving a guaranteed period of time for large blocks to propagate.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 4895, "url": "https://eips.ethereum.org/EIPS/eip-4895", "title": "Beacon chain push withdrawals as operations", "authors": ["Alex Stokes\u00a0(", "@ralexstokes", ")", "Danny Ryan\u00a0(", "@djrtwo", ")"], "sections": {"EIP-4895: Beacon chain push withdrawals as operations": "Introduce a system-level \u201coperation\u201d to support validator withdrawals that are \u201cpushed\u201d from the beacon chain to the EVM.", "Support validator withdrawals from the beacon chain to the EVM via a new \"system-level\" operation type.": "Introduce a system-level \u201coperation\u201d to support validator withdrawals that are \u201cpushed\u201d from the beacon chain to the EVM.", "Abstract": "Introduce a system-level \u201coperation\u201d to support validator withdrawals that are \u201cpushed\u201d from the beacon chain to the EVM.", "Motivation": "This EIP provides a way for validator withdrawals made on the beacon chain to enter into the EVM.\nThe architecture is \u201cpush\u201d-based, rather than \u201cpull\u201d-based, where withdrawals are required to be processed in the execution layer as soon as they are dequeued from the consensus layer.", "Specification": "Beginning with the execution timestampFORK_TIMESTAMP, execution clientsMUSTintroduce the following extensions to payload validation and processing:", "System-level operation: withdrawal": "Define a new payload-level object called awithdrawalthat describes withdrawals that have been validated at the consensus layer.Withdrawals are syntactically similar to a user-level transaction but live in a different domain than user-level transactions.", "New field in the execution payload: withdrawals": "The execution payload gains a new field for thewithdrawalswhich is an RLP list ofWithdrawaldata.", "New field in the execution payload header: withdrawals root": "The execution payload header gains a new field committing to thewithdrawalsin the execution payload.", "Execution payload validity": "Assuming the execution payload is well-formatted, the execution client has an additional payload validation to ensure that thewithdrawals_rootmatches the expected value given the list in the payload.", "State transition": "Thewithdrawalsin an execution payload are processedafterany user-level transactions are applied.", "Rationale": "This EIP suggests a new type of object \u2013 the \u201cwithdrawal operation\u201d \u2013 as it has special semantics different from other existing types of EVM transactions.", "Why not a new transaction type?": "This EIP suggests a new type of object \u2013 the \u201cwithdrawal operation\u201d \u2013 as it has special semantics different from other existing types of EVM transactions.", "Why no (gas) costs for the withdrawal type?": "The maximum number of withdrawals that can reach the execution layer at a given time is bounded (enforced by the consensus layer) and this limit has been chosen so that\nany execution layer operational costs are negligible in the context of the broader payload execution.", "Why only balance updates? No general EVM execution?": "More general processing introduces the risk of failures, which complicates accounting on the beacon chain.", "Backwards Compatibility": "No issues.", "Security Considerations": "Consensus-layer validation of withdrawal transactions is critical to ensure that the proper amount of ETH is withdrawn back into the execution layer.\nThis consensus-layer to execution-layer ETH transfer does not have a current analog in the EVM and thus deserves very high security scrutiny.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 5133, "url": "https://eips.ethereum.org/EIPS/eip-5133", "title": "Delaying Difficulty Bomb to mid-September 2022", "authors": ["Tomasz Kajetan Stanczak\u00a0(", "@tkstanczak", ")", "Eric Marti Haynes\u00a0(", "@ericmartihaynes", ")", "Josh Klopfenstein\u00a0(", "@joshklop", ")", "Abhimanyu Nag\u00a0(", "@AbhiMan1601", ")"], "sections": {"EIP-5133: Delaying Difficulty Bomb to mid-September 2022": "Starting withFORK_BLOCK_NUMBERthe client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 11,400,000 blocks later than the actual block number.", "Delays the difficulty bomb by a further 700000 blocks, to the middle of September 2022.": "Starting withFORK_BLOCK_NUMBERthe client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 11,400,000 blocks later than the actual block number.", "Abstract": "Starting withFORK_BLOCK_NUMBERthe client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting 11,400,000 blocks later than the actual block number.", "Motivation": "To avoid network degradation due to a premature activation of the difficulty bomb.", "Specification": "For the purposes ofcalc_difficulty, simply replace the use ofblock.number, as used in the exponential ice age component, with the formula:", "Rationale": "The following script predicts the bomb will go off at block 15530314, which is expected to be mined around mid-September.", "Backwards Compatibility": "No known backward compatibility issues.", "Security Considerations": "Misjudging the effects of the difficulty can mean longer blocktimes than anticipated until a hardfork is released. Wild shifts in difficulty can affect this number severely. Also, gradual changes in blocktimes due to longer-term adjustments in difficulty can affect the timing of difficulty bomb epochs. This affects the usability of the network but unlikely to have security ramifications.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 5656, "url": "https://eips.ethereum.org/EIPS/eip-5656", "title": "MCOPY - Memory copying instruction", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Paul Dworzanski\u00a0(", "@poemm", ")", "Jared Wasinger\u00a0(", "@jwasinger", ")", "Casey Detrio\u00a0(", "@cdetrio", ")", "Pawel Bylica\u00a0(", "@chfast", ")", "Charles Cooper\u00a0(", "@charles-cooper", ")"], "sections": {"EIP-5656: MCOPY - Memory copying instruction": "Provide an efficient EVM instruction for copying memory areas.", "An efficient EVM instruction for copying memory areas": "Provide an efficient EVM instruction for copying memory areas.", "Abstract": "Provide an efficient EVM instruction for copying memory areas.", "Motivation": "Memory copying is a basic operation, yet implementing it on the EVM comes with overhead.", "Specification": "The instructionMCOPYis introduced at0x5E.", "Input stack": "This ordering matches the other copying instructions, i.e.CALLDATACOPY,RETURNDATACOPY.", "Gas costs": "Per yellow paper terminology, it should be considered part of theW_copygroup of opcodes, and follow the gas calculation forW_copyin the yellow paper. While the calculation in the yellow paper should be considered the final word, for reference, as of time of this writing, that currently means its gas cost is:", "Output stack": "This instruction returns no stack items.", "Semantics": "It copieslengthbytes from the offset pointed atsrcto the offset pointed atdstin memory.\nCopying takes place as if an intermediate buffer was used, allowing the destination and source to overlap.", "Rationale": "Production implementation of exact-word memory copying and partial-word memory copying can be found in the Solidity, Vyper and Fe compilers.", "Backwards Compatibility": "This EIP introduces a new instruction which did not exist previously. Already deployed contracts using this instruction could change their behaviour after this EIP.", "Test Cases": "MCOPY 0 32 32- copy 32 bytes from offset 32 to offset 0.", "Full test suite": "A full suite of tests can be found in the execution spec tests:MCOPY suite.", "Security Considerations": "Clients should take care that their implementation does not use an intermediate buffer (see for instance that the C stdlibmemmovefunction does not use an intermediate buffer), as this is a potential Denial of Service (DoS) vector. Most language builtins / standard library functions for moving bytes have the correct performance characteristics here.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6780, "url": "https://eips.ethereum.org/EIPS/eip-6780", "title": "SELFDESTRUCT only in same transaction", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")", "Dankrad Feist\u00a0(", "@dankrad", ")"], "sections": {"EIP-6780: SELFDESTRUCT only in same transaction": "This EIP changes the functionality of theSELFDESTRUCTopcode. The new functionality will be only to send all Ether in the account to the target, except that the current behaviour is preserved whenSELFDESTRUCTis called in the same transaction a contract was created.", "SELFDESTRUCT will recover all funds to the target but not delete the account, except when called in the same transaction as creation": "This EIP changes the functionality of theSELFDESTRUCTopcode. The new functionality will be only to send all Ether in the account to the target, except that the current behaviour is preserved whenSELFDESTRUCTis called in the same transaction a contract was created.", "Abstract": "This EIP changes the functionality of theSELFDESTRUCTopcode. The new functionality will be only to send all Ether in the account to the target, except that the current behaviour is preserved whenSELFDESTRUCTis called in the same transaction a contract was created.", "Motivation": "TheSELFDESTRUCTopcode requires large changes to the state of an account, in particular removing all code and storage. This will not be possible in the future with Verkle trees: Each account will be stored in many different account keys, which will not be obviously connected to the root account.", "Specification": "The behaviour ofSELFDESTRUCTis changed in the following way:", "Rationale": "Getting rid of theSELFDESTRUCTopcode has been considered in the past, and there are currently no strong reasons to use it. This EIP implements a behavior that will attempt to leave some common uses ofSELFDESTRUCTworking, while reducing the complexity of the change on EVM implementations that would come from contract versioning.", "Backwards Compatibility": "This EIP requires a hard fork, since it modifies consensus rules.", "Test Cases": "Test cases for this EIP can be found in the Execution Spec Tests suiteeip6780_selfdestruct.", "Security Considerations": "The following applications ofSELFDESTRUCTwill be broken and applications that use it in this way are not safe anymore:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7044, "url": "https://eips.ethereum.org/EIPS/eip-7044", "title": "Perpetually Valid Signed Voluntary Exits", "authors": ["Lion\u00a0(", "@dapplion", ")"], "sections": {"EIP-7044: Perpetually Valid Signed Voluntary Exits": "Lock validator voluntary exit signature domain on Capella for perpetual validity. Currently, signed voluntary exits are only valid for two upgrades.", "Lock voluntary exit signature domain on capella for perpetual validity": "Lock validator voluntary exit signature domain on Capella for perpetual validity. Currently, signed voluntary exits are only valid for two upgrades.", "Abstract": "Lock validator voluntary exit signature domain on Capella for perpetual validity. Currently, signed voluntary exits are only valid for two upgrades.", "Motivation": "Currently, signed voluntary exits are valid up-to only two upgrades for block inclusion due to the Beacon Chain state considering only the current and previous fork version. This limitation increases the complexity of some staking operations, specifically those in which the staking operator (holder of active key) is distinct from the owner of the funds (holder of the withdrawal credential). Because voluntary exits can only be signed by the active key, such a relationship requires the exchange of signed exits ahead of time for an unbounded number of forks.", "Specification": "Specification changes are built into the Consensus Specs Deneb upgrade.", "Consensus Layer": "Specification changes are built into the Consensus Specs Deneb upgrade.", "Execution Layer": "This specification does not require any changes to the Execution Layer.", "Rationale": "Perpetually valid signed voluntary exits allow simpler staking operation designs. It also aligns the UX of such objects toBLSToExecutionChangesand deposits, such that downstream tooling does not need to be updated with fork version information.", "Backwards Compatibility": "This change is backwards compatible to the Consensus Layer of Ethereum block processing logic.", "Test Cases": "Test cases for this EIP can be found in thedenebtest suite of theconsensus-specsrepository.", "Security Considerations": "The divergent signature domains across forked networks would previously have prevented the replay of VoluntaryExits after two hard forks. This specification change causes the replay protection to no longer exist. These potential replays could impact individual stakers on both sides of a fork, but does not put funds at risk and does not impact the security of the chain.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7045, "url": "https://eips.ethereum.org/EIPS/eip-7045", "title": "Increase max attestation inclusion slot", "authors": ["Danny Ryan\u00a0(", "@djrtwo", ")"], "sections": {"EIP-7045: Increase max attestation inclusion slot": "Increases max attestation inclusion slot fromattestation.slot + SLOTS_PER_EPOCHto the last slot of epochN+1whereNis the epoch containing the attestation slot.", "Increases max attestaton inclusion slot to the last slot in `N+1` where `N` is the epoch containing the attestation's slot.": "Increases max attestation inclusion slot fromattestation.slot + SLOTS_PER_EPOCHto the last slot of epochN+1whereNis the epoch containing the attestation slot.", "Abstract": "Increases max attestation inclusion slot fromattestation.slot + SLOTS_PER_EPOCHto the last slot of epochN+1whereNis the epoch containing the attestation slot.", "Motivation": "Attestations can currently be included after some minimum delay (1slot on mainnet) up untilSLOTS_PER_EPOCHslots after the slot the attestation was created in. This rolling window of one epoch was decided upon during Phase 0 because the equal inclusion window for any attestation was assessed as \u201cfair\u201d. The alternative considered path was to allow inclusion during the current and next epoch which means attestations created during the start of an epoch have more potential slots of inclusion than those at the end of the epoch.", "Specification": "This requires no changes to the Execution Layer.", "Constants": "This requires no changes to the Execution Layer.", "Execution layer": "This requires no changes to the Execution Layer.", "Consensus layer": "Specification changes are built into the Consensus Specs Deneb upgrade.", "Rationale": "As discussed in the Motivation, extending this max inclusion slot to the end of the next epoch is critical for LMD-GHOST security proofs and confirmation rule.", "Extended max inclusion slot": "As discussed in the Motivation, extending this max inclusion slot to the end of the next epoch is critical for LMD-GHOST security proofs and confirmation rule.", "Removal ofinclusion_delayconsideration for target reward": "Previously,get_attestation_participation_flag_indiceswould only set theTIMELY_TARGET_FLAG(and thus reward for an attestation with correct target vote) if the attestation was included within aSLOTS_PER_EPOCHwindow.", "Backwards Compatibility": "This EIP introduces backwards incompatible changes to the block validation rule set on the consensus layer and must be accompanied by a hard fork.", "Test Cases": "Test cases for this EIP can be found in thedenebtest suite of theconsensus-specsrepository.", "Security Considerations": "This improves LMD-GHOST security as well as enables a fast confirmation rule.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7514, "url": "https://eips.ethereum.org/EIPS/eip-7514", "title": "Add Max Epoch Churn Limit", "authors": ["dapplion\u00a0(", "@dapplion", ")", "Tim Beiko\u00a0(", "@timbeiko", ")"], "sections": {"EIP-7514: Add Max Epoch Churn Limit": "Update the maximum validator growth rate from an exponential to a linear increase by capping the epoch churn limit.", "Modify the churn limit function to upper bound it to a max value": "Update the maximum validator growth rate from an exponential to a linear increase by capping the epoch churn limit.", "Abstract": "Update the maximum validator growth rate from an exponential to a linear increase by capping the epoch churn limit.", "Motivation": "This proposal aims to mitigate the negative externalities of very high level of total ETH supply staked before a proper solution is implemented. In other words, this proposal accepts the complexities of changing the rewards curve and is meant only to slow down growth.", "Specification": "This requires no changes to the Execution Layer.", "Constants": "This requires no changes to the Execution Layer.", "Execution layer": "This requires no changes to the Execution Layer.", "Consensus layer": "The full specification of the proposed change can be found in/specs/deneb/beacon-chain.md.", "Rationale": "Depending on the specific constant selection the churn candecreaseat the activation fork epoch. The Beacon chain spec can handle this without issues. During 2023 Q4 (projected Dencun activation) the churn value will range 14-16. The table below compares the projected validator set assuming a continuous full deposit queue.", "MAX_PER_EPOCH_CHURN_LIMITvalue": "Depending on the specific constant selection the churn candecreaseat the activation fork epoch. The Beacon chain spec can handle this without issues. During 2023 Q4 (projected Dencun activation) the churn value will range 14-16. The table below compares the projected validator set assuming a continuous full deposit queue.", "Backwards Compatibility": "This EIP introduces backward incompatible changes to the block validation rule set on the consensus layer and must be accompanied by a hard fork.", "Test Cases": "Test cases for this EIP can be found in thedenebtest suite of theconsensus-specsrepository.", "Security Considerations": "This EIP breaks the symmetry between the validator entry and exit queues, where the former is bound byMAX_PER_EPOCH_ACTIVATION_CHURN_LIMITwhile the latter isn\u2019t.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7516, "url": "https://eips.ethereum.org/EIPS/eip-7516", "title": "BLOBBASEFEE instruction", "authors": ["Carl Beekhuizen\u00a0(", "@carlbeek", ")"], "sections": {"EIP-7516: BLOBBASEFEE instruction": "Add aBLOBBASEFEE (0x4a)instruction that returns the value of the blob base-fee of the current block it is executing in. It is the identical toEIP-3198(BASEFEEopcode) except that it returns the blob base-fee as perEIP-4844.", "Instruction that returns the current data-blob base-fee": "Add aBLOBBASEFEE (0x4a)instruction that returns the value of the blob base-fee of the current block it is executing in. It is the identical toEIP-3198(BASEFEEopcode) except that it returns the blob base-fee as perEIP-4844.", "Abstract": "Add aBLOBBASEFEE (0x4a)instruction that returns the value of the blob base-fee of the current block it is executing in. It is the identical toEIP-3198(BASEFEEopcode) except that it returns the blob base-fee as perEIP-4844.", "Motivation": "The intended use case would be for contracts to get the value of the blob base-fee. This feature enables blob-data users to programmatically account for the blob gas price, eg:", "Specification": "Add aBLOBBASEFEEinstruction with opcode0x4a, with gas cost2.", "Rationale": "The value of the blob base-fee is needed to process data-blob transactions. That means its value is already available before running the EVM code.\nThe instruction does not add extra complexity and additional read/write operations, hence the choice of2gas cost. This is also identical toEIP-3198(BASEFEEopcode)\u2019s cost as it just makes available data that is in the header.", "Gas cost": "The value of the blob base-fee is needed to process data-blob transactions. That means its value is already available before running the EVM code.\nThe instruction does not add extra complexity and additional read/write operations, hence the choice of2gas cost. This is also identical toEIP-3198(BASEFEEopcode)\u2019s cost as it just makes available data that is in the header.", "Backwards Compatibility": "There are no known backward compatibility issues with this instruction.", "Test Cases": "Assume callingget_blob_gasprice(header)(as defined inEIP-4844 \u00a7Gas accounting) on the current block\u2019s header returns7 wei:BLOBBASEFEEshould push the value7(left padded byte32) to the stack.", "Nominal Case": "Assume callingget_blob_gasprice(header)(as defined inEIP-4844 \u00a7Gas accounting) on the current block\u2019s header returns7 wei:BLOBBASEFEEshould push the value7(left padded byte32) to the stack.", "Comprehensive Test Suite": "A complete suite of tests can be foundhere.", "Security Considerations": "The value of the blob base-fee is not sensitive and is publicly accessible in the block header. There are no known security implications with this instruction.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2537, "url": "https://eips.ethereum.org/EIPS/eip-2537", "title": "2025-04-01", "authors": ["Precompile for BLS12-381 curve operations"], "sections": {"EIP-2537: Precompile for BLS12-381 curve operations": "Add functionality to efficiently perform operations over the BLS12-381 curve, including those for BLS signature verification.", "Adds operation on BLS12-381 curve as a precompile in a set necessary to efficiently perform operations such as BLS signature verification.": "Add functionality to efficiently perform operations over the BLS12-381 curve, including those for BLS signature verification.", "Abstract": "Add functionality to efficiently perform operations over the BLS12-381 curve, including those for BLS signature verification.", "Motivation": "The motivation of this precompile is to add a cryptographic primitive that allows to get 120+ bits of security for operations over pairing friendly curve compared to the existing BN254 precompile that only provides 80 bits of security.", "Specification": "We introducesevenseparate precompiles to perform the following operations:", "Constants": "We introducesevenseparate precompiles to perform the following operations:", "Curve parameters": "The BLS12 curve is fully defined by the following set of parameters (coefficientA=0for all BLS12 curves):", "Fields and Groups": "Field Fp is defined as the finite field of sizepwith elements represented as integers between 0 and p-1 (both inclusive).", "Fine points and encoding of base elements": "In order to produce inputs to an operation, one encodes elements of the base field and the extension field.", "ABI for operations": "G1 addition call expects256bytes as an input that is interpreted as byte concatenation of two G1 points (128bytes each). Output is an encoding of addition operation result - single G1 point (128bytes).", "Gas burning on error": "Following the current state of all other precompiles, if a call to one of the precompiles in this EIP results in an error then all the gas supplied along with aCALLorSTATICCALLis burned.", "DDoS protection": "A sane implementation of this EIPshould notcontain potential infinite loops (it is possible and not even hard to implement all the functionality withoutwhileloops) and the gas schedule accurately reflects the time spent on computations of the corresponding function (precompiles pricing reflects an amount of gas consumed in the worst case where such a case exists).", "Gas schedule": "AssumingEcRecoverprecompile as a baseline.", "Rationale": "The motivation section covers a total motivation to have operations over the BLS12-381 curves available. We also extend a rationale for more specific fine points.", "MSM as a separate call": "Explicit separate MSM operation that allows one to save execution time (so gas) by both the algorithm used (namely Pippenger\u2019s algorithm) and (usually forgotten) by the fact thatCALLoperation in Ethereum is expensive (at the time of writing), so one would have to pay non-negligible overhead if e.g. for MSM of100points would have to call the multiplication precompile100times and addition for99times (roughly138600would be saved).", "No dedicated MUL call": "Dedicated MUL precompiles which perform single G1/G2 point by scalar multiplication have exactly the same ABI as MSM withk == 1.\nMSM has to inspect the input length to reject inputs of invalid lengths. Therefore, it should recognize the case ofk == 1and invoke the underlying implementation of single point multiplication to avoid the overhead of more complex multi-scalar multiplication algorithm.", "Backwards Compatibility": "There are no backward compatibility questions.", "Subgroup checks": "MSMs and pairings MUST perform a subgroup check.\nImplementations SHOULD use the optimized subgroup check method detailed in a dedicateddocument.\nOn any input that fails the subgroup check, the precompile MUST return an error.\nAs endomorphism acceleration requires input on the correct subgroup, implementers MAY use endomorphism acceleration.", "Field to curve mapping": "The algorithms and set of parameters for SWU mapping method are provided by a separatedocument", "Test Cases": "Due to the large test parameters space, we first provide properties that various operations must satisfy. We use additive notation for point operations, capital letters (P,Q) for points, small letters (a,b) for scalars. The generator for G1 is labeled asG, the generator for G2 is labeled asH, otherwise we assume random points on a curve in a correct subgroup.0means either scalar zero or point at infinity.1means either scalar one or multiplicative identity.group_orderis the main subgroup order.e(P, Q)means pairing operation wherePis in G1,Qis in G2.", "Benchmarking test cases": "A set of test vectors for quick benchmarking on new implementations is located in a separatefile", "Reference Implementation": "There are two fully spec compatible implementations on the day of writing:", "Security Considerations": "Strictly following the spec will eliminate security implications or consensus implications in a contrast to the previous BN254 precompile.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2935, "url": "https://eips.ethereum.org/EIPS/eip-2935", "title": "2025-04-01", "authors": ["Serve historical block hashes from state"], "sections": {"EIP-2935: Serve historical block hashes from state": "Store lastHISTORY_SERVE_WINDOWhistorical block hashes in the storage of a system contract as part of the block processing logic. Furthermore this EIP has no impact onBLOCKHASHresolution mechanism (and hence its range/costs etc).", "Store and serve last 8192 block hashes as storage slots of a system contract to allow for stateless execution": "Store lastHISTORY_SERVE_WINDOWhistorical block hashes in the storage of a system contract as part of the block processing logic. Furthermore this EIP has no impact onBLOCKHASHresolution mechanism (and hence its range/costs etc).", "Abstract": "Store lastHISTORY_SERVE_WINDOWhistorical block hashes in the storage of a system contract as part of the block processing logic. Furthermore this EIP has no impact onBLOCKHASHresolution mechanism (and hence its range/costs etc).", "Motivation": "EVM implicitly assumes the client has the recent block (hashes) at hand. This assumption is not future-proof given the prospect of stateless clients. Including the block hashes in the state will allow bundling these hashes in the witness provided to a stateless client. This is already possible in the MPT and will become more efficient post-Verkle.", "Specification": "This EIP specifies for storing lastHISTORY_SERVE_WINDOWblock hashes in a ring buffer storage ofHISTORY_SERVE_WINDOWlength. Note thatHISTORY_SERVE_WINDOW>BLOCKHASH_SERVE_WINDOW(which remains unchanged).", "Block processing": "At the start of processing any block where this EIP is active (ie. before processing any transactions), call toHISTORY_STORAGE_ADDRESSasSYSTEM_ADDRESSwith the 32-byte input ofblock.parent.hash, a gas limit of30_000_000, and0value. This will trigger theset()routine of the history contract. This is a system operation following the same convention asEIP-4788and therefore:", "EVM Changes": "TheBLOCKHASHopcode semantics remains the same as before.", "Block hash history contract": "The history contract has two operations:getandset. Thesetoperation is invoked only when thecalleris equal to theSYSTEM_ADDRESSas perEIP-4788. Otherwise thegetoperation is performed.", "EIP-161handling": "The bytecode above will be deployed \u00e0 laEIP-4788. As such the account atHISTORY_STORAGE_ADDRESSwill have code and a nonce of 1, and will be exempt from EIP-161 cleanup.", "Gas costs": "The system update at the beginning of the block, i.e.process_block_hash_history(or via system call to the contract withSYSTEM_ADDRESScaller), will not warm theHISTORY_STORAGE_ADDRESSaccount or its storage slots as perEIP-2929rules. As such the first call to the contract will pay for warming up the account and storage slots it accesses.To clarify further any contract call to theHISTORY_STORAGE_ADDRESSwill follow normal EVM execution semantics.", "Rationale": "Very similar ideas were proposed before. This EIP is a simplification, removing two sources of needless complexity:", "Inserting the parent block hash": "Clients have generally two options for inserting the parent block hash into state:", "Size of ring buffers": "The ring buffer data structure is sized to hold 8191 hashes. In other system contracts a prime ring buffer size is chosen in because using a prime as the modulus ensures that no value is overwritten until the entire ring buffer has been saturated and thereafter, each value will be updated once per iteration, regardless of if some slot are missing or the slot time changes. However, in this EIP the block number is the value in the modulo operation and it only ever increases by 1 each iteration. Which means we can be confident that the ring buffer will always remain saturated.", "Backwards Compatibility": "This EIP introduces backwards incompatible changes to the block validation rule set. But neither of these changes break anything related to current user activity and experience.", "Test Cases": "TBD", "Security Considerations": "Having contracts (system or otherwise) with hot update paths (branches) poses a risk of \u201cbranch\u201d poisioning attacks where attacker could sprinkle trivial amounts of eth around these hot paths (branches). But it has been deemed that cost of attack would escalate significantly to cause any meaningful slow down of state root updates.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6110, "url": "https://eips.ethereum.org/EIPS/eip-6110", "title": "2025-02-21", "authors": ["Supply validator deposits on chain"], "sections": {"EIP-6110: Supply validator deposits on chain": "Appends validator deposits to the Execution Layer block structure. This shifts responsibility of deposit inclusion and validation to the Execution Layer and removes the need for deposit (oreth1data) voting from the Consensus Layer.", "Provides validator deposits as a list of deposit operations added to the Execution Layer block": "Appends validator deposits to the Execution Layer block structure. This shifts responsibility of deposit inclusion and validation to the Execution Layer and removes the need for deposit (oreth1data) voting from the Consensus Layer.", "Abstract": "Appends validator deposits to the Execution Layer block structure. This shifts responsibility of deposit inclusion and validation to the Execution Layer and removes the need for deposit (oreth1data) voting from the Consensus Layer.", "Motivation": "Validator deposits are a core component of the proof-of-stake consensus mechanism. This EIP allows for an in-protocol mechanism of deposit processing on the Consensus Layer and eliminates the proposer voting mechanism utilized currently. This proposed mechanism relaxes safety assumptions and reduces complexity of client software design, contributing to the security of the deposits flow. It also improves validator UX.", "Specification": "DEPOSIT_CONTRACT_ADDRESS,DEPOSIT_EVENT_SIGNATURE_HASHparametersMUSTbe included into client software binary distribution.", "Execution Layer": "DEPOSIT_CONTRACT_ADDRESS,DEPOSIT_EVENT_SIGNATURE_HASHparametersMUSTbe included into client software binary distribution.", "Consensus layer": "Consensus layer changes can be summarized into the following list:", "Rationale": "Depositindexis used to deterministically initializedeposit_requests_start_indexin theBeaconState, this prevents same deposit from being applied twice duringEth1Datapoll deprecation.", "indexfield": "Depositindexis used to deterministically initializedeposit_requests_start_indexin theBeaconState, this prevents same deposit from being applied twice duringEth1Datapoll deprecation.", "Not limiting the size of deposit operations list": "The list is unbounded because of negligible data complexity and absence of potential DoS vectors. SeeSecurity Considerationsfor more details.", "Filtering events byDEPOSIT_CONTRACT_ADDRESSandDEPOSIT_EVENT_SIGNATURE_HASH": "Depending on the design, Deposit smart contract can emit different type of events when deposit is being processed. For instance, Deposit smart contract on Sepolia emitsTransferin addition toDepositEvent. Thus it is important to filter out irrelevant events.", "Backwards Compatibility": "This EIP introduces backwards incompatible changes to the block structure and block validation rule set. But neither of these changes break anything related to user activity and experience.", "Security Considerations": "At the time of the latest update of this document, the total number of submitted deposits is 1,899,120 which is 348MB of deposit data. Assuming frequency of deposit transactions remains the same, historic chain data complexity induced by this EIP can be estimated as 84MB per year which is negligible in comparison to other historical data.", "Data complexity": "At the time of the latest update of this document, the total number of submitted deposits is 1,899,120 which is 348MB of deposit data. Assuming frequency of deposit transactions remains the same, historic chain data complexity induced by this EIP can be estimated as 84MB per year which is negligible in comparison to other historical data.", "DoS vectors": "The code in the deposit contract costs 15,650 gas to run in the cheapest case (when all storage slots are hot and only a single leaf has to be modified). Some deposits in a batch deposit are more expensive, but those costs, when amortized over a large number of deposits, are small at around ~1,000 gas per deposit. Under current gas pricing rules an extra 6,900 gas is charged to make aCALLthat transfers ETH, this is a case of inefficient gas pricing and may be reduced in the future. For future robustness the beacon chain needs to be able to withstand 1,916 deposits in a 30M gas block (15,650 gas per deposit). The limit under current rules is less than 1,271 deposits in a 30M gas block.", "Optimistic sync": "An optimistically syncing node have to rely on the honest majority assumption. That is, if adversary is powerful enough to finalize a deposit sequence, a syncing node will have to apply these deposits disregarding the validity of deposit requests with respect to the execution of a given block. Thus, an adversary that can finalize an invalid chain can also convince an honest node to accept fake deposits. The same is applicable to the validity of execution layer world state today and a new deposit processing design is within boundaries of the existing security model in that regard.", "Weak subjectivity period": "This EIP removes a hard limit on a number of deposits per epoch and makes a block gas limit the only limitation on this number. That is, the limit on deposits per epoch shifts fromMAX_DEPOSITS * SLOTS_PER_EPOCH = 512tomax_deposits_per_30m_gas_block * SLOTS_PER_EPOCH ~ 32,768at 30M gas block (we considermax_deposits_per_30m_gas_block = 1,024for simplicity).", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6916, "url": "https://eips.ethereum.org/EIPS/eip-6916", "title": "2025-01-15", "authors": ["Automatically Reset Testnet"], "sections": {"EIP-6916: Automatically Reset Testnet": "This EIP proposes a specification for an automatically reset testnet, a novel approach to testnets that can be implemented within Ethereum clients. It enables a single testing infrastructure consisting of ephemeral networks with deterministic parameters. Each network iteration is created by a specified function which deterministically generates genesis states.", "A testnet network that periodically rolls back to genesis": "This EIP proposes a specification for an automatically reset testnet, a novel approach to testnets that can be implemented within Ethereum clients. It enables a single testing infrastructure consisting of ephemeral networks with deterministic parameters. Each network iteration is created by a specified function which deterministically generates genesis states.", "Abstract": "This EIP proposes a specification for an automatically reset testnet, a novel approach to testnets that can be implemented within Ethereum clients. It enables a single testing infrastructure consisting of ephemeral networks with deterministic parameters. Each network iteration is created by a specified function which deterministically generates genesis states.", "Motivation": "A testnet which automatically resets can provide an alternative environment for short-term testing of applications, validators and also breaking changes in client implementations. It avoids issues of long running testnets which suffer from state bloat, lack of testnet funds or consensus issues. Periodically resetting the network back to genesis cleans the validator set and returns funds back to faucets while keeping the network reasonably small for easy bootstrapping.", "Specification": "The testnet is set to always reset after a predefined time period. The reset means the generation of the next genesis, discarding the old one and starting a new network. This is possible by introducing functions for the genesis generation and the client reset.", "Genesis": "To connect to the current instance of the network, the client must implement the genesis function. This function defines how the client stores information about the testnet and generates the current genesis. With each reset, the network starts from a new genesis which needs to be built based on given parameters and correspond in EL and CL clients.", "Reset": "The reset function defines an automatic process of throwing away the old data and starting with a new genesis. It depends on the previously defined function for genesis generation which the client must implement in order to be able to automatically follow the latest network iteration.", "Rationale": "Ephemeral testnets with deterministic parameters provide a sustainable alternative to traditional testnets, with the same infrastructure. At each reset, the validator set is cleared, faucets are filled again and the database is kept small.", "Network parameters": "Constants and variables defining testnet properties are arbitrary but need to be crafted considering certain limitations and security properties set out below.", "Security Considerations": "The network itself is providing a secure environment thanks to regular resets. Even if some sort of vulnerability is exploited, it will be cleared on the next reset. This is also a reason to keep periods relatively short (weeks/months opposed to months/years) with a big enough genesis validator set to keep an honest majority.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7002, "url": "https://eips.ethereum.org/EIPS/eip-7002", "title": "2025-02-21", "authors": ["Execution layer triggerable withdrawals"], "sections": {"EIP-7002: Execution layer triggerable withdrawals": "Adds a new mechanism to allow validators to trigger withdrawals and exits from their execution layer (0x01) withdrawal credentials.", "Allow validators to trigger exits and partial withdrawals via their execution layer (0x01) withdrawal credentials": "Adds a new mechanism to allow validators to trigger withdrawals and exits from their execution layer (0x01) withdrawal credentials.", "Abstract": "Adds a new mechanism to allow validators to trigger withdrawals and exits from their execution layer (0x01) withdrawal credentials.", "Motivation": "Validators have two keys \u2013 an active key and a withdrawal credential. The active key takes the form of a BLS key, whereas the withdrawal credential can either be a BLS key (0x00) or an execution layer address (0x01). The active key is \u201chot\u201d, actively signing and performing validator duties, whereas the withdrawal credential can remain \u201ccold\u201d, only performing limited operations in relation to withdrawing and ownership of the staked ETH. Due to this security relationship, the withdrawal credential ultimately is the key that owns the staked ETH and any rewards.", "Specification": "The new withdrawal request operation is anEIP-7685request\nwith type0x01and consists of the following fields:", "Configuration": "The new withdrawal request operation is anEIP-7685request\nwith type0x01and consists of the following fields:", "Execution layer": "The new withdrawal request operation is anEIP-7685request\nwith type0x01and consists of the following fields:", "Consensus layer": "Full specification", "Rationale": "Multiple validators can utilize the same execution layer withdrawal credential, thus thevalidator_pubkeyfield is utilized to disambiguate which validator is being exited.", "validator_pubkeyfield": "Multiple validators can utilize the same execution layer withdrawal credential, thus thevalidator_pubkeyfield is utilized to disambiguate which validator is being exited.", "Message queue": "The contract maintains an in-state queue of withdrawal request messages to be dequeued each block into the block and thus into the execution layer.", "Rate limiting using a fee": "Transactions are naturally rate-limited in the execution layer via the gas limit, but an adversary willing to pay market-rate gas fees (and potentially utilize builder markets to pay for front-of-block transaction inclusion) can fill up the exit operation limits for relatively cheap, thus griefing honest validators that want to make a withdrawal request.", "TARGET_WITHDRAWAL_REQUESTS_PER_BLOCKconfiguration value": "TARGET_WITHDRAWAL_REQUESTS_PER_BLOCKhas been selected as2such that the growth of the partial withdrawal queue in the beacon state is negligible under extreme scenarios of the exit churn congestion.", "Fee update rule": "The fee update rule is intended to approximate the formulafee = MIN_WITHDRAWAL_REQUEST_FEE * e**(excess / WITHDRAWAL_REQUEST_FEE_UPDATE_FRACTION), whereexcessis the total \u201cextra\u201d amount of withdrawal requests that the chain has processed relative to the \u201ctargeted\u201d number (TARGET_WITHDRAWAL_REQUESTS_PER_BLOCKper block).", "Withdrawal requests inside of the block": "Withdrawal requests are placed into the actual body of the beacon block.", "Submitting requests via execution layer": "Verifyingsecp256k1signatures from the consensus layer via Engine API is one of the alternatives to the proposed requests mechanism which engineering complexity is much lower.\nHowever, this approach would limit usage of withdrawal requests to a large extent by making it impossible for smart contracts owning validator withdrawal credentials to benefit from this functionality.", "Backwards Compatibility": "This EIP introduces backwards incompatible changes to the block structure and block validation rule set. But neither of these changes break anything related to current user activity and experience.", "Security Considerations": "There might be existing custody relationships and/or products that rely upon the assumption that the withdrawal credentialscannottrigger a withdrawal request. We are currently confident that the additional withdrawal credentials feature does not impact the security of existing validators because:", "Impact on existing custody relationships": "There might be existing custody relationships and/or products that rely upon the assumption that the withdrawal credentialscannottrigger a withdrawal request. We are currently confident that the additional withdrawal credentials feature does not impact the security of existing validators because:", "Fee Overpayment": "Calls to the system contract require a fee payment defined by the current contract state. Overpaid fees are not returned to the caller. It is not generally possible to compute the exact required fee amount ahead of time. When adding a withdrawal request from a contract, the contract can perform a read operation to check for the current fee and then pay exactly the required amount. Here is an example in Solidity:", "System Call failure": "Although the likelihood of a failed system call toWITHDRAWAL_REQUEST_PREDEPLOY_ADDRESSis extremely low, the behavior in such cases is well-defined: the block is marked as invalid. However, if the failure results from processing a transaction within the block, the public mempool may still retain the transaction even after the block is invalidated. This can result in the offending transaction being included again, potentially causing one or more subsequent slots to go without valid blocks. To mitigate this, we recommend that the block producer implementation shuffle their transaction set to increase the chances of producing a valid block, without the offending transaction(s). The block producer implementation and/or the mempool should be aware of system call failure scenarios to enable this behavior.", "Empty Code failure": "This EIP should not have been activated if there is no code present atWITHDRAWAL_REQUEST_PREDEPLOY_ADDRESS(i.e., if the chain is not \u201cready\u201d). Doing so would cause the first and all subsequent blocks afterFORK_BLOCKto be marked invalid.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7251, "url": "https://eips.ethereum.org/EIPS/eip-7251", "title": "2025-02-21", "authors": ["Increase the MAX_EFFECTIVE_BALANCE"], "sections": {"EIP-7251: Increase the MAX_EFFECTIVE_BALANCE": "Increases the constantMAX_EFFECTIVE_BALANCE, while keeping the minimum staking balance32 ETH. This permits large node operators to consolidate into fewer validators while also allowing solo-stakers to earn compounding rewards and stake in more flexible increments.", "Allow validators to have larger effective balances, while maintaining the 32 ETH lower bound.": "Increases the constantMAX_EFFECTIVE_BALANCE, while keeping the minimum staking balance32 ETH. This permits large node operators to consolidate into fewer validators while also allowing solo-stakers to earn compounding rewards and stake in more flexible increments.", "Abstract": "Increases the constantMAX_EFFECTIVE_BALANCE, while keeping the minimum staking balance32 ETH. This permits large node operators to consolidate into fewer validators while also allowing solo-stakers to earn compounding rewards and stake in more flexible increments.", "Motivation": "As of October 3, 2023, there are currently over 830,000 validators participating in the consensus layer. The size of this set continues to grow due, in part, to theMAX_EFFECTIVE_BALANCE, which limits the stake of a single validator to32 ETH. This leads to large amounts of \u201credundant validators\u201d, which are controlled by a single entity, possibly running on the same beacon node, but with distinct BLS signing keys. The limit on theMAX_EFFECTIVE_BALANCEis technical debt from the original sharding design, in which subcommittees (not the attesting committee but the committee calculated inis_aggregator) needed to be majority honest. As a result, keeping the weights of subcommittee members approximately equal reduced the risk of a single large validator containing too much influence. Under the current design, these subcommittees are only used for attestation aggregation, and thus only have a1/Nhonesty assumption.", "Specification": "The new consolidation request is anEIP-7685request with type0x02consisting of the following fields:", "Constants": "The new consolidation request is anEIP-7685request with type0x02consisting of the following fields:", "Execution layer": "The new consolidation request is anEIP-7685request with type0x02consisting of the following fields:", "Consensus layer": "The defining features of this EIP are:", "Rationale": "This EIP aims to reduce the total number of validators without changing anything about the economic security of the protocol. It provides a mechanism by which large node operators who control significant amounts of stake can consolidate into fewer validators. We analyze the reasoning behind each of the core features.", "Increasing theMAX_EFFECTIVE_BALANCE, while creating aMIN_ACTIVATION_BALANCE": "While increasing theMAX_EFFECTIVE_BALANCEto allow larger-stake validators, it is important to keep the lower bound of32 ETH(by introducing a new constant \u2013MIN_ACTIVATION_BALANCE) to encourage solo-staking.", "Allowing for multiple validator indices to be combined through the protocol": "For large staking pools that already control thousands of validators, exiting and re-entering would be extremely slow and costly. The adoption of the EIP will be much higher by allowing in-protocol consolidation.", "Adding execution layer partial withdrawals (part ofEIP-7002)": "For validators that choose to raise their effective balance ceiling, allowing for custom partial withdrawals triggered from the execution layer increases the flexibility of the staking configurations. Validators can choose when and how much they withdraw but will have to pay gas for the EL transaction.", "Making the initial slashing penalty negligible": "To encourage consolidation, we could modify the slashing penalties. The biggest hit comes from the initial penalty of1/32of the validator\u2019s effective balance. Since this scales linearly on the effective balance, the higher-stake validators directly incur higher risk. By changing the scaling properties, we could make consolidation more attractive.", "Consolidation contract parameter values": "The consolidation smart contract uses a fee mechanism to rate limit the number of requests per block. Details of the fee mechanism are available inEIP-7002.", "Backwards Compatibility": "This EIP introduces backward incompatible changes to the block validation rule set and must be accompanied by a hard fork. These changes do not break anything related to current user activity and experience.", "Security Considerations": "This change modifies committees and churn, but doesn\u2019t significantly impact the security properties.", "Security of attestation committees": "Given full consolidation as the worst case, the probability of an adversarial takeover of a committee remains low. Even in a high consolidation scenario, the required share of honest validators remains well below the 2/3 supermajority needed for finality.", "Aggregator selection": "In the original sharding roadmap, subcommittees were required to be secure with extremely high probability. Now with the sole responsibility of attestation aggregation, we only require each committee to have at least one honest aggregator. Currently, aggregators are selected through a VRF lottery, targeting several validator units that can be biased by non-consolidated attackers. This proposal changes the VRF lottery to consider weight, so the probability of having at least one honest aggregator is not worse.", "Proposer selection probability": "Proposer selection is already weighted by the ratio of their effective balance toMAX_EFFECTIVE_BALANCE. Due to the lower probabilities, this change will slightly increase the time it takes to calculate the next proposer index.", "Sync committee selection probability": "Sync committee selection is also already weighted by effective balance, so this proposal does not require modifications to the sync protocol. Light clients can still check that a super-majority of participants have signed an update irrespective of their weights since we maintain a weight-based selection probability.", "Churn invariants": "This proposal maintains the activation and exit churn invariants limiting active weight instead of validator count. Balance top-ups are now handled explicitly, being subject to the same activation queue as full deposits.", "Fee Overpayment": "Calls to the system contract require a fee payment defined by the current contract state. Overpaid fees are not returned to the caller. It is not generally possible to compute the exact required fee amount ahead of time. When adding a consolidation request from a contract, the contract can perform a read operation to check for the current fee and then pay exactly the required amount. Here is an example in Solidity:", "Consolidation queue hard limit": "Consolidations exceeding the hard limit of the consolidation queue (262,144 requests) will be discarded by the consensus layer and will need to be re-submitted,\nnote that the fee is not refunded in this case.", "System Call failure": "Although the likelihood of a failed system call toCONSOLIDATION_REQUEST_PREDEPLOY_ADDRESSis extremely low, the behavior in such cases is well-defined: the block is marked as invalid. This consideration directly follows fromEIP-7002", "Empty Code failure": "This EIP should not have been activated if there is no code present atCONSOLIDATION_REQUEST_PREDEPLOY_ADDRESS(i.e., if the chain is not \u201cready\u201d). This is also similar to the consideration inEIP-7002", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7523, "url": "https://eips.ethereum.org/EIPS/eip-7523", "title": "2024-03-26", "authors": ["Empty accounts deprecation"], "sections": {"EIP-7523: Empty accounts deprecation": "This EIP prohibits the state of any post-merge network from containing empty accounts. Since no empty accounts exist outside the testsuite and no new ones can be created this requirement is already achieved in practice. An explicit ban reduces technical debt going forward.", "Prohibit empty accounts on post-merge networks": "This EIP prohibits the state of any post-merge network from containing empty accounts. Since no empty accounts exist outside the testsuite and no new ones can be created this requirement is already achieved in practice. An explicit ban reduces technical debt going forward.", "Abstract": "This EIP prohibits the state of any post-merge network from containing empty accounts. Since no empty accounts exist outside the testsuite and no new ones can be created this requirement is already achieved in practice. An explicit ban reduces technical debt going forward.", "Motivation": "The possibility of empty accounts is a historical artifact of the early history of Ethereum. The only networks that have ever been capable of containing them are Ethereum Mainnet, the deprecated testnet Ropsten, Etheruem Classic Mainnet and various Ethereum Classic testnets. All remaining empty accounts on Mainnet were cleared in block14049881(transaction0xf955834bfa097458a9cf6b719705a443d32e7f43f20b9b0294098c205b4bcc3d) and a similar transaction was sent on Ethereum Classic. None of the other myriad EVM-compatible networks are old enough to have empty accounts and there is no realistic prospect that anyone will encounter an empty account in a production context.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "This EIP was drafted to be the simplest possible way of eliminating the long term technical debt imposed by empty accounts. The Merge was chosen as a natural easily identifiable cutoff point.", "Backwards Compatibility": "As EIP does not change any behaviour that can occur outside the testsuite, it has no backwards compatibility consequences.", "Security Considerations": "The validity of this EIP is dependent on the assertion that all empty accounts on Ethereum Mainnet were cleared prior to the merge. This should be subject to appropriate verification.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7549, "url": "https://eips.ethereum.org/EIPS/eip-7549", "title": "2025-02-21", "authors": ["Move committee index outside Attestation"], "sections": {"EIP-7549: Move committee index outside Attestation": "Move the committeeindexfield outside of the signed Attestation message to allow aggregation of equal consensus votes.", "Move committee index outside of the signed Attestation message": "Move the committeeindexfield outside of the signed Attestation message to allow aggregation of equal consensus votes.", "Abstract": "Move the committeeindexfield outside of the signed Attestation message to allow aggregation of equal consensus votes.", "Motivation": "This proposal aims to make Casper FFG clients more efficient by reducing the average number of pairings needed to verify consensus rules. While all types of clients can benefit from this EIP, ZK circuits proving Casper FFG consensus are likely to have the most impact.", "Specification": "This requires no changes to the Execution Layer.", "Execution layer": "This requires no changes to the Execution Layer.", "Consensus layer": "The full specification of the proposed change can be found in/specs/electra/beacon-chain.md.", "Rationale": "Theindexfield inAttestationDatacan be deprecated by:", "Deprecation strategy": "Theindexfield inAttestationDatacan be deprecated by:", "MAX_ATTESTATIONSvalue": "The maximum size of an attestation increases, with a bitfield 64 times larger on networks with maxed committees.MAX_ATTESTATIONSvalue is reduced to limit the beacon block size while still increasing the total capacity of votes. A value of 8 increases the voting capacity by 4 while having the same attestation space size with a network of 1.2M active indices.\nRead the detailshere.", "MAX_ATTESTER_SLASHINGSvalue": "On-chainAttesterSlashingincludes a list of participants\u2019 indices. With this EIP the worst-case size increases by 64 times, resulting in an uncompressed size of 488 KB perAttesterSlashingin a network of 1M validators. Snappy compression reduces it to 320 KB, which is still significant. To bound the maximum size of the block this proposal reducesMAX_ATTESTER_SLASHINGSfrom 2 to 1, the minimum value.\nRead the detailshere.", "UsingBitvectorforcommittee_bits": "Thecommittee_bitssequence has a variable length with the max sizeMAX_COMMITTEES_PER_SLOT = 64. Encoding of theBitlistincludes its actual length which doubles the size of thecommittee_bitscomparing to theBitvectortype. Beacon chain state transition ensures correctness of thecommittee_bitswhen effective number of committees in a slot is less than its max value.", "Backwards Compatibility": "This EIP introduces backward incompatible changes to the block validation rule set on the consensus layer and must be accompanied by a hard fork.", "Security Considerations": "Because the on-chainAttestationcontainer changes, attestations from the prior fork can\u2019t be included in post-electra blocks. Therefore the first block after the fork may have zero attestations. LMD votes can still be applied to fork-choice viaon_attestationhandler, so there will be only a 1/32 loss of FFG votes. Attesters assigned to the last slot of the fork will incur one epoch worth of offline penalties. One possible mitigation is to change the Electra block body type to allow including attestations from both forks. However, the mitigation increases complexity for little gain so this proposal chooses to not address the issue.", "First block after the fork": "Because the on-chainAttestationcontainer changes, attestations from the prior fork can\u2019t be included in post-electra blocks. Therefore the first block after the fork may have zero attestations. LMD votes can still be applied to fork-choice viaon_attestationhandler, so there will be only a 1/32 loss of FFG votes. Attesters assigned to the last slot of the fork will incur one epoch worth of offline penalties. One possible mitigation is to change the Electra block body type to allow including attestations from both forks. However, the mitigation increases complexity for little gain so this proposal chooses to not address the issue.", "Mutation over gossip": "Moving theindexfield outside of the signed message allows malicious mutation only on the p2p gossip topicbeacon_attestation_${subnet_id}. Everywhere else, theAttestationmessage is wrapped with an outer signature that prevents mutation.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7610, "url": "https://eips.ethereum.org/EIPS/eip-7610", "title": "2024-11-20", "authors": ["Revert creation in case of non-empty storage"], "sections": {"EIP-7610: Revert creation in case of non-empty storage": "This EIP causes contract creation to throw an error when attempted at an address with pre-existing storage.", "Revert contract creation if address already has the non-empty storage": "This EIP causes contract creation to throw an error when attempted at an address with pre-existing storage.", "Abstract": "This EIP causes contract creation to throw an error when attempted at an address with pre-existing storage.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "EIP-684 defines two conditions for contract deployment: the destination address must have zero nonce and zero code length. Unfortunately, this is not sufficient. BeforeEIP-161was applied, the nonce of a newly deployed contract remained set to zero. Therefore, it was entirely possible to create a contract with a zero nonce and zero code length but with non-empty storage, if slots were set in the constructor. There exists 28 such contracts on Ethereum mainnet at this time.", "Backwards Compatibility": "This is an execution layer upgrade, and so it requires a hard fork.", "Test Cases": "There exists quite a number of tests in the ethereum tests repo as well as in the execution spec tests, which test the scenario of deployment to targets with non-empty storage. These tests have been considered problematic in the past; Reth and EELS both intentionally implement a version of the account reset solely to pass the tests. Py-evm declared the situation impossible and never implemented account reset.", "Security Considerations": "This EIP is a security upgrade: it enforces the imutability of deployed code.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7623, "url": "https://eips.ethereum.org/EIPS/eip-7623", "title": "2025-03-01", "authors": ["Increase calldata cost"], "sections": {"EIP-7623: Increase calldata cost": "The current calldata pricing permits EL payloads of up to 7.15 MB, while the average size is much smaller at around 100 KB.\nThis EIP proposes adjusting the calldata cost to reduce the maximum possible block size and its variance without negatively impacting regular users.\nThis is achieved by increasing calldata costs for transactions that predominantly post data.", "Increase calldata cost to reduce maximum block size": "The current calldata pricing permits EL payloads of up to 7.15 MB, while the average size is much smaller at around 100 KB.\nThis EIP proposes adjusting the calldata cost to reduce the maximum possible block size and its variance without negatively impacting regular users.\nThis is achieved by increasing calldata costs for transactions that predominantly post data.", "Abstract": "The current calldata pricing permits EL payloads of up to 7.15 MB, while the average size is much smaller at around 100 KB.\nThis EIP proposes adjusting the calldata cost to reduce the maximum possible block size and its variance without negatively impacting regular users.\nThis is achieved by increasing calldata costs for transactions that predominantly post data.", "Motivation": "The block gas limit has not been increased sinceEIP-1559, while the average size of blocks has continuously increased due to the growing number of rollups posting data to Ethereum. Moreover, calldata costs have remained unchanged sinceEIP-2028.EIP-4844introduces blobs as a preferred method for data availability (DA).\nThis transition demands a reevaluation of calldata pricing, especially in order to address the disparity between average and maximum block sizes.\nBy introducing a floor cost dependent on the ratio of gas spent on EVM operations to calldata, this proposal aims to reduce the maximum block size to make room for additional blobs or potential block gas limit increases.", "Specification": "Lettokens_in_calldata = zero_bytes_in_calldata + nonzero_bytes_in_calldata * 4.", "Rationale": "The current maximum EL payload size is approximately 1.79 MB (30_000_000/16). It is possible to create payloads filled with zero bytes that expand to 7.15 MB. However, since blocks are typically compressed with Snappy at the P2P layer, zero-byte-heavy EL payloads generally compress to under 1.79 MB. The implementation ofEIP-4844increased the maximum possible compressed block size to approximately 2.54 MB.", "Backwards Compatibility": "This is a backwards incompatible gas repricing that requires a scheduled network upgrade.", "Security Considerations": "As the maximum possible block size is reduced, no security concerns have been raised.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7685, "url": "https://eips.ethereum.org/EIPS/eip-7685", "title": "2025-02-21", "authors": ["General purpose execution layer requests"], "sections": {"EIP-7685: General purpose execution layer requests": "This proposal defines a general purpose framework for storing contract-triggered\nrequests. It extends the execution header with a single field to store the\nrequest information. Requests are later on exposed to the consensus layer, which\nthen processes each one.", "A general purpose bus for sharing EL triggered requests with the CL": "This proposal defines a general purpose framework for storing contract-triggered\nrequests. It extends the execution header with a single field to store the\nrequest information. Requests are later on exposed to the consensus layer, which\nthen processes each one.", "Abstract": "This proposal defines a general purpose framework for storing contract-triggered\nrequests. It extends the execution header with a single field to store the\nrequest information. Requests are later on exposed to the consensus layer, which\nthen processes each one.", "Motivation": "The proliferation of smart contract controlled validators has caused there to be\na demand for additional EL triggered behaviors. By allowing these systems to\ndelegate administrative operations to their governing smart contracts, they can\navoid intermediaries needing to step in and ensure certain operations occur.\nThis creates a safer system for end users. By abstracting each individual request\ndetails from the EL, adding new request types is simpler and does not require an\nupdate on the execution block structure.", "Specification": "Arequestsobject consists of arequest_typebyte prepended to an opaque byte arrayrequest_data. Therequest_datacontains zero or more encoded request objects.", "Execution Layer": "Arequestsobject consists of arequest_typebyte prepended to an opaque byte arrayrequest_data. Therequest_datacontains zero or more encoded request objects.", "Consensus Layer": "Each proposal may choose how to extend the beacon chain types to include new EL request\ntypes.", "Rationale": "By having the bytes ofrequest_dataarray from second byte on be opaque bytes, rather\nthan an RLP (or other encoding) list, we can support different encoding formats for the\nrequest payload in the future such as SSZ, LEB128, or a fixed width format.", "Opaque byte array rather than an RLP array": "By having the bytes ofrequest_dataarray from second byte on be opaque bytes, rather\nthan an RLP (or other encoding) list, we can support different encoding formats for the\nrequest payload in the future such as SSZ, LEB128, or a fixed width format.", "Request source and validity": "This EIP makes no strict requirement where a request may come from nor when/how\na request must be validated. This is to provide future protocol designers\nmaximum flexibility.", "Ordering": "The ordering across types is ascending by type. This is to simplify the process\nof verifying that all requests which were committed to inrequests_hashmatch.", "Removing empty requests in commitment": "We exclude empty requests elements from therequests_hashcommitment in order to get a\nstable \u2018empty\u2019 hash value that is independent of the blockchain fork. For a block with no\nrequests data, therequests_hashis simplysha256(\"\").", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "TODO", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7691, "url": "https://eips.ethereum.org/EIPS/eip-7691", "title": "2025-04-01", "authors": ["Blob throughput increase"], "sections": {"EIP-7691: Blob throughput increase": "Increases the number of blobs in a block to provide more scale to Ethereum via L2 solution that rely on L1 data capacity.", "Increase the number of blobs to reach a new target and max of 6 and 9 blobs per block respectively": "Increases the number of blobs in a block to provide more scale to Ethereum via L2 solution that rely on L1 data capacity.", "Abstract": "Increases the number of blobs in a block to provide more scale to Ethereum via L2 solution that rely on L1 data capacity.", "Motivation": "Ethereum, with its rollup centric roadmap, scales by relying on L2. Since the Dencun fork, the blob gas target and maximum was set to 3/6 respectively. The blob gas limit was arrived at based on a series of big block tests performed on the Ethereum mainnet network as well as a series of testnets. The values were chosen cautiously, as it\u2019s extremely hard to predict the exact p2p behaviour of Ethereum mainnet.", "Specification": "MAX_BLOBS_PER_BLOCK_ELECTRAandTARGET_BLOBS_PER_BLOCK_ELECTRAare consumed by the consensus layer clients, and starting atPECTRA_FORK_EPOCHreplace the respective old max and target values.", "Parameters": "MAX_BLOBS_PER_BLOCK_ELECTRAandTARGET_BLOBS_PER_BLOCK_ELECTRAare consumed by the consensus layer clients, and starting atPECTRA_FORK_EPOCHreplace the respective old max and target values.", "Rationale": "The EIP aims to minimize the amount of testing and implementation effort from the perspective of the client teams, to allow for more resources to be allocated to peerDAS and other scaling research.", "Simplicity": "The EIP aims to minimize the amount of testing and implementation effort from the perspective of the client teams, to allow for more resources to be allocated to peerDAS and other scaling research.", "Update Fraction": "The original target and max values fromEIP-4844were at a 1:2 ratio. As a consequence, responsiveness to full and empty blob sections was symmetrical:", "Backwards Compatibility": "The consensus clients would continue to useMAX_BLOBS_PER_BLOCKandTARGET_BLOBS_PER_BLOCKfor the deneb fork and once theELECTRAfork is active, they would useMAX_BLOBS_PER_BLOCK_ELECTRAandTARGET_BLOBS_PER_BLOCK_ELECTRArespectively.", "Security Considerations": "Through the use of big block/blob tests on Ethereum mainnet as well as testnets, we can earn a high degree of certainty that the blob limit increase would not negatively impact the network. These tests as well as the associated analysis can be performed mostly by non-client team entities, with minimal input required. Since the changes are quite contained, the EIP should be able to reduce the risk of the blob limit increase.", "Network Impacts": "Through the use of big block/blob tests on Ethereum mainnet as well as testnets, we can earn a high degree of certainty that the blob limit increase would not negatively impact the network. These tests as well as the associated analysis can be performed mostly by non-client team entities, with minimal input required. Since the changes are quite contained, the EIP should be able to reduce the risk of the blob limit increase.", "Stability Around Fork Epoch": "A blob limit increase at the fork transition is relatively straightforward from an implementation perspective. We would need to deploy an increased amount of monitoring around the fork epoch, but after a period of stability we can assume that the blob limit increase was successful, reducing any unexpected co-ordination efforts.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7702, "url": "https://eips.ethereum.org/EIPS/eip-7702", "title": "2025-04-01", "authors": ["Set EOA account code"], "sections": {"EIP-7702: Set EOA account code": "Add a new transaction type that adds a list of[chain_id, address, nonce,\ny_parity, r, s]authorization tuples. For each tuple, write a delegation\ndesignator(0xef0100 || address)to the signing account\u2019s code. All code\nexecuting operations must load the code pointed to by the designator.", "Add a new tx type that permanently sets the code for an EOA": "Add a new transaction type that adds a list of[chain_id, address, nonce,\ny_parity, r, s]authorization tuples. For each tuple, write a delegation\ndesignator(0xef0100 || address)to the signing account\u2019s code. All code\nexecuting operations must load the code pointed to by the designator.", "Abstract": "Add a new transaction type that adds a list of[chain_id, address, nonce,\ny_parity, r, s]authorization tuples. For each tuple, write a delegation\ndesignator(0xef0100 || address)to the signing account\u2019s code. All code\nexecuting operations must load the code pointed to by the designator.", "Motivation": "There is a lot of interest in adding short-term functionality improvements to\nEOAs, increasing the usability of applications and in some cases allowing\nimproved security. Three particular applications include:", "Specification": "We introduce a newEIP-2718transaction, \u201cset code\ntransaction\u201d, where theTransactionTypeisSET_CODE_TX_TYPEand theTransactionPayloadis the RLP serialization of the following:", "Parameters": "We introduce a newEIP-2718transaction, \u201cset code\ntransaction\u201d, where theTransactionTypeisSET_CODE_TX_TYPEand theTransactionPayloadis the RLP serialization of the following:", "Set Code Transaction": "We introduce a newEIP-2718transaction, \u201cset code\ntransaction\u201d, where theTransactionTypeisSET_CODE_TX_TYPEand theTransactionPayloadis the RLP serialization of the following:", "Rationale": "ThePER_AUTH_BASE_COSTis the cost to process the authorization tuple and set\nthe delegation destination. We are able to compute a fair cost for this\noperation by reviewing its impact on the system:", "Cost of Delegation": "ThePER_AUTH_BASE_COSTis the cost to process the authorization tuple and set\nthe delegation destination. We are able to compute a fair cost for this\noperation by reviewing its impact on the system:", "No initcode": "Running initcode is not desirable for many reasons. The chief concern is it\u2019s\nunnatural. Initcode is intended to initialize and deploy contracts. With this\nEIP, it will take on a new role of determining whether it is appropriate to\ndeploy code to the EOA. Suppose a user only wants code deployed to their account\nif they also have an operation bundled with the general transaction calldata.\nThis gives EOAs a unique power to control when and what code executes in their\naccount. AlthoughEIP-7702as written still allows this to a\ndegree, the lack of programmability in the decision will force wallets to not\nsign many authorization tuples and instead focus on signing only a tuple\npointing to a configurable proxy. This affords EOAs a similar experience to\nsmart contract wallets.", "Creation by template": "Initcode or not, there is a question of how users should specify the code they\nintend to run in their account. The two main options are to specify the bytecode\ndirectly in the transaction or to specify a pointer to the code. The simplest\npointer would just be the address of some code deployed on-chain.", "Lack of instruction prohibition": "Consistency is a valuable property in the EVM, both from an implementation\nperspective and a user understanding perspective. Despite considering bans on\nseveral families of instructions in the context of EOAs, the authors feel there\nis not a compelling reason to do so. It will force smart contract wallets and\nEOA smart contract wallets to proceed down distinct paths of contract\ndevelopment.", "Signature structure": "The signature scheme in this EIP supports flexible design patterns, allowing for\nboth full delegation toaddressand more protected delegations toaddress.", "Self-sponsoring: allowingtx.originto set code": "Allowingtx.originto set code enables simple transaction batching, where the\nsender of the outer transaction would be the signing account. The ERC-20\napprove-then-transfer pattern, which currently requires two separate\ntransactions, could be completed in a single transaction with this proposal.", "Forward-compatibility with future account abstraction": "This EIP is designed to be very forward-compatible with endgame account\nabstraction, without over-enshrining any fine-grained details ofERC-4337or RIP-7560.", "Clearing Delegation Designations": "A general design goal of state transition changes is to minimize the number of\nspecial cases an EIP has. In early iterations, this EIP resisted a special case\nfor clearing an account\u2019s delegation designation.", "Delegation of code execution only": "Other code retrieving operations likeEXTCODEHASHdo not automatically follow\ndelegations, they operate on the delegation designator itself. If instead\ndelegations were followed, an account would be able to temporarily masquerade as\nhaving a particular codehash, which would break contracts that rely on\ncodehashes as an indicator of possible account behavior. A change of behavior in\na contract is currently only possible if its code explicitly allows it (in\nparticular viaDELEGATECALL), and a change of codehash is only possible in the\npresence ofSELFDESTRUCT(and as of Cancun only in the same transaction as\ncontract creation), so choosing to follow delegations inEXTCODE*opcodes\nwould have created a new type of account that broke prior assumptions.", "Charge maximum cost upfront": "While computing the intrinsic gas cost, the transaction is charged the\nworst-case cost for each delegation. Later, while processing the authorization\nlist, a refund is issued if the account already exists in state. This mechanism\nis designed to avoid state lookups for each authorization when computing the\nintrinsic gas and can quickly determine the validity of the transaction with\nonly a state lookup on the sender\u2019s account.", "Backwards Compatibility": "This EIP breaks the invariant that an account balance can only decrease as a\nresult of transactions originating from that account. It also breaks the\ninvariant that an EOA nonce may not increase after transaction execution has\nbegun. These breakages have consequences for mempool design, and for other EIPs\nsuch as inclusion lists. However, because the accounts are listed statically in\nthe outer transaction, it is possible to modify transaction propagation rules so\nthat conflicting transactions are not forwarded.", "Security Considerations": "The following is a non-exhaustive list of checks/pitfalls/conditions that\ndelegate contractsshouldbe wary of and require a signature over from the\naccount\u2019s authority:", "Secure delegation": "The following is a non-exhaustive list of checks/pitfalls/conditions that\ndelegate contractsshouldbe wary of and require a signature over from the\naccount\u2019s authority:", "Setting code astx.origin": "Allowing the sender of an EIP-7702 to also set code has the possibility to:", "Sponsored transaction relayers": "It is possible for theauthorizedaccount to cause sponsored transaction\nrelayers to spend gas without being reimbursed by either invalidating the\nauthorization (i.e., increasing the account\u2019s nonce) or by sweeping the relevant\nassets out of the account. Relayers should be designed with these cases in mind,\npossibly by requiring a bond to be deposited or by implementing a reputation\nsystem.", "Front running initialization": "Smart contract wallet developers must consider the implications of setting code\nin an account without execution. Contracts are normally deployed by executing\ninitcode to determine the exact code to be placed in the account. This gives\ndevelopers the opportunity to initialize storage slots at the same time. The\ninitial values of the account cannot be replaced by an observer, because they\nare either signed over by an EOA in the case of a creation transaction or they\nare committed to by computing the contract\u2019s address deterministically from the\nhash of the initcode.", "Transaction propagation": "Allowing EOAs to behave as smart contracts via the delegation designation poses\nsome challenges for transaction propagation. Traditionally, EOAs have only be\nable to send value via a transaction. This invariant allows nodes to statically\ndetermine the validity of transactions for that account. In other words, a\nsingle transaction has only been able to invalidate transactions pending from\nthe senders account.", "Storage management": "Changing an account\u2019s delegation is a security-critical operation that should\nnot be done lightly, especially if the newly delegated code is not purposely\ndesigned and tested as an upgrade to the old one.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 663, "url": "https://eips.ethereum.org/EIPS/eip-663", "title": "SWAPN, DUPN and EXCHANGE instructions", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Charles Cooper\u00a0(", "@charles-cooper", ")", "Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-663: SWAPN, DUPN and EXCHANGE instructions": "Currently,SWAP*andDUP*instructions are limited to a stack depth of 16. Introduce three new instructions,SWAPN,DUPNandEXCHANGEwhich lift this limitation and allow accessing the stack at higher depths.", "Introduce additional instructions for manipulating the stack which allow accessing the stack at higher depths": "Currently,SWAP*andDUP*instructions are limited to a stack depth of 16. Introduce three new instructions,SWAPN,DUPNandEXCHANGEwhich lift this limitation and allow accessing the stack at higher depths.", "Abstract": "Currently,SWAP*andDUP*instructions are limited to a stack depth of 16. Introduce three new instructions,SWAPN,DUPNandEXCHANGEwhich lift this limitation and allow accessing the stack at higher depths.", "Motivation": "While the stack is 1024 items deep, easy access is only possible for the top 16 items. Supporting more local variables is possible via manually keeping them in memory or through a \u201cstack to memory elevation\u201d in a compiler. This can result in complex and inefficient code.", "Specification": "We introduce three new instructions:", "Rationale": "Allowing dynamic selection of the arguments to swap, dup, or exchange could be used to prevent static analysis of the contents of the stack. Since static analysis is an important tool for security auditors we want to do what we can to make their jobs easier. Hence, the operands require an immediate argument that is not dynamic in nature.", "Use of an immediate argument": "Allowing dynamic selection of the arguments to swap, dup, or exchange could be used to prevent static analysis of the contents of the stack. Since static analysis is an important tool for security auditors we want to do what we can to make their jobs easier. Hence, the operands require an immediate argument that is not dynamic in nature.", "EOF-only": "Since this instruction depends on an immediate argument encoding, it can only be enabled within EOF. In legacy bytecode that encoding could contradict jumpdest-analysis.", "Size of immediate argument": "ForDUPNandSWAPNa 16-bit size was considered to accommodate the full stack space of 1024 items, however:", "Gas cost": "The gas cost for these operations is the same as for existingDUP*andSWAP*instructions, because they are just implemented as pointer swaps.", "EXCHANGEvsSWAPN": "As mentioned before,EXCHANGEis important to compilers implementing stack scheduling algorithms. Specifically, in the case that a stack item is scheduled to be consumed deeper in the stack (for instance, the 3rd item in the stack needs to be moved into 2nd position in order to be consumed by the next operation), that currently takes three instructions,SWAP2 SWAP3 SWAP2. However, in the EVM implementation, the implementation is just a pointer swap, so it could be implemented in a single instruction at no extra runtime cost to the client.", "Backwards Compatibility": "This has no effect on backwards compatibility because the opcodes were not previously allocated and the feature is only enabled in EOF.", "Test Cases": "Givenstack[]is a 0-based data structure, andn,mandimmare defined as according to the spec:", "Security Considerations": "The authors are not aware of any additional risks introduced here. The EVM stack is fixed at 1024 items and most implementations keep that in memory at all times. This change will increase the number of stack items accessible via single instruction.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3540, "url": "https://eips.ethereum.org/EIPS/eip-3540", "title": "EOF - EVM Object Format v1", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")", "Matt Garnett\u00a0(", "@lightclient", ")", "Piotr Dobaczewski\u00a0(", "@pdobacz", ")"], "sections": {"EIP-3540: EOF - EVM Object Format v1": "We introduce an extensible and versioned container format for the EVM with a once-off validation at deploy time. The version described here brings the tangible benefit of code and data separation, and allows for easy introduction of a variety of changes in the future. This change relies on the reserved byte introduced byEIP-3541.", "EOF is an extensible and versioned container format for EVM bytecode with a once-off validation at deploy time.": "We introduce an extensible and versioned container format for the EVM with a once-off validation at deploy time. The version described here brings the tangible benefit of code and data separation, and allows for easy introduction of a variety of changes in the future. This change relies on the reserved byte introduced byEIP-3541.", "Abstract": "We introduce an extensible and versioned container format for the EVM with a once-off validation at deploy time. The version described here brings the tangible benefit of code and data separation, and allows for easy introduction of a variety of changes in the future. This change relies on the reserved byte introduced byEIP-3541.", "Motivation": "On-chain deployed EVM bytecode contains no pre-defined structure today. Code is typically validated in clients to the extent ofJUMPDESTanalysis at runtime, every single time prior to execution. This poses not only an overhead, but also a challenge for introducing new or deprecating existing features.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Remarks": "If code starts with theMAGIC, it is considered to be EOF formatted, otherwise it is considered to belegacycode. For clarity, theMAGICtogether with a version numbernis denoted as theEOFn prefix, e.g.EOF1 prefix.", "Code validation": "We introducecode validationfor new contract creation. To achieve this, we define a format called EVM Object Format (EOF), containing a version indicator, and a ruleset of validity tied to a given version.", "Container specification": "EOF container is a binary format with the capability of providing the EOF version number and a list of EOF sections.", "EOF version 1": "EOF version 1 is made up of several EIPs, including this one. Some values in this specification are only discussed briefly. To understand the full scope of EOF, it is necessary to review each EIP in-depth.", "Changes to execution semantics": "For an EOF contract:", "Rationale": "EVM and/or account versioning has been discussed numerous times over the past years. This proposal aims to learn from them.\nSee \u201cEthereum account versioning\u201d on the Fellowship of Ethereum Magicians Forum for a good starting point.", "Execution vs. creation time validation": "This specification introduces creation time validation, which means:", "The MAGIC": "NOTE: This EIP MUST NOT be enabled on chains which contain bytecodes starting withMAGICand not being valid EOF.", "EOF version range start with 1": "The version number 0 will never be used in EOF, so we can call legacy codeEOF0.\nAlso, implementations may use APIs where 0 version number denotes legacy code.", "Section structure": "We have considered different questions for the sections:", "Data-only contracts": "See sectionLack ofEXTDATACOPYin EIP-7480.", "EOF1 contracts can onlyDELEGATECALLEOF1 contracts": "Currently contracts can selfdestruct in three different ways (directly throughSELFDESTRUCT, indirectly throughCALLCODEand indirectly throughDELEGATECALL).EIP-3670disables the first two possibilities, however the third possibility remains. Allowing EOF1 contracts to onlyDELEGATECALLother EOF1 contracts allows the following strong statement: EOF1 contract can never be destructed. Attacks based onSELFDESTRUCTcompletely disappear for EOF1 contracts. These include destructed library contracts (e.g. Parity Multisig).", "EOF1 containers have a size limit": "Imposing an EOF-validation time limit for the size of EOF containers provides a reference limit of how large the containers should EVM implementations be able to handle when validating and processing containers.MAX_INITCODE_SIZEwas chosen for EOF1, as it is what contract creation currently allows for.", "kind_datacould be0x04not0xff": "Putting the data section last as0xffhas the advantage of aligning with the fact that it always comes last. We\u2019re avoiding a situation that a new section kind would need to go before the data section and break the section kind ordering. At the same time, data section being last is advantageous because it is the section which gets data appended to during contract deployment.", "Backwards Compatibility": "This is a breaking change given that any code starting with0xEFwas not deployable before (and resulted in exceptional abort if executed), but now some subset of such codes can be deployed and executed successfully.", "Security Considerations": "With the anticipated EOF extensions, the validation is expected to have linear computational and space complexity.\nWe think that the validation cost is sufficiently covered by:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3670, "url": "https://eips.ethereum.org/EIPS/eip-3670", "title": "EOF - Code Validation", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")"], "sections": {"EIP-3670: EOF - Code Validation": "Introduce code validation at contract creation time for EOF formatted (EIP-3540)\ncontracts. Reject contracts which contain truncatedPUSH-data or undefined instructions.\nLegacy bytecode (code which is not EOF formatted) is unaffected by this change.", "Validate EOF bytecode for correctness at the time of deployment.": "Introduce code validation at contract creation time for EOF formatted (EIP-3540)\ncontracts. Reject contracts which contain truncatedPUSH-data or undefined instructions.\nLegacy bytecode (code which is not EOF formatted) is unaffected by this change.", "Abstract": "Introduce code validation at contract creation time for EOF formatted (EIP-3540)\ncontracts. Reject contracts which contain truncatedPUSH-data or undefined instructions.\nLegacy bytecode (code which is not EOF formatted) is unaffected by this change.", "Motivation": "Currently existing contracts require no validation of correctness and EVM implementations can decide\nhow they handle truncated bytecode or undefined instructions. This change aims to bring code\nvalidity into consensus, so that it becomes easier to reason about bytecode.\nMoreover, EVM implementations may require fewer paths to decide which instruction is valid in\nthe current execution context.", "EOF1 forward compatibility": "The EOF1 format provides following forward compatibility properties:", "Specification": "This feature is introduced on the same block EIP-3540 is enabled, therefore every EOF1-compatible bytecode MUST be validated according to these rules.", "Rationale": "Allowing implicit zero immediate data forPUSHinstructions introduces inefficiencies to EVM implementations without any practical use-case (the value of aPUSHinstruction at the code end cannot be observed by EVM). This EIP requires all immediate bytes to be explicitly present in the code.", "Immediate data": "Allowing implicit zero immediate data forPUSHinstructions introduces inefficiencies to EVM implementations without any practical use-case (the value of aPUSHinstruction at the code end cannot be observed by EVM). This EIP requires all immediate bytes to be explicitly present in the code.", "Rejection of deprecated instructions": "The deprecated instructionsCALLCODE(0xf2) andSELFDESTRUCT(0xff) are removed from thevalid_opcodeslist to prevent their use in the future.", "BLOCKHASH instruction": "TheBLOCKHASHinstruction is well replaced by the system contract introduced inEIP-2935.\nHowever, despite a replacement being introduced this opcode has not been deprecated.\nThis opcode will remain valid in EOF not to differentiate from legacy bytecode.", "Backwards Compatibility": "This change poses no risk to backwards compatibility, as it is introduced at the same time EIP-3540 is. The validation does not cover legacy bytecode (code which is not EOF formatted).", "Test Cases": "Each case should be tested by submitting an EOF container to EOF contract creation (as specced out in a separate EIP). Each case should be tested with code placed in code sections at different indices.", "Contract creation": "Each case should be tested by submitting an EOF container to EOF contract creation (as specced out in a separate EIP). Each case should be tested with code placed in code sections at different indices.", "Valid codes": "SeeSecurity Considerations of EIP-3540.", "Invalid codes": "SeeSecurity Considerations of EIP-3540.", "Reference Implementation": "SeeSecurity Considerations of EIP-3540.", "Security Considerations": "SeeSecurity Considerations of EIP-3540.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 4200, "url": "https://eips.ethereum.org/EIPS/eip-4200", "title": "EOF - Static relative jumps", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")"], "sections": {"EIP-4200: EOF - Static relative jumps": "Three new EVM jump instructions are introduced (RJUMP,RJUMPIandRJUMPV) which encode destinations as signed immediate values. These can be useful in the majority of (but not all) use cases and offer a cost reduction.", "RJUMP, RJUMPI and RJUMPV instructions with a signed immediate encoding the jump destination": "Three new EVM jump instructions are introduced (RJUMP,RJUMPIandRJUMPV) which encode destinations as signed immediate values. These can be useful in the majority of (but not all) use cases and offer a cost reduction.", "Abstract": "Three new EVM jump instructions are introduced (RJUMP,RJUMPIandRJUMPV) which encode destinations as signed immediate values. These can be useful in the majority of (but not all) use cases and offer a cost reduction.", "Motivation": "A recurring discussion topic is that EVM only has a mechanism for dynamic jumps. They provide a very flexible architecture with only 2 (!) instructions. This flexibility comes at a cost however: it makes analysis of code more complicated and it also (partially) resulted in the need to have theJUMPDESTmarker.", "Specification": "We introduce three new instructions on the same block numberEIP-3540is activated on:", "Rationale": "We chose relative addressing in order to support code which is relocatable. This also means a code snippet can be injected. A technique seen used prior to this EIP to achieve the same goal was to inject code likePUSHn PC ADD JUMPI.", "Relative addressing": "We chose relative addressing in order to support code which is relocatable. This also means a code snippet can be injected. A technique seen used prior to this EIP to achieve the same goal was to inject code likePUSHn PC ADD JUMPI.", "Immediate size": "The signed 16-bit immediate means that the largest jump distance possible is 32767. In the case the bytecode atPC=0starts with anRJUMP, it will be possible to jump as far asPC=32770.", "PUSHn JUMPsequences": "If we chose absolute addressing, thenRJUMPcould be viewed similar to the sequencePUSHn JUMP(andRJUMPIsimilar toPUSHn JUMPI). In that case one could argue that instead of introducing a new instruction, such sequences should get a discount, because EVMs could optimise them.", "Relation to dynamic jumps": "The goal was not to completely replace the current control flow system of the EVM, but to augment it. There are many cases where dynamic jumps are useful, such as returning to the caller.", "Lack ofJUMPDEST": "JUMPDESTserves two purposes:", "RJUMPVfallback case": "If no match is found (i.e. thedefaultcase) in theRJUMPVinstruction execution will continue without branching. This allows for gaps in the arguments to be filled with0s, and a choice of implementation by the programmer. Alternate options would include exceptional aborts in case of no match.", "Backwards Compatibility": "This change poses no risk to backwards compatibility, as it is introduced at the same time EIP-3540 is. The new instructions are not introduced for legacy bytecode (code which is not EOF formatted).", "Test Cases": "TBA", "Validation": "TBA", "Execution": "TBA", "Security Considerations": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 4750, "url": "https://eips.ethereum.org/EIPS/eip-4750", "title": "EOF - Functions", "authors": ["Andrei Maiboroda\u00a0(", "@gumb0", ")", "Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")"], "sections": {"EIP-4750: EOF - Functions": "Introduce the ability to have several code sections in EOF-formatted (EIP-3540) bytecode, each one representing a separate subroutine/function. Two new opcodes,CALLFandRETF, are introduced to call and return from such a function. Dynamic jump instructions are disallowed.", "Individual sections for functions with `CALLF` and `RETF` instructions": "Introduce the ability to have several code sections in EOF-formatted (EIP-3540) bytecode, each one representing a separate subroutine/function. Two new opcodes,CALLFandRETF, are introduced to call and return from such a function. Dynamic jump instructions are disallowed.", "Abstract": "Introduce the ability to have several code sections in EOF-formatted (EIP-3540) bytecode, each one representing a separate subroutine/function. Two new opcodes,CALLFandRETF, are introduced to call and return from such a function. Dynamic jump instructions are disallowed.", "Motivation": "Currently, in the EVM everything is a dynamic jump. Languages like Solidity generate most jumps in a static manner (i.e. the destination is pushed to the stack right before,PUSHn .. JUMP). Unfortunately however this cannot be used by most EVM interpreters, because of added requirement of validation/analysis. This also restricts them from making optimisations and potentially reducing the cost of jumps.", "Specification": "The type section of EOF containers must adhere to following requirements:", "Type Section": "The type section of EOF containers must adhere to following requirements:", "New execution state in EVM": "A return stack is introduced, separate from the operand stack. It is a stack of items representing execution state to return to after function execution is finished. Each item is comprised of code section index and offset in the code section (PC value).", "New instructions": "We introduce two new instructions:", "Code Validation": "In addition to container format validation rules above, we extend code section validation rules (as defined inEIP-3670).", "Disallowed instructions": "Dynamic jump instructionsJUMP(0x56) andJUMPI(0x57) are invalid and their opcodes are undefined.", "Execution": "Alternative logic forRETFin the top frame could be to allow it during code validation and make it either:", "Rationale": "Alternative logic forRETFin the top frame could be to allow it during code validation and make it either:", "RETFin the top frame ends execution vs exceptionally halts vs is not allowed during validation": "Alternative logic forRETFin the top frame could be to allow it during code validation and make it either:", "\u201cMinimal\u201d function type": "Let\u2019s consider a trivial function with single instructionRETF.\nSuch function have the \u201cminimal\u201d type ofinputs = 0, outputs = 0.\nHowever, any other type likeinputs = k, outputs = kis also valid for such function.\nIt has been considered to enforce usage of the \u201cminimal\u201d type for all functions.\nThis requires additional validation rule that checks if any instruction in the function accesses the bottom stack operand.\nThis rule can be obeyed by compilers, but causes quite significant annoyance.\nOn the other hand, it provides close to zero benefits for the EVM implementations.\nIn the end, it has been decided that this is not enforced.", "Code section limit and instruction size": "The number of code sections is limited to 1024. This requires 2-byte immediate forCALLFand leaves room for increasing the limit in the future. The 256 limit (1-byte immediate) was discussed and concerns were raised that it might not be sufficient.", "NOPinstruction": "Instead of deprecatingJUMPDESTwe repurpose it asNOPinstruction, becauseJUMPDESTeffectively was a \u201cno-operation\u201d instruction and was already used as such in various contexts. It can be useful for some off-chain tooling, e.g. benchmarking EVM implementations (performance ofNOPinstruction is performance of EVM interpreter loop), as a padding to force code alignment, as a placeholder in dynamic code composition.", "DeprecatingJUMPDESTanalysis": "The purpose ofJUMPDESTanalysis was to find in code the validJUMPDESTbytes that do not happen to be insidePUSHimmediate data. Only dynamic jump instructions (JUMP,JUMPI) required destination to beJUMPDESTinstruction. Relative static jumps (RJUMPandRJUMPI) do not have this requirement and are validated once at deploy-time EOF instruction validation. Therefore, without dynamic jump instructions,JUMPDESTanalysis is not required.", "Backwards Compatibility": "This change poses no risk to backwards compatibility, as it is introduced only for EOF1 contracts, for which deploying undefined instructions is not allowed, therefore there are no existing contracts using these instructions. The new instructions are not introduced for legacy bytecode (code which is not EOF formatted).", "Security Considerations": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 4803, "url": "https://eips.ethereum.org/EIPS/eip-4803", "title": "Limit transaction gas to a maximum of 2^63-1", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-4803: Limit transaction gas to a maximum of 2^63-1": "Limit transaction gas to be between0and2^63-1.", "Valid transactions must have a reasonable gas limit": "Limit transaction gas to be between0and2^63-1.", "Abstract": "Limit transaction gas to be between0and2^63-1.", "Motivation": "The gas limit field in the transaction is specified to be an arbitrary long unsigned integer, but various clients put limits on this value. This EIP brings a reasonable limit into consensus.", "Specification": "Introduce one new restriction retroactively from genesis: any transaction is invalid and not includeable in a block, where the gas limit exceeds2^63-1.", "Rationale": "2^63-1is chosen because it allows representing the gas value as a signed integer, and so the out of gas check can be done as a simple \u201cless than zero\u201d check after subtraction.", "2^63-1vs2^64-1": "2^63-1is chosen because it allows representing the gas value as a signed integer, and so the out of gas check can be done as a simple \u201cless than zero\u201d check after subtraction.", "Consider2^31-1": "An alternative is considering a lower limit, because this can be handled easily in Javascript, since it handles numbers as floating point (the actual upper bound is2^53-1).", "Current limit": "Due to the nature of RLP encoding, there is no fixed upper bound for the value, but most implementations limit it to 256-bits. Furthermore, most client implementations (such as geth) internally handle gas as a 64-bit value.", "Backwards Compatibility": "While this is a breaking change, no actual effect should be visible.", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 5450, "url": "https://eips.ethereum.org/EIPS/eip-5450", "title": "EOF - Stack Validation", "authors": ["Andrei Maiboroda\u00a0(", "@gumb0", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Alex Beregszaszi\u00a0(", "@axic", ")", "Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-5450: EOF - Stack Validation": "Introduce extended validation of EOF code sections to guarantee that neither stack underflow nor overflow can happen during execution of validated contracts.", "Deploy-time validation of stack usage for EOF functions.": "Introduce extended validation of EOF code sections to guarantee that neither stack underflow nor overflow can happen during execution of validated contracts.", "Abstract": "Introduce extended validation of EOF code sections to guarantee that neither stack underflow nor overflow can happen during execution of validated contracts.", "Motivation": "The current EVM performs a number of validity checks for each executed instruction, such as checking\nfor instruction being defined, stack overflow and underflow, and enough amount of gas remaining.", "Specification": "Remark:We rely on the notions ofoperand stackandtype sectionas defined byEIP-4750.", "Code validation": "Remark:We rely on the notions ofoperand stackandtype sectionas defined byEIP-4750.", "Execution": "Given the deploy-time validation guarantees, an EVM implementation is not required anymore to have run-time stack underflow nor overflow checks for each executed instruction. The exception is theCALLFandJUMPFperforming operand stack overflow check for the entire called function.", "Rationale": "Any code section validated according to operand stack validation has the following properties:", "Properties of validated code": "Any code section validated according to operand stack validation has the following properties:", "Stack overflow check only in CALLF/JUMPF": "In this EIP, we provide a more efficient variant of the EVM where stack overflow check is performed only inCALLFandJUMPFinstructions using the called function\u2019smax_stack_heightinformation. This decreases flexibility of an EVM program becausemax_stack_heightcorresponds to the worst-case control-flow path in the function.", "Unreachable code": "The operand stack validation algorithm rejects any code having any unreachable instructions. This check can be performed very cheaply. It prevents deploying degenerated code. Moreover, it enables combining instruction validation and operand stack validation into single pass.", "Clean stack upon termination": "It is currently required that the operand stack is empty (in the current function context) after theRETFinstruction.\nOtherwise, theRETFsemantic would be more complicated. Fornfunction outputs andsthe stack height atRETFthe EVM would have to erases-nnon-top stack items and move thenstack items to the place of erased ones. Cost of such operation may be relatively cheap but is not constant.\nHowever, lifting the requirement and modifying theRETFsemantic as described above is backward\ncompatible and can be easily introduced in the future.", "More restrictive stack validation": "Originally another variant of stack validation was proposed, where instead of linear scan of the code section, all code paths were examined by following the target(s) of every jump instruction in a breadth-first-search manner, tracking stack height for each visited instruction and checking that for every possible code path to a particular instruction its stack height remains constant.", "Ordering of basic blocks": "The prerequisite to stack validation algorithm is ordering of code basic blocks in a way that no block is referenced only by backwards jump.", "Backwards Compatibility": "This change requires a \u201cnetwork upgrade,\u201d since it modifies consensus rules.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6206, "url": "https://eips.ethereum.org/EIPS/eip-6206", "title": "EOF - JUMPF and non-returning functions", "authors": ["Andrei Maiboroda\u00a0(", "@gumb0", ")", "Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Matt Garnett\u00a0(", "@lightclient", ")"], "sections": {"EIP-6206: EOF - JUMPF and non-returning functions": "This EIP allows for tail call optimizations in EOF functions (EIP-4750) by introducing a new instructionJUMPF, which jumps to a code section without adding a new return stack frame.", "Introduces instruction for chaining function calls.": "This EIP allows for tail call optimizations in EOF functions (EIP-4750) by introducing a new instructionJUMPF, which jumps to a code section without adding a new return stack frame.", "Abstract": "This EIP allows for tail call optimizations in EOF functions (EIP-4750) by introducing a new instructionJUMPF, which jumps to a code section without adding a new return stack frame.", "Motivation": "It is common for functions to make a call at the end of the routine only to then return.JUMPFoptimizes this behavior by changing code sections without needing to update the return stack.", "Specification": "We define a non-returning section as one that cannot return control to its caller section.", "Type section changes": "We define a non-returning section as one that cannot return control to its caller section.", "Execution Semantics": "A new instruction,JUMPF (0xe5), is introduced.", "Code Validation": "Let the definition oftype[i]be inherited fromEIP-4750and definestack_height_minandstack_height_maxto be the stack height bounds at a certain instruction during the instruction flow traversal.", "Rationale": "An alternative rule forJUMPFstack validation could require the target section\u2019s outputs to be exactly equal to the current section\u2019s outputs. Under such rule, a particular target section (a shared \u201chelper\u201d piece of code) would only \u201cmatch\u201d sections (requiring some shared \u201chelper\u201d code to execute before returning)with the same number of outputs.", "AllowingJUMPFto section with less outputs": "An alternative rule forJUMPFstack validation could require the target section\u2019s outputs to be exactly equal to the current section\u2019s outputs. Under such rule, a particular target section (a shared \u201chelper\u201d piece of code) would only \u201cmatch\u201d sections (requiring some shared \u201chelper\u201d code to execute before returning)with the same number of outputs.", "Backwards Compatibility": "This change is backward compatible as EOF does not allow undefined instructions to be used or deployed, meaning no contracts will be affected.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7069, "url": "https://eips.ethereum.org/EIPS/eip-7069", "title": "Revamped CALL instructions", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Danno Ferrin\u00a0(", "@shemnon", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")", "Charles Cooper\u00a0(", "@charles-cooper", ")"], "sections": {"EIP-7069: Revamped CALL instructions": "Introduce three new call instructions,EXTCALL,EXTDELEGATECALLandEXTSTATICCALL, with simplified semantics. Introduce another instruction,RETURNDATALOADfor loading a word from return data into stack. Modify the behavior ofRETURNDATACOPYinstruction executed within EOF formatted code (as defined byEIP-3540). The existing*CALLinstructions remain unchanged.", "Introduce EXTCALL, EXTDELEGATECALL and EXTSTATICCALL with simplified semantics": "Introduce three new call instructions,EXTCALL,EXTDELEGATECALLandEXTSTATICCALL, with simplified semantics. Introduce another instruction,RETURNDATALOADfor loading a word from return data into stack. Modify the behavior ofRETURNDATACOPYinstruction executed within EOF formatted code (as defined byEIP-3540). The existing*CALLinstructions remain unchanged.", "Abstract": "Introduce three new call instructions,EXTCALL,EXTDELEGATECALLandEXTSTATICCALL, with simplified semantics. Introduce another instruction,RETURNDATALOADfor loading a word from return data into stack. Modify the behavior ofRETURNDATACOPYinstruction executed within EOF formatted code (as defined byEIP-3540). The existing*CALLinstructions remain unchanged.", "Motivation": "Observability of gas has been a problem for very long. The system of gas has been (and likely must be) flexible in adapting to changes to both how Ethereum is used as well as changes in underlying hardware.", "Specification": "We introduce four new instructions:", "Rationale": "One major change from the originalCALLseries of instructions is that the caller has no control over the amount of gas passed in as part of the call. The number of cases where such a feature is essential are probably better served by direct protocol integration.", "Removing gas selectability": "One major change from the originalCALLseries of instructions is that the caller has no control over the amount of gas passed in as part of the call. The number of cases where such a feature is essential are probably better served by direct protocol integration.", "Stipend and 63/64th rule": "The purpose of the stipend is to have enough gas to emit logs (i.e. perform non-state-changing operations) when a \u201ccontract wallet\u201d is called. The stipend is only added when theCALLinstruction is used and the value is non-zero.", "Output buffers": "The functionality of specifying output buffer address is removed, because it is added complexity and in a large number of cases implementers prefer to useRETURNDATACOPYinstead. Even if they rely on the output buffer (like in the case of Vyper), they would still check the length withRETURNDATASIZE. In Solidity one exception is the case when the expected return size is known (i.e. non-dynamic return values), in this case Solidity still uses the output buffer. For these cases,RETURNDATALOADis introduced, which simplifies the workflow of copying returndata into a (known) output buffer and usingMLOADfrom there; instead,RETURNDATALOADcan be used directly.", "Status codes": "Current call instructions return a boolean value to signal success: 0 means failure, 1 means success. The Solidity compiler assumed this value is a boolean and thus uses the value as branch condition to status (if iszero(status) { /* failure */ }). This prevents us from introducing new status codes without breaking existing contracts. At the time of the design ofEIP-211the idea of return a specific code for revert was discussed, but ultimately abandoned for the above reason.", "Parameter order": "The order of parameters has been changed to move thevaluefield to be the last. This allows the instructions to have identical encoding with the exception of the last parameter, and simplifies EVM and compiler implementations slightly.", "Opcode encoding": "Instead of introducing three newEXT*CALLopcodes we have discussed a version with an immediate configuration byte (flags). There are two main disadvantages to this:", "CALLCODE": "SinceCALLCODEis deprecated, we do not introduce a counterpart here.", "Halting whentarget_addressis not a 20-byte ethereum addresses": "When existingCALLseries operations encounter an address that does not fit into 20 bytes the current behavior is to mask the address so that it fits into 20 bytes, ignoring all high bytes. For theEXT*CALLoperations a halt was chosen over treating the contract as empty for two reasons. First, it handles the case of sending value to an address that doesn\u2019t exist without having to create a special case. Second, it keeps thewarm_access_listfrom needing to track anything that is not a 20-byte ethereum address.", "New instructions undefined in legacy (only if this EIP is part of EOF)": "There is an alternative scenario where, in case this EIP is included as part of the greater EOF upgrade, the four new instructions areadditionallyavailable in legacy EVM. There is, however, a preference to limit changes to legacy EVM in the fork where EOF is included as well as in subsequent ones.", "RETURNDATALOADandRETURNDATACOPYpadding behavior": "This EIP initially proposed keeping the halt-on-OOB behavior of legacyRETURNDATACOPY. This makes compilers optimizations harder, because unnecessaryRETURNDATA*instructions cannot be optimized out without change to code semantics.", "EOF1 contracts canEXTDELEGATECALLonly EOF1 contracts": "Legacy contracts can selfdestruct in three different ways (directly throughSELFDESTRUCT, indirectly throughCALLCODEand indirectly throughDELEGATECALL).EIP-3670disables the first two possibilities, however the third possibility remains. Allowing EOF1 contracts toEXTDELEGATECALLonly other EOF1 contracts allows the following strong statement: EOF1 contract can never be destructed. Attacks based onSELFDESTRUCTcompletely disappear for EOF1 contracts. These include destructed library contracts (e.g. Parity Multisig).", "Backwards Compatibility": "No existing instructions are changed and so we do not think any backwards compatibility issues can occur.", "Security Considerations": "It is expected that the attack surface will not grow. All of these operations can be modeled by existing operations with fixed gas (all available) and output range (zero length at zero memory).", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7480, "url": "https://eips.ethereum.org/EIPS/eip-7480", "title": "EOF - Data section access instructions", "authors": ["Andrei Maiboroda\u00a0(", "@gumb0", ")", "Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")"], "sections": {"EIP-7480: EOF - Data section access instructions": "Four new instructions are introduced, that allow to read EOF container\u2019s data section:DATALOADloads 32-byte word to stack,DATALOADNloads 32-byte word to stack where the word is addressed by a static immediate argument,DATASIZEloads data section size andDATACOPYcopies a segment of data section to memory.", "Instructions to read data section of EOF container": "Four new instructions are introduced, that allow to read EOF container\u2019s data section:DATALOADloads 32-byte word to stack,DATALOADNloads 32-byte word to stack where the word is addressed by a static immediate argument,DATASIZEloads data section size andDATACOPYcopies a segment of data section to memory.", "Abstract": "Four new instructions are introduced, that allow to read EOF container\u2019s data section:DATALOADloads 32-byte word to stack,DATALOADNloads 32-byte word to stack where the word is addressed by a static immediate argument,DATASIZEloads data section size andDATACOPYcopies a segment of data section to memory.", "Motivation": "Clear separation between code and data is one of the main features of EOF1. Data section may contain anything, e.g. compiler\u2019s metadata, but to make it useful for smart contracts, EVM has to have instructions that allow to read from data section. Previously existing instructions for bytecode inspection (CODECOPY,CODESIZEetc.) are deprecated in EOF1 and cannot be used for this purpose.", "Specification": "We introduce four new instructions on the same block numberEIP-3540is activated on:", "DATALOAD": "[offset:offset+32]is guaranteed to be within data bounds bycode validation.", "DATALOADN": "[offset:offset+32]is guaranteed to be within data bounds bycode validation.", "DATASIZE": "We extend code section validation rules (as defined inEIP-3670).", "DATACOPY": "We extend code section validation rules (as defined inEIP-3670).", "Code Validation": "We extend code section validation rules (as defined inEIP-3670).", "Rationale": "Existing instructions for reading other kinds of data implicitly pad with zeroes on out of bounds access, with the only exception of return data copying.", "Zero-padding on out of bounds access": "Existing instructions for reading other kinds of data implicitly pad with zeroes on out of bounds access, with the only exception of return data copying.", "Lack ofEXTDATACOPY": "EXTCODECOPYinstruction is deprecated and rejected in EOF contracts and does not copy contract code when being called in legacy with an EOF contract as target. A replacement instructionEXTDATACOPYhas been considered, but decided against in order to reduce the scope of changes.", "Backwards Compatibility": "This change poses no risk to backwards compatibility, as it is introduced only for EOF1 contracts, for which deploying undefined instructions is not allowed, therefore there are no existing contracts using these instructions. The new instructions are not introduced for legacy bytecode (code which is not EOF formatted).", "Security Considerations": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7495, "url": "https://eips.ethereum.org/EIPS/eip-7495", "title": "SSZ StableContainer", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Cayman\u00a0(", "@wemeetagain", ")"], "sections": {"EIP-7495: SSZ StableContainer": "This EIP introduces two newSimple Serialize (SSZ) typesto enable forward-compatible containers.", "New SSZ type to represent a flexible container with stable serialization and merkleization": "This EIP introduces two newSimple Serialize (SSZ) typesto enable forward-compatible containers.", "Abstract": "This EIP introduces two newSimple Serialize (SSZ) typesto enable forward-compatible containers.", "Motivation": "Stable containers and profiles are currently not representable in SSZ. Adding support provides these benefits:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "StableContainer[N]": "Similar to the regularSSZContainer,StableContainer[N]defines an ordered heterogeneous collection of fields.Nindicates the potential maximum number of fields to which it can ever grow in the future.NMUST be> 0.", "Profile[B]": "Profile[B]also defines an ordered heterogeneous collection of fields, a subset of fields of a baseStableContainertypeBwith the following constraints:", "Rationale": "Current SSZ types are only stable within one version of a specification, i.e., one fork of Ethereum. This is alright for messages pertaining to a specific fork, such as attestations or beacon blocks. However, it is a limitation for messages that are expected to remain valid across forks, such as transactions or receipts. In order to support evolving the features of such perpetually valid message types, a new SSZ scheme needs to be defined. Furthermore, consumers of Merkle proofs may have a different software update cadence as Ethereum; an implementation should not break just because a new fork introduces unrelated new features.", "What are the problems solved byStableContainer[N]?": "Current SSZ types are only stable within one version of a specification, i.e., one fork of Ethereum. This is alright for messages pertaining to a specific fork, such as attestations or beacon blocks. However, it is a limitation for messages that are expected to remain valid across forks, such as transactions or receipts. In order to support evolving the features of such perpetually valid message types, a new SSZ scheme needs to be defined. Furthermore, consumers of Merkle proofs may have a different software update cadence as Ethereum; an implementation should not break just because a new fork introduces unrelated new features.", "What are the problems solved byProfile[B]?": "The forward-compatible merkleization ofStableContainermay be desirable even in situations where only a single sub-type is valid at any given time, e.g., as determined by the fork schedule. In such situations, message size can be reduced and type safety increased by exchangingProfile[B]instead of the underlying base type. This can be useful, e.g., for consensus data structures such asBeaconState, to ensure that Merkle proofs for its fields remain compatible across forks.", "Why notUnion[T, U, V]?": "There is combinatorial complexity when new optional features are introduced. For example, if there are three transaction types, and then priority fees are introduced as an optional feature, one has to define three additional transaction types to allow inclusion of a priority fee, raising the total to six transaction types. If, subsequently, optional access lists are introduced, that doubles again, to twelve transaction types.", "Why not modelOptional[T]as an SSZ type?": "IfOptional[T]is modeled as an SSZ type, each individual field introduces serialization and merkleization overhead. As anOptional[T]would be required to be\u201cvariable-size\u201d, lots of additional offset bytes would have to be used in the serialization. For merkleization, each individualOptional[T]would require mixing in a bit to indicate presence or absence of the value.", "Backwards Compatibility": "StableContainer[N]andProfile[B]are new SSZ types and, therefore, do not conflict with other SSZ types currently in use.", "Test Cases": "SeeEIP assets.", "Reference Implementation": "SeeEIP assets, based onprotolambda/remerkleable.", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7620, "url": "https://eips.ethereum.org/EIPS/eip-7620", "title": "EOF Contract Creation", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")", "Piotr Dobaczewski\u00a0(", "@pdobacz", ")"], "sections": {"EIP-7620: EOF Contract Creation": "EVM Object Format (EOF) removes the possibility to create contracts usingCREATEorCREATE2instructions. We introduce a new/replacement method in form of pair of instructions :EOFCREATEandRETURNCODEto provide a way to create contracts using EOF containers.", "Introduce `EOFCREATE` and `RETURNCODE` instructions": "EVM Object Format (EOF) removes the possibility to create contracts usingCREATEorCREATE2instructions. We introduce a new/replacement method in form of pair of instructions :EOFCREATEandRETURNCODEto provide a way to create contracts using EOF containers.", "Abstract": "EVM Object Format (EOF) removes the possibility to create contracts usingCREATEorCREATE2instructions. We introduce a new/replacement method in form of pair of instructions :EOFCREATEandRETURNCODEto provide a way to create contracts using EOF containers.", "Motivation": "This EIP uses terminology from theEIP-3540which introduces the EOF format.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Parameters": "We introduce two new instructions on the same block numberEIP-3540is activated on:", "Execution Semantics": "If the code is legacy bytecode, any of these instructions result in anexceptional halt. (Note: This means no change to behaviour.)", "Code Validation": "We extend code section validation rules (as defined inEIP-3670).", "Data Section Lifecycle": "For an EOF container which has not yet been deployed, thedata_sectionis only a portion of the finaldata_sectionafter deployment.\nLet\u2019s define it aspre_deploy_data_sectionand aspre_deploy_data_sizethedata_sizedeclared in that container\u2019s header.pre_deploy_data_size >= len(pre_deploy_data_section), which anticipates more data to be appended to thepre_deploy_data_sectionduring the process of deploying.", "Rationale": "The data section is appended to during contract creation and also its size needs to be updated in the header. Alternative designs were considered, where:", "Data section appending": "The data section is appended to during contract creation and also its size needs to be updated in the header. Alternative designs were considered, where:", "keccak256(initcontainer)in thenew_addresshashing scheme": "new_address = keccak256(0xff || sender || salt || keccak256(initcontainer))[12:]was originally proposed as the way to calculate the address of newly created contract, similar, but not exactly equal, to whatCREATE2uses.", "EOFCREATEstack argument order": "EXT*CALLinstructions fromEIP-7069have had their stack argument order changed, as compared to that of legacy instructions*CALL. We follow the same change to haveEOFCREATEstack arg order match those ofEXTCALL.", "Backwards Compatibility": "This change poses no risk to backwards compatibility, as it is introduced at the same time EIP-3540 is. The new instructions are not introduced for legacy bytecode (code which is not EOF formatted), and the contract creation options do not change for legacy bytecode.", "Test Cases": "Creation transaction,CREATEandCREATE2cannot have itscodestarting with0xEF, but such cases are covered already inEIP-3541. However, new cases must be added whereCREATEorCREATE2have itsinitcodebeing (validly or invalidly) EOF formatted:", "Security Considerations": "It is the EOFInitcodeTransaction(specified inEIP-7873) which needs a detailed review and discussion as that is where external unverified code enters the state. Among others:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7688, "url": "https://eips.ethereum.org/EIPS/eip-7688", "title": "Forward compatible consensus data structures", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Cayman\u00a0(", "@wemeetagain", ")"], "sections": {"EIP-7688: Forward compatible consensus data structures": "This EIP defines the changes needed to adoptStableContainerfromEIP-7495in consensus data structures.", "Transition consensus SSZ data structures to StableContainer": "This EIP defines the changes needed to adoptStableContainerfromEIP-7495in consensus data structures.", "Abstract": "This EIP defines the changes needed to adoptStableContainerfromEIP-7495in consensus data structures.", "Motivation": "Ethereum\u2019s consensus data structures make heavy use ofSimple Serialize (SSZ)Container, which defines how they are serialized and merkleized. The merkleization scheme allows application implementations to verify that individual fields (and partial fields) have not been tampered with. This is useful, for example, in smart contracts of decentralized staking pools that wish to verify that participating validators have not been slashed.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Conversion procedure": "For each converted data structure, a new fork agnosticStableContainertypeBis introduced that serves as the primary definition of each data structure.", "Immutable types": "These types are used as part of theStableContainerdefinitions, and, as they are notStableContainerthemselves, are considered to have immutable Merkleization. If a future fork requires changing these types in an incompatible way, a new type SHALL be defined and assigned a new field name.", "StableContainercapacities": "Maximum proof depth:", "Fork-agnosticStableContainerdefinitions": "These type definitions are fork independent and shared across all forks. They are not exchanged over libp2p.", "Fork-specificProfiledefinitions": "The consensus type definitions specific to the fork that introduces this EIP are updated to inherit the Merkleization of theStableContainerdefinitions. Fields are kept as is.", "Rationale": "Applying this EIP breakshash_tree_rootand Merkle tree verifiers a single time, while promising forward compatibility from the fork going forward. It is best to apply it before merkleization would be broken by different changes. Merkleization is broken by aContainerreaching a new power of 2 in its number of fields.", "Best timing?": "Applying this EIP breakshash_tree_rootand Merkle tree verifiers a single time, while promising forward compatibility from the fork going forward. It is best to apply it before merkleization would be broken by different changes. Merkleization is broken by aContainerreaching a new power of 2 in its number of fields.", "Can this be applied retroactively?": "WhileProfileserializes in the same way as the legacyContainer, the merkleization andhash_tree_rootof affected data structures changes. Therefore, verifiers that wish to process Merkle proofs of legacy variants still need to support the corresponding legacy schemes.", "Immutability": "Once a field in aStableContainerhas been published, its name can no longer be used to represent a different type in the future. This includes list types with a higher capacity than originally intended. This is in line with historical management of certain cases:", "Backwards Compatibility": "Existing Merkle proof verifiers need to be updated to support the new Merkle tree shape. This includes verifiers in smart contracts on different blockchains and verifiers in hardware wallets, if applicable.", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7698, "url": "https://eips.ethereum.org/EIPS/eip-7698", "title": "EOF - Creation transaction", "authors": ["Piotr Dobaczewski\u00a0(", "@pdobacz", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-7698: EOF - Creation transaction": "Creation transactions (i.e. the ones with emptyto) can be used to deploy EOF contracts by providing EOF initcontainer concatenated withcalldatafor initcontainer execution in transaction\u2019sdata. Initcontainer execution is similar to its execution duringEOFCREATEinstruction, ending withRETURNCODEinstruction. New account address calculation is based on sender\u2019s address and nonce.", "Deploy EOF contracts using creation transactions": "Creation transactions (i.e. the ones with emptyto) can be used to deploy EOF contracts by providing EOF initcontainer concatenated withcalldatafor initcontainer execution in transaction\u2019sdata. Initcontainer execution is similar to its execution duringEOFCREATEinstruction, ending withRETURNCODEinstruction. New account address calculation is based on sender\u2019s address and nonce.", "Abstract": "Creation transactions (i.e. the ones with emptyto) can be used to deploy EOF contracts by providing EOF initcontainer concatenated withcalldatafor initcontainer execution in transaction\u2019sdata. Initcontainer execution is similar to its execution duringEOFCREATEinstruction, ending withRETURNCODEinstruction. New account address calculation is based on sender\u2019s address and nonce.", "Motivation": "Creation transaction is one of the three ways alongside creation instructions provided by legacy EVM to deploy new code. Given that legacy creation instructions (CREATEandCREATE2) are not allowed to deploy EOF code, supporting EOF in creation transactions is the only way to get the first EOF on-chain.", "Specification": "Wherever not explicitly listed, the rules of EOF contract creation should be identical or analogous to those of legacy creation transaction. This includes but is not limited to:", "Parameters": "In case a creation transaction (transaction with emptyto) hasdatastarting withEOF_MAGIC,datais interpreted as a concatenation of EOFinitcontainerandcalldata. More specifically:", "Rationale": "Originally it was proposed to deploy the first EOF contract via irregular state change. This contract would executeTXCREATEinstruction and could be used then as an entry point to deploy any other EOF code. This would also require an introduction ofInitcodeTransaction, required byTXCREATE. It was decided against this variant for the benefit of reduced scope of changes.", "Irregular state change to deploy Creator Contract": "Originally it was proposed to deploy the first EOF contract via irregular state change. This contract would executeTXCREATEinstruction and could be used then as an entry point to deploy any other EOF code. This would also require an introduction ofInitcodeTransaction, required byTXCREATE. It was decided against this variant for the benefit of reduced scope of changes.", "Constructor arguments outside of initcontainer vs in data section": "Alternative mechanism for providing constructor arguments to initcontainer execution was considered, where they are concatenated with data section of the initcontainer and are accessed viaDATA*instructions instead ofCALLDATA*. This has a benefit of not requiring the step finding the split oftransaction.dataintoinitcontainerandcalldata, as entiretransaction.datais an EOF container. However it was rejected for the following reasons:", "Backwards Compatibility": "Creation transactions deploying legacy code are not affected, because any such transaction starting withEFbyte previously would fail on executing invalid instruction.", "Security Considerations": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7742, "url": "https://eips.ethereum.org/EIPS/eip-7742", "title": "Uncouple blob count between CL and EL", "authors": ["Alex Stokes\u00a0(", "@ralexstokes", ")"], "sections": {"EIP-7742: Uncouple blob count between CL and EL": "Update blob maximum and target verification fromEIP-4844.", "Have CL verify blob maximum and have EL get target value from CL": "Update blob maximum and target verification fromEIP-4844.", "Abstract": "Update blob maximum and target verification fromEIP-4844.", "Motivation": "Following EIP-4844, the execution layer (EL) maintains a hard-coded blob target value and blob maximum value. Given the relationship\nof the EL and the consensus layer (CL) node software, the verification of the blob maximum is redundant so it can be removed\nentirely without any change in security. The blob maximum is still provided during block construction via the Engine API.\nThis EIP also changes how the EL sources the current blob target value for two reasons:", "Background": "The data facility introduced via EIP-4844 adds blobs to Ethereum blocks, which are simply fixed sets of data that can be\nincluded in the canonical chain but have no execution semantics (cf.calldatain an Ethereum transaction).", "Specification": "Upon activation of this EIP, execution clientsMUSTextend the header schema with an\nadditional 64-bit field: thetarget_blobs_per_block. This value is set to the current target blob count. The Engine API\nis modified along with this EIP to provide thetarget_blobs_per_blockwith each payload and implementations can use this\nvalue to correctly set the block header field.", "Block structure and validity": "Upon activation of this EIP, execution clientsMUSTextend the header schema with an\nadditional 64-bit field: thetarget_blobs_per_block. This value is set to the current target blob count. The Engine API\nis modified along with this EIP to provide thetarget_blobs_per_blockwith each payload and implementations can use this\nvalue to correctly set the block header field.", "Block processing": "Upon activating this EIP (i.e. before processing any transactions),\nthe verification of the blob maximum as given in EIP-4844 can be skipped. Concretely, this means any logic relating\ntoMAX_BLOB_GAS_PER_BLOCKas given in EIP-4844 can be deprecated.", "Block construction": "The Engine API is extended to provide both thetarget_blobs_per_blockand themax_blobs_per_blockwhen the CL requests the EL to construct a payload for proposal.", "Rationale": "Hoisting the full computation into the CL is possible, but it does violate the separation of concerns between these two layers of the protocol stack.\nThe CL maintains a maximum value to address e.g. DoS risks, and the EL maintains knowledge of the target value to address fee accounting.\nPutting the target computation in the CL violates the respective responsibilities of each layer.", "Why not have the CL also compute the blob base fee and remove any notion of blob counts from EL processing?": "Hoisting the full computation into the CL is possible, but it does violate the separation of concerns between these two layers of the protocol stack.\nThe CL maintains a maximum value to address e.g. DoS risks, and the EL maintains knowledge of the target value to address fee accounting.\nPutting the target computation in the CL violates the respective responsibilities of each layer.", "Backwards Compatibility": "No issues.", "Test Cases": "N/A", "Reference Implementation": "N/A", "Security Considerations": "N/A", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7761, "url": "https://eips.ethereum.org/EIPS/eip-7761", "title": "EXTCODETYPE instruction", "authors": ["Andrei Maiboroda\u00a0(", "@gumb0", ")", "Piotr Dobaczewski\u00a0(", "@pdobacz", ")", "Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-7761: EXTCODETYPE instruction": "Allow EOF contracts to discriminate between EOAs (Externally Owned Accounts) and contract accounts by introducing anEXTCODETYPEinstruction.", "Add EXTCODETYPE instruction to EOF to address common uses of EXTCODE* instructions": "Allow EOF contracts to discriminate between EOAs (Externally Owned Accounts) and contract accounts by introducing anEXTCODETYPEinstruction.", "Abstract": "Allow EOF contracts to discriminate between EOAs (Externally Owned Accounts) and contract accounts by introducing anEXTCODETYPEinstruction.", "Motivation": "EOFv1 as scoped inEIP-7692removes code introspection capabilities from the EVM, including theEXTCODESIZEinstruction (inEIP-3540). This makes it hard forERC-721andERC-1155standard contracts to be implemented, as they rely on discovering whether a token\u2019ssafeTransfercall target was an EOA or a contract account:", "Specification": "We introduce a new EOFv1 instruction on the block numberFORK_BLKNUM:EXTCODETYPE(0xe9)", "Parameters": "We introduce a new EOFv1 instruction on the block numberFORK_BLKNUM:EXTCODETYPE(0xe9)", "Execution Semantics": "Note: if there is not enough gas to deduct for delegation designation the whole message frame will halt, making updating theaccessed_addressesirrelevant.", "Rationale": "There have been other solutions proposed to alleviate the problems related to lack of code introspection required for ERC-721 and ERC-1155 standards:", "Alternative solutions": "There have been other solutions proposed to alleviate the problems related to lack of code introspection required for ERC-721 and ERC-1155 standards:", "Reuse the0x3b(EXTCODESIZE) opcode forEXTCODETYPE": "A new opcode is preferred by a general policy to not reuse opcodes. AlsoEXTCODETYPEcan be rolled out in legacy EVM if desired.", "Keep code introspection banned": "Removing code introspection is one of the tenets of EOF andEXTCODETYPEwould be an exception from the principle. WithoutEXTCODETYPE, ERC-721 and ERC-1155 standard implementations have to resort to either:", "\u201cEndgame Account Abstraction\u201d issues": "EXTCODETYPE(and earlierEXTCODESIZEavailable in legacy EVM) are claimed to slow down AA adoption, because they encourage patterns which discriminate between smart contract and EOA accounts, e.g. not allowing the former to interact. However, there are counterarguments that it is up to other factors which slow down AA adoption (assumption that accounts can produce ECDSA signatures, and the lack of adoption of smart contract signatures).", "Including safeguarding against proxy bricking": "In parallel to the ERC-721 / ERC-1155 problem, another potential risk has been brought to attention. Since EOFv1 prohibitsEXTDELEGATECALLtargeting legacy contracts, there exists a scenario where an EOF proxy contract accidentally upgrades its implementation to a legacy EVM one. Since reverting this or upgrading again (using current proxy standards) requires the implementation contract to be called, it would effectively render the contract unusable.", "Relation toEIP-7702\u201cSet EOA account code\u201d": "AfterEIP-7702is activated, the discrimination between EOAs and contract accounts usingEXTCODESIZE(orEXTCODETYPE) has an edge case: Whenever an EOA sets its code to a contract account which does not respond as expected to anonERC721Received(onERC1155Received) callback, transfers to it will revert, despite the recipient being able to interact with the token. This has been deemed unlikely to be a problem, as for the intended real-world uses of EIP-7702, those callbacks will be implemented by designator codes.", "Backwards Compatibility": "EXTCODETYPEat0xe9can be introduced in a backwards compatible manner into EOFv1 (no bump to version), because0xe9has been rejected by EOF validation beforeFORK_BLKNUMand there are no EOF contracts on-chain with a0xe9which would have their behavior altered.", "Security Considerations": "Needs discussion", "Copyright": "Copyright and related rights waived viaCC0", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7762, "url": "https://eips.ethereum.org/EIPS/eip-7762", "title": "Increase MIN_BASE_FEE_PER_BLOB_GAS", "authors": ["Max Resnick\u00a0(", "@MaxResnick", ")", "Davide Crapis\u00a0(", "@dcrapis", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")"], "sections": {"EIP-7762: Increase MIN_BASE_FEE_PER_BLOB_GAS": "This EIP proposes an increase to the MIN_BASE_FEE_PER_BLOB_GAS to speed up price discovery on blob space. It also resets the excess blob gas to 0, to avoid a blob basefee spike.", "Adjust the MIN_BASE_FEE_PER_BLOB_GAS to speed up price discovery on blob space": "This EIP proposes an increase to the MIN_BASE_FEE_PER_BLOB_GAS to speed up price discovery on blob space. It also resets the excess blob gas to 0, to avoid a blob basefee spike.", "Abstract": "This EIP proposes an increase to the MIN_BASE_FEE_PER_BLOB_GAS to speed up price discovery on blob space. It also resets the excess blob gas to 0, to avoid a blob basefee spike.", "Motivation": "When scoping 4844, the thinking was that blobs would only enter price discovery once, relatively quickly after the blob rollout; however, this has not been the case. In fact, blobs have entered price discovery several times, and the frequency of price discovery events is likely to increase in the short term as we approach saturation of capacity. Moreover, the roadmap calls for further increases in blob capacity in subsequent hardforks, which may lead to price discovery events happening around those changes in the future.", "Specification": "The main specification change introduced by this EIP is setting MIN_BASE_FEE_PER_BLOB_GAS to 2**25:", "MIN_BASE_FEE_PER_BLOB_GASIncrease": "The main specification change introduced by this EIP is setting MIN_BASE_FEE_PER_BLOB_GAS to 2**25:", "excess_blob_gasReset": "To avoid a blob basefee spike, thecalc_excess_blob_gasis modified to resetexcess_blob_gasto 0 at the fork. To detect the fork height, the block timestamp needs to be passed intocalc_excess_blob_gas.", "Rationale": "The current MIN_BASE_FEE_PER_BLOB_GAS is 1 wei. This is many orders of magnitude lower than the prevailing price of blobs when blobs enter price discovery. Whenever demand for blobs exceeds supply, blobs enter price discovery, but traversing the 8 orders of magnitude between 1 wei and the point where elasticity of demand starts to decrease takes a long time.", "Backwards Compatibility": "This EIP is not backwards compatible and requires a coordinated upgrade across all clients at a specific block number.", "Security Considerations": "Rollups that use blobs as a data availability layer will need to update their posting strategies.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7784, "url": "https://eips.ethereum.org/EIPS/eip-7784", "title": "GETCONTRACT opcode", "authors": ["Tim Pechersky\u00a0(", "@peersky", ")"], "sections": {"EIP-7784: GETCONTRACT opcode": "This is a proposal to add a new opcode,GETCONTRACT. TheGETCONTRACTopcode would return the address containing the bytecode by its hash.", "Global byte code accessing by its hash": "This is a proposal to add a new opcode,GETCONTRACT. TheGETCONTRACTopcode would return the address containing the bytecode by its hash.", "Abstract": "This is a proposal to add a new opcode,GETCONTRACT. TheGETCONTRACTopcode would return the address containing the bytecode by its hash.", "Motivation": "Content addressing by hash is a common pattern in database design. It allows to store and retrieve data by its unique footprint in the storage. This pattern is widely used in the industry and it allows abstracting the actual storage location and allows reusing the same bytecode in multiple contracts.", "Specification": "Every contract stored in EVM MUST be added to the state trie with the key being the keccak256 hash of the contract\u2019s bytecode, provided it is:", "Opcode Definition": "Every contract stored in EVM MUST be added to the state trie with the key being the keccak256 hash of the contract\u2019s bytecode, provided it is:", "Example Usage": "Bytecode over Addresses: Bytecode is deterministic and can be verified on-chain, while addresses are opaque and mutable.", "Rationale": "Bytecode over Addresses: Bytecode is deterministic and can be verified on-chain, while addresses are opaque and mutable.", "Security Considerations": "Malicious Code: The index does NOT guarantee the safety or functionality of indexed contracts. Users MUST exercise caution and perform their own due diligence before interacting with indexed contracts.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7823, "url": "https://eips.ethereum.org/EIPS/eip-7823", "title": "Set upper bounds for MODEXP", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Radoslaw Zagorowicz\u00a0(", "@rodiazet", ")"], "sections": {"EIP-7823: Set upper bounds for MODEXP": "Introduce an upper bound on the inputs of the MODEXP precompile. This can reduce the number of potential bugs, because the testing surface is not infinite anymore, and makes it easier to be replaced using EVMMAX.", "Each input field is restricted to a maximum of 8192 bits": "Introduce an upper bound on the inputs of the MODEXP precompile. This can reduce the number of potential bugs, because the testing surface is not infinite anymore, and makes it easier to be replaced using EVMMAX.", "Abstract": "Introduce an upper bound on the inputs of the MODEXP precompile. This can reduce the number of potential bugs, because the testing surface is not infinite anymore, and makes it easier to be replaced using EVMMAX.", "Motivation": "The MODEXP precompile has been a source of numerous consensus bugs. Many of them were due to specifically crafted cases using impractical input lengths.", "Specification": "Recap fromEIP-198:", "Rationale": "This upper bound allows the existing use cases of MODEXP:", "Limit": "This upper bound allows the existing use cases of MODEXP:", "EVMMAX": "Replacing the precompile with EVM code using an instruction set like EVMMAX would be made simpler with this limit: Common cases (256, 381, 1024, 2048) could be implemented in special fast paths, while a slow fallback could be provided for the rest. Or even special, frequently used, moduli could have their own paths.", "Analysis": "Since MODEXP was introduced in the Byzantium hard fork, an analysis has been conducted between block 5472266 (April 20, 2018) and block 21550926 (January 4th, 2025). All lengths of inputs are expressed in bytes.", "Backwards Compatibility": "This is a backwards incompatible change. However, based on analysis until block 21550926 (see above), no past transaction would have behaved differently after this change.", "Security Considerations": "Since only the accepted input range is reduced, no new security surface area is expected.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7830, "url": "https://eips.ethereum.org/EIPS/eip-7830", "title": "Contract size limit increase for EOF", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-7830: Contract size limit increase for EOF": "Revise the contract size limit for EOF contracts to be 64 KiB instead of the existing 24 KiB limit. Legacy contracts are unaffected.", "Raise the limit for only EOF contracts to 64 KiB": "Revise the contract size limit for EOF contracts to be 64 KiB instead of the existing 24 KiB limit. Legacy contracts are unaffected.", "Abstract": "Revise the contract size limit for EOF contracts to be 64 KiB instead of the existing 24 KiB limit. Legacy contracts are unaffected.", "Motivation": "The contract size limit was introduced as a measure against DoS attacks.JUMPDEST-analysis is required for legacy contracts, and many of the algorithms performing it are not linear and/or have unknown unknowns. This is one of the reasons for the hesitance of a limit increase.", "Specification": "EIP-170specifiesMAX_CODE_SIZEas 24576 bytes, andEIP-3860specifiesMAX_INITCODE_SIZEas2 * MAX_CODE_SIZE(49152 bytes).", "Rationale": "The 64 KiB limit is over 2x of existing limit, while it is not a significant increase, it is the realistic increase given the limitations of initcode. In EOF deployment the to-be-deployed code is stored as a section (\u201csubcontainer\u201d), which has a size limit of 64 KiB, therefore it is not possible to deploy larger contracts without introducing a large or variable-length-encoded size field.", "Backwards Compatibility": "This is a backwards compatible change. Existing contracts are unaffected, and only new deployments see the effect.", "Security Considerations": "Given the analysis cost is paid as part of deployment, the size of contract should have no effect on the runtime.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7834, "url": "https://eips.ethereum.org/EIPS/eip-7834", "title": "Separate Metadata Section for EOF", "authors": ["Kaan Uzdogan\u00a0(", "@kuzdogan", ")", "Marco Castignoli\u00a0(", "@marcocastignoli", ")", "Manuel Wedler\u00a0(", "@manuelwedler", ")"], "sections": {"EIP-7834: Separate Metadata Section for EOF": "Introduce a new separate metadata section to the Ethereum Object Format (EOF) that is unreachable by the code, and any changes to which does not affect the code.", "Introduce a new separate metadata section to the EOF": "Introduce a new separate metadata section to the Ethereum Object Format (EOF) that is unreachable by the code, and any changes to which does not affect the code.", "Abstract": "Introduce a new separate metadata section to the Ethereum Object Format (EOF) that is unreachable by the code, and any changes to which does not affect the code.", "Motivation": "It is desirable to include metadata in contract\u2019s bytecode for various reasons. For instance, both the Solidity and Vyper compilers by default include the language and compiler version used to compile. Vyper (with 0.4.1) appends an integrity hash to the initcode in CBOR encoding. Solidity additionally includes the IPFS or the Swarm hash of the Solidity contract metadata.json file, and the experimental Solidity flag. The current (pre-EOF) practice is to append this CBOR encoded metadata section in the contract\u2019s runtime bytecode, followed by the 2 bytes length of the CBOR encoded bytes.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Header": "The strucure and the encoding of themetadata_sectionis not defined by this EIP. It is left to the compilers, tooling, or the contract developers to define the encoding and the content. The current practice by the Solidity and Vyper compilers is to use CBOR encoding.", "Body": "The strucure and the encoding of themetadata_sectionis not defined by this EIP. It is left to the compilers, tooling, or the contract developers to define the encoding and the content. The current practice by the Solidity and Vyper compilers is to use CBOR encoding.", "Rationale": "Themetadata_sectionin thebody, as well as thekind_metadataandmetadata_sizefields in theheader, are OPTIONAL. This way, the compilers can avoid additional bytes in the container if they don\u2019t want to write any metadata. Thedata_sectioncan change in its size and content during deployment, therefore it needs to be REQUIRED, even if the data is empty. Themetadata_sectionis not expected to change during the deployment.", "Backwards Compatibility": "No backward compatibility issues are expected sinceEIP-3540is not implemented yet.", "Security Considerations": "No security considerations as this section is meant not to be executed.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7873, "url": "https://eips.ethereum.org/EIPS/eip-7873", "title": "EOF - TXCREATE and InitcodeTransaction type", "authors": ["Piotr Dobaczewski\u00a0(", "@pdobacz", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Alex Beregszaszi\u00a0(", "@axic", ")", "Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-7873: EOF - TXCREATE and InitcodeTransaction type": "EVM Object Format (EOF) removes the possibility to create contracts using creation transactions (with an emptytofield),CREATEorCREATE2instructions. We introduce a new instruction:TXCREATE, as well as a new transaction type (InitcodeTransaction), to provide a way to create contracts using EOF containers in transaction data.", "Adds a `TXCREATE` instruction to EOF and an accompanying transaction type allowing to create EOF contracts from transaction data": "EVM Object Format (EOF) removes the possibility to create contracts using creation transactions (with an emptytofield),CREATEorCREATE2instructions. We introduce a new instruction:TXCREATE, as well as a new transaction type (InitcodeTransaction), to provide a way to create contracts using EOF containers in transaction data.", "Abstract": "EVM Object Format (EOF) removes the possibility to create contracts using creation transactions (with an emptytofield),CREATEorCREATE2instructions. We introduce a new instruction:TXCREATE, as well as a new transaction type (InitcodeTransaction), to provide a way to create contracts using EOF containers in transaction data.", "Motivation": "This EIP uses terminology from theEIP-3540which introduces the EOF format.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Parameters": "Introduce new transactionInitcodeTransaction(typeINITCODE_TX_TYPE) which extendsEIP-1559(type 2) transaction by adding a new fieldinitcodes: List[ByteList[MAX_INITCODE_SIZE], MAX_INITCODE_COUNT].", "Transaction Types": "Introduce new transactionInitcodeTransaction(typeINITCODE_TX_TYPE) which extendsEIP-1559(type 2) transaction by adding a new fieldinitcodes: List[ByteList[MAX_INITCODE_SIZE], MAX_INITCODE_COUNT].", "Execution Semantics": "Wherever not explicitly listed, the rules of EOF contract creation, as well as theTXCREATEinstruction, should be identical or analogous to those ofCREATE2instruction. This includes but is not limited to:", "Rationale": "TXCREATEhas two \u201clight\u201d failure modes in case the initcontainer is not present and in case the EOF validation is unsuccessful. An alternative design where both cases led to a \u201chard\u201d failure (consuming the entire gas available) was considered. We decided to have the more granular and forgiving failure modes in order to align the gas costs incurred to the actual work the EVM performs.", "TXCREATEfailure modes": "TXCREATEhas two \u201clight\u201d failure modes in case the initcontainer is not present and in case the EOF validation is unsuccessful. An alternative design where both cases led to a \u201chard\u201d failure (consuming the entire gas available) was considered. We decided to have the more granular and forgiving failure modes in order to align the gas costs incurred to the actual work the EVM performs.", "AllowingTXCREATEin legacy EVM": "EOF contract creation requires an exceptional possibility of calling an EOF opcode in legacy code -TXCREATE, because otherwise neither legacy contracts nor create transactions can deploy EOF code to bootstrap. The alternative approach was to continue using legacy creation mechanisms, by either still relying on fetching theinitcodefrom memory and not satisfy the overarching requirement of code non-observability, or to abuse the legacy creation transactions mechanism, or to introduce a predeployed Creator Contract into the state.", "New address hashing scheme": "TXCREATEuses the schemenew_address = keccak256(0xff || sender32 || salt)[12:], same asEOFCREATEinstruction. The decision whether to include initcontainer hash into salt is left to theTXCREATEcaller. SeeEIP-7620for detailed rationale.", "EOF creation transactions vs deployment patterns": "Relying on the EOF creation transactions as the alternative solution makes it impossible for smart contract wallets to deploy arbitrary EOF contracts (only EOAs can). At the same time, it is a use case current legacy creation rules allow, thanks toCREATEandCREATE2instructions. A workaround where those arbitrary EOF contracts are first \u201cuploaded\u201d to a factory contract, and then deployed using anEXTDELEGATECALL-EOFCREATEsequence, is very expensive, as it requires the deployed contract to be put on-chain twice. Because of this, the approach proposed in this EIP is more compatible with the Account Abstraction (AA) roadmap, where smart contract wallets should have feature parity with EOAs.", "Backwards Compatibility": "This change poses no risk to backwards compatibility, as it is introduced at the same time EIP-3540 is. Despite the new instruction being introduced for legacy bytecode (code which is not EOF formatted), there is little chance that a meaningful contract would unintentionally execute0xedinstruction with formally valid operands and inadvertently cause it to run EOF initcode (which would also require anInitcodeTransactionto be used, otherwise the initcode lookup will fail).", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7880, "url": "https://eips.ethereum.org/EIPS/eip-7880", "title": "EOF - EXTCODEADDRESS instruction", "authors": ["Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-7880: EOF - EXTCODEADDRESS instruction": "Add an instruction to EOF that reads code delegation designations from an account without requiring code introspection.", "Add EXTCODEADDRESS instruction to EOF to address code delegation use cases": "Add an instruction to EOF that reads code delegation designations from an account without requiring code introspection.", "Abstract": "Add an instruction to EOF that reads code delegation designations from an account without requiring code introspection.", "Motivation": "EOFv1 as scoped inEIP-7692removes code introspection capabilities from the EVM, preventing EOF from reading raw code values such as code delegation designations set byEIP-7702. There are a number of use cases where reading the delegation designation ofEIP-7702would allow contracts to be more proactive about user experience issues.", "Specification": "We introduce a new EOFv1 instructionEXTCODEADDRESS(0xea).", "Parameters": "We introduce a new EOFv1 instructionEXTCODEADDRESS(0xea).", "Execution Semantics": "Note: Iftarget_addresspoints to an account with a contract mid-creation, thentarget_addressis returned. If delegation designator points to an account with a contract mid-creation, then address of the designation is returned.", "Rationale": "This EIP is very similar toEIP-7761, which introduces account type introspection. Its rationale is included by reference as they all apply to this situation.", "Alternative: Return the whole designation, have contract parse": "One alternative is to have a specially limitedEXTCODECOPYthat would return just delegation designations. Apart from the general objections to code introspection this would then lock in and limit delegation designation formats and capabilities that must be preserved in future forks. By allowing access to the effect of the delegation rather than the mechanism, EOF preserves space for the mechanism to be changed without breaking existing code.", "Backwards Compatibility": "EXTCODEADDRESSat0xeacan be introduced in a backwards compatible manner into EOFv1 (no bump to version), because0xeahas been rejected by EOF validation prior to the actication of this EIP, and there are no EOF contracts on-chain with an0xeainstruction which would have their behavior altered.", "Security Considerations": "EIP-7702code delegation is a new feature that has not been made accessible to mainnet yet. EIP authors will keep abreast of any developments and reflect on their impact to this proposed instruction.", "Copyright": "Copyright and related rights waived viaCC0", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7918, "url": "https://eips.ethereum.org/EIPS/eip-7918", "title": "Blob base fee bounded by execution cost", "authors": ["Anders Elowsson\u00a0(", "@anderselowsson", ")"], "sections": {"EIP-7918: Blob base fee bounded by execution cost": "This EIP imposes that the price of the targeted number blobsTARGET_BLOB_GAS_PER_BLOCK * base_fee_per_blob_gasstays above the price of a simple blob-carrying transactionTX_BASE_COST * base_fee_per_gas. This ensures that the blob fee auction can function properly, because the equilibrium always forms relative to the fee that carries the price signal. The proposedifstatement to check fee parity incalc_excess_blob_gas()represents a neutral, simple, and future-proof resolution to current blob fee auction idiosyncrasies.", "Imposes that the price for TARGET_BLOB_GAS_PER_BLOCK is greater than the price for TX_BASE_COST": "This EIP imposes that the price of the targeted number blobsTARGET_BLOB_GAS_PER_BLOCK * base_fee_per_blob_gasstays above the price of a simple blob-carrying transactionTX_BASE_COST * base_fee_per_gas. This ensures that the blob fee auction can function properly, because the equilibrium always forms relative to the fee that carries the price signal. The proposedifstatement to check fee parity incalc_excess_blob_gas()represents a neutral, simple, and future-proof resolution to current blob fee auction idiosyncrasies.", "Abstract": "This EIP imposes that the price of the targeted number blobsTARGET_BLOB_GAS_PER_BLOCK * base_fee_per_blob_gasstays above the price of a simple blob-carrying transactionTX_BASE_COST * base_fee_per_gas. This ensures that the blob fee auction can function properly, because the equilibrium always forms relative to the fee that carries the price signal. The proposedifstatement to check fee parity incalc_excess_blob_gas()represents a neutral, simple, and future-proof resolution to current blob fee auction idiosyncrasies.", "Motivation": "Ethereum deploys a dynamic pricing auction to set the blob base fee, lowering the fee if less gas is consumed thanTARGET_BLOB_GAS_PER_BLOCKand raising the fee if more gas is consumed. Such an auction can function well when the blob base fee represents the price signal, allowing the mechanism to control the real price facing the consumer. However, when the cost of execution gas in the blob-carrying transaction dominates, the price signal is lost. The blob base fee no longer represents the actual cost facing the consumer, and the protocol cannot adjust the blob base fee to regulate the equilibrium quantity of blobs consumed. Under these circumstances, the current mechanism will continue lowering the blob base fee until it eventually settles at 1 wei. Whenever demand picks up, a sustained succession of near-full blocks is required to restore equilibrium, with the mechanism intermittently resorting to a first-price auction, considered a worse UX by blob consumers. The resulting spikiness in resource consumption is suboptimal for scaling blobspace.", "Specification": "The functioncalc_excess_blob_gas()fromEIP-4844is changed to addparent.blob_gas_used // 3and not subtractTARGET_BLOB_GAS_PER_BLOCKwhen updating theexcess_blob_gas, if the price ofTARGET_BLOB_GAS_PER_BLOCKis below the price ofTX_BASE_COST.", "Rationale": "This proposal alleviates idiosyncrasies in the blob base fee auction. Fundamentally, the issue is that the demand curve becomes fee-inelastic as the cost of blob data falls relative to the cost of the blob-carrying transaction. When the execution cost dominates, it does not matter to the blob consumer how the blob fee evolves\u2014it is ultimately the execution cost that determines equilibrium formation. Given that the protocol stipulates a long-run perfectly inelastic supply curve (vertical blue line in Figure 1), the blob base fee will simply fall to the boundary of 1 wei whenever the execution cost is too high for equilibrium formation atTARGET_BLOB_GAS_PER_BLOCK. Thus, in the regime where execution fees dominate, the demand curve isblob fee-inelastic, and whenever the blob fees dominate, the demand curve isexecution fee-inelastic. Figure 1 maps the quantity of blobs demanded $Q$ to the blob base fee $f_b$ and the execution cost $c_\\text{tx}$:", "Fee-inelasticity": "This proposal alleviates idiosyncrasies in the blob base fee auction. Fundamentally, the issue is that the demand curve becomes fee-inelastic as the cost of blob data falls relative to the cost of the blob-carrying transaction. When the execution cost dominates, it does not matter to the blob consumer how the blob fee evolves\u2014it is ultimately the execution cost that determines equilibrium formation. Given that the protocol stipulates a long-run perfectly inelastic supply curve (vertical blue line in Figure 1), the blob base fee will simply fall to the boundary of 1 wei whenever the execution cost is too high for equilibrium formation atTARGET_BLOB_GAS_PER_BLOCK. Thus, in the regime where execution fees dominate, the demand curve isblob fee-inelastic, and whenever the blob fees dominate, the demand curve isexecution fee-inelastic. Figure 1 maps the quantity of blobs demanded $Q$ to the blob base fee $f_b$ and the execution cost $c_\\text{tx}$:", "Designing for the future": "Figure 2 once again shows the permitted (green) and restricted (red) regions also captured in Figure 1, but this time with execution base fee on the x-axis. Various settings for fee parity are indicated by black lines. When fee parity is imposed based on a transaction carrying many blobs (e.g., 48), its total cost will be relatively higher, and the blob base fee will as a result be operational at a relatively lower level. Such a shift is inherent by design and as intended. If blob consumers include many more blobs in their blob-carrying transactions, the execution gas may no longer carry the price signal at the same blob base fee, and the blob base fee should be able to settle relatively lower. This is also why fixed thresholds not relating to blob quantity or the execution fee may not be sustainable. In a scenario where Ethereum provides many orders of magnitude more blobs, the equilibrium blob base fee should ideally have a relatively lower floor. To understand why potential future blob scaling is important to account for when designing the mechanism, consider how the price of storing a fixed amount of data has fallen over the last 80 years.", "Delayed response during a quick rise in execution fees": "When theifstatement concludes that Ethereum operates in the execution-fee-led pricing regime, the blob base fee rises in accordance withblob_gas_used // 3, without subtractingTARGET_BLOB_GAS_PER_BLOCK. This is an intuitive way to return to the blob-fee-led pricing regime, retaining the same maximum fee increase while not allowing for a decrease. If the execution base fee rises quickly, there may however be a few blocks before the blob base fee catches up (during whichTARGET_BLOB_GAS_PER_BLOCKwill never be subtracted and the blob fee moves in the direction of the arrows in Figure 2). This is arguably not an issue, and the smooth response in the blob base fee under these circumstances may even be seen as a benefit.", "Alternative specifications": "The specification outlines the simplest way to achieve the desired goals and is therefore preferred. Here, two alternative variants are outlined. In the first, the fee-parity comparison is instead made on the current block\u2019s base fees, as derived from the parent block. The computation for the execution base fee is omitted and the variable instead provided as input. This would also require a change to the block validityassertstatement (omitted here).", "Security Considerations": "The blob base fee will settle at a level where posting the target number of blobs costs at least as much as its blob-carrying transaction. To the best of the author\u2019s knowledge, there are no security risks associated with this.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 4762, "url": "https://eips.ethereum.org/EIPS/eip-4762", "title": "Statelessness gas cost changes", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")", "Dankrad Feist\u00a0(", "@dankrad", ")", "Ignacio Hagopian\u00a0(", "@jsign", ")", "Tanishq Jasoria\u00a0(", "@tanishqjasoria", ")", "Gajinder Singh\u00a0(", "@g11tech", ")"], "sections": {"EIP-4762: Statelessness gas cost changes": "This EIP introduces changes in the gas schedule to reflect the costs of creating a witness. It requires clients to update their database layout to match this, so as to avoid potential DoS attacks.", "Changes the gas schedule to reflect the costs of creating a witness by requiring clients update their database layout to match.": "This EIP introduces changes in the gas schedule to reflect the costs of creating a witness. It requires clients to update their database layout to match this, so as to avoid potential DoS attacks.", "Abstract": "This EIP introduces changes in the gas schedule to reflect the costs of creating a witness. It requires clients to update their database layout to match this, so as to avoid potential DoS attacks.", "Motivation": "The introduction of Verkle trees into Ethereum requires fundamental changes and as a preparation, this EIP is targeting the fork coming right before the verkle tree fork, in order to incentivize Dapp developers to adopt the new storage model, and ample time to adjust to it. It also incentivizes client developers to migrate their database format ahead of the verkle fork.", "Specification": "Whenever the state is read, one or more of the access events of the form(address, sub_key, leaf_key)take place, determining what data is being accessed. We define access events as follows:", "Helper functions": "Whenever the state is read, one or more of the access events of the form(address, sub_key, leaf_key)take place, determining what data is being accessed. We define access events as follows:", "Access events": "Whenever the state is read, one or more of the access events of the form(address, sub_key, leaf_key)take place, determining what data is being accessed. We define access events as follows:", "Write Events": "We definewrite eventsas follows. Note that when a write takes place, an access event also takes place (so the definition below should be a subset of the definition of access events). A write event is of the form(address, sub_key, leaf_key), determining what data is being written to.", "Transaction": "For a transaction, make these access events:", "Witness gas costs": "Remove the following gas costs:", "Block-level operations": "None of:", "System contracts": "When (and only when) calling a system contract either", "Account abstraction": "TODO : still waiting on a final decision between 7702 and 3074", "Rationale": "Gas costs for reading storage and code are reformed to more closely reflect the gas costs under the new Verkle tree design.WITNESS_CHUNK_COSTis set to charge 6.25 gas per byte for chunks, andWITNESS_BRANCH_COSTis set to charge ~13,2 gas per byte for branches on average (assuming 144 byte branch length) and ~2.5 gas per byte in the worst case if an attacker fills the tree with keys deliberately computed to maximize proof length.", "Gas reform": "Gas costs for reading storage and code are reformed to more closely reflect the gas costs under the new Verkle tree design.WITNESS_CHUNK_COSTis set to charge 6.25 gas per byte for chunks, andWITNESS_BRANCH_COSTis set to charge ~13,2 gas per byte for branches on average (assuming 144 byte branch length) and ~2.5 gas per byte in the worst case if an attacker fills the tree with keys deliberately computed to maximize proof length.", "Backwards Compatibility": "This EIP requires a hard fork, since it modifies consensus rules.", "Security Considerations": "This EIP will mean that certain operations, mostly reading and writing several elements in the same suffix tree, become cheaper. If clients retain the same database structure as they have now, this would result in a DOS vector.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 5920, "url": "https://eips.ethereum.org/EIPS/eip-5920", "title": "PAY opcode", "authors": ["Gavin John\u00a0(", "@Pandapip1", ")", "Zainan Victor Zhou\u00a0(", "@xinbenlv", ")", "Sam Wilson\u00a0(", "@SamWilsn", ")"], "sections": {"EIP-5920: PAY opcode": "This EIP introduces a new opcode,PAY, taking two stack parameters,addrandval, that transfersvalwei to the addressaddrwithout calling any of its functions.", "Introduces a new opcode, PAY, to send ether to an address without calling any of its functions": "This EIP introduces a new opcode,PAY, taking two stack parameters,addrandval, that transfersvalwei to the addressaddrwithout calling any of its functions.", "Abstract": "This EIP introduces a new opcode,PAY, taking two stack parameters,addrandval, that transfersvalwei to the addressaddrwithout calling any of its functions.", "Motivation": "Currently, to send ether to an address requires you to call into that address, which transfers execution context to that address, which creates several issues:", "Specification": "A new opcode is introduced:PAY(0xfc), which:", "Constants": "A new opcode is introduced:PAY(0xfc), which:", "Behavior": "A new opcode is introduced:PAY(0xfc), which:", "Gas Cost": "The gas cost forPAYis the sum of the following:", "Rationale": "The order of arguments mimics that ofCALL, which popsaddrbeforeval. Beyond consistency, though, this ordering aids validators pattern-matching MEV opportunities, soPAYalways appears immediately afterCOINBASE.", "Argument order": "The order of arguments mimics that ofCALL, which popsaddrbeforeval. Beyond consistency, though, this ordering aids validators pattern-matching MEV opportunities, soPAYalways appears immediately afterCOINBASE.", "Halting for invalid address": "The halting behavior is designed to allow for Address Space Extension.\nIf the high bytes were truncated, as inCALL, contracts could depend on the truncating behavior.\nIf the address space were extended beyond 20 bytes,PAYwould either not be able to target those accounts, or code expecting truncation could send ether to the wrong address.", "Backwards Compatibility": "This change requires a hard fork.", "Security Considerations": "Existing contracts should not rely on their balance being under their control, since it is already possible to send ether to an address without calling it, by creating a temporary contract and immediatelySELFDESTRUCTing it, sending the ether to an arbitrary address.\nIt is also possible to involuntarily fund an account using priority fees.\nHowever, this opcode does make this process cheaper and easier for already-vulnerable contracts.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6404, "url": "https://eips.ethereum.org/EIPS/eip-6404", "title": "SSZ transactions", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Gajinder Singh\u00a0(", "@g11tech", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-6404: SSZ transactions": "This EIP defines a migration process ofEIP-2718Recursive-Length Prefix (RLP) transactions toSimple Serialize (SSZ).", "Migration of RLP transactions to SSZ": "This EIP defines a migration process ofEIP-2718Recursive-Length Prefix (RLP) transactions toSimple Serialize (SSZ).", "Abstract": "This EIP defines a migration process ofEIP-2718Recursive-Length Prefix (RLP) transactions toSimple Serialize (SSZ).", "Motivation": "RLP transactions have a number of shortcomings:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Existing definitions": "Definitions from existing specifications that are used throughout this document are replicated here for reference.", "ExecutionSignaturecontainer": "Signatures use their native, opaque representation, and are extended with an on-chain commitment to the signing address.", "Transactioncontainer": "All transactions are represented as a single, normalized SSZ container. The definition uses theStableContainer[N]SSZ type andOptional[T]as defined inEIP-7495.", "Transactionprofiles": "EIP-7495Profiledefinitions provide type safety for valid transactions. Their original RLPTransactionTypeis retained to enable recovery of their original RLP representation and associatedsig_hashandtx_hashvalues where necessary.", "Execution block header changes": "Theexecution block header\u2019stxs-rootis transitioned from MPT to SSZ.", "Engine API": "In the engine API, the structure of thetransactionsfield inExecutionPayloadversions adopting this EIP is changed fromArray of DATAtoArray of TransactionV1.", "ConsensusExecutionPayloadchanges": "When building a consensusExecutionPayload, thetransactionslist is no longer opaque and uses the newTransactiontype.", "SSZPooledTransactioncontainer": "During transaction gossip responses (PooledTransactions), eachTransactionis wrapped into aPooledTransaction.", "Transaction gossip announcements": "The semantics of thetypeselementin transaction gossip announcements (NewPooledTransactionHashes) are changed to matchssz(PooledTransaction.active_fields()). The separate control flow for fetching blob transactions compared to basic transactions is retained.", "Networking": "When exchanging SSZ transactions via theEthereum Wire Protocol, the followingEIP-2718compatible envelopes are used:", "Rationale": "Switching to a single, unified and forward compatible transaction format within execution blocks reduces implementation complexity for client applications and smart contracts. Future use cases such as transaction inclusion proofs or submitting individual verifiable chunks of calldata to a smart contract become easier to implement with SSZ.", "Backwards Compatibility": "Applications that rely on the replaced MPTtransactions_rootin the block header require migration to the SSZtransactions_root.", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6465, "url": "https://eips.ethereum.org/EIPS/eip-6465", "title": "SSZ withdrawals root", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Mikhail Kalinin\u00a0(", "@mkalinin", ")"], "sections": {"EIP-6465: SSZ withdrawals root": "This EIP defines a migration process of the existing Merkle-Patricia Trie (MPT) commitment for withdrawals toSimple Serialize (SSZ).", "Migration of withdrawals MPT commitment to SSZ": "This EIP defines a migration process of the existing Merkle-Patricia Trie (MPT) commitment for withdrawals toSimple Serialize (SSZ).", "Abstract": "This EIP defines a migration process of the existing Merkle-Patricia Trie (MPT) commitment for withdrawals toSimple Serialize (SSZ).", "Motivation": "While the consensusExecutionPayloadHeaderand the execution block header map to each other conceptually, they are encoded differently. This EIP aims to align the encoding of thewithdrawals_root, taking advantage of the more modern SSZ format. This brings several advantages:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Existing definitions": "Definitions from existing specifications that are used throughout this document are replicated here for reference.", "SSZWithdrawalcontainer": "The existing consensusWithdrawalSSZ container is used to represent withdrawals.", "Execution block header changes": "The execution block header\u2019swithdrawals-rootis updated to match the consensusExecutionPayloadHeader.withdrawals_root.", "Typed withdrawal envelope": "A typed withdrawal envelope similar toEIP-2718is introduced for exchanging withdrawals via theEthereum Wire Protocol.", "Networking": "When exchanging SSZ withdrawals via theEthereum Wire Protocol, the following withdrawal envelope is used:", "Rationale": "This change was originally a candidate for inclusion in Shanghai, but was postponed to accelerate the rollout of withdrawals.", "Why typed withdrawal envelopes?": "The RLPx serialization layer may not be aware of the fork schedule and the block timestamp when withdrawals are exchanged. The typed withdrawal envelope assists when syncing historical blocks based on RLP and the MPTwithdrawals_root.", "Backwards Compatibility": "Applications that rely on the replaced MPTwithdrawals_rootin the block header require migration to the SSZwithdrawals_root.", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6466, "url": "https://eips.ethereum.org/EIPS/eip-6466", "title": "SSZ receipts", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Gajinder Singh\u00a0(", "@g11tech", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-6466: SSZ receipts": "This EIP defines a migration process ofEIP-2718Recursive-Length Prefix (RLP) receipts toSimple Serialize (SSZ)", "Migration of RLP receipts to SSZ": "This EIP defines a migration process ofEIP-2718Recursive-Length Prefix (RLP) receipts toSimple Serialize (SSZ)", "Abstract": "This EIP defines a migration process ofEIP-2718Recursive-Length Prefix (RLP) receipts toSimple Serialize (SSZ)", "Motivation": "RLP receipts have a number of shortcomings:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Existing definitions": "Definitions from existing specifications that are used throughout this document are replicated here for reference.", "Receiptcontainer": "All receipts are represented as a single, normalized SSZ container. The definition uses theStableContainer[N]SSZ type andOptional[T]as defined inEIP-7495.", "Receiptconstruction": "Receipts are constructed as follows.", "Execution block header changes": "Theexecution block header\u2019sreceipts-rootis transitioned from MPT to SSZ.", "JSON-RPC API": "Transaction receipt objects in the context of the JSON-RPC API are extended to include:", "ConsensusExecutionPayloadchanges": "When building a consensusExecutionPayload, thereceipts_rootis now based on theReceipttype, changing the type ofreceipts_rootfrom an MPTHash32to an SSZRoot.", "Networking": "When exchanging SSZ receipts via theEthereum Wire Protocol, the followingEIP-2718compatible envelope is used:", "Rationale": "Switching to a single, unified and forward compatible receipt format within execution blocks reduces implementation complexity for client applications and smart contracts. Individual chunks of receipt data can now be verified, simplifying implementation of bridges.", "Backwards Compatibility": "Applications that rely on the replaced MPTreceipts_rootin the block header require migration to the SSZreceipts_root.", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6493, "url": "https://eips.ethereum.org/EIPS/eip-6493", "title": "SSZ transaction signature scheme", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Gajinder Singh\u00a0(", "@g11tech", ")", "Matt Garnett\u00a0(", "@lightclient", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-6493: SSZ transaction signature scheme": "This EIP defines a signature scheme for nativeSimple Serialize (SSZ)encoded transactions.", "Signature scheme for native SSZ transactions": "This EIP defines a signature scheme for nativeSimple Serialize (SSZ)encoded transactions.", "Abstract": "This EIP defines a signature scheme for nativeSimple Serialize (SSZ)encoded transactions.", "Motivation": "EIP-6404introduces SSZ transactions by converting from RLP transactions. Defining a signature scheme for native SSZ transactions further reduces required conversions and unlocks the forward compatibility benefits of SSZStableContainer.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Transaction signature scheme": "Native SSZ transactions are based on theTransactionPayloadandTransactiontypes defined inEIP-6404and emit anEIP-6466Receipt. To distinguish native SSZ transactions from those converted from RLP, native SSZ transactions do not set an RLPTransactionTypein theirTransactionPayload.", "JSON-RPC": "Certain JSON-RPC endpoints such aseth_getTransactionByHashindicate the correspondingEIP-2718envelope type prefix in atypefield.", "Transactionprofiles": "NewEIP-7495Profiledefinitions are introduced to represent native SSZ transactions:", "Rationale": "The SSZ signature scheme reduces hashing overhead and ensures thattx_hashcommitments are available on-chain. It also provides a flexible basis for future transaction functionality.", "Backwards Compatibility": "The new transaction signature scheme is solely used for SSZ transactions and is represented using a differentEIP-2718envelope type prefix as existing RLP transactions.", "Security Considerations": "SSZ signatures MUST NOT collide with RLP transaction and message hashes.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6690, "url": "https://eips.ethereum.org/EIPS/eip-6690", "title": "EVM Modular Arithmetic Extensions", "authors": ["Jared Wasinger\u00a0(", "@jwasinger", ")", "Alex Beregszaszi\u00a0(", "@axic", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")", "Rados\u0142aw Zag\u00f3rowicz\u00a0(", "@rodiazet", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")"], "sections": {"EIP-6690: EVM Modular Arithmetic Extensions": "This EIP proposes new EVM modular arithmetic opcodes which support operations on odd or power-of-two moduli between 3 and 2**768-1", "Expanded-width, efficient modular arithmetic operations for the EVM": "This EIP proposes new EVM modular arithmetic opcodes which support operations on odd or power-of-two moduli between 3 and 2**768-1", "Abstract": "This EIP proposes new EVM modular arithmetic opcodes which support operations on odd or power-of-two moduli between 3 and 2**768-1", "Motivation": "Current opcodes for modular arithmetic only support values up to 256 bits wide.  In addition, they are permissive and accept any representable value for the inputs.", "Specification": "The execution state of an EVM call frame is modified to include a mapping ofid(a number 0-256) to a field context.  A field context comprises a modulus and an allocated space of virtual registers to perform modular arithmetic operations on.", "Constants": "The execution state of an EVM call frame is modified to include a mapping ofid(a number 0-256) to a field context.  A field context comprises a modulus and an allocated space of virtual registers to perform modular arithmetic operations on.", "Conventions": "The execution state of an EVM call frame is modified to include a mapping ofid(a number 0-256) to a field context.  A field context comprises a modulus and an allocated space of virtual registers to perform modular arithmetic operations on.", "Overview": "The execution state of an EVM call frame is modified to include a mapping ofid(a number 0-256) to a field context.  A field context comprises a modulus and an allocated space of virtual registers to perform modular arithmetic operations on.", "New Opcodes": "Input:<top of stack> id modulus_offset modulus_size alloc_count.", "EVM Memory Expansion Cost Modification": "When expanding EVM memory or allocating a new field context viaSETMODX, expansion cost will now consider the size of all allocated virtual registers in the current call frame.", "Rationale": "It is assumed that optimized implementations will not store values in EVM-compatible big-endian serialization format, but instead convert them to an internal working representation.  The costs in the spec explicitly reflect the choice of Montgomery form as an optimal internal representation.", "Separation of EVM Memory and EVMMAX Virtual Register Space": "It is assumed that optimized implementations will not store values in EVM-compatible big-endian serialization format, but instead convert them to an internal working representation.  The costs in the spec explicitly reflect the choice of Montgomery form as an optimal internal representation.", "Total Virtual Register Allocation Cap": "24576 bytes is chosen as the per-call-context allocation limit with the goal of ensuring that the virtual register space can be contained in the L1 CPU data cache of most machines (with room to spare), in order that arithmetic operation costs do not have to account for memory access latency.", "SETMODX cost": "For odd moduli,SETMODXprecomputes two values used for optimized modular multiplication via Montgomery reduction.  This is dominated by a modular reduction by the modulus, so the cost model is assumed to be linear.", "LOADX/STOREX costs": "For power-of-two moduli,LOADX/STOREXare assumed to copy values directly between EVM/EVMMAX memories without measurable conversion cost to convert between EVM big-endian serialization and whatever internal representation is used.", "Arithmetic Costs": "Addition/subtraction/multiplication are assumed to have constant-time implementations.  Addition/subtraction can be implemented with linear complexity, while multiplication is quadratic in the size of the modulus.", "Montgomery Modular Multiplication": "For a valueA, an odd modulusMand a valueR(must be coprime and greater thanM, chosen as a power of two for efficient performance), the Montgomery representation isA * R % M.", "Test Cases": "There are tests contained in the Geth implementation.  However, no cross-client tests exist yet.", "Reference Implementation": "There is an implementation of this EIP in an open PR to Go Ethereum.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6800, "url": "https://eips.ethereum.org/EIPS/eip-6800", "title": "Ethereum state using a unified verkle tree", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Dankrad Feist\u00a0(", "@dankrad", ")", "Kevaundray Wedderburn\u00a0(", "@kevaundray", ")", "Guillaume Ballet\u00a0(", "@gballet", ")", "Piper Merriam\u00a0(", "@pipermerriam", ")", "Gottfried Herold\u00a0(", "@GottfriedHerold", ")", "Ignacio Hagopian\u00a0(", "@jsign", ")", "Tanishq Jasoria\u00a0(", "@tanishqjasoria", ")", "Gajinder Singh\u00a0(", "@g11tech", ")", "Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-6800: Ethereum state using a unified verkle tree": "Introduce a new Verkle state tree alongside the existing hexary Patricia tree. After the hard fork, the Verkle tree stores all edits to state and a copy of all accessed state, and the hexary Patricia tree can no longer be modified. This is a first step in a multi-phase transition to Ethereum exclusively relying on Verkle trees to store execution state.", "This introduces a new Verkle state tree alongside the existing MPT.": "Introduce a new Verkle state tree alongside the existing hexary Patricia tree. After the hard fork, the Verkle tree stores all edits to state and a copy of all accessed state, and the hexary Patricia tree can no longer be modified. This is a first step in a multi-phase transition to Ethereum exclusively relying on Verkle trees to store execution state.", "Abstract": "Introduce a new Verkle state tree alongside the existing hexary Patricia tree. After the hard fork, the Verkle tree stores all edits to state and a copy of all accessed state, and the hexary Patricia tree can no longer be modified. This is a first step in a multi-phase transition to Ethereum exclusively relying on Verkle trees to store execution state.", "Motivation": "Verkle trees solve a key problem standing in the way of Ethereum being stateless-client-friendly: witness sizes. A witness accessing an account in today\u2019s hexary Patricia tree is, in the average case, close to 3 kB, and in the worst case it may be three times larger. Assuming a worst case of 6000 accesses per block (15m gas / 2500 gas per access), this corresponds to a witness size of ~18 MB, which is too large to safely broadcast through a p2p network within a 12-second slot. Verkle trees reduce witness sizes to ~200 bytes per account in the average case, allowing stateless client witnesses to be acceptably small.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Verkle tree definition": "We define a Verkle tree here by providing the function to compute the root commitment given a set of 32-byte keys and 32-byte values. Algorithms for updating and inserting values are up to the implementer; the only requirement is that the root commitment after the update must continue to match the value computed from this specification. We will then define an embedding that provides the 32-byte key at which any particular piece of state information (account headers, code, storage) should be stored.", "Illustration": "This is an illustration of the tree structure.", "Tree embedding": "Instead of a two-layer structure as in the Patricia tree, in the Verkle tree we will embed all information into a singlekey: valuetree. This section specifies which tree keys store the information (account header data, code, storage) in the state.", "Rationale": "This implements all of the logic in transitioning to a Verkle tree, and at the same time reforms gas costs, but does so in a minimally disruptive way that does not require simultaneously changing the whole tree structure. Instead, we add a new Verkle tree that starts out empty, and only new changes to state and copies of accessed state are stored in the tree. The Patricia tree continues to exist, but is frozen.", "Verkle tree design": "The Verkle tree uses a single-layer tree structure with 32-byte keys and values for several reasons:", "Gas reform": "Gas costs for reading storage and code are reformed to more closely reflect the gas costs under the new Verkle tree design. WITNESS_CHUNK_COST is set to charge 6.25 gas per byte for chunks, and WITNESS_BRANCH_COST is set to charge ~13,2 gas per byte for branches on average (assuming 144 byte branch length) and ~2.5 gas per byte in the worst case if an attacker fills the tree with keys deliberately computed to maximize proof length.", "Backwards Compatibility": "The main backwards-compatibility-breaking changes are:", "Test Cases": "TODO", "Reference Implementation": "Needs discussion.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6888, "url": "https://eips.ethereum.org/EIPS/eip-6888", "title": "Arithmetic verification at EVM level", "authors": ["Renan Rodrigues de Souza\u00a0(", "@RenanSouza2", ")"], "sections": {"EIP-6888: Arithmetic verification at EVM level": "This EIP adds arithmetics checks to EVM arithmetic and a new opcode jump conditionally if there were events. The list of check includes overflows, division by zero.", "Check for math overflows and division by zero at EVM level": "This EIP adds arithmetics checks to EVM arithmetic and a new opcode jump conditionally if there were events. The list of check includes overflows, division by zero.", "Abstract": "This EIP adds arithmetics checks to EVM arithmetic and a new opcode jump conditionally if there were events. The list of check includes overflows, division by zero.", "Motivation": "The importance of math checks in smart contract projects is very clear. It was an OpenZeppelin library and then incorporated in Solidity\u2019s default behavior. Bringing this to EVM level can combine both gas efficiency and safety.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Constants": "Two new flags are added to the EVM state: unsigned warning (carry) and signed warning (overflow). The scope of those flags are the same as the program counter.", "Flags": "Two new flags are added to the EVM state: unsigned warning (carry) and signed warning (overflow). The scope of those flags are the same as the program counter.", "Definitions": "From this point forwarda,bandcreferences the arguments in a math operation andresthe output.cis only used if the operation takes 3 inputs.", "Contidions": "Thecarryflag MUST be set in the following circumstances:", "Opcodes": "Consumes one argument from the stack, the possible pc dest,\nConditionally alter the program counter depending on thecarryflag.J_JUMPC = carry ? \u00b5_s[0] : \u00b5_pc + 1Clears both flags.carry = overflow = false", "gas": "The gas cost for both instructions isG_high, the same asJUMPI.", "Rationale": "EVM uses two\u2019s complement for negative numbers. The opcodes listed above triggers one or two flags depending if they are used for signed and unsigned numbers.", "Backwards Compatibility": "This EIP introduces a new opcode and changes int EVM behavior.", "Test Cases": "TBD", "Reference Implementation": "TBD", "Security Considerations": "This is a new EVM behavior but each code will decide how to interact with it.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7503, "url": "https://eips.ethereum.org/EIPS/eip-7503", "title": "Zero-Knowledge Wormholes", "authors": ["Keyvan Kambakhsh\u00a0(", "@keyvank", ")", "Hamid Bateni\u00a0(", "@irnb", ")", "Amir Kahoori\u00a0<", "a.kahoorizadeh@gmail.com", ">", "Nobitex Labs\u00a0<", "labs@nobitex.ir", ">", "0xwormhole\u00a0(", "@0xwormhole", ")"], "sections": {"EIP-7503: Zero-Knowledge Wormholes": "While researching on privacy solutions and applications of ZKP, we discovered a technique, \nby which people can burn their digital asset (E.g ETH) by sending it to an unspendable address, \nand later build a ZK proof showing that some amount of tokens reside in an account that are \nunspendable, without revealing the account.", "Enable minting of secretly burnt Ethers as a native privacy solution for Ethereum": "While researching on privacy solutions and applications of ZKP, we discovered a technique, \nby which people can burn their digital asset (E.g ETH) by sending it to an unspendable address, \nand later build a ZK proof showing that some amount of tokens reside in an account that are \nunspendable, without revealing the account.", "Abstract": "While researching on privacy solutions and applications of ZKP, we discovered a technique, \nby which people can burn their digital asset (E.g ETH) by sending it to an unspendable address, \nand later build a ZK proof showing that some amount of tokens reside in an account that are \nunspendable, without revealing the account.", "Specification": "We define a newEIP-2718transaction type, whereTransactionTypeisWormholeTxTypeand theTransactionPayloadformat is as follows:", "Parameters": "We define a newEIP-2718transaction type, whereTransactionTypeisWormholeTxTypeand theTransactionPayloadformat is as follows:", "Rationale": "In Elliptic-Curve based digital signatures, normally there is a secret scalar $s$, from which \na public-key is calculated (By multiplying the generator point with the scalar: $s \\times G$). An \nEthereum EOA-address is the keccak hash of a public-key.", "Scalability Implications": "In case the circuits are able to simultaneously re-mint the sum of multiple burns in a single-proof, \nmerchants and CEXs will be able to accept their payments in burn-addresses and accumulate their funds\nin a single address by storing a single proof (And a bunch of nullifiers) on the blockchain, which\nsignificantly reduces the transaction count on the blockchain. The people who will use this EIP as a\nscalability solution, will also increase the privacy guarantees of the protocol.", "Backwards Compatibility": "The Ethers generated using the mint function should not have any difference with original Ethers.\nPeople should be able to use those minted Ethers for paying the gas fees.", "Reference Implementation": "To be determined (TBD).", "ZK-SNARK Implementation": "Also TBD, but the implementation must meet the following conditions:", "Security Considerations": "In case of faulty implementation of this EIP, people may mint infinite amount of ETH, collapsing the price of Ethereum.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7519, "url": "https://eips.ethereum.org/EIPS/eip-7519", "title": "Atomic Storage Operations SCREDIT and SDEBIT", "authors": ["Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-7519: Atomic Storage Operations SCREDIT and SDEBIT": "Two new opcodes that atomically mutate smart contract storage are proposed:\nSCREDIT, which increments a storage slot by a specified value, and SDEBIT, which\ndecrements a storage slot by a specified value. Overflow and underflow errors\nare enforced, reverting when an unsigned 256-bit integer would overflow or\nunderflow.", "Add atomic operations for incrementing and decrementing storage slots": "Two new opcodes that atomically mutate smart contract storage are proposed:\nSCREDIT, which increments a storage slot by a specified value, and SDEBIT, which\ndecrements a storage slot by a specified value. Overflow and underflow errors\nare enforced, reverting when an unsigned 256-bit integer would overflow or\nunderflow.", "Abstract": "Two new opcodes that atomically mutate smart contract storage are proposed:\nSCREDIT, which increments a storage slot by a specified value, and SDEBIT, which\ndecrements a storage slot by a specified value. Overflow and underflow errors\nare enforced, reverting when an unsigned 256-bit integer would overflow or\nunderflow.", "Motivation": "There has been a large amount of energy around parallel EVMs across multiple\nchains, however there is a lack of parallel primitives within the EVM to support\nany model other than optimistic concurrency control (OCC). By adding concurrent\nincrement and decrement operations more advanced parallel environments can be\nintroduced in Layer 2 networks.", "Specification": "Two operations to atomically increment and decrement a storage will be\nintroduced\nat0xTBD. Each operation takes two stack arguments and has no immediate\narguments. Gas schedule will be the same as SSTORE.", "SCREDIT": "SCREDIT: slot, value", "SDEBIT": "SDEBIT: slot, value", "Rationale": "The primary consideration when choosing between alternatives is that the primary\nintended audiences is token contracts and other asset-tracking contracts\ncombined with a desire to ship the minimum necessary changes to enable that use\ncase. General concurrency controls is not a goal of this EIP.", "Enforcing Overflow Semantics": "When allowing for out-of-order execution there needs to be mechanism to handle\nany possible order of execution. OCC handles this by validating pre- and\npost-conditions, and re-evaluating the transactions if those invariants did not\nhold. This technique breaks down around writing to balances and counters.", "Gas Schedule": "The decision to cost the operations at the exact same value as SSTORE is partly\nfor ease of implementation and partly as an incentive to compilers and\ndevelopers.", "Storage Slots Only": "This most important use case for this EIP asset balances and not general\nconcurrency controls. Hence, only enabling credit and debit operations on\nstorage slots (which persist across transactions). Parallel execution within a\ntransaction and more generic tools like locks and semaphores have very limited\nutility within this scope. The lack of in-transaction parallel execution also\nprecludes the use of such primitives against transient storage (as defined inEIP-1153).", "Opcode Instead of System Contract": "One alternative, particularly viable for Layer 2 chains, would be to implement\nSCREDIT and SDEBIT as system contracts. The primary objection to system\ncontracts for other operations is the gas cost overhead of constructing a call.\nBecause a SSTORE is always greater than the cost of a call it would be possible\nto build in a discount. However, there is no such accommodation that can be made\nfor the code size needed to invoke such a call.", "Backwards Compatibility": "These opcodes are not simple replacements for SLOAD-(ADD|SUB)-SSTORE sequence\nbecause there is an overflow/underflow check", "Test Cases": "Test for overflow and non-overflow for the following values and values before\nand after:", "Reference Implementation": "/# TBD", "Security Considerations": "The use of revert to handle over/underflow represents a new halt condition that\nauditors will need to consider when examining reentrancy concerns.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7557, "url": "https://eips.ethereum.org/EIPS/eip-7557", "title": "Block-level Warming with fair cost savings", "authors": ["Yoav Weiss\u00a0(", "@yoavw", ")", "Alex Forshtat\u00a0(", "@forshtat", ")", "Dror Tirosh\u00a0(", "@drortirosh", ")", "Shahaf Nacson\u00a0(", "@shahafn", ")"], "sections": {"EIP-7557: Block-level Warming with fair cost savings": "A mechanism for a fair distribution of the gas costs associated with access to addresses and storage slots\namong multiple transactions with shared items in theiraccessList.", "Block-level warming of addresses and slots with access lists": "A mechanism for a fair distribution of the gas costs associated with access to addresses and storage slots\namong multiple transactions with shared items in theiraccessList.", "Abstract": "A mechanism for a fair distribution of the gas costs associated with access to addresses and storage slots\namong multiple transactions with shared items in theiraccessList.", "Motivation": "EIP-2929: Gas cost increases for state access opcodesintroduced a new gas cost model that differentiates\nbetween \u201ccold\u201d and \u201cwarm\u201d access to accounts and storage slots.", "Specification": "TheEIP-2930: Optional access listsalready introduced the first part of the solution.\nEach transaction can specify an array ofaccessed_addressesandaccessed_storage_keysto announce its intention to\nread those values during the execution of the transaction.", "Overview": "During the transaction execution, the cost of all storage-related operations is not affected,\nand all rules from EIP-2929 and EIP-2930 continue to apply.", "Participant transactions mapping": "After the block builder finalizes the contents of the block, it iterates over all included transactions to read\ntheaccessListcomponent of each supported transaction.", "Calculating a reimbursement of the burned base fee": "Considering that the same amount of computation is needed to access an address or a slot regardless of the number of\ntransactions using one, it is reasonable for the protocol to only burn the gas cost of the cold access once.\nAs all transactions in the same block pay exactly the samebaseFeePerGas, the single cost of accessing a cold item is\ndivided evenly among all transactions containing such access and the rest of the burned base fee is reimbursed.", "Setting an absolute minimal cost of cold state access": "If a large number of transactions all access the same addresses or slots, the cost of each cold access may get\nway too low which may represent a potential DoS attack vector.", "Calculating a reimbursement of the charged priority fee": "Each transaction pays an individualpriorityFeePerGasvalue and redistributing this part of the cold access cost\nis more complex.", "Efficiently storing the access lists in the block history": "The contents of theaccessListparameter are part of the Ethereum history and the potential cost of keeping this\ndata in the blockchain must be accounted for when implementing this change.\nThere is currently no additional charge applied to theaccessListparameter, due to the cost of including\nan address or a storage slot in theaccessListbeing a constant value that is significantly higher than the\npotential cost of storing theaccessListat the cost of  a\ndynamically sizedcalldatafield.", "Pseudocode implementation of the reimbursement calculation algorithm": "Note that two accumulating values,reimbursementFromBurnandreimbursementFromCoinbase,\nare necessary in light ofEIP-1559: Fee market change for ETH 1.0 chainin order to differentiate\nbetween the Ether reimbursement that is originating from a reduced block gas burn,\nand from the reduced block proposer priority fee per gas reward.", "Future EIP-6800 gas reform support": "OnceEIP-6800is active, the cost of accessing a contract code for a cold address is expected to change.", "Cost redistribution system operation": "TheEIP-4895: Beacon chain push withdrawals as operationssets a precedent by introducing a concept of asystem-level withdrawal operation.", "Rationale": "As described in theMotivationsection, the amount of gas that users spend on accessing the contract code does not reflect the actual cost of this access for the block builder or a validator.", "Current cold storage gas cost is unfair": "As described in theMotivationsection, the amount of gas that users spend on accessing the contract code does not reflect the actual cost of this access for the block builder or a validator.", "Issuing a regular gas refund after a transaction is not possible": "There exists a list of EVM instructions that trigger both a gas charge and a gas refund.\nA notable example of such operations is the0x55 SSTOREopcode as defined inEIP-1283: Net gas metering for SSTORE without dirty maps.\nIntuitively it seems reasonable to issue the gas reimbursements for the shared cold storage access in the same fashion.", "Weighting priority fee reimbursement": "A common game-theoretical answer to the problem of calculating a fair redistribution of the payoff of the\nresults of the participants\u2019 cooperation is the use of Shapley values.", "Backwards Compatibility": "This proposal does not introduce a change to any behavior that can be observed by a smart contract during its execution.\nThe only effect this change has is a lower effective gas cost for the transaction senders.", "Security Considerations": "The upper limit of storage reads in one block is not affected by this change as the gas charge is done with the\nfull cost ofCOLD_ACCOUNT_ACCESS_COSTorCOLD_SLOAD_COST.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7612, "url": "https://eips.ethereum.org/EIPS/eip-7612", "title": "Verkle state transition via an overlay tree", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")", "Ignacio Hagopian\u00a0(", "@jsign", ")", "Gottfried Herold\u00a0(", "@GottfriedHerold", ")", "Jamie Lokier\u00a0(", "@jlokier", ")", "Tanishq Jasoria\u00a0(", "@tanishqjasoria", ")", "Parithosh Jayanthi\u00a0(", "@parithosh", ")", "Gabriel Rocheleau\u00a0(", "@gabrocheleau", ")", "Karim Taam\u00a0(", "@matkt", ")"], "sections": {"EIP-7612: Verkle state transition via an overlay tree": "This EIP proposes a method to switch the state tree tree format from hexary Merkle Patricia Tree (MPT) to a Verkle Tree (VKT): the MPT tree is frozen, and new writes to the state are stored in a VKT \u201claid over\u201d the hexary MPT. The historical MPT state is left untouched and its eventual migration is handled at a later time.", "Describes the use of an overlay tree to use the verkle tree structure, while leaving the historical state untouched.": "This EIP proposes a method to switch the state tree tree format from hexary Merkle Patricia Tree (MPT) to a Verkle Tree (VKT): the MPT tree is frozen, and new writes to the state are stored in a VKT \u201claid over\u201d the hexary MPT. The historical MPT state is left untouched and its eventual migration is handled at a later time.", "Abstract": "This EIP proposes a method to switch the state tree tree format from hexary Merkle Patricia Tree (MPT) to a Verkle Tree (VKT): the MPT tree is frozen, and new writes to the state are stored in a VKT \u201claid over\u201d the hexary MPT. The historical MPT state is left untouched and its eventual migration is handled at a later time.", "Motivation": "The Ethereum state is growing, and VKTs offer a good mitigation strategy to stem this growth and enable weak statelessness. Owing to the difficulty of translating contracts with large storage while they are being accessed, proposals for migrating the current MPT state are complex and will require client teams to undergo a long process of refactoring their code to handle this conversion.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Constants": "In the execution spec, modify theStateclass as such:", "Helper functions": "In the execution spec, modify theStateclass as such:", "Changes to the execution spec": "In the execution spec, modify theStateclass as such:", "Changes to the block header": "AtFORK_TIMEthe block header state root is changed from the MPT root to the VKT root.", "Rationale": "This approach doesn\u2019t convert the state, which is left to a subsequent EIP. This is meant as a stopgap in case we decide to push the conversion itself to a later time. It has the advantage of simplicity, which means that the Verge fork could happen at the same time as other, simpler EIPs. It also requires no change at the consensus layer.", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "Needs discussion.", "Reference Implementation": "Needs discussion.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7701, "url": "https://eips.ethereum.org/EIPS/eip-7701", "title": "Native Account Abstraction with EOF", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Yoav Weiss\u00a0(", "@yoavw", ")", "Alex Forshtat\u00a0(", "@forshtat", ")", "Dror Tirosh\u00a0(", "@drortirosh", ")", "Shahaf Nacson\u00a0(", "@shahafn", ")"], "sections": {"EIP-7701: Native Account Abstraction with EOF": "We propose splitting the Ethereum transaction scope into multiple steps: validations, execution, and post-operation logic. Transaction validity is determined by the result of the validation steps of a transaction.", "Native Account Abstraction protocol, relying on EOF code sections, new transaction type and a family of opcodes": "We propose splitting the Ethereum transaction scope into multiple steps: validations, execution, and post-operation logic. Transaction validity is determined by the result of the validation steps of a transaction.", "Abstract": "We propose splitting the Ethereum transaction scope into multiple steps: validations, execution, and post-operation logic. Transaction validity is determined by the result of the validation steps of a transaction.", "Motivation": "Native Account Abstraction allows custom validation logic of a transaction and custom gas payment logic, opening new use-cases and features for wallets and dApps.", "Specification": "A newEIP-2718transaction with typeAA_TX_TYPEis introduced.\nTransactions of this type are referred to as \u201cAA transactions\u201d.", "Constants": "A newEIP-2718transaction with typeAA_TX_TYPEis introduced.\nTransactions of this type are referred to as \u201cAA transactions\u201d.", "New Transaction Type": "A newEIP-2718transaction with typeAA_TX_TYPEis introduced.\nTransactions of this type are referred to as \u201cAA transactions\u201d.", "Definitions": "The base gas cost of this transaction is set toAA_BASE_GAS_COSTinstead of 21000 to reflect the lack of \u201cintrinsic\u201d\nECDSA signature verification.", "System-level code entry points": "Modify the EOF container format, by adding the fieldskind_entry_pointsandentry_points_sizeto the container header, and adding a sectionentry_points_sectionto the container body.", "Validation and PostOp code entry points": "We define the following as a validentry_point_rolevalues:", "Non-EOF Proxy Contract Support": "We want to support legacy proxy contracts upgrading to add EIP-7701 support.", "Execution entry point for Sender, Paymaster and Deployer": "During a regular contract code execution, its behaviour is defined as follows by EIP-3540:", "NewTXPARAMLOAD,TXPARAMSIZE, andTXPARAMCOPYopcodes": "Accessing transaction details within call frames is performed using the newTXPARAM*opcode family.\nThe instructions are followed by an 8-bit immediate value, which we calln, and can have a value of 0 to 255.", "Limitations onTXPARAM*opcodes": "TheexecutionStatusandexecutionGasCostparameters are only accessible in therole_paymaster_post_opsection.", "Transaction Execution Flow": "All legacy transaction types only have an implicit validation phase where balance, nonce, and signature are checked,\nand an implicit execution phase with a single top-level execution frame.", "Transaction execution context": "Note that some behaviours in the EVM depend on the transaction context. These behaviours include:", "Costs of accessing cold addresses for Sender, Paymaster and Deployer": "The Sender address is pre-warmed as part of theAA_BASE_GAS_COST.", "Flow diagrams": "", "Pseudocode": "The validation section of a Smart Contract Account code needs to have full access to the majority of transaction\ndetails in order to be able to make an informed decision about either accepting or rejecting the transaction.", "Rationale": "The validation section of a Smart Contract Account code needs to have full access to the majority of transaction\ndetails in order to be able to make an informed decision about either accepting or rejecting the transaction.", "Introduction of theTXPARAM*opcode family": "The validation section of a Smart Contract Account code needs to have full access to the majority of transaction\ndetails in order to be able to make an informed decision about either accepting or rejecting the transaction.", "Backwards Compatibility": "An EOF contract withkind_entry_pointssection is not valid according to EIP-3540 and cannot exist on-chain\nbefore this proposal is implemented.", "Security Considerations": "As thekind_entry_pointscode sections represent a generic way to authorize any action on behalf of the contract,\ncorrect and secure implementation of this code is critical.\nWe expect that compilers targeting EVM will play a major role in enabling and ensuring Smart Contract Accounts\u2019 security.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7703, "url": "https://eips.ethereum.org/EIPS/eip-7703", "title": "Increase calldata cost", "authors": ["William Morriss\u00a0(", "@wjmelements", ")"], "sections": {"EIP-7703: Increase calldata cost": "An adjustment in the Ethereum calldata cost which reduces the maximum possible block size and allows a higher block gas limit.", "Increase calldata cost to decrease the maximum block size": "An adjustment in the Ethereum calldata cost which reduces the maximum possible block size and allows a higher block gas limit.", "Abstract": "An adjustment in the Ethereum calldata cost which reduces the maximum possible block size and allows a higher block gas limit.", "Motivation": "Larger blocks take longer to propagate through the network. \nIn this way, the maximum potential block size is constraining the block gas limit.\nTherefore, in order to safely increase the block gas limit, the calldata gas must be increased.", "Specification": "Tripling the gas cost of calldata reduces the maximum possible block size by a factor of three.", "Rationale": "Tripling the gas cost of calldata reduces the maximum possible block size by a factor of three.", "Backwards Compatibility": "Activation can cause some transactions to revert due to the increased gas costs.\nAhead of activation,eth_estimateGascould be calculated using the new parameters in order to provide results viable for activation, avoiding out-of-gas reverts.", "Security Considerations": "No security issues have been found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7709, "url": "https://eips.ethereum.org/EIPS/eip-7709", "title": "Read BLOCKHASH from storage and update cost", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Tomasz Stanczak\u00a0(", "@tkstanczak", ")", "Guillaume Ballet\u00a0(", "@gballet", ")", "Gajinder Singh\u00a0(", "@g11tech", ")", "Tanishq Jasoria\u00a0(", "@tanishqjasoria", ")", "Ignacio Hagopian\u00a0(", "@jsign", ")", "Jochem Brouwer\u00a0(", "@jochem-brouwer", ")", "Gabriel Rocheleau\u00a0(", "@gabrocheleau", ")"], "sections": {"EIP-7709: Read BLOCKHASH from storage and update cost": "Update theBLOCKHASH (0x40)opcode to read and serve from the system contract storage and charge theadditional(cold or warm) storage costs.", "Read the `BLOCKHASH (0x40)` opcode from the EIP-2935 system contract storage and adjust its gas cost to reflect storage access.": "Update theBLOCKHASH (0x40)opcode to read and serve from the system contract storage and charge theadditional(cold or warm) storage costs.", "Abstract": "Update theBLOCKHASH (0x40)opcode to read and serve from the system contract storage and charge theadditional(cold or warm) storage costs.", "Motivation": "TheBLOCKHASH (0x40)opcode currently assumes that the client has knowledge of the previous blocks, which in VerkleEIP-6800would prevent stateless execution. However withEIP-2935blockhashes can be retrieved and served from its system contract storage which allows Verkle blocks to include a storage access witness for stateless execution.", "Specification": "TheBLOCKHASHopcode semantics remains the same as before. From thefork_block(defined asfork_block.timestamp >= FORK_TIMESTAMP and fork_block.parent.timestamp < FORK_TIMESTAMP), theBLOCKHASHinstruction should be updated to resolve block hash in the following manner:", "Activation": "This EIP specifies the transition to the new logic assuming thatEIP-2935has been activated:", "Gas costs": "As described above, if theargto be resolved is within the correct window, the correspondingSLOADcharges and accesses are to be applied for the slotarg % HISTORY_SERVE_WINDOW. Note that theHISTORY_SERVE_WINDOWandBLOCKHASH_SERVE_WINDOWare different.", "Reading from the System contract": "Even if the clients choose to resolveBLOCKHASHthrough system call toEIP-2935contract, the gas cost for the system code execution (and also the code witnesses if Verkle activated) is not applied. Only the effect ofSLOADis applied as described above.", "Rationale": "Note thatBLOCKHASHopcode only serves a limitedBLOCKHASH_SERVE_WINDOWto be backward compatible (and to not extend the above exemptions). For deeper accesses one will need to directly callEIP-2935system contract which will lead to a normal contract execution (as well as charges and accesses)", "Backwards Compatibility": "This EIP introduces a significant increase in the cost ofBLOCKHASH, which could break use-cases that rely on the previous gas cost. Also, this EIP introduces a breaking change in the case where less thanBLOCKHASH_SERVE_WINDOWelapse between theEIP-2935fork and this EIP\u2019s fork (unlessEIP-2935is activated in genesis for e.g. in testnets/devnets) as theEIP-2935system contract would not have saved the required history.", "Test Cases": "No security considerations other than the ones contained inEIP-2935are determined as of now.", "Security Considerations": "No security considerations other than the ones contained inEIP-2935are determined as of now.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7732, "url": "https://eips.ethereum.org/EIPS/eip-7732", "title": "Enshrined Proposer-Builder Separation", "authors": ["Francesco D'Amato\u00a0<", "francesco.damato@ethereum.org", ">", "Barnab\u00e9 Monnot\u00a0<", "barnabe.monnot@ethereum.org", ">", "Michael Neuder\u00a0<", "michael.neuder@ethereum.org", ">", "Potuz\u00a0(", "@potuz", ")", "Terence Tsao\u00a0<", "ttsao@offchainlabs.com", ">"], "sections": {"EIP-7732: Enshrined Proposer-Builder Separation": "This EIP fundamentally changes the way an Ethereum block is validated by decoupling the execution validation from the consensus validation both logically as well as temporally. It does so by introducing a new optional attribution (being abuilder) and a new duty (submittingpayload timeliness attestations) to Ethereum validators. TheExecutionPayloadfield of theBeaconBlockBodyis removed and instead it is replaced by a signed commitment (aSignedExecutionPayloadHeaderobject) from a builder to later reveal the corresponding execution payload. This commitment specifies in particular the blockhash of the execution block and avalueto be paid to the beacon block proposer. When processing theBeaconBlock, the committed value is deducted from the builder\u2019s beacon chain balance and credited to the beacon block proposer. A subset of validators in the beacon committee is assigned to thePayload Timeliness Committee(PTC), these validators are tasked to attest (by broadcasting aPayloadAttestationMessage) to whether the corresponding builder has revealed the committed execution payload (with the right blockhash) in a timely fashion. PTC members are not required to validate the execution payload, execution validation is thus deferred until the next beacon block validation.", "Separates the ethereum block in consensus and execution parts, adds a mechanism for the consensus proposer to choose the execution proposer.": "This EIP fundamentally changes the way an Ethereum block is validated by decoupling the execution validation from the consensus validation both logically as well as temporally. It does so by introducing a new optional attribution (being abuilder) and a new duty (submittingpayload timeliness attestations) to Ethereum validators. TheExecutionPayloadfield of theBeaconBlockBodyis removed and instead it is replaced by a signed commitment (aSignedExecutionPayloadHeaderobject) from a builder to later reveal the corresponding execution payload. This commitment specifies in particular the blockhash of the execution block and avalueto be paid to the beacon block proposer. When processing theBeaconBlock, the committed value is deducted from the builder\u2019s beacon chain balance and credited to the beacon block proposer. A subset of validators in the beacon committee is assigned to thePayload Timeliness Committee(PTC), these validators are tasked to attest (by broadcasting aPayloadAttestationMessage) to whether the corresponding builder has revealed the committed execution payload (with the right blockhash) in a timely fashion. PTC members are not required to validate the execution payload, execution validation is thus deferred until the next beacon block validation.", "Abstract": "This EIP fundamentally changes the way an Ethereum block is validated by decoupling the execution validation from the consensus validation both logically as well as temporally. It does so by introducing a new optional attribution (being abuilder) and a new duty (submittingpayload timeliness attestations) to Ethereum validators. TheExecutionPayloadfield of theBeaconBlockBodyis removed and instead it is replaced by a signed commitment (aSignedExecutionPayloadHeaderobject) from a builder to later reveal the corresponding execution payload. This commitment specifies in particular the blockhash of the execution block and avalueto be paid to the beacon block proposer. When processing theBeaconBlock, the committed value is deducted from the builder\u2019s beacon chain balance and credited to the beacon block proposer. A subset of validators in the beacon committee is assigned to thePayload Timeliness Committee(PTC), these validators are tasked to attest (by broadcasting aPayloadAttestationMessage) to whether the corresponding builder has revealed the committed execution payload (with the right blockhash) in a timely fashion. PTC members are not required to validate the execution payload, execution validation is thus deferred until the next beacon block validation.", "Motivation": "This EIP solves a different set of unrelated important problems.", "Specification": "No changes are required.", "Execution Layer": "No changes are required.", "Consensus Layer": "The full consensus changes can be found in the consensus-specs Github repository. They are split between:", "Engine API": "No changes needed.", "Rationale": "Being a builder is a new attribution of validators. As such builders are staked in the beacon chain. This allows for in-protocol trustless enforcement of the builder\u2019s payment to the proposer. Alternatively, payment could be enforced in the Execution Layer (EL) at the cost of adding the corresponding EL consensus-changing logic. Payments in the EL have the advantage of not requiring the builder to periodically submit deposit transactions to replenish their validator balance. Both systems require availability of funds before the payload is revealed: in the Consensus Layer (CL) this is done by getting builders to stake. In the EL this is done with a balance check and a payment transaction. This transaction can be checked without executing the payload only if it the first transaction of the block.", "Staked builders": "Being a builder is a new attribution of validators. As such builders are staked in the beacon chain. This allows for in-protocol trustless enforcement of the builder\u2019s payment to the proposer. Alternatively, payment could be enforced in the Execution Layer (EL) at the cost of adding the corresponding EL consensus-changing logic. Payments in the EL have the advantage of not requiring the builder to periodically submit deposit transactions to replenish their validator balance. Both systems require availability of funds before the payload is revealed: in the Consensus Layer (CL) this is done by getting builders to stake. In the EL this is done with a balance check and a payment transaction. This transaction can be checked without executing the payload only if it the first transaction of the block.", "Delayed validation": "The Payload Timeliness Committee members do not need to validate the execution payload before attesting to it. They perform basic checks such as verifying the builder\u2019s signature, and the correct blockhash is included. This takes away the full execution payload validation from the hot path of validation of an Ethereum block, giving the next proposer 6 seconds (SECONDS_PER_SLOT * 2 // INTERVALS_PER_SLOT) to validate the payload and every other validator 9 seconds (SECONDS_PER_SLOT * 3 // INTERVALS_PER_SLOT). From a user UX perspective, a transaction included in slotNby the builder is not widely validated until the proposer of slotN+1releases their beacon block on top of blockNfirst and the attesters of slotN+1vote on this beacon block as the head of the chain.", "(Block, Slot, Payload) - Fork choice": "The following features of fork choice are guaranteed under specified margins of security:", "Builder timeliness boosts": "When a builder reveals an expected payload and the PTC achieved consensus that it was timely, that is, when at leastPAYLOAD_TIMELY_THRESHOLDvotes have been received forPAYLOAD_PRESENT, the forkchoice node containing the full slot (that is the consensus block together with its payload present) receives a boost equivalent to 40% of the beacon committee.", "PTC equivocations": "There is no penalty for PTC nor payload equivocation (that is revealing the right payload and also a withheld message at the same time). A collusion of a builder controlling network partition with a single malicious PTC member could cause a split view by achieving consensus both on payload withheld and a payload present. This could be mitigated by settingPAYLOAD_TIMELY_THRESHOLDto be 2/3 of the PTC, in which case the malicious operator would have to control at least 33% of the PTC.", "Withdrawals": "Withdrawals from the beacon chain are complex in nature, they involve removing funds from one layer and crediting them on another, with different trigger mechanisms that can start from either layer. Before applying the consensus layer state transition function to a given beacon statepre_stateand processing a given signed beacon blockblock, the set of withdrawals that are expected to be deducted from the beacon chain are completely determined bypre_state. Previous to this EIP the set of withdrawals that are credited on the execution layer are included inblock. The block is deemed invalid if these withdrawals do not match. With the separation included in this EIP, these operations of deducting and crediting become asynchronous:", "Three state transition functions": "The current EIP adds an extra state transition function to the block processing in Ethereum. Processing aSignedBeaconBlockchanges the consensus layerBeaconState. ASignedExecutionPayloadEnvelopechanges both the execution layer state and the consensus layer one. As such, the envelope commits to the consensus layer post-state-transition beacon state root.", "Compatible designs": "This EIP is fully compatible with forward inclusion lists as specified inEIP-7547or similar.", "Backwards Compatibility": "This EIP introduces backward incompatible changes to the block validation rule set on the consensus layer and must be accompanied by a hard fork.", "Security Considerations": "PROPOSER_SCORE_BOOSTis reduced from 40 to 20. This does not allow however a ex-ante reorg by a proposer with 20% of the total stake as the attacker\u2019s payload will also not be included. Proposers are protected against1-slot sandwichreorgs by a colluding set of validators and builders controlling more than 20% of the total stake.", "Reorg resistance": "PROPOSER_SCORE_BOOSTis reduced from 40 to 20. This does not allow however a ex-ante reorg by a proposer with 20% of the total stake as the attacker\u2019s payload will also not be included. Proposers are protected against1-slot sandwichreorgs by a colluding set of validators and builders controlling more than 20% of the total stake.", "Builder safety": "The expected time for a malicious attacker, controlling 35% of the total stake, to have a majority control on the PTC is 205 000 years.", "Malicious PTC": "The expected time for a malicious attacker, controlling 35% of the total stake, to have a majority control on the PTC is 205 000 years.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7745, "url": "https://eips.ethereum.org/EIPS/eip-7745", "title": "Light client and DHT friendly log index", "authors": ["Zsolt Felf\u00f6ldi\u00a0(", "@zsfelfoldi", ")"], "sections": {"EIP-7745: Light client and DHT friendly log index": "Replace the fixed 2048 bit log event bloom filters in block headers with a new data structure that can adapt to the changing number of events per block and consistently guarantee a sufficiently low false positive ratio.", "An efficient, light client and DHT friendly replacement for block header bloom filters": "Replace the fixed 2048 bit log event bloom filters in block headers with a new data structure that can adapt to the changing number of events per block and consistently guarantee a sufficiently low false positive ratio.", "Abstract": "Replace the fixed 2048 bit log event bloom filters in block headers with a new data structure that can adapt to the changing number of events per block and consistently guarantee a sufficiently low false positive ratio.", "Motivation": "Adding logs has a significantly lower gas cost and should accordingly be less resource consuming than writing to the state. The original design of bloom filters in each block achieves this goal as there is no complex data structure like the state to update, the set of logs emitted in each block is all contained within the header and receipts belonging to that block. Logs mostly just have long term storage costs. On the other hand, searching logs in a long range of blocks is very expensive.", "Specification": "Beginning at the execution timestampFORK_TIMESTAMP, execution clients MUST replace thelogs_bloomfield of the header schema withlog_index_rootwhich is the root hash of theLogIndexstructure after adding the logs emitted in the given block.", "Terms and definitions": "Beginning at the execution timestampFORK_TIMESTAMP, execution clients MUST replace thelogs_bloomfield of the header schema withlog_index_rootwhich is the root hash of theLogIndexstructure after adding the logs emitted in the given block.", "Consensus data format": "Beginning at the execution timestampFORK_TIMESTAMP, execution clients MUST replace thelogs_bloomfield of the header schema withlog_index_rootwhich is the root hash of theLogIndexstructure after adding the logs emitted in the given block.", "Constructing the filter map": "For eachVALUES_PER_MAPlong section of thelog value indexspace afilter mapis generated. These are fixed sizeMAP_WIDTHbyMAP_HEIGHTsparse bit maps and eachlog valueis marked on the map with a single bit being set to one. Block delimiters are not marked on the map but otherwise the density of the maps are close to constant. The number of marks in a row (the length of the sparse encoded row) is referred to as \u201crow length\u201d, not to be confused with the constantMAP_WIDTH.", "Design goals": "The proposed data structure is intended to represent a balance between the cost of adding items and accessing old ones. Thefilter mapshave a fixed tree shape, making in-memory maintenance, Merkle hashing and DHT distribution easy to implement. Filter entries are sorted into rows based on content and position in a way that allows quick linear database access and size efficient Merkle proofs. The difficulties arising from certain types of events being much more frequent than others are also mitigated.", "Epochs and mapping layers": "In order to allow efficient search of a certainlog valuein a long historical range,filter mapsare organized into epochs, each consisting of a fixedMAPS_PER_EPOCHnumber of maps. In the most usual case (when row density is around average or below) row mapping stays the same  during an entire epoch. The database and the hash tree both should be organized in a way that instead of putting all rows of a single map close to each other, rows of the same _row index_throughout an entire epoch are close to each other and therefore are cheap to access and/or prove with a Merkle proof.", "Row mapping": "While base layer row mapping stays the same for an entire epoch, higher layer mappings are changed more frequently. Each mapping change has a cost in terms of database access overhead and Merkle proof size overhead and epoch size is determined in a way that these overheads stay sufficiently low compared to the cost of accessing the actual useful data. On higher layers where the rows are longer, a more frequent remapping is possible because the useful data size per map is also higher. It is also desirable so that a less frequentlog valuewill only suffer from colliding with longer rows for a shorter time.", "Column mapping": "Column mapping assumes thatMAP_WIDTHis a multiple ofVALUES_PER_MAP.column indexis calculated as follows:", "Initialization and minimal state": "A Merkle tree updated with strictly monotonically increasing keys can be initialized with a Merkle branch of the next leaf to be added. If the keys are non-strictly monotonical (the same leaf can be updated multiple times) then the previous leaf value itself is also needed. In case ofLogIndexMinimalStateepochs are strictly monotinically added. Thelog_entriestrees are also strictly monotinical while theMAPS_PER_EPOCHsized subtrees belonging to eachrow indexare non-strictly monotonically updated.", "Rationale": "In each block a varying number oflog valuesare emitted. In addition to inefficient search, another drawback of per-block fixed size bloom filters is the varying filter utilization leading to over-utilized filters giving many false positives in some blocks and/or wastefully under-utilized filters in some blocks. Block gas limits also tend to change significantly over the long term so any future-proof solution has to be able to adapt to the varying number oflog valuesper block.", "Log value index space": "In each block a varying number oflog valuesare emitted. In addition to inefficient search, another drawback of per-block fixed size bloom filters is the varying filter utilization leading to over-utilized filters giving many false positives in some blocks and/or wastefully under-utilized filters in some blocks. Block gas limits also tend to change significantly over the long term so any future-proof solution has to be able to adapt to the varying number oflog valuesper block.", "Log entries tree": "Hashing entire logs along with position info into a tree greatly simplifies the remote proving/verifying process. There is no need to separately prove the canonicalness of block headers and the receipts referenced in them, everything can be proven with Merkle proof of a singleLogIndexstructure and theBlockDelimiterMetabelonging to the same block number if the block hash is needed.", "Alternative filter structures considered": "In a search structure of a constantly growing dataset there is typically a tradeoff between the cost of adding new data and the cost of searcing the existing dataset. One extreme is just linearly storing the data, which is practically the case now with logs, with the bloom filters being mostly useless. The other extreme is one big Merkle tree with alllog valuesever used as keys and the list of all occurences (possibly in a further merkleized format) as values. With billions of uniquelog values, adding new entries here is expected to have costs similar to that of the state, with multiple lookups and modifications/insertions at random places in a database on the order of magnitude of hundreds of gigabytes. Another issue where this is similar to the state is that removing old entries is hard and expensive. Adding logs is supposed to be cheaper than writing the state so solutions between these two extremes were considered as potentially practical, with multiple smaller structures generated periodically.", "False positive rate": "From thefilter mapsa set of potential matches can be derived for any block range andlog valueor pattern oflog values. These matches can then be looked up in the correspondinglog_entriestrees and actually matching logs can be added to the set of results. The design guarantees that the set of potential matches includes all actual matches but and also has a consistent rate of random false positive rate.", "Backwards Compatibility": "The existing log filter API (eth_getLogs,eth_newFilter,eth_getFilterLogs,eth_getFilterChanges) can be implemented with the new filter data structure. Applications relying on this API can operate without any change, with a higher performance. Repricing theLOGopcode might be considered after performing benchmarks but the extra processing cost is not significant while the extra storage cost is around 15%. Other than that the EVM is not affected in any way as it only emits logs but does not directly access them.", "Security Considerations": "In order to prove a complete set of matches matching a given search pattern in a given block range, the prover needs to", "Safe access with a remote prover": "In order to prove a complete set of matches matching a given search pattern in a given block range, the prover needs to", "Deliberate false positive attacks": "The design guarantees that false positive rates do even out statistically over several epochs, even in case of random collisions with very frequent values, ensuring that an excessive amount false positives will not make the bandwidth and processing costs of the search prohibitively high. All of this is true for random collisions only though, not deliberately created collisions. A deliberate attack on a certain importantlog valuein order to raise its false positive rate can not be ruled out entirely since with a low amount of filter data generated perlog valueit is always possible to \u201cmine\u201d another value that generates colliding filter data. The column mapping used here makes this attack a lot harder though, since thecolumn indexdepends on both thelog valueand the exactlog value index, making this attack only possible for block creators who are probably offered MEV rewards for much more lucrative manipulations of the transaction set than making the search of certain log events slightly more expensive.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7748, "url": "https://eips.ethereum.org/EIPS/eip-7748", "title": "State conversion to Verkle Tree", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")", "Ignacio Hagopian\u00a0(", "@jsign", ")", "Gajinder Singh\u00a0(", "@g11tech", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")", "Gottfried Herold\u00a0(", "@GottfriedHerold", ")", "Jamie Lokier\u00a0(", "@jlokier", ")", "Tanishq Jasoria\u00a0(", "@tanishqjasoria", ")", "Parithosh Jayanthi\u00a0(", "@parithosh", ")", "Gabriel Rocheleau\u00a0(", "@gabrocheleau", ")", "Karim Taam\u00a0(", "@matkt", ")"], "sections": {"EIP-7748: State conversion to Verkle Tree": "This EIP proposes a procedure to convert, on each block, a fixed number of key-values from the existing  Merkle Patricia Tree (MPT) to the Verkle Tree (VKT).", "Describes a state conversion procedure to migrate key-values from the Merkle Patricia Tree to the Verkle Tree.": "This EIP proposes a procedure to convert, on each block, a fixed number of key-values from the existing  Merkle Patricia Tree (MPT) to the Verkle Tree (VKT).", "Abstract": "This EIP proposes a procedure to convert, on each block, a fixed number of key-values from the existing  Merkle Patricia Tree (MPT) to the Verkle Tree (VKT).", "Motivation": "The accounts state is too large to wait for transactions to organically move all of them to the VKT through the Overlay Tree. Thus, we need a strategy to convert all the state within a reasonable time. The state conversion completion allows removing the Overlay Tree abstraction introduced inEIP-7612and use directly the VKT for all state access.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Constants": "Aconversion unitis:", "Changes to the execution spec": "Include the following code in the existingapply_body(...)function:", "Rationale": "Performing the conversion step before the block txs execution has some benefits:", "State conversion step position in block execution": "Performing the conversion step before the block txs execution has some benefits:", "CONVERSION_STRIDEproposed value": "Performance benchmarks were done to achieve the right balance between:", "Account code chunking done in a single step": "If an account has code, this is chunked and inserted in the VKT in one go. An alternative is including aCodePhaseand let each inserted chunk consume one unit ofCONVERSION_STRIDE.", "Expected time for the conversion to finish": "TODO: We have an estimation, but it might be worth recalculating it closer to the proposed fork having a more up to date state size estimate.", "Missed slots": "The conversion logic runs at the start of each block, so missed slots don\u2019t create special situations.", "Accounts storage->account-data order": "The proposed order synergizes with many EL client flat-db architectures, minimizing random disk-IO.", "Not countingEIP-161accounts forCONVERSION_STRIDElimit": "TheCONVERSION_STRIDEparameter tries to limit the load of effective writes. These special accounts are skipped since we try to perform a bulkEIP-158deletion of the remaining accounts.", "MPT preimage resolving": "EL clients are expected to satisfy at least one of these conditions:", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "TODO: currently described in an external document.", "Reference Implementation": "Needs discussion.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7775, "url": "https://eips.ethereum.org/EIPS/eip-7775", "title": "BURN opcode", "authors": ["Dev Bear\u00a0(", "@itsdevbear", ")"], "sections": {"EIP-7775: BURN opcode": "This proposal introduces aBURNopcode to the EVM. When called, the opcode is to burn native ether at the address of the current evm context.", "An opcode to burn native ether at the given address": "This proposal introduces aBURNopcode to the EVM. When called, the opcode is to burn native ether at the address of the current evm context.", "Abstract": "This proposal introduces aBURNopcode to the EVM. When called, the opcode is to burn native ether at the address of the current evm context.", "Motivation": "The motivation for this proposal is to provide a standardized and efficient way to burn native ether directly within the EVM. Historically, contracts such as the BeaconDepositContract have \u201cburned\u201d ether by making it irrecoverable from the given address. This approach can lead to confusion and potential misuse. By introducing a dedicatedBURNopcode, we can ensure a clear and consistent method for burning native ether. This could become useful for Ethereum L2s when transferring ether back to the L1, as well as other EVM L1 chains that could leverage this for their cryptoeconomics.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Behaviour": "TheBURNopcode(0xFC)is introduced with the following behavior:", "Gas Cost": "The base gas cost for theBURNopcode is 100 gas. The dynamic gas cost is determined as follows:", "Pseudocode": "Example pseudocode for theBURNopcode:", "Rationale": "The introduction of theBURNopcode helps clean up a piece of weird semantics in the Ethereum. Historically, burning native ether involved sending them to an address from which they could not be recovered, such as the zero address or a contract with no withdrawal functionality. This method is not only inefficient but also confusing for indexers and other tools that track token movements. By providing a dedicatedBURNopcode, we eliminate this ambiguity and ensure that the act of burning tokens is explicit and standardized.", "Backwards Compatibility": "This EIP introduces a new opcode and thus must be activated via a scheduled hardfork.", "Test Cases": "Needs discussion.", "Reference Implementation": "Needs discussion.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7778, "url": "https://eips.ethereum.org/EIPS/eip-7778", "title": "Prevent Block Gas Smuggling", "authors": ["Ben Adams\u00a0(", "@benaadams", ")"], "sections": {"EIP-7778: Prevent Block Gas Smuggling": "Prevent the circumvention of the block gas limit by excluding certain gas discounts and refunds from block gas accounting, except for those reflecting actual reductions in computational work.", "Exclude Discounts & Refunds for Block GasLimit Enforcement": "Prevent the circumvention of the block gas limit by excluding certain gas discounts and refunds from block gas accounting, except for those reflecting actual reductions in computational work.", "Abstract": "This EIP modifies the gas accounting mechanism to prevent block gas smuggling \u2014 situations where transactions include more gas-consuming operations than the block gas limit intends due to gas discounts and refunds.", "Motivation": "WithEIP-7623for transactions, the gas used (tx.gasUsed) is calculated as:", "Preventing Block Gas Smuggling": "Copyright and related rights waived via CC0 1.0 Universal.", "Complementing EIP-7623": "Copyright and related rights waived via CC0 1.0 Universal.", "Specification": "WithEIP-7623for transactions, the gas used (tx.gasUsed) is calculated as:", "Gas Cost Adjustments": "WithEIP-7623for transactions, the gas used (tx.gasUsed) is calculated as:", "Transaction Gas Calculation (Adjusted)": "WithEIP-7623for transactions, the gas used (tx.gasUsed) is calculated as:", "Block Gas Limit Enforcement": "Copyright and related rights waived via CC0 1.0 Universal.", "Implementation": "Copyright and related rights waived via CC0 1.0 Universal.", "Rationale": "Copyright and related rights waived via CC0 1.0 Universal.", "Backwards Compatibility": "Copyright and related rights waived via CC0 1.0 Universal.", "Test Cases": "Copyright and related rights waived via CC0 1.0 Universal.", "Security Considerations": "Copyright and related rights waived via CC0 1.0 Universal.", "Copyright": "Copyright and related rights waived via CC0 1.0 Universal.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7782, "url": "https://eips.ethereum.org/EIPS/eip-7782", "title": "Reduce Slot Time for Lower Peak Bandwidth", "authors": ["Ben Adams\u00a0(", "@benaadams", ")"], "sections": {"EIP-7782: Reduce Slot Time for Lower Peak Bandwidth": "Propose reducing Ethereum\u2019s slot time from 12 seconds to 8 seconds to increase transaction throughput by one-third. This approach distributes bandwidth usage over time, lowering peak bandwidth requirements without increasing individual block or blob counts. It requiresEIP-7623andEIP-7778to ensure network stability and efficiency with the higher block rate.", "Reduce Ethereum's slot time from 12s to 8s to increase throughput by ~33%, distribute bandwidth usage, and improve rollup latency.": "Propose reducing Ethereum\u2019s slot time from 12 seconds to 8 seconds to increase transaction throughput by one-third. This approach distributes bandwidth usage over time, lowering peak bandwidth requirements without increasing individual block or blob counts. It requiresEIP-7623andEIP-7778to ensure network stability and efficiency with the higher block rate.", "Abstract": "This EIP suggests decreasing the slot time in Ethereum\u2019s Proof-of-Stake (PoS) consensus mechanism from 12 seconds to 8 seconds. The reduction increases the number of slots per unit time, boosting the network\u2019s transaction processing capacity by approximately 33%.", "Motivation": "Copyright and related rights waived via CC0 1.0 Universal.", "Distributing Bandwidth and Reducing Peak Usage": "Copyright and related rights waived via CC0 1.0 Universal.", "Complementing EIP-7623": "Copyright and related rights waived via CC0 1.0 Universal.", "Specification": "Copyright and related rights waived via CC0 1.0 Universal.", "Slot Time Reduction": "Copyright and related rights waived via CC0 1.0 Universal.", "Adjustments to Timing Parameters": "Copyright and related rights waived via CC0 1.0 Universal.", "Validator Operations": "Copyright and related rights waived via CC0 1.0 Universal.", "Rationale": "Copyright and related rights waived via CC0 1.0 Universal.", "Based Rollup Latency": "Copyright and related rights waived via CC0 1.0 Universal.", "Throughput Increase Without Raising Peak Bandwidth": "Copyright and related rights waived via CC0 1.0 Universal.", "Validator Capability": "Copyright and related rights waived via CC0 1.0 Universal.", "Alternative to Increasing Block Size or Blob Count": "Copyright and related rights waived via CC0 1.0 Universal.", "Backwards Compatibility": "Copyright and related rights waived via CC0 1.0 Universal.", "Test Cases": "Copyright and related rights waived via CC0 1.0 Universal.", "Network Propagation Considerations": "Copyright and related rights waived via CC0 1.0 Universal.", "Consensus Adjustments": "Copyright and related rights waived via CC0 1.0 Universal.", "Implementation": "Copyright and related rights waived via CC0 1.0 Universal.", "Security Considerations": "Copyright and related rights waived via CC0 1.0 Universal.", "Copyright": "Copyright and related rights waived via CC0 1.0 Universal.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7788, "url": "https://eips.ethereum.org/EIPS/eip-7788", "title": "Dynamic target blob count", "authors": ["Marc Harvey-Hill\u00a0(", "@Marchhill", ")"], "sections": {"EIP-7788: Dynamic target blob count": "This EIP proposes to make the target blob count adjust dynamically up to a safe maximum target. This adjustment will target a constant price in ETH for blobs, aiming for consistent costs of L2 transactions.", "Target blob count changes dynamically to aim for constant blob costs": "This EIP proposes to make the target blob count adjust dynamically up to a safe maximum target. This adjustment will target a constant price in ETH for blobs, aiming for consistent costs of L2 transactions.", "Abstract": "This EIP proposes to make the target blob count adjust dynamically up to a safe maximum target. This adjustment will target a constant price in ETH for blobs, aiming for consistent costs of L2 transactions.", "Motivation": "Ethereum currently uses a target of 50% capacity for blob count, withEIP-1559smoothing out short term spikes and pushing average throughput towards the target. A dynamic target is orthogonal to EIP-1559, tweaking the target itself over a longer timescale to aim for some desired blob cost.", "Specification": "The target blob count changes each epoch based on the mean blob cost over the previous epoch. If the average cost exceeds the desired amount beyond some margin then the target is increased; likewise if it is below the desired amount by some margin the target will decrease. The target can increase up toMAX_TARGET_BLOB_COUNT, which is deemed to be a safe average throughput for the network, and down to a minimum ofMIN_TARGET_BLOB_COUNT.", "Parameters": "The target blob count changes each epoch based on the mean blob cost over the previous epoch. If the average cost exceeds the desired amount beyond some margin then the target is increased; likewise if it is below the desired amount by some margin the target will decrease. The target can increase up toMAX_TARGET_BLOB_COUNT, which is deemed to be a safe average throughput for the network, and down to a minimum ofMIN_TARGET_BLOB_COUNT.", "Dynamic targeting": "The target blob count changes each epoch based on the mean blob cost over the previous epoch. If the average cost exceeds the desired amount beyond some margin then the target is increased; likewise if it is below the desired amount by some margin the target will decrease. The target can increase up toMAX_TARGET_BLOB_COUNT, which is deemed to be a safe average throughput for the network, and down to a minimum ofMIN_TARGET_BLOB_COUNT.", "Engine API change": "The Engine API is extended to provide themean_blob_costfor the current epoch when the CL requests it from the EL. The CL requests this at the end of an epoch to set the target for the next epoch (depends onEIP-7742).", "Rationale": "A constant blob cost target can keep L2 transaction costs affordable for end users. Volatility in the price of ETH would affect affordability, but is unlikely to be significant compared to normal fluctuations in blob gas costs due to spikes in activity. In future the costs could be adjusted in the case of changes in the order of magnitude of ETH price.", "Constant blob cost target": "A constant blob cost target can keep L2 transaction costs affordable for end users. Volatility in the price of ETH would affect affordability, but is unlikely to be significant compared to normal fluctuations in blob gas costs due to spikes in activity. In future the costs could be adjusted in the case of changes in the order of magnitude of ETH price.", "Target block gas": "The same logic could be applied to the target block gas, but generally blockspace is in high demand so arguably gas costs are never too low. The target should be set to the maximum average throughput that the network can safely handle, a dynamic target is not necessary.", "Parameter choices": "TARGET_BLOB_COSTis chosen so that the system targets affordable L2 transactions. Assuming that the theoretical compressed size of a simple transfer is 23 bytes, this gives a blobspace cost for L2 transactions of:", "Backwards Compatibility": "N/A", "Test Cases": "N/A", "Reference Implementation": "N/A", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7791, "url": "https://eips.ethereum.org/EIPS/eip-7791", "title": "GAS2ETH opcode", "authors": ["Charles Cooper\u00a0(", "@charles-cooper", ")", "Pascal Caversaccio\u00a0(", "@pcaversaccio", ")"], "sections": {"EIP-7791: GAS2ETH opcode": "This EIP introduces a newGAS2ETHopcode that enables the direct conversion of gas into ether (ETH).", "Introduces a new opcode, `GAS2ETH`, to convert gas to ETH": "This EIP introduces a newGAS2ETHopcode that enables the direct conversion of gas into ether (ETH).", "Abstract": "This EIP introduces a newGAS2ETHopcode that enables the direct conversion of gas into ether (ETH).", "Motivation": "This EIP is based on the premise that smart contract authors, compiler teams and public goods projects in general should be compensated for their contributions.\nMoreover, their compensation should scale with the usage of their contracts.\nA widely used and popular contract offers significant value to its users through its functionality and to the network by driving demand for blockspace \u2014 Ethereum\u2019sraison d\u2019\u00eatre.\nThis increased demand also benefits miners and validators, who are rewarded for executing these contracts.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Gas cost": "The proposed cost of this opcode is identical to the recently proposedPAYopcode.", "Rationale": "No backward compatibility issues found.", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "TBD", "Reference Implementation": "TBD", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7792, "url": "https://eips.ethereum.org/EIPS/eip-7792", "title": "Verifiable logs", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Gajinder Singh\u00a0(", "@g11tech", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-7792: Verifiable logs": "This EIP defines a method to make theeth_getLogsJSON-RPC response verifiable.", "Scheme to make the eth_getLogs response verifiable": "This EIP defines a method to make theeth_getLogsJSON-RPC response verifiable.", "Abstract": "This EIP defines a method to make theeth_getLogsJSON-RPC response verifiable.", "Motivation": "Theeth_getLogsendpoint is used by wallets to obtain the transaction history pertaining to an account or a topic. To verify correctness and completeness of the logs, a wallet would also have to obtain all block headers and check against their logs bloom. However, that mechanism is inefficient due to its high false positive rate and also involves an unpractical amount of network round trips. This EIP defines a replacement mechanism to efficiently and incrementally verify correctness and completeness ofeth_getLogsresponses.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Configuration": "After executing all transactions of a block, commitments of all emitted logs are accumulated into the storage ofLOG_CONTRACT_ADDRESS. The contract has no code, and its storage layout consists of three slots of typemapping. However to preventEIP-158cleanup, the contract\u2019s nonce is set to1at the first write.", "Log accumulation": "After executing all transactions of a block, commitments of all emitted logs are accumulated into the storage ofLOG_CONTRACT_ADDRESS. The contract has no code, and its storage layout consists of three slots of typemapping. However to preventEIP-158cleanup, the contract\u2019s nonce is set to1at the first write.", "JSON-RPC API": "Theeth_getLogsresponse format is extended to include:", "Verification": "Foreth_getLogs(address, topics, fromBlock, toBlock), the response data can be verified for correctness and completion by obtaining:", "Rationale": "Making theeth_getLogsresponse verifiable adds the necessary security attributes to enable wallets to transition away from relying on trusted data providers, ultimately improving the wallet\u2019s privacy guarantees as it is no longer subject to the privacy policy of any given provider.", "Gas cost": "The gas cost produced by this scheme is significantly higher than whatLOG#opcodes produce as of Prague, primarily due to the additionalSLOAD/SSTORErequirement and the double cost ofSHA256opcodes compared toKECCAK256opcodes. The gas cost increases outweigh the savings from dropping logs blooms.", "Block number / transaction index in meta instead of hashes": "As long as the accumulators are stored in the state trie, they cannot refer to the block hash as the block hash hashes over the state trie, producing a cyclic dependency. If an external system is used, hashes may be included as in that scenario the state root is not affected by the IVC.", "Backwards Compatibility": "It is still possible to processeth_getLogsresponses from trusted servers as is, without verifying them. Client applications with strict response validation may need to be updated to allow the additionalblockTimestampfield.", "Security Considerations": "This scheme reuses existingeth_getProofand SSZ Merkle proofs; it does not introduce new security risks.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7793, "url": "https://eips.ethereum.org/EIPS/eip-7793", "title": "TXINDEX precompile", "authors": ["Marc Harvey-Hill\u00a0(", "@Marchhill", ")", "Ahmad Bitar\u00a0(", "@smartprogrammer93", ")"], "sections": {"EIP-7793: TXINDEX precompile": "This EIP proposes to add a new precompile that returns the index of the transaction being executed within the current block.", "Precompile to get index of transaction within block": "This EIP proposes to add a new precompile that returns the index of the transaction being executed within the current block.", "Abstract": "This EIP proposes to add a new precompile that returns the index of the transaction being executed within the current block.", "Motivation": "The new precompile aims to improve support for encrypted mempools. In order to be secure, the validity of encrypted mempool transactions should be tied to the inclusion of all transactions by a proposer in the correct slot, and following the ordering rules. If these rules are not enshrined as block validity conditions then they can be enforced by a smart contract.", "Specification": "Ifblock.timestamp >= TBDa new precompiled contractTXINDEXshall be created at addressTBD.", "Gas Cost": "The gas cost forTXINDEXis a fixed fee of2", "Rationale": "The precompile is priced to match similar opcodes in theW_baseset.", "Gas Price": "The precompile is priced to match similar opcodes in theW_baseset.", "Precompile": "Making the feature a precompile rather than an opcode gives L2s flexibility to decide whether to implement it.", "ZK-VM proving": "The TXINDEX precompile should not increase the complexity of proving EVM execution, as it is similar to existing opcodes such as GAS. If a whole block is proven then no additional inputs to the circuit are required to prove transaction indices, as they can be inferred from the transaction ordering. If a transaction is proved individually then the index must be provided as an input to the circuit, along with the remaining gas for GAS, and more for other introspective opcodes.", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "N/A", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7797, "url": "https://eips.ethereum.org/EIPS/eip-7797", "title": "Double speed for hash_tree_root", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")"], "sections": {"EIP-7797: Double speed for hash_tree_root": "This EIP explains how to customizehash_tree_rootto double its performance.", "Double the performance of hash_tree_root by customizing SHA-256": "This EIP explains how to customizehash_tree_rootto double its performance.", "Abstract": "This EIP explains how to customizehash_tree_rootto double its performance.", "Motivation": "Hashing is a dominant performance bottleneck for Consensus Layer implementations. To support large validator counts, it is critical to optimize hashing performance.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "SHA-256 preprocessing": "Before SHA-256 hash computation begins, the input message is preprocessed. A single1bit is appended to the input message, followed by a varying number of0bits, and finally a big endianuint64indicating the input message bit length. The number of0bits is chosen so that the message size is the smallest possible multiple of 512 bits. In the context ofhash_tree_rootwhere the input message size is 512 bits, preprocessing results in the following padded message:", "SHA-256 blocks": "SHA-256 operates on message blocks of 512 bits. Therefore, in the context ofhash_tree_rootwhere the input message size is 512 bits, two message blocks are formed, the first containing the entire input message, and the second containing entirely static data resulting from the preprocessing step.", "SHA-256-512": "A new algorithm SHA-256-512 is defined as a modified SHA-256 algorithm that skips input message preprocessing and is restricted to inputs of exactly 512 bits. The input message SHALL be processed as is, as a single 512-bit SHA-256 message block.", "Consensus types": "Starting with the hard fork that introduces this EIP, the SHA-256-512 based composite SSZ types SHOULD be preferred over existing SHA-256 based types.", "Rationale": "Doubling the throughput of the underlying hash algorithm allows scaling to more validators on the same hardware, or allows using the freed CPU time for other tasks. Even when caching rarely-changed intermediate hashes across computations such as thevalidatorslist of aBeaconState, and employing hardware-accelerated SHA-256 implementations that are further optimized for the tree structure using libraries such asprysmaticlabs/hashtree, the state root validation step of the Consensus Layer state transition function can still consume ~25% of CPU time (Holesky test network, ~1.7m validators), mostly dominated by frequently changing per-validator structures such as theEpochParticipationFlagslists.", "Backwards Compatibility": "Smart contracts and client applications that verify Consensus Layer data require updates to remain compatible with data hashed using SHA-256-512. New logic may be required to correctly select the hash algorithm for historical structures such asBeaconBlockHeader.", "Security Considerations": "Certain SHA-256-512 hashes of 512 bit data may collide with regular SHA-256 hashes of shorter data. For example:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7799, "url": "https://eips.ethereum.org/EIPS/eip-7799", "title": "System logs", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Gajinder Singh\u00a0(", "@g11tech", ")"], "sections": {"EIP-7799: System logs": "This EIP defines an extension for eth_getLogs to provide logs for events that are not associated with a given transaction, such as block rewards and withdrawals.", "Per-block logs without associated transactions": "This EIP defines an extension for eth_getLogs to provide logs for events that are not associated with a given transaction, such as block rewards and withdrawals.", "Abstract": "This EIP defines an extension for eth_getLogs to provide logs for events that are not associated with a given transaction, such as block rewards and withdrawals.", "Motivation": "WithEIP-7708wallets gain the ability to use eth_getLogs to track changes to their ETH balance. However, the ETH balance may change without an explicit transaction, through block production and withdrawals. By having such operations emit block-level system logs, eth_Logs provides a complete picture of ETH balance changes.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "System logs list": "A new list is introduced to track all block level logs emitted from system interactions. The definition uses theLogSSZ type fromEIP-6466.", "Priority fee processing": "EIP-1559priority fees SHALL no longer be credited after each individual transaction. Instead, they SHALL be summed up and credited after all transactions of a block are processed but beforeEIP-4895withdrawals are processed.", "Withdrawal processing": "A log SHALL be appended to the system logs list on everyEIP-4895withdrawal.", "Genesis processing": "A log SHALL be appended to the system logs list when generating genesis blocks for networks that adopt this EIP from the beginning.", "Execution block header changes": "Theexecution block headeris extended with a new field,system-logs-root.", "JSON-RPC API": "Block header objects in the context of the JSON-RPC API are extended to include:", "Engine API": "In the engine API, theExecutionPayloadfor versions corresponding to forks adopting this EIP is extended to include:", "ConsensusExecutionPayloadchanges": "The consensusExecutionPayloadtype is extended with a new field to store the system logs root.", "Rationale": "Together withEIP-7708this EIP provides the ability for wallets to compute the exact ETH balance from logs without requiring download of every single block header and all withdrawals.", "Alternatives / Future": "The fee recipient now receives priority fees at the end of the block rather than incrementally after each transaction, making it only possible to spend them in the next block. This may require updates to block builder infrastructure and change liquidity requirements for MEV use cases.", "Backwards Compatibility": "The fee recipient now receives priority fees at the end of the block rather than incrementally after each transaction, making it only possible to spend them in the next block. This may require updates to block builder infrastructure and change liquidity requirements for MEV use cases.", "Security Considerations": "The emitted logs useSYSTEM_ADDRESSas theiraddresswhich cannot conflict with user controlled smart contracts.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7804, "url": "https://eips.ethereum.org/EIPS/eip-7804", "title": "Withdrawal Credential Update Request", "authors": ["Lucas Saldanha\u00a0(", "@lucassaldanha", ")", "Mikhail Kalinin\u00a0(", "@mkalinin", ")"], "sections": {"EIP-7804: Withdrawal Credential Update Request": "This proposal defines a mechanism to allow validators to update their withdrawal\ncredentials using a new execution request type (0x03). The request allows for\nchanging the execution address and the withdrawal credential prefix (0x01 or 0x02).", "Allow validators to update their withdrawal credentials via execution requests": "This proposal defines a mechanism to allow validators to update their withdrawal\ncredentials using a new execution request type (0x03). The request allows for\nchanging the execution address and the withdrawal credential prefix (0x01 or 0x02).", "Abstract": "This proposal defines a mechanism to allow validators to update their withdrawal\ncredentials using a new execution request type (0x03). The request allows for\nchanging the execution address and the withdrawal credential prefix (0x01 or 0x02).", "Motivation": "When the ability to update a validator BLS withdrawal credentials to execution\naddress was introduced in Capella, one of the most common questions was about\nallowing the withdrawal credential to be changed in the future.\nEither for security (e.g. credential rotation) or to allow for alternative ways\nof handling withdrawals (e.g. having a contract address as credentials).\nThe main reason for not adding this options was because implementing\nthis communication channel between the Execution Layer and the Consensus Layer is\ncomplex (based on the experience with the Eth1 bridge).", "Specification": "The new withdrawal credential update request operation is anEIP-7685request\nwith type0x03and consists of the following fields:", "Constants": "The new withdrawal credential update request operation is anEIP-7685request\nwith type0x03and consists of the following fields:", "Configuration": "The new withdrawal credential update request operation is anEIP-7685request\nwith type0x03and consists of the following fields:", "Execution Layer": "The new withdrawal credential update request operation is anEIP-7685request\nwith type0x03and consists of the following fields:", "Consensus Layer": "Summary of changes:", "Rationale": "Ownership is defined based on control of the withdrawal credential account, either as a private key (for EOA accounts) or controlling\nthe smart contract at the address set as withdrawal credential. Therefore allowing an update should not bring any security implications.", "Backwards Compatibility": "Ownership is defined based on control of the withdrawal credential account, either as a private key (for EOA accounts) or controlling\nthe smart contract at the address set as withdrawal credential. Therefore allowing an update should not bring any security implications.", "Test Cases": "Ownership is defined based on control of the withdrawal credential account, either as a private key (for EOA accounts) or controlling\nthe smart contract at the address set as withdrawal credential. Therefore allowing an update should not bring any security implications.", "Security Considerations": "Ownership is defined based on control of the withdrawal credential account, either as a private key (for EOA accounts) or controlling\nthe smart contract at the address set as withdrawal credential. Therefore allowing an update should not bring any security implications.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7805, "url": "https://eips.ethereum.org/EIPS/eip-7805", "title": "Fork-choice enforced Inclusion Lists (FOCIL)", "authors": ["Thomas Thiery (@soispoke)\u00a0<", "thomas.thiery@ethereum.org", ">", "Francesco D'Amato\u00a0<", "francesco.damato@ethereum.org", ">", "Julian Ma\u00a0<", "julian.ma@ethereum.org", ">", "Barnab\u00e9 Monnot\u00a0<", "barnabe.monnot@ethereum.org", ">", "Terence Tsao\u00a0<", "ttsao@offchainlabs.com", ">", "Jacob Kaufmann\u00a0<", "jacob.kaufmann@ethereum.org", ">", "Jihoon Song\u00a0<", "jihoonsong.dev@gmail.com", ">"], "sections": {"EIP-7805: Fork-choice enforced Inclusion Lists (FOCIL)": "FOCIL implements a robust mechanism to preserve Ethereum\u2019s censorship resistance properties by guaranteeing timely transaction inclusion.", "Allow a committee of validators to force-include a set of transactions in every block": "FOCIL implements a robust mechanism to preserve Ethereum\u2019s censorship resistance properties by guaranteeing timely transaction inclusion.", "Abstract": "FOCIL implements a robust mechanism to preserve Ethereum\u2019s censorship resistance properties by guaranteeing timely transaction inclusion.", "Motivation": "In an effort to shield the Ethereum validator set from centralizing forces, the right to build blocks has been auctioned off to specialized entities known asbuilders. This has led to a few sophisticated builders dominating block production, leading to a deterioration of the network\u2019s censorship resistance properties. To address this issue, research has focused on improving Ethereum\u2019s transaction inclusion guarantees by enabling validators to impose constraints on builders. This is achieved by force-including transactions in blocks via ILs.", "High-level Overview": "FOCIL is a committee-based, fork-choice enforced inclusion list (IL) design that improves upon previous IL mechanisms and block co-creation proposals. It addresses issues related to bribing/extortion attacks, IL equivocation, account abstraction (AA), and transaction invalidation.", "Roles And Participants": "This section outlines the workflow of FOCIL, detailing the roles and responsibilities of various participants: IL committee members, validators, builders, proposers and attesters.", "Specification": "On the execution layer, the block validity conditions are extended such that, after all of the transactions in the block have been executed, we attempt to execute each valid transaction from ILs that was not present in the block.\nIf one of those transactions executes successfully, then the block is invalid.", "Execution Layer": "On the execution layer, the block validity conditions are extended such that, after all of the transactions in the block have been executed, we attempt to execute each valid transaction from ILs that was not present in the block.\nIf one of those transactions executes successfully, then the block is invalid.", "Consensus Layer": "The full consensus changes can be found in the following GitHub repository. They are split between:", "Rationale": "This EIP introduces backward incompatible changes to the block validation rule set on the consensus layer and must be accompanied by a hard fork. These changes do not break anything related to current user activity and experience.", "Core Properties": "This EIP introduces backward incompatible changes to the block validation rule set on the consensus layer and must be accompanied by a hard fork. These changes do not break anything related to current user activity and experience.", "Backwards Compatibility": "This EIP introduces backward incompatible changes to the block validation rule set on the consensus layer and must be accompanied by a hard fork. These changes do not break anything related to current user activity and experience.", "Security Considerations": "The builder ofslot N+1cannot construct a canonical block without first receiving the ILs broadcast duringslot N. This means that the builder (including cases in which the proposer locally builds its block) must be well-connected to the IL committee members to ensure timely access to these inclusion lists. Additionally, there must be sufficient time between the view freeze deadline (t=9sofslot N) and the moment the proposer must broadcastblock Bto the rest of the network. This buffer allows the builder to gather all available ILs and update the execution payload ofblock Baccordingly.", "Consensus Liveness": "The builder ofslot N+1cannot construct a canonical block without first receiving the ILs broadcast duringslot N. This means that the builder (including cases in which the proposer locally builds its block) must be well-connected to the IL committee members to ensure timely access to these inclusion lists. Additionally, there must be sufficient time between the view freeze deadline (t=9sofslot N) and the moment the proposer must broadcastblock Bto the rest of the network. This buffer allows the builder to gather all available ILs and update the execution payload ofblock Baccordingly.", "IL Equivocation": "To mitigate IL equivocation, FOCIL introduces a new P2P network rule that allows forwarding up to two ILs per IL committee member. If the proposer or attesters detect two different ILs sent by the same IL committee member, they should ignore all ILs from that member. In the worst case, the bandwidth of the IL gossip subnet can at most double.", "Payload Construction": "The builder, responsible for constructing the execution payload, must ensure that the IL is satisfied. A naive way to do so would be to build an initial payload in whatever way the builder desires, then execute the following algorithm:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7807, "url": "https://eips.ethereum.org/EIPS/eip-7807", "title": "SSZ execution blocks", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Gajinder Singh\u00a0(", "@g11tech", ")"], "sections": {"EIP-7807: SSZ execution blocks": "This EIP defines a migration process of execution blocks toSimple Serialize (SSZ).", "Migration of execution blocks to SSZ": "This EIP defines a migration process of execution blocks toSimple Serialize (SSZ).", "Abstract": "This EIP defines a migration process of execution blocks toSimple Serialize (SSZ).", "Motivation": "WithEIP-6404SSZ transactions,EIP-6466SSZ receipts, andEIP-6465SSZ withdrawals, all Merkle-Patricia Trie (MPT) besides the state trie are converted to SSZ. This enables the surrounding data structure, in this case, the execution block itself, to also convert to SSZ, achieving a unified block representation across both Consensus Layer and Execution Layer.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "ExecutionBlockHeadercontainer": "Execution blocks are represented as a single, normalized SSZ container. The definition uses theStableContainer[N]SSZ type andOptional[T]as defined inEIP-7495.", "Requests hash computation": "requests_hashis changed toExecutionRequests.hash_tree_root()using the same structure as in the Consensus LayerBeaconBlockBody.", "Execution block hash computation": "The execution block hash is changed to be based onhash_tree_rootin all contexts, including (1) the BLOCKHASH opcode, (2) engine API interactions (blockHashfield), (3) JSON-RPC API interactions, (4) devp2p networking.", "Rationale": "In the initial draft, only the requests hash and block hash are changed to be SSZhash_tree_root()based. No Consensus Layer changes are required.", "Future": "This breaks compatibility of smart contracts that depend on the previous block header binary format, including for \u201cgeneric\u201d implementations that assume a common prefix and run the entire data through a linear keccak256 hash.", "Backwards Compatibility": "This breaks compatibility of smart contracts that depend on the previous block header binary format, including for \u201cgeneric\u201d implementations that assume a common prefix and run the entire data through a linear keccak256 hash.", "Security Considerations": "The SSZ block hash is based on SHA256 and shares the namespace with existing keccak256 based block hashes. As these hash algorithms are fundamentally different, no significant collision risk is expected.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7819, "url": "https://eips.ethereum.org/EIPS/eip-7819", "title": "Create delegate", "authors": ["Hadrien Croubois\u00a0(", "@amxx", ")", "Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-7819: Create delegate": "Introduce a new EVM instruction toEOFthat allows smart contracts to create (and update) delegation accounts that matchEIP-7702\u2019s design. These accounts can be used similarly toERC-1167clones, with significant advantages.", "Add a new EVM instruction allowing contracts to create clones using EIP-7702 delegation designations": "Introduce a new EVM instruction toEOFthat allows smart contracts to create (and update) delegation accounts that matchEIP-7702\u2019s design. These accounts can be used similarly toERC-1167clones, with significant advantages.", "Abstract": "Introduce a new EVM instruction toEOFthat allows smart contracts to create (and update) delegation accounts that matchEIP-7702\u2019s design. These accounts can be used similarly toERC-1167clones, with significant advantages.", "Motivation": "Many on-chain applications involve creating multiple instances of the same code at different locations. These applications often rely on clones, or proxies, to reduce deployment costs.", "Specification": "A new instruction (CREATE_DELEGATE) is added to EOF at0xf6.", "Behavior": "Executing this instruction does the following:", "Parameters": "The execution of theCREATE_DELEGATEinstruction involves fewer moving pieces than what EIP-7702 gas costs account for:", "Rationale": "The execution of theCREATE_DELEGATEinstruction involves fewer moving pieces than what EIP-7702 gas costs account for:", "Gas cost": "The execution of theCREATE_DELEGATEinstruction involves fewer moving pieces than what EIP-7702 gas costs account for:", "Backwards Compatibility": "TODO", "Security Considerations": "Reusing EIP-7702 behavior, including clearing the code if the target is 0, results in the ability to upgrade or even \u201cremove\u201d the created designator. This process is controlled (and can be restricted) by the factory (the contract that callsCREATE_DELEGATE). Some factories will add checks that prevent re-executingCREATE_DELEGATEwith a salt that was already used, making the create designator immutable. Others may allow access-restricted upgrades, but prevent deletion. In any case, guarantees about the lifecycle of the designator created usingCREATE_DELEGATEare provided by the contracts that call it and not by the protocol.", "Delegator upgrades & deletion": "Reusing EIP-7702 behavior, including clearing the code if the target is 0, results in the ability to upgrade or even \u201cremove\u201d the created designator. This process is controlled (and can be restricted) by the factory (the contract that callsCREATE_DELEGATE). Some factories will add checks that prevent re-executingCREATE_DELEGATEwith a salt that was already used, making the create designator immutable. Others may allow access-restricted upgrades, but prevent deletion. In any case, guarantees about the lifecycle of the designator created usingCREATE_DELEGATEare provided by the contracts that call it and not by the protocol.", "Delegator chaining": "As documented in EIP-7702, designator chains or loops are not resolved. This means that, unlike clones, chaining is an issue. This is however something developers are used to, as chaining proxy can result in strange behaviors, including infinite delegation loops.", "Front running initialization": "Unlike EIP-7702 signature, which can be included in any transaction, and can thus lead to initialization front-running if the implementation doesn\u2019t check the authenticity of the initialization parameters,CREATE_DELEGATIONis executed by a smart contract that can execute the initialization logic atomically, just after the delegation is created. This process is well-known to developers that initialize clones and proxies just after creation.", "Multiple delegation changes within a single transaction.": "If a contract performs multipleCREATE_DELEGATEoperations with the same salt but different targets within the same transaction, while doing calls corresponding address, this would have, in the same transaction without reverts, an address that has multiple different codes associated with it, two or more of which are executed. This include the delegation being removed/reset any number of time during the transaction.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7825, "url": "https://eips.ethereum.org/EIPS/eip-7825", "title": "Transaction Gas Limit Cap", "authors": ["Giulio Rebuffo\u00a0(", "@Giulio2002", ")"], "sections": {"EIP-7825: Transaction Gas Limit Cap": "This proposal introduces a protocol-level cap on the maximum gas usage per transaction to 30 million gas. By implementing this limit, Ethereum can enhance its resilience against certain DoS vectors, improve network stability, and provide more predictability to transaction processing costs, especially in the context of increasing the Gas Limit.", "Introduce a protocol-level cap on the maximum gas used by a transaction to 30 million.": "This proposal introduces a protocol-level cap on the maximum gas usage per transaction to 30 million gas. By implementing this limit, Ethereum can enhance its resilience against certain DoS vectors, improve network stability, and provide more predictability to transaction processing costs, especially in the context of increasing the Gas Limit.", "Abstract": "This proposal introduces a protocol-level cap on the maximum gas usage per transaction to 30 million gas. By implementing this limit, Ethereum can enhance its resilience against certain DoS vectors, improve network stability, and provide more predictability to transaction processing costs, especially in the context of increasing the Gas Limit.", "Motivation": "Currently, transactions can theoretically consume up to the entire block gas limit, which poses several risks:", "Specification": "The proposed cap of 30 million gas is based on the typical size of Ethereum blocks today, which often range between 30-40 million gas. This value is large enough to allow complex transactions, such as contract deployments and advanced DeFi interactions, while still reserving space for other transactions within a block.", "Gas Cap": "The proposed cap of 30 million gas is based on the typical size of Ethereum blocks today, which often range between 30-40 million gas. This value is large enough to allow complex transactions, such as contract deployments and advanced DeFi interactions, while still reserving space for other transactions within a block.", "Changes to EVM Behavior": "The proposed cap of 30 million gas is based on the typical size of Ethereum blocks today, which often range between 30-40 million gas. This value is large enough to allow complex transactions, such as contract deployments and advanced DeFi interactions, while still reserving space for other transactions within a block.", "Protocol Adjustment": "The proposed cap of 30 million gas is based on the typical size of Ethereum blocks today, which often range between 30-40 million gas. This value is large enough to allow complex transactions, such as contract deployments and advanced DeFi interactions, while still reserving space for other transactions within a block.", "Rationale": "The proposed cap of 30 million gas is based on the typical size of Ethereum blocks today, which often range between 30-40 million gas. This value is large enough to allow complex transactions, such as contract deployments and advanced DeFi interactions, while still reserving space for other transactions within a block.", "Why 30 Million?": "The proposed cap of 30 million gas is based on the typical size of Ethereum blocks today, which often range between 30-40 million gas. This value is large enough to allow complex transactions, such as contract deployments and advanced DeFi interactions, while still reserving space for other transactions within a block.", "Compatibility with Current Gas Dynamics": "This change isnot backward-compatiblewith transactions that specify gas limits exceeding 30 million. Transactions with such high limits will need to be split into smaller operations. This adjustment is expected to impact a minimal number of users and dApps, as most transactions today fall well below the proposed cap.", "Backwards Compatibility": "This change isnot backward-compatiblewith transactions that specify gas limits exceeding 30 million. Transactions with such high limits will need to be split into smaller operations. This adjustment is expected to impact a minimal number of users and dApps, as most transactions today fall well below the proposed cap.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7833, "url": "https://eips.ethereum.org/EIPS/eip-7833", "title": "Scheduled function calls", "authors": ["Keyvan Kambakhsh\u00a0(", "@keyvank", ")", "Nobitex Labs\u00a0<", "labs@nobitex.ir", ">"], "sections": {"EIP-7833: Scheduled function calls": "Ethereum\u2019s smart contracts enable users to delegate control of their funds to code, but these contracts require an external trigger to execute. Timing is often critical, and issues such as network delays or malicious behavior by block producers\u2014like MEV attacks\u2014can prevent timely execution. To address these challenges, this Ethereum Improvement Proposal (EIP) introduces a new opcode, OFFERCALL, which allows contracts to schedule function calls. When functions self-schedule, they exhibit bot-like behavior. These scheduled calls would offer ETH to block producers as an incentive to prioritize their execution over manually submitted transactions. If the offer is not fulfilled, the bot is deactivated until manually re-ignited by the owner. The EIP proposes enforcing the execution of scheduled calls as a requirement for block validity. This could help mitigate MEV attacks, as block producers would be compelled to execute bots that neutralize market manipulation within the blockchain.", "Giving life to smart contracts by enabling their functions to be automatically invoked by block producers.": "Ethereum\u2019s smart contracts enable users to delegate control of their funds to code, but these contracts require an external trigger to execute. Timing is often critical, and issues such as network delays or malicious behavior by block producers\u2014like MEV attacks\u2014can prevent timely execution. To address these challenges, this Ethereum Improvement Proposal (EIP) introduces a new opcode, OFFERCALL, which allows contracts to schedule function calls. When functions self-schedule, they exhibit bot-like behavior. These scheduled calls would offer ETH to block producers as an incentive to prioritize their execution over manually submitted transactions. If the offer is not fulfilled, the bot is deactivated until manually re-ignited by the owner. The EIP proposes enforcing the execution of scheduled calls as a requirement for block validity. This could help mitigate MEV attacks, as block producers would be compelled to execute bots that neutralize market manipulation within the blockchain.", "Abstract": "Ethereum\u2019s smart contracts enable users to delegate control of their funds to code, but these contracts require an external trigger to execute. Timing is often critical, and issues such as network delays or malicious behavior by block producers\u2014like MEV attacks\u2014can prevent timely execution. To address these challenges, this Ethereum Improvement Proposal (EIP) introduces a new opcode, OFFERCALL, which allows contracts to schedule function calls. When functions self-schedule, they exhibit bot-like behavior. These scheduled calls would offer ETH to block producers as an incentive to prioritize their execution over manually submitted transactions. If the offer is not fulfilled, the bot is deactivated until manually re-ignited by the owner. The EIP proposes enforcing the execution of scheduled calls as a requirement for block validity. This could help mitigate MEV attacks, as block producers would be compelled to execute bots that neutralize market manipulation within the blockchain.", "Specification": "Adding bot-like behavior to an EVM function is achieved by recursively scheduling a call to the same function in the next block. We propose introducing a new EVM opcode, OFFERCALL, which, as the name implies, offers ETH to be burnt to the block producer of the next block in exchange for invoking a function. These offers are aggregated and ranked by the Ethereum node, with only the top N offers being retained; all others are discarded. Scheduled calls must be executed before any user transactions, with execution order determined by their rank in the sorted list. The offered ETH is burnt to prevent block producers from exploiting the system by scheduling calls that pay the offered amounts back to themselves.", "Rationale": "The rationale behind this Ethereum Improvement Proposal (EIP) stems from the need to enhance the reliability and fairness of smart contract execution on the Ethereum network. While Ethereum\u2019s smart contracts allow for a high degree of programmability and automation, the execution of these contracts often depends on external triggers, such as user transactions or network conditions. This dependency introduces significant challenges, particularly in situations where timing is critical or when malicious actors, like block producers, can exploit the system for profit.", "Backwards Compatibility": "The introduction of the new OFFERCALL opcode in this EIP requires a network upgrade, as it adds new functionality that is not currently supported by the Ethereum Virtual Machine (EVM). This change will affect how smart contracts can schedule and incentivize the execution of specific function calls, introducing a new mechanism that block producers must accommodate.", "Reference Implementation": "N/A", "Security Considerations": "The main concern with this EIP is whether it could lead to centralization, as wealthier users might dominate execution priorities. Burning unfulfilled offers partly addresses this by preventing endless offers.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7843, "url": "https://eips.ethereum.org/EIPS/eip-7843", "title": "SLOT precompile", "authors": ["Marc Harvey-Hill\u00a0(", "@Marchhill", ")"], "sections": {"EIP-7843: SLOT precompile": "This EIP proposes to add a new precompile that returns the corresponding slot number for the current block.", "Precompile to get the current slot number": "This EIP proposes to add a new precompile that returns the corresponding slot number for the current block.", "Abstract": "This EIP proposes to add a new precompile that returns the corresponding slot number for the current block.", "Motivation": "It is currently possible to calculate the slot number from the block timestamp. However, this requires hardcoding the chain slot length into a smart contract. This would require the contract code to be changed in the event of a future change to slot length. A better approach is for the slot length to be abstracted away from applications, and instead the slot number can be calculated in the consensus layer client and exposed in a precompile.", "Example application: Encrypted Mempools": "An example of a smart contract that needs the slot number is a validation contract for an encrypted mempool. In order to be secure, the validity of encrypted mempool transactions should be tied to the inclusion of all transactions by a proposer in the correct slot. This rule can be enforced by a smart contract using this precompile.", "Specification": "Ifblock.timestamp >= TBDa new precompiled contractSLOTshall be created at addressTBD.", "Gas Cost": "The gas cost forSLOTis a fixed fee of2.", "RPC changes": "The slot number is calculated in the consensus layer and passed to the execution layer through the engine API.", "Rationale": "The precompile is priced to match similar opcodes in theW_baseset.", "Gas Price": "The precompile is priced to match similar opcodes in theW_baseset.", "Precompile": "Making the feature a precompile rather than an opcode gives L2s flexibility to decide whether to implement it.", "Calculation in consensus layer": "The slot number could alternatively be calculated in the execution layer using the timestamp, but it is more appropriate to calculate values pertaining to the beacon chain in the consensus layer. Additionally this avoids code duplication, as the slot number is already calculated in the consensus layer.", "ZK-VM proving": "The SLOT precompile should not increase the complexity of proving EVM execution, as it is similar to existing opcodes such as TIMESTAMP. The slot number is included in the block header rather than as anew_payloadparameter, ensuring that the block is self-contained for proving; no extra inputs to the circuit are required.", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "N/A", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7848, "url": "https://eips.ethereum.org/EIPS/eip-7848", "title": "On-chain upgrade signaling", "authors": ["William Entriken\u00a0(", "@fulldecent", ")"], "sections": {"EIP-7848: On-chain upgrade signaling": "This proposal adds a mechanism for clients to signal their willingness for a network upgrade by including a \u201creference implementation hash\u201d field in each block. A network upgrade activates only if enough blocks specify that they are using the new software.", "Allows participants to indicate readiness for a client upgrade when producing blocks": "This proposal adds a mechanism for clients to signal their willingness for a network upgrade by including a \u201creference implementation hash\u201d field in each block. A network upgrade activates only if enough blocks specify that they are using the new software.", "Abstract": "This proposal adds a mechanism for clients to signal their willingness for a network upgrade by including a \u201creference implementation hash\u201d field in each block. A network upgrade activates only if enough blocks specify that they are using the new software.", "Motivation": "Currently, upgrades to Ethereum Mainnet are announced on the ethereum.org blog. This proposal changes that process by activating upgrades based on the consent of network participants.", "Specification": "Ethereum consensus clients shall identify with a reference implementation having its equivalent behaviors.", "The Reference Implementation Hash": "When proposing a network upgrade, the proposer shall point to a published, feature-complete reference implementation including the new software behaviors.", "Verification": "Network participants shall study the reference implementation and decide whether they support an upgrade.", "Upgrade": "Upgrade proposals (often referred to as hard fork EIPs) must specify an upgrade window and threshold. These parameters are implemented in the consensus client:", "Rationale": "Since the merge, forking Ethereum Mainnet has become practically impossible. Validators stake valuable assets to participate in the network, so any rational validator will choose to upgrade only if they expect widespread adoption. If a validator expects 95% or more participants to upgrade, they should upgrade; if they expect only 5% or less, they should not. For intermediate cases, there is a threshold where a validator would rationally shut down (incurring a small penalty) rather than risk participating in the wrong network\u2014which could result in slashing 100% of their staked ether (currently 16 Ether per share).", "Forking is no Longer Possible": "Since the merge, forking Ethereum Mainnet has become practically impossible. Validators stake valuable assets to participate in the network, so any rational validator will choose to upgrade only if they expect widespread adoption. If a validator expects 95% or more participants to upgrade, they should upgrade; if they expect only 5% or less, they should not. For intermediate cases, there is a threshold where a validator would rationally shut down (incurring a small penalty) rather than risk participating in the wrong network\u2014which could result in slashing 100% of their staked ether (currently 16 Ether per share).", "Community Direction": "Using a voting window to count votes provides real-time on-chain feedback about upgrade readiness. The upgrade is activated only after the successful completion of the voting window.", "Window": "Using a voting window to count votes provides real-time on-chain feedback about upgrade readiness. The upgrade is activated only after the successful completion of the voting window.", "Backwards Compatibility": "The Ethereum Foundation (Stiftung Ethereum), Zug, Switzerland, owns the trademark \u201cEthereum.\u201d As a result, if anybody publishes a proposed Ethereum Mainnet consensus client, the foundation may have the right to restrict marketing of that software as an \u201cEthereum\u201d client. That also posess unique risks related to securities rules.", "Trademark": "The Ethereum Foundation (Stiftung Ethereum), Zug, Switzerland, owns the trademark \u201cEthereum.\u201d As a result, if anybody publishes a proposed Ethereum Mainnet consensus client, the foundation may have the right to restrict marketing of that software as an \u201cEthereum\u201d client. That also posess unique risks related to securities rules.", "EIP-2124": "EIP-2124 introduces a mechanism to communicate software versions between nodes. However, it does not allow for signaling readiness before an upgrade, nor does it specify what software is being upgraded to.", "Security Considerations": "Any upgrade that achieves less than 100% participation will harm validators who do not participate.", "Copyright": "Copyright and related rights have been waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7851, "url": "https://eips.ethereum.org/EIPS/eip-7851", "title": "Deactivate/Reactivate a Delegated EOA's Key", "authors": ["Liyi Guo\u00a0(", "@colinlyguo", ")"], "sections": {"EIP-7851: Deactivate/Reactivate a Delegated EOA's Key": "This EIP introduces a precompiled contract that enables Externally Owned Accounts (EOAs) with delegated control to smart contracts viaEIP-7702to deactivate or reactivate their private keys. This design does not require additional storage fields or account state changes. By leveraging delegated code, reactivation can be performed securely through mechanisms such as social recovery.", "Introduce a new precompiled contract for EOAs with delegated code to deactivate or reactivate private keys.": "This EIP introduces a precompiled contract that enables Externally Owned Accounts (EOAs) with delegated control to smart contracts viaEIP-7702to deactivate or reactivate their private keys. This design does not require additional storage fields or account state changes. By leveraging delegated code, reactivation can be performed securely through mechanisms such as social recovery.", "Abstract": "This EIP introduces a precompiled contract that enables Externally Owned Accounts (EOAs) with delegated control to smart contracts viaEIP-7702to deactivate or reactivate their private keys. This design does not require additional storage fields or account state changes. By leveraging delegated code, reactivation can be performed securely through mechanisms such as social recovery.", "Motivation": "EIP-7702enables EOAs to gain smart contract capabilities, but the private key of the EOA still retains full control over the account.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Parameters": "The deactivation status is encoded by appending or removing the0x00byte at the end of the delegated code. The transitions between two states are as follows:", "Definitions": "The deactivation status is encoded by appending or removing the0x00byte at the end of the delegated code. The transitions between two states are as follows:", "Delegated Code Encoding": "The deactivation status is encoded by appending or removing the0x00byte at the end of the delegated code. The transitions between two states are as follows:", "Precompiled Contract": "A new precompiled contract is introduced at addressPRECOMPILE_ADDRESS. It costsPRECOMPILE_GAS_COSTand executes the following logic:", "Transaction Validation": "Validation to check whether a private key is deactivated (identified by a code prefix0xef0100and a code length of24) MUST be performed in the following scenarios:", "Rationale": "ThePRECOMPILE_GAS_COSTrepresents the gas required to validate and potentially update an account\u2019s code. A fair cost for calling this precompiled contract can be determined by analyzing its impact on the node:", "Cost of Precompiled Contract": "ThePRECOMPILE_GAS_COSTrepresents the gas required to validate and potentially update an account\u2019s code. A fair cost for calling this precompiled contract can be determined by analyzing its impact on the node:", "Additional Transaction Validation Overhead": "Due toEIP-3607andEIP-7702, nodes already load the account code during transaction validation to verify whether the sender is an EOA (empty code or code with prefix0xef0100). This EIP introduces only a code length check after loading the code, resulting in minimal additional overhead. Similarly,EIP-7702\u2019s authorization validation already involves retrieving the account code, with this EIP adding only a code length check, which is negligible compared to code reading.", "An Alternative EOA Deprecation Approach": "An alternative deprecation approach involves using a hard fork to edit all existing and new EOAs to pre-written upgradeable smart contracts, which utilize the original EOA private key for authorization. Users can add and replace keys, or upgrade the smart contracts to other implementations. However, this approach is incompatible with EOAs already delegated to smart contracts, as it will overwrite the existing smart contract implementations. This EIP aims to fill this migration gap.", "Using a Precompiled Contract": "Alternative methods for deactivating and reactivating EOA private keys include:", "In-Protocol Reactivation": "This approach ensures maximum compatibility with future migrations. EOAs can reactivate their private keys, delegate their accounts to anEIP-7701contract, and then deactivate their private keys again. This avoids the limitations of contract upgrades. e.g., to remove legacy proxy contracts (reducing gas overhead) when upgrading to EOF contracts, one can reactivate the EOA and redelegate it to an EOF proxy contract.", "Avoiding Delegated Code Prefix Modification": "This EIP appends a byte (0x00) to the delegated code instead of modifying the prefix (0xef0100) ofEIP-7702to ensure forward compatibility. If new prefixes such as0xef0101are introduced in the future, changing the prefix to represent the deactivated status (e.g.,0xef01ff) makes it unclear which prefix to restore (0xef0100or0xef0101) upon reactivation.", "Avoiding Account State Changes": "An alternative is to add adeactivatedfield in the account state to track the status. However, this approach will introduce backward compatibility logic and more test vectors related to this optional field when enabling this EIP, because the field is not present in existing accounts.", "Backwards Compatibility": "When the private key is deactivated, this EIP introduces: (i) an extra byte (0x00) to be appended to the end of the delegated code, and (ii) the delegated code length becomes24bytes (e.g.,EXTCODESIZEwould return24).", "Test Cases": "Contracts that have already been deployed and use ECDSAsecp256k1signatures outside of transaction signatures (e.g.,ERC-20tokens that supportERC-2612, thepermitfunction) will not be able to verify the deactivated status of the EOA. This means that signatures signed by private keys will remain valid in these functions.", "Reference Implementation": "Contracts that have already been deployed and use ECDSAsecp256k1signatures outside of transaction signatures (e.g.,ERC-20tokens that supportERC-2612, thepermitfunction) will not be able to verify the deactivated status of the EOA. This means that signatures signed by private keys will remain valid in these functions.", "Security Considerations": "Contracts that have already been deployed and use ECDSAsecp256k1signatures outside of transaction signatures (e.g.,ERC-20tokens that supportERC-2612, thepermitfunction) will not be able to verify the deactivated status of the EOA. This means that signatures signed by private keys will remain valid in these functions.", "Contracts Using ECDSASecp256k1Signatures": "Contracts that have already been deployed and use ECDSAsecp256k1signatures outside of transaction signatures (e.g.,ERC-20tokens that supportERC-2612, thepermitfunction) will not be able to verify the deactivated status of the EOA. This means that signatures signed by private keys will remain valid in these functions.", "Irreversible Deactivation": "Delegating to a wallet that lacks reactivation support (e.g., by calling the precompiled contract through an appropriate interface) may result in irreversible deactivation. To mitigate this risk, users should delegate their EOAs only to thoroughly audited implementations that explicitly support this EIP.", "Deactivation and Reactivation Replay": "Replay attacks can occur in two scenarios: (i) repeating the same authorization on a single chain, or (ii) using the authorization across different chains.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7862, "url": "https://eips.ethereum.org/EIPS/eip-7862", "title": "Delayed Execution Layer State Root", "authors": ["Charlie Noyes\u00a0<", "charlie@paradigm.xyz", ">", "Dan Robinson\u00a0<", "dan@paradigm.xyz", ">", "Justin Drake\u00a0<", "justin@ethereum.org", ">", "Toni Wahrst\u00e4tter\u00a0(", "@nerolation", ")"], "sections": {"EIP-7862: Delayed Execution Layer State Root": "This EIP proposes that, for each blockn, thestate_rootin blockn\u2019sExecutionPayloadreferences thepost-state of blockn-1. As a result, blocknno longer needs to compute & include or verify the post state root for blockn. This removes the expensive state root computation from the block-propagation critical path, reducing end-to-end latency for block production and potentially increasing throughput.", "Delays the ExecutionPayload's state root reference by one block.": "This EIP proposes that, for each blockn, thestate_rootin blockn\u2019sExecutionPayloadreferences thepost-state of blockn-1. As a result, blocknno longer needs to compute & include or verify the post state root for blockn. This removes the expensive state root computation from the block-propagation critical path, reducing end-to-end latency for block production and potentially increasing throughput.", "Abstract": "This EIP proposes that, for each blockn, thestate_rootin blockn\u2019sExecutionPayloadreferences thepost-state of blockn-1. As a result, blocknno longer needs to compute & include or verify the post state root for blockn. This removes the expensive state root computation from the block-propagation critical path, reducing end-to-end latency for block production and potentially increasing throughput.", "Motivation": "Currently, every Ethereum block includes twostate_root.", "Specification": "No changes are required in the CL validation process or block structure:", "Execution Layer Changes": "No changes are required in the CL validation process or block structure:", "Consensus Layer": "No changes are required in the CL validation process or block structure:", "Transition / Fork Activation": "Upon the hard fork that activates this proposal (call this activation blockF):", "Rationale": "This EIP is a consensus-breaking change and requires a coordinated hard fork on mainnet or any network that adopts it. Once activated, older clients that expect blocks to contain their own (execution layer) post-state root will be incompatible and fail to sync.", "Backwards Compatibility": "This EIP is a consensus-breaking change and requires a coordinated hard fork on mainnet or any network that adopts it. Once activated, older clients that expect blocks to contain their own (execution layer) post-state root will be incompatible and fail to sync.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7863, "url": "https://eips.ethereum.org/EIPS/eip-7863", "title": "Block-level Warming", "authors": ["Toni Wahrst\u00e4tter\u00a0(", "@nerolation", ")", "Jochem Brouwer\u00a0(", "@jochem-brouwer", ")", "Alex Stokes\u00a0(", "@ralexstokes", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")"], "sections": {"EIP-7863: Block-level Warming": "This proposal introduces block-level address and storage key warming, allowing accessed addresses and storage keys to maintain their \u201cwarm\u201d status throughout an entire block\u2019s execution. Accessed slots can be effectively cached at the block level, allowing for this opimization.", "Warm addresses and storage keys over the duration of a block": "This proposal introduces block-level address and storage key warming, allowing accessed addresses and storage keys to maintain their \u201cwarm\u201d status throughout an entire block\u2019s execution. Accessed slots can be effectively cached at the block level, allowing for this opimization.", "Abstract": "This proposal introduces block-level address and storage key warming, allowing accessed addresses and storage keys to maintain their \u201cwarm\u201d status throughout an entire block\u2019s execution. Accessed slots can be effectively cached at the block level, allowing for this opimization.", "Motivation": "Currently, the EVM\u2019s storage slot warming mechanism operates at the transaction level, requiring each transaction to \u201cwarm up\u201d slots independently, even when accessing the same storage locations within the same block. This design does not take advantage of the fact that modern node implementations can effectively cache storage access patterns at the block level. By extending the slot warming duration to the block level, we can:", "Specification": "When a storage slot is accessed within a block:", "Mechanics": "When a storage slot is accessed within a block:", "Block Processing": "The implementation modifies the block execution process to maintain block-level sets of accessed addresses and storage slots.", "Implementation Details": "The implementation modifies the block execution process to maintain block-level sets of accessed addresses and storage slots.", "Rationale": "The proposal builds on several key observations:", "Backwards Compatibility": "This change is not backward compatible and requires a hard fork activation. However, it does not introduce any breaking changes for existing contracts, as:", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7864, "url": "https://eips.ethereum.org/EIPS/eip-7864", "title": "Ethereum state using a unified binary tree", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Guillaume Ballet\u00a0(", "@gballet", ")", "Dankrad Feist\u00a0(", "@dankrad", ")", "Ignacio Hagopian\u00a0(", "@jsign", ")", "Kevaundray Wedderburn\u00a0(", "@kevaundray", ")", "Tanishq Jasoria\u00a0(", "@tanishqjasoria", ")", "Gajinder Singh\u00a0(", "@g11tech", ")", "Danno Ferrin\u00a0(", "@shemnon", ")", "Piper Merriam\u00a0(", "@pipermerriam", ")", "Gottfried Herold\u00a0(", "@GottfriedHerold", ")"], "sections": {"EIP-7864: Ethereum state using a unified binary tree": "Introduce a new binary state tree, intended to replace the hexary patricia trees. Account and storage tries are merged into a single tree with 32-byte keys, which also contains contracts code. Account data is broken into independent leaves which  are grouped by 256 in order to provide some locality.", "Switch Ethereum state tree to a unified binary tree": "Introduce a new binary state tree, intended to replace the hexary patricia trees. Account and storage tries are merged into a single tree with 32-byte keys, which also contains contracts code. Account data is broken into independent leaves which  are grouped by 256 in order to provide some locality.", "Abstract": "Introduce a new binary state tree, intended to replace the hexary patricia trees. Account and storage tries are merged into a single tree with 32-byte keys, which also contains contracts code. Account data is broken into independent leaves which  are grouped by 256 in order to provide some locality.", "Motivation": "Ethereum\u2019s long-term goal is to allow blocks to be proved with validity proof so that chain verification is as simple and fast as possible. One of the most challenging parts of achieving that goal is proving the state of the tree, which is required for EVM execution.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Notable changes from the hexary structure": "The proposed Binary Tree stores key-value entries where both the key and value are 32 bytes. The first 31-bytes of the key define the entry stem, and the last byte is the subindex in that stem. If two keys have the same stem, they live in the same \u201cbig branch\u201d \u2014 this co-locates groups of 256 keys (i.e: keys with the same first 31-bytes).", "Tree structure": "The proposed Binary Tree stores key-value entries where both the key and value are 32 bytes. The first 31-bytes of the key define the entry stem, and the last byte is the subindex in that stem. If two keys have the same stem, they live in the same \u201cbig branch\u201d \u2014 this co-locates groups of 256 keys (i.e: keys with the same first 31-bytes).", "Node merkelization": "Definehash(value)as:", "Tree embedding": "Instead of a two-layer structure like the MPT, we will embed all information into a uniquekey: valuespace in the proposed single tree. This section specifies which tree keys store the state\u2019s information (account header data, code, storage). The data is colocated in such way that data that is usually accessed together lives in the sameStemNodewhich reduces branch openings.", "Header values": "These are the positions in the tree at which header fields of an account are stored.", "Code": "Chunkistores a 32 byte value, where bytes 1\u202631 are bytesi*31...(i+1)*31 - 1of the code (i.e. the i\u2019th 31-byte slice of it), and byte 0 is the number of leading bytes that are part of PUSHDATA (e.g. if part of the code is...PUSH4 99 98 | 97 96 PUSH1 128 MSTORE...where|is the position where a new chunk begins, then the encoding of the latter chunk would begin2 97 96 PUSH1 128 MSTOREto reflect that the first 2 bytes are PUSHDATA).", "Storage": "Note that storage slots in the same sizeSTEM_SUBTREE_WIDTHrange (i.e. a range with the formx*STEM_SUBTREE_WIDTH ... (x+1)*STEM_SUBTREE_WIDTH-1)are all, except for theHEADER_STORAGE_OFFSETspecial case, part of a single stem.", "Fork": "Described inEIP-7612.", "Access events": "Described inEIP-4762.", "Rationale": "This EIP defines a new Binary Tree that starts empty. Only new state changes are stored in the tree. The MPT continues to exist but is frozen. This sets the stage for a future hard fork that migrates the MPT data to this Binary Tree (EIP-7748).", "Single tree design": "The proposal uses a single-layer tree structure with 32-byte keys and values for several reasons:", "SNARK friendliness and Post-Quantum security": "The proposed design should consider the usual complexity, performance, and efficiency for out-of-circuit implementations (i.e. EL clients) and in-circuit ones for generating proofs in ZK circuits.", "Arity-2": "Binary tries have been chosen primarily because they reduce the witness size. In general, in anN-element tree with each element havingkchildren, the average size of a branch is roughly32 * (k-1) * log(N) / log(k)plus a few percent for overhead. 32 is the length of a hash; thek-1refers to the fact that a Merkle proof needs to provide allk-1sister nodes at each level, andlog(N) / log(k)is an approximation of the number of levels in the tree (e.g. a tree where each node has 5 children, with 625 nodes total, would have depth 4, as625 = 5**4and solog(625) / log(5) = 4).", "Tree depth": "The tree design attempts to be as simple as possible considering both out-of-circuit and circuit implementations, while satisfying our throughput constraints on proving hashes.", "State-expiry": "State-expiry strategies such asEIP-7736could still be applied, requiring a change in the design. One potential solution is adding a field theStemNodewithepochas described in the mentioned EIP. Another alternative is to use 247-bits for the stem, and have two subtreesStemValuesNode, which would correspond to the current 256-values, andStemMetaNodewhich is also a 256-subtree that can be used to store arbitrary stem metadata.", "Backwards Compatibility": "The main breaking changes are:", "Test Cases": "TODO:", "Reference Implementation": "Python reference implementation (github.com/jsign/binary-tree-spec).", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7877, "url": "https://eips.ethereum.org/EIPS/eip-7877", "title": "Enhanced RETURN opcodes", "authors": ["Josh Weintraub\u00a0(", "@jhweintraub", ")"], "sections": {"EIP-7877: Enhanced RETURN opcodes": "This EIP specifies a series of newRETURNopcodes which allow the user to specify which data location to return from\ninstead of defaulting to returning from memory.", "Deprecate RETURN opcode in favor of new opcodes that allow returning data from various locations without first having to write to memory.": "This EIP specifies a series of newRETURNopcodes which allow the user to specify which data location to return from\ninstead of defaulting to returning from memory.", "Abstract": "This EIP specifies a series of newRETURNopcodes which allow the user to specify which data location to return from\ninstead of defaulting to returning from memory.", "Motivation": "With the introduction of transient storage, many smart contracts have begun to store data using the new transient opcodes to optimize for gas usage, whereby a callback\ninvolves returning the data previously stored transiently. However, the currentRETURNopcode only allows for returning sequential bytes in memory. This requires\ndevelopers to incur additional gas overhead by manually writing data from transient storage to memory before returning,\nincuring both an additional memory expansion and opcode cost from complicated for-loops. Similar\ninefficiencies already occur when attempting to return data already placed in storage. This EIP attempts to rectify\nthis by allowing developers to optimize their code by deciding where to return data from directly, instead of requiring\nthe intermediate step of first copying the data to memory.", "Specification": "This EIP introduces 3 new opcodes as well as renaming/aliasing an existing one.", "Rationale": "Allowing for more targeted return opcodes allows for saving gas at all levels of smart contract optimization by eliminating\nthe intermediate steps of first writing any data to memory before returning. In events where this data may be large, this can result in significant gas savings. These opcodes can be built into the Solidity compiler directly so that all contracts\ncan take advantage of them. Similarly, by making return more explicit it allows for better static analysis by avoiding messy memory allocations.", "Backwards Compatibility": "There are no backwards compatibility concerns, asMRETURNwill utilize the same gas cost and opcode asRETURNdoes now. Due to EOF, it is suggested that these changes be\nactivated in future EVM version once EOF has been fully implemented.", "Security Considerations": "There are no security considerations as it is fully backwards compatible, and reduces potential attack space through simplified bytecode.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7883, "url": "https://eips.ethereum.org/EIPS/eip-7883", "title": "ModExp Gas Cost Increase", "authors": ["Marcin Sobczak\u00a0(", "@marcindsobczak", ")", "Marek Moraczy\u0144ski\u00a0(", "@MarekM25", ")", "Marcos Maceo\u00a0(", "@stdevMac", ")"], "sections": {"EIP-7883: ModExp Gas Cost Increase": "This EIP is modifying theModExpprecompile pricing algorithm introduced inEIP-2565.", "Increases cost of ModExp precompile": "This EIP is modifying theModExpprecompile pricing algorithm introduced inEIP-2565.", "Abstract": "This EIP is modifying theModExpprecompile pricing algorithm introduced inEIP-2565.", "Motivation": "There are cases where theModExpprecompile is underpriced for it\u2019s resource consumption. By modifying theModExppricing formula these scenarios would be covered with minimal impact on real world applications. The target is to makeModExpat least as fast as EcRecover precompile in all cases.", "Specification": "Upon activation of this EIP, the gas cost of calling the precompile at address0x0000000000000000000000000000000000000005will be calculated as follows:", "1. Increase minimal price from 200 to 500": "This part of equation:", "2. Increase cost when exponent is larger than 32 bytes": "This part of equation:", "3. Increase cost when base or modulus is larger than 32 bytes": "This part of equation:", "Rationale": "After benchmarking theModExpprecompile, we identified certain scenarios that are underpriced and require repricing to ensure appropriate costs. Further research revealed that all underpriced edge cases can be addressed by adjusting the parameters in the currentModExppricing formula. With these changes, the minimum cost for using theModExpprecompile will increase from 200 to 500 (a 150% increase), and the cost will scale higher when thebase,modulus, orexponentexceed 32 bytes. These adjustments will ensure that the worst-performing edge cases of theModExpprecompile perform no worse than theEcRecoverprecompile.", "Backwards Compatibility": "This change is backwards incompatible. However, similar gas repricings have occurred multiple times in the Ethereum ecosystem, and their effects are well understood.", "Test Cases": "There are no changes to the underlying interface or arithmetic algorithms, so the existing test vectors can be reused. Below is a table with the updated test vectors:", "Reference Implementation": "[None]", "Security Considerations": "There are no security concerns since no new functionality is introduced or made cheaper. The primary consideration for this EIP is the risk of potentially overpricedModExpscenarios.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7886, "url": "https://eips.ethereum.org/EIPS/eip-7886", "title": "Delayed execution", "authors": ["Francesco D`Amato\u00a0(", "@fradamt", ")", "Toni Wahrst\u00e4tter\u00a0(", "@nerolation", ")"], "sections": {"EIP-7886: Delayed execution": "This proposal makes (execution) blocks statically verifiable through minimal checks that only require the previous state, but no execution of the block\u2019s transactions, allowing validators attest to a block\u2019s validity without completing its execution. We allow transactions to be skipped when invalid at execution time, without invalidating the whole block. To ensure that even skipped transactions pay for their resources, theCOINBASEpays for all inclusion costs upfront (base cost, calldata and blobs), and recovers the costs only when transactions are successfully executed.", "Make blocks statically verifiable by charging coinbase for inclusion costs upfront": "This proposal makes (execution) blocks statically verifiable through minimal checks that only require the previous state, but no execution of the block\u2019s transactions, allowing validators attest to a block\u2019s validity without completing its execution. We allow transactions to be skipped when invalid at execution time, without invalidating the whole block. To ensure that even skipped transactions pay for their resources, theCOINBASEpays for all inclusion costs upfront (base cost, calldata and blobs), and recovers the costs only when transactions are successfully executed.", "Abstract": "This proposal makes (execution) blocks statically verifiable through minimal checks that only require the previous state, but no execution of the block\u2019s transactions, allowing validators attest to a block\u2019s validity without completing its execution. We allow transactions to be skipped when invalid at execution time, without invalidating the whole block. To ensure that even skipped transactions pay for their resources, theCOINBASEpays for all inclusion costs upfront (base cost, calldata and blobs), and recovers the costs only when transactions are successfully executed.", "Motivation": "A key advantage of this proposal is that it enablesasynchronous block validation. Currently, blocks must be fully executed before validators can attest to their validity. This requirement creates a bottleneck in the consensus process, as attestors must wait for execution results before committing their votes.", "Specification": "In order to be verifiable before execution, the header cannot commit to any execution output. In particular, we need to defer these fields:state_root, receipt_root, bloom, gas_used, requests_hash. We replace them with the equivalent execution outputs from the parent block.", "Change to the header structure": "In order to be verifiable before execution, the header cannot commit to any execution output. In particular, we need to defer these fields:state_root, receipt_root, bloom, gas_used, requests_hash. We replace them with the equivalent execution outputs from the parent block.", "Static block validation": "We split up a block\u2019s validation from its execution. In the ethereum/execution-specs, static validation is done in[validate_block](https://github.com/ethereum/execution-specs/blob/ae2c77989cb83e5d5e5eb1f51d9da840a337d5b0/src/ethereum/prague/fork.py#L480), after which a block is guaranteed to be valid and can be attested to, while execution remains within[apply_body](https://github.com/ethereum/execution-specs/blob/ae2c77989cb83e5d5e5eb1f51d9da840a337d5b0/src/ethereum/prague/fork.py#L696). Invalidate_block, we do some formal checks, as well as:", "Block execution": "This logic is implemented into the ethereum/execution-specs, in[apply_body](https://github.com/ethereum/execution-specs/blob/ae2c77989cb83e5d5e5eb1f51d9da840a337d5b0/src/ethereum/prague/fork.py#L696).", "Rationale": "Enabling delayed execution by making the block\u2019s validity statically verifiable requires two things:", "Overview": "Enabling delayed execution by making the block\u2019s validity statically verifiable requires two things:", "Coinbase signature over the header": "By signing over the header, theCOINBASEaddress explicitly accepts responsibility for the upfront inclusion costsof this block. Therefore, the recovered address MUST equal the block\u2019sCOINBASE. TheCOINBASE\u2019s commitment is protected from replay attacks, because the header is a commitment to the block, so the signature only serves as an authorization for the exact block for which theCOINBASEhas agreed to take responsibility.", "Backwards Compatibility": "This change is not backward compatible and requires a hard fork activation.", "Security Considerations": "At the time of block creation, theCOINBASEmust be sufficiently funded to cover up toblock.gas_limit * base_fee_per_gas+blob_gas_price * max_blob_gas_per_blockto be able to cover the maximum possible inclusion cost. For instance, with a base fee of 100 gwei and a 36 million gas limit, theCOINBASEwould need to hold 3.6 ETH to front this cost (ignoring the blob fees) for a worst-case block. This requirement could introduce additional liquidity constraints for block proposers, especially under high base fee conditions. However, the inclusion costs under normal conditions (lower base fee, inclusion gas much below the gas limit) are significantly lower. Over a one year period of blocks from ~19.1M to ~21.7M, the average inclusion costs would have been ~5.5M gas per block, or ~0.55 ETH even at 100 gwei.", "Coinbase funding": "At the time of block creation, theCOINBASEmust be sufficiently funded to cover up toblock.gas_limit * base_fee_per_gas+blob_gas_price * max_blob_gas_per_blockto be able to cover the maximum possible inclusion cost. For instance, with a base fee of 100 gwei and a 36 million gas limit, theCOINBASEwould need to hold 3.6 ETH to front this cost (ignoring the blob fees) for a worst-case block. This requirement could introduce additional liquidity constraints for block proposers, especially under high base fee conditions. However, the inclusion costs under normal conditions (lower base fee, inclusion gas much below the gas limit) are significantly lower. Over a one year period of blocks from ~19.1M to ~21.7M, the average inclusion costs would have been ~5.5M gas per block, or ~0.55 ETH even at 100 gwei.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7889, "url": "https://eips.ethereum.org/EIPS/eip-7889", "title": "Emit log on revert", "authors": ["Shoham Chakraborty\u00a0(", "@shohamc1", ")", "Alex Forshtat\u00a0(", "@forshtat", ")"], "sections": {"EIP-7889: Emit log on revert": "All calls to the REVERT opcode with non-zero size must emit a log with revert data, making it accessible via standard RPC without the need for tracing.", "Top level reverts emit a log with revert message": "All calls to the REVERT opcode with non-zero size must emit a log with revert data, making it accessible via standard RPC without the need for tracing.", "Abstract": "All calls to the REVERT opcode with non-zero size must emit a log with revert data, making it accessible via standard RPC without the need for tracing.", "Motivation": "Revert messages are currently inaccessible to users as they are not available via standard RPC. Instead, users have to request a node to trace the transaction and check the stack and memory at the moment when the REVERT opcode was executed.", "Specification": "WheneverREVERTis called with non-zero size, emit a log identical to a LOG1 with the topicREVERTTOPIC. The log data is the raw bytes of the revert message. The data is truncated toDATA_LIMIT.", "Parameters": "WheneverREVERTis called with non-zero size, emit a log identical to a LOG1 with the topicREVERTTOPIC. The log data is the raw bytes of the revert message. The data is truncated toDATA_LIMIT.", "Functionality": "WheneverREVERTis called with non-zero size, emit a log identical to a LOG1 with the topicREVERTTOPIC. The log data is the raw bytes of the revert message. The data is truncated toDATA_LIMIT.", "Rationale": "This is the simplest possible implementation that allows revert messages to be accessible via RPC methods. It does not require any changes to client libraries, or other RPC consumers as it is backward compatible. It does not introduce new RPC methods or new opcodes.", "Backwards Compatibility": "Reverted transactions may now contain up to one log.", "Security Considerations": "Reverted transactions must cost at least intrinsic gas (21000 gas), which is much more expensive than the LOG1 opcode (750 gas). Hence, this EIP does not introduce any new avenues to inflate Ethereum storage requirements. However, it is expected to increase the average number of logs.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7898, "url": "https://eips.ethereum.org/EIPS/eip-7898", "title": "Uncouple execution payload from beacon block", "authors": ["Gajinder Singh\u00a0(", "@g11tech", ")"], "sections": {"EIP-7898: Uncouple execution payload from beacon block": "Currently, the beacon block in Ethereum Consensus embed transactions withinExecutionPayloadfield ofBeaconBlockBody. This EIP proposes to replaceExecutionPayloadwithExecutionPayloadHeaderinBeaconBlockBodyand to independently transmitExecutionPayloadWithInclusionProof.", "Separates the execution payload from beacon block to independently transmit them": "Currently, the beacon block in Ethereum Consensus embed transactions withinExecutionPayloadfield ofBeaconBlockBody. This EIP proposes to replaceExecutionPayloadwithExecutionPayloadHeaderinBeaconBlockBodyand to independently transmitExecutionPayloadWithInclusionProof.", "Abstract": "Currently, the beacon block in Ethereum Consensus embed transactions withinExecutionPayloadfield ofBeaconBlockBody. This EIP proposes to replaceExecutionPayloadwithExecutionPayloadHeaderinBeaconBlockBodyand to independently transmitExecutionPayloadWithInclusionProof.", "Motivation": "Ethereum protocol has an ambitious goal to grow thegasLimitof the execution payloads (possibly by 10X). This leads to larger messages, negatively affecting the networking and block processing pipelines of the consensus layer (CL) clients leading to following issues:", "Specification": "ELs can optionally introduce agetExecutionPayloadmethod (similar togetBlobs) to assist with faster recovery of execution payload from the EL\u2019s p2p network peers who could annouce new payload hashes when they see newVALIDpayloads. However, as noted above, that mechanism could be independently specified and is out of scope for this EIP.", "Rationale": "There is another choice we could have made to go forSignedExecutionPayloadinstead ofExecutionPayloadWithInclusionProofand having aSignedExecutionPayloadHeaderwith builder signing these messages (validator is the builder in local block building). But without builder enshrinment tight gossip validation ofSignedExecutionPayloadwould be an issue and could become a DOS vector.", "Backwards Compatibility": "This change isn\u2019t backward compatible and a new hardfork is required to activate this EIP.", "Test Cases": "<\u2013 TODO \u2013>", "Reference Implementation": "<\u2013 TODO \u2013>", "Security Considerations": "<\u2013 TODO \u2013>", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7903, "url": "https://eips.ethereum.org/EIPS/eip-7903", "title": "Remove Initcode Size Limit", "authors": ["Charles Cooper\u00a0(", "@charles-cooper", ")"], "sections": {"EIP-7903: Remove Initcode Size Limit": "This EIP proposes the removal of theinitcodesize limit of 49152 bytes introduced inEIP-3860. The restriction complicates deploying multiple contracts addressing theEIP-170limit (24576 bytes) within a single transaction, while the existing gas metering forinitcode, already ensures fairinitcodecosting, including forJUMPDESTanalysis.", "Removes the initcode size limit introduced in EIP-3860": "This EIP proposes the removal of theinitcodesize limit of 49152 bytes introduced inEIP-3860. The restriction complicates deploying multiple contracts addressing theEIP-170limit (24576 bytes) within a single transaction, while the existing gas metering forinitcode, already ensures fairinitcodecosting, including forJUMPDESTanalysis.", "Abstract": "This EIP proposes the removal of theinitcodesize limit of 49152 bytes introduced inEIP-3860. The restriction complicates deploying multiple contracts addressing theEIP-170limit (24576 bytes) within a single transaction, while the existing gas metering forinitcode, already ensures fairinitcodecosting, including forJUMPDESTanalysis.", "Motivation": "The EIP-3860initcodesize limit imposes an unnecessary constraint on deployment patterns, particularly for creation transactions creating largelogicalcontracts composed of multiplephysical sub-contractsin a single transaction.\nA key argument for retaining EIP-170\u2019s 24KB runtime code limit is that high-level languages (HLLs) should abstract it away.\nHowever, the EIP-3860 limit prevents HLLs from cleanly abstracting this, as deploying large logical contracts exceeding 49152 bytes ofinitcoderequires splitting into multiple transactions, undermining the abstraction.", "Specification": "Revert theinitcodesize limit introduced in EIP-3860. Specifically:", "Rationale": "This proposal is driven by the need to restore flexibility in contract deployment patterns, such as factory contracts creating multiple sub-contracts in one transaction. The design decision to remove the 49152-byte cap leverages the pre-existing gas metering system, which scales linearly withinitcodesize (i.e., 2 gas per byte), ensuring fair cost attribution without artificial limits.", "Backwards Compatibility": "This change is fully backwards compatible. Existing contracts and transactions remain unaffected, as the proposal only lifts a restriction without altering execution semantics or gas costs.", "Test Cases": "No new security risks are introduced. The current gas schedule already mitigates denial-of-service concerns by charging per-byte forinitcode. Benchmarks were performed, and ns/byte remained consistent across a range of different bytecodes, ranging from 128 bytes to 15MB.", "Security Considerations": "No new security risks are introduced. The current gas schedule already mitigates denial-of-service concerns by charging per-byte forinitcode. Benchmarks were performed, and ns/byte remained consistent across a range of different bytecodes, ranging from 128 bytes to 15MB.", "Copyright": "Copyright and related rights waived via CC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7907, "url": "https://eips.ethereum.org/EIPS/eip-7907", "title": "Meter Contract Code Size And Increase Limit", "authors": ["Charles Cooper\u00a0(", "@charles-cooper", ")", "Qi Zhou\u00a0(", "@qizhou", ")"], "sections": {"EIP-7907: Meter Contract Code Size And Increase Limit": "This EIP substantially increases the hard contract code size limit from 24KB (24576 bytes) introduced inEIP-170to 256KB, and adds gas metering. It introduces a gas cost of 2 gas per (32 byte) word for contract code exceeding 24KB, allowing deployment of contracts of any size while preventing DoS attacks through appropriate gas metering. Lastly, it also commensurately increases initcode size limit from 48KB, introduced inEIP-3860, to 512KB.", "Increases the contract code size limit introduced in EIP-170 and adds a gas metering to code loading": "This EIP substantially increases the hard contract code size limit from 24KB (24576 bytes) introduced inEIP-170to 256KB, and adds gas metering. It introduces a gas cost of 2 gas per (32 byte) word for contract code exceeding 24KB, allowing deployment of contracts of any size while preventing DoS attacks through appropriate gas metering. Lastly, it also commensurately increases initcode size limit from 48KB, introduced inEIP-3860, to 512KB.", "Abstract": "This EIP substantially increases the hard contract code size limit from 24KB (24576 bytes) introduced inEIP-170to 256KB, and adds gas metering. It introduces a gas cost of 2 gas per (32 byte) word for contract code exceeding 24KB, allowing deployment of contracts of any size while preventing DoS attacks through appropriate gas metering. Lastly, it also commensurately increases initcode size limit from 48KB, introduced inEIP-3860, to 512KB.", "Motivation": "EIP-170 introduced a 24KB contract code size limit to prevent potential DoS attacks, as large contract code requires O(n) resource cost in terms of disk reads, VM preprocessing, and Merkle proof sizes, all of which are not directly compensated by gas fees. However, this limit restricts legitimate use cases for large contracts.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "The gas cost of 2 per word was chosen in-line with EIP-3860. This accounts for:", "Backwards Compatibility": "This EIP is backward compatible with existing contracts. All contracts that were valid before this EIP will remain valid after it, and their gas costs will not change.", "Test Cases": "Clients should add an efficient way to determine the code size without loading the entire code, e.g. storing it in a separate table keyed by code hash. This way, they can charge for the access cost before physically loading the code. Otherwise, a client may load a contract, even when there is not enough gas left to pay for the code load.", "Reference Implementation": "Clients should add an efficient way to determine the code size without loading the entire code, e.g. storing it in a separate table keyed by code hash. This way, they can charge for the access cost before physically loading the code. Otherwise, a client may load a contract, even when there is not enough gas left to pay for the code load.", "Security Considerations": "Clients should add an efficient way to determine the code size without loading the entire code, e.g. storing it in a separate table keyed by code hash. This way, they can charge for the access cost before physically loading the code. Otherwise, a client may load a contract, even when there is not enough gas left to pay for the code load.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7915, "url": "https://eips.ethereum.org/EIPS/eip-7915", "title": "Adaptive mean reversion blob pricing", "authors": ["Anders Elowsson\u00a0(", "@anderselowsson", ")"], "sections": {"EIP-7915: Adaptive mean reversion blob pricing": "Reworks the excess blob gas update incalc_excess_blob_gas()so that the blob base fee rises relatively more during high gas usage than it falls during low usage whenever the current fee is below the long-run average. This establishes a smoothly adapting, neutral lower bound for the base fee. The exponential moving average (EMA) is computed in the linear domain and stored as a header variable.", "Fee schedule accounting for the long-run average to quickly restore equilibrium under inelastic demand": "Reworks the excess blob gas update incalc_excess_blob_gas()so that the blob base fee rises relatively more during high gas usage than it falls during low usage whenever the current fee is below the long-run average. This establishes a smoothly adapting, neutral lower bound for the base fee. The exponential moving average (EMA) is computed in the linear domain and stored as a header variable.", "Abstract": "Reworks the excess blob gas update incalc_excess_blob_gas()so that the blob base fee rises relatively more during high gas usage than it falls during low usage whenever the current fee is below the long-run average. This establishes a smoothly adapting, neutral lower bound for the base fee. The exponential moving average (EMA) is computed in the linear domain and stored as a header variable.", "Motivation": "Demand for blobspace is fee-inelastic, leading to a blob base fee that may fluctuate excessively with minor shifts in aggregate demand. The lower end of the fee range of 1 wei is under current circumstances economically inconsequential, but can be reached after a period of blocks consuming fewer blobs than the target. During increases in demand, the existing fee mechanism requires sustained periods of near-full blocks to re-establish equilibrium. This exacerbates spikiness in resource consumption, which can hamper efficient scaling of throughput. Furthermore, users may intermittently need to compete in a first-price auction for inclusion, degrading UX. The appropriate fee range will inadvertently vary going forward due to changes in the ETH token price and circulating supply, as well as the protocol\u2019s ability to scale throughput. To remain neutral and future-proof, the operational range should be established relative to the long-run average fee, smoothly affecting the equilibrium quantity of blobs consumed. Thus, this EIP introduces a new fee update mechanism that accounts for the long-run average fee when responding to shifts in demand. This allows the protocol to quickly converge to desirable equilibria while also remaining neutral and future-proof.", "Specification": "The functioncalc_excess_blob_gas()fromEIP-4844is updated. A mean reversion weightwis computed based on the ratio between the long-run base fee and the current base fee. The weight influences the excess gas update by smoothly increasing the gas used and decreasing the gas target as the current base fee falls below the long-run base fee (see Figure 2 below). The variableUpupsampleswto retain precision. Note that the function appliesinteger_squareroot(), which must be implemented at the execution layer; it is currently implemented at the consensus layer. Thresholding atMEAN_REVERSION_FULLBANDand strategic deployment ofUpallows the mechanism to rely on theuint64type internally.", "Parameters": "The functioncalc_excess_blob_gas()fromEIP-4844is updated. A mean reversion weightwis computed based on the ratio between the long-run base fee and the current base fee. The weight influences the excess gas update by smoothly increasing the gas used and decreasing the gas target as the current base fee falls below the long-run base fee (see Figure 2 below). The variableUpupsampleswto retain precision. Note that the function appliesinteger_squareroot(), which must be implemented at the execution layer; it is currently implemented at the consensus layer. Thresholding atMEAN_REVERSION_FULLBANDand strategic deployment ofUpallows the mechanism to rely on theuint64type internally.", "Functions": "The functioncalc_excess_blob_gas()fromEIP-4844is updated. A mean reversion weightwis computed based on the ratio between the long-run base fee and the current base fee. The weight influences the excess gas update by smoothly increasing the gas used and decreasing the gas target as the current base fee falls below the long-run base fee (see Figure 2 below). The variableUpupsampleswto retain precision. Note that the function appliesinteger_squareroot(), which must be implemented at the execution layer; it is currently implemented at the consensus layer. Thresholding atMEAN_REVERSION_FULLBANDand strategic deployment ofUpallows the mechanism to rely on theuint64type internally.", "Header extension": "The current header encoding is extended with theuintfieldbase_fee_per_blob_gas_ema. For the first post-fork block,parent.base_fee_per_blob_gas_emais evaluated as4*10**9(4 gwei).", "Execution layer validation": "The block validity conditions on the execution layer are extended to assert thatbase_fee_per_blob_gas_emawas correctly updated:", "Rationale": "Since the introduction of blobs, the reservation fee of the marginal consumer of blobs has periodically been very low. Whenever demand picks up, a sustained succession of near-full blocks is required to restore equilibrium, with the mechanism intermittently resorting to a first-price auction, considered a worse UX by blob consumers. The resulting spikiness in resource consumption is suboptimal for scaling blobspace. At a fundamental level, the issue is that Ethereum faces a fee-inelastic demand curve while operating a perfectly inelastic supply curve\u2014with supply fixed atTARGET_BLOB_GAS_PER_BLOCK. When an equilibrium forms between fee-inelastic supply and demand curves, even a small shift in aggregate demand can lead to huge shifts in the equilibrium fee. This proposal smoothly increases the elasticity of the supply curve as it diverges from the long-run average, restricting the equilibrium fee from forming much below the average. Combined with the faster fee adjustments in the direction of the average, a desirable equilibrium can then quickly be established during temporary shifts in demand.", "Supply and demand": "Since the introduction of blobs, the reservation fee of the marginal consumer of blobs has periodically been very low. Whenever demand picks up, a sustained succession of near-full blocks is required to restore equilibrium, with the mechanism intermittently resorting to a first-price auction, considered a worse UX by blob consumers. The resulting spikiness in resource consumption is suboptimal for scaling blobspace. At a fundamental level, the issue is that Ethereum faces a fee-inelastic demand curve while operating a perfectly inelastic supply curve\u2014with supply fixed atTARGET_BLOB_GAS_PER_BLOCK. When an equilibrium forms between fee-inelastic supply and demand curves, even a small shift in aggregate demand can lead to huge shifts in the equilibrium fee. This proposal smoothly increases the elasticity of the supply curve as it diverges from the long-run average, restricting the equilibrium fee from forming much below the average. Combined with the faster fee adjustments in the direction of the average, a desirable equilibrium can then quickly be established during temporary shifts in demand.", "Proposed base fee update schedule": "The update schedule adheres to the following design principles:", "Computing the long-run average base fee": "An average of the base fee $\\bar{f}_g$ is maintained in the header variablebase_fee_per_blob_gas_ema, computed as an exponential moving average. Each slot, $\\bar{f}_g$ is updated by taking", "Alternative approach": "One alternative way to structure the adaptive mean reversion was referenced in the previous subsection and will be described here. It differs in that that the protocol would rely on and store a log-domain representation ofbase_fee_per_blob_gas_ema:excess_blob_gas_ema. The EMA computation would still be performed in the linear domain, butget_base_fee_per_blob_gas()and its inverse\u2014relying on a newfake_log()function\u2014would be applied during computations to first go to the linear domain and then return to the log-domain", "Security Considerations": "The blob base fee doubles during full blocks if the current fee is several orders of magnitude below the average. As a result, a single-block delay in inclusion results in users paying twice as much, potentially influencing inclusion and fee-market strategies. However, practical implications should be limited, given that this aggressive fee schedule only operates at fees well below the average.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7916, "url": "https://eips.ethereum.org/EIPS/eip-7916", "title": "SSZ ProgressiveList", "authors": ["Zsolt Felf\u00f6ldi\u00a0(", "@zsfelfoldi", ")", "Cayman\u00a0(", "@wemeetagain", ")", "Etan Kissling\u00a0(", "@etan-status", ")"], "sections": {"EIP-7916: SSZ ProgressiveList": "This EIP introduces a newSimple Serialize (SSZ)type,ProgressiveList[T], to represent lists of arbitrary length with stable merkleization. Unlike the existingList[T, N]type, which imposes a fixed capacityN,ProgressiveList[T]supports unbounded growth using a recursive tree structure during merkleization to efficiently handle lists of any size while maintaining stablegeneralized indices (gindices)for individual elements. This enables reduced hash overhead for small lists and avoids arbitrary predefined limits.", "New SSZ type to improve efficiency for short lists": "This EIP introduces a newSimple Serialize (SSZ)type,ProgressiveList[T], to represent lists of arbitrary length with stable merkleization. Unlike the existingList[T, N]type, which imposes a fixed capacityN,ProgressiveList[T]supports unbounded growth using a recursive tree structure during merkleization to efficiently handle lists of any size while maintaining stablegeneralized indices (gindices)for individual elements. This enables reduced hash overhead for small lists and avoids arbitrary predefined limits.", "Abstract": "This EIP introduces a newSimple Serialize (SSZ)type,ProgressiveList[T], to represent lists of arbitrary length with stable merkleization. Unlike the existingList[T, N]type, which imposes a fixed capacityN,ProgressiveList[T]supports unbounded growth using a recursive tree structure during merkleization to efficiently handle lists of any size while maintaining stablegeneralized indices (gindices)for individual elements. This enables reduced hash overhead for small lists and avoids arbitrary predefined limits.", "Motivation": "Current SSZList[T, N]types require a predefined capacityN, which leads to several issues:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "ProgressiveList[T]": "ProgressiveList[T]defines an ordered, homogeneous collection of elements of typeT, whereTis any valid SSZ type (e.g.,uint64,Container, etc.).", "ProgressiveByteList": "For convenienceProgressiveByteListis defined as an alias toProgressiveList[byte].", "Rationale": "Dynamic-depth Merkleization destabilizes gindices:", "Why a Recursive Structure?": "Dynamic-depth Merkleization destabilizes gindices:", "Why Not Dynamic Depth?": "Dynamic-depth Merkleization destabilizes gindices:", "Why Not Fixed-Capacity Lists?": "List[T, N]:", "Why Are Base Size and Scaling Factors Not Exposed Parameters?": "ProgressiveList[T]is a new SSZ type, coexisting withList[T, N]and other types without conflict. ItsList-equivalent serialization ensures compatibility with existing serializers.", "Backwards Compatibility": "ProgressiveList[T]is a new SSZ type, coexisting withList[T, N]and other types without conflict. ItsList-equivalent serialization ensures compatibility with existing serializers.", "Test Cases": "SeeEIP assets.", "Reference Implementation": "SeeEIP assets, based onprotolambda/remerkleable.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7917, "url": "https://eips.ethereum.org/EIPS/eip-7917", "title": "Deterministic proposer lookahead", "authors": ["Lin Oshitani (@linoscope)\u00a0<", "lin@nethermind.io", ">", "Justin Drake (@JustinDrake)\u00a0<", "justin@ethereum.org", ">"], "sections": {"EIP-7917: Deterministic proposer lookahead": "At the start of each epoch, pre-calculate and store in thebeacon_statea deterministicproposer_lookaheadfor the nextMIN_SEED_LOOKAHEAD + 1epochs.", "Pre-calculate and store a deterministic proposer lookahead in the beacon state at the start of every epoch": "At the start of each epoch, pre-calculate and store in thebeacon_statea deterministicproposer_lookaheadfor the nextMIN_SEED_LOOKAHEAD + 1epochs.", "Abstract": "At the start of each epoch, pre-calculate and store in thebeacon_statea deterministicproposer_lookaheadfor the nextMIN_SEED_LOOKAHEAD + 1epochs.", "Motivation": "Unlike RANDAO seeds, which have a deterministic lookahead of at leastMIN_SEED_LOOKAHEAD == 1epochs, the beacon proposer schedule of epochN + 1is not fully predictable from the beacon state during epochN. The reason is that, under certain edge cases, the effective balances (EBs) of active validators\u2014themselves used as input for proposer election in epochN + 1\u2014can change within epochN.", "Specification": "TheBeaconStatecontainer is extended with aproposer_lookaheadfield, which is a list of validator indices covering the full visible lookahead period, starting from the beginning of the current epoch to the nextMIN_SEED_LOOKAHEADepochs.", "Rationale": "An alternative approach would be to cache the effective balances at the start of epochNso it can be used to calculate the proposer lookahead at the start of epochN+MIN_SEED_LOOKAHEAD. However, this approach would require additional footprint in the beacon state, and would not be able to provide the proposer lookahead to the EVM via the beacon root.", "Considered Alternatives": "An alternative approach would be to cache the effective balances at the start of epochNso it can be used to calculate the proposer lookahead at the start of epochN+MIN_SEED_LOOKAHEAD. However, this approach would require additional footprint in the beacon state, and would not be able to provide the proposer lookahead to the EVM via the beacon root.", "Single Secret Leader Election Compatibility": "In the future, we may introduce a Single Secret Leader Election (SSLE) mechanism in which only the selected validator knows their role until they propose a block. However, current SSLE designs still rely on a lookahead, albeit an encrypted one. In such designs, we could reuse theproposer_lookaheadfield by changing its type to something likeList[EncryptedValidatorIndex]. And if a construction were to remove lookahead entirely, we could simply setproposer_lookaheadto an empty list, meaning this wouldn\u2019t be a blocker.", "Added Computation at the Epoch Boundary": "Before this EIP, consensus clients only needed to compute the current proposer\u2019s index at each slot. With the changes introduced by this EIP, they must calculate the entire epoch\u2019s proposer schedule at the start of each epoch. However, computing the proposer index is light, involving sampling validators until we reach a validator with sufficient effective balance to be selected as a proposer. Still, testing is needed to confirm that these additional calculations do not create performance bottlenecks in practice.", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "Seethe spec testsin consensus-specs.", "Security Considerations": "A critical consideration for any proposer election mechanism is preventing validators from manipulating lookahead to gain an unfair advantage. This proposal does not increase the chances of such attacks, as we do not alter the \u201cRANDAO delay\u201d used in the lookahead\u2014the lookahead of epochNis still determined by the RANDAO of epochN - MIN_SEED_LOOKAHEAD - 1(which becomes available at the start of epochN - MIN_SEED_LOOKAHEAD). The only difference is that it changes the \u201ceffective balances delay\u201d: rather than using the effective balances (EB) at the start of epochN, it now uses the EB at the start of epochN - MIN_SEED_LOOKAHEAD.", "Malicious Lookahead Alteration": "A critical consideration for any proposer election mechanism is preventing validators from manipulating lookahead to gain an unfair advantage. This proposal does not increase the chances of such attacks, as we do not alter the \u201cRANDAO delay\u201d used in the lookahead\u2014the lookahead of epochNis still determined by the RANDAO of epochN - MIN_SEED_LOOKAHEAD - 1(which becomes available at the start of epochN - MIN_SEED_LOOKAHEAD). The only difference is that it changes the \u201ceffective balances delay\u201d: rather than using the effective balances (EB) at the start of epochN, it now uses the EB at the start of epochN - MIN_SEED_LOOKAHEAD.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7921, "url": "https://eips.ethereum.org/EIPS/eip-7921", "title": "Skip `JUMPDEST` immediate argument check", "authors": ["William Morriss\u00a0(", "@wjmelements", ")"], "sections": {"EIP-7921: Skip `JUMPDEST` immediate argument check": "AllowJUMPandJUMPIto arrive at any byte matchingJUMPDEST(0x5b), even if that byte is an immediate argument.", "All `JUMPDEST` bytes become valid `JUMPDEST`": "AllowJUMPandJUMPIto arrive at any byte matchingJUMPDEST(0x5b), even if that byte is an immediate argument.", "Abstract": "AllowJUMPandJUMPIto arrive at any byte matchingJUMPDEST(0x5b), even if that byte is an immediate argument.", "Motivation": "Immediate arguments are opcode parameters supplied within the code rather than the stack.\nCurrently determining the validity of aJUMPDESTrequires determining which bytes are immediate arguments to other opcodes, such asPUSH1.\nThis presents several problems:", "Specification": "When activated, all0x5bbytes are validJUMPDESTforJUMPIandJUMPopcodes.", "Rationale": "Removing the check solves several problems while reducing EVM complexity.", "Backwards Compatibility": "Code previously only had one interpretation for disassembly.\nWith this change, aJUMPDESTlocated inside an immediate argument can cause multiple disassembly interpretations.\nUsually the interpretations will converge after a few bytes but the length of such a dispute can be unbounded.CODECOPYdata has always been difficult to identify.\nIt is recommended that disassemblers provide all possible interpretations in their output in order to reveal possible underhanded functionality.", "Security Considerations": "Current contracts performing dynamic jumps may gain new unintended functionality if it is possible to jump to an immediate argument containingJUMPDEST.\nIt is expected that very few contracts will become vulnerable in this way.\nMost smart contract programming languages do not even allow dynamic jumps, and of those that do, few will haveJUMPDESTin an accessible immediate argument.\nTherefore it is expected that few contracts will become vulnerable, and for many of them the newly possible codepaths will contain invalid opcodes.\nA static analysis tool should be developed and made publicly available to test if a contract might become vulnerable, and the program should be run for all current contracts in order to notify projects about potential security issues.\nAffected programs will have ample time to migrate.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7922, "url": "https://eips.ethereum.org/EIPS/eip-7922", "title": "Dynamic exit queue rate limit", "authors": ["Mikhail Kalinin\u00a0(", "@mkalinin", ")", "Mike Neuder\u00a0(", "@michaelneuder", ")", "Mallesh Pai\u00a0(", "@Mmp610", ")"], "sections": {"EIP-7922: Dynamic exit queue rate limit": "This EIP proposes updating Ethereum\u2019s validator exit churn calculation by dynamically adjusting the churn limit at the start of each 256-epoch period (\u201cgeneration\u201d) based on historical validator exits. Specifically, the maximum churn allowed in each generation will adjust according to the unused churn from the past 16 generations. This approach reduces validator wait times during periods of high exit demandwithout sacrificing network safety.", "Update the validator exit process by dynamically adjusting the churn limit based on historical validator exits.": "This EIP proposes updating Ethereum\u2019s validator exit churn calculation by dynamically adjusting the churn limit at the start of each 256-epoch period (\u201cgeneration\u201d) based on historical validator exits. Specifically, the maximum churn allowed in each generation will adjust according to the unused churn from the past 16 generations. This approach reduces validator wait times during periods of high exit demandwithout sacrificing network safety.", "Abstract": "This EIP proposes updating Ethereum\u2019s validator exit churn calculation by dynamically adjusting the churn limit at the start of each 256-epoch period (\u201cgeneration\u201d) based on historical validator exits. Specifically, the maximum churn allowed in each generation will adjust according to the unused churn from the past 16 generations. This approach reduces validator wait times during periods of high exit demandwithout sacrificing network safety.", "Motivation": "Ethereum currently implements a fixed, rate-limited queue for validator exits to ensure the security and stability of the network. The exit queue ensures the economic security of transactions finalized by the validator set. Suppose a malicious validator could immediately exit the set without any delay. In that case, they may attempt to execute a double spend attack by publishing a block while withholding a conflicting block, which they release after their stake has exited the protocol. The slashing mechanism can no longer hold the malicious validator accountable, and two conflicting finalized transactions may exist (if the attacker has 1/3 of the total stake and successfully splits the 2/3 honest majority in half).", "Specification": "Since the validator exit process is complex, we start with the stack trace and a verbal description of the end-to-end process in Electra.", "Definitions": "Add the following to the state:", "Preset": "Add the following to the state:", "New State Variables": "Add the following to the state:", "Initialization": "Upon activation of this EIP, initialize new variables:", "New Functions": "Design note: This function resets the lookahead generation churn upon switching to the next generation. Ifstate.earliest_exit_epochfalls into the generation earlier than the lookahead, the lookahead generation churn usage is reset. Otherwise, it is marked as fully used.", "Modified Functions": "Replace the existingcompute_exit_epoch_and_update_churnfunction with this simplified MINSLACK-inspired version:", "Rationale": "As we described earlier, by computing unused churn from the previous 14 generations, the churn limit dynamically responds to actual validator behavior. This mechanism:", "Backwards Compatibility": "This EIP requires a hard fork.", "Security Considerations": "Copyright and related rights waived via CC0.", "Copyright": "Copyright and related rights waived via CC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7923, "url": "https://eips.ethereum.org/EIPS/eip-7923", "title": "Linear, Page-Based Memory Costing", "authors": ["Charles Cooper\u00a0(", "@charles-cooper", ")", "Qi Zhou\u00a0(", "@qizhou", ")"], "sections": {"EIP-7923: Linear, Page-Based Memory Costing": "This EIP replaces the quadratic memory model in the EVM with a linear, page-based costing model. Memory is virtually addressable. Page allocation and page thrashing are included in the cost model. After applying this EIP, memory limits are invariant to the state of the message call stack.", "Linearize Memory Costing and replace the current quadratic formula with a page-based cost model.": "This EIP replaces the quadratic memory model in the EVM with a linear, page-based costing model. Memory is virtually addressable. Page allocation and page thrashing are included in the cost model. After applying this EIP, memory limits are invariant to the state of the message call stack.", "Abstract": "This EIP replaces the quadratic memory model in the EVM with a linear, page-based costing model. Memory is virtually addressable. Page allocation and page thrashing are included in the cost model. After applying this EIP, memory limits are invariant to the state of the message call stack.", "Motivation": "The EVM currently uses a quadratic pricing model for its memory. This was originally put in place to defend against DoS attacks. However, the memory model has several drawbacks.", "Specification": "Consider the following constants:", "Rationale": "Benchmarks were performed on a 2019-era CPU, with the ability tokeccak256around 256MB/s, giving it a gas-to-ns ratio of 20 ns per 1 gas (given thatkeccak256costs 6 gas per 32 bytes). The following benchmarks were performed:", "Backwards Compatibility": "Addressed in Security Considerations section. No backwards compatibility is broken, although some contracts that previously ran out of gas may now successfully complete.", "Test Cases": "A ~60-line reference implementation is provided below. It is implemented as a patch against thepy-evmcodebase at commit ethereum/py-evm@fec63b8c4b9dad9fcb1022c48c863bdd584820c6. (This is a reference implementation, it does not, for example, contain fork choice rules).", "Reference Implementation": "A ~60-line reference implementation is provided below. It is implemented as a patch against thepy-evmcodebase at commit ethereum/py-evm@fec63b8c4b9dad9fcb1022c48c863bdd584820c6. (This is a reference implementation, it does not, for example, contain fork choice rules).", "Security Considerations": "There are two primary security considerations regarding this EIP.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 86, "url": "https://eips.ethereum.org/EIPS/eip-86", "title": "Abstraction of transaction origin and signature", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-86: Abstraction of transaction origin and signature": "Implements a set of changes that serve the combined purpose of \u201cabstracting out\u201d signature verification and nonce checking, allowing users to create \u201caccount contracts\u201d that perform any desired signature/nonce checks instead of using the mechanism that is currently hard-coded into transaction processing.", "": "Implements a set of changes that serve the combined purpose of \u201cabstracting out\u201d signature verification and nonce checking, allowing users to create \u201caccount contracts\u201d that perform any desired signature/nonce checks instead of using the mechanism that is currently hard-coded into transaction processing.", "Summary": "Implements a set of changes that serve the combined purpose of \u201cabstracting out\u201d signature verification and nonce checking, allowing users to create \u201caccount contracts\u201d that perform any desired signature/nonce checks instead of using the mechanism that is currently hard-coded into transaction processing.", "Parameters": "Ifblock.number >= METROPOLIS_FORK_BLKNUM, then:", "Specification": "Ifblock.number >= METROPOLIS_FORK_BLKNUM, then:", "Rationale": "The goal of these changes is to set the stage for abstraction of account security. Instead of having an in-protocol mechanism where ECDSA and the default nonce scheme are enshrined as the only \u201cstandard\u201d way to secure an account, we take initial steps toward a model where in the long term all accounts are contracts, contracts can pay for gas, and users are free to define their own security model.", "Miner and transaction replaying strategy": "Note that miners would need to have a strategy for accepting these transactions. This strategy would need to be very discriminating, because otherwise they run the risk of accepting transactions that do not pay them any fees, and possibly even transactions that have no effect (eg. because the transaction was already included and so the nonce is no longer current).", "Copyright": "Copyright and related rights waived via CC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 101, "url": "https://eips.ethereum.org/EIPS/eip-101", "title": "Serenity Currency and Crypto Abstraction", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-101: Serenity Currency and Crypto Abstraction": "Note thatECRECOVER, sequence number/nonce incrementing and ether are now nowhere in the bottom-level spec (NOTE: ether is going to continue to have a privileged role in Casper PoS). To replicate existing functionality under the new model, we do the following.", "": "Note thatECRECOVER, sequence number/nonce incrementing and ether are now nowhere in the bottom-level spec (NOTE: ether is going to continue to have a privileged role in Casper PoS). To replicate existing functionality under the new model, we do the following.", "Specification": "Note thatECRECOVER, sequence number/nonce incrementing and ether are now nowhere in the bottom-level spec (NOTE: ether is going to continue to have a privileged role in Casper PoS). To replicate existing functionality under the new model, we do the following.", "Rationale": "This allows for a large increase in generality, particularly in a few\nareas:", "Implementation": "Coming soon.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 210, "url": "https://eips.ethereum.org/EIPS/eip-210", "title": "Blockhash refactoring", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-210: Blockhash refactoring": "Stores blockhashes in the state, reducing the protocol complexity and the need for client implementation complexity in order to process the BLOCKHASH opcode. Also extends the range of how far back blockhash checking can go, with the side effect of creating direct links between blocks with very distant block numbers, facilitating much more efficient initial light client syncing.", "": "Stores blockhashes in the state, reducing the protocol complexity and the need for client implementation complexity in order to process the BLOCKHASH opcode. Also extends the range of how far back blockhash checking can go, with the side effect of creating direct links between blocks with very distant block numbers, facilitating much more efficient initial light client syncing.", "Summary": "Stores blockhashes in the state, reducing the protocol complexity and the need for client implementation complexity in order to process the BLOCKHASH opcode. Also extends the range of how far back blockhash checking can go, with the side effect of creating direct links between blocks with very distant block numbers, facilitating much more efficient initial light client syncing.", "Parameters": "Ifblock.number == CONSTANTINOPLE_FORK_BLKNUM, then when processing the block, before processing any transactions set the code of BLOCKHASH_CONTRACT_ADDR to BLOCKHASH_CONTRACT_CODE.", "Specification": "Ifblock.number == CONSTANTINOPLE_FORK_BLKNUM, then when processing the block, before processing any transactions set the code of BLOCKHASH_CONTRACT_ADDR to BLOCKHASH_CONTRACT_CODE.", "BLOCKHASH_CONTRACT_CODE": "The Serpent source code is:", "Rationale": "This removes the need for implementations to have an explicit way to look into historical block hashes, simplifying the protocol definition and removing a large component of the \u201cimplied state\u201d (information that is technically state but is not part of the state tree) and thereby making the protocol more \u201cpure\u201d. Additionally, it allows blocks to directly point to blocks far behind them, which enables extremely efficient and secure light client protocols.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 615, "url": "https://eips.ethereum.org/EIPS/eip-615", "title": "Subroutines and Static Jumps for the EVM", "authors": ["Greg Colvin\u00a0<", "greg@colvin.org", ">", "Brooklyn Zelenka\u00a0(", "@expede", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Christian Reitwiessner\u00a0(", "@chriseth", ")"], "sections": {"EIP-615: Subroutines and Static Jumps for the EVM": "In the 21st century, on a blockchain circulating billions of ETH, formal specification and verification are an essential tool against loss. Yet the design of the EVM makes this unnecessarily difficult. Further, the design of the EVM makes near-linear-time compilation to machine code difficult. We propose to move forward with proposals to resolve these problems by tightening EVM security guarantees and reducing barriers to performance.", "": "In the 21st century, on a blockchain circulating billions of ETH, formal specification and verification are an essential tool against loss. Yet the design of the EVM makes this unnecessarily difficult. Further, the design of the EVM makes near-linear-time compilation to machine code difficult. We propose to move forward with proposals to resolve these problems by tightening EVM security guarantees and reducing barriers to performance.", "Simple Summary": "In the 21st century, on a blockchain circulating billions of ETH, formal specification and verification are an essential tool against loss. Yet the design of the EVM makes this unnecessarily difficult. Further, the design of the EVM makes near-linear-time compilation to machine code difficult. We propose to move forward with proposals to resolve these problems by tightening EVM security guarantees and reducing barriers to performance.", "Abstract": "EVM code is currently difficult to statically analyze, hobbling critical tools for preventing the many expensive bugs our blockchain has experienced. Further, none of the current implementations of the Ethereum Virtual Machine\u2014including the compilers\u2014are sufficiently performant to reduce the need for precompiles and otherwise meet the network\u2019s long-term demands.  This proposal identifies dynamic jumps as a major reason for these issues, and proposes changes to the EVM specification to address the problem, making further efforts towards a safer and more performant the EVM possible.", "Motivation": "Currently the EVM supports only dynamic jumps, where the address to jump to is an argument on the stack.  Worse, the EVM fails to provide ordinary, alternative control flow facilities like subroutines and switches provided by Wasm and most CPUs.  So dynamic jumps cannot be avoided, yet they obscure the structure of the code and thus mostly inhibit control- and data-flow analysis.  This puts the quality and speed of optimized compilation fundamentally at odds.  Further, since many jumps can potentially be to any jump destination in the code, the number of possible paths through the code can go up as the product of the number of jumps by the number of destinations, as does the time complexity of static analysis.  Many of these cases are undecidable at deployment time, further inhibiting static and formal analyses.", "Specification": "We propose to deprecate two existing instructions\u2014JUMPandJUMPI\u2014and propose new instructions to support their legitimate uses.  In particular, it must remain possible to compile Solidity and Vyper code to EVM bytecode, with no significant loss of performance or increase in gas price.", "Dependencies": "We propose to deprecate two existing instructions\u2014JUMPandJUMPI\u2014and propose new instructions to support their legitimate uses.  In particular, it must remain possible to compile Solidity and Vyper code to EVM bytecode, with no significant loss of performance or increase in gas price.", "Proposal": "We propose to deprecate two existing instructions\u2014JUMPandJUMPI\u2014and propose new instructions to support their legitimate uses.  In particular, it must remain possible to compile Solidity and Vyper code to EVM bytecode, with no significant loss of performance or increase in gas price.", "Semantics": "Jumps to and returns from subroutines are described here in terms of", "Validity": "We would like to consider EVM code valid iff no execution of the program can lead to an exceptional halting state, but we must validate code in linear time. So our validation does not consider the code\u2019s data and computations, only its control flow and stack use.  This means we will reject programs with invalid code paths, even if those paths are not reachable.  Most conditions can be validated, and will not need to be checked at runtime; the exceptions are sufficient gas and sufficient stack.  As such, static analysis may yield false negatives belonging to well-understood classes of code requiring runtime checks.  Aside from those cases, we can validate large classes at validation time and with linear complexity.", "Backwards Compatibility": "These changes would need to be implemented in phases at decent intervals:", "Rationale": "This design was highly constrained by the existing EVM semantics, the requirement for eWasm compatibility, and the security demands of the Ethereum environment.  It was also informed by the lead author\u2019s previous work implementing Java and Scheme interpreters.  As such there was very little room for alternative designs.", "Implementation": "Implementation of this proposal need not be difficult.  At the least, interpreters can simply be extended with the new opcodes and run unchanged otherwise.  The new opcodes require only stacks for the frame pointers and return offsets and the few pushes, pops, and assignments described above. The bulk of the effort is the validator, which in most languages can almost be transcribed from the pseudocode above.", "Appendix A": "Validation comprises two tasks:", "Validation": "Validation comprises two tasks:", "Appendix B": "There is a large and growing ecosystem of researchers, authors, teachers, auditors, and analytic tools\u2013providing software and services focused on the correctness and security of EVM code.  A small sample is given here.", "EVM Analysis": "There is a large and growing ecosystem of researchers, authors, teachers, auditors, and analytic tools\u2013providing software and services focused on the correctness and security of EVM code.  A small sample is given here.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 616, "url": "https://eips.ethereum.org/EIPS/eip-616", "title": "SIMD Operations for the EVM", "authors": ["Greg Colvin\u00a0<", "greg@colvin.org", ">"], "sections": {"EIP-616: SIMD Operations for the EVM": "A proposal to provide Single Instruction Multiple Data types and operations for the Ethereum Virtual Machine, making full use of the 256-bit wide EVM stack items, and offering substantial performance gains for both vector and scalar operations.", "": "A proposal to provide Single Instruction Multiple Data types and operations for the Ethereum Virtual Machine, making full use of the 256-bit wide EVM stack items, and offering substantial performance gains for both vector and scalar operations.", "ABSTRACT": "A proposal to provide Single Instruction Multiple Data types and operations for the Ethereum Virtual Machine, making full use of the 256-bit wide EVM stack items, and offering substantial performance gains for both vector and scalar operations.", "MOTIVATION": "Most all modern CPUs include SIMD hardware that operates on wide registers of data, applying a Single Instruction to Multiple Data lanes in parallel, where lanes divide a register into a vector of scalar elements of equal size.  This model is an excellent fit for the wide stack items of the EVM, offering substantial performance boosts for operations that can be expressed as parallel operations on vectors of scalars.  For some examples, a brief literature search finds SIMD speedups of", "SPECIFICATION": "We propose a simple encoding of SIMD operations as extended two-byte codes.  The first byte is the opcode, and the second byte is the SIMD type: scalar type, lane width, and number of elements.", "Encoding": "We propose a simple encoding of SIMD operations as extended two-byte codes.  The first byte is the opcode, and the second byte is the SIMD type: scalar type, lane width, and number of elements.", "Semantics": "We define the following extended versions of the EVM\u2019s arithmetic, logic, and comparison operations.  As with the normal versions, they consume their arguments from the stack and place their results on the stack, except that their arguments are vectors rather than scalars.", "Subroutines": "IfEIP-187is accepted a type-safe syntax for declaring subroutines taking vector arguments will be needed.", "RATIONALE": "Currently, the lowest common denominator for SIMD hardware (e.g. Intel SSE2 and ARM Neon) is 16-byte registers supporting integer lanes of 1, 2, 4, and 8 bytes, and floating point lanes of 4 and 8 bytes.  More recent SIMD hardware (e.g. Intel AVX) supports 32-byte registers, and EVM stack items are also 32 bytes wide.  The limits above derive from these numbers, assuring that EVM code is within the bounds of available hardware - and the reserved bits provide room for growth.", "Gas": "One motivation for these operations, besides taking full advantage of the hardware, is assigning lower gas costs for operations on smaller scalars.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 665, "url": "https://eips.ethereum.org/EIPS/eip-665", "title": "Add precompiled contract for Ed25519 signature verification", "authors": ["Tobias Oberstein\u00a0<", "tobias.oberstein@crossbario.com", ">"], "sections": {"EIP-665: Add precompiled contract for Ed25519 signature verification": "Support performant and cheap verification of Ed25519 cryptographic signatures in smart contracts in general by adding a precompiled contract for Ed25519 signature verification to the EVM.", "": "Support performant and cheap verification of Ed25519 cryptographic signatures in smart contracts in general by adding a precompiled contract for Ed25519 signature verification to the EVM.", "Simple Summary": "Support performant and cheap verification of Ed25519 cryptographic signatures in smart contracts in general by adding a precompiled contract for Ed25519 signature verification to the EVM.", "Abstract": "Verification of Ed25519 cryptographic signatures is obviously possible in EVM bytecode. However, the gas cost will be very high, and computationally expensive, as such tight, wide word operations intensive code as required for Ed25519 is not a good fit for the EVM bytecode model.", "Motivation": "Ed25519 and Ed448 (that is, EdDSA using Curve25519 or Curve448) are IETF recommendations (RFC7748) with some attractive properties:", "Specification": "Ifblock.number >= CONSTANTINOPLE_FORK_BLKNUM, add a precompiled contract for Ed25519 signature verification (ED25519VFY).", "Address": "The address ofED25519VFYis0x9.", "Gas costs": "Gas cost forED25519VFYis2000.", "Rationale": "The proposedED25519VFYfunction takes the signer public key as a call parameter, as with Ed25519, I don\u2019t believe it is possible to derive the signers public key from the signature and message alone.", "Backwards Compatibility": "As the proposed precompiled contract is deployed at a reserved (<255) and previously unused address, an implementation of the proposal should not introduce any backward compatibility issues.", "Test Cases": "Test vectors for Ed25519 can be found in this IETF ID https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-6.", "Implementation": "libsodium is a mature, high-quality C implementation of Ed25519, with bindings for many languages.", "libsodium": "libsodium is a mature, high-quality C implementation of Ed25519, with bindings for many languages.", "libsodium bindings": "Here is an overview of the language bindings to libsodium for four Ethereum clients this proposal recommends:", "PRs": "Implementations of this proposal are here:", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 689, "url": "https://eips.ethereum.org/EIPS/eip-689", "title": "Address Collision of Contract Address Causes Exceptional Halt", "authors": ["Yoichi Hirai\u00a0<", "i@yoichihirai.com", ">"], "sections": {"EIP-689: Address Collision of Contract Address Causes Exceptional Halt": "This EIP proposes to make contract creation fail on an account with nonempty code or non-zero nonce.", "": "This EIP proposes to make contract creation fail on an account with nonempty code or non-zero nonce.", "Simple Summary": "This EIP proposes to make contract creation fail on an account with nonempty code or non-zero nonce.", "Abstract": "Some test cases in the consensus test suite try to deploy a contract at an address already with nonempty code. Although such cases can virtually never happen on the main network before the Constantinople fork block, the test cases detected discrepancies in clients\u2019 behavior.  Currently, the Yellow Paper says that the contract creation starts with the empty code and the initial nonce even in the case of address collisions. To simplify the semantics, this EIP proposes that address collisions cause failures of contract creation.", "Motivation": "This EIP has no practical relevance to the main net history, but simplifies testing and reasoning.", "Specification": "Ifblock.number >= 0, when a contract creation is on an account with non-zero nonce or non-empty code, the creation fails as if init code execution resulted in an exceptional halt.  This applies to contract creation triggered by a contract creation transaction and by CREATE instruction.", "Rationale": "It seems impractical to implement never-used features just for passing tests.  Client implementations will be simpler with this EIP.", "Backwards Compatibility": "This EIP is backwards compatible on the main network.", "Test Cases": "At least the BlockchainTest calledcreateJS\\_ExampleContract\\_d0g0v0\\_EIP158will distinguish clients that implement this EIP.", "Implementation": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 698, "url": "https://eips.ethereum.org/EIPS/eip-698", "title": "OPCODE 0x46 BLOCKREWARD", "authors": ["Cody Burns\u00a0<", "dontPanic@codywburns.com", ">"], "sections": {"EIP-698: OPCODE 0x46 BLOCKREWARD": "This EIP adds an additional opcode to the EVM which will return a finalized blocks reward value.", "": "This EIP adds an additional opcode to the EVM which will return a finalized blocks reward value.", "Simple Summary": "This EIP adds an additional opcode to the EVM which will return a finalized blocks reward value.", "Abstract": "In the EVM, the 0x40 opcodes are reserved forBlock Information. Currently reserved opcodes are:", "Motivation": "Per EIP-649 ( #669 ) periodic block reward reductions/variance are now planned in the roadmap, however, this EIP is consensus system agnostic and is most useful in decentralized pool operations and for any contract that benefits from knowing a block reward payout(i.e. Merge mined tokens)", "Specification": "After blocknall clients should process opcode0x46as follows:", "Rationale": "For distributed consensus systems(staking pools and mining pools) ad hoc groups combine resources in order to reduce variance in payouts. Broadly, pool operations function by allowing a collective of  miners / stakers  to verify their contribution to solving PoW or staking share by periodically submitting solutions which are representative of the miners probability of finding a true block.", "Contract Mining Pools": "For distributed consensus systems(staking pools and mining pools) ad hoc groups combine resources in order to reduce variance in payouts. Broadly, pool operations function by allowing a collective of  miners / stakers  to verify their contribution to solving PoW or staking share by periodically submitting solutions which are representative of the miners probability of finding a true block.", "Merge mined tokens": "Contracts could create tokens which could be variably \u2018minted\u2019 as a function of block reward by calling0x46", "Backwards Compatibility": "No impact", "Currently deployed contracts": "No impact", "Current clients": "This EIP would be incompatible with currently deployed clients that are not able to handle0x46and would process all transactions and block containing the opcode as invalid.", "Implementation": "Mining Pools", "Further reading": "Mining Pools", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 858, "url": "https://eips.ethereum.org/EIPS/eip-858", "title": "Reduce block reward and delay difficulty bomb", "authors": ["Carl Larson\u00a0<", "cslarson@gmail.com", ">"], "sections": {"EIP-858: Reduce block reward and delay difficulty bomb": "Reduce the block reward to 1 ETH and delay the difficulty bomb.", "": "Reduce the block reward to 1 ETH and delay the difficulty bomb.", "Simple Summary": "Reduce the block reward to 1 ETH and delay the difficulty bomb.", "Abstract": "The current public Ethereum network has a hashrate that corresponds to a tremendous level of energy consumption. As this energy consumption has a correlated environmental cost the network participants have an ethical obligation to ensure this cost is not higher than necessary. At this time, the most direct way to reduce this cost is to lower the block reward in order to limit the appeal of ETH mining. Unchecked growth in hashrate is also counterproductive from a security standpoint.\nRecent research developments also now time the switch to POS as sometime in 2019 and as a result there is need to further delay the difficulty bomb so the network doesn\u2019t grind to a halt.", "Motivation": "The current public Ethereum network has a hashrate of 296 TH/s. This hashrate corresponds to a power usage of roughly1 TWand yearly energy consumption of 8.8 TWh (roughly 0.04% oftotalglobal electricity consumption). A future switch to full Proof of Stake will solve this issue entirely. Yet that switch remains enough in the future that action should be taken in the interim to limit excess harmful side affects of the present network.", "Specification": "Delay difficulty bomb by 2,000,000 blocks\nAdjust block, uncle, and nephew rewards to reflect a new block reward of 1 ETH.", "Rationale": "This will delay the difficulty bomb by roughly a year. The difficulty bomb remains a community supported mechanism to aid a future transition to POS.", "Backwards Compatibility": "This EIP is consensus incompatible with the current public Ethereum chain and would cause a hard fork when enacted. The resulting fork would allow users to chose between two chains: a chain with a block reward of 1 ETH/block and another with a block reward of 3 ETH/block. This is a good choice to allow users to make. In addition, the difficulty bomb would be delayed - ensuring the network would not grind to a halt.", "Test Cases": "Tests have, as yet, not been completed.", "Implementation": "No implementation including both block reward and difficulty adjustment is currently available.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 969, "url": "https://eips.ethereum.org/EIPS/eip-969", "title": "Modifications to ethash to invalidate existing dedicated hardware implementations", "authors": ["David Stanfill\u00a0<", "david@airsquirrels.com", ">"], "sections": {"EIP-969: Modifications to ethash to invalidate existing dedicated hardware implementations": "This EIP modifies ethash in order to break ASIC miners specialized for the current ethash\nmining algorithm.", "": "This EIP modifies ethash in order to break ASIC miners specialized for the current ethash\nmining algorithm.", "Simple Summary": "This EIP modifies ethash in order to break ASIC miners specialized for the current ethash\nmining algorithm.", "Abstract": "There are companies who currently have dedicated hardware based ethereum miners in\nproduction, and may be actively mining.  This EIP aims to \u201cpoison\nthe well\u201d by modifying the block mining algorithm in a low risk manner that\nmay\u201cbreak\u201dthese miners if they are in-fact built as traditional ASICs.", "Motivation": "ASIC-based miners will have lower operational costs than GPU-based miners, which\nwill result in GPU-based mining quickly becoming unprofitable.  Given that\nproduction of ASIC-based miners has a high barrier to entry and few market players,\nthis will cause a trend towards centralization of mining power.", "Specification": "Ifblock.number >= ASIC_MITIGATION_FORK_BLKNUM, require that the ethash solution\nsealing the block has been mined usingethashV2.", "EthashV2": "ethashV2will be identical in specification to the currentethash(v1) algorithm, with\nthe exception of the implementation offnv.", "Agent Changes (Optional Variant)": "The JSON-RPCeth_GetWorkcall may optionally return the proposed blocks algorithm.\nWhile a miner or pool may infer the requirement forethashV2based on the computed\nepoch of the provided seedHash, it is beneficial to explicitly provide this\nfield so a miner does not require special configuration when mining on a chain\nthat chooses not to implement theASIC_Mitigationhardfork.", "Rationale": "This EIP is aimed at breaking existing ASIC-based miners via small changes to the\nexisting ethash algorithm.  We hope to accomplish the following:", "Backwards Compatibility": "This change implements a backwards incompatible change to proof of work based\nblock mining.  All existing miners will be required to update to clients which\nimplement this new algorithm, and all nodes will require updates to accept\nsolutions from the new proof of work algorithm.", "Test Cases": "TODO: will need to generate test cases forethereum/testsrepository corresponding to the consensus\nchanges.", "Implementation": "TODO", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1010, "url": "https://eips.ethereum.org/EIPS/eip-1010", "title": "Uniformity Between 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B and 0x15E55EF43efA8348dDaeAa455F16C43B64917e3c", "authors": ["Anderson Wesley\u00a0(", "@andywesley", ")"], "sections": {"EIP-1010: Uniformity Between 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B and 0x15E55EF43efA8348dDaeAa455F16C43B64917e3c": "This document proposes to improve the uniformity of ether distribution\nbetween wallet address0xAb5801a7D398351b8bE11C439e05C5B3259aeC9Band\nwallet address0x15E55EF43efA8348dDaeAa455F16C43B64917e3cwhich are\ncurrently experiencing a significant non-uniformity.", "": "This document proposes to improve the uniformity of ether distribution\nbetween wallet address0xAb5801a7D398351b8bE11C439e05C5B3259aeC9Band\nwallet address0x15E55EF43efA8348dDaeAa455F16C43B64917e3cwhich are\ncurrently experiencing a significant non-uniformity.", "Simple Summary": "This document proposes to improve the uniformity of ether distribution\nbetween wallet address0xAb5801a7D398351b8bE11C439e05C5B3259aeC9Band\nwallet address0x15E55EF43efA8348dDaeAa455F16C43B64917e3cwhich are\ncurrently experiencing a significant non-uniformity.", "Abstract": "As of the date of this EIP, the difference in balance between\naddress0xAb5801a7D398351b8bE11C439e05C5B3259aeC9Band address0x15E55EF43efA8348dDaeAa455F16C43B64917e3cis far from equitable\nor uniform, with the former having more than 365,000 ether\nmore than the latter. The distribution of ether between these two\naddresses must be improved in order to protect the Ethereum economy\nfrom centralized control. This will be accomplished by transferring\n100,000 ether from the former address to the latter. This is a properly\nmotivated improvement in keeping with the core Ethereum philosophy of\ndecentralization.", "Motivation": "This proposal is necessary because the Ethereum protocol does not allow\nthe owner of an address which does not own an equitable amount of ether\nto claim their share of ether from an address which owns a dangerously\ncentralized quantity. Rather than proposing an overly complicated generic\nmechanism for any user to claim ether to which they believe they are\nequitably entitled, this proposal will take the simple route of a one-time\ntransfer of 100,000 ether from0xAb5801a7D398351b8bE11C439e05C5B3259aeC9Bto0x15E55EF43efA8348dDaeAa455F16C43B64917e3c. This avoids duplicating\nthe effort of other proposals and provides a net improvement to the\nEthereum project and community.", "Specification": "The balance of0xAb5801a7D398351b8bE11C439e05C5B3259aeC9Bwill be decreased\nby 100,000 ether. The balance of0x15E55EF43efA8348dDaeAa455F16C43B64917e3cwill be increased by 100,000 ether. No net change in the amount of extant\nether will occur unless at the time of implementation the former address does not\ncontain sufficient ether for such a deduction.", "Rationale": "The value 100,000 was chosen after careful technically sound analysis of various economic theories\ndeveloped over the past century. In spite of the fact that it is a convenient round\nnumber, it is actually the exact output of a complex statistical process iterated to\ndetermine the optimal distribution of ether between these addresses.", "Backwards Compatibility": "Clients that fail to implement this change will not be aware of the correct balances\nfor these addresses. This will create a hard fork. The implementation of this change\nconsistently among all clients as intended by the proposal process will be sufficient\nto ensure that backwards compatibility is not a concern.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1011, "url": "https://eips.ethereum.org/EIPS/eip-1011", "title": "Hybrid Casper FFG", "authors": ["Danny Ryan\u00a0(", "@djrtwo", ")", "Chih-Cheng Liang\u00a0(", "@ChihChengLiang", ")"], "sections": {"EIP-1011: Hybrid Casper FFG": "Specification of the first step to transition Ethereum main net from Proof of Work (PoW) to Proof of Stake (PoS). The resulting consensus model is a PoW/PoS hybrid.", "": "Specification of the first step to transition Ethereum main net from Proof of Work (PoW) to Proof of Stake (PoS). The resulting consensus model is a PoW/PoS hybrid.", "Simple Summary": "Specification of the first step to transition Ethereum main net from Proof of Work (PoW) to Proof of Stake (PoS). The resulting consensus model is a PoW/PoS hybrid.", "Abstract": "This EIP specifies a hybrid PoW/PoS consensus model for Ethereum main net. Existing PoW mechanics are used for new block creation, and a novel PoS mechanism called Casper the Friendly Finality Gadget (FFG) is layered on top using a smart contract.", "Glossary": "Transitioning the Ethereum network from PoW to PoS has been on the roadmap and in theYellow Papersince the launch of the protocol. Although effective in coming to a decentralized consensus, PoW consumes an incredible amount of energy, has no economic finality, and has no effective strategy in resisting cartels. Excessive energy consumption, issues with equal access to mining hardware, mining pool centralization, and an emerging market of ASICs each provide a distinct motivation to make the transition as soon as possible.", "Motivation": "Transitioning the Ethereum network from PoW to PoS has been on the roadmap and in theYellow Papersince the launch of the protocol. Although effective in coming to a decentralized consensus, PoW consumes an incredible amount of energy, has no economic finality, and has no effective strategy in resisting cartels. Excessive energy consumption, issues with equal access to mining hardware, mining pool centralization, and an emerging market of ASICs each provide a distinct motivation to make the transition as soon as possible.", "Parameters": "Ifblock.number == HYBRID_CASPER_FORK_BLKNUM, then when processing the block before processing any transactions:", "Casper Contract Parameters": "Ifblock.number == HYBRID_CASPER_FORK_BLKNUM, then when processing the block before processing any transactions:", "Specification": "Ifblock.number == HYBRID_CASPER_FORK_BLKNUM, then when processing the block before processing any transactions:", "Rationale": "Naive PoS specifications and implementations have existed since early blockchain days, but most are vulnerable to serious attacks and do not hold up under crypto-economic analysis. Casper FFG solves problems such as \u201cNothing at Stake\u201d and \u201cLong Range Attacks\u201d through requiring validators to post slashable deposits and through defining economic finality.", "Backwards Compatibility": "This EIP is not forward compatible and introduces backwards incompatibilities in the state, fork choice rule, block reward, transaction validity, and gas calculations on certain transactions. Therefore, all changes should be included in a scheduled hardfork atHYBRID_CASPER_FORK_BLKNUM.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1015, "url": "https://eips.ethereum.org/EIPS/eip-1015", "title": "Configurable On Chain Issuance", "authors": ["Alex Van de Sande\u00a0<", "avsa@ethereum.org", ">"], "sections": {"EIP-1015: Configurable On Chain Issuance": "This EIP changes the block reward step by instead of setting it to be hard coded on the clients and to be given to the miner/validator etherbase, it should instead go to an address decided by an on-chain contract, with hard limits on how it would be issued (six month lock-in; issuance can only decrease or be maintained, but not increase;). A decision method is suggested but not essential to the notion of this EIP. This wouldnot be a generic governance solution, which is a much broader and harder topic, wouldnotaffect technical upgrade decisions or other hard forks, but seen asa forum to attempt to prevent contentious hard forksthat can be solved with the issuance.", "": "This EIP changes the block reward step by instead of setting it to be hard coded on the clients and to be given to the miner/validator etherbase, it should instead go to an address decided by an on-chain contract, with hard limits on how it would be issued (six month lock-in; issuance can only decrease or be maintained, but not increase;). A decision method is suggested but not essential to the notion of this EIP. This wouldnot be a generic governance solution, which is a much broader and harder topic, wouldnotaffect technical upgrade decisions or other hard forks, but seen asa forum to attempt to prevent contentious hard forksthat can be solved with the issuance.", "Simple Summary": "This EIP changes the block reward step by instead of setting it to be hard coded on the clients and to be given to the miner/validator etherbase, it should instead go to an address decided by an on-chain contract, with hard limits on how it would be issued (six month lock-in; issuance can only decrease or be maintained, but not increase;). A decision method is suggested but not essential to the notion of this EIP. This wouldnot be a generic governance solution, which is a much broader and harder topic, wouldnotaffect technical upgrade decisions or other hard forks, but seen asa forum to attempt to prevent contentious hard forksthat can be solved with the issuance.", "Summary": "These are current EIPs that are being developed or debated. They might seem unrelated but they have something in common, that they can be resolved by proper channel of funds.", "Thesis: many controversial issues boil down to resources": "These are current EIPs that are being developed or debated. They might seem unrelated but they have something in common, that they can be resolved by proper channel of funds.", "Proposed Solution": "This EIP proposes a future hard fork where block reward is not issued to miners/validators etherbase, but instead to a single contract, that then will activate the default function (with a fixed amount of gas) and then it will forward the ether to other contracts which will finally distribute to their final destinations.", "Issuance Contract": "This EIP proposes a future hard fork where block reward is not issued to miners/validators etherbase, but instead to a single contract, that then will activate the default function (with a fixed amount of gas) and then it will forward the ether to other contracts which will finally distribute to their final destinations.", "Questions to be debated": "A lot of things are suggested in this EIP, so I would like to propose these questions to be debated:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1051, "url": "https://eips.ethereum.org/EIPS/eip-1051", "title": "Overflow checking for the EVM", "authors": ["Nick Johnson\u00a0<", "arachnid@notdot.net", ">"], "sections": {"EIP-1051: Overflow checking for the EVM": "This EIP adds overflow checking for EVM arithmetic operations, and two new opcodes that check and clear the overflow flags.", "": "This EIP adds overflow checking for EVM arithmetic operations, and two new opcodes that check and clear the overflow flags.", "Abstract": "This EIP adds overflow checking for EVM arithmetic operations, and two new opcodes that check and clear the overflow flags.", "Motivation": "The correct functioning of many contracts today is dependent on detecting and preventing overflow of arithmetic operations. Since the EVM operates on mod 2^256 integers and provides no built-in overflow detection or prevention, this requires manual checks on every arithmetic operation.", "Specification": "Two new flags are added to the EVM state: overflow (ovf) and signed overflow (sovf).", "Rationale": "Any change to implement overflow protection needs to preserve behaviour of existing contracts, which precludes many changes to the arithmetic operations themselves. One option would be to provide an opcode that enables overflow protection, causing a throw or revert if an overflow happens. However, this limits the manner in which overflows can be handled.", "Backwards Compatibility": "This EIP introduces no backwards compatibility issues.", "Test Cases": "TBD", "Implementation": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1057, "url": "https://eips.ethereum.org/EIPS/eip-1057", "title": "ProgPoW, a Programmatic Proof-of-Work", "authors": ["Greg Colvin\u00a0<", "greg@colvin.org", ">", "Andrea Lanfranchi\u00a0(", "@AndreaLanfranchi", ")", "Michael Carter\u00a0(", "@bitsbetrippin", ")", "IfDefElse\u00a0<", "ifdefelse@protonmail.com", ">"], "sections": {"EIP-1057: ProgPoW, a Programmatic Proof-of-Work": "A new Proof-of-Work algorithm to replace Ethash that utilizes almost all parts of commodity GPUs.", "": "A new Proof-of-Work algorithm to replace Ethash that utilizes almost all parts of commodity GPUs.", "Simple Summary": "A new Proof-of-Work algorithm to replace Ethash that utilizes almost all parts of commodity GPUs.", "Abstract": "ProgPoW is a proof-of-work algorithm designed to close the efficiency gap available to specialized ASICs. It utilizes almost all parts of commodity hardware (GPUs), and comes pre-tuned for the most common hardware utilized in the Ethereum network.", "Motivation": "Ever since the first bitcoin mining ASIC was released, many new Proof of Work algorithms have been created with the intention of being \u201cASIC-resistant\u201d. The goal of \u201cASIC-resistance\u201d is to resist the centralization of PoW mining power such that these coins couldn\u2019t be so easily manipulated by a few players.", "ProgPoW Overview": "The design goal of ProgPoW is to have the algorithm\u2019s requirements match what is available on commodity GPUs:  If the algorithm were to be implemented on a custom ASIC there should be little opportunity for efficiency gains compared to a commodity GPU.", "Rationale for PoW on Commodity Hardware": "With the growth of large mining pools, the control of hashing power has been delegated to the top few pools to provide a steadier economic return for small miners. While some have made the argument that large centralized pools defeats the purpose of \u201cASIC resistance,\u201d it\u2019s important to note that ASIC based coins are even more centralized for several reasons.", "Review of Existing PoW Algorithms": "The SHA algorithm is a sequence of simple math operations - additions, logical ops, and rotates.", "Specification": "ProgPoW can be tuned using the following parameters.  The proposed settings have been tuned for a range of existing, commodity GPUs:", "Security Considerations": "This proposal has been software and hardware audited:", "Test Cases": "The random sequence generated for block 30,000 (prog_seed 3,000) can been seen inkernel.cu.", "Implementation": "The reference ProgPoW mining implementation is located atthe @ifdefelse ProgPOW repository.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1087, "url": "https://eips.ethereum.org/EIPS/eip-1087", "title": "Net gas metering for SSTORE operations", "authors": ["Nick Johnson\u00a0(", "@arachnid", ")"], "sections": {"EIP-1087: Net gas metering for SSTORE operations": "This EIP proposes a change to how gas is charged for EVMSSTOREoperations, in order to reduce excessive gas costs in situations where these are unwarranted, and to enable new use-cases for contract storage.", "": "This EIP proposes a change to how gas is charged for EVMSSTOREoperations, in order to reduce excessive gas costs in situations where these are unwarranted, and to enable new use-cases for contract storage.", "Abstract": "This EIP proposes a change to how gas is charged for EVMSSTOREoperations, in order to reduce excessive gas costs in situations where these are unwarranted, and to enable new use-cases for contract storage.", "Motivation": "Presently,SSTORE(0x55) operations are charged as follows:", "Specification": "The following changes are made to the EVM:", "Rationale": "We believe the proposed mechanism represents the simplest way to reduce storage gas costs in situations where they do not reflect the actual costs borne by nodes. Several alternative designs were considered and dismissed:", "Backwards Compatibility": "This EIP requires a hard fork to implement.", "Test Cases": "TBD", "Implementation": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1109, "url": "https://eips.ethereum.org/EIPS/eip-1109", "title": "PRECOMPILEDCALL opcode (Remove CALL costs for precompiled contracts)", "authors": ["Jordi Baylina\u00a0(", "@jbaylina", ")"], "sections": {"EIP-1109: PRECOMPILEDCALL opcode (Remove CALL costs for precompiled contracts)": "This EIP creates a specific opcode namedPRECOMPILEDCALLto call Precompiled contracts without the costs of a normalCALL.", "": "This EIP creates a specific opcode namedPRECOMPILEDCALLto call Precompiled contracts without the costs of a normalCALL.", "Simple Summary": "This EIP creates a specific opcode namedPRECOMPILEDCALLto call Precompiled contracts without the costs of a normalCALL.", "Abstract": "This EIP tries to resolve the problem of high gas consumption when calling precompiled contracts with a small gas cost. Using this opcode for calling precompiled contracts allows to define precompiled contracts whose effective cost it is less than 700.", "Motivation": "Each precompiled contract has an already defined cost for calling it. It does not make sense to add the implicit extra gas cost of the CALL opcode.", "Specification": "Ifblock.number >= XXXXX, define a new opcode namedPRECOMPILEDCALLwith code value0xfb.", "Rationale": "There was a first proposal for removing the gast consts for theCALL, but it looks that it\u2019s easier to implement and test a new opcode just for that.", "Backwards Compatibility": "This EIP is backwards compatible.  Smart contracts that call precompiled contracts using this new opcode will cost less from now on.", "Test Cases": "Not implemented yet.", "Implementation": "Not implemented yet.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1227, "url": "https://eips.ethereum.org/EIPS/eip-1227", "title": "Defuse Difficulty Bomb and Reset Block Reward", "authors": ["SmeargleUsedFly\u00a0(", "@SmeargleUsedFly", ")"], "sections": {"EIP-1227: Defuse Difficulty Bomb and Reset Block Reward": "This EIP proposes to permanently disable the \u201cdifficulty bomb\u201d and reset the block reward to pre-Byzantium levels.", "": "This EIP proposes to permanently disable the \u201cdifficulty bomb\u201d and reset the block reward to pre-Byzantium levels.", "Simple Summary": "This EIP proposes to permanently disable the \u201cdifficulty bomb\u201d and reset the block reward to pre-Byzantium levels.", "Abstract": "Starting withFORK_BLKNUMthe client will calculate the difficulty without the additional exponential component. Furthermore, block rewards will be adjusted to a base of 5 ETH, uncle and nephew rewards will be adjusted accordingly.", "Motivation": "Due to the \u201cdifficulty bomb\u201d (also known as the \u201cice age\u201d), introduced in EIP#2, an artificial exponential increase in difficulty until chain freeze, users may find it much more challenging to remain on the unforked chain after a hard-fork. This is a desirable effect of the ice age (in fact, its only stated purpose) in the case of a scheduled network upgrade, but is especially problematic when a hard-fork includes a controversial change.", "Specification": "For the purposes ofcalc_difficulty, simply remove the exponential difficulty adjustment component,epsilon, i.e. theint(2**((block.number // 100000) - 2)).", "Rationale": "This will permanently, without further changes, disable the \u201cice age.\u201d It will also reset the block reward to pre-Byzantium levels. Both of these changes are specified similarly to EIP#649, so they should require only minimal changes from client developers.", "Backwards Compatibility": "This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation, as well as the block, uncle and nephew reward structure. However, it may be controversial in nature among different sections of the userbase\u2014the very problem this EIP is made to address. Therefore, it should not be included in a scheduled hardfork at a certain block number. It is suggested to implement this EIP in an isolated hard-fork before the second of the two Metropolis hard-forks.", "Test Cases": "Forthcoming.", "Implementation": "Forthcoming.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1276, "url": "https://eips.ethereum.org/EIPS/eip-1276", "title": "Eliminate Difficulty Bomb and Adjust Block Reward on Constantinople Shift", "authors": ["EOS Classic\u00a0(", "@eosclassicteam", ")"], "sections": {"EIP-1276: Eliminate Difficulty Bomb and Adjust Block Reward on Constantinople Shift": "The average block times are increasing due to the factor of difficulty logic well known as difficulty bomb. This EIP proposes to eliminate the difficulty bomb forever and to reduce the block rewards with the Constantinople fork, the second part of the Metropolis fork.", "": "The average block times are increasing due to the factor of difficulty logic well known as difficulty bomb. This EIP proposes to eliminate the difficulty bomb forever and to reduce the block rewards with the Constantinople fork, the second part of the Metropolis fork.", "Simple Summary": "The average block times are increasing due to the factor of difficulty logic well known as difficulty bomb. This EIP proposes to eliminate the difficulty bomb forever and to reduce the block rewards with the Constantinople fork, the second part of the Metropolis fork.", "Abstract": "Starting withCNSTNTNPL_FORK_BLKNUMthe client will calculate the difficulty without considering the current block number. Furthermore, block rewards will be adjusted to a base of 2 ETH, uncle and nephew rewards will be adjusted accordingly.", "Motivation": "Block time has been played a most important role on blockchain ecosystem, and it is being adjusted by the logic of mining difficulty calculation that is already implemented on the node client as a part of proof-of-work consensus. Last year, average block time rapidly increased due to the wrong design of difficulty logic that is meant to be changed on the part of Casper upgrade, however, implementation of casper has been delayed therefore it was inevitable to delay the difficulty bomb in order to prevent the significant delay of processing transactions on ethereum network.", "Specification": "For the purposes ofcalc_difficulty, simply remove the exponential difficulty adjustment component,epsilon, i.e. theint(2**((block.number // 100000) - 2)).", "Rationale": "This will completely remove the difficulty bomb on difficulty adjustment algorithm without delaying the difficulty bomb again, therefore it is possible to prevent network delay on the beginning of 2019.", "Backwards Compatibility": "This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation, as well as the block, uncle and nephew reward structure. Therefore, it should be included in a scheduled hardfork at a certain block number. It\u2019s suggested to include this EIP in the second Metropolis hard-fork,Constantinople.", "Test Cases": "Test cases shall be created once the specification is to be accepted by the developers or implemented by the clients.", "Implementation": "The implementation shall be created once the specification is to be accepted by the developers or implemented by the clients.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1285, "url": "https://eips.ethereum.org/EIPS/eip-1285", "title": "Increase Gcallstipend gas in the CALL opcode", "authors": ["Ben Kaufman\u00a0<", "ben@daostack.io", ">", "Adam Levi\u00a0<", "adam@daostack.io", ">"], "sections": {"EIP-1285: Increase Gcallstipend gas in the CALL opcode": "Increase theGcallstipendfee parameter in theCALLopcode from2,300to3,500gas units.", "": "Increase theGcallstipendfee parameter in theCALLopcode from2,300to3,500gas units.", "Simple Summary": "Increase theGcallstipendfee parameter in theCALLopcode from2,300to3,500gas units.", "Abstract": "Currently, theCALLopcode forwards a stipend of2,300gas units for a non zero valueCALLoperations where a contract is called. This stipend is given to the contract to allow execution of itsfallbackfunction. The stipend given is intentionally small in order to prevent the called contract from spending the call gas or performing an attack (like re-entrancy).\nWhile the stipend is small it should still give the sufficient gas required for some cheap opcodes likeLOG, but it\u2019s not enough for some more complex and modern logics to be implemented.\nThis EIP proposes to increase the given stipend from2,300to3,500to increase the usability of  thefallbackfunction.", "Motivation": "The main motivation behind this EIP is to allow simple fallback functions to be implemented for contracts following the\"Proxy\"pattern. Simply explained, a\"Proxy Contract\"is a contract which useDELEGATECALLin itsfallbackfunction to behave according to the logic of another contract and serve as an independent instance for the logic of the contract it points to.\nThis pattern is very useful for saving gas per deployment (as Proxy contracts are very lean) and it opens the ability to experiment with upgradability of contracts.\nOn average, theDELEGATECALLfunctionality of a proxy contract costs about1,000gas units.\nWhen a contract transfers ETH to a proxy contract, the proxy logic will consume about1,000gas units before thefallbackfunction of the logic contract will be executed. This leaves merely about 1,300 gas units for the execution of the logic. This is a severe limitation as it is not enough for an averageLOGoperation (it might be enough for aLOGwith one parameter).\nBy slightly increasing the gas units given in the stipend we allow proxy contracts have properfallbacklogic without increasing the attack surface of the calling contract.", "Specification": "Increase theGcallstipendfee parameter in theCALLopcode from2,300to3,500gas unit.\nThe actual change to the Ethereum clients would be to change theCallStipendthey store as a constant.\nFor an implementation example you can find a Geth client implementation linkedhere. The actual change to the code can be foundhere.", "Rationale": "The rational for increasing theGcallstipendgas parameter by1,200gas units comes from the cost of performingDELEGATECALLandSLOADwith a small margin for some small additional operations. All while still keeping the stipend relatively small and insufficient for accessing the storage or changing the state.", "Backwards Compatibility": "This EIP requires a backwards incompatible change for theGcallstipendgas parameter in theCALLopcode.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1295, "url": "https://eips.ethereum.org/EIPS/eip-1295", "title": "Modify Ethereum PoW Incentive Structure and Delay Difficulty Bomb", "authors": ["Brian Venturo\u00a0(", "@atlanticcrypto", ")"], "sections": {"EIP-1295: Modify Ethereum PoW Incentive Structure and Delay Difficulty Bomb": "Network security and overall ecosystem maturity warrants the continued incentivization of Proof of Work participation but may allow for a reduction in ancillary ETH issuance and the delay of the Difficulty Bomb. This EIP proposes a reduction of Uncle and removal of Nephew rewards while delaying the Difficulty Bomb with the Constantinople hard fork.", "": "Network security and overall ecosystem maturity warrants the continued incentivization of Proof of Work participation but may allow for a reduction in ancillary ETH issuance and the delay of the Difficulty Bomb. This EIP proposes a reduction of Uncle and removal of Nephew rewards while delaying the Difficulty Bomb with the Constantinople hard fork.", "Simple Summary": "Network security and overall ecosystem maturity warrants the continued incentivization of Proof of Work participation but may allow for a reduction in ancillary ETH issuance and the delay of the Difficulty Bomb. This EIP proposes a reduction of Uncle and removal of Nephew rewards while delaying the Difficulty Bomb with the Constantinople hard fork.", "Abstract": "Starting with CNSTNTNPL_FORK_BLKNUM the client will calculate the difficulty based on a fake block number suggesting the client that the difficulty bomb is adjusting around 6 million blocks later than previously specified with the Homestead fork.", "Motivation": "Network scalability and security are at the forefront of risks to the Ethereum protocol. With great strides being made towards on and off chain scalability, the existence of an artificial throughput limiting device in the protocol is not warranted. Removing the risk of reducing throughput through the initialization of the Difficulty Bomb is \u201clow-hanging-fruit\u201d to ensure continued operation at a minimum of current throughput through the next major hard fork (scheduled for late 2019).", "Specification": "For the purposes ofcalc_difficulty, simply replace the use ofblock.number, as used in the exponential ice age component, with the formula:", "Rationale": "The security layer of the Ethereum network is and should remain robust. Incentives for continued operation of the growing ecosystem\u2019s security are paramount.", "Backwards Compatibility": "This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation, as well as the block, uncle and nephew reward structure. Therefore, it should be included in a scheduled hardfork at a certain block number. It\u2019s suggested to include this EIP in the second Metropolis hard-fork, Constantinople.", "Test Cases": "Test cases shall be created once the specification is to be accepted by the developers or implemented by the clients.", "Implementation": "Forthcoming.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1352, "url": "https://eips.ethereum.org/EIPS/eip-1352", "title": "Specify restricted address range for precompiles/system contracts", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-1352: Specify restricted address range for precompiles/system contracts": "Specify an Ethereum address range occupied by precompiles and future system contracts. Regular accounts and contracts cannot obtain such an address.", "": "Specify an Ethereum address range occupied by precompiles and future system contracts. Regular accounts and contracts cannot obtain such an address.", "Simple Summary": "Specify an Ethereum address range occupied by precompiles and future system contracts. Regular accounts and contracts cannot obtain such an address.", "Abstract": "The address range between 0x0000000000000000000000000000000000000000 and 0x000000000000000000000000000000000000ffff is reserved for precompiles and system contracts.", "Motivation": "This will simplify certain future features where unless this is implemented, several exceptions must be specified.", "Specification": "The address range between 0x0000000000000000000000000000000000000000 and 0x000000000000000000000000000000000000ffff is reserved for precompiles and system contracts.", "Rationale": "N/A", "Backwards Compatibility": "No contracts on the main network have been created at the specified addresses. As a result it should pose no backwards compatibility problems.", "Test Cases": "N/A", "Implementation": "N/A", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1380, "url": "https://eips.ethereum.org/EIPS/eip-1380", "title": "Reduced gas cost for call to self", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Jacques Wagener\u00a0(", "@jacqueswww", ")"], "sections": {"EIP-1380: Reduced gas cost for call to self": "Reduce the gas cost for call instructions, when the goal is to run a new instance of the currently loaded contract.", "": "Reduce the gas cost for call instructions, when the goal is to run a new instance of the currently loaded contract.", "Abstract": "Reduce the gas cost for call instructions, when the goal is to run a new instance of the currently loaded contract.", "Motivation": "The current gas cost of 700 for all call types (CALL,DELEGATECALL,CALLCODEandSTATICCALL) does not take into account that a call to a contract itself\ndoes not need to perform additional I/O operations, because the current contract code has already been loaded into memory.", "Specification": "Ifblock.number >= FORK_BLKNUM, then decrease the cost ofCALL,DELEGATECALL,CALLCODEandSTATICCALLfrom 700 to 40,\nif and only if, the destination address of the call equals to the address of the caller.", "Rationale": "EIP150 has increased the cost of these instructions from 40 to 700 to more fairly charge for loading new contracts from disk, e.g. to reflect the I/O charge more closely.\nBy assuming that 660 is the cost of loading a contract from disk, one can assume that the original 40 gas is a fair cost of creating a new VM instance of an already loaded contract code.", "Backwards Compatibility": "This should pose no risk to backwards compatibility. Currently existing contracts should not notice the difference, just see cheaper execution.\nWith EIP150 contract (and language) developers had a lesson that relying on strict gas costs is not feasible as costs may change.\nThe impact of this EIP is even less that of EIP150 because the costs are changing downwards and not upwards.", "Test Cases": "TBA", "Implementation": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1418, "url": "https://eips.ethereum.org/EIPS/eip-1418", "title": "Blockchain Storage Rent Payment", "authors": ["William Entriken\u00a0(", "@fulldecent", ")"], "sections": {"EIP-1418: Blockchain Storage Rent Payment": "At each block, deduct an amount of value (\u201crent\u201d) from every account based on the quantity of storage used by that account.", "At each block, deduct value from every account based on the quantity of storage used by that account.": "At each block, deduct an amount of value (\u201crent\u201d) from every account based on the quantity of storage used by that account.", "Abstract": "At each block, deduct an amount of value (\u201crent\u201d) from every account based on the quantity of storage used by that account.", "Motivation": "Ethereum is a public utility and we are underpricing the long-term costs of storage. Storage cost can be approximately modeled as bytes \u00d7 time.", "Specification": "Updated transaction type", "Rationale": "No call", "Economics & constants": "AnSSTOREexecuted in 2015 cost 20,000 gas and has survived about 6 million blocks. The gas price has been around 1 ~ 50 Gwei. So basically 4,000 Wei per block per word so far. Maybe storing an account is 10 times more intensive than storing a word. But actuallyG_transactionis 21,000 andG_sstoreis 20,000 so these are similar and they can both create new accounts / words.", "Backwards Compatibility": "EIP-1559 already introduces a mechanism for nodes to participate without recording the full network state and for clients to warm cache with storage data in their type 2 transactions.", "Security Considerations": "Many smart contracts allow anybody to use an arbitrary amount of storage in them.", "Copyright": "Copyright and related rights waived via CC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1482, "url": "https://eips.ethereum.org/EIPS/eip-1482", "title": "Define a maximum block timestamp drift", "authors": ["Maurelian\u00a0(", "@Maurelian", ")"], "sections": {"EIP-1482: Define a maximum block timestamp drift": "Include an explicit definition of the acceptable timestamp drift in the protocol specification.", "": "Include an explicit definition of the acceptable timestamp drift in the protocol specification.", "Simple Summary": "Include an explicit definition of the acceptable timestamp drift in the protocol specification.", "Abstract": "On the basis that both Geth and Parity implement the same timestamp validation requirements, this should be written into the reference specification.", "Motivation": "There is a lack of clarity about how accurate timestamps in the block header must be. The yellow paper describes the timestamp as", "Specification": "The yellow paper should define a timestamp as:", "Rationale": "BothGethandParityreject blocks with timestamp more than 15 seconds in the future. This establishes a defacto standard, which should be made explicit in the reference specification.", "Backwards Compatibility": "It may be necessary to relax this requirement for blocks which were mined early in the main chain\u2019s history, if they would be considered invalid.", "Test Cases": "These would be important to have.", "Implementation": "_The implementations must be completed before any EIP is given status \u201cFinal\u201d, but it need not be completed before the EIP is accepted. While there is merit to the approach of reaching consensus on the specification and rationale before writing code, the principle of \u201crough consensus and running code\u201d is still useful when it comes to resolving many discussions of API details.\n_", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1485, "url": "https://eips.ethereum.org/EIPS/eip-1485", "title": "TEthashV1", "authors": ["trustfarm\u00a0<", "trustfarm.info@gmail.com", ">", "trustfarm\u00a0<", "cpplover@trustfarm.net", ">"], "sections": {"EIP-1485: TEthashV1": "This EIP modifies ethash in order to break ASIC miners specialized for the current ethash mining algorithm.", "": "This EIP modifies ethash in order to break ASIC miners specialized for the current ethash mining algorithm.", "Simple Summary": "This EIP modifies ethash in order to break ASIC miners specialized for the current ethash mining algorithm.", "Abstract": "This EIP pursue \u201cobsolete current ASIC miners\u201d by modifying PoW algorithm in a very low risk manner and update to latest hash algorithm from deprecated FNV Hash algorithms.", "Motivation": "Provide original Ethash proof of work verification with minimal set of changes by updating FNV0 algorithm", "Specification": "[FNV-0hash (deprecated)](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-0_hash(deprecated))", "Rationale": "In case of ethash algorithm, it can\u2019t prevent ASIC forever.", "Test Results::": "Tethash miner has 2~3% of hashrate degrade on GPU, due to more core computation time.", "Copyright": "This work is licensed under aCreative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1681, "url": "https://eips.ethereum.org/EIPS/eip-1681", "title": "Temporal Replay Protection", "authors": ["Martin Holst Swende\u00a0(", "@holiman", ")"], "sections": {"EIP-1681: Temporal Replay Protection": "This EIP proposes adding a \u2018temporal\u2019 replay protection to transactions, in the form of avalid-untiltimestamp. \nThis EIP is very similar to https://github.com/ethereum/EIPs/pull/599 by Nick Johnson and Konrad Feldmeier, the main difference\nbeing that this EIP is based on clock-time / walltime instead of block numbers.", "": "This EIP proposes adding a \u2018temporal\u2019 replay protection to transactions, in the form of avalid-untiltimestamp. \nThis EIP is very similar to https://github.com/ethereum/EIPs/pull/599 by Nick Johnson and Konrad Feldmeier, the main difference\nbeing that this EIP is based on clock-time / walltime instead of block numbers.", "Simple Summary": "This EIP proposes adding a \u2018temporal\u2019 replay protection to transactions, in the form of avalid-untiltimestamp. \nThis EIP is very similar to https://github.com/ethereum/EIPs/pull/599 by Nick Johnson and Konrad Feldmeier, the main difference\nbeing that this EIP is based on clock-time / walltime instead of block numbers.", "Motivation": "There are a couple of different motivators for introducing a timebased transaction validity.", "Specification": "The roll-out would be performed in two phases,X(hardfork), andY(softfork).", "Rationale": "For the dust-account clearing usecase,", "Rationale for this EIP": "For the dust-account clearing usecase,", "Rationale for walltime": "Why use walltime instead of block numbers, as proposed in https://github.com/ethereum/EIPs/pull/599 ?", "Backwards Compatibility": "This EIP means that all software/hardware that creates transactions need to add timestamps to the transactions, or will otherwise be incapable of signing transactions after blockY. Note: this EIP does not introduce any maximumvalid-untildate, so it would still be possible to create\ntransactions with near infinite validity.", "Test Cases": "todo", "Implementation": "None yet", "Security considerations": "The most notable security impact is that pre-signed transactions stored on paper backups, will become invalid as of blockY. There are a couple of cases where this might be used", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1702, "url": "https://eips.ethereum.org/EIPS/eip-1702", "title": "Generalized Account Versioning Scheme", "authors": ["Wei Tang\u00a0(", "@sorpaas", ")"], "sections": {"EIP-1702: Generalized Account Versioning Scheme": "Introduce account versioning for smart contracts so upgrading the VM\nor introducing new VMs can be easier.", "": "Introduce account versioning for smart contracts so upgrading the VM\nor introducing new VMs can be easier.", "Simple Summary": "Introduce account versioning for smart contracts so upgrading the VM\nor introducing new VMs can be easier.", "Abstract": "This defines a method of hard forking while maintaining the exact\nfunctionality of existing account by allowing multiple versions of the\nvirtual machines to execute in the same block. This is also useful to\ndefine future account state structures when we introduce the on-chain\nWebAssembly virtual machine.", "Motivation": "By allowing account versioning, we can execute different virtual\nmachine for contracts created at different times. This allows breaking\nfeatures to be implemented while making sure existing contracts work\nas expected.", "Specification": "Re-define account state stored in the world state trie to have 5\nitems:nonce,balance,storageRoot,codeHash, andversion. The newly added fieldversionis a 256-bitscalar. We\nuse the definition of \u201cscalar\u201d from Yellow Paper. Note that this is\nthe same type asnonceandbalance, and it is equivalent to a RLP\nvariable-sized byte array with no leading zero, of maximum length 32.", "Account State": "Re-define account state stored in the world state trie to have 5\nitems:nonce,balance,storageRoot,codeHash, andversion. The newly added fieldversionis a 256-bitscalar. We\nuse the definition of \u201cscalar\u201d from Yellow Paper. Note that this is\nthe same type asnonceandbalance, and it is equivalent to a RLP\nvariable-sized byte array with no leading zero, of maximum length 32.", "Contract Execution": "When fetching an account code from state, we always fetch the\nassociated version field together. We refer to this as thecode\u2019s\nversionbelow. The code of the account is always executed in thecode\u2019s version.", "Contract Deployment": "In Ethereum, a contract has a deployment method, either by a contract\ncreation transaction, or by another contract. If we regard this\ndeployment method a contract\u2019sparent, then we find them forming a\nfamily of contracts, with therootbeing a contract creation\ntransaction.", "Validation": "A new phrase,validationis added to contract deployment (byCREATE/CREATE2opcodes, or by contract creation\ntransaction). Whenversionis0, the phrase does nothing and\nalways succeeds. Future VM versions can define additional validation\nthat has to be passed.", "Contract Creation Transaction": "DefineLATEST_VERSIONin a hard fork to be the latest supported VM\nversion. A contract creation transaction is always executed inLATEST_VERSION(which means thecode\u2019s versionisLATEST_VERSION), and deploys contracts ofLATEST_VERSION. Before a\ncontract creation transaction is executed, runvalidationon the\ncontract creation code. If it does not pass, return out-of-gas.", "Precompiled Contract and Externally-owned Address": "Precompiled contracts and externally-owned addresses do not haveversion. If a message-call transaction orCALL/CALLCODE/STATICCALL/DELEGATECALLtouches a new externally-owned address\nor a non-existing precompiled contract address, it is always created\nwithversionfield being0.", "Additional Fields in Account State RLP": "In the future we may need to associate more information into an\naccount, and we already have some EIPs that define new additional\nfields in the account state RLP. In this section, we define the\nparsing strategy when additional fields are added.", "Extensions": "In relation to the above \u201cSpecification\u201d section, we have defined the\nbase account versioning layer. The base account versioning layer is\nalready useful by itself and can handle most EVM improvements. Below\nwe define two specifications that can be deployed separately, which\nimproves functionality of base layer account versioning.", "Usage Template": "This section defines how other EIPs might use this account\nversioning specification. Note that currently we only define the usage\ntemplate for base layer.", "Rationale": "This introduces account versioning via a new RLP item in account\nstate. The design above gets account versioning by making the contractfamilyalways have the same version. In this way, versions are only\nneeded to be provided by contract creation transaction, and there is\nno restrictions on formats of code for any version. If we want to\nsupport multiple newest VMs (for example, EVM and WebAssembly running\ntogether), then this will requires extensions such as 44-VERTXN and\n45-VEROP.", "Backwards Compatibility": "Account versioning is fully backwards compatible, and it does not\nchange how current contracts are executed.", "Discussions": "Currently nearly all full node implementations uses config parameters\nto decide which virtual machine version to use. Switching virtual\nmachine version is simply an operation that changes a pointer using a\ndifferent set of config parameters. As a result, this scheme has\nnearly zero impact to performance.", "Performance": "Currently nearly all full node implementations uses config parameters\nto decide which virtual machine version to use. Switching virtual\nmachine version is simply an operation that changes a pointer using a\ndifferent set of config parameters. As a result, this scheme has\nnearly zero impact to performance.", "WebAssembly": "This scheme can also be helpful when we deploy on-chain WebAssembly\nvirtual machine. In that case, WASM contracts and EVM contracts can\nco-exist and the execution boundary and interaction model are clearly\ndefined as above.", "Test Cases and Implementations": "To be added.", "References": "The source of this specification can be found at43-VER.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1829, "url": "https://eips.ethereum.org/EIPS/eip-1829", "title": "Precompile for Elliptic Curve Linear Combinations", "authors": ["Remco Bloemen\u00a0<", "Recmo@0x.org", ">"], "sections": {"EIP-1829: Precompile for Elliptic Curve Linear Combinations": "Currently the EVM only supportssecp256k1in a limited way throughecrecoverandaltbn128through two pre-compiles. There are draft proposals to add more curves. There are many more elliptic curve that have useful application for integration with existing systems or newly developed curves for zero-knowledge proofs.", "": "Currently the EVM only supportssecp256k1in a limited way throughecrecoverandaltbn128through two pre-compiles. There are draft proposals to add more curves. There are many more elliptic curve that have useful application for integration with existing systems or newly developed curves for zero-knowledge proofs.", "Precompile for Elliptic Curve Linear Combinations": "Currently the EVM only supportssecp256k1in a limited way throughecrecoverandaltbn128through two pre-compiles. There are draft proposals to add more curves. There are many more elliptic curve that have useful application for integration with existing systems or newly developed curves for zero-knowledge proofs.", "Simple Summary": "Currently the EVM only supportssecp256k1in a limited way throughecrecoverandaltbn128through two pre-compiles. There are draft proposals to add more curves. There are many more elliptic curve that have useful application for integration with existing systems or newly developed curves for zero-knowledge proofs.", "Abstract": "A precompile that takes a curve and computes a linear combination of curve points.", "Motivation": "Given integersm, \u03b1and\u03b2, scalarss_i, and curve pointsA_iconstruct the elliptic curve", "Specification": "Given integersm, \u03b1and\u03b2, scalarss_i, and curve pointsA_iconstruct the elliptic curve", "Gas cost": "The total gas cost isBASE_GASplusADD_GASfor eachs_ithat is1andMUL_GASfor eachs_i > 1(s_i = 0is free).", "Encoding of points": "Encode as(x, y')wheresindicates whetheryor-yis to be taken. It follows SEC 1 v 1.9 2.3.4, except uncompressed points (y' = 0x04) are not supported.", "Special cases": "Coordinate recovery.Sets\u2080 = 1. The output will be the recovered coordinates ofA\u2080.", "Edge cases": "Generic Field and Curve.Many important optimizations are independent of the field and curve used. Some missed specific optimizations are:", "Rationale": "Generic Field and Curve.Many important optimizations are independent of the field and curve used. Some missed specific optimizations are:", "Backwards Compatibility": "There will be a reference implementation in Rust based on the existing libraries (in particular those by ZCash and The Matter Inc.).", "Test Cases": "There will be a reference implementation in Rust based on the existing libraries (in particular those by ZCash and The Matter Inc.).", "Implementation": "There will be a reference implementation in Rust based on the existing libraries (in particular those by ZCash and The Matter Inc.).", "References": "This EIP overlaps in scope with", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1895, "url": "https://eips.ethereum.org/EIPS/eip-1895", "title": "Support for an Elliptic Curve Cycle", "authors": ["Alexandre Belling\u00a0<", "alexandrebelling8@gmail.com", ">"], "sections": {"EIP-1895: Support for an Elliptic Curve Cycle": "The EVM currently supports elliptic curves operations for curvealt-bn128thanks to precompilesecaddandecmulandecpairing. The classes MNT4 and 6 contain cycles of curves. Those cycles enable doing operations on one curve inside a SNARK on the other curve (and reversely). This EIP suggests adding support for those curves.", "": "The EVM currently supports elliptic curves operations for curvealt-bn128thanks to precompilesecaddandecmulandecpairing. The classes MNT4 and 6 contain cycles of curves. Those cycles enable doing operations on one curve inside a SNARK on the other curve (and reversely). This EIP suggests adding support for those curves.", "Simple Summary": "The EVM currently supports elliptic curves operations for curvealt-bn128thanks to precompilesecaddandecmulandecpairing. The classes MNT4 and 6 contain cycles of curves. Those cycles enable doing operations on one curve inside a SNARK on the other curve (and reversely). This EIP suggests adding support for those curves.", "Abstract": "Adds supports for the following operations through precompiles:", "Motivation": "Elliptic curve is the basic block of recursive SNARKs (ie: verifying a SNARK inside a SNARK) and this addresses the issue of scalable zero-knowledge. More generally this addresses partly the scalability issue as SNARKs verification are constant time in the size of the circuit being verified.", "Specification": "The proposed cycle has been introduced inScalable Zero Knowledge via Cycles of Elliptic Curves.", "The curve": "The proposed cycle has been introduced inScalable Zero Knowledge via Cycles of Elliptic Curves.", "MNT4 definition": "The groupsG_1andG_2are cyclic groups of prime order :", "The operations and gas cost": "The following operations and their gas cost would be implemented", "Encoding": "The curves points P(X, Y) over F_p are represented in their compressed form C(X, Y):", "Edge cases": "The curve has 80 bits of security (whereas MNT6 has 120 bits) which might not be considered enough for critical security level, (for instance transferring several billions), but enough for others. If it turns out this is not enough security for adoption, there is another option : another cycle is being used by Coda but is defined over a 753 bits sized field which might also be prohibitively low (no reference to this curve from Coda\u2019s publications found).", "Rationale": "The curve has 80 bits of security (whereas MNT6 has 120 bits) which might not be considered enough for critical security level, (for instance transferring several billions), but enough for others. If it turns out this is not enough security for adoption, there is another option : another cycle is being used by Coda but is defined over a 753 bits sized field which might also be prohibitively low (no reference to this curve from Coda\u2019s publications found).", "Test Cases": "Copyright and related rights waived viaCC0.", "References": "Copyright and related rights waived viaCC0.", "Implementation": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1930, "url": "https://eips.ethereum.org/EIPS/eip-1930", "title": "CALLs with strict gas semantic. Revert if not enough gas available.", "authors": ["Ronan Sandford\u00a0(", "@wighawag", ")"], "sections": {"EIP-1930: CALLs with strict gas semantic. Revert if not enough gas available.": "Add the ability for smart contract to execute calls with a specific amount of gas. If this is not possible the execution should revert.", "": "Add the ability for smart contract to execute calls with a specific amount of gas. If this is not possible the execution should revert.", "Simple Summary": "Add the ability for smart contract to execute calls with a specific amount of gas. If this is not possible the execution should revert.", "Abstract": "The current CALL, DELEGATE_CALL, STATIC_CALL opcode do not enforce the gas being sent, they simply consider the gas value as a maximum. This pose serious problem for applications that require the call to be executed with a precise amount of gas.", "Specification": "There are 2 possibilities", "Rationale": "Currently the gas specified as part of these opcodes is simply a maximum value. And due to the behavior ofEIP-150it is possible for an external call to be given less gas than intended (less than the gas specified as part of the CALL) while the rest of the current call is given enough to continue and succeed. Indeed since with EIP-150, the external call is given at maxG - Math.floor(G/64)where G is the gasleft() at the point of the CALL, the rest of the current call is givenMath.floor(G/64)which can be plenty enough for the transaction to succeed. For example, when G = 6,400,000 the rest of the transaction will be given 100,000 gas plenty enough in many case to succeed.", "Backwards Compatibility": "for specification a) : Backwards compatible as it introduce new opcodes.", "Test Cases": "None fully implemented yet. But see Specifications for an example in geth.", "Implementation": "None fully implemented yet. But see Specifications for an example in geth.", "References": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1959, "url": "https://eips.ethereum.org/EIPS/eip-1959", "title": "New Opcode to check if a chainID is part of the history of chainIDs", "authors": ["Ronan Sandford\u00a0(", "@wighawag", ")"], "sections": {"EIP-1959: New Opcode to check if a chainID is part of the history of chainIDs": "To protect off-chain messages from being reused across different chain, a mechanism need to be given to smart contract to only accept messages for that chain. Since a chain can change its chainID, the mechanism should consider old chainID valid.", "": "To protect off-chain messages from being reused across different chain, a mechanism need to be given to smart contract to only accept messages for that chain. Since a chain can change its chainID, the mechanism should consider old chainID valid.", "Simple Summary": "To protect off-chain messages from being reused across different chain, a mechanism need to be given to smart contract to only accept messages for that chain. Since a chain can change its chainID, the mechanism should consider old chainID valid.", "Abstract": "This EIP adds an opcode that returns whether the specific number passed in has been a valid chainID (EIP-155 unique identifier) in the history of the chain (including the current chainID).", "Motivation": "EIP-155proposes to use the chain ID to prevent replay attacks between different chains. It would be a great benefit to have the same possibility inside smart contracts when handling signatures, especially for Layer 2 signature schemes usingEIP-712.", "Specification": "Adds a new opcodeVALID_CHAINIDat 0x46, which uses 1 stack argument : a 32 bytes value that represent the chainID to test. It will push0x1onto the stack if the uint256 value is part of the history (since genesis) of chainIDs of that chain,0x0otherwise.", "Rationale": "The only approach available today is to specify the chain ID at compile time. Using this approach will result in problems after a contentious hardfork as the contract can\u2019t accept message signed with a new chainID.", "Test Cases": "TBD", "Implementation": "TBD", "Backwards Compatibility": "This EIP is fully backwards compatible with all chains which implement EIP-155 chain ID domain separator for transaction signing. Existing contract are not affected.", "References": "This was previously suggested as part ofEIP-1344 discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1962, "url": "https://eips.ethereum.org/EIPS/eip-1962", "title": "EC arithmetic and pairings with runtime definitions", "authors": ["Alex Vlasov\u00a0(", "@shamatar", ")"], "sections": {"EIP-1962: EC arithmetic and pairings with runtime definitions": "This proposal is an extension and formalization ofEIP-1829with an inclusion of pairings.EIP-1109is required due to low cost of some operations compared to theSTATICCALLopcode (more information in the corresponding section below).", "": "This proposal is an extension and formalization ofEIP-1829with an inclusion of pairings.EIP-1109is required due to low cost of some operations compared to theSTATICCALLopcode (more information in the corresponding section below).", "Simple summary": "This proposal is an extension and formalization ofEIP-1829with an inclusion of pairings.EIP-1109is required due to low cost of some operations compared to theSTATICCALLopcode (more information in the corresponding section below).", "Abstract": "This EIP proposes a new precompile to bring cryptographic functionality desired for privacy and scaling solutions. Functionality of such precompile will require the following:", "Motivation": "Functionality of this newly proposed precompile is different fromEIP-1829in the following aspects:", "Specification": "Ifblock.number >= XXXXX, define a set of10new precompiles with an addresses[0x.., 0x.., ...]and the following functionality.", "Possible simplifications": "Due to high complexity of the proposed operations in the aspects of implementation, debugging and evaluation of the factors for gas costs it may be appropriate to either limit the set of curves at the moment of acceptance to some list and then extend it. Another approach (if it\u2019s technically possible) would be to have the \u201cwhilelist\u201d contract that can be updated without consensus changes (w/o fork).", "Rationale": "Only the largest design decisions will be covered:", "This precompile and EIP 1109": "While there is no strict requirement of EIP 1109 for functionality, here is an example why it would be desired:", "Backwards Compatibility": "This change is not backwards compatible and requires hard fork to be activated.", "Test Cases": "Test cases are the part of the implementation with a link below.", "Implementation": "There is an ongoing implementation efforthere. Right now:", "Preliminary benchmarks": "cp6 in benchmarks is a Cocks-Pinch method curve that embeds BLS12-377. Machine: Core i7, 2.9 GHz.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1965, "url": "https://eips.ethereum.org/EIPS/eip-1965", "title": "Method to check if a chainID is valid at a specific block Number", "authors": ["Ronan Sandford\u00a0(", "@wighawag", ")"], "sections": {"EIP-1965: Method to check if a chainID is valid at a specific block Number": "This EIP adds a precompile that returns whether a specific chainID (EIP-155 unique identifier) is valid at a specific blockNumber. ChainID are assumed to be valid up to the blockNumber at which they get replaced by a new chainID.", "": "This EIP adds a precompile that returns whether a specific chainID (EIP-155 unique identifier) is valid at a specific blockNumber. ChainID are assumed to be valid up to the blockNumber at which they get replaced by a new chainID.", "Abstract": "This EIP adds a precompile that returns whether a specific chainID (EIP-155 unique identifier) is valid at a specific blockNumber. ChainID are assumed to be valid up to the blockNumber at which they get replaced by a new chainID.", "Motivation": "EIP-155proposes to use the chain ID to prevent the replay of transactions between different chains. It would be a great benefit to have the same possibility inside smart contracts when handling off-chain message signatures, especially for Layer 2 signature schemes usingEIP-712.", "Specification": "Adds a new precompile which uses 2 argument : a 32 bytes value that represent the chainID to test and a 32 bytes value representing the blockNumber at which the chainID is tested. It return 0x1  if the chainID is valid at the specific blockNumber, 0x0 otherwise. Note that chainID are considered valid up to the blockNumber at which they are replaced. So they are valid for every blockNumber past their replacement.", "Rationale": "The rationale at EIP-1959 applies here as well too :", "Backwards Compatibility": "EIP-712 is still in draft but would need to be updated to include the blockNumber as part of the values that wallets need to verify for the protection of their users.", "References": "This was previously suggested as part ofEIP1959 discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1985, "url": "https://eips.ethereum.org/EIPS/eip-1985", "title": "Sane limits for certain EVM parameters", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")"], "sections": {"EIP-1985: Sane limits for certain EVM parameters": "Introduce an explicit value range for certain EVM parameters\n(such as gas limit, block number, block timestamp, size field when returning/copying data within EVM).\nSome of these already have an implicit value range due to various (practical) reasons.", "": "Introduce an explicit value range for certain EVM parameters\n(such as gas limit, block number, block timestamp, size field when returning/copying data within EVM).\nSome of these already have an implicit value range due to various (practical) reasons.", "Abstract": "Introduce an explicit value range for certain EVM parameters\n(such as gas limit, block number, block timestamp, size field when returning/copying data within EVM).\nSome of these already have an implicit value range due to various (practical) reasons.", "Motivation": "Having such an explicit value range can help in creating compatible client implementations,\nin certain cases it can also offer minor speed improvements,\nand can reduce the effort needed to create consensus critical test cases\nby eliminating unrealistic edge cases.", "Specification": "Ifblock.number >= {FORK_BLOCK}, the following value ranges are introduced.\nThey restrict the results (i.e. values pushed to the stack) of the instructions listed below.", "Rationale": "These limits have been:", "Timestamp": "TheYellow Paperdefines the timestamp in block as \u201cA scalar value equal to the reasonable output of Unix\u2019s time() at this block\u2019s inception\u201d.\nIEEE Std 1003.1-2001 (POSIX.1) leaves that definition implementation defined.", "Addresses": "The size of addresses is specified in theYellow Paperas 20 bytes.\nE.g. theCOINBASEinstruction is specified to returnHc\u2208 \ud835\udd3920which has 20 bytes.", "Memory size": "Memory expansion cost is not linear and is determined by the following formula:\n        cost = cost_per_word * number_of_words + (number_of_words ^ 2 / 512)", "Code size": "EIP-170has implemented a code size limit of 0x6000, however even before that, it was practically impossible to deploy a code blob exceeding2**32 - 1bytes in size.", "Comparing current implementations": "All of these limits are already enforced mostly through the block gas limit. Since the out of range case results in a transaction failure, there should not be a change in behaviour.", "Backwards Compatibility": "All of these limits are already enforced mostly through the block gas limit. Since the out of range case results in a transaction failure, there should not be a change in behaviour.", "Test Cases": "TBA", "Implementation": "TBA", "References": "Copyright and related rights waived viaCC0.", "TODO": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2014, "url": "https://eips.ethereum.org/EIPS/eip-2014", "title": "Extended State Oracle", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-2014: Extended State Oracle": "Introduce a new system contract with an extensible interface following theContract ABI Encodingto access extended data sets, such as chain identifiers, block hashes, etc.", "": "Introduce a new system contract with an extensible interface following theContract ABI Encodingto access extended data sets, such as chain identifiers, block hashes, etc.", "Simple Summary": "Introduce a new system contract with an extensible interface following theContract ABI Encodingto access extended data sets, such as chain identifiers, block hashes, etc.", "Abstract": "Introduce a new system contract with an extensible interface following theContract ABI Encodingto access extended data sets, such as chain identifiers, block hashes, etc.", "Motivation": "Over the past couple of years several proposals were made to extend the EVM with more data. Some examples include extended access to block hashes (EIP-210) and chain identifiers (EIP-1344).", "Specification": "A new system contract (\u201cprecompile\u201d) is introduced at address0x0000000000000000000000000000000000000009called ESO (Extended State Oracle).", "Chain identifier": "Initially, a feature to read the current chain identifier is introduced:getCurrentChainId()returns the current chain identifier as auint64encoded value.\nIt should be a non-payable function, which means sending any value would revert the transaction as described inEIP-140.\nThis has been proposed asEIP-1344.", "Rationale": "TBA", "Backwards Compatibility": "TBA", "Test Cases": "TBA", "Implementation": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2026, "url": "https://eips.ethereum.org/EIPS/eip-2026", "title": "State Rent H - Fixed Prepayment for accounts", "authors": ["Alexey Akhunov\u00a0(", "@AlexeyAkhunov", ")"], "sections": {"EIP-2026: State Rent H - Fixed Prepayment for accounts": "Creation of new accounts (both contracts and non-contracts) requires a fixed one-off rent prepayment. Pre-existed accounts require the same prepayment upon\nthe first modification. The act of rent prepayment causes the addition of an extra field to accounts, calledrentbalance. This field becomes part of state.", "": "Creation of new accounts (both contracts and non-contracts) requires a fixed one-off rent prepayment. Pre-existed accounts require the same prepayment upon\nthe first modification. The act of rent prepayment causes the addition of an extra field to accounts, calledrentbalance. This field becomes part of state.", "Simple Summary": "Creation of new accounts (both contracts and non-contracts) requires a fixed one-off rent prepayment. Pre-existed accounts require the same prepayment upon\nthe first modification. The act of rent prepayment causes the addition of an extra field to accounts, calledrentbalance. This field becomes part of state.", "Abstract": "This is part of the State Rent roadmap. This particular change introduces a fixed charge for state expansion that comes from adding new accounts to the state. Theoretically, it puts a bound on the number of accounts that can be ever created, because that fixed charge cannot be recycled via mining.", "Motivation": "The penalty is levied to the transaction sender. Rather than raising the gas cost of account creation (that would direct levy towards the miner), this change directs prepayment into the account\u2019s special field,rentbalance. It addresses several shortcomings of the simple raising of the gas cost:", "Specification": "On and after blockH, every newly created account gets a new fieldrentbalanceof type unsigned 256-bit integer.\nOn and after blockH, any operation that leads to the creation of a new account, deducts the amountACCOUNT_PREPAYMENTfromtx.origin. This amount is added to therentbalancefield of the created account.\nOn and after blockH, any operation that modifies an account that does not yet haverentbalancefield, deducts the amountACCOUNT_PREPAYEMENTfromtx.origin. This amount is added to therentbalancefield of the modified account. This is an anti-hoarding measure.", "Rationale": "Prior to rent prepayments, other alternatives were considered:", "Backwards Compatibility": "This change is not backwards compatible and requires hard fork to be activated.\nIt might have some adverse effects on the existing contracts, due to more gas needed to be allocated for the creation of new accounts. These adverse effects need to analysed in more detail.", "Test Cases": "Tests cases will be generated out of a reference implementation.", "Implementation": "There will be proof of concept implementation to refine and clarify the specification.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2027, "url": "https://eips.ethereum.org/EIPS/eip-2027", "title": "State Rent C - Net contract size accounting", "authors": ["Alexey Akhunov\u00a0(", "@AlexeyAkhunov", ")"], "sections": {"EIP-2027: State Rent C - Net contract size accounting": "Ethereum starts counting the number of storage slots filled and emptied in the contracts. Since the number of pre-existing slots is not currently accounted\nin the state, effectively, only net change in the number of slots is tracked. In the subsequent change, calledGross contract size accounting, the total\nnumber of storage slots starts being tracked.", "": "Ethereum starts counting the number of storage slots filled and emptied in the contracts. Since the number of pre-existing slots is not currently accounted\nin the state, effectively, only net change in the number of slots is tracked. In the subsequent change, calledGross contract size accounting, the total\nnumber of storage slots starts being tracked.", "Simple Summary": "Ethereum starts counting the number of storage slots filled and emptied in the contracts. Since the number of pre-existing slots is not currently accounted\nin the state, effectively, only net change in the number of slots is tracked. In the subsequent change, calledGross contract size accounting, the total\nnumber of storage slots starts being tracked.", "Abstract": "This is part of the State Rent roadmap. This particular change introduces initial, net accounting of the number of the contract storage slots. Though not very\nuseful on its own, it makes it possible to introduce gross accounting of the number of storage slots, which is useful for number of things:", "Motivation": "Ethereum currently does not track the number of contract storage slots at all, and producing such number given the downloaded state cannot be done in\nconstantO(1)time.", "Specification": "Each contract (account withcodeHashfield not equal to 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470, which the hash of the empty code) gets a new uint64 field, calledstoragesize. On and after blockC, the semantics of the operationSSTORE(location,value) changes as follows:", "Semantics ofincrementstoragesize": "Ifstoragesizeis not present,storagesize=HUGE_NUMBER+ 1.\nIfstoragesizeis present,storagesize=storagesize+ 1.", "Semantics ofdecrementstoragesize": "Ifstoragesizeis not present,storagesize=HUGE_NUMBER- 1.\nIfstoragesizeis present,storagesize=storagesize- 1.", "Note ofHUGE_NUMBER": "There is a constantHUGE_NUMBER. It needs to be large enough so that no real metrics (contract storage size, number of accounts, number of contracts, total size of code, total size of storage) will never reach that number, and small enough that it fits in an unsigned 64-bit integer.\nCurrent suggestion is to haveHUGE_NUMBER= 2^63, which is binary representation is the a single bit in a 64-bit number.", "Rationale": "A mechanism for estimation of contract storage size has been proposedhere. But it does have a big drawback of introducing a lot of complexity into the consensus\n(in the form of estimation algorithm, which has quite a few edge cases to cater for different sizes of the storage).", "Backwards Compatibility": "This change is not backwards compatible and requires hard fork to be activated. Since the newly introduced field is not observable, this change does not impact any operations of the existing smart contracts.", "Test Cases": "Tests cases will be generated out of a reference implementation.", "Implementation": "There will be proof of concept implementation to refine and clarify the specification.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2029, "url": "https://eips.ethereum.org/EIPS/eip-2029", "title": "State Rent A - State counters contract", "authors": ["Alexey Akhunov\u00a0(", "@AlexeyAkhunov", ")"], "sections": {"EIP-2029: State Rent A - State counters contract": "A smart contract is deployed on all Ethereum networks, at a pre-determined address, with the code that simply reads the slot in its storage specified by the\nonly parameter. Later, this contract becomes \u201cspecial\u201d in that Ethereum start writing state counters (number of total transactions, number of accounts,\netc.) into that contract.", "": "A smart contract is deployed on all Ethereum networks, at a pre-determined address, with the code that simply reads the slot in its storage specified by the\nonly parameter. Later, this contract becomes \u201cspecial\u201d in that Ethereum start writing state counters (number of total transactions, number of accounts,\netc.) into that contract.", "Simple Summary": "A smart contract is deployed on all Ethereum networks, at a pre-determined address, with the code that simply reads the slot in its storage specified by the\nonly parameter. Later, this contract becomes \u201cspecial\u201d in that Ethereum start writing state counters (number of total transactions, number of accounts,\netc.) into that contract.", "Abstract": "This is part of the State Rent roadmap. This particular change introduces a place in the Ethereum state where various state counters can be stored. At this\npoint, the most important counter is the total number of transactions happened, and this counter will be used to populate the nonces of newly created\nnon-contract accounts. This way of populating nonce ensures replay protection for accounts that were evicted and then brought back by sending ether to them.", "Motivation": "Ethereum currently does not have a special place in the state for tracking state counters such as number of transactions or number of accounts.", "Specification": "Prior to the block A, a contract is deployed with the following code:0x60 0x20 0x60 0x00 0x80 0x80 0x35 0x54 0x90 0x52 0xF3, which corresponds to this assembly:PUSH1 32 PUSH1 0 DUP1 DUP1 CALLDATALOAD SLOAD SWAP1 MSTORE RETURNCall to this contract accepts one 32-byte argument,x, and returns the value of the storage item [x].", "Rationale": "Two alternative solutions were considered so far:", "Backwards Compatibility": "This change is backwards compatible and does not require hard fork to be activated.", "Test Cases": "Tests cases will be created to ensure that the state counter contract returns its storage items correctly.", "Implementation": "Implementation is envisaged as a transaction that can be posted from any Ethereum address and will cause the deployment of the state counter contract.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2031, "url": "https://eips.ethereum.org/EIPS/eip-2031", "title": "State Rent B - Net transaction counter", "authors": ["Alexey Akhunov\u00a0(", "@AlexeyAkhunov", ")"], "sections": {"EIP-2031: State Rent B - Net transaction counter": "Ethereum starts to track the number of transactions inside its state (for now, only number of transactions after this change is introduced, therefore\nit is calledNettransaction count).\nIt is done by incrementing a storage slot in the special contract, calledState counter contract(EIP-2029).", "": "Ethereum starts to track the number of transactions inside its state (for now, only number of transactions after this change is introduced, therefore\nit is calledNettransaction count).\nIt is done by incrementing a storage slot in the special contract, calledState counter contract(EIP-2029).", "Simple Summary": "Ethereum starts to track the number of transactions inside its state (for now, only number of transactions after this change is introduced, therefore\nit is calledNettransaction count).\nIt is done by incrementing a storage slot in the special contract, calledState counter contract(EIP-2029).", "Abstract": "It is part of the State Rent roadmap. This particular change makes any Ethereum transaction increment the transaction counter, which is a special storage slot\nin theState counter contract. This counter will be used to populate the nonces of newly created\nnon-contract accounts. This way of populating nonce ensures replay protection for accounts that were evicted and then brought back by sending ether to them.", "Motivation": "Ethereum currently does not have a special place in the state for tracking number of transactions.", "Specification": "A new field, with the location 0 (that means it resides in the storage slot 0 in the state counter contract, and can\nbe read by calling that contract with argument being 32 zero bytes), is added to the state counter contract. It will eventually containtxCount, the total number of transactions processed up until that point.\nOn an after block B, or after the deployment of the state counter contract (which comes first), the fieldtxCountis incremented after each transaction. UpdatingtxCountmeans updating the storage of state counter contract at the location 0. These changes are never reverted.", "Rationale": "Two main alternatives were proposed for the replay protection of the accounts that were evicted by subsequently brought back by sending ether to them:", "Backwards Compatibility": "This change is not backwards compatible and requires hard fork to be activated.", "Test Cases": "Tests cases will be generated out of a reference implementation.", "Implementation": "There will be proof of concept implementation to refine and clarify the specification.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2035, "url": "https://eips.ethereum.org/EIPS/eip-2035", "title": "Stateless Clients - Repricing SLOAD and SSTORE to pay for block proofs", "authors": ["Alexey Akhunov\u00a0(", "@AlexeyAkhunov", ")"], "sections": {"EIP-2035: Stateless Clients - Repricing SLOAD and SSTORE to pay for block proofs": "The gas cost of EVM opcodesSLOADandSSTOREincreases in order to accommodate extra bandwidth required to propagate block proof together with the block\nheaders and block bodies, as explainedhere.", "": "The gas cost of EVM opcodesSLOADandSSTOREincreases in order to accommodate extra bandwidth required to propagate block proof together with the block\nheaders and block bodies, as explainedhere.", "Simple Summary": "The gas cost of EVM opcodesSLOADandSSTOREincreases in order to accommodate extra bandwidth required to propagate block proof together with the block\nheaders and block bodies, as explainedhere.", "Abstract": "It is part of the State Rent roadmap. This particular change prepares Ethereum for introduction of the block proofs (current understanding is that they\ncan be introuced without a hard fork). The introduction of the block proofs allows any Ethereum node that wishes to receive them, to process transactions\nin the blocks without needing to access the Ethereum state. All necessary information for the execution (and the proof of validity) is continued in the\nblock proofs. In most Ethereum nodes, it will speed up the block processing and reduce the memory footprint of such processing. For mining nodes, however,\nthere will be more work to do to construct and transmit the block proofs. Therefore, the extra charge (payable to the miners) is introduced. In the first\nphase, only contract storage will be covered by the block proofs. It means that the Ethereum nodes will still need access to the accounts in the state,\nbut block proofs will make it optional to have access to contract storage for executing transactions. Therefore, onlySSTOREandSLOADopcodes are\naffected.", "Motivation": "There isempirical analysisshowing thatSLOADopcode is currently underpriced in terms\nof execution latency it adds to the block processing. The hypothesis is that it is due to the latency of the database accesses. In the same\nanalysis,SSTOREis not considered, because its effect on the database accesses can be (and are in many implementations) delayed until the end of\nthe block. Stateless clients approach to the contract storage will largely negate that latency because no database accesses will be required.\nInstead, bandwidth consumption goes up. There is emprical analysis (unpublished, but will be) suggesting that 1 uncachedSSTOREorSLOADadds\nat most 1 kB to the block proofs. At the current cost of data transmission (68 gas per byte), this translates to the increase of gas cost of both\noperations by 69k gas. However, in light of proposal inEIP-2028, the increase can be made much smaller.", "Specification": "Not very formal at the moment, but will be formalised with more research and prototyping. Gas of operationsSLOADandSSTOREincreases byXgas when the storage slots accessed (read bySLOADor written bySSTORE) were not previously accessed (by anotherSLOADorSSTORE) during the same transaction.", "Rationale": "EIP-1884seeks to increase the gas cost ofSLOADbut using a different justification\n(latency of the execution as described in the Motivation). This EIP is likely to increase the cost ofSLOADby a larger amount, therefore partially\n(because EIP-1884 also proposed other increases) supersedes EIP-1884.", "Backwards Compatibility": "This change is not backwards compatible and requires hard fork to be activated.\nThere might also be an adverse effect of this change on the already deployed contract. It is expected that after this EIP andEIP-2026(rent prepayment for accounts), the recommendation will be made to raise the gas limit. This can somewhat dampen the\nadverse effect of EIP. The most problematic cases would be with the contracts that assume certain gas costs ofSLOADandSSTOREand hard-code them in their internal gas computations. For others, the cost of interacting with the contract\nstorage will rise and may make some dApps based on such interactions, non-viable. This is a trade off to avoid even bigger\nadverse effect of the rent proportional to the contract storage size. However, more research is needed to more fully\nanalyse the potentially impacted contracts.", "Test Cases": "Tests cases will be generated out of a reference implementation.", "Implementation": "There will be proof of concept implementation to refine and clarify the specification.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2045, "url": "https://eips.ethereum.org/EIPS/eip-2045", "title": "Particle gas costs for EVM opcodes", "authors": ["Casey Detrio\u00a0(", "@cdetrio", ")", "Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-2045: Particle gas costs for EVM opcodes": "According to recent benchmarks, EVM opcodes for computation (ADD,SUB,MUL, etc.) are generally overpriced relative to opcodes for storage I/O (SLOAD,SSTORE, etc.). Currently the minimum gas cost is 1 (i.e. one unit of gas), and most computational opcodes have a cost near to 1 (e.g. 3, 5, or 8), so the range in possible cost reduction is limited. A new minimum unit of gas, called a \u201cparticle\u201d, which is a fraction of 1 gas, would expand the range of gas costs and thus enable reductions below the current minimum.", "": "According to recent benchmarks, EVM opcodes for computation (ADD,SUB,MUL, etc.) are generally overpriced relative to opcodes for storage I/O (SLOAD,SSTORE, etc.). Currently the minimum gas cost is 1 (i.e. one unit of gas), and most computational opcodes have a cost near to 1 (e.g. 3, 5, or 8), so the range in possible cost reduction is limited. A new minimum unit of gas, called a \u201cparticle\u201d, which is a fraction of 1 gas, would expand the range of gas costs and thus enable reductions below the current minimum.", "Abstract": "According to recent benchmarks, EVM opcodes for computation (ADD,SUB,MUL, etc.) are generally overpriced relative to opcodes for storage I/O (SLOAD,SSTORE, etc.). Currently the minimum gas cost is 1 (i.e. one unit of gas), and most computational opcodes have a cost near to 1 (e.g. 3, 5, or 8), so the range in possible cost reduction is limited. A new minimum unit of gas, called a \u201cparticle\u201d, which is a fraction of 1 gas, would expand the range of gas costs and thus enable reductions below the current minimum.", "Motivation": "The transaction capacity of an Ethereum block is determined by the gas cost of transactions relative to the block gas limit. One way to boost the transaction capacity is to raise the block gas limit. Unfortunately, raising the block gas limit would also increase the rate of state growth, unless the costs of state-expanding storage opcodes (SSTORE,CREATE, etc.) are simultaneously increased to the same proportion. Increasing the cost of storage opcodes may have adverse side effects, such as shifting the economic assumptions around gas fees of deployed contracts, or possibly breaking invariants in current contract executions (as mentioned inEIP-20351, more research is needed on the potential effects of increasing the cost of storage opcodes).", "Specification": "A new gas counterparticlesUsedis added to the EVM, in addition to the existing gas countergasUsed. The unit 1 gas is equal to 10000 particles (PARTICLES_PER_GAS). TheparticlesUsedcounter is only increased for opcodes priced in particles (i.e. opcodes that cost less than 1 gas). If increasingparticlesUsedresults in an excess of 1 gas, then 1 gas is added togasUsed(and deducted fromparticlesUsed).", "Rationale": "Adoption of fractional gas costs should only be an implementation detail inside the EVM, and not alter the current user experience around transaction gas limits and block gas limits. The concept ofparticlesneed not be exposed to Ethereum users nor most contract authors, but only to EVM implementers and contract developers concerned with optimized gas usage. Furthermore, only the EVM logic for charging gas per opcode executed should be affected by this change. All other contexts dealing with gas and gas limits, such as block headers and transaction formats, should be unaffected.", "Ewasm": "The term \u201cparticles\u201d was first introduced for Ewasm3to enable gas accounting for low cost wasm instructions, while remaining compatible with EVM gas costs. This EIP proposes introducing particles as a new minimum gas unit for EVM opcodes, and is not related to Ewasm.", "Backwards Compatibility": "This change is not backwards compatible and requires a hard fork to be activated.", "Test Cases": "TODO", "Implementation": "TODO", "References": "1.EIP-2035: Stateless Clients - Repricing SLOAD and SSTORE to pay for block proofs", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2046, "url": "https://eips.ethereum.org/EIPS/eip-2046", "title": "Reduced gas cost for static calls made to precompiles", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-2046: Reduced gas cost for static calls made to precompiles": "This change reduces the gas cost of using precompiled contracts.", "": "This change reduces the gas cost of using precompiled contracts.", "Simple Summary": "This change reduces the gas cost of using precompiled contracts.", "Abstract": "Reduce the base gas cost of calling precompiles usingSTATICCALLfrom 700 to 40. This should allow more efficient use of precompiles as well as precompiles with a total cost below 700.", "Motivation": "The Spurious Dragon hard fork increased the cost of calls significantly to account for loading contract code from the state without making an exception for precompiles, whose \u201ccode\u201d is always loaded.", "Specification": "After blockHFtheSTATICCALL(0xfa) instruction charges different basic gas cost (GcallinYellow Paper\u2019s notation) depending on the destination address provided:", "Rationale": "Only theSTATICCALLinstruction was changed to reduce the impact of the change. This should not be a limiting factor, given precompiles (currently) do not have a state and cannot change the state.\nHowever, contracts created and deployed before Byzantium likely will not useSTATICCALLand as a result this change will not reduce their costs.", "Backwards Compatibility": "This EIP should be backwards compatible. The only effect is that the cost is reduced. Since the cost is not reduced to zero, it should not be possible for a malicious proxy contract, when deployed before\ntheHF, to do any state changing operation.", "Test Cases": "TBA", "Implementation": "TBA", "References": "This has been previously suggested as part ofEIP-1109andEIP-1231.\nHowever EIP-1109 was later changed to a very different approach. The authorhas suggested to change EIP-1109.", "Acknowledgements": "Jordi Baylina (@jbaylina) and Matthew Di Ferrante (@mattdf) who have proposed this before.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2242, "url": "https://eips.ethereum.org/EIPS/eip-2242", "title": "Transaction Postdata", "authors": ["John Adler\u00a0(", "@adlerjohn", ")"], "sections": {"EIP-2242: Transaction Postdata": "An additional, optional transaction field is added for \u201cpostdata,\u201d data that is posted on-chain but that cannot be read from the EVM.", "": "An additional, optional transaction field is added for \u201cpostdata,\u201d data that is posted on-chain but that cannot be read from the EVM.", "Simple Summary": "An additional, optional transaction field is added for \u201cpostdata,\u201d data that is posted on-chain but that cannot be read from the EVM.", "Abstract": "A paradigm shift in how blockchains are used has been seen recently in Eth 2.0, with the rise ofExecution Environments(EEs), andstateless clients. This shift involves blockchains serving as a secure data availability and arbitration layer,i.e., they provide a globally-accepted source of available data, and process fraud/validity and data availability proofs. This same paradigm can be applied on Eth 1.x, replacing EEs withtrust-minimized side chains.", "Motivation": "WhileEIP-2028provides a reduction in gas cost of calldata, and is a step in the right direction of encouraging use of history rather than state, the EVM does not actually need to see all data that is posted on-chain. Following the principle of \u201cdon\u2019t pay for what you don\u2019t use,\u201d a distinct way of posting data on-chain, but without actually being usable within the EVM, is needed.", "Specification": "We propose a consensus modification, beginning atFORK_BLKNUM:", "Rationale": "The changes proposed are as minimal and non-disruptive to the existing EVM and transaction format as possible while also supporting possiblefuture extensionsthrough a version code.", "Backwards Compatibility": "The new transaction format is backwards compatible, as the newpostdatafield is optionally appended to existing transactions.", "Test Cases": "TODO", "Implementation": "TODO", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2327, "url": "https://eips.ethereum.org/EIPS/eip-2327", "title": "BEGINDATA opcode", "authors": ["Martin Lundfall\u00a0(", "@MrChico", ")"], "sections": {"EIP-2327: BEGINDATA opcode": "Introduces a new opcodeBEGINDATA, which indicates that the remaining bytes of the contract should be regarded as data rather than contract code\nand cannot be executed.", "": "Introduces a new opcodeBEGINDATA, which indicates that the remaining bytes of the contract should be regarded as data rather than contract code\nand cannot be executed.", "Simple Summary": "Introduces a new opcodeBEGINDATA, which indicates that the remaining bytes of the contract should be regarded as data rather than contract code\nand cannot be executed.", "Abstract": "It is common for smart contracts to efficiently store data directly in the contract bytecode. Examples include constructor arguments, constant variables, compiler metadata and the contract runtime during the init phase. Currently, such data is not distinguished from normal bytecode and is still being analysed forJUMPDESTs by EVM interpreters. This EIP introduces a new opcodeBEGINDATAat byte0xb6, which marks the remainding bytecode as data, indicating to EVM interpreters, static analysis tools and chain explorers that the remaining bytes do not represent opcodes.", "Motivation": "TheBEGINDATAopcode has been suggested before as part of the EIPSubroutines and Static Jumps for the EVMEIP-615as a way to determine the position of jumptables in contract bytecode. It is here introduced in its own right in order to exclude data from theJUMPDESTanalysis of contracts, making it impossible to jump to data. This makes it easier for static analysis tools to analyse contracts, allows disassemblers, chain explorers and debuggers to not display data as a mess of INVALID opcodes and may even provide a marginal improvement in performance. It also helps scalability because it improves on-chain evaluation of transactions from other chains in that the validation that the code conforms to a certain pattern does not need to do a full jumpdest analysis to see that data is not executed and thus does not have to conform to the pattern (used by the optimism project). Additionally, it paves the way for suggestions such asEIP-1712to disallow unused opcodes, jumptablesEIP-615and speculative proposals to disallow for deployment of contracts with stack usage violations.", "Specification": "While computing the validJUMPDESTs of a contract, halt analysis once the firstBEGINDATAis encountered. In other words: A jump to any codelocation equal to or greater than the location of the firstBEGINDATAcauses aBAD_JUMP_DESTINATIONerror.\nIfBEGINDATAis encountered during contract execution, it has the same semantics asSTOP. It uses 0 gas.", "Rationale": "The byte0xb6was chosen to align withEIP-615.\nThe choice toSTOPifBEGINDATAis encountered is somewhat arbitrary. An alternative would be to be to abort the execution with an out-of-gas error.", "Backwards Compatibility": "The proposal will not change any existing contracts unless their current behaviour relies upon the usage of unused opcodes.", "Test Cases": "Test cases should include:\n1) A contract which jumps to a destinationX, whereXhas a pc value higher than theBEGINDATAopcode, and the byte atXis0x5b. This should fail with aBAD_JUMP_DESTINATIONerror.\n2) A contract which encounters theBEGINDATAopcode (should stop executing the current call frame)", "Implementation": "Not yet.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2330, "url": "https://eips.ethereum.org/EIPS/eip-2330", "title": "EXTSLOAD opcode", "authors": ["Dominic Letz\u00a0(", "@dominicletz", ")", "Santiago Palladino\u00a0(", "@spalladino", ")"], "sections": {"EIP-2330: EXTSLOAD opcode": "This proposal adds a new opcodeEXTSLOADat0x5cwhich pops two items from the stack:<account address> <storage key>and pushes one item:<storage value>. The gas cost is sum of account access cost and storage read based onEIP-2929Access Lists.", "A new EVM opcode to read external contract storage data.": "This proposal adds a new opcodeEXTSLOADat0x5cwhich pops two items from the stack:<account address> <storage key>and pushes one item:<storage value>. The gas cost is sum of account access cost and storage read based onEIP-2929Access Lists.", "Abstract": "This proposal adds a new opcodeEXTSLOADat0x5cwhich pops two items from the stack:<account address> <storage key>and pushes one item:<storage value>. The gas cost is sum of account access cost and storage read based onEIP-2929Access Lists.", "Motivation": "While any off-chain application can read all contract storage data of all contracts, this is not possible for deployed smart contracts themselves. These are bound to use contract calls for any interaction including reading data from other contracts. This EIP adds an EVM opcode to directly read external contract storage.", "Specification": "A new EVM instructionEXTSLOAD (0x5c)that works likeSLOAD (0x54)but an additional parameter representing the contract that is to be read from.", "Gas cost pre-verkle": "Gas to be charged before Verkle Tree change is specified asACCOUNT_ACCESS_COST + STORAGE_READ_COSTwhere:", "Gas cost post-verkle": "It is important to consider that post Verkle tree change,ACCOUNT_ACCESS_COSTwill not be needed since a single account\u2019s storage would be spread across the entire global trie. Hence gas to be charged post Verkle Tree change is justSTORAGE_READ_COST, which is as specified inGas cost pre-verkle.", "Rationale": "This change is fully backwards compatible since it adds a new instruction.", "Backwards Compatibility": "This change is fully backwards compatible since it adds a new instruction.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2474, "url": "https://eips.ethereum.org/EIPS/eip-2474", "title": "Coinbase calls", "authors": ["Ricardo Guilherme Schmidt\u00a0(", "@3esmit", ")"], "sections": {"EIP-2474: Coinbase calls": "Allow contracts to be called directly byblock.coinbase(block validator), without a transaction.", "": "Allow contracts to be called directly byblock.coinbase(block validator), without a transaction.", "Simple Summary": "Allow contracts to be called directly byblock.coinbase(block validator), without a transaction.", "Abstract": "In proof-of-work blockchains, validators are known as miners.", "Motivation": "In order to reduce the overhead of calls that don\u2019t usemsg.senderand are being called by validator withtx.gasPrice = 0.", "Specification": "The calls to be executed byblock.coinbasewould be included first at block, and would consume normally the gas of block, however they won\u2019t pay/cost gas, instead the call logic would pay the validator in other form.", "Rationale": "TBD", "Backwards Compatibility": "tx.origin = block.coinbasecould cause some issues on bad designed contracts, such as usingtx.originto validate a signature, an analysis on how contracts use tx.origin might be useful to decide if this is a good choice.", "Test Cases": "TBD", "Implementation": "TBD", "Security Considerations": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2488, "url": "https://eips.ethereum.org/EIPS/eip-2488", "title": "Deprecate the CALLCODE opcode", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-2488: Deprecate the CALLCODE opcode": "DeprecateCALLCODEin asomewhatbackwards compatible way, by making it always return failure.", "": "DeprecateCALLCODEin asomewhatbackwards compatible way, by making it always return failure.", "Abstract": "DeprecateCALLCODEin asomewhatbackwards compatible way, by making it always return failure.", "Motivation": "CALLCODEwas part of the Frontier release of Ethereum. In the first few weeks/months it became clear\nthat it cannot accomplish its intended design goal. This was rectified with introducingDELEGATECALL(EIP-7) in the Homestead update (early 2016).", "Specification": "Ifblock.number >= FORK_BLOCK, theCALLCODE(0xf2) instruction always returns0, which signals failure.", "Rationale": "It would be possible just to remove the opcode and exceptionally abort if it is encountered.\nHowever, by returning failure, the contract has a chance to act on it and potentially recover.", "Backwards Compatibility": "This is a breaking change and has a potential to break contracts. The author expects no contracts of any value\nshould be affected.", "Security Considerations": "TBA", "Test Cases": "TBA", "Implementation": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2515, "url": "https://eips.ethereum.org/EIPS/eip-2515", "title": "Implement Difficulty Freeze", "authors": ["James Hancock\u00a0(", "@madeoftin", ")"], "sections": {"EIP-2515: Implement Difficulty Freeze": "The difficulty Freeze is an alternative to the Difficulty Bomb that is implemented within the protocols difficulty adjustment algorithm. The Difficulty Freeze begins at a certain block height, determined in advance, freezes the difficulty and increases by 1% after that block forever. This does not stop the chain, but it incentivizes devs to upgrade at a regular cadence and requires any chain split to address the difficulty freeze.", "": "The difficulty Freeze is an alternative to the Difficulty Bomb that is implemented within the protocols difficulty adjustment algorithm. The Difficulty Freeze begins at a certain block height, determined in advance, freezes the difficulty and increases by 1% after that block forever. This does not stop the chain, but it incentivizes devs to upgrade at a regular cadence and requires any chain split to address the difficulty freeze.", "Simple Summary": "The difficulty Freeze is an alternative to the Difficulty Bomb that is implemented within the protocols difficulty adjustment algorithm. The Difficulty Freeze begins at a certain block height, determined in advance, freezes the difficulty and increases by 1% after that block forever. This does not stop the chain, but it incentivizes devs to upgrade at a regular cadence and requires any chain split to address the difficulty freeze.", "Abstract": "The difficulty Freeze is a mechanism that is easy to predict and model, and the pressures of missing it are more readily felt by the core developers and client maintainers. The client maintainers are also positioned as the group that is most able to respond to an incoming Difficulty Freeze. This combined with the predictability is more likely to lead to the timely diffusual of the bomb.", "Motivation": "The current difficulty bombs\u2019 effect on the Block Time Targeting mechanism is rather complex to model, and it has both appeared when it was not expected (Muir Glacier) and negatively affected miners when they are not the target (in the case of delaying forks due to technical difficulties). Miners are affected by a reduction in block rewards due to the increase in block time. Users are affected as a function of the usability of the chain is affected by increased block times. Both of these groups are unable on their own to address the difficulty bomb. In the case of the Difficulty Freeze, the consequences of missing it are more directly felt by the client maintainers and it is more predictiable and so knowing when to make the change is readily apparent.", "Specification": "Add variableDIFFICULTY_FREEZE_HEIGHT", "Rationale": "Block height is very easy to predict and evaluate within the system. This removes the effect of the Difficulty Bomb on block time, simplifying the block time targeting mechanism. The addition of an increase in the difficulty was added after feedback that the game theory of the mechanism did not reliably result in .", "Backwards Compatibility": "No backward incompatibilities", "Test Cases": "TBD", "Implementation": "TBD", "Security Considerations": "The effect of missing the Difficulty Freeze has a different impact than missing the Difficulty Bomb. At the point of a Difficulty freeze, the protocol is no longer able to adapt to changes in hash power on the network. This can lead to one of three scenarios.", "Economic Considerations": "Under the current Difficult, Bomb issuance of ETH is reduced as the Ice Age takes affect. Under the Difficulty Freeze, it is more likely that issuance would increase for a short time; however, clients are motivated to prevent this and keep clients syncing effectively. This means it is much less likely to occur. The increase to the difficulty over time will eventually reduce blocktimes and also issuance.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2539, "url": "https://eips.ethereum.org/EIPS/eip-2539", "title": "BLS12-377 curve operations", "authors": ["Alex Vlasov\u00a0(", "@shamatar", ")", "hujw77\u00a0(", "@hujw77", ")"], "sections": {"EIP-2539: BLS12-377 curve operations": "This precompile adds operation on BLS12-377 curve (from Zexe paper) as a precompile in a set necessary toefficientlyperform operations such as BLS signature verification and perform SNARKs verifications. Unique properties of BLS12-377 also later allow to have SNARKs that check BLS12-377 pairing in an efficient way and allow e.g. constant-size BLS signature aggregation.", "Precompiles for BLS12-377 curve operations": "This precompile adds operation on BLS12-377 curve (from Zexe paper) as a precompile in a set necessary toefficientlyperform operations such as BLS signature verification and perform SNARKs verifications. Unique properties of BLS12-377 also later allow to have SNARKs that check BLS12-377 pairing in an efficient way and allow e.g. constant-size BLS signature aggregation.", "Abstract": "This precompile adds operation on BLS12-377 curve (from Zexe paper) as a precompile in a set necessary toefficientlyperform operations such as BLS signature verification and perform SNARKs verifications. Unique properties of BLS12-377 also later allow to have SNARKs that check BLS12-377 pairing in an efficient way and allow e.g. constant-size BLS signature aggregation.", "Proposed addresses table": "Motivation of this precompile is to add a cryptographic primitive that allows to get 120+ bits of security for operations over pairing friendly curve compared to the existing BN254 precompile that only provides 80 bits of security. In addition it allows efficient one-time recursive proof aggregations, e.g. proofs about existence of BLS12-377 based signature.", "Motivation": "Motivation of this precompile is to add a cryptographic primitive that allows to get 120+ bits of security for operations over pairing friendly curve compared to the existing BN254 precompile that only provides 80 bits of security. In addition it allows efficient one-time recursive proof aggregations, e.g. proofs about existence of BLS12-377 based signature.", "Specification": "Curve parameters:", "Fine points and encoding of base elements": "To encode points involved in the operation one has to encode elements of the base field and the extension field.", "ABI for operations": "G1 addition call expects256bytes as an input that is interpreted as byte concatenation of two G1 points (128bytes each). Output is an encoding of addition operation result - single G1 point (128bytes).", "Prevention of DDoS on error handling": "This precompile performs extensive computations and in case of any errors during execution it MUST consume all gas from the gas schedule for the corresponding operation.", "Gas schedule": "Assuming a constant30 MGas/secondfollowing prices are suggested.", "Rationale": "Motivation section covers a total motivation to have operations over BLS12-377 curve available. We also extend a rationale for move specific fine points.", "Multiexponentiation as a separate call": "Explicit separate multiexponentiation operation that allows one to save execution time (so gas) by both the algorithm used (namely Peppinger algorithm) and (usually forgotten) by the fact thatCALLoperation in Ethereum is expensive (at the time of writing), so one would have to pay non-negigible overhead if e.g. for multiexponentiation of100points would have to call the multipication precompile100times and addition for99times (roughly138600would be saved).", "Backwards Compatibility": "There are no backward compatibility questions.", "Important notes": "Subgroup checkis mandatoryduring the pairing call. Implementationsshoulduse fast subgroup checks: at the time of writing multiplication gas cost is based ondouble-and-addmultiplication method that has a clear \u201cworst case\u201d (all bits are equal to one). For pairing operation it\u2019s expected that implementation uses faster subgroup check, e.g. by using wNAF multiplication method for elliptic curves that is ~40%cheaper with windows size equal to 4. (Tested empirically. Savings are due to lower hamming weight of the group order and even lower hamming weight for wNAF. Concretely, subgroup check for both G1 and G2 points in a pair are around35000combined).", "Test Cases": "Due to the large test parameters space we first provide properties that various operations must satisfy. We use additive notation for point operations, capital letters (P,Q) for points, small letters (a,b) for scalars. Generator for G1 is labeled asG, generator for G2 is labeled asH, otherwise we assume random point on a curve in a correct subgroup.0means either scalar zero or point of infinity.1means either scalar one or multiplicative identity.group_orderis a main subgroup order.e(P, Q)means pairing operation wherePis in G1,Qis in G2.", "Reference Implementation": "There is a various choice of existing implementations of the curve operations. It may require extra work to add an ABI:\n\t- Code bases with fixed parameters\n\t  - Rust: matter-labs\n\t  - C++: matter-labs\n\t- Original implementation linked in Zexe paper in Rust: github.com/scipr-lab/zexe\n\t- Standalone in Go: github.com/kilic/bls12-377", "Security Considerations": "Strictly following the spec will eliminate security implications or consensus implications in a contrast to the previous BN254 precompile.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2542, "url": "https://eips.ethereum.org/EIPS/eip-2542", "title": "New opcodes TXGASLIMIT and CALLGASLIMIT", "authors": ["Alex Forshtat\u00a0<", "forshtat1@gmail.com", ">"], "sections": {"EIP-2542: New opcodes TXGASLIMIT and CALLGASLIMIT": "A mechanism to allow smart contracts to access information on gas limits for the current transaction and execution frame.", "": "A mechanism to allow smart contracts to access information on gas limits for the current transaction and execution frame.", "Simple Summary": "A mechanism to allow smart contracts to access information on gas limits for the current transaction and execution frame.", "Abstract": "Currently, there is an existing opcode0x45 GASLIMITthat provides access to the block gas limit. While this information may be useful in some cases, it is probably not a value that smart contract developers may be concerned about. The opcode0x5a GASprovides the remaining gas, not the initial one. Also, it is worth noting how existing0x32 ORIGIN,0x33 CALLER,0x34 CALLVALUEand0x3a GASPRICEopcodes set a pattern of having access to both the transaction and current execution frame state.\nTBD: as 0x30 opcode range is exhausted, the proposed opcodes can be added to 0x50 range, or a new range can be added.", "Motivation": "As concepts of relaying, meta-transactions, gas fees, and account abstraction gain popularity, it becomes critical for some contracts to be able to track gas expenditure with absolute precision. Without access to this data on an EVM level, such contracts resort to approximation, mimicking EVM logic on-chain, and some use-cases even become infeasible.", "Specification": "If block.number >= TBD, add three new opcodes:", "Rationale": "Consider a solidity smart contract that wants to know how much gas the entire transaction or a part of it had consumed. It is not entirely possible with the current EVM. With proposed changes, using a pseudo-Solidity syntax, this information would be easily available:", "Backwards Compatibility": "This proposal introduces two new opcodes and renames an existing one, but stays fully backwards compatible apart from that.", "Forwards Compatibility": "A major consideration for this proposal is its alignment with one or many possible future modifications to the EVM:", "Security considerations": "Existing smart contracts are not affected by this change.Smart contracts that will use proposed opcodes must not use them for the core of any security features, but only as a source of information about their execution environment.", "Implementation": "The implementations must be completed before any EIP is given status \u201cFinal\u201d, but it need not be completed before the EIP is accepted. While there is merit to the approach of reaching consensus on the specification and rationale before writing code, the principle of \u201crough consensus and running code\u201d is still useful when it comes to resolving many discussions of API details.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2583, "url": "https://eips.ethereum.org/EIPS/eip-2583", "title": "Penalty for account trie misses", "authors": ["Martin Holst Swende\u00a0(", "@holiman", ")"], "sections": {"EIP-2583: Penalty for account trie misses": "This EIP introduces a gas penalty for opcodes which access the account for trie non-existent accounts.", "": "This EIP introduces a gas penalty for opcodes which access the account for trie non-existent accounts.", "Simple Summary": "This EIP introduces a gas penalty for opcodes which access the account for trie non-existent accounts.", "Abstract": "This EIP adds a gas penalty for accesses to the account trie, where the address being looked up does not exist. Non-existing accounts can be used in \nDoS attacks, since they bypass cache mechanisms, thus creating a large discrepancy between \u2018normal\u2019 mode of execution and \u2018worst-case\u2019 execution of an opcode.", "Motivation": "As the ethereum trie becomes more and more saturated, the number of disk lookups that a node is required to do in order to access a piece of state increases too. This means that checking e.g.EXTCODEHASHof an account at block5wasinherentlya cheaper operation that it is at, say8.5M.", "Specification": "We define the constantpenaltyasTBD(suggested2000gas).", "Detailed specification": "These are the opcodes which triggers lookup into the main account trie:", "Notes on Call-derivatives": "ACALLtriggers a lookup of theCALLdestination address. The base cost forCALLis at700gas. A few other characteristics determine the actual gas cost of a call:", "Note onSELFDESTRUCT": "TheSELFDESTRUCTopcode also triggers an account trie lookup of thebeneficiary. However, due to the following reasons, it has been omitted from having apenaltysince it already costs5Kgas.", "Clarifications:": "With this scheme, we could continue to price these operations based on the \u2018normal\u2019 usage, but gain protection from attacks that try to maximize disk lookups/cache misses. \nThis EIP does not modify anything regarding storage trie accesses, which might be relevant for a future EIP. However, there are a few crucial differences.", "Rationale": "With this scheme, we could continue to price these operations based on the \u2018normal\u2019 usage, but gain protection from attacks that try to maximize disk lookups/cache misses. \nThis EIP does not modify anything regarding storage trie accesses, which might be relevant for a future EIP. However, there are a few crucial differences.", "Determining thepenalty": "A transaction with10Mgas can today cause ~14Ktrie lookups.", "Backwards Compatibility": "This EIP requires a hard-fork.", "Ether transfers": "A regulartransactionfrom one EOA to another, with value, is not affected.", "Layer 2": "Regarding layer-2 backward compatibility, this EIP is a lot less disruptive than EIPs which modify thebasecost of an opcode. For state accesses, there are \nseldom legitimate scenarios where", "Other": "The contractDentacoinwould be affected.", "Test Cases": "The following cases need to be considered and tested:", "Security Considerations": "See \u2018Backwards Compatibility\u2019", "Implementation": "Not yet available.", "Alternative variants": "Bump all trie accesses withpenalty.EXTCODEHASHbecomes2700instead of700.", "Alt 1: Insta-refunds": "Bump all trie accesses withpenalty.EXTCODEHASHbecomes2700instead of700.", "Alt 2: Parent bail": "Usepenaltyas described, but if a child context goes OOG on thepenalty, then the remainder is subtracted from the \nparent context (recursively).", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2584, "url": "https://eips.ethereum.org/EIPS/eip-2584", "title": "Trie format transition with overlay trees", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")"], "sections": {"EIP-2584: Trie format transition with overlay trees": "This EIP proposes a method to convert the state trie format from hexary to binary: new values are directly stored in a binary trie \u201claid over\u201d the hexary trie. Meanwhile, the hexary trie is converted to a binary trie in the background. When the process is finished, both layers are merged.", "": "This EIP proposes a method to convert the state trie format from hexary to binary: new values are directly stored in a binary trie \u201claid over\u201d the hexary trie. Meanwhile, the hexary trie is converted to a binary trie in the background. When the process is finished, both layers are merged.", "Simple Summary": "This EIP proposes a method to convert the state trie format from hexary to binary: new values are directly stored in a binary trie \u201claid over\u201d the hexary trie. Meanwhile, the hexary trie is converted to a binary trie in the background. When the process is finished, both layers are merged.", "Abstract": "This EIP describes a four phase process to complete the conversion.", "Motivation": "There is a long running interest in switching the state trie from a hexary format to a binary format, for reasons pertaining to proof and storage sizes. The conversion process poses a catch-up issue, caused by the sheer size of the full state: it can not be translated in a reasonable time (i.e. on the same order of magnitude as the block time).", "Specification": "This specification follows the notation introduced by theYellow Paper. Prior to reading it is advisable to be familiar with the Yellow Paper.", "Binary tries": "This EIP assumes that a binary trie is defined like the MPT, except that:", "Phase 1": "Leth\u2081be the previously agreed-upon block height at which phase 1 starts, andh\u2082the block at which phase 2 starts. For each block of height h\u2081 \u2264h< h\u2082:", "Phase 2": "This phase differs from the previous one on the following points:", "Phase 3": "Phase 3 is the same as phase 2, except for the following change:", "Rationale": "Methods that have been discussed until now include a \u201cstop the world\u201d approach, in which the chain is stopped for the significant amount of time that is required by the conversion, and a \u201ccopy on write\u201d approach, in which branches are converted upon being accessed.\nThe approach suggested here has the advantage that the chain continues to operate normally during the conversion process, and that the tree is fully converted to a binary format, in a predictable time.", "Backwards Compatibility": "This requires a fork and will break backwards compatibility, as the hashes and block formats will necessarily be different. This will cause a fork in clients that don\u2019t implement the overlay tree, and those that do not accept the new binary root. No mitigation is proposed, as this is a hard fork.", "Test Cases": "A prototype version of the conversion process (phase 1) is available forgethinthis PR.", "Implementation": "A prototype version of the conversion process (phase 1) is available forgethinthis PR.", "Security Considerations": "There are three attack vectors that I can foresee:", "Community feedback": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2593, "url": "https://eips.ethereum.org/EIPS/eip-2593", "title": "Escalator fee market change for ETH 1.0 chain", "authors": ["Dan Finlay\u00a0<", "dan@danfinlay.com", ">"], "sections": {"EIP-2593: Escalator fee market change for ETH 1.0 chain": "The current \u201cfirst price auction\u201d fee model in Ethereum is inefficient and needlessly costly to users. This EIP proposes a way to replace this with a mechanism that allows dynamically priced transaction fees and efficient transaction price discovery.", "": "The current \u201cfirst price auction\u201d fee model in Ethereum is inefficient and needlessly costly to users. This EIP proposes a way to replace this with a mechanism that allows dynamically priced transaction fees and efficient transaction price discovery.", "Simple Summary": "The current \u201cfirst price auction\u201d fee model in Ethereum is inefficient and needlessly costly to users. This EIP proposes a way to replace this with a mechanism that allows dynamically priced transaction fees and efficient transaction price discovery.", "Abstract": "Based onThe Agoric Papers.", "Motivation": "Ethereum currently prices transaction fees using a simple first-price auction, which leads to well documented inefficiencies (some of which are documented inEIP-1559) when users are trying to estimate what price will get a transaction included in a block, especially during times of price volatility and full blocks.", "User Strategies Under Various Conditions and Algorithms": "First I will suggest a likely optimal strategy for different players under the conditions of the different algorithms being considered.", "User Results Under Various Conditions and Algorithms": "Now I will consider the ultimate results of the strategies listed above. Are users happy under these conditions? Did we save users money? Were users who wanted urgent inclusion able to secure it?", "Specification": "Client-Wide Parameters", "Backwards Compatibility": "Since a currentgasPricetransaction is effectively a flat-escalated transaction bid, it is entirely compatible with this model, and so there is no concrete requirement to deprecate current transaction processing logic, allowing cold wallets and hardware wallets to continue working for the foreseeable future.", "Test Cases": "TBD", "Implementation": "TBD", "Security Considerations": "The security considerations for this EIP are:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2666, "url": "https://eips.ethereum.org/EIPS/eip-2666", "title": "Repricing of precompiles and Keccak256 function", "authors": ["Alex Vlasov\u00a0(", "@shamatar", ")"], "sections": {"EIP-2666: Repricing of precompiles and Keccak256 function": "This EIP tries to set prices of certain precompiles and built-in EVM function to be in line with their performance, consumed resources and newer changes in EVM itself.", "": "This EIP tries to set prices of certain precompiles and built-in EVM function to be in line with their performance, consumed resources and newer changes in EVM itself.", "Simple Summary": "This EIP tries to set prices of certain precompiles and built-in EVM function to be in line with their performance, consumed resources and newer changes in EVM itself.", "Abstract": "Costs of many precompiles and built-in functions are invalid at the current state of the clients. This EIP contains a list of changes to the pricing formulas to better reflect underlying computations\u2019 structure.", "Motivation": "Historical pricing for these functions in EVM does not reflect inner structure of the underlying computations (inner structure of the hash functions).", "Specification": "Ifblock_number >= Xset the gas cost of the following precompiles and Keccak256 opcode:", "Rationale": "Cost of functions being executed must accurately reflect real CPU time spent on computations, so benchmarking was performed for current precompiles and Keccak256 function to measure running time versus input parameters.", "Detailed summary of repricing approach": "This EIP relies on two facts:", "Benchmarks on the most popular clients": "Necessary benchmarks for EIP-2666 were provided by the clients and raw form is assembled inhere", "Tooling and data": "Reference material (from benchmarks of different clients) with raw data can be foundhere.", "Note on formulas structure": "There are terms in formulas that look likeA * 1and those are explicitly not combined to theBcoefficient to reflect that hash of an empty byte array requires to perform a round of hashing anyway.", "Backwards Compatibility": "Precompile repricings has happened in a past and can be considered standard procedure. Gas costs of many contracts is expected to reduce that may break re-entrancy protection measures based on fixed gas costs. In any case, such protection should have never been considered good and final.", "Test Cases": "Let\u2019s consider a simple example of Keccak256 hash of0,64and160bytes that can is a simple sanity check for implementation.", "Implementation": "There is no reference implementation at the time of writing as it requires just a simple change of constants in major clients.", "Security Considerations": "As described in backward compatibility section in some cases reduction of cost may allow e.g. re-entrancy that was not expected before, but we think that re-entrancy protection based on fixed gas costs is anyway flawed design decision.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2803, "url": "https://eips.ethereum.org/EIPS/eip-2803", "title": "Rich Transactions", "authors": ["Micah Zoltu\u00a0(", "@MicahZoltu", ")"], "sections": {"EIP-2803: Rich Transactions": "If a transaction has atoof addressx, then thedataof the transaction will be treated as EVM bytecode and it will be executed from the context of theCALLERof the transaction (aka: the transaction signer).", "Support 'rich transactions' by allowing transactions from externally owned accounts to execute bytecode directly.": "If a transaction has atoof addressx, then thedataof the transaction will be treated as EVM bytecode and it will be executed from the context of theCALLERof the transaction (aka: the transaction signer).", "Abstract": "If a transaction has atoof addressx, then thedataof the transaction will be treated as EVM bytecode and it will be executed from the context of theCALLERof the transaction (aka: the transaction signer).", "Motivation": "Many Ethereum DApps presently require users to approve multiple transactions in order to produce one effect - for example, the common pattern of first approving a contract to spend a token, then calling that contract. This results in a poor user-experience, and complicates the experience of interacting with DApps.", "Specification": "A new reserved address is specified atx, in the range used for precompiles. When a transaction is sent to this address from an externally owned account, the payload of the transaction is treated as EVM bytecode, and executed with the signer of the transaction as the current account. For clarity:", "Rationale": "The intent of this EIP is for the new precompile to act in all ways possible like aDELEGATECALLfrom an externally owned account. Some changes are required to reflect the fact that the code being executed is not stored on chain, and for special cases such asSELFDESTRUCT, to prevent introducing new edge-cases such as the ability to zero-out an EOA\u2019s nonce.", "Backwards Compatibility": "This EIP introduces a new feature that will need to be implemented in a future hard fork. No backwards compatibility issues with existing code are expected.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2926, "url": "https://eips.ethereum.org/EIPS/eip-2926", "title": "Chunk-Based Code Merkleization", "authors": ["Sina Mahmoodi\u00a0(", "@s1na", ")", "Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-2926: Chunk-Based Code Merkleization": "Code merkleization, along with binarification of the trie and gas cost bump of state accessing opcodes, are considered as the main levers for decreasing block witness sizes in stateless or partial-stateless Eth1x roadmaps. Here we specify a fixed-sized chunk approach to code merkleization and outline how the transition of existing contracts to this model would look like.", "": "Code merkleization, along with binarification of the trie and gas cost bump of state accessing opcodes, are considered as the main levers for decreasing block witness sizes in stateless or partial-stateless Eth1x roadmaps. Here we specify a fixed-sized chunk approach to code merkleization and outline how the transition of existing contracts to this model would look like.", "Abstract": "Code merkleization, along with binarification of the trie and gas cost bump of state accessing opcodes, are considered as the main levers for decreasing block witness sizes in stateless or partial-stateless Eth1x roadmaps. Here we specify a fixed-sized chunk approach to code merkleization and outline how the transition of existing contracts to this model would look like.", "Motivation": "Bytecode is currently thesecond contributorto block witness size, after the proof hashes. Transitioning the trie from hexary to binary reduces the hash section of the witness by 3x, thereby making code the first contributor. By breaking contract code into chunks and committing to those chunks in a merkle tree, stateless clients would only need the chunks that were touched during a given transaction to execute it.", "Specification": "This specification assumes thatEIP-2584is deployed, and the merkleization rules and gas costs are proposed accordingly. What follows is structured to have two sections:", "Constants and Definitions": "For an account recordAwith codeC, the fieldA.codeHashis replaced withcodeRoot.codeRootisEMPTY_CODE_ROOTifCis empty. Otherwise it contains the root ofcodeTrie, abinary triewith the following leaves:", "Code merkleization": "For an account recordAwith codeC, the fieldA.codeHashis replaced withcodeRoot.codeRootisEMPTY_CODE_ROOTifCis empty. Otherwise it contains the root ofcodeTrie, abinary triewith the following leaves:", "Updating existing code (transition process)": "The transition process involves reading all contracts in the state and applying the above procedure to them. A benchmark showing how long this process will take is still pending, but intuitively it should take longer than the time between two blocks (in the order of hours). Hence we recommend clients to pre-process the changes before the EIP is activated.", "Rationale": "The Ethereum mainnet state is encoded as of now in a hexary Merkle Patricia Tree. As part of the Eth1x roadmap, a transition to abinary triehas beeninvestigatedwith the goal of reducing witness sizes. Because code chunks are also stored in the trie, this EIP would benefit from the witness size reduction offered by the binarification. Therefore we have decided to explicitly stateEIP-2584to be a requirement of this change. Note that if code merkleization is included in a hard-fork beforehand, then all code must be re-merkleized after the binary transition.", "Hexary vs binary trie": "The Ethereum mainnet state is encoded as of now in a hexary Merkle Patricia Tree. As part of the Eth1x roadmap, a transition to abinary triehas beeninvestigatedwith the goal of reducing witness sizes. Because code chunks are also stored in the trie, this EIP would benefit from the witness size reduction offered by the binarification. Therefore we have decided to explicitly stateEIP-2584to be a requirement of this change. Note that if code merkleization is included in a hard-fork beforehand, then all code must be re-merkleized after the binary transition.", "Chunk size": "The current recommended chunk size of 32 bytes has been selected based on a few observations. Smaller chunks are more efficient (i.e. have higherchunk utilization), but incur a larger hash overhead (i.e. number of hashes as part of the proof) due to a higher trie depth. Larger chunks are less efficient, but incur less hash overhead. We plan to run a larger experiment comparing various chunk sizes to arrive at a final recommendation.", "First instruction offset": "ThefirstInstructionOffsetfields allows safe jumpdest analysis when a client doesn\u2019t have all the chunks, e.g. a stateless clients receiving block witnesses.", "Gas cost of code-accessing opcodes": "How merkleized code is stored in the client database affects the performance of code-accessing opcodes, i.e: CALL, CALLCODE, DELEGATECALL, STATICCALL, EXTCODESIZE, EXTCODEHASH, and EXTCODECOPY. Storing the code trie with all intermediate nodes in the database implies multiple look-ups to fetch the code of the callee, which is more than the current one look-up (excluding the trie traversal to get the account) required. Note CODECOPY and CODESIZE are not affected since the code for the current contract has already been loaded to memory.", "Different chunking logic": "We have considered an alternative option to package chunks, where each chunk is prepended with itschunkLengthand would only contain complete opcodes (i.e. any multi-byte opcode not fitting theCHUNK_SIZEwould be deferred to the next chunk).", "RLP and SSZ": "To remain consistent with the binary transition proposal we avoid using RLP for serializing the leaf values. We have furthermore considered SSZ for both serializing data and merkleization and remain open to adopting it, but decided to use the binary trie format for simplicity.", "Metadata fields": "The metadata fieldsversion,codeLenandcodeHashare added mostly to facilitate a cheaper implementation ofEXTCODESIZEandEXTCODEHASHin a stateless paradigm. The version field allows for differentiating between bytecode types (e.g.EVM1.5/EIP-615,EIP-2315, etc.) or code merkleization schemes (or merkleization settings, such as largerCHUNK_SIZE) in future.", "The keys in the code trie (andKEY_LENGTH)": "As explained in the specification above, the keys in the code trie are indices of thechunksarray. Having a key length of 2 bytes means the trie can address 65536 - 3 (minus metadata fields) chunks, which corresponds to ~2Mb code size. That allows for roughly ~85x increase in the code size limit in future without requiring a change in merkleization.", "Alternate values of codeRoot for EoAs": "This proposal changes the meaning of the fourth field (codeHash) of the account. Prior to this change, that field represents the Keccak-256 hash of the bytecode, which is logically hash of an empty input for EoAs.", "Backwards Compatibility": "From the perspective of contracts, the design aims to be transparent, with the exception of changes in gas costs.", "Test Cases": "TBD", "Implementation": "The implementation of the chunking and merkleization logic in Typescript can be foundhere, and in Pythonhere. Please note neither of these examples currently use a binary tree.", "Security Considerations": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2936, "url": "https://eips.ethereum.org/EIPS/eip-2936", "title": "EXTCLEAR Opcode For SELFDESTRUCTed contracts", "authors": ["William Morriss\u00a0(", "@wjmelements", ")"], "sections": {"EIP-2936: EXTCLEAR Opcode For SELFDESTRUCTed contracts": "Enable new opcode to clear storage forSELFDESTRUCTEDed contracts.", "": "Enable new opcode to clear storage forSELFDESTRUCTEDed contracts.", "Simple Summary": "Enable new opcode to clear storage forSELFDESTRUCTEDed contracts.", "Abstract": "ChangesSELFDESTRUCT(0xff) to not clear any storage and adds a newEXTCLEAR(0x5c) opcode that will clear a specific storage slot for a contract that has previously been self destructed.", "Motivation": "SELFDESTRUCT(0xFF) is unnecessarily complex because it clears an unbounded amount of contract storage.\nIt is computationally expensive for nodes to track all of the storage used in every contract in case the contractSELFDESTRUCTs.\nFurther, contracts can be re-initialized usingCREATE2(0xF5), and thenSLOAD(0x54) prior storage.\nTherefore, several ethereum clients do not clear storage at all, and just check if the contract was initiated sinceSSTORE(0x55) duringSLOAD.CREATE2was not intended to complicateSLOAD, and this change reverts that complexity.\nAlso, bugs in this implementation could split the network.", "Specification": "AfterFORK_BLOCK_NUM, a new opcode,EXTCLEAR, is enabled at0x5Cto clear storage forSELFDESTRUCTed contracts.EXTCLEAR:", "Rationale": "0x5Cis available in the same range asSSTOREandSLOAD.", "Backwards Compatibility": "A reincarnation upgrade mechanism that expects all internal storage to be cleared might break, but such an upgrade mechanism would allow adaptation to this new behavior.", "Test Cases": "TODO", "Implementation": "Implementation is required on all major clients to add the opcode.", "Security Considerations": "A reincarnated contract that does not expect its state to be cleared by malicious actors SHOULD reinitialize itself to avoid antagonisticEXTCLEAR.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2937, "url": "https://eips.ethereum.org/EIPS/eip-2937", "title": "SET_INDESTRUCTIBLE opcode", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-2937: SET_INDESTRUCTIBLE opcode": "Add aSET_INDESTRUCTIBLE (0xA8)opcode that prevents the contract from callingSELFDESTRUCT (0xFF).", "": "Add aSET_INDESTRUCTIBLE (0xA8)opcode that prevents the contract from callingSELFDESTRUCT (0xFF).", "Simple Summary": "Add aSET_INDESTRUCTIBLE (0xA8)opcode that prevents the contract from callingSELFDESTRUCT (0xFF).", "Abstract": "The intended use case would be for contracts to make their first byte of code be theSET_INDESTRUCTIBLEopcode if they wish to serve as libraries that guarantee to users that their code will exist unmodified forever. This is useful in account abstraction as well as other contexts.", "Motivation": "The intended use case would be for contracts to make their first byte of code be theSET_INDESTRUCTIBLEopcode if they wish to serve as libraries that guarantee to users that their code will exist unmodified forever. This is useful in account abstraction as well as other contexts.", "Specification": "Add a transaction-wide global variableglobals.indestructible: Set[Address](i.e. a variable that operates the same way as the selfdestructs set), initialized to the empty set.", "Rationale": "Alternative proposals to this include:", "Backwards Compatibility": "TBD", "Security Considerations": "This breaks forward compatibility withsomeforms of state rent, which would simply delete contracts that get too old without paying some maintenance fee. However, this is not the case with all state size control schemes; for example this is not an issue if we useReGenesis.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2938, "url": "https://eips.ethereum.org/EIPS/eip-2938", "title": "Account Abstraction", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")", "Matt Garnett\u00a0(", "@lightclient", ")", "Will Villanueva\u00a0(", "@villanuevawill", ")", "Sam Wilson\u00a0(", "@SamWilsn", ")"], "sections": {"EIP-2938: Account Abstraction": "Account abstraction (AA) allows a contract to be the top-level account that pays fees and starts transaction execution.", "": "Account abstraction (AA) allows a contract to be the top-level account that pays fees and starts transaction execution.", "Simple Summary": "Account abstraction (AA) allows a contract to be the top-level account that pays fees and starts transaction execution.", "Abstract": "See also:https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020and the links therein for historical work and motivation.", "Motivation": "The existing limitations preclude innovation in a number of important areas, particularly:", "Specification": "AfterFORK_BLOCK, the following changes will be recognized by the protocol.", "Single Tenant": "AfterFORK_BLOCK, the following changes will be recognized by the protocol.", "Single Tenant+": "If theindestructible contracts EIPis added, Single Tenant AA can be adapted to allow forDELEGATECALLduring transaction verification: during execution of a new AA transaction, external state access that reads code (EXTCODESIZE,EXTCODEHASH,EXTCODECOPY,CALLCODE,DELEGATECALL) of any contract whose first byte is theSET_INDESTRUCTIBLEopcode is no longer banned. However, calls to anything but thetargetor a precompile that change thecallee(i.e., calls other thanCALLCODEandDELEGATECALL) are still not permitted.", "Multi-Tenant & Beyond": "In a later stage, we can add support for multiple pending transactions per account in the mempool. The main challenge here is that a single transaction can potentially cause state changes that invalidate all other transactions to that same account. Additionally, if we naively prioritize transactions by gasprice, there is an attack vector where the user willing to pay the highest gasprice publishes many (mutually exclusive) versions of their transaction with small alterations, thereby pushing everyone else\u2019s transactions out of the mempool.", "Rationale": "The core problem in an account abstraction setup is always that miners and network nodes need to be able to verify that a transaction that they attempt to include, or rebroadcast, will actually pay a fee. Currently, this is fairly simple, because a transaction is guaranteed to be includable and pay a fee as long as the signature and nonce are valid and the balance and gasprice are sufficient. These checks can be done quickly.", "Nonces still enshrined in single-tenant AA": "Nonces are still enforced in single-tenant AA to ensure that single-target AA does not break the invariant that each transaction (and hence each transaction hash) can only be included in the chain once. While there is some limited value in allowing arbitrary-order transaction inclusion in single-tenant AA, there is not enough value to justify breaking that invariant.", "Nonces are exposed to the EVM": "This is done to allow signature checking done in validation code to validate the nonce.", "Replay Protection": "One of the above two approaches (requiringSET_INDESTRUCTIBLEor modifyingSELFDESTRUCTbehavior) must be implemented so that nonces cannot be reused. It must be a consensus change, and not simply part ofAA_PREFIX, so that transaction hash uniqueness is maintained.", "Miners refuse transactions that access external data or the target\u2019s own balance, before PAYGAS": "An important property of traditional transactions is that activity happening as part of transactions that originate outside of some given account X cannot make transactions whose sender is X invalid. The only state change that an outside transaction can impose on X is increasing its balance, which cannot invalidate a transaction.", "AA transactions must call contracts with prefix": "The prelude is used to ensure thatonlyAA transactions can call the contract. This is another measure taken to ensure the invariant described above. If this check did not occur, it would be possible for a transaction originating outside some AA account X to call into X and make a storage change, forcing transactions targeting that account to be reprocessed at the cost of a mere 5000 gas.", "Multi-tenant AA": "Multi-tenant AA extends single-tenant AA bybetter handling cases where distinct and uncoordinated users attempt to send transactions for/to the same account and those transactions may interfere with each other.", "Backwards Compatibility": "This AA implementation preserves the existing transaction type. The use ofassert origin == callerto verify that an account is an EOA remains sound, but is not extensible to AA accounts; AA transactions will always haveorigin == AA_ENTRY_POINT.", "Test Cases": "See:https://github.com/quilt/tests/tree/account-abstraction", "Implementation": "See:https://github.com/quilt/go-ethereum/tree/account-abstraction", "Security Considerations": "Seehttps://ethresear.ch/t/dos-vectors-in-account-abstraction-aa-or-validation-generalization-a-case-study-in-geth/7937for an analysis of DoS issues.", "Re-validation": "When a transaction enters the mempool, the client is able to quickly ascertain whether the transaction is valid. Once it determines this, it can be confident that the transaction will continue to be valid unless a transaction from the same account invalidates it.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2970, "url": "https://eips.ethereum.org/EIPS/eip-2970", "title": "IS_STATIC opcode", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-2970: IS_STATIC opcode": "Add aIS_STATIC (0x4A)opcode that pushes1if the current context is static (ie. the execution is in aSTATICCALLor a descendant thereof, so state-changing operations are not possible), and0if it is not.", "": "Add aIS_STATIC (0x4A)opcode that pushes1if the current context is static (ie. the execution is in aSTATICCALLor a descendant thereof, so state-changing operations are not possible), and0if it is not.", "Simple Summary": "Add aIS_STATIC (0x4A)opcode that pushes1if the current context is static (ie. the execution is in aSTATICCALLor a descendant thereof, so state-changing operations are not possible), and0if it is not.", "Abstract": "The main intended use case is to allow account abstraction (EIP 2938) to be extended so that accounts can allow static calls from the outside (which are harmless to AA\u2019s security model) but not state-changing calls.", "Motivation": "The main intended use case is to allow account abstraction (EIP 2938) to be extended so that accounts can allow static calls from the outside (which are harmless to AA\u2019s security model) but not state-changing calls.", "Specification": "Add aIS_STATIC (0x4A)opcode that pushes1if the current context is static (ie. the execution is in aSTATICCALLor a descendant thereof, so state-changing operations are not possible), and0if it is not.", "Rationale": "Determining staticness is already possibly using the following hacky technique: make aCALLwith limited gas, and inside thatCALLissue oneLOGand exit. If the context is static, theCALLwould fail and leave a 0 on the stack; if the context is non-static, theCALLwould succeed. However, this technique is fragile against changes to gas costs, and is needlessly wasteful. Hence, the status quo neither allows a reasonably effective way of determining whether or not the context is static, nor provides any kind of invariant that executions that do not fail outright will execute the same way in a static and non-static context. This EIP provides a cleaner way of determining staticness.", "Backwards Compatibility": "TBD", "Security Considerations": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2997, "url": "https://eips.ethereum.org/EIPS/eip-2997", "title": "IMPERSONATECALL Opcode", "authors": ["Sergio Demian Lerner\u00a0(", "@SergioDemianLerner", ")"], "sections": {"EIP-2997: IMPERSONATECALL Opcode": "Add a new opcode,IMPERSONATECALLat0xf6, which is similar in idea toCALL (0xF1), except that it impersonates a sender, i.e. the callee sees a sender different from the real caller. The impersonated sender address is derived from the real caller address and a salt.", "": "Add a new opcode,IMPERSONATECALLat0xf6, which is similar in idea toCALL (0xF1), except that it impersonates a sender, i.e. the callee sees a sender different from the real caller. The impersonated sender address is derived from the real caller address and a salt.", "Abstract": "Add a new opcode,IMPERSONATECALLat0xf6, which is similar in idea toCALL (0xF1), except that it impersonates a sender, i.e. the callee sees a sender different from the real caller. The impersonated sender address is derived from the real caller address and a salt.", "Motivation": "This proposal enables native multi-user wallets (wallets that serve multiple users) that can be commanded by EIP-712 based messages and therefore enable meta-transactions. Multi-user wallets also enable the aggregation of transfer operations in batches similar to rollups, but maintaining the same address space as normal onchain transactions, so the sender\u2019s wallet does not need to be upgraded to support sinding ether or tokens to a user of a multi-user wallet. \nAdditionally, many times a sponsor company wants to deploy non-custodial smart wallets for all its users. The sponsor does not want to pay the deployment cost of each user contract in advance. Counterfactual contract creation enables this, yet it forces the sponsor to create the smart wallet (or a proxy contract to it) when the user wants to transfer ether or tokens out of his/her account for the first time. This proposal avoids this extra cost, which is at least 42000 gas per user.", "Specification": "IMPERSONATECALL:0xf6, takes 7 operands:", "Computation of impersonated sender": "The impersonated sender address is computed askeccak256( 0xff ++ address ++ salt ++ zeros32)[12:].", "Notes": "Even ifIMPERSONATECALLrequires hashing 3 words, implying an additional cost of 180 gas, we think the benefit of accounting for hashing doesn\u2019t not compensate increasing the complexity of the implementation.", "Rationale": "Even ifIMPERSONATECALLrequires hashing 3 words, implying an additional cost of 180 gas, we think the benefit of accounting for hashing doesn\u2019t not compensate increasing the complexity of the implementation.", "Clarifications": "The opcode number0xf6is currently unused and results in an out-of-gas (OOG) exception.  Solidity uses theINVALID (0xfe)opcode (calledABORTby EIP-1803) to raise OOG exceptions, so the0xf6opcode does not appear in normal Solidity programs. Programmers are already advised not to include this opcode in contracts written in EVM assembly.  Therefore is does not pose any backward compatibility risk.", "Backward Compatibility": "The opcode number0xf6is currently unused and results in an out-of-gas (OOG) exception.  Solidity uses theINVALID (0xfe)opcode (calledABORTby EIP-1803) to raise OOG exceptions, so the0xf6opcode does not appear in normal Solidity programs. Programmers are already advised not to include this opcode in contracts written in EVM assembly.  Therefore is does not pose any backward compatibility risk.", "Test Cases": "We present 4 examples of impersonated address derivation:", "Security Considerations": "The address derivation scheme prevents address collision with another deployed contract or an externally owned account, as the impersonated sender address is derived from the real caller address and a salt.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3026, "url": "https://eips.ethereum.org/EIPS/eip-3026", "title": "BW6-761 curve operations", "authors": ["Youssef El Housni\u00a0(", "@yelhousni", ")", "Michael Connor\u00a0(", "@iAmMichaelConnor", ")", "Aurore Guillevic\u00a0<", "aurore.guillevic@inria.fr", ">", "hujw77\u00a0(", "@hujw77", ")"], "sections": {"EIP-3026: BW6-761 curve operations": "This precompile adds operations for the BW6-761 curve (from the EY/InriaOptimized and secure pairing-friendly elliptic curves suitable for one layer proof compositionresearch paper) as a precompile in a set necessary toefficientlyperform verification of one-layer composed zkSNARKs proofs.\nIfblock.number >= Xwe introducesevenseparate precompiles to perform the following operations (addresses to be determined):", "Precompiles for BW6-761 curve operations": "This precompile adds operations for the BW6-761 curve (from the EY/InriaOptimized and secure pairing-friendly elliptic curves suitable for one layer proof compositionresearch paper) as a precompile in a set necessary toefficientlyperform verification of one-layer composed zkSNARKs proofs.\nIfblock.number >= Xwe introducesevenseparate precompiles to perform the following operations (addresses to be determined):", "Abstract": "This precompile adds operations for the BW6-761 curve (from the EY/InriaOptimized and secure pairing-friendly elliptic curves suitable for one layer proof compositionresearch paper) as a precompile in a set necessary toefficientlyperform verification of one-layer composed zkSNARKs proofs.\nIfblock.number >= Xwe introducesevenseparate precompiles to perform the following operations (addresses to be determined):", "Motivation": "This EIP is based on and tends to replace matter-labs\u2019 proposol for significant performance reasons. In most applications, BW6-761 is used as an outer curve to BLS12-377 considered inEIP-2539.\nThe motivation of this precompile is to allow efficient one-layer composition of SNARK proofs. Currently this is done by Zexe using the BLS12-377/CP6-782 pair of curves. This precompile proposes a replacement of CP6-782 by BW6-761, which allows much faster operations. For example, it was shown that verifying a Groth16 proof with BW6-761 is 30 times faster than with CP6-782.", "Proposed addresses table": "Curve parameters:", "Specification": "Curve parameters:", "Encoding": "To encode points involved in the operation one has to encode elements of only the base field.", "ABI for operations": "G1 addition call expects384bytes as an input that is interpreted as the byte concatenation of two G1 points (point-encoded as192bytes each). Output is a point-encoding of the addition operation result.", "Prevention of DDoS on error handling": "This precompile performs extensive computations and in case of any errors during execution itMUSTconsume all gas from the gas schedule for the corresponding operation.", "Gas schedule": "180gas", "Rationale": "Gas costs are based onEIP-1962estimation strategy (but do not fully include yet parsing of ABI, decoding and encoding of the result as a byte array).", "Gas estimation strategy": "Gas cost is derived by taking the average timing of the same operations over different implementations and assuming a constant30 MGas/second. Since the execution time is machine-specific, this constant is determined based on execution times ofECRECOVERandBNPAIRprecompiles on my machine and their proposed gas price (43.5 MGas/sfor ECRECOVER and16.5 MGas/sfor BNPAIR). Following are the proposed methods to time the precompile operations:", "Multiexponentiation as a separate call": "Explicit separate multiexponentiation operation that allows one to save execution time (so gas) by both the algorithm used (namely Peppinger algorithm) and (usually forgotten) by the fact thatCALLoperation in Ethereum is expensive (at the time of writing), so one would have to pay non-negigible overhead if e.g. for multiexponentiation of100points would have to call the multipication precompile100times and addition for99times (roughly138600would be saved).", "Explicit subgroup checks": "G2 subgroup check has the same cost as G1 subgroup check. Endomorphisms can be leverages to optimize this operation.", "Backwards Compatibility": "There are no backward compatibility questions.", "Test Cases": "Due to the large test parameters space we first provide properties that various operations must satisfy. We use additive notation for point operations, capital letters (P,Q) for points, small letters (a,b) for scalars. Generator for G1 is labeled asG, generator for G2 is labeled asH, otherwise we assume random point on a curve in a correct subgroup.0means either scalar zero or point of infinity.1means either scalar one or multiplicative identity.group_orderis a main subgroup order.e(P, Q)means pairing operation wherePis in G1,Qis in G2.", "Reference Implementation": "There is a various choice of existing implementations:", "Security Considerations": "Strictly following the spec will eliminate security implications or consensus implications in a contrast to the previous BN254 precompile.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3068, "url": "https://eips.ethereum.org/EIPS/eip-3068", "title": "Precompile for BN256 HashToCurve Algorithms", "authors": ["Dr. Christopher Gorman\u00a0(", "@chgormanMH", ")"], "sections": {"EIP-3068: Precompile for BN256 HashToCurve Algorithms": "This EIP defines a hash-to-curve precompile for use in BN256\nand would allow for cheaper BLS signature verification.", "": "This EIP defines a hash-to-curve precompile for use in BN256\nand would allow for cheaper BLS signature verification.", "Simple Summary": "This EIP defines a hash-to-curve precompile for use in BN256\nand would allow for cheaper BLS signature verification.", "Abstract": "There is currently no inexpensive way to perform BLS signature\nverification for arbitrary messages.\nThis stems from the fact that there is no precompiled contract\nin the EVM for a hash-to-curve algorithm for the BN256 elliptic curve.\nThe gas cost of calling a deterministic hash-to-curve algorithm\nwritten in Solidity is approximately that of one pairing check,\nalthough the latter requires an order of magnitude\nmore computation.\nThis EIP remedies this by implementing a hash-to-curve algorithm\nfor the BN256 G1 curve, which would reduce the cost of\nsignature verification to essentially that of the pairing check\nprecompiled contract.\nWe also include a hash-to-curve algorithm for the BN256 G2 group.", "Motivation": "The precompiled contracts inEIP-198andEIP-1108increased usage of cryptographic operations in the EVM\nby reducing the gas costs.\nIn particular, the cost reduction fromEIP-1108helps increase the use of SNARKs in Ethereum\nvia an elliptic curve pairing check;\nhowever, a hash-to-curve algorithm enabling arbitrary\nBLS signature verification on BN256 in the EVM was noticeably missing.\nThere is interest in having a precompiled contract which would allow\nfor signature verification, as notedhere.", "Specification": "Here is the pseudocode for theHashToG1function:", "Rationale": "The BaseToG1 algorithm is based on the original Fouque and Tibouchipaperwith modifications based on Wahby and Boneh\u2019spaper.\nThere is freedom in choosing the HashToBase function\nand this could easily be changed.\nWithin HashToBase, the particular hashing algorithm\n(Keccak256 in our case) could also be modified.\nIt may be desired to change the call tosign0at the end of BaseToG1 and BaseToTwist withis_square,\nas this would result in the same deterministic map to curve from the\nFouque and Tibouchipaperand ensure HashToG1 is indifferentiable from a random oracle;\nthey proved this result in their paper.\nIt may be possible to show that switching theis_squarecall withsign0does not affect indifferentiability,\nalthough this has not been proven.", "Backwards Compatibility": "There are no backward compatibility concerns.", "Test Cases": "TBD", "Implementation": "TBD", "Security Considerations": "Due to recentwork, the\n128-bit security promised by the BN256 elliptic curve no longer applies;\nthis was mentioned in the Cloudflare BN256library.\nThere has been some discussion on the exact security decrease\nfrom this advancement; see thesetwopapersfor different estimates.\nThe more conservative estimate puts the security of BN256 at\n100-bits.\nWhile this is likely still out of reach for many adversaries,\nit should give us pause.\nThis reduced security was noted in the recent MadNetwhitepaper,\nand this security concern was partially mitigated by\nrequiring Secp256k1 signatures of the partial group signatures\nin order for those partial signatures to be valid.\nFull disclosure: the author of this EIP works for MadHive,\nassisted in the development of MadNet, and\nhelped write the MadNet whitepaper.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3074, "url": "https://eips.ethereum.org/EIPS/eip-3074", "title": "AUTH and AUTHCALL opcodes", "authors": ["Sam Wilson\u00a0(", "@SamWilsn", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")", "Matt Garnett\u00a0(", "@lightclient", ")", "Micah Zoltu\u00a0(", "@micahzoltu", ")"], "sections": {"EIP-3074: AUTH and AUTHCALL opcodes": "This EIP introduces two EVM instructionsAUTHandAUTHCALL. The first sets a context variableauthorizedbased on an ECDSA signature. The second sends a call as theauthorizedaccount. This essentially delegates control of the externally owned account (EOA) to a smart contract.", "Allow externally owned accounts to delegate control to a contract.": "This EIP introduces two EVM instructionsAUTHandAUTHCALL. The first sets a context variableauthorizedbased on an ECDSA signature. The second sends a call as theauthorizedaccount. This essentially delegates control of the externally owned account (EOA) to a smart contract.", "Abstract": "This EIP introduces two EVM instructionsAUTHandAUTHCALL. The first sets a context variableauthorizedbased on an ECDSA signature. The second sends a call as theauthorizedaccount. This essentially delegates control of the externally owned account (EOA) to a smart contract.", "Motivation": "Adding more functionality to EOAs has been a long-standing feature request. The requests have spanned from implementing batching capabilities, allowing for gas sponsoring, expirations, scripting, and beyond. These changes often mean increased complexity and rigidity of the protocol. In some cases, it also means increased attack surfaces.", "Specification": "MAGICis used forEIP-3074signatures to prevent signature collisions with other signing formats.", "Conventions": "MAGICis used forEIP-3074signatures to prevent signature collisions with other signing formats.", "Constants": "MAGICis used forEIP-3074signatures to prevent signature collisions with other signing formats.", "Context Variables": "The context variableauthorizedshall indicate the active account forAUTHCALLinstructions in the current frame of execution. If set,authorizedshall only contain an account which has given the contract authorization to act on its behalf. An unset value shall indicate that no such account is set and that there is not yet an active account forAUTHCALLinstructions in the current frame of execution.", "AUTH(0xf6)": "A new opcodeAUTHshall be created at0xf6. It shall take three stack element inputs (the last two describing a memory range), and it shall return one stack element.", "AUTHCALL(0xf7)": "A new opcodeAUTHCALLshall be created at0xf7. It shall take seven stack elements and return one stack element. It matches the behavior of the existingCALL(0xF1) instruction, except where noted below.", "Rationale": "The signature format (yParity,r, ands) is fixed, so it might seem curious thatauthaccepts a dynamic memory range. The signature is placed in memory so thatauthcan be upgraded in the future to work with contract accounts (which might use non-ECDSA signatures) and not just EOAs.", "Signature in Memory": "The signature format (yParity,r, ands) is fixed, so it might seem curious thatauthaccepts a dynamic memory range. The signature is placed in memory so thatauthcan be upgraded in the future to work with contract accounts (which might use non-ECDSA signatures) and not just EOAs.", "Signing AddressauthArgument": "Includingauthority(the signing address) as an argument toauthallows future upgrades to the instruction to work with contract accounts, and not just EOAs.", "Reserving One Sixty-Fourth of Available Gas": "AUTHCALLwill not pass more than 63/64th of the available gas for the reasons enumerated inEIP-150.", "Throwing for UnsetauthorizedDuringAUTHCALL": "A well-behaved contract should never reach anAUTHCALLwithout having successfully setauthorizedbeforehand. The safest behavior, therefore, is to exit the current frame of execution immediately. This is especially important in the context of transaction sponsoring / relaying, which is expected to be one of the main use cases for this EIP. In a sponsored transaction, the inability to distinguish between a sponsee-attributable fault (like a failing sub-call) and a sponsor-attributable fault (like a failingAUTH) is especially dangerous and should be prevented because it charges unfair fees to the sponsee.", "Another Sponsored Transaction EIP": "There are two general approaches to separating the \u201cfee payer\u201d from the \u201caction originator\u201d.", "What to Sign?": "As originally written, this proposal specified a precompile with storage to track nonces. Since a precompile with storage is unprecedented, a revision moved replay protection into the invoker contract, necessitating a certain level of user trust in the invoker. Expanding on this idea of trusted invokers, the other signed fields were eventually eliminated, one by one, until onlyinvokerandcommitremained. To appease concerns about cross-chain replay attacks and irrevocable signatures, thechainIdandnoncefields returned to the signed message.", "Understandingcommit": "Earlier iterations of this EIP included mechanisms for replay protection, and also signed over value, gas, and other arguments toAUTHCALL. After further investigation, we revised this EIP to its current state: explicitly delegate these responsibilities to the invoker contract.", "Invoker Contracts": "The invoker contract is a trustless intermediary between the sponsor and sponsee. A sponsee signs overinvokerto require the transaction to be processed only by a contract they trust. This allows them to interact with sponsors without needing to trust them.", "On Call Depth": "The EVM limits the maximum number of nested calls, and naively allowing a sponsor to manipulate the call depth before reaching the invoker would introduce a griefing attack against the sponsee. That said, with the 63/64th gas rule, and the cost ofAUTHCALL, the stack is effectively limited to a much smaller depth than the hard maximum by thegasparameter.", "Source ofvalue": "In previous iterations of this EIP, it was thought that deducting value from an EOA mid-execution was problematic. This was due to an invariant of pending transactions which allows tx pools to statically determine the validity of a given transaction.", "Allowingtx.originas Signer": "Allowingauthorizedto equaltx.originhas the possibility to:", "AUTHCALLcheaper thanCALLwhen sending value": "Sending non-zero value withCALLincreases its cost by 9,000. Of that, 6,700 covers the increased overhead of the balance transfer and 2,300 is used as a stipend into the subcall to seed its gas counter.AUTHCALLdoes not provide a stipend and thus only charges the base 6,700.", "In-Protocol Revocation": "This EIP has goneback and forthon how to deal withAUTHmessage revocation. Without revocation, this EIP is a supremely powerful and flexible primitive for developers. However, it does have risk for users who use insecure and/or actively malicious invokers.", "Failing onEXTCODESIZEcheck": "InEIP-3607, it was determined that the protocol should reject any transaction which originates from an account with code. Although this EIP focused on transaction origination, the authors of EIP-3074 feel the intention is clear: an account that has both code and a known private key should not be allowed to make arbitrary calls on behalf of said account. Therefore, the property is upheld in this EIP. For full rationale, please refer toEIP-3607.", "Backwards Compatibility": "Although this EIP poses no issues for backwards compatibility, there are concerns that it limits future changes to accounts by further enshrining ECDSA signatures. For example, it might be desirable to eradicate the concept of EOAs altogether, and replace them with smart contract wallets that emulate the same behavior. This is fully compatible with the EIP as written, however, it gets tricky if users can then elect to \u201cupgrade\u201d their smart contract wallets to use other methods of authentication \u2013 e.g. convert into a multi-sig. Without any changes,AUTHwould not respect this new logic and continue allowing the old private key to perform actions on behalf of the account.", "Security Considerations": "The following is a non-exhaustive list of checks/pitfalls/conditions that invokersshouldbe wary of:", "Secure Invokers": "The following is a non-exhaustive list of checks/pitfalls/conditions that invokersshouldbe wary of:", "Sponsored Transaction Relayers": "It is possible for theauthorizedaccount to cause sponsored transaction relayers to spend gas without being reimbursed by either invalidating the authorization (i.e. increasing the account\u2019s nonce) or by sweeping the relevant assets out of the account. Relayers should be designed with these cases in mind, possibly by requiring a bond to be deposited or by implementing a reputation system.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3102, "url": "https://eips.ethereum.org/EIPS/eip-3102", "title": "Binary trie structure", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-3102: Binary trie structure": "Change the storage structure from hexary to binary, merge the account and storage tries, and use blake2b.", "": "Change the storage structure from hexary to binary, merge the account and storage tries, and use blake2b.", "Simple Summary": "Change the storage structure from hexary to binary, merge the account and storage tries, and use blake2b.", "Abstract": "This proposal presents a binary structure and merkelization rule for the account and storage tries, which are merged into a single \u201cstate\u201d trie. RLP and most of the MPT\u2019s optimizations are dropped to simplify the design. Keccak256 is replaced with blake2b.", "Motivation": "The current design of the Merkle Patricia Trie (MPT) uses an hexary trie. Hexary Merkle trees are more shallow than their binary counterparts, which means less hashing.\nOver the course of the 5 years of Ethereum\u2019s existence, it has become apparent that disk accesses are a greater bottleneck than hashing. Clients are therefore moving away from a storage model in which all internal nodes are stored, in favor of a flat (key, value) storage model first used by turbo-geth, in which the intermediate nodes are recalculated only when needed.", "Specification": "The trie structure is made up ofnodes. A nodeN \u2261 (N_l,N_r,N_p,N_v)has the following 4 components:", "Conventions": "The trie structure is made up ofnodes. A nodeN \u2261 (N_l,N_r,N_p,N_v)has the following 4 components:", "Notable changes from the hexary structure": "The trie structure is made up ofnodes. A nodeN \u2261 (N_l,N_r,N_p,N_v)has the following 4 components:", "The trie": "The trie structure is made up ofnodes. A nodeN \u2261 (N_l,N_r,N_p,N_v)has the following 4 components:", "Node merkelization rule": "Leaves and nodes that have no prefix are hashed according to the rule below:", "Rationale": "BLAKE2 offers better performance, which is key to compensate for the loss of performance associated to a ~4x increase in the number of nodes.", "blake2b": "BLAKE2 offers better performance, which is key to compensate for the loss of performance associated to a ~4x increase in the number of nodes.", "Merging of the account and storage tries": "The trend in clients is to store the keys and values in a \u201cflat\u201d database. Having the key of any storage slot prefixed with the address key of the account it belongs to helps grouping all of an account\u2019s data on disk, as well as simplifying the witness structure.", "Prefixes and extension nodes": "An alternative proposal has been made, which provides optimal witnesses. The trade-off is that extension nodes must be removed.", "2x32-byte inputs": "It has been requested to keep each node hash calculation as a function that takes two 256-bit integer as an input and outputs one 256-bit integer. This property is expected to play nice with circuit constructions and is therefore expected to greatly help with future zero-knowledge applications.", "Binary tries": "Binary tries have been chosen primarily because they reduce the witness size. In general, in anN-element tree with each element havingkchildren, the average length of a branch is roughly32 * (k-1) * log(N) / log(k)plus a few percent for overhead. 32 is the length of a hash; thek-1refers to the fact that a Merkle proof needs to provide allk-1sister nodes at each level, andlog(N) / log(k)is an approximation of the number of levels in the tree (eg. a tree where each node has 5 children, with 625 nodes total, would have depth 4, as625 = 5**4and solog(625) / log(5) = 4).", "Path length instead of bit prefix": "In order to remove the complexity associated with byte manipulation, only the bit-length of the extension is used to merkelize a node with a prefix.", "Value hashing": "Except for the code, all values in the trie are less than 32 bytes. EIP-2926 introduces code chunks, withCHUNK_SIZE = 32 bytes. The hashing of the leaf\u2019s value could therefore be saved. The authors of the EIP are however considering a future increase ofCHUNK_SIZE, makinghash(value)the future-proof choice.", "Backwards Compatibility": "A hard fork is required in order for blocks to have a trie root using a different structure.", "Test Cases": "TBD", "Implementation": "Issues could arise when performing the transition. In particular, a heavy conversion process could incentivize clients to wait the transition out. This could lead to a lowered network security at the time of the transition. A transition process has been proposed withEIP-2584.", "Security Considerations": "Issues could arise when performing the transition. In particular, a heavy conversion process could incentivize clients to wait the transition out. This could lead to a lowered network security at the time of the transition. A transition process has been proposed withEIP-2584.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3143, "url": "https://eips.ethereum.org/EIPS/eip-3143", "title": "Increase block rewards to 5 ETH", "authors": ["Ben Tinner\u00a0(", "@Terra854", ")"], "sections": {"EIP-3143: Increase block rewards to 5 ETH": "Changes the block reward paid to proof-of-work (POW) miners to 5 ETH.", "": "Changes the block reward paid to proof-of-work (POW) miners to 5 ETH.", "Simple Summary": "Changes the block reward paid to proof-of-work (POW) miners to 5 ETH.", "Abstract": "Starting withFORK_BLKNUMblock rewards will be increased to a base of 5 ETH, uncle and nephew rewards will be adjusted accordingly.", "Motivation": "Currently, the transaction fees (tx fees) portion of the mining rewards makes up a significant portion of the total rewards per block, at times almost exceeded the block reward of 2 ETH. This have resulted in situations where at times of low tx fees, POW miners decide to point their rigs away from ETH as they will always prefer to mine coins that are the most profitable at any point in time, reducing the security of the ETH network till transaction activity picks up again. By increasing the block rewards back to the original 5 ETH when the network first started, the voliatility will be reduced in terms of the percentage of tx fees that make up the mining rewards per block while increasing the total rewards per block, making it more financially attractive to POW miners to mine ETH barring any gigantic ETH price drops. The increase in block rewards will also allow smaller POW miners ample opporturnity to build up their stores of ETH so that when the time comes to fully transition to ETH 2.0, they may be more willing to become validators as they already have earned the requite amount of ETH needed to do so as opposed to having to spend tens of thousands of dollars to purchase the required ETH directly, increasing the number of validators in the network and therefore strengthening network security.", "Specification": "Adjust the block reward tonew_block_reward, where", "Rationale": "A 5 ETH base reward was chosen as a middle ground between wanting to prevent too high of an inflation rate (10.4% per annum for the first year at 5 ETH per block) and converting as many POW miners as possible into POS validators by making it easier to amass the required ETH needed through POW mining.", "Backwards Compatibility": "There are no known backward compatibility issues with the introduction of this EIP.", "Security Considerations": "There are no known security issues presented by this change.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3220, "url": "https://eips.ethereum.org/EIPS/eip-3220", "title": "Crosschain Identifier Specification", "authors": ["Weijia Zhang\u00a0(", "@weijia31415", ")", "Peter Robinson\u00a0(", "@drinkcoffee", ")"], "sections": {"EIP-3220: Crosschain Identifier Specification": "A self-verifying unique blockchain identifier that deals with forks.", "": "A self-verifying unique blockchain identifier that deals with forks.", "Simple Summary": "A self-verifying unique blockchain identifier that deals with forks.", "Abstract": "The crosschain-id is a 32 byte hex string and with some bytes extracted from blockchain hash and some manually defined to characterize a blockchain.\nWe also propose a registration and lookup service to retrieve blockchain metadata from the crosschain-id.", "Motivation": "With the success of Bitcoin and Ethereum, various blockchains such as EOS, Ripple, Litecoin, Besu, Wanchain and the like have been developed and are growing at a fast pace.  There are also other private and consortium blockchains such as Hyperledger Fabric, Hyperledger Besu, Stellar, Corda, Quorum that only allow nodes with permitted identities to join the blockchain network.  The growth of public and private blockchains imposes challenges for inter-chain interoperability, particularly when these chains are heterogeneous and incompatible. Enterprise Ethereum Alliance formed Crosschain Interoperability Task Force (CITF) to look into common crosschain problems and solutions. CITF team noticed that there is a lack of unique identifier to charaterise and describe a blockchain. Several proprosals were discussed in EEA Crosschain Interoperability Task Force meetings and discussions.", "Specification": "We have considered various alternative specifications such as using a random unique hex string to represent a blockchain.  The drawback of this method is that the random id can not be used to verify a blockchain\u2019s intrinsic identity such as the blockhash of the genesis block.  A second alternative is simply using a genesis blockhash to represent a blockchain id for crosschain operations.  The drawback of this is that this id does not have information about the property of the blockchain and it has problem when a blockchain is forked into two blockchain.", "Definition of a 32 byte crosschain id": "We have considered various alternative specifications such as using a random unique hex string to represent a blockchain.  The drawback of this method is that the random id can not be used to verify a blockchain\u2019s intrinsic identity such as the blockhash of the genesis block.  A second alternative is simply using a genesis blockhash to represent a blockchain id for crosschain operations.  The drawback of this is that this id does not have information about the property of the blockchain and it has problem when a blockchain is forked into two blockchain.", "Rationale": "We have considered various alternative specifications such as using a random unique hex string to represent a blockchain.  The drawback of this method is that the random id can not be used to verify a blockchain\u2019s intrinsic identity such as the blockhash of the genesis block.  A second alternative is simply using a genesis blockhash to represent a blockchain id for crosschain operations.  The drawback of this is that this id does not have information about the property of the blockchain and it has problem when a blockchain is forked into two blockchain.", "Backwards Compatibility": "Crosschainid can be backward compatible with EIP-155.  The crosschain id contains an 8 byte segment to record theNative Chain ID.\nFor Ethereum chains, that can be used for a value intended to be used with EIP-155.", "Security Considerations": "Collision of crosschain id:  Two blockchains can contain the same crosschain id and hence making the mistakenly transfer assets to a wrong blockchain.This security concern is addressed by comparing the hash of the crosschain id with the hash of the genesis block.  If it matches, then the crosschain id is verified.  If not, the crosschain id can be compared with the forked blockhash.  If none of the blockhash match the crosschain id hash, then the crosschain id cannot be verified.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3238, "url": "https://eips.ethereum.org/EIPS/eip-3238", "title": "Difficulty Bomb Delay to Q2/2022", "authors": ["Afri Schoedon\u00a0(", "@q9f", ")"], "sections": {"EIP-3238: Difficulty Bomb Delay to Q2/2022": "Delays the difficulty bomb so 30 second blocks won\u2019t happen until around Q2/2022.", "": "Delays the difficulty bomb so 30 second blocks won\u2019t happen until around Q2/2022.", "Simple Summary": "Delays the difficulty bomb so 30 second blocks won\u2019t happen until around Q2/2022.", "Abstract": "Starting withFORK_BLOCK_NUMBERthe client will calculate the difficulty based on a fake block number suggesting to the client that the difficulty bomb is adjusting eleven million blocks later than the actual block number.", "Motivation": "Even after the Ethereum 2.0 mainnet launch, Ethash proof-of-work mining on the legacy chain should be feasible. It should allow miners sealing new blocks every 13~15 seconds on average for another ten months and allow both Ethereum 1.x and Ethereum 2.0 developers to conclude the merge.", "Specification": "For the purposes ofcalc_difficulty, simply replace the use ofblock.number, as used in the exponential ice age component, with the formula:", "Rationale": "This will delay the ice age by another ~26 million seconds (approximately ~9.89 months), so the chain would be back at ~30 second block times in Q2/2022. Hopefully, by then the Eth1-to-Eth2 merge will be concluded and the ice age fulfilled its task.", "Backwards Compatibility": "This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation. Therefore, it should be included in a scheduled hardfork at a certain block number. It\u2019s suggested to consider this EIP either with or shortly after the Berlin hard-fork but not later than July 2021.", "Security Considerations": "There are no known security issues with this proposal.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3267, "url": "https://eips.ethereum.org/EIPS/eip-3267", "title": "Giving Ethereum fees to Future Salaries", "authors": ["Victor Porton\u00a0(", "@vporton", ")", "Victor Porton\u00a0<", "porton@narod.ru", ">"], "sections": {"EIP-3267: Giving Ethereum fees to Future Salaries": "Transfer a part of Ethereum transfer/mining fees to Future Salaries contract", "": "Transfer a part of Ethereum transfer/mining fees to Future Salaries contract", "Simple Summary": "Transfer a part of Ethereum transfer/mining fees to Future Salaries contract", "Abstract": "Transfer a part (exact fractions - TBD) of mining/transfer fees + (probably: TBD) some minted ETH to theDonateETHcontract configured to transfer toSalaryWithDAOcontract.", "Motivation": "This proposal solves two problems at once:", "Specification": "(TBD)", "Rationale": "The Future Salaries is theonlyknown system of distributing significant funds to common good producers. (Quadratic funding aimed to do a similar thing, but in practice as we see on GitCoin it favors a few developers, ignores project of highly advanced scientific research that is hard to explain to an average developer, and encourages colluding, and it just highly random due to small number of donors. Also quadratic funding simply does not gather enough funds to cover common good needs). So this EIP is the only known way to recover the economy.", "Backwards Compatibility": "Because transferring to the aforementioned account is neither mining nor a transaction, we get a new kinds of ETH transfers, so there may be some (expected moderate impact) troubles with applications that have made assumptions about ETH transfers all occurring either as miner payments or transactions.", "Security Considerations": "The security considerations are:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3298, "url": "https://eips.ethereum.org/EIPS/eip-3298", "title": "Removal of refunds", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Martin Swende\u00a0(", "@holiman", ")"], "sections": {"EIP-3298: Removal of refunds": "Remove gas refunds for SSTORE and SELFDESTRUCT.", "": "Remove gas refunds for SSTORE and SELFDESTRUCT.", "Simple Summary": "Remove gas refunds for SSTORE and SELFDESTRUCT.", "Motivation": "Gas refunds for SSTORE and SELFDESTRUCT were originally introduced to motivate application developers to write applications that practice \u201cgood state hygiene\u201d, clearing storage slots and contracts that are no longer needed. However, they are not widely used for this, and poor state hygiene continues to be the norm. It is now widely accepted that the only solution to state growth is some form ofstatelessness or state expiry, and if such a solution is implemented, then disused storage slots and contracts would start to be ignored automatically.", "Specification": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Parameters": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Rationale": "A full removal of refunds is the simplest way to solve the issues with refunds; any gains from partial retention of the refund mechanism are not worth the complexity that that would leave remaining in the Ethereum protocol.", "Backwards Compatibility": "Refunds are currently only appliedaftertransaction execution, so they cannot affect how much gas is available to any particular call frame during execution. Hence, removing them will not break the ability of any code to execute, though it will render some applications economically nonviable.", "Implementation": "An implementation can be found here: https://gist.github.com/holiman/460f952716a74eeb9ab358bb1836d821#gistcomment-3642048", "Test case changes": "Gas costs are provided with refunds subtracted; if the number is negative this means that refunds exceed gas costs. The 50% refund limit is not applied (due to the implied assumption that this code is only a small fragment of a much larger execution).", "Security Considerations": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3300, "url": "https://eips.ethereum.org/EIPS/eip-3300", "title": "Phase out refunds", "authors": ["William Morriss\u00a0(", "@wjmelements", ")"], "sections": {"EIP-3300: Phase out refunds": "Phases out theSSTOREandSELFDESTRUCTgas refunds.", "": "Phases out theSSTOREandSELFDESTRUCTgas refunds.", "Simple Summary": "Phases out theSSTOREandSELFDESTRUCTgas refunds.", "Abstract": "This EIP would define a block when theSSTOREandSELFDESTRUCTrefunds would begin to diminish.\nThe refund would step linearly downward, eroding the implicit value of such refunds at an accelerating pace.", "Motivation": "Refunds increase block elasticity, so the block gas target can exceed the number established by miners by up to 2x.\nThis can cause hesitancy for miners to increase the block gas target.", "Specification": "Parameters:", "EIP-2929": "The refunds as of EIP-2929 are as follows:", "Rationale": "Persisted refunds would become worthless before they fall below their activation cost.\nOnce the refunds are worthless, they can be removed by another hard fork without waiting for 0.\nThe rate of diminishing specified would currently require (24000-5000) * 100 = 1,900,000 blocks forSELFDESTRUCTand (15000-5000) * 100 = 1,000,000 blocks forSSTORE.\nThis timeframe is currently about a year, which should be enough flexibility for the remaining refunds to be consumed.", "Backwards Compatibility": "This proposal breaks gas refunds, which contribute to block elasticity.\nThe effect of this will be increased gas price volatility: higher highs and lower lows.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3322, "url": "https://eips.ethereum.org/EIPS/eip-3322", "title": "Account gas storage opcodes", "authors": ["William Morriss\u00a0(", "@wjmelements", ")"], "sections": {"EIP-3322: Account gas storage opcodes": "Allows contract accounts to store gas that can be transferred to the refund counter.", "": "Allows contract accounts to store gas that can be transferred to the refund counter.", "Simple Summary": "Allows contract accounts to store gas that can be transferred to the refund counter.", "Abstract": "Contracts can persist gas for later transfer to the refund counter.\nThree opcodes are introduced to read, add to, and use this gas counter.", "Motivation": "The refund mechanism is currently being used by gas tokens to arbitrage gas price.\nThis brings gas supply elasticity and price stability by moving gas from blocks with less demand to blocks with more demand.\nUnfortunately this rewards unnecessary state growth.\nBy introducing a superior gas storage mechanism, the gas market will require less storage and computation.", "Specification": "Contract accounts gain an unsigned gas refund counter, initially zero.", "Rationale": "By reusing the execution context\u2019s refund counter we can reuse its 50% DoS protection, which limits its block elasticity contribution to 2x.", "Backwards Compatibility": "Because the gas is added to the refund counter, no compatibility issues are anticipated.", "Test Cases": "| Code             | Used Gas | Refund | Original | Final |\n|\u2014\u2014\u2014\u2014\u2014\u2014|\u2014\u2014\u2014-|\u2014\u2014\u2013|\u2014\u2014\u2014-|\u2014\u2014-|\n| 0x60004900       |     5003 |      0 |        0 |     0 |\n| 0x60034900       |     5003 |      2 |        2 |     0 |\n| 0x60034900       |     5003 |      3 |        3 |     0 |\n| 0x60034900       |     5003 |      3 |        4 |     1 |\n| 0x60034960034900 |    10006 |      4 |        4 |     0 |\n| 0x60034960034900 |    10006 |      6 |        6 |     0 |\n| 0x484900         |     5010 | 100000 |   100000 |     0 |\n| 0x61ffff4a00     |    70538 |      0 |        0 | 65535 |", "Security Considerations": "DoS is already limited by the 50% refund limit.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3336, "url": "https://eips.ethereum.org/EIPS/eip-3336", "title": "Paged memory allocation for the EVM", "authors": ["Nick Johnson\u00a0(", "@arachnid", ")"], "sections": {"EIP-3336: Paged memory allocation for the EVM": "Changes the memory model for the EVM to use pagination.", "": "Changes the memory model for the EVM to use pagination.", "Simple Summary": "Changes the memory model for the EVM to use pagination.", "Abstract": "Presently, the EVM charges for memory as a linear array starting at address 0 and extending to the highest address that has been read from or written to. This suffices for simple uses, but means that compilers have to generate programs that use memory compactly, which leads to wasted gas with reallocation of memory elements, and makes some memory models such as separate heap and stack areas impractical. This EIP proposes changing to a page-based billing model, which adds minimal complexity to implementations, while providing for much more versatility in EVM programs.", "Motivation": "Most modern computers implement \u201cvirtual memory\u201d for userspace programs, where programs have access to a large address space, with pages of RAM that are allocated as needed by the OS. This allows them to distribute data throughout memory in ways that minimises the amount of reallocation and copying that needs to go on, and permits flexible use of memory for data with different lifetimes. Implementing a simple version of paged memory inside the EVM will provide the same flexibility to compilers targeting the EVM.", "Specification": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Parameters": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Changes to memory allocation in EVM implementations": "Memory is now allocated in pages of2**PAGE_BITSbytes each. The most significant256 - PAGE_BITSbits of each memory address denote the page number, while the least significantPAGE_BITSbits of the memory address denote the location in the page. Pages are initialized to contain all zero bytes and allocated when the first byte from a page is read or written.", "Changes to memory expansion gas cost": "Presently, the total cost to extend the memory toawords long isCmem(a) = 3 * a + floor(a ** 2 / 512). If the memory is alreadybwords long, the incremental cost isCmem(a) - Cmem(b).ais the number of words required to cover the range from memory address 0 to the last word that has been read or written by the EVM.", "Changes toMLOADandMSTORE": "Loading a word from memory or storing a word to memory requires instantiating any pages that it touches that do not already exist, with the resulting gas cost as described above. If the word being loaded or stored resides in a single page, the gas cost remains unchanged at 3 gas. If the word being loaded spans two pages, the cost is 6 gas.", "Changes to other memory-touching opcodes": "CALLDATACOPY,CODECOPY,EXTCODECOPY,CALL,CALLCODE,DELEGATECALL,STATICCALL,CREATE,MSTORE8and any other opcodes that read or write memory are modified as follows:", "Rationale": "The new gas cost follows the same curve as the previous one, while ensuring that the new gas cost is always less than or equal to the previous cost. This prevents existing programs that make assumptions about memory allocation gas costs from resulting in errors, without unduly discounting memory below what it costs today. Intuitively, a program that uses up to a page boundary pays for one page less than they would under the old model, while a program that uses one word more than a page boundary pays for one word less than they would under the old model.", "Memory expansion gas cost": "The new gas cost follows the same curve as the previous one, while ensuring that the new gas cost is always less than or equal to the previous cost. This prevents existing programs that make assumptions about memory allocation gas costs from resulting in errors, without unduly discounting memory below what it costs today. Intuitively, a program that uses up to a page boundary pays for one page less than they would under the old model, while a program that uses one word more than a page boundary pays for one word less than they would under the old model.", "Additional cost for MLOADs and MSTOREs spanning two pages": "Loading or storing data spanning two memory pages requires more work from the EVM implementation, which must split the word at the page boundary and update the two (possibly disjoint) pages. Since we cannot guarantee loads and stores in existing EVM programs are page-aligned, we cannot prohibit this behaviour for efficiency. Instead, we propose treating each as two loads or stores for gas accounting purposes. This discourages the use of this functionality, and accounts for the additional execution cost, without prohibiting it outright.", "Backwards Compatibility": "The new function for memory expansion gas cost is designed specifically to avoid backwards compatibility issues by always charging less than or equal to the amount the current EVM would charge. Under some circumstances existing programs will be charged more for MLOADs and MSTOREs that span page boundaries as described above; we believe these changes will affect a minimum of programs and have only a small impact on their gas consumption.", "Test Cases": "TBD", "Security Considerations": "Potential CPU DoS issues arising from additional work done under the new model are alleviated by charging more for non-page-aligned reads and writes. Charges for memory expansion asymptotically approach those currently in force, so this change will not permit programs to allocate substantially more memory than they can today.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3337, "url": "https://eips.ethereum.org/EIPS/eip-3337", "title": "Frame pointer support for memory load and store operations", "authors": ["Nick Johnson\u00a0(", "@arachnid", ")"], "sections": {"EIP-3337: Frame pointer support for memory load and store operations": "Introduces four new opcodes for loading data from and storing data to memory offset by a frame pointer.", "": "Introduces four new opcodes for loading data from and storing data to memory offset by a frame pointer.", "Simple Summary": "Introduces four new opcodes for loading data from and storing data to memory offset by a frame pointer.", "Abstract": "This EIP introduces four new opcodes,MLOADFP,MSTOREFP,GETFPandSETFPthat allow for more efficient memory access offset by a user-controlled quantity called the \u201cframe pointer\u201d. This permits compilers to more efficiently offload ephemeral data such as local variables to memory instead of the EVM\u2019s evaluation stack, which has a number of benefits, including the effective elimination of restrictions on the number of local variables in a function.", "Motivation": "In most commonly used VMs, ephemeral data such as local variables, function arguments, and return addresses is stored in a region of memory called the stack. In contrast to the EVM\u2019s evaluation stack, this area of memory is randomly accessible, and thus can store an arbitrary amount of data, which can be referenced from anywhere they remain in scope. Although this model is possible in the current EVM design, it is made difficult by the linear model of memory (addressed inEIP-3336) and by the lack of opcodes for relative memory access commonly found in other architectures. This EIP proposes new opcodes that permit this form of memory use, without imposing undue burden on EVM implementers or on runtime efficiency.", "Specification": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Parameters": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Frame pointer": "A new EVM internal state variable called the \u201cframe pointer\u201d is introduced. This is a signed integer that starts at 0.", "SETFPopcode": "A new opcode,SETFPis introduced with value0x5c. This opcode costsG_low(3 gas) and takes one argument from the stack. The argument is stored as the new value of the frame pointer.", "GETFPopcode": "A new opcode,GETFPis introduced with value0x5d. This opcode costsG_low(3 gas) and takes no arguments. It takes the current value of the frame pointer and pushes it to the stack.", "MLOADFPopcode": "A new opcodeMLOADFPis introduced with value0x5e. This opcode acts in all ways identical toMLOAD, except that the value of the frame pointer is added to the address before loading data from memory. An attempt to load data from a negative address should be treated identically to an invalid opcode, consuming all gas and reverting the current execution context.", "MSTOREFPopcode": "A new opcodeMSTOREFPis introduced with value0x5f. This opcode acts in all ways identical toMSTORE, except that the value of the frame pointer is added to the address before storing data to memory. An attempt to store data to a negative address should be treated identically to an invalid opcode, consuming all gas and reverting the current execution context.", "Rationale": "The cost of the new opcodesMLOADFPandMSTOREFPreflects the cost ofMLOADandMSTORE. They are generally equivalent in cost with the exception of an extra addition operation, which imposes negligible cost.", "Cost of new opcodes": "The cost of the new opcodesMLOADFPandMSTOREFPreflects the cost ofMLOADandMSTORE. They are generally equivalent in cost with the exception of an extra addition operation, which imposes negligible cost.", "Absence ofMSTORE8FP": "MSTORE8FPopcode was not included because it is expected that it would be used infrequently, and there is a desire to minimise the size of the instruction set and to conserve opcodes for future use.", "Backwards Compatibility": "This EIP exclusively introduces new opcodes, and as a result should not impact any existing programs unless they operate under the assumption that these opcodes are undefined, which we believe will not be the case.", "Security Considerations": "DoS risks are mitigated by correct pricing of opcodes to reflect current execution costs. No other security considerations pertain to this EIP.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3368, "url": "https://eips.ethereum.org/EIPS/eip-3368", "title": "Increase block rewards to 3 ETH, with 2 Year Decay to 1 ETH Scheduled", "authors": ["Michael D. Carter\u00a0(", "@BitsBeTrippin", ")"], "sections": {"EIP-3368: Increase block rewards to 3 ETH, with 2 Year Decay to 1 ETH Scheduled": "Changes the block reward paid to proof-of-work (POW) miners to 3 ETH from existing 2 ETH and starts a decay schedule for next two years to 1 ETH Block Reward.", "": "Changes the block reward paid to proof-of-work (POW) miners to 3 ETH from existing 2 ETH and starts a decay schedule for next two years to 1 ETH Block Reward.", "Simple Summary": "Changes the block reward paid to proof-of-work (POW) miners to 3 ETH from existing 2 ETH and starts a decay schedule for next two years to 1 ETH Block Reward.", "Abstract": "Set the block reward to 3 ETH and then decrease it slightly every block for 4,724,000 blocks (approximately 2 years) until it reaches 1 ETH.", "Motivation": "A sudden drop in PoW mining rewards could result in a sudden precipitous decrease in mining profitability that may drive miners to auction off their hashrate to the highest bidder while they figure out what to do with their now \u201cworthless\u201d hardware. If enough hashrate is auctioned off in this way at the same time, an attacker will be able to rent a large amount of hashing power for a short period of time at relatively low cost vs. reward and potentially attack the network. By setting the block reward to X (where X is enough to offset the sudden profitability decrease) and then decreasing it over time to Y (where Y is a number below the sudden profitability decrease), we both avoid introducing long term inflation while at the same time spreading out the rate that individual miners cross into a transitional range. This approach offers a higher level of confidence and published schedule of yield, while allowing mining participants time to gracefully repurpose/sell their hardware. This greatly increases ethereums PoW security by keeping incentives aligned to ethereum and not being force projected to short term brokerage for the highest bidder. Additionally the decay promotes a known schedule of a deflationary curve, aligning to the overall Minimal Viable Issuance directive aligned to a 2 year transition schedule for Proof of Stake, consensus replacement of Proof of Work. Security is paramount in cryptocurrency blockchains and the risk to a 51% non-resistant chain is real. The scope of Ethereum\u2019s current hashrate has expanded to hundreds of thousands of new participants and over 2.5x original ATH hashrate/difficulty. While the largest by hashrate crypto is bitcoin, ethereum is not far behind the total network size in security aspects. This proposal is focused to keep that superiority in security one of the key aspects.", "Specification": "Adjust block, uncle, and nephew rewards", "Constants": "2 years was chosen because it gives miners sufficient time to find alternative uses for their hardware and/or get their hardware back out onto the open market (e.g., in the form of gaming GPUs) without flooding the market suddenly. This proposal should ONLY be considered as a last resort as something we have in our pocket should the \u201cnetwork need to attract hashing power quickly and then bleed it off over time\u201d rather than \u201csomething that is scheduled to be included in X hard fork\u201d ; Recommendation to have in a fast track state, but NOT deployed to mainnet unless needed.", "Rationale": "2 years was chosen because it gives miners sufficient time to find alternative uses for their hardware and/or get their hardware back out onto the open market (e.g., in the form of gaming GPUs) without flooding the market suddenly. This proposal should ONLY be considered as a last resort as something we have in our pocket should the \u201cnetwork need to attract hashing power quickly and then bleed it off over time\u201d rather than \u201csomething that is scheduled to be included in X hard fork\u201d ; Recommendation to have in a fast track state, but NOT deployed to mainnet unless needed.", "Backwards Compatibility": "There are no known backward compatibility issues with the introduction of this EIP.", "Security Considerations": "There are no known security issues with the introduction of this EIP.", "Copyright": "Copyright and related rights waived via CC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3372, "url": "https://eips.ethereum.org/EIPS/eip-3372", "title": "5 FNV primes for ethash", "authors": ["mineruniter969\u00a0(", "@mineruniter969", ")", "mineruniter969\u00a0<", "mineruniter969@tutanota.com", ">"], "sections": {"EIP-3372: 5 FNV primes for ethash": "Introduce 5 new FNV primes into the ethash algorithm.", "": "Introduce 5 new FNV primes into the ethash algorithm.", "Simple Summary": "Introduce 5 new FNV primes into the ethash algorithm.", "Abstract": "This EIP is to kick current ASIC implementations out of the network to keep the Ethereum network secure and healthy by changing thefnvconstants.", "Motivation": "ASICs provide a severe centralization risk for the Ethereum network. If we do not get rid of them, small GPU miners will be forced to exit the Ethereum mining because EIP-1559 will make them mining at a loss. Furthermore, ASIC production will be concentrated only at one or two parties, which will make the Ethereum hashrate centralized. Also, it is worth noting that Ethash ASIC machines cost 10k+ USD, while GPUs are priced less than 1000 USD.", "Specification": "Ifblock.number >= ETHASH11_BLKNUM, activate theethash1.1algorithm version.", "ethash1.1": "Prior to this change,fnvhash function is used throughout thehashimotofunction.fnvis identical for all steps,ethash1.1will introduce additionalfnvA,fnvB,fnvC,fnvD, andfnvEfunctions. All those functions will have different FNV constants.", "Rationale": "ASIC Miners have become a threat to the future of Ethereum and a hard fork is required to remove them from the network before additional damage is caused. EIP-3372 proposes the minimum necessary to do so and will not affect ETH stakeholders or the network like Ethash 2.0 would. The threat ASICs pose is legal, social, moral, technical, monetary, and environmental. As we continue to come closer to the merge ASICs will attack the network and the developers personally as they have done in the past because miners will always pursue profits.", "Technical Overview": "Ethash 1.1 will replace the only FNV prime with five new primes at the stage of the hash computation. The prime used for the DAG generation is remained unchanged, while all others are be changed. This will not prevent ASIC companies from creating new ASICs that adapt but so close to the merge it is unlikely they will do so, and even if they do they are unlikely to be able to produce enough to again be a threat.\nThe choice of FNV constants are based on the formal specification that is available onhttps://tools.ietf.org/html/draft-eastlake-fnv-14#section-2.1", "Backwards Compatibility": "Mining hardware that is optimized for ethash may no longer work if thefnvconstants are baked into the hardware and cannot be changed.", "Test Vectors": "There are no known security issues with this change.", "Security Considerations": "There are no known security issues with this change.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3403, "url": "https://eips.ethereum.org/EIPS/eip-3403", "title": "Partial removal of refunds", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Martin Swende\u00a0(", "@holiman", ")"], "sections": {"EIP-3403: Partial removal of refunds": "Remove gas refunds for SELFDESTRUCT, and restrict gas refunds for SSTORE to one specific case.", "": "Remove gas refunds for SELFDESTRUCT, and restrict gas refunds for SSTORE to one specific case.", "Simple Summary": "Remove gas refunds for SELFDESTRUCT, and restrict gas refunds for SSTORE to one specific case.", "Motivation": "Gas refunds for SSTORE and SELFDESTRUCT were originally introduced to motivate application developers to write applications that practice \u201cgood state hygiene\u201d, clearing storage slots and contracts that are no longer needed. However, they are not widely used for this, and poor state hygiene continues to be the norm. It is now widely accepted that the only solution to state growth is some form of statelessness or state expiry, and if such a solution is implemented, then disused storage slots and contracts would start to be ignored automatically.", "The mutex usecase": "There are two typical ways to implement mutexes: \u20180-1-0\u2019 and \u20181-2-1. Let\u2019s see how they differ", "Specification": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Parameters": "For blocks whereblock.number >= FORK_BLOCK, the following changes apply.", "Rationale": "Preserving refunds in thenew = original = 0 != currentcase ensures that a few key use cases that deserve favorable gas cost treatment continue to receive favorable gas cost treatment, particularly:", "Backwards Compatibility": "Refunds are currently only appliedaftertransaction execution, so they cannot affect how much gas is available to any particular call frame during execution. Hence, removing them will not break the ability of any code to execute, though it will render some applications economically nonviable.", "Test Cases": "Note, there is a difference between \u2018hot\u2019 and \u2018cold\u2019 slots. This table shows the values as ofEIP-2929assuming that all touched storage slots were already \u2018hot\u2019 (the difference being a one-time cost of2100gas).", "2929 Gas Costs": "Note, there is a difference between \u2018hot\u2019 and \u2018cold\u2019 slots. This table shows the values as ofEIP-2929assuming that all touched storage slots were already \u2018hot\u2019 (the difference being a one-time cost of2100gas).", "With EIP-3403 partial refunds": "If refunds were to be partially removed, as specifiedhere, this would be the comparative table.This table also assumes touched storage slots were already \u2018hot\u2019.", "Security Considerations": "Refunds are not visible to transaction execution, so this should not have any impact on transaction execution logic.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3416, "url": "https://eips.ethereum.org/EIPS/eip-3416", "title": "Median Gas Premium", "authors": ["HexZorro\u00a0(", "@hexzorro", ")", "Mojtaba Tefagh\u00a0(", "@mtefagh", ")"], "sections": {"EIP-3416: Median Gas Premium": "A transaction pricing mechanism with a fixed-per-block network fee and a median inclusion fee with additive updates.", "": "A transaction pricing mechanism with a fixed-per-block network fee and a median inclusion fee with additive updates.", "Simple Summary": "A transaction pricing mechanism with a fixed-per-block network fee and a median inclusion fee with additive updates.", "Abstract": "There is a base fee per gas in protocol, which can move up or down by a maximum of 1/8 in each block. The base fee per gas is adjusted by the protocol to target an average gas usage per block instead of an absolute gas usage per block.  The base fee is increased when blocks are over the gas limit target and decreases when blocks are under the gas limit target. Transaction senders specify their fees by providingonly one value:", "Motivation": "We target the following goals:", "Specification": "This is a classic fork without a long migration time.", "Definitions": "This is a classic fork without a long migration time.", "Process": "The miners can still use agreedystrategy to include new transactions in the proposed blocks by adding the transactions ordered by largerFEE_CAPfirst. This is similar to how current blocks are filled, and is a consequence ofFEE_CAPandGAS_PREMIUMbeing a positive linear function of each other.", "Rationale": "The rationale behind the premium being 50% of (fee cap - base fee) is that at any given point the average network sender has an average fee cap, and we assume that between base fee and fee cap the sender has no specific preference, as long as the transaction is included in some block. Then, the sender is happy with a median premium among this uniform range. Another justification can be that the user also knows that this new version of the pricing protocol for the complete block uses a median, then is fair for him to apply a median within his preferential range, assuming an uniform sampling there. Simulations (here) with Ethereum gas data shows indeed that median one of the most robust metric.s", "Backwards Compatibility": "The backward compatibility is very straightforward because there are no new fields added to the transactions. Pricing of the gas per block on the miner/validator side is still fast to compute but a little more complex. Changes only affect miners/validators. Wallets are no affected by this proposal.", "Test Cases": "TBD.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3436, "url": "https://eips.ethereum.org/EIPS/eip-3436", "title": "Expanded Clique Block Choice Rule", "authors": ["Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-3436: Expanded Clique Block Choice Rule": "Add a four step block rule to Clique that should reduce block production deadlocks", "": "Add a four step block rule to Clique that should reduce block production deadlocks", "Simple Summary": "Add a four step block rule to Clique that should reduce block production deadlocks", "Abstract": "The current specification of Clique allows for multiple competing blocks from producers but does not\nprovide any strategies to pick blocks aside from the current \u201chighest total difficulty\u201d rule. This\nEIP proposes a four step choice rule of highest total difficulty, shortest chain, most recently\nin-turn, and lowest hash. This would prevent deadlocks that have occurred in production systems.", "Motivation": "There has been more than one deadlock in the Goerli multi-client Clique network. The number of\nactive validators was greater than 1/2 of the available validators so a chain halt should not have\noccurred. The halt was resolved by an inactive validator coming back on line. The state of the chain\nwas in one of two configurations of 8 validators that can result in a chain halt. Three of the four\nclients observed a choice sequence of lowest total difficulty followed by first observed block. Geth\nadded one extra rule of preferring the shortest chain before preferring the first observed block.\nThis fork would have resolved itself with Geth\u2019s rule, but there is still a configuration where the\nchain can halt with a shortest chain rule.", "Specification": "When a Clique validator is arbitrating the canonical status between two different chain head blocks,\nthey should choose the canonical block with the following ordered priorities.", "Rationale": "Two scenarios of a halted chain are known based on the current total difficulty then first observed\nrule. One of the scenarios is also resistant to the shortest chain rule.", "Backwards Compatibility": "The current block choice rules are a mix of most total difficulty and most total difficulty plus\nshortest chain.", "Security Considerations": "Malicious and motivated attackers who are participating in the network can force the chain to halt\nwith well crafted block production. With a fully deterministic choice rule the opportunity to halt\nis diminished. Attackers still have the same opportunities to flood the network with multiple blocks\nat the same height. A deterministic rule based on the lowest hash reduces the impact of such a\nflooding attack. A malicious validator could exploit this deterministic rule to produce a\nreplacement block. Such an attack exists in current implementations but a deterministic hash rule\nmakes such replacements more likely. However the impact of such an attack seems low to trivial at\nthis time.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3455, "url": "https://eips.ethereum.org/EIPS/eip-3455", "title": "SUDO Opcode", "authors": ["William Morriss\u00a0(", "@wjmelements", ")", "Baptiste Vauthey\u00a0(", "@thabaptiser", ")"], "sections": {"EIP-3455: SUDO Opcode": "A new opcode,SUDO, is introduced with the same parameters asCALL, plus another parameter to specify the sender address.", "A new opcode is introduced to allow calling from an arbitrary sender address.": "A new opcode,SUDO, is introduced with the same parameters asCALL, plus another parameter to specify the sender address.", "Abstract": "A new opcode,SUDO, is introduced with the same parameters asCALL, plus another parameter to specify the sender address.", "Motivation": "There are many use cases for being able to set the sender.", "Specification": "Adds a new opcode (SUDO) at0xf8.SUDOpops 8 parameters from the stack.\nBesides the sender parameter, the parameters shall matchCALL.", "Rationale": "TheGASparameter is first so that callers can tediously compute how much of their remaining gas to send at the last possible moment.\nThe remaining parameters inherited fromCALLare in the same order, with sender inserted between.", "Security Considerations": "It will be fine.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3508, "url": "https://eips.ethereum.org/EIPS/eip-3508", "title": "Transaction Data Opcodes", "authors": ["Alex Papageorgiou\u00a0(", "@alex-ppg", ")"], "sections": {"EIP-3508: Transaction Data Opcodes": "Provide access to original transaction data.", "": "Provide access to original transaction data.", "Simple Summary": "Provide access to original transaction data.", "Abstract": "This EIP introduces the following three EVM instructions:ORIGINDATALOAD,ORIGINDATASIZE, andORIGINDATACOPY.", "Motivation": "As the Ethereum development scene matures, more ambitious and complex features are introduced into smart contracts more often than not requiring the utilization of complex and at times large data structures. Given the inherent limits of the EVM, however, transporting large data structures in between contracts is a costly task that can at times lead to even futile scenarios whereby the gas consumption of such an operation is impossible to execute within the gas limit bounds as well as without sacrificing a large chunk of ETH to facilitate its gas cost.", "Specification": "These instructions are meant to operate similarly to their call-prefixed counterparts with the exception that they instead operate on the originaldataof a transaction instead of the current call\u2019s data. In detail:", "ORIGINDATALOAD (0x47), ORIGINDATASIZE (0x48) and ORIGINDATACOPY (0x49)": "These instructions are meant to operate similarly to their call-prefixed counterparts with the exception that they instead operate on the originaldataof a transaction instead of the current call\u2019s data. In detail:", "Rationale": "TheEIP-3074that will be part of the London fork has introduced a new call instruction calledAUTHCALL(0xf7) that will replace a transaction\u2019sORIGIN(0x32) with the context variableauthorized. The intention ofAUTHCALLis to prevent discrimination between smart contracts and EOAs whichORIGINinitially facilitated and as a result, it is sensible also replace the values retrieved by theORIGINDATA*opcodes to the ones used in theAUTHCALL.", "AUTHCALL (0xf7) Interaction": "TheEIP-3074that will be part of the London fork has introduced a new call instruction calledAUTHCALL(0xf7) that will replace a transaction\u2019sORIGIN(0x32) with the context variableauthorized. The intention ofAUTHCALLis to prevent discrimination between smart contracts and EOAs whichORIGINinitially facilitated and as a result, it is sensible also replace the values retrieved by theORIGINDATA*opcodes to the ones used in theAUTHCALL.", "Naming Conventions": "TheORIGIN-prefixed instructions attempted to conform to the existing naming convention ofCALL-prefixed instructions given the existence of theORIGIN(0x32) instruction which is equivalent to theCALLER(0x33) instruction but on the original transaction\u2019s context.", "Instruction Address Space": "The instruction address space of the0x30-0x3fhas been exhausted by calls that already provide information about the execution context of a call so a new range had to be identified that is suitable for the purposes of the EIP.", "Gas Costs": "The opcodes ORIGINDATALOAD (0x47), ORIGINDATASIZE (0x48), and ORIGINDATACOPY (0x49) essentially perform the same thing as opcodes CALLDATALOAD (0x35), CALLDATASIZE (0x36), and CALLDATACOPY (0x37) respectively and thus share the exact same gas costs.", "Instruction Space Pollution": "One can argue that multiple new EVM instructions pollute the EVM instruction address space and could cause issues in assigning sensible instruction codes to future instructions. This particular issue was assessed and a methodology via which the raw RLP encoded transaction may be accessible to the EVM was ideated. This wouldfuture-proofthe new instruction set as it would be usable for other members of the transaction that may be desired to be accessible on-chain in the future, however, it would also cause a redundancy in theORIGINopcode.", "Backwards Compatibility": "The EIP does not alter or adjust existing functionality provided by the EVM and as such, no known issues exist.", "Test Cases": "TODO.", "Security Considerations": "Atomically, theORIGINDATALOADandORIGINDATACOPYvalues should be considered insecure as they can easily be spoofed by creating an entry smart contract with the appropriate function signature and arguments that consequently invokes other contracts within the call chain. In brief, one should always assume thattx.data != calldataand these instructions should not be used as an introspection tool alone.", "Introspective Contracts": "Atomically, theORIGINDATALOADandORIGINDATACOPYvalues should be considered insecure as they can easily be spoofed by creating an entry smart contract with the appropriate function signature and arguments that consequently invokes other contracts within the call chain. In brief, one should always assume thattx.data != calldataand these instructions should not be used as an introspection tool alone.", "Denial-of-Service Attack": "An initial concern that may arise from this EIP is the additional contextual data that must be provided at the software level of nodes to the EVM in order for it to be able to access the necessary data via theORIGINDATALOADandORIGINDATACOPYinstructions.", "Multi-Contract System Gas Reduction": "Given that most complex smart contract systems deployed on Ethereum today rely on cross-contract interactions whereby values are passed from one contract to another via function calls, theORIGIN-prefixed instruction set would enable a way for smart contract systems to acquire access to the original transaction data at any given step in the call chain execution which could result in cross-contract calls ultimately consuming less gas if the data passed between them is reduced as a side-effect of this change.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3520, "url": "https://eips.ethereum.org/EIPS/eip-3520", "title": "Transaction Destination Opcode", "authors": ["Alex Papageorgiou\u00a0(", "@alex-ppg", ")"], "sections": {"EIP-3520: Transaction Destination Opcode": "Provide access to the original recipient of a transaction.", "": "Provide access to the original recipient of a transaction.", "Simple Summary": "Provide access to the original recipient of a transaction.", "Abstract": "This EIP introduces the following EVM instruction:ENTRYPOINT.", "Motivation": "It is undeniable that smart contracts are becoming more interconnected than ever. Up until this point, smart contracts have entirely relied on compliant interfaces and introspection to introduce a new step in the call chain of a complex multi-contract interaction. However, this presents a forwards-only approach which limits the types of interactions that can manifest.", "Specification": "TheENTRYPOINTinstruction uses 0 stack arguments and pushes the originaltomember of the transaction onto the stack. The address yielded by the instruction is a 160-bit value padded to 256-bits. The operation costsG_baseto execute, similarly toORIGIN(0x32).", "ENTRYPOINT (0x4a)": "TheENTRYPOINTinstruction uses 0 stack arguments and pushes the originaltomember of the transaction onto the stack. The address yielded by the instruction is a 160-bit value padded to 256-bits. The operation costsG_baseto execute, similarly toORIGIN(0x32).", "Rationale": "TheEIP-3074introduced a new call instruction calledAUTHCALL(0xf7) that will replace a transaction\u2019sORIGIN(0x32) with the context variableauthorized. The intention ofAUTHCALLis to prevent discrimination between smart contracts and EOAs whichORIGINinitially facilitated. TheENTRYPOINTopcode by itself re-introduces discrimination into the system as it indirectly allows one to evaluate whether the smart contract code being executed is done so by an EOA by validating thatENTRYPOINT == ADDRESSwhereADDRESS(0x30) retrieves the currently executing account address. Therefore, it is sensible also replace the values retrieved by theENTRYPOINTopcode to the target of anAUTHCALL.", "AUTHCALL (0xf7) Interaction": "TheEIP-3074introduced a new call instruction calledAUTHCALL(0xf7) that will replace a transaction\u2019sORIGIN(0x32) with the context variableauthorized. The intention ofAUTHCALLis to prevent discrimination between smart contracts and EOAs whichORIGINinitially facilitated. TheENTRYPOINTopcode by itself re-introduces discrimination into the system as it indirectly allows one to evaluate whether the smart contract code being executed is done so by an EOA by validating thatENTRYPOINT == ADDRESSwhereADDRESS(0x30) retrieves the currently executing account address. Therefore, it is sensible also replace the values retrieved by theENTRYPOINTopcode to the target of anAUTHCALL.", "Naming Conventions": "TheENTRYPOINTinstruction came to be by defining a sensible name that immediately and clearly depicts what it is meant to achieve by signaling the first interaction of a particular call, i.e. the entry-point.", "Instruction Address Space": "Equivalent toEIP-3508.", "Gas Cost": "The opcode ENTRYPOINT (0x4a) essentially performs the same thing as the opcode ORIGIN (0x32) and thus shares the exact same gas cost.", "Dependency on EIP-3508": "TheENTRYPOINT(0x4a) instruction alone has no perceivable benefit as it can be replaced by theAUTHCALL(0xf7) instruction and as such should solely be introduced to the system in conjunction with theORIGINDATA*opcodes defined inEIP-3508.", "Backwards Compatibility": "The EIP does not alter or adjust existing functionality provided by the EVM and as such, no known issues exist.", "Test Cases": "TODO.", "Security Considerations": "TheENTRYPOINTinstruction allows the association of theORIGINDATALOADandORIGINDATACOPYvalues with a particular smart contract address and interface, enabling introspection to be applied based on the function signature invoked and the arguments provided to reliably deduce the call-path via which a particular smart contract was invoked and allowing a more granular level of interaction to be defined in such special cases.", "Introspective Contracts": "TheENTRYPOINTinstruction allows the association of theORIGINDATALOADandORIGINDATACOPYvalues with a particular smart contract address and interface, enabling introspection to be applied based on the function signature invoked and the arguments provided to reliably deduce the call-path via which a particular smart contract was invoked and allowing a more granular level of interaction to be defined in such special cases.", "Caller Discrimination": "The instructions of this EIP should not be utilized as a way to discriminate between EOA callers and smart contracts, as this type of differentiation can be broken by anAUTHCALLas defined in the specification chapter.", "Contract Creation Behaviour": "The behaviour of theENTRYPOINTopcode during a contract creation will result in the opcode yielding the zero-address as the first address interacted with in the transaction. This should be taken into account by contract implementations in a similar fashion to howecrecoverinvalid signatures are handled to prevent software misbehaviours from arising.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3521, "url": "https://eips.ethereum.org/EIPS/eip-3521", "title": "Reduce access list cost", "authors": ["Matt Garnett\u00a0(", "@lightclient", ")"], "sections": {"EIP-3521: Reduce access list cost": "Reduce the cost of declaringtx.tostorage keys in access lists.", "": "Reduce the cost of declaringtx.tostorage keys in access lists.", "Simple Summary": "Reduce the cost of declaringtx.tostorage keys in access lists.", "Motivation": "Currently, a transaction must read at least 25 distinct storage slots intx.tobefore it\u2019s more expensive to forego an access list.", "Specification": "Treat the first occurrence oftx.toin an access list ascalldatafor gas\naccounting purposes. Do not chargeACCESS_LIST_ADDRESS_COSTfor it. Storage\nkeys underneath the address are unaffected.", "Rationale": "EIP-2930 is specifically written to make access lists simple to reason about and\nvalidate. It may be possible to modify the structure of the access list to avoid\nincludingtx.toexplicitly, but this would renege on the spirit of EIP-2930.", "Why charge at all?": "EIP-2930 is specifically written to make access lists simple to reason about and\nvalidate. It may be possible to modify the structure of the access list to avoid\nincludingtx.toexplicitly, but this would renege on the spirit of EIP-2930.", "Why charge ascalldata?": "The cost ofcalldatawas  thoroughly analyzed in EIP-2028 to determine\na fair value that is not susceptible to denial-of-service attacks. We consider\nthis the lower bound on how much transaction data should cost. Since there is\nno computation burden imposed for addingtx.toto theaccessed_addressesmap (it\u2019s added by default byEIP-2929), there is no reason to charge more than\nthe absolute minimum for the data.", "Test Cases": "No issues.", "Backwards Compatibility": "No issues.", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3534, "url": "https://eips.ethereum.org/EIPS/eip-3534", "title": "Restricted Chain Context Type Transactions", "authors": ["Isaac Ardis\u00a0(", "@whilei", ")"], "sections": {"EIP-3534: Restricted Chain Context Type Transactions": "Defines a new transaction type with constraints on ancestor block hash, block author, and/or block timestamp.", "": "Defines a new transaction type with constraints on ancestor block hash, block author, and/or block timestamp.", "Simple Summary": "Defines a new transaction type with constraints on ancestor block hash, block author, and/or block timestamp.", "Abstract": "We introduce a new EIP-2718 transaction type with the format0x4 || rlp([chainId, chainContext, nonce, gasPrice, gasLimit, to, value, data, access_list, yParity, senderR, senderS]).", "Motivation": "Establish a protocol-based mechanism with which transactions are able to articulate constraints on eligible chain contexts.\nGenerally, these constraints give the consumer (the transactor) an ability to express requirements about the transaction\u2019s relationship to blockchain data and its provenance.", "Specification": "As ofFORK_BLOCK_NUMBER, a new EIP-2718 transaction is introduced withTransactionTypeTRANSACTION_TYPE_NUMBER.", "Parameters": "As ofFORK_BLOCK_NUMBER, a new EIP-2718 transaction is introduced withTransactionTypeTRANSACTION_TYPE_NUMBER.", "Definitions": "ThechainContextvalue should be of the formANNOTATION_COMPOSITE_PREFIX || [{subclass value}...], where", "Validation": "The values defined as subclasses below acts as constraints on transaction validity for specific chain contexts.\nTransactions defining constraints which are not satisfied by their chain context should be rejected as invalid.\nBlocks containing invalid transactions should be rejected as invalid themselves, per thestatus quo.", "Subclass Combination": "Since subclasses use octal-based values forANNOTATION_PREFIX, they can be distinguishably combined as sums, provided as we assume annotation cardinality (ie ordering).\nFor example:", "Subclasses": "Subclasses are defined with a high level of conceptual independence, and can be modified and/or extended independently from this EIP.\nTheir specification definitions allow arbitrary mutual (AND) combinations.", "Rationale": "Subclasses are defined with a high level of conceptual independence, and can be modified and/or extended independently from this EIP.\nTheir specification definitions allow arbitrary mutual (AND) combinations.", "EIP-2930 Inheritance": "TheEIP-2930 Optional Access List Type Transactionis used as an assumed \u201cbase\u201d transaction type for this proposal. \nHowever, this is NOT a conceptual dependency; the includedaccessListportion of this proposal (the only differential from post-EIP-155 legacy transaction fields) can readily be removed. \nStanding on the shoulders of EIP-2930 is only intended to support and further the adoption of next-generation transactions.", "Signature target": "The signature signs over the transaction type as well as the transaction data.\nThis is done to ensure that the transaction cannot be \u201cre-interpreted\u201d as a transaction of a different type.", "Backwards Compatibility": "There are no known backward compatibility issues.", "Test Cases": "Further test cases, TODO.", "Security Considerations": "TL;DR: The chance of an ineffectualancestorIdis about 1 in between ~4 billion and ~40 billion, with the greater chance for intentional duplication scenarios, eg. malicious reorgs.", "Why 4 bytes of a block hash is \u201csafe enough\u201d for theancestorId": "TL;DR: The chance of an ineffectualancestorIdis about 1 in between ~4 billion and ~40 billion, with the greater chance for intentional duplication scenarios, eg. malicious reorgs.", "eligibleMinerList": "Miners who do not find themselves listed in an annotatedeligibleMinerListshould be expected to immediately remove the transaction from their transaction pool.", "ineligibleMinerList": "In addition to the concerns and arguments presented byeligibleMinerListabove, there is a unique concern forineligibleMinerList: in order for a miner entity to avoid ineligibility by a blacklist, they only need to use an alternative adhoc address as the block beneficiary.\nIn principle, this is ineluctable.", "Validation costs": "Miner lists and expiry depend on easily cached and contextually available conditions (ie. the containing block header). The infrastructural overhead costs for enforcing these validations are expected to be nominal.", "Transaction size increase": "The proposed additional fields potentially increase transaction size.\nThe proposed fields are not associated with any gas costs, establishing no protocol-defined economic mitigation for potential spam.\nHowever, transactions which are considered by a miner to be undesirable can be simply dropped from the transaction pool and ignored.", "Copyright": "Copyright and related rights waved viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3584, "url": "https://eips.ethereum.org/EIPS/eip-3584", "title": "Block Access List", "authors": ["Gajinder Singh\u00a0(", "@g11in", ")", "Piper Merriam\u00a0(", "@pipermerriam", ")"], "sections": {"EIP-3584: Block Access List": "A proposal to build a block\u2019saccess_listand include its fingerprintAccessListRootin the block header.", "": "A proposal to build a block\u2019saccess_listand include its fingerprintAccessListRootin the block header.", "Simple Summary": "A proposal to build a block\u2019saccess_listand include its fingerprintAccessListRootin the block header.", "Abstract": "EIP-2929/EIP-2930centers around normalizing the (low) gas costs of data/storage accesses made by a transaction as well as providing for (and encouraging) a new transaction type format:", "Motivation": "Motivation for collating thetransactionaccess_lists for all the transactions in ablock\u2019saccess_listis to have anaccess indexof the block with following benefits:", "Specification": "A blockaccess_listrepresents:", "Canonical Block Access List": "Anaccess_listis defined to be comprised of manyaccess_list_entryelements:", "AccessListRoot": "AccessListRootis generated to prevent anygriefingattacks and hence will need to be included (and validated) in theblock header.\nEven thoughAccessListRootis currently specified to be a simplesha256hash of the canonicalaccess_list, it would be beneficial to consider other constructions", "Additional Block Validation": "Validating a new block requires an additional validation check that the block\u2019sAccessListRootmatches the one generated by executing the block using the construction as defined by theAccessListRootURN.", "Rationale": "It is specified to be sorted in lexicographic ordering or integer sorting wherever applicable and specified. Sorting with respect to access time was considered but didn\u2019t seem to provide any additional benefit at the cost of adding implementation complexity and bookkeeping.", "Sorting of canonicalaccess_list": "It is specified to be sorted in lexicographic ordering or integer sorting wherever applicable and specified. Sorting with respect to access time was considered but didn\u2019t seem to provide any additional benefit at the cost of adding implementation complexity and bookkeeping.", "Future extensions ofaccess_list": "We can extend the notion of a block\u2019saccess_listto include witnesses:", "Backwards Compatibility": "The extra block validation will only be mandatory post the block number this EIP comes into effect, but the clients can still provide a way to generate (and possibly store) this access list  on request (via theJSON/RPCapi). However this is optional and client dependent.", "Security Considerations": "There are no known security issues as a result of this change.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3690, "url": "https://eips.ethereum.org/EIPS/eip-3690", "title": "EOF - JUMPDEST Table", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Andrei Maiboroda\u00a0(", "@gumb0", ")"], "sections": {"EIP-3690: EOF - JUMPDEST Table": "Introduce a section in the EOF format (EIP-3540) for storing the list ofJUMPDESTs, validate the correctness of this list at the time of contract creation, and remove the need forJUMPDEST-analysis at execution time. In EOF contracts, theJUMPDESTinstruction is not needed anymore and becomes invalid. Legacy contracts are entirely unaffected by this change.", "A special EOF section for storing the list of JUMPDESTs, which simplifies execution time analysis.": "Introduce a section in the EOF format (EIP-3540) for storing the list ofJUMPDESTs, validate the correctness of this list at the time of contract creation, and remove the need forJUMPDEST-analysis at execution time. In EOF contracts, theJUMPDESTinstruction is not needed anymore and becomes invalid. Legacy contracts are entirely unaffected by this change.", "Abstract": "Introduce a section in the EOF format (EIP-3540) for storing the list ofJUMPDESTs, validate the correctness of this list at the time of contract creation, and remove the need forJUMPDEST-analysis at execution time. In EOF contracts, theJUMPDESTinstruction is not needed anymore and becomes invalid. Legacy contracts are entirely unaffected by this change.", "Motivation": "Currently existing contracts require no validation of correctness, but every time they are executed, a list must be built containing all the valid jump-destinations. This is an overhead which can be avoided, albeit the effect of the overhead depends on the client implementation.", "Specification": "This feature is introduced on the very same blockEIP-3540is enabled, therefore every EOF1-compatible bytecode MUST have a JUMPDEST-table if it uses jumps.", "EOF container changes": "The length of thejumpdestssection is bounded by the EOF maximum section size value 0xffff. Moreover, for deployed code this additionally limited by the max bytecode size 0x6000. Then any validjumpdestssection may not be more larger than 0x3000.", "Validation rules": "The length of thejumpdestssection is bounded by the EOF maximum section size value 0xffff. Moreover, for deployed code this additionally limited by the max bytecode size 0x6000. Then any validjumpdestssection may not be more larger than 0x3000.", "Execution": "The length of thejumpdestssection is bounded by the EOF maximum section size value 0xffff. Moreover, for deployed code this additionally limited by the max bytecode size 0x6000. Then any validjumpdestssection may not be more larger than 0x3000.", "Rationale": "The length of thejumpdestssection is bounded by the EOF maximum section size value 0xffff. Moreover, for deployed code this additionally limited by the max bytecode size 0x6000. Then any validjumpdestssection may not be more larger than 0x3000.", "Jumpdests section is bounded": "The length of thejumpdestssection is bounded by the EOF maximum section size value 0xffff. Moreover, for deployed code this additionally limited by the max bytecode size 0x6000. Then any validjumpdestssection may not be more larger than 0x3000.", "Delta encoding": "Delta-encoding is very efficient for this job. From a quick analysis of a small set of contractsJUMPDESTopcodes are relatively close to each other. In the delta-encoding the values almost never exceed 128. Combined with any form of variable-length quantity (VLQ) where values < 128 occupy one byte, encoding of single jumpdest takes ~1 byte. We also removeJUMPDESTopcodes from the code section therefore the total bytecode length remains the same if extreme examples are ignored.", "LEB128 for offsets": "The LEB128 encoding is the most popular VLQ used in DWARF and WebAssembly.", "Size-prefix for offsets": "This is another option for encoding inspired by UTF-8. The benefit is that the number of following bytes is encoded in the first byte (the top two bits), so the expected length is known upfront.", "Empty table": "In case code does not use jumps, an empty JUMPDEST table is represented by omittingjumpdestssection as opposed to a section that is always present, but allowed to be empty. This is consistent with the requirement of EIP-3540 for section size to be non-zero. Additionally, omitting the section saves 3 bytes of code storage.", "Why jumpdests before code?": "The contents ofjumpdestssection are always needed to start EVM execution. For chunked and/or merkleized bytecode it is more efficient to havejumpdestsjust after the EOF header so they can share the same first chunk(s).", "Code chunking / merkleization": "In code chunking the contract code is split into (fixed size) chunks. Due to the requirement of jumpdest-analysis, it must be known where the first instruction starts in a given chunk, in case the split happened within a PUSH-data. This is commonly accomplished with reserving the first byte of the chunk as the \u201cfirst instruction offset\u201d (FIO) field.", "Benchmarks / performance analysis": "We compared the performance ofjumpdestssection loading to JUMPDEST analysis in evmone/Baseline interpreter. In both cases a bitset of valid jumpdest positions is built.", "Reference Implementation": "We extend thevalidate_code()function ofEIP-3670:", "Test Cases": "This change poses no risk to backwards compatibility, as it is introduced at the same time EIP-3540 is. The requirement of a JUMPDEST table does not cover legacy bytecode.", "Backwards Compatibility": "This change poses no risk to backwards compatibility, as it is introduced at the same time EIP-3540 is. The requirement of a JUMPDEST table does not cover legacy bytecode.", "Security Considerations": "The authors are not aware of any security or DoS risks posed by this change.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3756, "url": "https://eips.ethereum.org/EIPS/eip-3756", "title": "Gas Limit Cap", "authors": ["lightclient\u00a0(", "@lightclient", ")"], "sections": {"EIP-3756: Gas Limit Cap": "Set an in-protocol cap for the gas limit of 30,000,000.", "Set an in-protocol cap for the gas limit": "Set an in-protocol cap for the gas limit of 30,000,000.", "Abstract": "Set an in-protocol cap for the gas limit of 30,000,000.", "Motivation": "A high gas limit increases pressure on the network. In the benign case, it\nincreases the size of the state and history faster than we can sustain. In the\nmalicious case, it amplifies the devastation of certain denial-of-service\nattacks.", "Specification": "As of the fork blockN, consider blocks with agas_limitgreater than30,000,000invalid.", "Rationale": "The gas limit is currently under the control of block proposers. They have the\nability to increase the gas limit to whatever value they desire. This allows\nthem to bypass the EIP and All Core Devs processes in protocol decisions that\nmay negatively affect the security and/or decentralization of the network.", "Why Cap the Gas Limit": "The gas limit is currently under the control of block proposers. They have the\nability to increase the gas limit to whatever value they desire. This allows\nthem to bypass the EIP and All Core Devs processes in protocol decisions that\nmay negatively affect the security and/or decentralization of the network.", "No Fixed Gas Limit": "A valuable property of proposers choosing the gas limit is they can scale it\ndown quickly if the network becomes unstable or is undergoing certain types of\nattacks. For this reason, we maintain their ability to lower the gas limitbelow30,000,000.", "Backwards Compatibility": "No backwards compatibility issues.", "Test Cases": "TBD", "Security Considerations": "No security considerations.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3788, "url": "https://eips.ethereum.org/EIPS/eip-3788", "title": "Strict enforcement of chainId", "authors": ["Gregory Markou\u00a0(", "@GregTheGreek", ")"], "sections": {"EIP-3788: Strict enforcement of chainId": "Reject transactions that do not explicitly have the same chainId as the node\u2019s configuration.", "Reject transactions that do not explicitly have the same chainId as the node's configuration.": "Reject transactions that do not explicitly have the same chainId as the node\u2019s configuration.", "Abstract": "Reject transactions that do not explicitly have the same chainId as the node\u2019s configuration.", "Motivation": "PerEIP-155a transaction with achainId = 0is considered to be a valid \ntransaction. This was a feature to offer developers the ability to submit replayable transactions \nacross different chains. With the rise of evm compatible chains, many of which use forks, or packages\nfrom popular Ethereum clients, we are putting user funds at risk. This is because most wallet\ninterfaces do not expose the chainId to the user, meaning they typically do not have insight\ninto what chainId they are signing. Should a malicious actor (or accidental) choose to, they\ncan easily have users submit transactions with achainId = 0on a non-mainnet network, allowing\nthe malicious actor to replay the transaction on ethereum mainnet (or other networks for that matter)\nas a grief or sophisticated attack.", "Specification": "As of the fork blockN, consider transactions with achaindId = 0to be invalid. Such that \ntransactions are verified based on the nodes configuration. Eg:", "Rationale": "The configuration set by the node is the main source of truth, and thus should be explicitly used\nwhen deciding how to filter out a transaction. This check should exist in two places, as a filter\non the JSON-RPC (eg:eth_sendTransaction), and strictly enforced on the EVM during transaction \nvalidation.", "Backwards Compatibility": "This breaks all applications or tooling that submit transactions with achainId == 0after block numberN.", "Test Cases": "TBD", "Security Considerations": "It should be noted this will not prevent a malicious actor from deploying a network withchainId = 1, or copying any other networks chainId.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3978, "url": "https://eips.ethereum.org/EIPS/eip-3978", "title": "Gas refunds on reverts", "authors": ["Anton Bukov\u00a0(", "@k06a", ")", "Mikhail Melnik\u00a0(", "@ZumZoom", ")"], "sections": {"EIP-3978: Gas refunds on reverts": "For reverted state modification operations, keep access cost, but refund modification cost.", "Reprice reverted SSTORE/CREATE/SELFDESTRUCT/LOGX operations gas via gas refund mechanism": "For reverted state modification operations, keep access cost, but refund modification cost.", "Abstract": "For reverted state modification operations, keep access cost, but refund modification cost.", "Motivation": "Reverting a transaction, or any of its sub-calls, drops any state modifications that happened inside.\nBut now, users are being charged for the dropped modifications as if they persisted.", "Specification": "For each callframe, trackrevert_gas_refund, initially 0.", "Rationale": "Gas should reflect the cost of use.\nThe revert cost reflects the cost of access during execution, but not the cost of modification.", "Backwards Compatibility": "No known backward incompatibilities.", "Test Cases": "TBD", "Reference Implementation": "TBD", "Security Considerations": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 4396, "url": "https://eips.ethereum.org/EIPS/eip-4396", "title": "Time-Aware Base Fee Calculation", "authors": ["Ansgar Dietrichs\u00a0(", "@adietrichs", ")"], "sections": {"EIP-4396: Time-Aware Base Fee Calculation": "This EIP proposes accounting for time between blocks in the base fee calculation to target a stable throughput by time, instead of by block. Aiming to minimize changes to the calculation, it only introduces a variable block gas target proportional to the block time. The EIP can, in principle, be applied to either a Proof-of-Work or a Proof-of-Stake chain, however the security implications for the Proof-of-Work case remain unexplored.", "Accounts for block time in the base fee calculation to target a stable throughput by time instead of by block.": "This EIP proposes accounting for time between blocks in the base fee calculation to target a stable throughput by time, instead of by block. Aiming to minimize changes to the calculation, it only introduces a variable block gas target proportional to the block time. The EIP can, in principle, be applied to either a Proof-of-Work or a Proof-of-Stake chain, however the security implications for the Proof-of-Work case remain unexplored.", "Abstract": "This EIP proposes accounting for time between blocks in the base fee calculation to target a stable throughput by time, instead of by block. Aiming to minimize changes to the calculation, it only introduces a variable block gas target proportional to the block time. The EIP can, in principle, be applied to either a Proof-of-Work or a Proof-of-Stake chain, however the security implications for the Proof-of-Work case remain unexplored.", "Motivation": "The current base fee calculation chooses the gas usage of a block as the signal to determine whether demand for block space is too low (indicating that the base fee should be lowered) or too high (indicating that the base fee should be increased). While simple, this choice of signal has drawbacks: it does not take the block time into account. Assuming a relatively constant demand, a proposer constructing a block after 20 seconds will have transactions available with twice the gas of a proposer constructing a block after 10 seconds. Using the same gas target for both is accordingly sub-optimal. In practice, there are several undesirable consequences of this flawed signal:", "Base Fee Volatility Under Proof-of-Work": "Under Proof-of-Work (PoW), block times are stochastic, and for that reason there exists large block time variability. This variability contributes to the base fee volatility, where the base fee can be expected to oscillate around the equilibrium value even under perfectly stable demand.", "Missed Slots": "Under Proof-of-Stake (PoS), block times are ideally uniform (always 12s), but missed slots lead to individual blocks with increased block time (24s, 36s, \u2026). Such missed slots will result in the next block being overfull, and with the current update rule, signal a fake demand spike and thus cause a small unwarranted base fee spike.", "Throughput Degradation During Consensus Issues": "A more severe version of individual missed slots can be caused by consensus issues that prevent a significant portion of block proposers from continuing to create blocks. This can be due to block proposers forking off (and creating blocks on their own fork), being unable to keep up with the current chain head for another reason, or simply being unable to create valid blocks.", "Specification": "Using the pseudocode language ofEIP-1559, the updated base fee calculation becomes:", "Rationale": "The proposed new base fee calculation only adjusts the block gas target by scaling it with the block time, capped at a maximum percent of the overall block gas limit:", "Mechanism": "The proposed new base fee calculation only adjusts the block gas target by scaling it with the block time, capped at a maximum percent of the overall block gas limit:", "Limitations": "Under PoS, block time increases always come in multiples of full blocks (e.g. a single missed slot = 24s instead of 12s block time). Accounting for this already requires doubling the block gas target, even for a single missed slot. However, with the block elasticity currently set to 2, this target would be equal to the block gas limit. Having the new target equal to the block gas limit is less than ideal, and thus is reduced slightly, according to theMAX_GAS_TARGET_PERCENTparameter. The reason for the existence of this parameter is twofold:", "Possible Extensions": "These limitations directly result from the design goal of a minimal change, to maximize chances of being included in the merge. There are natural ways of extending the EIP design to more effectively handle offline validators, at the expense of somewhat more extensive changes:", "Backwards Compatibility": "The EIP has minimal impact on backwards compatibility, only requiring updates to existing base fee calculation tooling.", "Test Cases": "tbd", "Reference Implementation": "tbd", "Security Considerations": "Under PoW, miners are in control over the timestamp field of their blocks. While there are some enforced limits to valid timestamps, implications regarding potential timestamp manipulation are nontrivial and remain unexplored for this EIP.", "Timestamp Manipulation": "Under PoW, miners are in control over the timestamp field of their blocks. While there are some enforced limits to valid timestamps, implications regarding potential timestamp manipulation are nontrivial and remain unexplored for this EIP.", "Suppressing Base Fee Increases": "As discussed in the rationale, a high value forMAX_GAS_TARGET_PERCENTduring times of many offline block proposers results in a small remaining signal space for genuine demand increases that should result in base fee increases. This in turn decreases the cost for block proposers for suppresing these base fee increases, instead forcing the fallback to a first-price priority fee auction.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 4488, "url": "https://eips.ethereum.org/EIPS/eip-4488", "title": "Transaction calldata gas cost reduction with total calldata limit", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")"], "sections": {"EIP-4488: Transaction calldata gas cost reduction with total calldata limit": "Decrease transaction calldata gas cost, and add a limit of how much total transaction calldata can be in a block.", "Greatly decreases the gas cost of transaction calldata and simultaneously caps total transaction calldata in a block": "Decrease transaction calldata gas cost, and add a limit of how much total transaction calldata can be in a block.", "Abstract": "Decrease transaction calldata gas cost, and add a limit of how much total transaction calldata can be in a block.", "Motivation": "Rollups are in the short and medium term, and possibly the long term, the only trustless scaling solution for Ethereum. Transaction fees on L1 have been very high for months and there is greater urgency in doing anything required to help facilitate an ecosystem-wide move to rollups. Rollups are significantly reducing fees for many Ethereum users: Optimism and Arbitrum frequently provide fees that are ~3-8x lower than the Ethereum base layer itself, and ZK rollups, which have better data compression and can avoid including signatures, have fees ~40-100x lower than the base layer.", "Specification": "Reduce the gas cost of transaction calldata toNEW_CALLDATA_GAS_COSTper byte, regardless of whether the byte is zero or nonzero.", "Rationale": "A natural alternative proposal is to decreaseNEW_CALLDATA_GAS_COSTwithout adding a limit. However, this presents a security concern: today, the average block sizeis 60-90 kB, but themaximumblock size is30M / 16 = 1,875,000bytes (plus about a kilobyte of block and tx overhead). Simply decreasing the calldata gas cost from 16 to 3 would increase the maximum block size to 10M bytes. This would push the Ethereum p2p networking layer to unprecedented levels of strain and risk breaking the network; some previous live tests of ~500 kB blocks a few years ago had already taken down a few bootstrap nodes.", "Backwards Compatibility": "This is a backwards incompatible gas repricing that requires a scheduled network upgrade.", "Security Considerations": "Theburstdata capacity of the chain does not increase as a result of this proposal (in fact, it slightly decreases). However, theaveragedata capacity will increase. This means that the storage requirements of history-storing will go up. A worst-case scenario would be a theoretical long-run maximum of ~1,262,861 bytes per 12 sec slot, or ~3.0 TB per year.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 4520, "url": "https://eips.ethereum.org/EIPS/eip-4520", "title": "Multi-byte opcodes prefixed by EB and EC.", "authors": ["Brayton Goodall\u00a0(", "@Spore-Druid-Bray", ")", "Mihir Faujdar\u00a0(", "@uink45", ")"], "sections": {"EIP-4520: Multi-byte opcodes prefixed by EB and EC.": "Reserve0xEBand0xECfor usage as extended opcode space.", "Reserve `0xEB` and `0xEC` for usage as extended opcode space.": "Reserve0xEBand0xECfor usage as extended opcode space.", "Abstract": "Reserve0xEBand0xECfor usage as extended opcode space.", "Motivation": "It would be convenient to introduce new opcodes that are likely to be infrequently used, whilst also being able to have greater than 256 opcodes in total. As a single byte opcode is half the size of a double byte opcode, the greatest efficiency in code sizes will be one where frequently used opcodes are single bytes. Two prefix bytes are used to accommodate up to 510 double byte opcodes.", "Specification": "For example, a new arithmetic opcode may be allocated to0xEC 01(ADD), and a novel opcode may be introduced at0xEB F4(DELEGATECALL).", "Rationale": "It was considered that two prefix bytes rather than one would be adequate for reservation as extension addresses. Both0xEBand0xECwere chosen to be part of the E-series of opcodes. For example, the0xEFbyte is reserved for contracts conforming to the Ethereum Object Format. By having unassigned opcodes for extending the opcode space, there will be a lower risk of breaking the functionalities of deployed contracts compared to choosing assigned opcodes.", "Backwards Compatibility": "Previous usage of0xEBand0xECmay result in unexpected behaviour and broken code.", "Security Considerations": "There are no known security considerations.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 4573, "url": "https://eips.ethereum.org/EIPS/eip-4573", "title": "Procedures for the EVM", "authors": ["Greg Colvin\u00a0(", "@gcolvin", ")", "Greg Colvin\u00a0<", "greg@colvin.org", ">"], "sections": {"EIP-4573: Procedures for the EVM": "Five EVM instructions are introduced to define, call, and return from named EVMproceduresand access theircall framesin memory -ENTERPROC,LEAVEPROC,CALLPROC,RETURNPROC, andFRAMEADDRESS.", "Introduces support for EVM Procedures.": "Five EVM instructions are introduced to define, call, and return from named EVMproceduresand access theircall framesin memory -ENTERPROC,LEAVEPROC,CALLPROC,RETURNPROC, andFRAMEADDRESS.", "Abstract": "Five EVM instructions are introduced to define, call, and return from named EVMproceduresand access theircall framesin memory -ENTERPROC,LEAVEPROC,CALLPROC,RETURNPROC, andFRAMEADDRESS.", "Motivation": "Currently, Ethereum bytecode has no syntactic structure, andsubroutineshave no defined interfaces.", "Prior Art": "The terminology is not well-defined, but we will follow Intel in calling the low-level conceptsubroutinesand the higher level conceptprocedures.  The distinction is thatsubroutinesare little more than a jump that knows where it came from, whereas procedures have a defined interface and manage memory as a stack.EIP-2315introducessubroutines, and this EIP introducesprocedures.", "Specification": "Marks the entry point to a procedure", "Instructions": "Marks the entry point to a procedure", "Memory Costs": "Presently,MSTOREis defined as", "Call Frame Stack": "These instructions make use of aframe stackto allocate and free frames of local data forproceduresin memory.  Frame memory begins at address 0 in memory and grows downwards, towards more negative addresses.  A frame is allocated for each procedure when it is called, and freed when it returns.", "Rationale": "There is actually not much new here.  It amounts toEIP-615, refined and refactored into bite-sized pieces, along lines common to other machines.", "Backwards Compatibility": "This proposal adds new EVM opcodes.  It doesn\u2019t remove or change the semantics of any existing opcodes, so there should be no backwards compatibility issues.", "Security": "Safe use of these constructs must be checked completely at validation time \u2013 per EIP-3779 \u2013 so there should be no security issues at runtime.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 4747, "url": "https://eips.ethereum.org/EIPS/eip-4747", "title": "Simplify EIP-161", "authors": ["Peter Davies\u00a0(", "@petertdavies", ")"], "sections": {"EIP-4747: Simplify EIP-161": "Simplify the definition ofEIP-161, removing the requirement for implementors to support edge cases that are impossible on Ethereum Mainnet.", "Simplify EIP-161 and retroactively deprecate unused aspects of it": "Simplify the definition ofEIP-161, removing the requirement for implementors to support edge cases that are impossible on Ethereum Mainnet.", "Abstract": "Simplify the definition ofEIP-161, removing the requirement for implementors to support edge cases that are impossible on Ethereum Mainnet.", "Motivation": "EIP-161 is overly complex and has a number of edge cases that are poorly documented and tested. This EIP takes advantage of the complete removal of all remaining empty accounts in block 14049881 (tx0xf955834bfa097458a9cf6b719705a443d32e7f43f20b9b0294098c205b4bcc3d) to clarify it, and allows implementors to not implement various edge cases that never occurred and are not possible in the future.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Rationale": "EIP-161 provides that empty accounts (accounts that have zero nonce, zero balance and no code, but that might have storage) can no longer be created and provides mechanism to remove old empty accounts. The last empty accounts were removed in block 14049881 (tx0xf955834bfa097458a9cf6b719705a443d32e7f43f20b9b0294098c205b4bcc3d).", "Backwards Compatibility": "This EIP is identical to EIP-161 except for the following differences, none of which affect Ethereum Mainnet. The differences are:", "\u201cPotentially state-changing operations\u201d": "EIP-161 specifies 11 \u201cpotentially state-changing operations\u201d that trigger state clearing. All but the 3 listed in this EIP are irrelevant, for the following reasons:", "Interaction withSTATICCALL": "The interaction betweenSTATICCALLand account clearing has never been specified in an EIP. The Ethereum currently testsuite requires thatSTATICCALLtriggers state clearing.", "\u201cAt the end of the transaction\u201d": "This only makes a difference if an account is deleted and later recreated in the same transaction. This never happens on Ethereum Mainnet.", "Test Cases": "All test cases involving empty accounts in the Ethereum execution layer test suite shall be removed unless they relate to the Spurious Dragon Hardfork. If a Spurious Dragon test relates involved deprecated edgecase the test must be removed or reworked.", "Other networks": "Ropsten had empty accounts seeded at genesis. They appear to have been cleared early in Ropsten\u2019s history before the Byzantium hardfork. Ropsten has never been checked for edgecases occurring. All other Ethereum testnets have had EIP-161 from genesis.", "Security considerations": "This EIP is only equivalent to EIP-161 on Ethereum Mainnet if the following facts are true:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 4758, "url": "https://eips.ethereum.org/EIPS/eip-4758", "title": "Deactivate SELFDESTRUCT", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")", "Dankrad Feist\u00a0(", "@dankrad", ")"], "sections": {"EIP-4758: Deactivate SELFDESTRUCT": "This EIP renames theSELFDESTRUCTopcode toSENDALL, and replaces its functionality. The new functionality will be only to send all Ether in the account to the caller.", "Deactivate SELFDESTRUCT by changing it to SENDALL, which does recover all funds to the caller but does not delete any code or storage.": "This EIP renames theSELFDESTRUCTopcode toSENDALL, and replaces its functionality. The new functionality will be only to send all Ether in the account to the caller.", "Abstract": "This EIP renames theSELFDESTRUCTopcode toSENDALL, and replaces its functionality. The new functionality will be only to send all Ether in the account to the caller.", "Motivation": "TheSELFDESTRUCTopcode requires large changes to the state of an account, in particular removing all code and storage. This will not be possible in the future with Verkle trees: Each account will be stored in many different account keys, which will not be obviously connected to the root account.", "Specification": "Getting rid of theSELFDESTRUCTopcode has been considered in the past, and there are currently no strong reasons to use it. Disabling it will be a requirement for statelessness.", "Rationale": "Getting rid of theSELFDESTRUCTopcode has been considered in the past, and there are currently no strong reasons to use it. Disabling it will be a requirement for statelessness.", "Backwards Compatibility": "This EIP requires a hard fork, since it modifies consensus rules.", "Security Considerations": "The following applications ofSELFDESTRUCTwill be broken and applications that use it in this way are not safe anymore:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 4760, "url": "https://eips.ethereum.org/EIPS/eip-4760", "title": "SELFDESTRUCT bomb", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")", "Dankrad Feist\u00a0(", "@dankrad", ")"], "sections": {"EIP-4760: SELFDESTRUCT bomb": "This EIP renames theSELFDESCRUCTopcode toSENDALL, and replaces its functionality. The new functionality will be only to send all Ether in the account to the caller.", "Deactivate SELFDESTRUCT by changing it to SENDALL and stage this via a stage of exponential gas cost increases.": "This EIP renames theSELFDESCRUCTopcode toSENDALL, and replaces its functionality. The new functionality will be only to send all Ether in the account to the caller.", "Abstract": "This EIP renames theSELFDESCRUCTopcode toSENDALL, and replaces its functionality. The new functionality will be only to send all Ether in the account to the caller.", "Motivation": "TheSELFDESTRUCTopcode requires large changes to the state of an account, in particular removing all code and storage. This will not be possible in the future with Verkle trees: Each account will be stored in many different account keys, which will not be obviously connected to the root account.", "Specification": "The idea behind this EIP is to disableSELFDESTRUCTin a way that gives ample warning to Dapp developers. Many developers do not watch the EIP process closely and can therefore be caught by surprise when an opcode is deactivated and does not fulfill its original purpose anymore. However, at least if the smart contract has regular use, then users will notice the price of the operation going up tremendously. The period over which this is happening (HARD_FORK_BLOCK + DOUBLING_SLOTS * DOUBLINGS_BEFORE_SENDALL) is chosen to be long enough (ca. 4 months) such that it gives developers time to react to this change and prepare their application.", "Constants": "The idea behind this EIP is to disableSELFDESTRUCTin a way that gives ample warning to Dapp developers. Many developers do not watch the EIP process closely and can therefore be caught by surprise when an opcode is deactivated and does not fulfill its original purpose anymore. However, at least if the smart contract has regular use, then users will notice the price of the operation going up tremendously. The period over which this is happening (HARD_FORK_BLOCK + DOUBLING_SLOTS * DOUBLINGS_BEFORE_SENDALL) is chosen to be long enough (ca. 4 months) such that it gives developers time to react to this change and prepare their application.", "Rationale": "The idea behind this EIP is to disableSELFDESTRUCTin a way that gives ample warning to Dapp developers. Many developers do not watch the EIP process closely and can therefore be caught by surprise when an opcode is deactivated and does not fulfill its original purpose anymore. However, at least if the smart contract has regular use, then users will notice the price of the operation going up tremendously. The period over which this is happening (HARD_FORK_BLOCK + DOUBLING_SLOTS * DOUBLINGS_BEFORE_SENDALL) is chosen to be long enough (ca. 4 months) such that it gives developers time to react to this change and prepare their application.", "Backward Compatibility": "This EIP requires a hard fork, since it modifies consensus rules.", "Security Considerations": "The following applications ofSELFDESTRUCTwill be broken and applications that use it in this way are not safe anymore:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 4863, "url": "https://eips.ethereum.org/EIPS/eip-4863", "title": "Beacon chain push withdrawals", "authors": ["Alex Stokes\u00a0(", "@ralexstokes", ")", "Danny Ryan\u00a0(", "@djrtwo", ")"], "sections": {"EIP-4863: Beacon chain push withdrawals": "Introduce a newEIP-2718 transaction typeto support validator withdrawals that are \u201cpushed\u201d from the beacon chain to the EVM.", "Support validator withdrawals from the beacon chain to the EVM via a new \"push-style\" transaction type.": "Introduce a newEIP-2718 transaction typeto support validator withdrawals that are \u201cpushed\u201d from the beacon chain to the EVM.", "Abstract": "Introduce a newEIP-2718 transaction typeto support validator withdrawals that are \u201cpushed\u201d from the beacon chain to the EVM.", "Motivation": "This EIP provides a way for validator withdrawals made on the beacon chain to enter into the EVM.\nThe architecture is \u201cpush\u201d-based, rather than \u201cpull\u201d-based, where withdrawals are required to be processed in the execution block as soon as they are dequeued from the beacon chain.", "Specification": "Beginning with the execution timestampFORK_TIMESTAMP, execution clientsMUSTintroduce the following extensions to transaction processing and block validation:", "New transaction type": "Define a newEIP-2718transaction type withTransactionTypeWITHDRAWAL_TX_TYPE.", "Block validity": "If a block containsanytransactions withWITHDRAWAL_TX_TYPEtype, theyMUSTcome afterALLother transactions in the block.", "Transaction processing": "When processing a transaction withWITHDRAWAL_TX_TYPEtype, the implementation should increase the balance of theaddressspecified by\ntheWithdrawalTransactionby theamountof wei specified.", "Rationale": "This push approach gives validators a small subsidy with respect to processing, in lieu of needing to buy gas via normal EVM processing that would be required for a pull-based approach.", "Push vs pull approach": "This push approach gives validators a small subsidy with respect to processing, in lieu of needing to buy gas via normal EVM processing that would be required for a pull-based approach.", "Why a new transaction type?": "This EIP suggests a new transaction type as it has special semantics different from other existing types of EVM transactions.", "Why no (gas) costs for new transaction type?": "The maximum number of this transaction type that can reach the execution layer at a given time is bounded (enforced by the consensus layer) and this limit is kept small so that\nany execution layer operational costs are negligible in the context of the broader block execution.", "Why only balance updates? No general EVM execution?": "More general processing introduces the risk of failures, which complicates accounting on the beacon chain.", "Why new block validations?": "The beacon chain must be able to efficiently validate that the withdrawal transactions in a given execution block are\nthe ones expected based on its own internal scheduling logic to maintain the soundness of the withdrawal mechanism.", "Backwards Compatibility": "No issues.", "Security Considerations": "Consensus-layer validation of withdrawal transactions is critical to ensure that the proper amount of ETH is withdrawn back into the execution layer.\nThis consensus-layer to execution-layer ETH transfer does not have a current analog in the EVM and thus deserves very high security scrutiny.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 5000, "url": "https://eips.ethereum.org/EIPS/eip-5000", "title": "MULDIV instruction", "authors": ["Harikrishnan Mulackal\u00a0(", "@hrkrshnn", ")", "Alex Beregszaszi\u00a0(", "@axic", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")"], "sections": {"EIP-5000: MULDIV instruction": "Introduce a new instruction,MULDIV(x, y, z), to perform((x * y) / z) % 2**256in 512-bit precision.z = 0is a special case for(x * y) / 2**256.", "Introduce a new instruction to perform x * y / z in 512-bit precision": "Introduce a new instruction,MULDIV(x, y, z), to perform((x * y) / z) % 2**256in 512-bit precision.z = 0is a special case for(x * y) / 2**256.", "Abstract": "Introduce a new instruction,MULDIV(x, y, z), to perform((x * y) / z) % 2**256in 512-bit precision.z = 0is a special case for(x * y) / 2**256.", "Motivation": "Fixed point operations in high level languages are very commonly used on Ethereum, especially in the domain of financial applications.", "Specification": "A new instruction is introduced:MULDIV(0x1e).", "Rationale": "All the arithmetic instructions in EVM handle division or modulo 0 specially: the instructions return 0. We have decided to break consistency in order to provide a flexible opcode, which can be used to detect wrapping behaviour.", "The special 0 case": "All the arithmetic instructions in EVM handle division or modulo 0 specially: the instructions return 0. We have decided to break consistency in order to provide a flexible opcode, which can be used to detect wrapping behaviour.", "Argument ordering": "The order of arguments matchesaddmodandmulmod.", "Backwards Compatibility": "This is a new instruction not present prior.", "Test Cases": "TBA", "Security Considerations": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 5003, "url": "https://eips.ethereum.org/EIPS/eip-5003", "title": "Insert Code into EOAs with AUTHUSURP", "authors": ["Dan Finlay\u00a0(", "@danfinlay", ")", "Sam Wilson\u00a0(", "@SamWilsn", ")"], "sections": {"EIP-5003: Insert Code into EOAs with AUTHUSURP": "This EIP introduces a new opcode,AUTHUSURP, which deploys code at anEIP-3074authorized address. For externally owned accounts (EOAs), together withEIP-3607, this effectively revokes the original signing key\u2019s authority.", "Allow migrating away from ECDSA by deploying code in place of an externally owned account.": "This EIP introduces a new opcode,AUTHUSURP, which deploys code at anEIP-3074authorized address. For externally owned accounts (EOAs), together withEIP-3607, this effectively revokes the original signing key\u2019s authority.", "Abstract": "This EIP introduces a new opcode,AUTHUSURP, which deploys code at anEIP-3074authorized address. For externally owned accounts (EOAs), together withEIP-3607, this effectively revokes the original signing key\u2019s authority.", "Motivation": "EOAs currently hold a significant amount of user-controlled value on Ethereum blockchains, but are limited by the protocol in a variety of critical ways. These accounts do not support rotating keys for security, batching to save gas, or sponsored transactions to reduce the need to hold ether yourself. There are countless other benefits that come from having a contract account or account abstraction, like choosing one\u2019s own authentication algorithm, setting spending limits, enabling social recovery, allowing key rotation, arbitrarily and transitively delegating capabilities, and just about anything else we can imagine.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Conventions": "A new opcodeAUTHUSURPshall be created at0xf8. It shall take two stack elements and return one stack element.", "AUTHUSURP(0xf8)": "A new opcodeAUTHUSURPshall be created at0xf8. It shall take two stack elements and return one stack element.", "Rationale": "AUTHUSURPdoes not check the nonce of theauthorizedaccount because it must work with accounts that have previously sent transactions.", "Backwards Compatibility": "AUTHUSURPwith EIP-3607 revokes the authority of the original ECDSA signature to send transactions from the account. This is completely new behavior, although it is somewhat similar to theCREATE2opcode.", "Security Considerations": "Contracts using ECDSA signatures outside of transactions will not be aware that the usurped account is no longer controlled by a private key. This means that, for example, the private key willalwayshave access to thepermitfunction on token contracts. This can\u2014and should\u2014be mitigated by modifying theecrecoverpre-compiled contract.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 5022, "url": "https://eips.ethereum.org/EIPS/eip-5022", "title": "Increase price of SSTORE from zero to non-zero to 40k gas", "authors": ["Green\u00a0(", "@greenlucid", ")"], "sections": {"EIP-5022: Increase price of SSTORE from zero to non-zero to 40k gas": "Increase the price of the SSTORE opcode from20_000gas to40_000gas when the original slot is zero and the resultant slot is non-zero.", "": "Increase the price of the SSTORE opcode from20_000gas to40_000gas when the original slot is zero and the resultant slot is non-zero.", "Abstract": "Increase the price of the SSTORE opcode from20_000gas to40_000gas when the original slot is zero and the resultant slot is non-zero.", "Motivation": "The cost of creating a piece of new state increases as state is larger. However, the price for creating every new storage slot has not increased.\nAll resources are merged into the same pricing mechanism. If the price for creating new storage slots is fixed, then it needs to be manually changed.", "Rationale": "Rewriting storage does not affect state growth, which is the main issue this EIP is addressing. Rewriting storage may also be underpriced.\nIncreasing the price of state growth will, at least, incentivize developers to reuse storage instead.", "Why not also raise the cost of non-zero to non-zero?": "Rewriting storage does not affect state growth, which is the main issue this EIP is addressing. Rewriting storage may also be underpriced.\nIncreasing the price of state growth will, at least, incentivize developers to reuse storage instead.", "Why not also increase the gas refund from setting non-zero to zero?": "More discussion is needed on this.", "Why not a better state solution?": "Whereas solutions like state rent, or state expiry have been researched for a long time, they will not be ready on the short to medium term. So, it is desirable to patch pricing for the short term. Opcode repricing has been done before, so it should not impose a large development time investment for clients.", "Why was that specific amount chosen?": "The current pricing was made off a naive approach of benchmarking opcodes in a laptop. Not only it did not consider the long term problem of having the same price for a resource that costs more over time, the benchmark itself was wrong. This price is closer to what the naive original benchmark should have been. It could go higher, but that may be too disruptive.", "Is this too distruptive?": "This change will severely impact the gas cost of many applications. The network does not have to subsidize state growth at the expense of more expensive regular transactions, so even if it is too disruptive, it will increase the health of the network.", "Specification": "For blocks whereblock.number >= FORK_BLOCK, a new gas schedule applies. MakeSSTORE_SET_GAS, the price when a slot is set from zero to non-zero, equalNEW_STORAGE_PRICE. All other costs remain the same.", "Backwards compatibility": "Contracts that depend on hardcoded gas costs will break if they create state.", "Implementation": "https://github.com/ethereum/go-ethereum/pull/24725", "Security considerations": "TODO", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 5027, "url": "https://eips.ethereum.org/EIPS/eip-5027", "title": "Remove the limit on contract code size", "authors": ["Qi Zhou\u00a0(", "@qizhou", ")"], "sections": {"EIP-5027: Remove the limit on contract code size": "Remove the limit on the contract code size, i.e., only limit the contract code size by block gas limit, with minimal changes to existing code and proper gas metering adjustment to avoid possible attacks.", "Change the limit on contract size from 24576 to infinity": "Remove the limit on the contract code size, i.e., only limit the contract code size by block gas limit, with minimal changes to existing code and proper gas metering adjustment to avoid possible attacks.", "Abstract": "Remove the limit on the contract code size, i.e., only limit the contract code size by block gas limit, with minimal changes to existing code and proper gas metering adjustment to avoid possible attacks.", "Motivation": "The motivation is to remove the limit on the code size so that users can deploy a large-code contract without worrying about splitting the contract into several sub-contracts.", "Specification": "Ifblock.number >= FORK_BLKNUM, the contract creation initialization can return data with any length, but the contract-related opcodes will take extra gas as defined below:", "Parameters": "Ifblock.number >= FORK_BLKNUM, the contract creation initialization can return data with any length, but the contract-related opcodes will take extra gas as defined below:", "Rationale": "The goal is to measure the CPU/IO cost of the contract read/write operations reusing existing gas metering so that the resources will not be abused.", "Gas Metering": "The goal is to measure the CPU/IO cost of the contract read/write operations reusing existing gas metering so that the resources will not be abused.", "Backwards Compatibility": "All existing contracts will not be impacted by the proposal.", "Reference Implementation": "The reference implementation on Geth is available at0001-unlimit-code-size.patch.", "Security Considerations": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 5065, "url": "https://eips.ethereum.org/EIPS/eip-5065", "title": "Instruction for transferring ether", "authors": ["Mudit Gupta\u00a0(", "@maxsam4", ")"], "sections": {"EIP-5065: Instruction for transferring ether": "Add a new instruction that transfers ether to a destination address without handing over the flow of execution to it. It should work similarly to howSELFDESTRUCT (0xFF)transfers ether to the destination without making a call to it.", "Instruction for just transferring ether without transferring the flow of execution": "Add a new instruction that transfers ether to a destination address without handing over the flow of execution to it. It should work similarly to howSELFDESTRUCT (0xFF)transfers ether to the destination without making a call to it.", "Abstract": "Add a new instruction that transfers ether to a destination address without handing over the flow of execution to it. It should work similarly to howSELFDESTRUCT (0xFF)transfers ether to the destination without making a call to it.", "Motivation": "From an architectural point of view, execution flow should never be handed over to an untrusted contract. Ethereum currently does not have any ideal way to transfer ether without transferring the flow of execution. People have come up with reentrancy guards and similar solutions to prevent some types of attacks but it\u2019s not an ideal solution. The only way to transfer ether from smart contracts without triggering a call is to create a dummy contract, send the precise amount of ether to it and then callSELFDESTRUCT (0xFF)from it.", "Specification": "Introduce a new instruction,AIRDROP(0xFG) that transfers ether to the destination without making a call to it.", "Stack input": "address: the account to send ether to.\nvalue: value in wei to send to the account.", "Gas": "The total gas cost should be the sum of a static cost + address_access_cost + value_to_empty_account_cost.", "Rationale": "This behavior is already possible by deploying a new contract that doesSELFDESTRUCT (0xFF)but it is prohibitively expensive. In most scenarios, the contract author only wants to transfer ether rather than transferring control of the execution. ERC20 can be used as a case study for this where most users transfer funds without a post-transfer hook.", "Backwards Compatibility": "No known issues as this is a new instruction that does not affect any old instructions and does not break any valid assumptions since it make not anything impossible possible.", "Test Cases": "TODO", "Security Considerations": "No known security risks.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 5081, "url": "https://eips.ethereum.org/EIPS/eip-5081", "title": "Expirable Transaction", "authors": ["Zainan Victor Zhou\u00a0(", "@xinbenlv", ")", "Nick Johnson\u00a0(", "@Arachnid", ")", "Konrad Feldmeier\u00a0<", "konrad@brainbot.com", ">"], "sections": {"EIP-5081: Expirable Transaction": "This EIP adds a new transaction type of that includes expiration with a blocknum.", "This EIP adds a new transaction type of that includes expiration with a blocknum": "This EIP adds a new transaction type of that includes expiration with a blocknum.", "Abstract": "This EIP adds a new transaction type of that includes expiration with a blocknum.", "Motivation": "When a user sends a transactiontx0with a low gas price, sometimes it might not be high enough to be executed.\nA common resolution is for the user to submit the transaction again with the same nonce and higher gas price.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Parameters": "As ofFORK_BLOCK_NUMBER, a newEIP-2718transaction is introduced withTransactionType=TX_TYPE(TBD).", "Rationale": "TODO", "Backwards Compatibility": "TODO", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 5283, "url": "https://eips.ethereum.org/EIPS/eip-5283", "title": "Semaphore for Reentrancy Protection", "authors": ["Sergio D. Lerner\u00a0(", "@SergioDemianLerner", ")"], "sections": {"EIP-5283: Semaphore for Reentrancy Protection": "This EIP proposes adding a precompiled contract that provides a semaphore function for creating a new type of reentrancy protection guard (RPG). This function aims to replace the typical RPG based on modifying a contract storage cell. The benefit is that the precompile-based RPG does not write to storage, and therefore it enables contracts to be forward-compatible with all designs that provide fine-grained (i.e. cell level) parallelization for the multi-threaded execution of EVM transactions.", "A Precompile-based parallelizable reentrancy protection using the call stack": "This EIP proposes adding a precompiled contract that provides a semaphore function for creating a new type of reentrancy protection guard (RPG). This function aims to replace the typical RPG based on modifying a contract storage cell. The benefit is that the precompile-based RPG does not write to storage, and therefore it enables contracts to be forward-compatible with all designs that provide fine-grained (i.e. cell level) parallelization for the multi-threaded execution of EVM transactions.", "Abstract": "This EIP proposes adding a precompiled contract that provides a semaphore function for creating a new type of reentrancy protection guard (RPG). This function aims to replace the typical RPG based on modifying a contract storage cell. The benefit is that the precompile-based RPG does not write to storage, and therefore it enables contracts to be forward-compatible with all designs that provide fine-grained (i.e. cell level) parallelization for the multi-threaded execution of EVM transactions.", "Motivation": "The typical smart contract RPG uses a contract storage cell. The algorithm is simple: the code checks that a storage cell is 0 (or any other predefined constant) on entry, aborting if not, and then sets it to 1. After executing the required code, it resets the cell back to 0 before exiting. This is the algorithm implemented in OpenZeppelin\u2019s ReentrancyGuard. The algorithm results in a read-write pattern on the RPG\u2019s storage cell. This pattern prevents the parallelization of the execution of the smart contract for all known designs that try to provide fine-grained parallelization (detecting conflicts at the storage cell level).", "Specification": "Starting from an activation block (TBD) a new precompiled contractSemaphoreis created at address0x0A. WhenSemaphoreis called, if the caller address is present more than once in the call stack, the contract behaves as if the first instruction had been aREVERT, therefore the CALL returns 0. Otherwise, it executes no code and returns 1. The gas cost of the contract execution is set to 100, which is consumed independently of the call result.", "Rationale": "The address0x0Ais the next one available within the range defined byEIP-1352.", "Sample usage": "The only way to parallelize preexistent contracts that are using the storage RPG construction is that the VM automatically detects that a storage variable is used for the RPG, and proves that it works as required. This requires static code analysis. This is difficult to implement in consensus for two reasons. First, the CPU cost of detection and/or proving may be high. Second, some contract functions may not be protected by the RPG, meaning that some execution paths do not alter the RPG, which may complicate proving. Therefore this proposal aims to protect future contracts and let them be parallelizable, rather than to parallelize already deployed ones.", "Parallelizable storage-based RPGs": "The only way to parallelize preexistent contracts that are using the storage RPG construction is that the VM automatically detects that a storage variable is used for the RPG, and proves that it works as required. This requires static code analysis. This is difficult to implement in consensus for two reasons. First, the CPU cost of detection and/or proving may be high. Second, some contract functions may not be protected by the RPG, meaning that some execution paths do not alter the RPG, which may complicate proving. Therefore this proposal aims to protect future contracts and let them be parallelizable, rather than to parallelize already deployed ones.", "Alternatives": "There are alternative designs to implement RPGs on the EVM:", "Gas cost": "A gas cost of 100 represents a worst-case resource consumption, which occurs when the stack is almost full (approximately 400 addresses) and it is fully scanned. As the stack is always present in RAM, the scanning is fast.", "Backwards Compatibility": "This change requires a hard fork and therefore all full nodes must be updated.", "Test Cases": "A call tosecond()directly from a transaction does not revert, but a call tofirst()does revert.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 5478, "url": "https://eips.ethereum.org/EIPS/eip-5478", "title": "CREATE2COPY Opcode", "authors": ["Qi Zhou\u00a0(", "@qizhou", ")"], "sections": {"EIP-5478: CREATE2COPY Opcode": "Adding a new opcode,CREATE2COPY, that is identical toCREATE2but with potentially much lower gas cost by accepting an additional argumentexisting_contract_addressthat already stored the code of the new contract.", "Reducing the gas cost of contract creation with existing code": "Adding a new opcode,CREATE2COPY, that is identical toCREATE2but with potentially much lower gas cost by accepting an additional argumentexisting_contract_addressthat already stored the code of the new contract.", "Abstract": "Adding a new opcode,CREATE2COPY, that is identical toCREATE2but with potentially much lower gas cost by accepting an additional argumentexisting_contract_addressthat already stored the code of the new contract.", "Motivation": "This EIP aims to reduce the smart contract creation cost of account abstraction (AA) contracts that have identical code.", "Specification": "Ifblock.number >= FORK_BLKNUM, a new opcode is added (CREATE2COPY) at0xf6, which takes 5 stack arguments:endowment,memory_start,memory_length,salt,existing_contract_address.CREATE2COPYbehaves identically toCREATE2(0xf5as defined inEIP-1014), except that the code hash of the creating contract MUST be the same as that ofexisting_contract_address.", "Parameters": "Ifblock.number >= FORK_BLKNUM, a new opcode is added (CREATE2COPY) at0xf6, which takes 5 stack arguments:endowment,memory_start,memory_length,salt,existing_contract_address.CREATE2COPYbehaves identically toCREATE2(0xf5as defined inEIP-1014), except that the code hash of the creating contract MUST be the same as that ofexisting_contract_address.", "Rationale": "TBD", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 5806, "url": "https://eips.ethereum.org/EIPS/eip-5806", "title": "Delegate transaction", "authors": ["Hadrien Croubois\u00a0(", "@Amxx", ")"], "sections": {"EIP-5806: Delegate transaction": "This EIP adds a new transaction type that allows EOAs to execute arbitrary code using a delegate-call-like mechanism.", "Adds a new transaction type that allows EOAs to execute arbitrary code through delegation": "This EIP adds a new transaction type that allows EOAs to execute arbitrary code using a delegate-call-like mechanism.", "Abstract": "This EIP adds a new transaction type that allows EOAs to execute arbitrary code using a delegate-call-like mechanism.", "Motivation": "EOA are the most widely used type of account, yet their ability to perform operations is limited to deploying contracts and sending \u201ccall\u201d transactions. It is currently not possible for an EOA to execute arbitrary code, which greatly limits the interactions users can have with the blockchain. Account abstraction has been extensively discussed but the path toward mainstream adoption is still unclear. Some approaches, such asERC-4337hope to improve the usability of smart wallets, without addressing the issue of smart wallet support by applications.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Parameters": "As ofFORK_BLOCK_NUMBER, a newEIP-2718transaction is introduced withTransactionType=TX_TYPE(TBD).", "Opcode restriction": "For security reasons, some opcodes should not be executed in the context of an EOA:", "Rationale": "EOAs are the most widely used type of wallet.", "Backwards Compatibility": "No known backward compatibility issues thanks to the transaction envelope (EIP-2718).", "Security Considerations": "The nonce mechanism, already used in other transaction types, prevents replay attacks. Similar to existing transaction types, a delegate transaction can be cancelled by replacing it with a dummy transaction that pays more fees.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 5988, "url": "https://eips.ethereum.org/EIPS/eip-5988", "title": "Add Poseidon hash function precompile", "authors": ["Abdelhamid Bakhta\u00a0(", "@abdelhamidbakhta", ")", "Eli Ben Sasson\u00a0(", "@Elistark", ")", "Avihu Levy\u00a0(", "@avihu28", ")", "David Levit Gurevich\u00a0(", "@DavidLevitGurevich", ")"], "sections": {"EIP-5988: Add Poseidon hash function precompile": "This EIP introduces a new precompiled contract which implements the hash function used in the Poseidon cryptographic hashing algorithm, for the purpose of allowing interoperability between the EVM and ZK / Validity rollups, as well as introducing more flexible cryptographic hash primitives to the EVM.", "Add a precompiled contract which implements the hash function used in the Poseidon cryptographic hashing algorithm": "This EIP introduces a new precompiled contract which implements the hash function used in the Poseidon cryptographic hashing algorithm, for the purpose of allowing interoperability between the EVM and ZK / Validity rollups, as well as introducing more flexible cryptographic hash primitives to the EVM.", "Abstract": "This EIP introduces a new precompiled contract which implements the hash function used in the Poseidon cryptographic hashing algorithm, for the purpose of allowing interoperability between the EVM and ZK / Validity rollups, as well as introducing more flexible cryptographic hash primitives to the EVM.", "Motivation": "Poseidonis an arithmetic hash function that is designed to be efficient for Zero-Knowledge Proof Systems.\nEthereum adopts a rollup centric roadmap and hence must adopt facilities for L2s to be able to communicate with the EVM in an optimal manner.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Parameters": "Here are the Poseidon parameters that the precompile will support:", "Rationale": "TODO: Add rationale", "Backwards Compatibility": "There is very little risk of breaking backwards-compatibility with this EIP, the sole issue being if someone were to build a contract relying on the address at0xPOSEIDON_PRECOMPILE_ADDRESSbeing empty. The likelihood of this is low, and should specific instances arise, the address could be chosen to be any arbitrary value with negligible risk of collision.", "Test Cases": "The Poseidon reference implementation contains test vectors that can be used to test the precompile.\nThose tests are availablehere.", "Security Considerations": "Quoting Vitalik Buterin fromArithmetic hash based alternatives to KZG for proto-dankshardingthread on EthResearch:", "Security of the Poseidon parameters": "The MDS matrix is a square matrix of sizet*tthat is used to mix the state.", "Papers and research related to Poseidon security": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6046, "url": "https://eips.ethereum.org/EIPS/eip-6046", "title": "Replace SELFDESTRUCT with DEACTIVATE", "authors": ["Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-6046: Replace SELFDESTRUCT with DEACTIVATE": "ChangeSELFDESTRUCTto not delete all storage keys, and to use a special value in the account nonce to signaldeactivatedaccounts. Because the semantics of revival change (storage keys may exists), we also rename the instruction toDEACTIVATE.", "Change SELFDESTRUCT to not delete storage keys and use a special value in the account nonce to signal deactivation": "ChangeSELFDESTRUCTto not delete all storage keys, and to use a special value in the account nonce to signaldeactivatedaccounts. Because the semantics of revival change (storage keys may exists), we also rename the instruction toDEACTIVATE.", "Abstract": "ChangeSELFDESTRUCTto not delete all storage keys, and to use a special value in the account nonce to signaldeactivatedaccounts. Because the semantics of revival change (storage keys may exists), we also rename the instruction toDEACTIVATE.", "Motivation": "TheSELFDESTRUCTinstruction currently has a fixed price, but is unbounded in terms of how many storage/account changes it performs (it needs to delete all keys). This has been an outstanding concern for some time.", "Specification": "There have been various proposals of removingSELFDESTRUCTand many would just outright remove the deletion capability. This breaks certain usage patterns, which thedeactivationoption leaves intact, albeit with minor changes. This only affectsnewlydeployed code, and not existing one.", "Rationale": "There have been various proposals of removingSELFDESTRUCTand many would just outright remove the deletion capability. This breaks certain usage patterns, which thedeactivationoption leaves intact, albeit with minor changes. This only affectsnewlydeployed code, and not existing one.", "Backwards Compatibility": "This EIP requires a protocol upgrade, since it modifies consensus rules. The further restriction of nonce should not have an effect on accounts, as2^64-2is an unfeasibly high limit.", "Security Considerations": "The new behaviour of preserving storage has a potential effect on security. Contract authors must be aware and design contracts accordingly. There may be an effect on existing deployed code performing autonomous destruction and revival.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6188, "url": "https://eips.ethereum.org/EIPS/eip-6188", "title": "Nonce Cap", "authors": ["Gavin John\u00a0(", "@Pandapip1", ")"], "sections": {"EIP-6188: Nonce Cap": "This EIP caps the nonce at2^64-2, reserving it for contracts with unusual behavior, as defined in other EIPs.", "Caps the nonce at 2^64-2": "This EIP caps the nonce at2^64-2, reserving it for contracts with unusual behavior, as defined in other EIPs.", "Abstract": "This EIP caps the nonce at2^64-2, reserving it for contracts with unusual behavior, as defined in other EIPs.", "Motivation": "This EIP is not terribly useful on its own, as it adds additional computation without any useful side effects. However, it can be used by other EIPs.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "EOA Transactions": "The nonce of a transaction originating from an EOA MUST be less than2^64-2. If the nonce is either2^64-1or2^64-2, the transaction MUST be invalid.", "CREATEandCREATE2": "If a nonce would be incremented to2^64-1byCREATEorCREATE2, it is instead set to2^64-2.2^64-1is reserved for alias or other special contracts.", "Rationale": "Capping a nonce allows for contracts with special properties to be created, with their functionality based on their contract code. As such, only one nonce needs to be reserved.", "Backwards Compatibility": "This EIP requires a protocol upgrade, since it modifies consensus rules. The further restriction of nonce should not have an effect on accounts, as reaching a nonce of2^64-2is difficult.", "Security Considerations": "As it is not feasible for contract accounts to get to the nonce limit, any potential problems with opcodes that depend on the value of an account\u2019s nonce can be safely ignored.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6189, "url": "https://eips.ethereum.org/EIPS/eip-6189", "title": "Alias Contracts", "authors": ["Gavin John\u00a0(", "@Pandapip1", ")"], "sections": {"EIP-6189: Alias Contracts": "This EIP allows contracts to be turned into \u201calias contracts\u201d using a magic nonce. Alias contracts automatically forward calls to other contracts.", "Allows the creation of contracts that forward calls to other contracts": "This EIP allows contracts to be turned into \u201calias contracts\u201d using a magic nonce. Alias contracts automatically forward calls to other contracts.", "Abstract": "This EIP allows contracts to be turned into \u201calias contracts\u201d using a magic nonce. Alias contracts automatically forward calls to other contracts.", "Motivation": "This EIP is not terribly useful on its own, as it adds additional computation and gas costs without any useful side effects. However, in conjunction withEIP-6190, it can be used to make SELFDESTRUCT compatible with Verkle trees.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Definitions": "A contract is an alias contract if its nonce is2^64-1, and its contract code is equal to0x1.", "Prerequisites": "EIP-6188MUST be used to protect the magic nonce value of2^64-1.", "Opcode Changes": "The \u201ccallee\u201d refers to the account that is being called or being paid.", "Transfers to the zero address": "Transfers to the zero address continue to have the same effect as theCREATEopcode, and will cost extra gas as discussed in theCREATEandCREATE2section.", "Transaction Validity": "The \u201corigin\u201d refers to the account that sent the transaction to be validated.", "RPC Endpoint Changes": "Theeth_getStorageAtRPC endpoint must error if the target contract has a contract code of0x1and a nonce of2^64-1.", "Rationale": "The additional gas cost of25represents the cost of fetching the nonce and comparing it to the given value.", "Backwards Compatibility": "This EIP requires a protocol upgrade, since it modifies consensus rules. No existing contracts should be affected, as they will not have a nonce of2^64-1, nor will they have the contract code0x1.", "Security Considerations": "The additional gas costs may cause potential DoS attacks if they access an arbitrary contract\u2019s data or make frequent contract deactivations. Contract authors must be aware and design contracts accordingly. There may be an effect on existing deployed code performing autonomous destruction and revival.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6190, "url": "https://eips.ethereum.org/EIPS/eip-6190", "title": "Verkle-compatible SELFDESTRUCT", "authors": ["Gavin John\u00a0(", "@Pandapip1", ")"], "sections": {"EIP-6190: Verkle-compatible SELFDESTRUCT": "ChangesSELFDESTRUCTto only cause a finite number of state changes.", "Changes SELFDESTRUCT to only cause a finite number of state changes": "ChangesSELFDESTRUCTto only cause a finite number of state changes.", "Abstract": "ChangesSELFDESTRUCTto only cause a finite number of state changes.", "Motivation": "TheSELFDESTRUCTinstruction has a fixed price, but is unbounded in storage/account changes (it needs to delete all keys). This has been an outstanding concern for some time.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Prerequisites": "EIP-6188andEIP-6189must be used for this EIP to function correctly.", "SELFDESTRUCTBehaviour": "Instead of destroying the contract at the end of the transaction, instead, the following will occur at the end of the transaction in which it is invoked:", "Gas Cost ofSELFDESTRUCT": "The base gas cost ofSELFDESTRUCTis set to5000. The gas cost ofSELFDESTRUCTis increased by5000for each alias contract that forwarded to the contract being self-destructed. Finally, theEIP-2929gas cost increase is applied.", "Rationale": "This EIP is designed to be a step towards supportingSELFDESTRUCTin Verkle trees while making the minimum amount of changes.", "Backwards Compatibility": "This EIP requires a protocol upgrade, since it modifies consensus rules.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6475, "url": "https://eips.ethereum.org/EIPS/eip-6475", "title": "SSZ Optional", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")", "Zahary Karadjov\u00a0(", "@zah", ")"], "sections": {"EIP-6475: SSZ Optional": "This EIP introduces a newSimple Serialize (SSZ) typeto representOptional[T]values.", "New SSZ type to represent optional values": "This EIP introduces a newSimple Serialize (SSZ) typeto representOptional[T]values.", "Abstract": "This EIP introduces a newSimple Serialize (SSZ) typeto representOptional[T]values.", "Motivation": "Optional values are currently only representable in SSZ using workarounds. Adding proper support provides these benefits:", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Type definition": "Optional[T]is defined as a type that can represent:", "Default value": "The default value ofOptional[T]isNone.", "Serialization": "The deserialization of anOptional[T]depends on the input length:", "Deserialization": "The deserialization of anOptional[T]depends on the input length:", "Merkleization": "AnOptional[T]is merkleized as aList[T, 1].", "Rationale": "Union[None, T]leaves ambiguity about the intention whether the type may be extended in the future, i.e.,Union[None, T, U].", "Why notUnion[None, T]?": "Union[None, T]leaves ambiguity about the intention whether the type may be extended in the future, i.e.,Union[None, T, U].", "Why notList[T, 1]?": "The serialization is less compact for variable-lengthT, due to the extra offset table at the beginning of the list to indicate the list length.", "Backwards Compatibility": "Union[None, T]andList[T, 1]workarounds are not used at this time to representOptional[T].", "Test Cases": "SeeEIP assets.", "Reference Implementation": "None", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6810, "url": "https://eips.ethereum.org/EIPS/eip-6810", "title": "Ex Post Facto Cascading Revert", "authors": ["William Morriss\u00a0(", "@wjmelements", ")"], "sections": {"EIP-6810: Ex Post Facto Cascading Revert": "A new transaction type reverts one of a sender\u2019s prior transactions, and other transactions dependent on that state, recursively.", "Allow transactions to be reversed after confirmation": "A new transaction type reverts one of a sender\u2019s prior transactions, and other transactions dependent on that state, recursively.", "Abstract": "A new transaction type reverts one of a sender\u2019s prior transactions, and other transactions dependent on that state, recursively.", "Motivation": "While Ethereum has the capability of reversible transactions through smart contracts, instant settlement is the default.\nBut sometimes users make mistakes.\nMost mistakes are discovered quickly.\nHowever, once the transaction is confirmed, it is settled.\nThere are many use cases for reverting settled transactions.\nSome of the most-common mistakes are listed below.", "Specification": "A newEIP-2718transaction is introduced withTransactionType0x5a.\nTheEIP-2718TransactionPayloadfor this transaction isrlp([chainId, nonce, revertNonce, budget, signatureYParity, signatureR, signatureS]).\nThesignatureYParity, signatureR, signatureSelements of this transaction represent a secp256k1 signature overkeccak256(0x5a || rlp([chainId, nonce, revertNonce, budget])).\nTheEIP-2718ReceiptPayloadfor this transaction isrlp([status, budgetUsed, removedLogsBloom, [newReceiptPayloads]]), wherenewReceiptPayloadsis a sequential array of the updated receipts of all reverted transactions.", "Parameters": "A newEIP-2718transaction is introduced withTransactionType0x5a.\nTheEIP-2718TransactionPayloadfor this transaction isrlp([chainId, nonce, revertNonce, budget, signatureYParity, signatureR, signatureS]).\nThesignatureYParity, signatureR, signatureSelements of this transaction represent a secp256k1 signature overkeccak256(0x5a || rlp([chainId, nonce, revertNonce, budget])).\nTheEIP-2718ReceiptPayloadfor this transaction isrlp([status, budgetUsed, removedLogsBloom, [newReceiptPayloads]]), wherenewReceiptPayloadsis a sequential array of the updated receipts of all reverted transactions.", "Block gas limit": "A transaction of type0x5ashall be the only transaction in its block.", "Cascading revert operation": "A transaction fee budget is initialized to the value specified bybudget, denominated in ether.\nThis budget is the transaction fee for this type of transaction.\nReverted transaction fees are refunded from this budget.\nShould the budget be insufficient, the Ex Post Facto Cascading Revert transaction fails and the entire budget is paid to theCOINBASEspecified in the block header.\nOtherwise, the remainder of the budget after all transactions are reverted is paid to theCOINBASEaccount.", "Snap sync": "Due to the large amount of state that may be modified by such a transaction, slower clients should use snap sync to load the new state.", "Rationale": "The transaction must fill the entire block to prevent MEV attacks.", "Backwards Compatibility": "If we find any backwards compatibility issue we can maybe reverse those transactions.\nIf that doesn\u2019t work idk maybe need another hard fork.", "Test Cases": "Seems simple enough.\nTODO this later; should only take a few hours, tops.", "Reference Implementation": "Seems simple enough.\nTODO this later; should only take a few hours, tops.", "Security Considerations": "This specification has been audited by Illinois Senator Robert Peters.\nNo exploits were found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6811, "url": "https://eips.ethereum.org/EIPS/eip-6811", "title": "To The Moon\u201410 Minute Blocks", "authors": ["Pandapip1\u00a0(", "@Pandapip1", ")"], "sections": {"EIP-6811: To The Moon\u201410 Minute Blocks": "This EIP makes a minimal number of changes to allow Ethereum to be used on the moon and other potentially habitable bodies in Earth\u2019s solar system. It changes the time between blocks, the per-block validator reward, and the number of blocks per epoch.", "Increases the block time to facilitate finality over cosmic distances": "This EIP makes a minimal number of changes to allow Ethereum to be used on the moon and other potentially habitable bodies in Earth\u2019s solar system. It changes the time between blocks, the per-block validator reward, and the number of blocks per epoch.", "Abstract": "This EIP makes a minimal number of changes to allow Ethereum to be used on the moon and other potentially habitable bodies in Earth\u2019s solar system. It changes the time between blocks, the per-block validator reward, and the number of blocks per epoch.", "Motivation": "It is impossible for today\u2019s Ethereum to literally \u201cgo to the moon\u201d due to a limitation in the protocol: the block length. Should validators attempt to validate on the surface of the moon, they would find that the ~1.25 second communication delay (caused by the speed of light) might cause issues with synchronization, considering the 12-second timer between blocks. The validators would eventually be ejected on the terrestrial chain after leaking. If however a substantial number of validators are displaced (think 1/3), they might follow their own fork and would eventually eject the terrestrial to finalize their own chain.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "Many applications expect mainnet transactions to be included in a short amount of time. This would clearly no longer be the case. Such applications should switch to planetary rollups. Syncing rollups across heavenly bodies is outside the scope of this proposal.", "Backwards Compatibility": "Many applications expect mainnet transactions to be included in a short amount of time. This would clearly no longer be the case. Such applications should switch to planetary rollups. Syncing rollups across heavenly bodies is outside the scope of this proposal.", "Test Cases": "TODO.", "Security Considerations": "Definitely needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6873, "url": "https://eips.ethereum.org/EIPS/eip-6873", "title": "Preimage retention", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")"], "sections": {"EIP-6873: Preimage retention": "Enforce preimage collection by every node on the network from the fork preceding the verge, up to the fork. This is needed in case each node is responsible for their own conversion.", "Execution clients must retain the preimages of addresses and slots accessed between the fork preceding the verge, and the verge itself.": "Enforce preimage collection by every node on the network from the fork preceding the verge, up to the fork. This is needed in case each node is responsible for their own conversion.", "Abstract": "Enforce preimage collection by every node on the network from the fork preceding the verge, up to the fork. This is needed in case each node is responsible for their own conversion.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "Switching to verkle trees require a complete rehashing of all tree keys. Most execution clients store all keys hashed, without their preimages, which as the time of print take up 70GB on mainnet. In order to make these preimages available to everyone, the following course of action are available to each user:", "Backwards Compatibility": "No backward compatibility issues found.", "Reference Implementation": "All clients already implement preimage retention, at least as an option.", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6914, "url": "https://eips.ethereum.org/EIPS/eip-6914", "title": "Reuse Withdrawn Validator Indices", "authors": ["Lion\u00a0(", "@dapplion", ")", "Danny Ryan\u00a0(", "@djrtwo", ")"], "sections": {"EIP-6914: Reuse Withdrawn Validator Indices": "Reuse fully withdrawn validator indices after a sufficient safe-to-reuse period has passed to eliminate the unbounded growth of the beacon chain validator list as the validator set churns.", "Reuse fully withdrawn and safe to reuse validator indices for new beacon chain deposits.": "Reuse fully withdrawn validator indices after a sufficient safe-to-reuse period has passed to eliminate the unbounded growth of the beacon chain validator list as the validator set churns.", "Abstract": "Reuse fully withdrawn validator indices after a sufficient safe-to-reuse period has passed to eliminate the unbounded growth of the beacon chain validator list as the validator set churns.", "Motivation": "The beacon chain maintains a list of validators and a separate list of balances associated with each validator. When a new deposit for a new validator occurs, the current mechanism only appends, rather than reusing previously fully withdrawn validator indices. As validators fully withdraw and new validators enter, this means the two lists will grow unbounded.", "Specification": "The configuration values and mechanics of the specification can be found in theConsensus Layer specs.", "Consensus Layer": "The configuration values and mechanics of the specification can be found in theConsensus Layer specs.", "Execution Layer": "This specification does not require any changes to the Execution Layer.", "Rationale": "Thevalidatorsandbalanceslists are currently appended to each time a new Deposit for a new pubkey comes into the beacon chain. Due to the natural mechanics of stakers entering and leaving consensus over long time spans, these lists, thus the state size, will grow unbounded.", "Backwards Compatibility": "This is a backwards incompatible change to the Consensus Layer of Ethereum and must be scheduled with a hard fork.", "Test Cases": "Test cases are work-in-progress within the standard Consensus Layer tests.", "Security Considerations": "Validator indices cannot be immediately reused but instead must waitSAFE_EPOCHS_TO_REUSE_INDEXepochs to ensure that attestations cannot be \u201cpoisoned\u201d with withdrawn validator signatures \u2013 thus non-slashable \u2013 for at least the weak subjectivity period.", "Details of attack": "Assume a 1/3 attacker. Attacker exits N validators on the honest chain, where N is a small fraction of the validator set. These validators leave the exit queue and are withdrawable within a few days. Now N new deposits come in and overwrite the validators and most importantly their pubkeys.", "Mitigation": "Not overwriting withdrawn validators forSAFE_EPOCHS_TO_REUSE_INDEXepochs (3x the max weak subjectivity period) ensures that attestations cannot be poisoned within the accountable safety security window.", "Alternative": "Note that ifAttesterSlashings included a list of pubkeys instead of validator indices, then this would not be an issue. However this would require more breaking changes and would increase the data requirement of anAttesterSlashing, the largest Consensus Layer data type by a factor of 6.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6968, "url": "https://eips.ethereum.org/EIPS/eip-6968", "title": "Contract Secured Revenue on an EVM based L2", "authors": ["Zak Cole\u00a0<", "zak@numbergroup.xyz", ">", "Zak Cole\u00a0(", "@zscole", ")", "Kevin Owocki\u00a0<", "kevin@supermodular.xyz", ">", "lightclient\u00a0(", "@lightclient", ")"], "sections": {"EIP-6968: Contract Secured Revenue on an EVM based L2": "Contract Secured Revenue (CSR) allows smart contract developers to claim a percentage of all transaction fees paid by users when interacting with their smart contracts.", "Contract Secured Revenue on an EVM based L2": "Contract Secured Revenue (CSR) allows smart contract developers to claim a percentage of all transaction fees paid by users when interacting with their smart contracts.", "Abstract": "Contract Secured Revenue (CSR) allows smart contract developers to claim a percentage of all transaction fees paid by users when interacting with their smart contracts.", "Motivation": "Using protocol rewards of an L1 to fund smart contract development would be a big change to the way the current market works.  This EIPdoes notadvocate for any changes to the existing Ethereum L1.", "Specification": "The currentEIP-1559fee behavior is modified so thatheader.base_fee_per_gas * REVENUE_SHARE_QUOTIENTper gas is reallocated proportionally, based on gas used, to each contract executed during the transaction.", "Parameters": "The currentEIP-1559fee behavior is modified so thatheader.base_fee_per_gas * REVENUE_SHARE_QUOTIENTper gas is reallocated proportionally, based on gas used, to each contract executed during the transaction.", "Fee Mechanism": "The currentEIP-1559fee behavior is modified so thatheader.base_fee_per_gas * REVENUE_SHARE_QUOTIENTper gas is reallocated proportionally, based on gas used, to each contract executed during the transaction.", "Rationale": "A simpler mechanism would be to send the full transaction revenue to thetovalue of the transaction. This, however, does not accurately reward the composition of many different smart contracts and applications. Additionally, it is not compatible with smart contract wallets which, by definition, are often the first destination of a transaction.", "Tracking Gas Proportionally": "A simpler mechanism would be to send the full transaction revenue to thetovalue of the transaction. This, however, does not accurately reward the composition of many different smart contracts and applications. Additionally, it is not compatible with smart contract wallets which, by definition, are often the first destination of a transaction.", "Ephemeral Revenue Recipient Mapping": "Constructing the revenue recipient mapping ephemerally during each transaction appears inefficient on the surface. This value is expected to be relatively static and even if it did need to change, the change could be facilitated by the recipient contract.", "Security Considerations": "Similar to EIP-1559, we must consider the effects this will have on block size. Depending on the method by which this is implemented, it could increase maximum block size in the event that a significant number of contracts opt-in to CSR.", "Increased Max Block Size/Complexity": "Similar to EIP-1559, we must consider the effects this will have on block size. Depending on the method by which this is implemented, it could increase maximum block size in the event that a significant number of contracts opt-in to CSR.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6988, "url": "https://eips.ethereum.org/EIPS/eip-6988", "title": "Elected block proposer has not been slashed", "authors": ["Mikhail Kalinin\u00a0(", "@mkalinin", ")"], "sections": {"EIP-6988: Elected block proposer has not been slashed": "Introduces a modification to the consensus layer specification which ensures that slashed validator cannot be elected as block proposer.", "Prevents a slashed validator from being elected as a block proposer": "Introduces a modification to the consensus layer specification which ensures that slashed validator cannot be elected as block proposer.", "Abstract": "Introduces a modification to the consensus layer specification which ensures that slashed validator cannot be elected as block proposer.", "Motivation": "A block proposed by a slashed validator is rejected by the corresponding validity check in thephase0/process_block_headerfunction as defined in the consensus layer specification.", "Specification": "Specification of the proposed change can be found in/_features/eip6988/beacon-chain.md.", "Rationale": "This function is modified to read a proposer index from a beacon state if a slot of a latest block header is the same as thestate.slot.", "Modifyingget_beacon_proposer_index": "This function is modified to read a proposer index from a beacon state if a slot of a latest block header is the same as thestate.slot.", "Backwards Compatibility": "This fix changes proposer election mechanism in a backwards incompatible way and requires a hard fork to be deployed.", "Test Cases": "The following test cases were added to cover this change:", "Reference Implementation": "Reference implementation is in the same place asSpecification.", "Security Considerations": "There are no observed security issues introduced by the proposed change.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7266, "url": "https://eips.ethereum.org/EIPS/eip-7266", "title": "Remove BLAKE2 compression precompile", "authors": ["Pascal Caversaccio\u00a0(", "@pcaversaccio", ")"], "sections": {"EIP-7266: Remove BLAKE2 compression precompile": "This EIP removes theblake2f(0x09) precompile by changing the precompile behaviour to result in an exceptional abort.", "Remove the blake2f (0x09) precompile by changing the precompile behaviour to result in an exceptional abort": "This EIP removes theblake2f(0x09) precompile by changing the precompile behaviour to result in an exceptional abort.", "Abstract": "This EIP removes theblake2f(0x09) precompile by changing the precompile behaviour to result in an exceptional abort.", "Motivation": "EIP-152has never capitalised on a real-world use case. This fact is clearly reflected in the number of times the address0x09has been invoked (numbers from the date this EIP was created):", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "The EVM should be optimised for simplicity and future-proofness. The original Yellow Paper states:these are so-called \u2018precompiled\u2019 contracts, meant as a preliminary piece of architecture that may later become native extensions. Considering that no use cases have been realised in the last 3.5 years, we can conclude that the precompileblake2f(0x09) will never transition into a native opcode. In that sense, the precompileblake2f(0x09) is an obsolete carry-along with no real-world traction and thus should be removed. This removal will simplify the EVM to the extent that it only consists of clear instructions with real-world use cases. Eventually, the precompileblake2f(0x09) can be safely used as a test run for the phase-out and removal of EVM functions.", "Backwards Compatibility": "This EIP requires a hard fork as it modifies the consensus rules. Note that very few applications are affected by this change and a lead time of 6-12 months can be considered sufficient.", "Security Considerations": "There are no known additional security considerations introduced by this change.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7377, "url": "https://eips.ethereum.org/EIPS/eip-7377", "title": "Migration Transaction", "authors": ["lightclient\u00a0(", "@lightclient", ")", "Sam Wilson\u00a0(", "@samwilsn", ")", "Ansgar Dietrichs\u00a0(", "@adietrichs", ")"], "sections": {"EIP-7377: Migration Transaction": "Introduce a newEIP-2718transaction type with the format0x04 || rlp([chainId, nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit, codeAddr, storage, data, value, accessList, yParity, r, s])which sets the sending account\u2019scodefield in the state trie to thecodevalue atcodeAddrand applies the storage tuples to the sender\u2019s storage trie.", "Allow EOAs to send a one-time transaction which deploys code at their account.": "Introduce a newEIP-2718transaction type with the format0x04 || rlp([chainId, nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit, codeAddr, storage, data, value, accessList, yParity, r, s])which sets the sending account\u2019scodefield in the state trie to thecodevalue atcodeAddrand applies the storage tuples to the sender\u2019s storage trie.", "Abstract": "Introduce a newEIP-2718transaction type with the format0x04 || rlp([chainId, nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit, codeAddr, storage, data, value, accessList, yParity, r, s])which sets the sending account\u2019scodefield in the state trie to thecodevalue atcodeAddrand applies the storage tuples to the sender\u2019s storage trie.", "Motivation": "Smart contract wallets have long been touted as the solution to Ethereum\u2019s user experience woes. As early as 2015, there were proposals for allowing smart contracts to originate transactions in hopes that new users would flock to smart contract wallets to store their assets. So far, only a fraction of users have elected to do so.", "Specification": "At the fork blockX, introduce the migration transaction type.", "Migration Transaction": "The EIP-2718TransactionTypeis0x04and theTransactionPayloadisrlp([chainId, nonce, maxFeePerGas, maxPriorityFeePerGas, gasLimit, codeAddr, storage, data, value, accessList, yParity, r, s]).", "Rationale": "This transaction is only good for one-time use to migrate an EOA to a smart contract. It is designed to immediately call the deployed contract, which is at the sender\u2019s address, after deployment to allow the sender to do any kind of further processing.", "Notoaddress field": "This transaction is only good for one-time use to migrate an EOA to a smart contract. It is designed to immediately call the deployed contract, which is at the sender\u2019s address, after deployment to allow the sender to do any kind of further processing.", "Code pointer for deployment": "Naively, one could design the migration transaction to have a fieldcodeof typebytes. However, there would be substantial duplication of code calldata, since many users will want to deploy the exact same thing (often a wallet). Using a pointer instead acknowledges this overwhelming use case for the transaction type, and exploits it as an optimization.", "Cheaper storage": "Since the storage is guaranteed to be empty, there is no need to read before write. This means only 20,000 gas is needed to pay for theEIP-2200SSTORE_SET_GASvalue. This is a small discount to the normal cost of22,100, which isSSTORE_SET_GASplus theEIP-2929COLD_SLOAD_COSTof2100, because no load occurs.", "Intrinsic does not account for contract deployment": "This takes advantage of the fact that clients tend to store a single, unique copy of code; no matter the number of deployments. Therefore, the only operation here is changing a pointer in the state trie to the desired code.", "Manipulating transaction origin": "Many applications have a security checkcaller == originto verify the caller is an EOA. This is done to \u201cprotect\u201d assets. While it is usually more of a bandage than an actual fix, we attempt to placate these projects by modifying the origin of the transaction so the check will continue performing its duty.", "One-time migration": "There is no technical reason we couldn\u2019t allow EOAs to change their code at any time with this transaction type. The only inhibitor at the moment isEIP-3607which will cause migration transactions to be considered invalid if they come from an account with code already deployed. A functional reason for retaining this behavior though is that it makes it simpler to reason about contracts and their upgradability.", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "As with all sufficiently sophisticated account designs, if a user can be convinced to sign an arbitrary message, that message could be a migration transaction which is owned by a malicious actor instead of the user. This can generally be avoided if wallets treat these transactions withextremecare and create as much friction and verification as possible before completing the signature.", "Blind Signing": "As with all sufficiently sophisticated account designs, if a user can be convinced to sign an arbitrary message, that message could be a migration transaction which is owned by a malicious actor instead of the user. This can generally be avoided if wallets treat these transactions withextremecare and create as much friction and verification as possible before completing the signature.", "Onecrecover": "Applications standards such asERC-2612: Permit Extensionhave exploited the cryptographic relationship between EOA addresses and their private keys. Many tokens today support this extension, allowing EOAs to approve the transfer of fund from their account using only a signature. Although collisions between EOAs and contract accounts are considered unlikely andmaybe impossiblegiven today\u2019s computing power, this EIP would make it common place for private keys to exist for contract accounts. There are some considerations here regarding security:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7378, "url": "https://eips.ethereum.org/EIPS/eip-7378", "title": "Add time-weighted averaging to the base fee", "authors": ["Guy Goren (@guy-goren)\u00a0<", "guy.nahsholim@gmail.com", ">"], "sections": {"EIP-7378: Add time-weighted averaging to the base fee": "This EIP proposes a new formula to update the base fee, derived fromEIP-1559. The existing base fee update formula,", "Using geometric weights to average past block sizes into consideration": "This EIP proposes a new formula to update the base fee, derived fromEIP-1559. The existing base fee update formula,", "Abstract": "This EIP proposes a new formula to update the base fee, derived fromEIP-1559. The existing base fee update formula,", "Motivation": "To reduce bribe motivation when the demand for blockspace is high (see Incentive Considerations section) and to reduce oscillations, thus, having a more stable fee setting mechanism.", "Specification": "$s[i]$ is replaced by $s_{\\textit{avg}}[i]$, where:", "Rationale": "An intuitive option for the Transaction Fee Mechanism (TFM) that adjusts supply and demand economically isFirst price auction, which is well known and studied. Nevertheless, the Ethereum network choice was to use EIP-1559 for the TFM (one stated reason was to try and simplify the fee estimation for users, and reduce the advantage of sophisticated users). In this proposal, our design goal is to improve the TFM (of EIP-1559) by mitigating known problems that it raises. It is important to note that these problems severity are in direct relation to the demand for block space, and currently only mildly impact the Ethereum network. If demand to use Ethereum increases, however, these problems are expected to exacerbate. We may want to prepare for this beforehand.", "Incentive Considerations": "The proposal is designed to improve the incentive compatibility of the TFM. Agame theoretic analysisshows that the current TFM, which is based on EIP-1559, encourages bribes.", "Backwards Compatibility": "This change requires a hard fork since the base fee is enforced (for blocks to be considered valid).", "Test Cases": "TBD", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7441, "url": "https://eips.ethereum.org/EIPS/eip-7441", "title": "Upgrade block proposer election to Whisk", "authors": ["George Kadianakis\u00a0(", "@asn-d6", ")", "Justin Drake\u00a0(", "@JustinDrake", ")", "dapplion\u00a0(", "@dapplion", ")"], "sections": {"EIP-7441: Upgrade block proposer election to Whisk": "Upgrades the block proposer election mechanism to Whisk, a single secret leader election (SSLE) protocol. Currently, block proposers are publicly known in advance, sufficiently to allow sequential DoS attacks that could disable Ethereum. This upgrade allows the next block proposer to remain secret until its block is published.", "Allow elected block proposers to remain private until block publishing, to prevent DoS attacks": "Upgrades the block proposer election mechanism to Whisk, a single secret leader election (SSLE) protocol. Currently, block proposers are publicly known in advance, sufficiently to allow sequential DoS attacks that could disable Ethereum. This upgrade allows the next block proposer to remain secret until its block is published.", "Abstract": "Upgrades the block proposer election mechanism to Whisk, a single secret leader election (SSLE) protocol. Currently, block proposers are publicly known in advance, sufficiently to allow sequential DoS attacks that could disable Ethereum. This upgrade allows the next block proposer to remain secret until its block is published.", "Motivation": "The beacon chain currently elects the next 32 block proposers at the beginning of each epoch. The results of this election are public and everyone gets to learn the identity of those future block proposers.", "Specification": "This requires no changes to the Execution Layer.", "Execution layer": "This requires no changes to the Execution Layer.", "Consensus layer": "The protocol can be summarized in the following concurrent steps:", "Rationale": "Whisk requires having one tracker(rG,krG)and one unique commitmentkGper validator. Both are updated only once on a validator\u2019s first proposal after the fork.", "Fields per validator": "Whisk requires having one tracker(rG,krG)and one unique commitmentkGper validator. Both are updated only once on a validator\u2019s first proposal after the fork.", "Identity binding": "Each tracker must be bound to a validator\u2019s identity to prevent multiple parties to claim the same proposer slot. Otherwise, it would allow proposers to sell their proposer slot, and cause fork-choice issues if two competing blocks appear.", "Alternative: non-single secret election": "Secret non-single leader election could be based on protocol engineering rather than cryptography, thus much simpler and cheaper than Whisk. However, it complicates the fork-choice and opens it up to potential MEV time-buying attacks, making it an unsuitable option at the time of writing.", "Alternative: network anonymity": "Privacy-preserving networking protocols like Dandelion or Dandelion++ increase the privacy of network participants but not sufficiently for Ethereum\u2019s use case.", "Backwards Compatibility": "This EIP introduces backward incompatible changes to the block validation rule set on the consensus layer and must be accompanied by a hard fork.", "Security Considerations": "The shuffling strategy is analyzed in a companion paper and considered sufficiently safe for Whisk\u2019s use case. The data and computational complexity of this EIP are significant but constant, thus does not open new DoS vectors.", "Anonymity set": "The anonymity set in Whisk is the set of 8,192 candidates that did not get selected as proposers. That count of validators corresponds to a smaller number of p2p nodes. Assuming a Pareto principle where \u201c20% of the nodes run 80% of the validators\u201d the anonymity corresponds to 2,108 nodes on average. A bigger candidate pool could make the shuffling strategy unsafe while shuffling more trackers per round would increase the cost of the ZK proofs.", "RANDAO biasing": "Whisk uses RANDAO in the candidate selection and proposer selection events, and is susceptible to potential RANDAO biasing attacks by malicious proposers. Whisk security could be made identical to the status quo by spreading the selection events over an entire shuffling period. However, status quo security is not ideal either and it would complicate the protocol further.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7543, "url": "https://eips.ethereum.org/EIPS/eip-7543", "title": "EVM arbitrary precision decimal math", "authors": ["1m1\u00a0(", "@1m1-github", ")"], "sections": {"EIP-7543: EVM arbitrary precision decimal math": "This EIP addsarbitrary precision decimal floatOPCODEs for arithmetic via DECADD, DECNEG, DECMUL, DECINV and expression of all elementary functions via DECEXP, DECLN, DECSIN. All decimal values upto the maximal precision allowed by a int256 coefficient and exponent are represented exactly, as c*10^q. All implemented algorithms converge for all inputs given enough precision, as chosen by the user. All calculations are deterministic and gas is precisely embedded bottom-up. Allowing arbitrary precision decimal elementary functions invites the worlds of mathematical finance, machine learning, science, digital art, games and others to Ethereum. The implementation is functional.", "This EIP adds OPCODEs to allow arbitrary precision decimal float calculation of all elementary functions with precise gas enumeration.": "This EIP addsarbitrary precision decimal floatOPCODEs for arithmetic via DECADD, DECNEG, DECMUL, DECINV and expression of all elementary functions via DECEXP, DECLN, DECSIN. All decimal values upto the maximal precision allowed by a int256 coefficient and exponent are represented exactly, as c*10^q. All implemented algorithms converge for all inputs given enough precision, as chosen by the user. All calculations are deterministic and gas is precisely embedded bottom-up. Allowing arbitrary precision decimal elementary functions invites the worlds of mathematical finance, machine learning, science, digital art, games and others to Ethereum. The implementation is functional.", "Abstract": "This EIP addsarbitrary precision decimal floatOPCODEs for arithmetic via DECADD, DECNEG, DECMUL, DECINV and expression of all elementary functions via DECEXP, DECLN, DECSIN. All decimal values upto the maximal precision allowed by a int256 coefficient and exponent are represented exactly, as c*10^q. All implemented algorithms converge for all inputs given enough precision, as chosen by the user. All calculations are deterministic and gas is precisely embedded bottom-up. Allowing arbitrary precision decimal elementary functions invites the worlds of mathematical finance, machine learning, science, digital art, games and others to Ethereum. The implementation is functional.", "Motivation": "Currently, to take a power, a^b, of non integer values, requires vast amounts of Solidity code.\nThe simplest task in trading e.g. is to convert volatilities from yearly to daily, which involves taking the 16th root.", "Why decimal?": "To represent a simple value like 0.1 in binary requires infinite many digits and is therefore not exactly represently in a finite binary machine. Decimal types are much closer to the vast majority of numerical calculations run by humans.", "eVm": "The EVM is a virtual machine and thereby not restricted by hardware. Usually, assembly languages provide OPCODES that are mimic the ability of hardware. In a virtual machine, we have no such limitations and nothing stops us from adding more complex OPCODEs, as long as fair gas is provided. At the same time, we do not want to clutter the OPCODEs library. EXP, LN and SIN are universal functions that open the path to: powers, trigonometry, integrals, differential equations, machine learning, digital art, etc.", "Specification": "A decimal is defined as", "Decimal": "A decimal is defined as", "OPCODE defs": "0xd0 DECADD a+b -> c    : (ac, aq, bc, bq, precision) -> (cc, cq)\n0xd1 DECNEG  -a -> b    : (ac, aq) -> (bc, bq)\n0xd2 DECMUL a*b -> c    : (ac, aq, bc, bq, precision) -> (cc, cq)\n0xd3 DECINV 1/a -> b    : (ac, aq, precision) -> (bc, bq)\n0xd4 DECEXP exp(a) -> b : (ac, aq, precision, steps) -> (bc, bq)\n0xd5 DECLN   ln(a) -> b : (ac, aq, precision, steps) -> (bc, bq)\n0xd6 DECSIN sin(a) -> b : (ac, aq, precision, steps) -> (bc, bq)", "Why these functions?": "The proposed functions (+,-,*,/,exp,ln,sin) form a small set that combined enable all calculation of all elementary functions, which includes the sets of sums, products, roots and compositions of finitely many polynomial, rational, trigonometric, hyperbolic, and exponential functions, including their inverse functions.", "DECNEG instead of DECSUB": "Negation is a more general operation vs subtraction. OPCODEs should be as fundamental as possible and as complex as desirable.\nFor the same reason, we have DECINV instead of DECDIV.", "DECEXP, DECSIN via Taylor series": "The Taylor series of exp and sin converge everywhere and fast. The error falls as fast as the factorial of steps.", "DECLN via continued fractions": "Ln converges fast using continued fractions within the interval ]0,2]. The implementation scales the input into this interval and scales the result back correctly.", "Rationale": "All the above OPCODEs are deterministic, hence the gas cost can be determined. At the same time, the calculations are complex and depend on the input.", "gas": "All the above OPCODEs are deterministic, hence the gas cost can be determined. At the same time, the calculations are complex and depend on the input.", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "../assets/eip-EVM+/decimal_float_test.go", "Reference Implementation": "The reference implementation is found in ../assets/eip-EVM+/decimal_float.go", "Security Considerations": "There are no security considerations, as long as numerical correctness is guaranteed and gas is collected fairly.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7545, "url": "https://eips.ethereum.org/EIPS/eip-7545", "title": "Verkle proof verification precompile", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")", "Diederik Loerakker\u00a0(", "@protolambda", ")"], "sections": {"EIP-7545: Verkle proof verification precompile": "This EIP proposes the addition of a precompiled contract to provide up-to-date state proof verification capabilities to smart contracts in a stateless Ethereum context.", "Add a precompile to help dapps verify verkle proofs": "This EIP proposes the addition of a precompiled contract to provide up-to-date state proof verification capabilities to smart contracts in a stateless Ethereum context.", "Abstract": "This EIP proposes the addition of a precompiled contract to provide up-to-date state proof verification capabilities to smart contracts in a stateless Ethereum context.", "Motivation": "The proposed proof systems for stateless Ethereum require an upgrade to many tools and applications, that need a simple path to keep their proving systems up-to-date, without having to develop and deploy new proving libraries each time another proof format must be supported.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Gas costs": "The precompile cost is:", "Rationale": "Stateless Ethereum relies on proofs using advanced mathematical concepts and tools from a fast-moving area of cryptography. As a result, a soft-fork approach is currently favored in the choice of the proof format: proofs are going to be distributed outside of consensus, and in the future, stateless clients will be able to chose their favorite proof format.", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "TODO", "Reference Implementation": "WIP", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7547, "url": "https://eips.ethereum.org/EIPS/eip-7547", "title": "Inclusion lists", "authors": ["mike\u00a0(", "@michaelneuder", ")", "Vitalik\u00a0(", "@vbuterin", ")", "Francesco\u00a0(", "@fradamt", ")", "Terence\u00a0(", "@terencechain", ")", "potuz\u00a0(", "@potuz", ")", "Manav\u00a0(", "@manav2401", ")"], "sections": {"EIP-7547: Inclusion lists": "Censorship resistance is a core value proposition of blockchains. Inclusion lists aim to provide a mechanism to improve the censorship resistance of Ethereum by allowing proposers to specify a set of transactions that must be promptly included for subsequent blocks to be considered valid.", "Add an inclusion list mechanism to allow forced transaction inclusion.": "Censorship resistance is a core value proposition of blockchains. Inclusion lists aim to provide a mechanism to improve the censorship resistance of Ethereum by allowing proposers to specify a set of transactions that must be promptly included for subsequent blocks to be considered valid.", "Abstract": "Censorship resistance is a core value proposition of blockchains. Inclusion lists aim to provide a mechanism to improve the censorship resistance of Ethereum by allowing proposers to specify a set of transactions that must be promptly included for subsequent blocks to be considered valid.", "Motivation": "Since the merge, validators have started outsourcing almost all block production to a specialized set of builders who compete to extract the most MEV (this is commonly referred to as Proposer-Builder Separation). As of October 2023, nearly 95% of blocks are built by builders rather than the proposer. While it is great that all proposers have access to competitive blocks through themev-boostecosystem, a major downside of externally built blocks is the fact that the builders ultimately decide what transactions to include or exclude. Without any forced transaction inclusion mechanism, the proposer is faced with a difficult choice: they either have no say on the transactions that get included, or they build the block locally (thus have the final say on transactions) and sacrifice some MEV rewards.", "Specification": "slot Nproposal:", "Constants": "slot Nproposal:", "Consensus layer": "slot Nproposal:", "Execution layer": "We consider a few design decisions present in this EIP.", "Rationale": "We consider a few design decisions present in this EIP.", "Backwards Compatibility": "This EIP introduces backward incompatible changes to the block validation rule set on the consensus layer and must be accompanied by a hard fork. These changes do not break anything related to current user activity and experience.", "Security Considerations": "The main potential issue is around the incentivization of the inclusion lists. If theslot Nproposer constructs an inclusion list that negatively impacts the rewards of theslot N+1proposer, theslot N+1proposer may attempt to bribe theslot Nproposer to publish an empty list. This isn\u2019t a direct attack on the protocol, but rather a profit-sharing mechanism by which the inclusion list would go unutilized. It seems likely these commitment games could be played no matter the censorship resistance scheme in place, but this remains an active area of research.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7591, "url": "https://eips.ethereum.org/EIPS/eip-7591", "title": "BLS signed transactions", "authors": ["Marius van der Wijden\u00a0(", "@MariusVanDerWijden", ")"], "sections": {"EIP-7591: BLS signed transactions": "This EIP introduces a newEIP-2718transaction type that is signed with BLS signatures.", "Introduces a new transaction type signed with BLS signatures": "This EIP introduces a newEIP-2718transaction type that is signed with BLS signatures.", "Abstract": "This EIP introduces a newEIP-2718transaction type that is signed with BLS signatures.", "Motivation": "The BLS signature scheme allows for easy aggregation and verification of aggregated signatures.\nIf a substantial number of transactions on mainnet were BLS signed transactions, we can aggregate signatures in a block and batch-verify them.\nThis will reduce growth of the chain history.", "Specification": "BLS_TX_TYPE = Bytes1(0x04)", "Transaction Type": "The transaction type will have the following format:", "Header changes": "The block header will be amended with theaggregated_sigfield, containing an aggregated signature of all BLS transactions in the block.", "Block changes": "The block building algorithm needs to be changed in order to built the aggregated signature of all BLS signed transactions in the block. \nAll transactions in the block will be added without the signature field set.", "Rationale": "Removing the ECDSA signature from a transaction saves 65 bytes. The BLS public key is 48 bytes, the aggregated signature is 96 bytes.\nThus we save-96 + (65-48)* #transactionsbytes per block. With ~7000 blocks per day, 1.000.000 transactions per day, the average block contains roughly 150 transactions.", "Backwards Compatibility": "This EIP introduces backward incompatible changes to the block validation rule set on the execution layer and introduces a new transaction type and a new header field. Thus a hardfork is needed.", "Security Considerations": "The messages signed via BLS are distinct (no hash collisions on the txhash), thus the aggregation is secure even without a proof-of-possession.\nThe public keys are not distinct which is not a problem in BLS.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7609, "url": "https://eips.ethereum.org/EIPS/eip-7609", "title": "Decrease base cost of TLOAD/TSTORE", "authors": ["Charles Cooper\u00a0(", "@charles-cooper", ")", "James Prestwich\u00a0(", "@prestwich", ")", "brockelmore\u00a0(", "@brockelmore", ")"], "sections": {"EIP-7609: Decrease base cost of TLOAD/TSTORE": "Decrease the base cost of TLOAD/TSTORE while introducing a superlinear pricing model. This increases the efficiency of TLOAD/TSTORE for common use cases, while providing a pricing model to prevent DoS vectors.", "Improve the efficiency of TLOAD/TSTORE by decreasing the base cost and introducing a superlinear pricing model.": "Decrease the base cost of TLOAD/TSTORE while introducing a superlinear pricing model. This increases the efficiency of TLOAD/TSTORE for common use cases, while providing a pricing model to prevent DoS vectors.", "Abstract": "Decrease the base cost of TLOAD/TSTORE while introducing a superlinear pricing model. This increases the efficiency of TLOAD/TSTORE for common use cases, while providing a pricing model to prevent DoS vectors.", "Motivation": "EIP-1153introduces a new storage region, termed \u201ctransient storage\u201d. It behaves like storage (word-addressed and persists between call frames), but unlike storage it is wiped at the end of each transaction. During development of EIP-1153, the pricing was set to be the same as warm storage loads and stores. This was for two reasons: conceptual simplicity of the EIP, and it also addressed concerns about two related DoS vectors: being able to allocate too much transient storage, and the cost of rolling back state in the case of reverts.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "In benchmarking,TLOADwas found to cost a similar amount of CPU time asMUL, whileTSTOREwas found to cost about 1.5x that. The valuesG_lowandG_midwere therefore chosen forTLOADandTSTORE, respectively.", "Gas": "In benchmarking,TLOADwas found to cost a similar amount of CPU time asMUL, whileTSTOREwas found to cost about 1.5x that. The valuesG_lowandG_midwere therefore chosen forTLOADandTSTORE, respectively.", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "The maximum number of transient slots which can be allocated on a single contract given 30m gas is approximately 7,739 (solution tox(x-1)/2*1 + 8*x = 30_000_000), which totals 248KB.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7637, "url": "https://eips.ethereum.org/EIPS/eip-7637", "title": "Optimize EOA EXTCODEHASH", "authors": ["Jame\u00a0(", "@ZWJKFLC", ")"], "sections": {"EIP-7637: Optimize EOA EXTCODEHASH": "This proposal is an optimization forEIP-1052,\nFor addresses with a balance, but without code, the codehash should still be0x.", "Modify the output value of EXTCODEHASH for EOA accounts to `0x`": "This proposal is an optimization forEIP-1052,\nFor addresses with a balance, but without code, the codehash should still be0x.", "Abstract": "This proposal is an optimization forEIP-1052,\nFor addresses with a balance, but without code, the codehash should still be0x.", "Motivation": "EIP-1052 was proposed to save gas fees. However, due to some flaws in the set specifications, in actual applications, due to safety concerns, they will not actually be used. In order for EIP-1052 to be truly useful, it should be optimized.", "Specification": "The behaviour ofEXTCODEHASHis changed in the following way:", "Rationale": "EIP-1052 In order to include the function ofBALANCE, let theEXTCODEHASHof the address without balance be0x, and theEXTCODEHASHof the address with balance bekeccak256(\"\").", "Backwards Compatibility": "Using codehash to determine whether a non-contract address has a balance will not be available", "Reference Implementation": "Code reference for execution-specs", "Security Considerations": "Using codehash to determine whether a non-contract address has a balance will not be available", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7643, "url": "https://eips.ethereum.org/EIPS/eip-7643", "title": "History accumulator for pre-PoS data", "authors": ["lightclient\u00a0(", "@lightclient", ")", "kdeme\u00a0(", "@kdeme", ")"], "sections": {"EIP-7643: History accumulator for pre-PoS data": "Defines an SSZ object for accumulating all pre-PoS data and commit to the\nhistorical hashes accumulator\u2019s root0xec8e040fd6c557b41ca8ddd38f7e9d58a9281918dc92bdb72342a38fb085e701.", "Commit to a single root for all block data before the merge.": "Defines an SSZ object for accumulating all pre-PoS data and commit to the\nhistorical hashes accumulator\u2019s root0xec8e040fd6c557b41ca8ddd38f7e9d58a9281918dc92bdb72342a38fb085e701.", "Abstract": "Defines an SSZ object for accumulating all pre-PoS data and commit to the\nhistorical hashes accumulator\u2019s root0xec8e040fd6c557b41ca8ddd38f7e9d58a9281918dc92bdb72342a38fb085e701.", "Motivation": "There are two main uses we consider for the historical hashes accumulator:", "Specification": "The historical hashes accumulator commits to the set of pre-merge headers and their\nassociated total difficulty. The format for this data is defined as:", "Historical Hashes Accumulator": "The historical hashes accumulator commits to the set of pre-merge headers and their\nassociated total difficulty. The format for this data is defined as:", "Pre-PoS Root": "The hash tree root ofHistoricalHashesAccumulatorfor data before block 15537394 is0xec8e040fd6c557b41ca8ddd38f7e9d58a9281918dc92bdb72342a38fb085e701.", "Rationale": "The total difficulty allowed so that clients may return the value for specific\nJSON-RPC methods which support it. It is also useful for verifying the TTD of\nthe final proof-of-work block.", "Inclusion of total difficulty": "The total difficulty allowed so that clients may return the value for specific\nJSON-RPC methods which support it. It is also useful for verifying the TTD of\nthe final proof-of-work block.", "Backwards Compatibility": "n/a", "Test Cases": "The accumulator root should be verified by community members before being\naccepted. Although the accumulator root can be verified at anytime by anyone in\nthe future, it is likely clients and other tooling will begin relying on proofs\nagainst the aforementioned root in the near term.", "Security Considerations": "The accumulator root should be verified by community members before being\naccepted. Although the accumulator root can be verified at anytime by anyone in\nthe future, it is likely clients and other tooling will begin relying on proofs\nagainst the aforementioned root in the near term.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7645, "url": "https://eips.ethereum.org/EIPS/eip-7645", "title": "Alias ORIGIN to SENDER", "authors": ["Cyrus Adkisson\u00a0(", "@cyrusadkisson", ")", "Eirik Ulvers\u00f8y\u00a0(", "@EirikUlversoy", ")"], "sections": {"EIP-7645: Alias ORIGIN to SENDER": "This EIP proposes aliasing the ORIGIN opcode to the SENDER opcode within the Ethereum Virtual Machine (EVM). The purpose of this change is to move Ethereum closer to enabling account abstraction by harmonizing the treatment of externally owned accounts (EOAs) and smart contracts and to address the security concerns associated with the use of ORIGIN that have and will continue to surface in all or most account abstraction proposals.", "Eliminate ORIGIN tech debt to lay groundwork for account abstraction and close security holes": "This EIP proposes aliasing the ORIGIN opcode to the SENDER opcode within the Ethereum Virtual Machine (EVM). The purpose of this change is to move Ethereum closer to enabling account abstraction by harmonizing the treatment of externally owned accounts (EOAs) and smart contracts and to address the security concerns associated with the use of ORIGIN that have and will continue to surface in all or most account abstraction proposals.", "Abstract": "This EIP proposes aliasing the ORIGIN opcode to the SENDER opcode within the Ethereum Virtual Machine (EVM). The purpose of this change is to move Ethereum closer to enabling account abstraction by harmonizing the treatment of externally owned accounts (EOAs) and smart contracts and to address the security concerns associated with the use of ORIGIN that have and will continue to surface in all or most account abstraction proposals.", "Motivation": "The ORIGIN opcode in Ethereum returns the address of the account that started the transaction chain, differing from the SENDER (or CALLER) opcode, which returns the address of the direct caller. The use of ORIGIN has been discouraged and deemed deprecated since mid-2016 due to the security problems it introduces, such as susceptibility to phishing attacks and other vulnerabilities where the distinction between the original sender and the immediate sender can be exploited.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "The rationale behind aliasing ORIGIN to SENDER is to:", "Backwards Compatibility": "This change is not fully backwards compatible. Contracts relying on the distinction between ORIGIN and SENDER for logic or security will be affected. However, given the longstanding discouragement of ORIGIN\u2019s use, the minimal impact of the change, the widespread desire for a future account abstraction solution in the EVM, and the reality that any AA solution will ultimately have to deal with ORIGIN one way or the other, this incompatibility is considered a necessary step forward for Ethereum\u2019s development.", "Test Cases": "For each CALL, STATICCALL, DELEGATECALL, CALLCODE:", "Security Considerations": "By aliasing ORIGIN to SENDER, the specific security vulnerabilities associated with the ORIGIN opcode are addressed and eliminated. Outside the scope of this EIP, it may be wise to ban all use of ORIGIN to eliminate further misunderstanding or misuse. This can be done via tooling changes outside the EVM or, inside the EVM, reverting smart contract deployments that use ORIGIN.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7650, "url": "https://eips.ethereum.org/EIPS/eip-7650", "title": "Programmable access lists", "authors": ["Qi Zhou\u00a0(", "@qizhou", ")", "Zhiqiang Xu\u00a0(", "@zhiqiangxu", ")"], "sections": {"EIP-7650: Programmable access lists": "We introduce a new precompiled contract namedprefetch, which accepts anaccessList.", "Add a precompiled contract that add access lists programmatically": "We introduce a new precompiled contract namedprefetch, which accepts anaccessList.", "Abstract": "We introduce a new precompiled contract namedprefetch, which accepts anaccessList.", "Motivation": "The primary goal of this EIP is to enhance EIP-2930 by enabling contracts to add access lists programmatically. The advantage of implementing this precompile within a contract is the sustained reduction in gas costs for data access operations, leveraging the concurrent computing and IOs that most nodes have.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Parameters": "As ofFORK_BLOCK_NUMBER, a new precompile is deployed atPREFETCH_PRECOMPILE_ADDRESS.  The encoding of the precompile input is the following:", "Examples": "Using UniswapV2swap()function as an example:", "Rationale": "Similar to EIP-2930, we encourage contract developers to use theprefetchprecompile as much as possible, especially assuming the nodes have some decent concurrent capabilities (e.g., some cores and IO bandwidth).", "Charging less for accesses in the access list": "Similar to EIP-2930, we encourage contract developers to use theprefetchprecompile as much as possible, especially assuming the nodes have some decent concurrent capabilities (e.g., some cores and IO bandwidth).", "Allowing duplicates": "Similar to EIP-2930, we allow duplicates in the list to maximize simplicity.", "No storage keys for external contract": "Unlike EIP-2930, theprefetchprecompile only accepts local storage keys and addresses. Prefetching the data of the storage keys of external contracts assumes that the contract knows the storage layout of an external contract, which may not be a good practice. To better employ the concurrency of a node, the precompile may accept a list of static calls of external contracts together with the calldata.  This work may be done in the future EIP.", "Backwards Compatibility": "If the EIP is not yet implemented, a contract calling the precompile should result in no operation.", "Security Considerations": "No security considerations were found.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7657, "url": "https://eips.ethereum.org/EIPS/eip-7657", "title": "Sync committee slashings", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")"], "sections": {"EIP-7657: Sync committee slashings": "This EIP defines a slashing condition for malicioussync committee messages.", "Slashing condition for malicious sync committee messages": "This EIP defines a slashing condition for malicioussync committee messages.", "Abstract": "This EIP defines a slashing condition for malicioussync committee messages.", "Motivation": "A dishonest supermajority of sync committee members is able to convince applications relying on Ethereum\u2019slight client sync protocolto assume a non-canonical finalized header, and to potentially take over the sync authority for futureSyncCommitteePeriod. By signing a malicious beacon block root, a malicious (but valid!)LightClientUpdatemessage can be formed and subsequently used to, for example, exploit a trust-minimized bridge contract based on the light client sync protocol.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "State transition checks": "Note: This still allows having contradictions between attestations/proposals and sync committee messages. This also, by design, allows a validator to not participate at all in honest sync committee messages but solely participate in dishonest sync committee messages.", "Rationale": "Without a slashing, the light client sync protocol is somewhat limited. While wallet applications may benefit from it (the risk being, that incorrect data is displayed) and new beacon nodes may use it for accelerating chain synchronization, other interesting use cases such as bridges, token distributions or other systems requiring proofs depend on the mechanism providing higher security guarantees.", "What\u2019s the use case?": "Without a slashing, the light client sync protocol is somewhat limited. While wallet applications may benefit from it (the risk being, that incorrect data is displayed) and new beacon nodes may use it for accelerating chain synchronization, other interesting use cases such as bridges, token distributions or other systems requiring proofs depend on the mechanism providing higher security guarantees.", "Backwards Compatibility": "This EIP requires a hard fork as it introduces new consensus validation rules.", "Test Cases": "TBD", "Reference Implementation": "TBD", "Security Considerations": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7658, "url": "https://eips.ethereum.org/EIPS/eip-7658", "title": "Light client data backfill", "authors": ["Etan Kissling\u00a0(", "@etan-status", ")"], "sections": {"EIP-7658: Light client data backfill": "This EIP defines a mechanism for syncinglight client databetween beacon nodes.", "Mechanism for beacon nodes for syncing historical light client data": "This EIP defines a mechanism for syncinglight client databetween beacon nodes.", "Abstract": "This EIP defines a mechanism for syncinglight client databetween beacon nodes.", "Motivation": "Light client datais collected by beacon nodes to assistlight clientsto sync with the network. Thesync protocoldefines a mechanism to sync forward in time. However, it cannot be used to sync backward.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Containers": "New fields are added to the end ofBeaconStatefrom the activating fork onward to track the current and previous sync committee period\u2019s best sync data.", "Helper functions": "On sync committee boundaries, current period data is moved to previous period. This allows proving that light client data for the previous period is canonical.", "Beacon chain state transition function": "On sync committee boundaries, current period data is moved to previous period. This allows proving that light client data for the previous period is canonical.", "Rationale": "The EIP reuses theis_better_updatefunction from existing specs.", "How to rankSyncAggregate?": "The EIP reuses theis_better_updatefunction from existing specs.", "How could a backfill protocol use this?": "Once the data is available in theBeaconState, a light client data backfill protocol could be defined that serves, for past periods:", "Backwards Compatibility": "This EIP requires a hard fork as it introduces new consensus validation rules.", "Security Considerations": "None", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7666, "url": "https://eips.ethereum.org/EIPS/eip-7666", "title": "EVM-ify the identity precompile", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-7666: EVM-ify the identity precompile": "Remove the identity precompile at 0x04. At the start of executing the block in which this change activates, put into that contract a short piece of EVM code that has the same functionality.", "Remove the identity precompile, and put into place a piece of EVM code that has equivalent functionality": "Remove the identity precompile at 0x04. At the start of executing the block in which this change activates, put into that contract a short piece of EVM code that has the same functionality.", "Abstract": "Remove the identity precompile at 0x04. At the start of executing the block in which this change activates, put into that contract a short piece of EVM code that has the same functionality.", "Motivation": "Ethereum today has a large number of precompiles. Nearly half of these precompiles are not seeing significant use, and are contributing to ongoing maintenance cost and risk of consensus bugs, as well as increased development effort for new Ethereum client implementations, including ZK-EVMs and implementations in formal-verification-friendly languages.", "Specification": "At the start of the block in which this fork activates, set the code ofIDENTITY_PRECOMPILE_ADDRESStoEVM_CODE. Starting from and including that block,IDENTITY_PRECOMPILE_ADDRESSshould no longer be treated as a precompile.", "Rationale": "The givenEVM_CODEcorresponds to", "Backwards Compatibility": "The functionality of the givenEVM_CODEis the same as the identity precompile. Gas costs are slightly different, though gas repricings have been done in the Ethereum ecosystem several times before and their effects are well understood.", "Security Considerations": "As no new functionality is introduced or made cheaper, no security concerns are raised.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7667, "url": "https://eips.ethereum.org/EIPS/eip-7667", "title": "Raise gas costs of hash functions", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-7667: Raise gas costs of hash functions": "Raise the gas costs of opcodes and precompiles that involve hash functions.", "Raise the gas costs of hash function opcodes and precompiles, to match prover expenses in ZK-EVMs": "Raise the gas costs of opcodes and precompiles that involve hash functions.", "Abstract": "Raise the gas costs of opcodes and precompiles that involve hash functions.", "Motivation": "Gas costs for hash function opcodes and precompiles were originally set based on the time that it takes to execute them on a regular CPU. Since then, however, there has emerged another equally important execution substrate that the EVM is executed on: zero knowledge proof (ZK-SNARK) systems. By that standard, these opcodes and precompiles areveryunderpriced relative to other operations.", "Specification": "Change the above parameters to their new values.", "Rationale": "The above increases the gas costs of all opcodes and precompiles that can be used to require large amounts of hashing in the EVM. All hashing costs are increased to 300 per hash plus 60 per word (or kept the same if they are already higher than this).\n\u2018\u201d\nA possible alternative to this approach is to implement either multidimensional gas pricing (ie. a separate floating basefee and per-block target and limit for hashes) or a \u201ctotal gas cost floor\u201d similar to whatEIP-7623does for calldata. However, this approach is much harder to implement for in-EVM gas costs such as hashes than it is for calldata and blobs, because EVM gas limits are set not just by users, for whom new transaction types that specify newly required limits, max-basefees and priority fees can easily be added, but also by contracts making sub-calls to other contracts.", "Backwards Compatibility": "For most applications, a reasonable upper bound is that data that is getting hashed in the EVM is getting brought in as calldata. If the hashing being done is binary Merkle proof verification, every 32 bytes of data corresponds to a 64-byte (2-word) hash. A word of costs 512 gas. Under the new costs, the hashing per word in that situation would be300 + 60 * 2 = 420gas. Hence, this will increase gas consumption for that component of the application by less than 2x.", "Security Considerations": "As no new operations are introduced or made cheaper, no security concerns were raised.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7668, "url": "https://eips.ethereum.org/EIPS/eip-7668", "title": "Remove bloom filters", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-7668: Remove bloom filters": "Require the bloom filters in an execution block, including at the top level and in the receipt object, to be empty.", "Remove bloom filters from the execution block": "Require the bloom filters in an execution block, including at the top level and in the receipt object, to be empty.", "Abstract": "Require the bloom filters in an execution block, including at the top level and in the receipt object, to be empty.", "Motivation": "Logs were originally introduced to give applications a way to record information about onchain events, which decentralized applications (dapps) would be able to easily query. Using bloom filters, dapps would be able to quickly go through the history, identify the few blocks that contained logs relative to their application, and then quickly identify which individual transactions have the logs that they need.", "Specification": "The logs bloom of an execution block is now required to be empty (ie. 0 bytes long). The logs bloom of a transaction receipt is now required to be empty (ie. 0 bytes long).", "Rationale": "This is a minimally disruptive way to remove the need to handle blooms from clients. A future EIP can later clean up by removing this field entirely, along with other fields that have been deprecated.", "Backwards Compatibility": "Applications that depend on bloom filters to read events will cease to work. Very few applications depend on this feature today, because at current gas limits the false positive rate is so high and processing the logs in a long history query is so slow, especially for light clients (whom this feature was primarily intended to benefit).", "Security Considerations": "As no new features are introduced or made cheaper, no security concerns are raised.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7676, "url": "https://eips.ethereum.org/EIPS/eip-7676", "title": "EOF - Prepare for Address Space Extension", "authors": ["Danno Ferrin\u00a0(", "@shemnon", ")"], "sections": {"EIP-7676: EOF - Prepare for Address Space Extension": "Operations in the Legacy EVM trim off the top 12 bytes of an address operand before evaluation. This\nEIP changes the handling of those opcodes within EOF so that no trimming occurs and the top twelve\nbytes need to be zero or an exceptional halt is raised.", "Update EOF opcodes so addresses are not trimmed during execution": "Operations in the Legacy EVM trim off the top 12 bytes of an address operand before evaluation. This\nEIP changes the handling of those opcodes within EOF so that no trimming occurs and the top twelve\nbytes need to be zero or an exceptional halt is raised.", "Abstract": "Operations in the Legacy EVM trim off the top 12 bytes of an address operand before evaluation. This\nEIP changes the handling of those opcodes within EOF so that no trimming occurs and the top twelve\nbytes need to be zero or an exceptional halt is raised.", "Motivation": "There have been proposals to extend Ethereum Addresses from 160 bits to 256, such as one that would\nuse the extra bits for state expiry (such as the ethereum magicians forum topic \u201cIncreasing the\naddress size from 20 to 32 bytes\u201d). One issue ground the work to a halt: EVM opcodes that accept\naddresses trim all but the lowest 20 bytes out from the operand before processing. EVM Reference\ntests verify this behavior in the \u2018stBadOpcode/invalidAddr.json\u2019 tests.", "Specification": "We introduce one new instruction:", "Rationale": "There is no need to ban theBALANCEopcode as it does not cause any problems that would require\nbanning it within an EOF container. Adding a new opcode also allows the existing opcode to behave\nthe same in EOF and legacy code, reducing potential friction points for end user confusion and bugs.", "New Opcode": "There is no need to ban theBALANCEopcode as it does not cause any problems that would require\nbanning it within an EOF container. Adding a new opcode also allows the existing opcode to behave\nthe same in EOF and legacy code, reducing potential friction points for end user confusion and bugs.", "Revert on invalid address": "There are two alternative ways to handle accounts with high bits set. The specification calls for\nan exceptional halt, but the alternative was to treat the account as empty. The reason the \u201cempty\naccount\u201d approach was rejected is twofold:", "No change in gas costing": "Because the BALANCE operation already needs to checkaccessed_addressesthere is already a good\namount of processing that must go into the operation. Hence, no changes to the gas schedule are\nneeded to prevent abuse of the failures. Such incremental costs will be dominated by costs related\nto reverts and address checking for valid accounts.", "Backwards Compatibility": "Preparing for Address Space Expansion is explicitly done inside the scope of EOF with the intent\nthat it will not require changes in old contracts, but with the caveat that old contracts may not be\nable to use addresses in the expanded space.", "Test Cases": "Test cases similar toinvalidAddr.jsontests in the standard reference tests will need to be\nwritten for the EOF tests, except they would check for halts on invalid addresses.", "Reference Implementation": "TBD", "Security Considerations": "This EIP only defines a revert behavior for previously stripped addresses. Compilers will need to be\naware of the need to mask addresses coming in from call data. Some of this is already present in\nexisting Solidity ABI standards, but more care should be taken in examining the flow\naroundEXTBALANCEand code forEXTCALLoperations to ensure that compiled code strips the high\nbytes.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7684, "url": "https://eips.ethereum.org/EIPS/eip-7684", "title": "Return deposits for distinct credentials", "authors": ["Lion\u00a0(", "@dapplion", ")"], "sections": {"EIP-7684: Return deposits for distinct credentials": "Automatically withdraw deposits for existing validator records, but where the deposit includes a distinct execution withdrawal credential.", "Automatically withdraw deposits for existing validator records but with distinct execution withdrawal credentials": "Automatically withdraw deposits for existing validator records, but where the deposit includes a distinct execution withdrawal credential.", "Abstract": "Automatically withdraw deposits for existing validator records, but where the deposit includes a distinct execution withdrawal credential.", "Motivation": "Some staking operations feature two distinct entities, one operating the validating key, and one funding the deposit. The funding entity delegates control of the stake operation but must retain ultimate control of funds. If the funding entity naively submits a single deposit with the full stake amount and the other entity\u2019s validating key, it is subject to a front-run attack. The validating entity can front-run the bigger deposit with a second deposit with its own set of withdrawal credentials. The full stake amount deposit becomes a top-up, in control of the validating entity.", "Specification": "The configuration values and mechanics of the specification can be found in theConsensus Layer specs.", "Consensus Layer": "The configuration values and mechanics of the specification can be found in theConsensus Layer specs.", "Execution Layer": "This specification does not require any changes to the Execution Layer.", "Rationale": "Rejected deposits from block at slot N can not be withdrawn in block N due to a cyclic dependency. An execution client must know the full list of withdrawals before constructing a payload for slot N. AfterEIP-6110, a consensus client must know the full execution payload for slot N before constructing the beacon block for slot N. Therefore, rejected deposits must be withdrawn in some future slot. All pending withdrawals are processed at once in the very next slot for simplicity but could be queued and processed progressively if there are DOS concerns.", "Persist pending withdrawals": "Rejected deposits from block at slot N can not be withdrawn in block N due to a cyclic dependency. An execution client must know the full list of withdrawals before constructing a payload for slot N. AfterEIP-6110, a consensus client must know the full execution payload for slot N before constructing the beacon block for slot N. Therefore, rejected deposits must be withdrawn in some future slot. All pending withdrawals are processed at once in the very next slot for simplicity but could be queued and processed progressively if there are DOS concerns.", "Backwards Compatibility": "This is a backward incompatible change to the Consensus Layer of Ethereum and must be scheduled with a hard fork.", "Test Cases": "Test cases are work-in-progress within the standard Consensus Layer tests.", "Security Considerations": "The worst-case number of withdrawals is raised from a fixed 16 to 1,271 under current gas rules and a 30M gas block. CitingEIP-6110, future gas efficiencies can increase the number to 1,916 withdrawals in a 30M gas block. Each withdrawal results in a single address balance change. There is no explicit pricing for such an operation, but under the worst case, it results in a notable increase in the total block gas (30% assuming 6,900 gas per withdrawal and current gas rules).", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7686, "url": "https://eips.ethereum.org/EIPS/eip-7686", "title": "Linear EVM memory limits", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-7686: Linear EVM memory limits": "Add a hard memory limit equal to the gas limit of the current context. Make the maximum gas cost of a sub-call depend on the memory used in the current context. The two rules together ensure that a transaction with N gas can use at most N bytes of memory.", "Adjust memory limits and gas limits of sub-calls to create a clear linear bound on how much total memory an EVM execution can consume": "Add a hard memory limit equal to the gas limit of the current context. Make the maximum gas cost of a sub-call depend on the memory used in the current context. The two rules together ensure that a transaction with N gas can use at most N bytes of memory.", "Abstract": "Add a hard memory limit equal to the gas limit of the current context. Make the maximum gas cost of a sub-call depend on the memory used in the current context. The two rules together ensure that a transaction with N gas can use at most N bytes of memory.", "Motivation": "Today, memory pricing rules are complicated: we have the quadratic cost for expanding memory as well as the 63/64 rule for how much gas can go into a child call. This also makes it extremely hard to calculate a maximum possible amount of memory required to process a given EVM execution.", "Specification": "Changememory_costfrom:", "Rationale": "With this EIP, there is a simple EVM implementation that can process an N-gas call using an N-byte bytearray as memory: allocate all bytes to the current context, when doing a child call use the remaining memory starting from the positionmemory_byte_sizefor the child call\u2019s memory, and so on recursively.", "Backwards Compatibility": "It is theoretically possible for EVM code that works today to fail to work under this new EIP, if that code accesses a high index in memory but is called with a low gas limit. However, almost all EVM execution consumes far more code than it uses bytes of memory. For example, for a call to cause even a single state change, it must have at least 5000 gas. This would allow it 5000 bytes of memory, which is greater than that used by almost all applications. More complex applications would have even higher limits.", "Security Considerations": "No security concerns were raised.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7705, "url": "https://eips.ethereum.org/EIPS/eip-7705", "title": "NONREENTRANT and REENTRANT opcodes", "authors": ["Charles Cooper\u00a0(", "@charles-cooper", ")"], "sections": {"EIP-7705: NONREENTRANT and REENTRANT opcodes": "Add two opcodes,NONREENTRANTandREENTRANT, which set and clear a contract\u2019s reentrancy status. After invokingNONREENTRANT, a contract cannot beCALLed (orSTATICCALLed, orDELEGATECALLed) untilREENTRANTis invoked.", "Opcodes to mark a contract as nonreentrant": "Add two opcodes,NONREENTRANTandREENTRANT, which set and clear a contract\u2019s reentrancy status. After invokingNONREENTRANT, a contract cannot beCALLed (orSTATICCALLed, orDELEGATECALLed) untilREENTRANTis invoked.", "Abstract": "Add two opcodes,NONREENTRANTandREENTRANT, which set and clear a contract\u2019s reentrancy status. After invokingNONREENTRANT, a contract cannot beCALLed (orSTATICCALLed, orDELEGATECALLed) untilREENTRANTis invoked.", "Motivation": "Reentrancy attacks account for a substantial portion of user funds stolen on EVM chains, including the famous \u201cDAO hack\u201d. However, due to the cost of preventing against reentrancy attacks in application code, developers often opt-out of reentrancy protection. This cost has come down with the advent of transient storage (EIP-1153), but it is still not cheap enough where it is a \u201cno-brainer\u201d to use it by default. This EIP proposes opcodes which make it cheaper to protect against reentrancy in application code.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Rationale": "The computational cost of pushing the current value to the call stack (for handling reverts) is accounted for in the overhead cost of the*CALLopcodes.", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "TBD", "Reference Implementation": "TBD", "Security Considerations": "TBD", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7706, "url": "https://eips.ethereum.org/EIPS/eip-7706", "title": "Separate gas type for calldata", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-7706: Separate gas type for calldata": "Add a new type of gas for transaction calldata. Add a new transaction type that providesmax_basefeeandpriority_feeas a vector, providing values for execution gas, blob gas and calldata gas. Modify the basefee adjustment to use the same mechanism for the three types of gas.", "Create a separate basefee and gaslimit for calldata": "Add a new type of gas for transaction calldata. Add a new transaction type that providesmax_basefeeandpriority_feeas a vector, providing values for execution gas, blob gas and calldata gas. Modify the basefee adjustment to use the same mechanism for the three types of gas.", "Abstract": "Add a new type of gas for transaction calldata. Add a new transaction type that providesmax_basefeeandpriority_feeas a vector, providing values for execution gas, blob gas and calldata gas. Modify the basefee adjustment to use the same mechanism for the three types of gas.", "Motivation": "A major argument against raising the Ethereum gas limit, making calldata cheaper, or increasing theEIP-4844blob count before technologies like PeerDAS become available, is that the theoretical maximum size of an Ethereum block is already too large, and we cannot afford to increase it further. However, there is an inefficiency here: the current average size of a block (not including blobs) is ~100 kB, and the theoretical max is30,000,000 / 16 = 1,875,000bytes (one could make larger blocks using zero bytes, but in practice zero-byte-heavy blocks would be compressed to less than 1.87 million bytes due to snappy compression). Ideally, we would have a way to bound the maximum, without making calldata more scarceon average.", "Specification": "The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119.", "Parameters": "As ofFORK_BLOCK_NUMBER, a newEIP-2718transaction is introduced withTransactionType=TX_TYPE(NEW_TX_TYPE).", "New transaction type": "As ofFORK_BLOCK_NUMBER, a newEIP-2718transaction is introduced withTransactionType=TX_TYPE(NEW_TX_TYPE).", "Block processing and transaction fees": "We add the functionsget_max_feesandget_priority_fees, to compute these length-3 vectors for previous transaction types:", "Block structure:": "We updateBlockHeaderfield, to remove theblob_gas_used,gas_used,base_fee_per_gas,gas_limitandexcess_blob_gasfields, and we add new fields, all of the[int, int, int]type:gas_limits,gas_used,excess_gas. The resulting RLP encoding becomes:", "Rationale": "This allows the same logic that is used for handling gas to handle all three types of gas. As a result, it\u2019s arguably a net simplification of protocol gas handling logic, despite the fact that the total number of gas types increases from 2 to 3", "Conversion of all gas-related mechanics into vectors": "This allows the same logic that is used for handling gas to handle all three types of gas. As a result, it\u2019s arguably a net simplification of protocol gas handling logic, despite the fact that the total number of gas types increases from 2 to 3", "Target ratios": "The target ratios for execution gas and blobs are set to 2; the target ratio for calldata is set to 4. This greatly decreases the number of scenarios in which calldata actually hits the limit, which mitigates economic impact of the EIP, because analysis of EIP-1559-style fee markets is much simpler in \u201cunder-the-limit\u201d conditions than in \u201cat-the-limit\u201d conditions. Additionally, it reduces the risk that applications requiring large calldata will outright stop working.", "Backwards Compatibility": "Previous transaction types set the calldata basefee and priority fee to equal each other. The calldata gas costs were intentionally set to be identical to today, and the gas target similar to present-day usage, so that setting the two fees to be equal each other is a reasonable approximation to optimal behavior. In practice, the new transaction type would be superior, so we expect users to switch to it over time. However, the loss suffered by old-style transaction users would not be that high, because priority fees are generally small compared to basefees, and the amount that a user pays is proportional to the basefee.", "Security Considerations": "Optimal block building behavior becomes more complex as a result of this EIP, particularly under the boundary conditions when blocks are full of one or both types of gas. We argue that the effects of this are not too large, because in practice over 90% of blocks are under-full, and naive \u201cgreedy algorithms\u201d can get a close-enough-to-optimal outcome. The centralization risks of proprietary block-building algorithms are thus likely to be much smaller than other existing risks with eg. MEV extraction.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7707, "url": "https://eips.ethereum.org/EIPS/eip-7707", "title": "Incentivize Access List Provisioning", "authors": ["Ben Adams\u00a0(", "@benaadams", ")", "Oleg Iakushkin\u00a0(", "@OlegJakushkin", ")"], "sections": {"EIP-7707: Incentivize Access List Provisioning": "This EIP reduces the gas cost of access list data, incentivizing the inclusion of complete and valid access lists in transactions to improve data load efficiency for execution layer clients.", "This EIP proposes updating gas cost parameters for access lists to incentivise their use and improve transaction execution efficiency.": "This EIP reduces the gas cost of access list data, incentivizing the inclusion of complete and valid access lists in transactions to improve data load efficiency for execution layer clients.", "Abstract": "This EIP reduces the gas cost of access list data, incentivizing the inclusion of complete and valid access lists in transactions to improve data load efficiency for execution layer clients.", "Motivation": "WhileEIP-2930introducedaccessListsas a mechanism forSLOADpre-warming  to reduce gas costs by informing the EVM upfront about which storage slots a transaction will access,\nthe practical use is limited and uncommon due to the savings versus penalties involved. In order to break even for\neach address included24 storage keysare required per address, and there is a100 gassaving per key at25+; \nin contrast the penalty for including an unused key is1900 gas, so break-even where one key is unused is43 keys.This situation makes the break-even and risk-reward ratio ofaccessListsrarely appealing in practice for regular\ntransactions, where a prior transaction could lead to a different branch being taken and a slightly different set of\nstorage slots being accessed. Furthermore, a very high number of SLOADs is required to start breaking even.For some clients, data loading takes>70%of block execution time. This\nhappens in part due to sequential transaction execution and iterative\nsearch of effectively random access data.While NVMe drives have massive throughput and IOPS; this is their\nconcurrent throughput operated through multiple queues and they do not\nhave this performance if data is accessed completely sequentially with\none request waiting for the prior to complete i.e. stacking individual\nIOPS latency end to end will not give anything close to maximal\nthroughput that these drives can deliver (which is different from the\nHDD world where heads needed to seek to different physical locations for\neach read). This is a similar situation with network attached storage or\ncloud data disks; however the latency here is even more amplified than a\nlocal direct CPU attached NVMe drive (i.e. via network card).If nodes had a somewhat clearer picture of what data to pre-load for the\nblock\u2019s execution; that can be done in parallel, hiding much of the\nlatency from accessing that data when discovered from executing the\ntransaction. Very much in a similar way to instruction pipelining on a\nCPU hiding memory access latencies; the data access for transactions\ncould be pipelined. This can lead to faster/cheaper block execution and\nwould facilitate data dependency hints for parallel Tx execution in the\nfuture, like on other emerging chains that were developed with more\nmodern hardware in mind.", "Specification": "We shall updateEIP-2930parameters:", "Rationale": "As stated in the introduction the gas cost benefit analysis does not\nencourage the users of the chain to provide accessList hints, even\nthough the mechanism is already in protocol (and a call toeth_createAccessListwill give them, or a wallet the correct list\nto include). So we propose a reduction in the pricing of those data\naccess lists to make them more inline with calldata.Levelling the playing field between smallcall_dataandaccess_listscosts, (and incentiviseaccess_listsprovisioning from transaction\nsenders as they are needed for transaction execution in a faster\nmanner), the price model updates would look as follows:", "Examples": "Current", "Backwards Compatibility": "This EIP makes a minor update toEIP-2930with\nrespect to modern execution challenges and capabilities.", "Security Considerations": "Same as perEIP-2930", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7708, "url": "https://eips.ethereum.org/EIPS/eip-7708", "title": "ETH transfers emit a log", "authors": ["Vitalik Buterin\u00a0(", "@vbuterin", ")", "Peter Davies\u00a0(", "@petertdavies", ")"], "sections": {"EIP-7708: ETH transfers emit a log": "All ETH-transfers, including transactions,CALLandSELFDESTRUCTemit a log.", "All ETH transfers emit a log": "All ETH-transfers, including transactions,CALLandSELFDESTRUCTemit a log.", "Abstract": "All ETH-transfers, including transactions,CALLandSELFDESTRUCTemit a log.", "Motivation": "Logs are often used to track when balance changes of assets on Ethereum. Logs work forERC-20tokens, but they do not work for ETH. ETH transfers from EOAs can be read from the transaction list in the block, but ETH transfers from smart contract wallets are not automatically logged anywhere. This has already led to problems in the past, eg. early exchanges would often not properly support deposits from smart contract wallets, or only support them with a much longer delay. This EIP proposes that we automatically generate a log every time a value-transferringCALLorSELFDESTRUCThappens. We also add a similar log for transfers in transactions, so that all ETH transfers can be tracked using one mechanism.", "Specification": "Whenever (i) a nonzero-valueCALL, (ii) a nonzero-value-transferringSELFDESTRUCT, or (iii) a nonzero-value-transferring transaction takes place, issue a log, identical to a LOG3, with three topics: (i)MAGIC, (ii) the sender address, (iii) the recipient address. The log data is a big-endian 32-byte encoding of the transfer value.", "Parameters": "Whenever (i) a nonzero-valueCALL, (ii) a nonzero-value-transferringSELFDESTRUCT, or (iii) a nonzero-value-transferring transaction takes place, issue a log, identical to a LOG3, with three topics: (i)MAGIC, (ii) the sender address, (iii) the recipient address. The log data is a big-endian 32-byte encoding of the transfer value.", "Functionality": "Whenever (i) a nonzero-valueCALL, (ii) a nonzero-value-transferringSELFDESTRUCT, or (iii) a nonzero-value-transferring transaction takes place, issue a log, identical to a LOG3, with three topics: (i)MAGIC, (ii) the sender address, (iii) the recipient address. The log data is a big-endian 32-byte encoding of the transfer value.", "Rationale": "This is the simplest possible implementation that ensures that all ETH transfers are implemented in some kind of record that can be easily accessed through making RPC calls into a node, or through asking for a Merkle branch that is hashed into the block root. The log type is compatible with the ERC-20 token standard, but does not introduce any overly-specific ERC-20 features (eg. ABI encodings) into the specification.", "Open questions": "No backward compatibility issues found.", "Backwards Compatibility": "No backward compatibility issues found.", "Test Cases": "TODO", "Security Considerations": "ETH transfers already cost a minimum of 6700 gas, which is much more expensive than the LOG3 opcode (1500 gas). Hence, this EIP does not increase the worst-case number of logs that can be put into a block. It will somewhat increase the average number of logs.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7716, "url": "https://eips.ethereum.org/EIPS/eip-7716", "title": "Anti-correlation attestation penalties", "authors": ["dapplion\u00a0(", "@dapplion", ")", "Toni Wahrst\u00e4tter\u00a0(", "@nerolation", ")", "Vitalik Buterin\u00a0(", "@vbuterin", ")"], "sections": {"EIP-7716: Anti-correlation attestation penalties": "The decentralization of the validator set is one of the most important properties of Ethereum for credible neutrality and censorship resistance. By adjusting penalties to foster decentralization, diversification and fault-tolerance, this EIP proposes to adjust penalties in a way that more diversified entities get lower penalties while entities with high correlations in their setup face more severe ones.", "Adjust penalties for missed attestations based on in-slot correlation of missed attestation": "The decentralization of the validator set is one of the most important properties of Ethereum for credible neutrality and censorship resistance. By adjusting penalties to foster decentralization, diversification and fault-tolerance, this EIP proposes to adjust penalties in a way that more diversified entities get lower penalties while entities with high correlations in their setup face more severe ones.", "Abstract": "The decentralization of the validator set is one of the most important properties of Ethereum for credible neutrality and censorship resistance. By adjusting penalties to foster decentralization, diversification and fault-tolerance, this EIP proposes to adjust penalties in a way that more diversified entities get lower penalties while entities with high correlations in their setup face more severe ones.", "Motivation": "As of now, during times of usual network operation, there are no economic incentives to diversify node operations through using multiple different nodes, geographical locations, clients, ISP providers, etc., except for reducing the risk of penalties affecting all validators simultaneously, thereby limiting the impact to only a fraction of them.", "Specification": "Add a variableNET_EXCESS_PENALTIESto the beacon state.", "Rationale": "This variable impacts the sensitivity of theNET_EXCESS_PENALTIES.", "PENALTY_ADJUSTMENT_FACTOR": "This variable impacts the sensitivity of theNET_EXCESS_PENALTIES.", "MAX_PENALTY_FACTOR": "TheMAX_PENALTY_FACTORputs a ceiling onto the maximum factor with which the penalty for missed attestations is scaled to prevent overly harsh punishments.", "Backwards Compatibility": "This is a backwards incompatible adjustment of attestations rewards and penalties that requires a scheduled network upgrade.", "Security Considerations": "We acknowledge that splitting validator views can be leveraged as an attack to increase thepenalty_factorfor validators of consecutive slots with little risk for the proposer. \nTBD.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7727, "url": "https://eips.ethereum.org/EIPS/eip-7727", "title": "EVM Transaction Bundles", "authors": ["Lily Johnson\u00a0(", "@lilyjjo", ")"], "sections": {"EIP-7727: EVM Transaction Bundles": "This EIP introduces two newEIP-2718transaction types and one new opcode, enabling smart contracts and transactions to delegate their local sequencing rights to an off-chain entity. These new transaction types work together to create EVM-native \u2018bundles\u2019, which are similar to but weaker than the Proposer-Builder Separation (PBS) bundles offered by builders to searchers.", "Enable meta transactions to order other transactions without revert protections.": "This EIP introduces two newEIP-2718transaction types and one new opcode, enabling smart contracts and transactions to delegate their local sequencing rights to an off-chain entity. These new transaction types work together to create EVM-native \u2018bundles\u2019, which are similar to but weaker than the Proposer-Builder Separation (PBS) bundles offered by builders to searchers.", "Abstract": "This EIP introduces two newEIP-2718transaction types and one new opcode, enabling smart contracts and transactions to delegate their local sequencing rights to an off-chain entity. These new transaction types work together to create EVM-native \u2018bundles\u2019, which are similar to but weaker than the Proposer-Builder Separation (PBS) bundles offered by builders to searchers.", "Motivation": "Currently, a single block builder has unrestricted control over the final sequencing of a block\u2019s transactions. This poses a problem, as sequencing\u2014the choice of who gets to interact with specific pieces of state and in what order\u2014significantly influences value flow. The objective of this EIP is to allow more parties to participate in the construction of single blocks by exposing sequencing concepts inside of the EVM. This change would enable EVM applications to reclaim some of the sequencing value that is currently monopolized by block builders, redirecting it back to the applications themselves.", "Specification": "Two newEIP-2718transactions with typesDELEGATED_TX_TYPEandBUNDLE_TX_TYPE.", "Constants": "Two newEIP-2718transactions with typesDELEGATED_TX_TYPEandBUNDLE_TX_TYPE.", "New Transaction Payload Types": "Two newEIP-2718transactions with typesDELEGATED_TX_TYPEandBUNDLE_TX_TYPE.", "BUNDLE_SIGNEROpcode": "TheBUNDLE_SIGNERis a new opcode identified byBUNDLE_SIGNER_OPCODE_NUMBERthat requires zero stack arguments.", "Transaction Validity Rules": "For aDELEGATED_TX_TYPEto be valid, the following must be true:", "Gas Costs": "TheBUNDLE_TX_TYPEhas a new gas cost formula that changes based on whether the transactions in thetransactionListare valid at the time of execution.", "Execution": "DELEGATED_TX_TYPEexecute normally with theBUNDLE_SIGNERopcode returning thebundleSignerpayload variable.", "ReceiptPayload Definitions": "ForDELEGATED_TX_TYPEtransaction that are able to begin execution, theirEIP-2718receipt payload should be interpreted as:", "Rationale": "Knowing how a transaction will execute is challenging without knowing the state root to which the transaction is applied. Creators ofBUNDLE_TX_TYPEtransactions can only access the previous block\u2019s state root and cannot predict which transactions will precede theBUNDLE_TX_TYPEtransaction in the upcoming block\u2019s total order. If only valid transactions were permitted,BUNDLE_TX_TYPEtransaction lists could be easily invalidated by a single inner transaction attempting to grief the bundle through nonce or gas invalidations.", "Allowing invalid transactions to be included in aBUNDLE_TX_TYPE\u2019stransactionList": "Knowing how a transaction will execute is challenging without knowing the state root to which the transaction is applied. Creators ofBUNDLE_TX_TYPEtransactions can only access the previous block\u2019s state root and cannot predict which transactions will precede theBUNDLE_TX_TYPEtransaction in the upcoming block\u2019s total order. If only valid transactions were permitted,BUNDLE_TX_TYPEtransaction lists could be easily invalidated by a single inner transaction attempting to grief the bundle through nonce or gas invalidations.", "Charging theBUNDLE_TX_TYPE\u2019s signerCALLDATAgas costs for invalid transactions": "Blockchains must charge for the work that nodes perform to prevent DoS attacks. Even though invalid transactions inBUNDLE_TX_TYPEtransaction lists do not execute, they still occupy block space as bytes and must be paid for by some entity. It is assumed thatBUNDLE_TX_TYPEcreators will be sophisticated entities capable of simulating the previous block\u2019s state with relative accuracy and able to generate enough profit to offset any invalidation costs incurred.", "RequiringDELEGATED_TX_TYPEtyped transactions to be included in aBUNDLE_TX_TYPE\u2019stransactionList": "IfDELEGATED_TX_TYPEtransactions were able to be executed outside of aBUNDLE_TX_TYPEtransaction list, then there would be competition between theBUNDLE_TX_TYPEsigner and the total block builder for the right to choose how to locally sequence the transaction. If theDELEGATED_TX_TYPEtransaction signer wished to allow the total block builder to choose the local ordering, then theDELEGATED_TX_TYPEtransaction type should not be used.", "Not allowing other transactions types to be included in aBUNDLE_TX_TYPE\u2019stransactionList": "This restriction was implemented as a precautionary measure and could be reconsidered in the future. Allowing the inclusion of other transaction types that do not specify abundleSignerinto thetransactionListcould result in multiple searchers attempting to include the same transaction in a bundle. This could potentially create spam within a block.", "Differences from PBS Searcher Bundles": "PBS block builders currently offer \u2018bundles\u2019 as a service to searchers in the form of transaction lists that either all execute without reversion or are not included in a block. Searchers typically use these bundles to bid for the right to be the first to interact with a piece of state or to place logic before or after transactions created by non-searcher entities, with back-running and sandwiching being examples. PBS block builders provide this service as a way to gain order flow and increase their block\u2019s value.", "Backwards Compatibility": "No backward compatibility issues found.", "Security Considerations": "Block builders are problematic today partly due to their ability to perform censorship and enforce malicious orderings. These concerns persist even when sequencing rights are delegated to a specific entity. The code that generates the off-chain ordering should be public and executed in a trust-minimized manner, such as in a TEE (Trusted Execution Environment) or on a blockchain with faster block times.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7736, "url": "https://eips.ethereum.org/EIPS/eip-7736", "title": "Leaf-level state expiry in verkle trees", "authors": ["Guillaume Ballet\u00a0(", "@gballet", ")", "Wei Han Ng\u00a0(", "@weiihann", ")"], "sections": {"EIP-7736: Leaf-level state expiry in verkle trees": "Adds an \u201cupdate epoch\u201d to the verkle tree extension node. When it is time for an epoch to expire, the extension node and its suffix nodes can be deleted.", "Simple state expiry scheme in which only \"extension-and-suffix trees\" are expired.": "Adds an \u201cupdate epoch\u201d to the verkle tree extension node. When it is time for an epoch to expire, the extension node and its suffix nodes can be deleted.", "Abstract": "Adds an \u201cupdate epoch\u201d to the verkle tree extension node. When it is time for an epoch to expire, the extension node and its suffix nodes can be deleted.", "Motivation": "Previous attempts at implementing state expiry have been stalled by the quickly-increasing complexity, require heavy change in the structure of ethereum (address space extension, oil, multiple trees, \u2026). This proposal is offering a simpler albeit non-exhaustive approach to state expiry: only removing the leaf nodes and leaving the rest of the tree intact. This removes the need for methods that would be detrimental to the user and developer experience.", "Specification": "The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cNOT RECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 and RFC 8174.", "Constants": "Add an integral variable calledcurrent_epoch. It is initialized toINITIAL_EPOCH_COUNTERbefore the fork, and contains the current epoch number.", "Change to the verkle tree": "Add an integral variable calledcurrent_epoch. It is initialized toINITIAL_EPOCH_COUNTERbefore the fork, and contains the current epoch number.", "Expiry": "At the start of block processing, before transactions are executed, runcheck_epoch_end:", "Resurrection": "The resurrection transaction is defined as follows:", "Rationale": "This approach has the benefit of simplicity, over previous proposals for state expiry:", "Backwards Compatibility": "This proposal is backwards-compatible with verkle, as by default the value for the 4th (index starting at 0) evaluation point is set to0inEIP-6800, which is the value ofINITIAL_EPOCH_COUNTER.", "Test Cases": "TODO", "Reference Implementation": "TODO", "Security Considerations": "Needs discussion.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3, "url": "https://eips.ethereum.org/EIPS/eip-3", "title": "Addition of CALLDEPTH opcode", "authors": ["Martin Holst Swende\u00a0<", "martin@swende.se", ">"], "sections": {"EIP-3: Addition of CALLDEPTH opcode": "This is a proposal to add a new opcode,CALLDEPTH. TheCALLDEPTHopcode would return the remaining available call stack depth.", "": "This is a proposal to add a new opcode,CALLDEPTH. TheCALLDEPTHopcode would return the remaining available call stack depth.", "Abstract": "This is a proposal to add a new opcode,CALLDEPTH. TheCALLDEPTHopcode would return the remaining available call stack depth.", "Motivation": "There is a limit specifying how deep contracts can call other contracts; the call stack. The limit is currently256. If a contract invokes another contract (either viaCALLorCALLCODE), the operation will fail if the call stack depth limit has been reached.", "Specification": "The opcodeCALLDEPTHshould return the remaining call stack depth. A value of0means that the call stack is exhausted, and no further calls can be made.", "Rationale": "The actual call stack depth, as well as the call stack depth limit, are present in the EVM during execution, but just not available within the EVM. The implementation should be fairly simple and would provide a cheap and way to protect against call stack attacks.", "Implementation": "Not implemented.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 908, "url": "https://eips.ethereum.org/EIPS/eip-908", "title": "Reward clients for a sustainable network", "authors": ["James Ray\u00a0(", "@jamesray1", ")", "Micah Zoltu\u00a0(", "@MicahZoltu", ")"], "sections": {"EIP-908: Reward clients for a sustainable network": "While Casper validators are incentivized to validate transactions, there are still no incentives for relaying blocks and storing data (which includes state). This paper is more a high-level analysis and discussion rather than attempting to provide a concrete solution.Pocket Networkis a separate blockchain being designed as of Sept 2018 that incentivises relaying transactions, that is intended to be compatible with other blockchains. Note also thatRocket Poolis under development and is planned to be a pool for Casper, which will help to incentivise running a full node. Another alternative isVIPnodewhich charges fees to light clients for full nodes that serve them. In light of these solutions being developed, perhaps a more appropriate approach to generally rewarding clients would be to incentivize bandwidth (relaying and downloading), storage and I/O (while computation is already incentivized with gas for miners and will be for proposers under sharding and Casper). Note also that notaries will be incentivized to download collations under sharding. Outdated (Casper FFG will be implemented with Ethereum 2.0 with sharding:shasper): given that it looks like Casper FFG will be implemented soon, to minimize undue complexity to the protocol, incentivizing validation in the mean time may be considered not worthwhile. For a previous version of the proposal containing a proposal for rewarding a full node, refer tohere.", "": "While Casper validators are incentivized to validate transactions, there are still no incentives for relaying blocks and storing data (which includes state). This paper is more a high-level analysis and discussion rather than attempting to provide a concrete solution.Pocket Networkis a separate blockchain being designed as of Sept 2018 that incentivises relaying transactions, that is intended to be compatible with other blockchains. Note also thatRocket Poolis under development and is planned to be a pool for Casper, which will help to incentivise running a full node. Another alternative isVIPnodewhich charges fees to light clients for full nodes that serve them. In light of these solutions being developed, perhaps a more appropriate approach to generally rewarding clients would be to incentivize bandwidth (relaying and downloading), storage and I/O (while computation is already incentivized with gas for miners and will be for proposers under sharding and Casper). Note also that notaries will be incentivized to download collations under sharding. Outdated (Casper FFG will be implemented with Ethereum 2.0 with sharding:shasper): given that it looks like Casper FFG will be implemented soon, to minimize undue complexity to the protocol, incentivizing validation in the mean time may be considered not worthwhile. For a previous version of the proposal containing a proposal for rewarding a full node, refer tohere.", "A reward for running a full node is deprecated, but the proposal for a reward for clients remains": "While Casper validators are incentivized to validate transactions, there are still no incentives for relaying blocks and storing data (which includes state). This paper is more a high-level analysis and discussion rather than attempting to provide a concrete solution.Pocket Networkis a separate blockchain being designed as of Sept 2018 that incentivises relaying transactions, that is intended to be compatible with other blockchains. Note also thatRocket Poolis under development and is planned to be a pool for Casper, which will help to incentivise running a full node. Another alternative isVIPnodewhich charges fees to light clients for full nodes that serve them. In light of these solutions being developed, perhaps a more appropriate approach to generally rewarding clients would be to incentivize bandwidth (relaying and downloading), storage and I/O (while computation is already incentivized with gas for miners and will be for proposers under sharding and Casper). Note also that notaries will be incentivized to download collations under sharding. Outdated (Casper FFG will be implemented with Ethereum 2.0 with sharding:shasper): given that it looks like Casper FFG will be implemented soon, to minimize undue complexity to the protocol, incentivizing validation in the mean time may be considered not worthwhile. For a previous version of the proposal containing a proposal for rewarding a full node, refer tohere.", "Simple Summary": "When each transaction is validated, give a reward to clients for developing the client.", "Abstract": "The tragedy of the commons is a phenomenon that is well known in many sectors, most notably in regard to sustainability. It involves the over-utilization of shared finite resources, which detriments all participants and stakeholders involved (which in the case of a global public good can be everyone, including future generations). Without proper management of public resources, a tragedy of the commons can occur. Internalizing externalities (where externalities can be broadly defined as effects that are not accounted for in the intrinsic price of a good, service or resource) is one way of incentivizing the proper management of resources, although other methods that actually properly manage them are necessary. This EIP proposes to make a change to the protocol to providea reward to clients for providing the software that enables Ethereum to function, where the reward can include a proportion of transaction fees (reducing the full proportion that the miner currently receives), and some newly minted ETH. Thus, clients are incentivized to maintain and improve the security and health of the Ethereum protocol and ecosystem. To summarize the mechanism in the proposal, a user agent is attached to a transaction, where this user agent contains a vector with the index of a client address in an access list. The client address could be inserted by the client and verified that it is the same as a read-only constant in the client\u2019s storage.", "Motivation": "Currently there is a lack of incentives for anyone to run a full node, while joining a mining pool is not really economical if one has to purchase a mining rig (several GPUs) now, since there is unlikely to be a return on investment by the time that Ethereum transitions to hybrid Proof-of-Work/Proof-of-Stake withCasper FFG, then full PoS withCBC Casper.", "Specification": "Add a new field to each block calledPrevBlockVerifications, which is an arbitrary, unlimited size byte array. When a client verifies that a previous block isvalid, the client appends a user agent to PrevBlockVerifications via an opcode in a transaction, PREV_BLOCK_VERIF. The user agent is a vector with the  immutable fields: the blockhash of the block that is validated, and the index of a client address in an access list (details are below). A miner validates a transaction before including it in a block, however they are not able to change these fields of the vector because they\u2019re immutable.", "Attacks and added specifications to prevent them": "A miner could create a client and fill their block with transactions that only contain the PREV_BLOCK_VERIF opcode (or alternatively, arbitrarily complex transactions, still with the opcode), with previous blockhashes that they have validated and the address of their client. To prevent this, state would have to store a list containing lists, with each sublist listing the blockhashes up to 400 blocks ago that correspond to a miner, then a miner (or a proposer under Casper CBC) could have to put down a deposit, and be slashed if the proposer inserts such a transaction (that contains a blockhash which they have already proposed, not just in a block but at any time previously). Updating the state to remove blockhashes more than 400 blocks ago would add additional overhead, although you could add an extra window for older blocks, say 120,000 blocks (roughly every 3 weeks), still ignore blocks that are older than 400 blocks ago, and remove these older 120,000 blocks every 120,000 blocks. An attacker could bribe a miner/proposer to include transactions like above that contain an address of a client in the access list which they own. However, the above slashing condition should disincentivize this.", "More details on the access list": "The access list prevents anyone inserting any address to the first element of the vector, where there may be a way to prevent censorship and centralization of authority of who decides to register new addresses in the list, e.g. on-chain governance with signalling (possibly similar toEIP-1015, which also specifies an alternative way of sending funds) or a layer 2 proof of authority network where new addresses can be added via a smart contract. Note that there may be serious drawbacks to implementing either of these listed examples. There is a refutation ofon-chain governanceas well as ofplutocracy.Proof of Authorityisn\u2019t suitable for a public network since it doesn\u2019t distribute trust well. However, using signalling in layer 2 contracts is more acceptable, but Vlad Zamfir argues that using that to influence outcomes in the protocol can disenfranchise miners from being necessary participants in the governance process. Thus, in light of these counterpoints, having an access list may not be suitable until a decentralized, trustless way of maintaining it is implemented and ideally accepted by the majority of a random sample that represents the population of Ethereum users.", "Rationale": "As of May 4 2018, there are16428 nodes. Assume that an annual cost for an average client developer organisation is $1 million per annum. Projecting forward (and noting that the number of nodes should increase substantially if this EIP was implemented, thus aiding Ethereum\u2019s goal of decentralizing everything) assume that there are 10 clients. Thus let us assume that the number of nodes doubles to 30000 nodes within 5 years (this assumption is probably conservative, even if it is forward looking). Assume for simplicity that the costs of a client are entirely covered by this block reward.", "A rough qualitative analysis of fees": "As of May 4 2018, there are16428 nodes. Assume that an annual cost for an average client developer organisation is $1 million per annum. Projecting forward (and noting that the number of nodes should increase substantially if this EIP was implemented, thus aiding Ethereum\u2019s goal of decentralizing everything) assume that there are 10 clients. Thus let us assume that the number of nodes doubles to 30000 nodes within 5 years (this assumption is probably conservative, even if it is forward looking). Assume for simplicity that the costs of a client are entirely covered by this block reward.", "More rationale (outdated by above)": "The amount of computation to validate a transaction will be the same as a miner, since the transaction will need to be executed. Thus, if there would be transaction fees for validating full nodes and clients, and transactions need to be executed by validators just like miners have to, it makes sense to have them calculated in the same way as gas fees for miners. This would controversially increase the amount of transaction fees a lot, since there can be many validators for a transaction. In other words, it is controversial whether to provide the same amount of transaction fee for a full node validator as for a miner (which in one respect is fair, since the validator has to do the same amount of computation), or prevent transaction fees from rising much higher, and have a transaction fee for a full node as, say, the transaction fee for a miner, divided by the average number of full nodes validating a transaction. The latter option seems even more controversial (but is still better than the status quo), since while there would be more of an incentive to run a full node than there is now with no incentive, validators would be paid less for performing the same amount of computation.", "Security": "All of the below struck out information should be prevented via using an access list and verifying that the read-only address provided by the client matches with an address in the access list, as well as using a layer 2 solution such as a PoA network for censhorship resistance and minimization of centralization in the access list.", "Backwards Compatibility": "Introducing in-protocol fees is a backwards-incompatible change, so would be introduced in a hard-fork.", "Test Cases": "TODO", "Implementation": "TODO", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 999, "url": "https://eips.ethereum.org/EIPS/eip-999", "title": "Restore Contract Code at 0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4", "authors": ["Afri Schoedon\u00a0(", "@5chdn", ")"], "sections": {"EIP-999: Restore Contract Code at 0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4": "This document proposes to restore the contract code of theWalletLibrarycontract at0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4with a patched version.\nThe contract was accidentally self-destructed and renders a significant amount\nof Ether inaccessible.", "": "This document proposes to restore the contract code of theWalletLibrarycontract at0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4with a patched version.\nThe contract was accidentally self-destructed and renders a significant amount\nof Ether inaccessible.", "Simple Summary": "This document proposes to restore the contract code of theWalletLibrarycontract at0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4with a patched version.\nThe contract was accidentally self-destructed and renders a significant amount\nof Ether inaccessible.", "Abstract": "TheWalletLibrarycontract was used by theParity Walletto reduce gas costs for users deploying\nmulti-signature wallets on the Ethereum blockchain. It contained basic\nfunctionality such as confirming or revoking multi-signature transactions for\nany wallet deployed that depends on this library. Theaccidental self-destructionof the library contract caused significant amounts of Ether and other assets\nowned by many different parties to be inaccessible. This proposal suggests\nrestoring theWalletLibraryby apatchedversion to allow the\nowners of the dependent multi-signature wallets regain access to their assets.", "Motivation": "This proposal is necessary because the Ethereum protocol does not allow the\nrestoration of self-destructed contracts and there is no other simple way to\nenable the affected users and companies regaining access to their tokens and\nEther. In opposite to previously discussed proposals, this will not change any\nEVM semantics and tries to achieve the goal of unfreezing the funds by a single\nstate transition as specified in the next section.", "Specification": "The self-destructed contract code at0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4shall be replaced with a patched version of thewalletLibrary.solas reviewed, tested, and approved inparity-contracts/0x863df6bfa4:", "Direct State Transition via Bytecode (999a)": "AtCNSTNTNPL_FORK_BLKNUM, directly recreate the account0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4with the following parameters:", "Alternate Specification via Codehash (999b)": "AtCNSTNTNPL_FORK_BLKNUM, directly recreate the account0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4with the following parameters:", "Rationale": "The design decision to restore theWalletLibrarycontract code in a single\nstate transition was made after lengthy discussions ofalternate proposalsthat explored different ways to improve the Ethereum protocol to allow contract\nrevivals by adding different built-in contracts. It was eventually concluded\nthat all of these proposals changing the EVM semantics around self-destructed\ncontracts were introducing unwanted side-effects andpotential risksto the existing smart-contract ecosystem on the Ethereum platform.", "Backwards Compatibility": "This proposal introduces backwards incompatibilities in the state of the\ncontract at0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4. The Ethereum protocol\ndoes not allow the restoration of self-destructed contracts. To implement this\non the Ethereum blockchain, it is recommended to add the necessary state\ntransition in a future hard-fork at a well-defined block number, e.g.,CNSTNTNPL_FORK_BLKNUMfor the Constantinople milestone which is supposed to be\nthe next scheduled hard-fork on the Ethereum road-map.", "Implementation": "A proof-of-concept implementation is available for the Parity client on brancha5-eip999-poc(#8406). A sample chain\nconfiguration for Parity can be found at the same branch inmultisig_test.jsondescribing the state change as specified above.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1240, "url": "https://eips.ethereum.org/EIPS/eip-1240", "title": "Remove Difficulty Bomb", "authors": ["Micah Zoltu\u00a0(", "@MicahZoltu", ")"], "sections": {"EIP-1240: Remove Difficulty Bomb": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) slowly accelerating. This EIP proposes to remove the difficulty increase over time and replace it with a fixed difficulty targeting 15 second blocks.", "": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) slowly accelerating. This EIP proposes to remove the difficulty increase over time and replace it with a fixed difficulty targeting 15 second blocks.", "Simple Summary": "The average block times are increasing due to the difficulty bomb (also known as the \u201cice age\u201d) slowly accelerating. This EIP proposes to remove the difficulty increase over time and replace it with a fixed difficulty targeting 15 second blocks.", "Abstract": "Starting withFORK_BLOCK_NUMBERthe client will calculate the difficulty without considering the current block number.", "Motivation": "The difficulty bomb operates under the assumption that miners decide what code economic participants are running, rather than economic participants deciding for themselves.  In reality, miners will mine whatever chain is most profitable and the most profitable chain is the one that economic participants use.  If 99% of miners mine a chain that no economic participants use then that chain will have no value and the miners will cease mining of it in favor of some other chain that does have economic participants.  Another way to put this is that miners will follow economic participants, not the other way around.", "Specification": "For the purposes ofcalc_difficulty, ifblock.number >= FORK_BLOCK_NUMBERthen change the epsilon component to0rather than having it be a function of block number.", "Rationale": "With the difficulty bomb removed, when Casper is released it will be up to economic participants to decide whether they want the features that Casper enables or not.  If they do not want Casper, they are free to continue running unpatched clients and participating in the Ethereum network as it exists today.  This freedom of choice is the cornerstone of DLTs and making it hard for people to make that choice (by creating an artificial pressure) does not work towards that goal of freedom of choice.  If the development team is not confident that economic participants will want Casper, then they should re-evaluate their priorities rather than trying to force Casper onto users.", "Backwards Compatibility": "This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation. Therefore, it should be included in a scheduled hardfork at a certain block number.", "Test Cases": "Test cases shall be created once the specification is to be accepted by the developers or implemented by the clients.", "Implementations": "The yellow paper implements this change in https://github.com/ethereum/yellowpaper/pull/710", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1355, "url": "https://eips.ethereum.org/EIPS/eip-1355", "title": "Ethash 1a", "authors": ["Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Jean M. Cyr\u00a0(", "@jean-m-cyr", ")"], "sections": {"EIP-1355: Ethash 1a": "Provide minimal set of changes to Ethash algorithm to hinder and delay the adoption of ASIC based mining.", "": "Provide minimal set of changes to Ethash algorithm to hinder and delay the adoption of ASIC based mining.", "Motivation": "Provide minimal set of changes to Ethash algorithm to hinder and delay the adoption of ASIC based mining.", "Specification": "The usual argument for decentralization and network security.", "Rationale": "The usual argument for decentralization and network security.", "FNV Primes": "The 16777639 satisfies all requirements fromWikipedia.", "Copyright": "This work is licensed under aCreative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1682, "url": "https://eips.ethereum.org/EIPS/eip-1682", "title": "Storage Rent", "authors": ["Felix J Lange\u00a0(", "@fjl", ")", "Martin Holst Swende\u00a0(", "@holiman", ")"], "sections": {"EIP-1682: Storage Rent": "This EIP describes a scheme to charge for data in state, and \u2018archive\u2019 data which is no longer being paid for. It also describes how resurrection of \u2018archived\u2019 data happens.", "": "This EIP describes a scheme to charge for data in state, and \u2018archive\u2019 data which is no longer being paid for. It also describes how resurrection of \u2018archived\u2019 data happens.", "Abstract": "This EIP describes a scheme to charge for data in state, and \u2018archive\u2019 data which is no longer being paid for. It also describes how resurrection of \u2018archived\u2019 data happens.", "Motivation": "The Ethereum blockchain in its current form is not sustainable because it grows\nindefinitely. This is true of any blockchain, but Ethereum grows faster than most chains.\nMany implementation strategies to slow down growth exist. A common strategy is \u2018state\npruning\u2019 which discards historical state, keeping only the active copy of contract data\nand a few recent versions to deal with short-range chain reorganizations. Several\nimplementations also employ compression techniques to keep the active copy of the state as\nsmall as possible.", "Specification": "The cost of storing an account over time is calledrent. The amount ofrentdue depends\non the size of the account. Theetherthat is paid forrentis destroyed. Therentis deducted whenever an account is touched.", "Changes To State": "At the top level, a new keysizeis added to the accounts trie. This key tracks the\ntotal number of trie nodes across all accounts, including storage trie nodes. To track\nrent, the structure of account entries is changed as well.", "Charging Rent": "There is a new protocol constantMAX_STORAGE_SIZEthat specifies the upper bound on the\nnumber of state tree nodes:", "New EVM Opcodes": "At any time, therent balanceof an account may be topped up by thePAYRENTopcode.PAYRENTdeducts the given amount ofetherfrom the account executing the opcode and adds\nit to therent balanceof the address specified as beneficiary.", "Rationale": "Accounts need a separate rent balance because some contracts are non-payable, i.e. they\nreject regular value transfers. Such contracts might not be able to keep themselves alive,\nbut users of those contracts can keep them alive by paying rent for them.", "Why do we need a separate rent balance?": "Accounts need a separate rent balance because some contracts are non-payable, i.e. they\nreject regular value transfers. Such contracts might not be able to keep themselves alive,\nbut users of those contracts can keep them alive by paying rent for them.", "Why restoration?": "One of the fundamental guarantees provided by Ethereum is that changes to contract storage\ncan only be made by the contract itself and storage will persist forever. If you hold a\ntoken balance in a contract, you\u2019ll have those tokens forever. By adding restoration, we\ncan maintain this guarantee to a certain extent.", "Implementation Impact": "The proposed changes tries to fit within the existing state transition model. Note that\nthere is no mechanism for deactivating accounts the moment they can\u2019t pay rent. Users must\ntouch accounts to ensure their storage is removed because we\u2019d need to track all accounts\nand their rent requirements in an auxlilary data structure otherwise.", "Backwards Compatibility": "TBA", "Test Cases": "TBA", "Implementation": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1706, "url": "https://eips.ethereum.org/EIPS/eip-1706", "title": "Disable SSTORE with gasleft lower than call stipend", "authors": ["Alex Forshtat\u00a0<", "alex@tabookey.com", ">", "Yoav Weiss\u00a0<", "yoav@tabookey.com", ">"], "sections": {"EIP-1706: Disable SSTORE with gasleft lower than call stipend": "The proposal that had been accepted changes security properties of a large portion of an existing contract code base that may be infeasible to update and validate. This proposal will make the old assumptions hold even after a network upgrade.", "": "The proposal that had been accepted changes security properties of a large portion of an existing contract code base that may be infeasible to update and validate. This proposal will make the old assumptions hold even after a network upgrade.", "Simple Summary": "The proposal that had been accepted changes security properties of a large portion of an existing contract code base that may be infeasible to update and validate. This proposal will make the old assumptions hold even after a network upgrade.", "Abstract": "EIP-1283significantly lowers the gas costs of writing to contract\u2019s storage. This created a danger of a new kind of reentrancy attacks on existing contracts as Solidity by default grants a \u2018stipend\u2019 of 2300 gas to simple transfer calls.\nThis danger is easily mitigated if SSTORE is not allowed in low gasleft state, without breaking the backward compatibility and the original intention of this EIP.", "Motivation": "An attack that is described inthis article.\nExplicitly specifying the call stipend as an invariant will have a positive effect on Ethereum protocol security: \nhttps://www.reddit.com/r/ethereum/comments/agdqsm/security_alert_ethereum_constantinople/ee5uvjt", "Specification": "Add the following condition to the SSTORE opcode gas cost calculation:", "Rationale": "In order to keep in place the implicit reentrancy protection of existing contracts, transactions should not be allowed to modify state if the remaining gas is lower then the 2300 stipend given to \u2018transfer\u2019/\u2019send\u2019 in Solidity.\nThese are other proposed remediations and objections to implementing them:", "Backwards Compatibility": "Performing SSTORE has never been possible with less than 5000 gas, so it does not introduce incompatibility to the Ethereum mainnet. Gas estimation should account for this requirement.", "Test Cases": "Test cases for an implementation are mandatory for EIPs that are affecting consensus changes. Other EIPs can choose to include links to test cases if applicable.\nTODO", "Implementation": "TODO", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 1890, "url": "https://eips.ethereum.org/EIPS/eip-1890", "title": "Commitment to Sustainable Ecosystem Funding", "authors": ["Gregory Markou\u00a0<", "greg@chainsafe.io", ">", "Kevin Owocki\u00a0<", "kevin@gitcoin.co", ">", "Lane Rettig\u00a0<", "lane@ethereum.org", ">"], "sections": {"EIP-1890: Commitment to Sustainable Ecosystem Funding": "Ethereum currently provides a block reward to proof of work miners every block, but it does not capture any block rewards for ecosystem funding. This EIP adds a simple mechanism for capturing a portion of block rewards for ecosystem funding as a credible commitment to doing so in future, but it does not actually capture any such rewards.", "": "Ethereum currently provides a block reward to proof of work miners every block, but it does not capture any block rewards for ecosystem funding. This EIP adds a simple mechanism for capturing a portion of block rewards for ecosystem funding as a credible commitment to doing so in future, but it does not actually capture any such rewards.", "Commitment to Sustainable Ecosystem Funding": "Ethereum currently provides a block reward to proof of work miners every block, but it does not capture any block rewards for ecosystem funding. This EIP adds a simple mechanism for capturing a portion of block rewards for ecosystem funding as a credible commitment to doing so in future, but it does not actually capture any such rewards.", "Simple Summary": "Ethereum currently provides a block reward to proof of work miners every block, but it does not capture any block rewards for ecosystem funding. This EIP adds a simple mechanism for capturing a portion of block rewards for ecosystem funding as a credible commitment to doing so in future, but it does not actually capture any such rewards.", "Abstract": "A mechanism that allows specification of two parameters, a beneficiary address and a per-block reward denominated in wei, that allows a portion of block rewards to be captured for the purpose of ecosystem funding. Both values are set to zero.", "Motivation": "In order for Ethereum to succeed, it needs talented, motivated researchers and developers to continue to develop and maintain the platform. Those talented researchers and developers deserve to be paid fairly for their work. At present there is no mechanism in the Ethereum ecosystem that rewards R&D teams fairly for their work on the platform.", "Specification": "Two new constants are introduced: BENEFICIARY_ADDRESS, an Address, and DEVFUND_BLOCK_REWARD, an amount denominated in wei. Both are set to zero.", "Rationale": "We believe that the technical design of this EIP is straightforward. The social rationale is explained inthis article.", "Backwards Compatibility": "This EIP has no impact on backwards compatibility.", "Test Cases": "This EIP makes no changes to existing state transitions. Existing consensus tests should be sufficient.", "Implementation": "Reference implementations are included for the Trinity, go-ethereum, and parity clients.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2025, "url": "https://eips.ethereum.org/EIPS/eip-2025", "title": "Block Rewards Proposal for funding Eth1.x", "authors": ["James Hancock\u00a0(", "@madeoftin", ")"], "sections": {"EIP-2025: Block Rewards Proposal for funding Eth1.x": "Add0.0055 ETHper block for 18 months (A total of 17050 ETH) as a developer block reward reserved for funding specific Ethereum1.X working groups. The working groups are State rent (750k), Better sync (360k), Finality gadget (360k), Fee market (360k), Testing infrastructure (360k). Governance of the funds will be through a multisig of trusted individuals from the ecosystem including client teams, the foundation, and the community.", "": "Add0.0055 ETHper block for 18 months (A total of 17050 ETH) as a developer block reward reserved for funding specific Ethereum1.X working groups. The working groups are State rent (750k), Better sync (360k), Finality gadget (360k), Fee market (360k), Testing infrastructure (360k). Governance of the funds will be through a multisig of trusted individuals from the ecosystem including client teams, the foundation, and the community.", "Simple Summary": "Add0.0055 ETHper block for 18 months (A total of 17050 ETH) as a developer block reward reserved for funding specific Ethereum1.X working groups. The working groups are State rent (750k), Better sync (360k), Finality gadget (360k), Fee market (360k), Testing infrastructure (360k). Governance of the funds will be through a multisig of trusted individuals from the ecosystem including client teams, the foundation, and the community.", "Abstract": "This EIP extends the mechanism established in EIP-1890 to add0.0055 ETHto the block reward for a specific distribution period of3,100,000 BLOCKS(\u2248 18 months). TheRECIPIENT_ADDRESSis set to a smart contract with hardcoded denominations that distributes incoming ETH to a set of addresses for the purpose of Eth1.X development. The emission schedule would start at the hard fork block number and continue for3,100,000 BLOCKS(\u2248 18 months) at which point the address and amount would again return to 0. Any further distribution would require a future hard fork.", "Motivation": "The context for this proposal came from attending theCore Dev Eth1.X Meetingin Berlin. Development is needed to move Eth1.X forward, and I observed that a lack of funding is the primary barrier to this work. This work can only be effectively conducted by working groups forming around these issues, and these working groups need funding in order to pay dedicated contractors and project managers. This proposal is a plan for funding these groups and supporting their operation.", "Specification": "Two constants will be introduced:", "Rewards Distribution Rationale": "With a price of Etheruem at $150.00 this will raise approx USD $2,325,000.00 for developing Eth1.X over the next 18 months.", "Rationale": "There has been great public debate concerning EIP-1890, and one of the primary concerns is that it is difficult to evaluate the proposal without more complete information on how funds would be raised, how they would be administered, and how they would be used. There is a need for funding Eth1.x development and it is currently unclear where those funds will come from. This proposal is intended to give a more comprehensive proposal for its funding. In the case that ETH1.x is fully funded before the Istanbul upgrade I will withdraw this EIP. Until that point I intend to continue championing this proposal as a valid funding mechanism for this work.", "Why a loan?": "The Eth1x initiative needs funding now, not in 18 months. A loan is necessary to complete certain stages of work before the funding mechanism begins to provide funds. A loan would provide this necessary funding today, and the investors willing to front this cost can recoup their contribution + a reward ofa fixed interest ratefor the risk on their loan. This arrangement will make it easier to find investors willing to participate who have sufficient funds.", "Loan Repayment": "", "Development Loan": "Development Loan: 0.005over 3.1 Million blocks = 15500 ETH", "Accountability": "The funds will be transferred into DAI and secured in a multi-sig comprised of members of the community. Representatives from the following groups will receive a key.", "Personal Notes and Disclosure": "I want to address any concerns about conflicts of interests directly. My participation with Eth1.X currently has been as a volunteer. I am in talks about a possible funded role helping with testing and coordination. If my work for with Eth1.x is funded, I will accept no additional funding collected by the mechanism proposed in this EIP.", "COI": "Previously I was PM for Tennagraph, a signalling solution for Ethereum. An Aragon grant funded this project and was distributed through Giveth and an AragonDAO. I have not received any funding from the project beyond this grant. All of this is verifiable on-chain. I am stepping down from any paid role on the project to continue as an advisor. I am also stepping down as a moderator for stances as there is a COI moderating stances for EIPs I am working with directly.", "Disclaimer": "I do not claim to represent the community with my views; any members who wish to join supporting me with this proposal are free to do so. This is as fair of a proposal as I can personally conceive.", "Backwards Compatibility": "This EIP has no impact on backwards compatibility.", "Test Cases": "Not Implemented", "Implementation": "Not Implemented", "FAQ": "Why not us a smart contract with some governance mechanism to allow changing the distribution of funds? Wouldn\u2019t that be more flexible and effective?", "Why Hardcoded Values?": "Why not us a smart contract with some governance mechanism to allow changing the distribution of funds? Wouldn\u2019t that be more flexible and effective?", "Why not allow current client implementors fund this work? (EF, Consensys, Parity, etc\u2026)": "Historically there has been a precedent that the Ethereum Foundation is solely responsible for funding the development of Ethereum. This process has evolved as the development has become more distributed. Aya Miyaguchi observed in a recentCoindesk article, \u201cit really is not only Ethereum Foundation people who are building [Ethereum]\u201d. Yes, we could rely on the Ethereum Foundation to fund Eth1.X. But, why should we? This is a call for the network to come together and fund its own development. Ethereumthe networkis not owned by any one organization or group of people. We are lucky to have the EF and I consider this EIP in support of their coordination efforts.", "How Will Funding the Devs be Organized": "I do not profess to know the best way to organize these funds. There is work already in progress to organize these efforts championed by Alexey Akhunov. The following is a quote from arecent medium article:", "Isn\u2019t a loan considered a security, or is it?": "I am not a lawyer and will seek further guidance from lawyers in the field on this point in particular. From the research I have done and conversations I have had there is a very good argument that a loan of this nature will not be considered a security by the US Supreme Court.\nAs the result ofREVES ET AL. v . ERNST YOUNG 1990, the court stated that a home loan, consumer financing, a loan secured by a lien on a small business or some assets of a small business, short term notes, or notes that formalize a debt incurred in the ordinary course of business are not securities. If the note resembles the items listed above (home loans, etc.) then the note will not be deemed a security. The Supreme Court provided four factors to determine if a note sufficiently resembles the types of notes that are not classified as securities. (source)", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2315, "url": "https://eips.ethereum.org/EIPS/eip-2315", "title": "Simple Subroutines for the EVM", "authors": ["Greg Colvin\u00a0(", "@gcolvin", ")", "Martin Holst Swende\u00a0(", "@holiman", ")", "Brooklyn Zelenka\u00a0(", "@expede", ")", "John Max Skaller\u00a0<", "skaller@internode.on.net", ">"], "sections": {"EIP-2315: Simple Subroutines for the EVM": "This proposal provides acomplete,efficient,safeandstaticcontrol-flow facility.", "Two opcodes for efficient, safe, and static subroutines.": "This proposal provides acomplete,efficient,safeandstaticcontrol-flow facility.", "Abstract": "This proposal provides acomplete,efficient,safeandstaticcontrol-flow facility.", "Motivation": "Jumps, conditional jumps and subroutines were proposed by Alan Turing in 1945 as a means of organizing the logic of the code and the design of the memory crystals for his Automatic Computing Engine:", "A complete control-flow facility.": "Jumps, conditional jumps and subroutines were proposed by Alan Turing in 1945 as a means of organizing the logic of the code and the design of the memory crystals for his Automatic Computing Engine:", "Efficient control-flow.": "Efficient to write by hand, compile from high level labguages, validate at deploy time, interpret by VMs, and compile to machine code.", "Safe control-flow.": "The EVM has unusually high requirements for safety.  Not only do many smart contracts control inordinately large amounts of valuable Ether, but once placed on the blockchain any defects are visible to attackers and cannot be repaired.  We propose to statically validate important safety constraints on code at initialization time.", "Static control-flow.": "The EVM\u2019s dynamic jumps cause two major problems. First, the need to synthesize static jumps and subroutines with dynamic jumps wastes space and gas with needlessly complex code, as we will show below.", "Specification": "Transfers control to a subroutine.", "Opcodes": "Transfers control to a subroutine.", "Validity": "Executionis defined in the Yellow Paper as a sequence of changes in the EVM state.  The conditions on valid code are preserved by state changes.  At runtime, if execution of an instruction would violate a condition the execution is in an exceptional halting state.  The Yellow Paper defines six such states.", "Rationale": "This is a purely semantic specification, placing no constraints on the syntax of code sections beyond being a sequence of opcodes and immediate data \u2013 a subroutine is not a contiguous sequence of bytecode, it is a subgraph of the bytecode\u2019s control-flow graph.  The EVM is a simple state machine.  We only promise that valid code will not, as it were, jam up the gears of the machine.", "Validation": "Rather than enforce constraints via syntax, we enforce them via validation.", "Alternative Designs": "There are a few major designs for a subroutine facility, two of which are considered here.  The others are mostly not appropriate for the EVM, such as the Wheeler Jump \u2013 self-modifying code that writes return addresses into called subroutines.", "Efficiency": "We illustrate here how subroutine instructions can be used to reduce the complexity and gas costs of both ordinary and optimized subroutine calls compared to usingJUMP.", "Costs": "Thelowcost ofRJUMPSUBversus themidcost ofJUMPis justified by needing only to decode the immediate two byte destination to thePCand push the return address on thereturn stack, all using native arithmetic, versus using the data stack with emulated 256-bit instructions.", "Backwards Compatibility": "These changes affect the semantics of existing EVM code: bytes that would have been interpreted as valid jump destinations may now be interpreted as immediate data.  Since this proposal depends on the Ethereum Object Format to signal the change this is not a practical issue.", "Test Cases": "This should jump into a subroutine, back out and stop.", "Simple routine": "This should jump into a subroutine, back out and stop.", "Two levels of subroutines": "This should execute fine, going into one two depths of subroutines", "Failure 1: invalid jump": "This should fail, since the given location is outside of the code-range.", "Failure 2: shallowreturn stack": "This should fail at first opcode, due to shallowreturn_stack", "Subroutine at end of code": "In this example the RJUMPSUB is on the last byte of code. When the subroutine returns, it should hit the \u2018virtual stop\u2019afterthe bytecode, and not exit with error", "Reference Implementation": "The following is a pseudo-Python implementation of an algorithm for predicating code validity.  An equivalent algorithm must be run at initialization time.", "Validation Function": "** Note: this function is known to be incomplete and incorrect. **", "Security Considerations": "These changes introduce new flow control instructions.  They do not introduce any new security considerations. This EIP is intended to improve security by validating a higher level of safety for EVM code deployed on the blockchain.  The validation algorithm must be quasi-linear in time and space to not be a denial of service vulnerability.  The algorithm here makes one linear-time pass of the bytecode, and uses a stack of continuations that cannot exceed the number ofRJUMPIinstructions in the code.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2677, "url": "https://eips.ethereum.org/EIPS/eip-2677", "title": "Limit size of `initcode`", "authors": ["Martin Holst Swende\u00a0(", "@holiman", ")", "Pawe\u0142 Bylica\u00a0(", "@chfast", ")", "Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-2677: Limit size of `initcode`": "Enforce a maximum size limit (max_initcode_size) of49152(0xc000) forinitcode.", "": "Enforce a maximum size limit (max_initcode_size) of49152(0xc000) forinitcode.", "Simple Summary": "Enforce a maximum size limit (max_initcode_size) of49152(0xc000) forinitcode.", "Abstract": "Enforce a maximum size limit (max_initcode_size) forinitcode. If the size ofinitcodeexceedsmax_initcode_size, then contract creation fails with an out of gas error.", "Motivation": "When a client executesinitcode, the client has to perform a jumpdest analysis. In some cases, the client also performs ahashof the code:", "Specification": "There are three situations where this is applicable:", "Rationale": "TBA", "Backwards Compatibility": "This EIP requires a \u201cnetwork upgrade\u201d, since it modifies consenus-rules.", "Security Considerations": "For client implementations, this EIP makes attacks based on jumpdest-analysis or hashing of code less problematic, so should increase the robustness of clients.", "Test Cases": "Test cases should include the following cases,", "Implementation": "TBA", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2711, "url": "https://eips.ethereum.org/EIPS/eip-2711", "title": "Sponsored, expiring and batch transactions.", "authors": ["Micah Zoltu\u00a0(", "@MicahZoltu", ")"], "sections": {"EIP-2711: Sponsored, expiring and batch transactions.": "Creates a new transaction type that supports sponsored transactions (separate gas payer from sender), batch transactions (multiple transactions executed in sequence), and expiring transactions (transactions which are not valid after a certain timestamp).", "": "Creates a new transaction type that supports sponsored transactions (separate gas payer from sender), batch transactions (multiple transactions executed in sequence), and expiring transactions (transactions which are not valid after a certain timestamp).", "Simple Summary": "Creates a new transaction type that supports sponsored transactions (separate gas payer from sender), batch transactions (multiple transactions executed in sequence), and expiring transactions (transactions which are not valid after a certain timestamp).", "Abstract": "An EIP-2718 transaction with the type number2is a new type of transaction that includes support for:", "Motivation": "With the advent of tokens and especially stable coins, it has become common for users to not hold ETH in an account while they may have other assets of value in that account.  Some users don\u2019t want to be exposed to the perceived volatility of ETH and instead would prefer to transact using other assets.  Unfortunately, since gasMUSTbe paid for with ETH, this prevents the user from transacting with their assets without first acquiring some ETH using some other means, and then using that ETH to pay fees.", "Sponsored Transactions": "With the advent of tokens and especially stable coins, it has become common for users to not hold ETH in an account while they may have other assets of value in that account.  Some users don\u2019t want to be exposed to the perceived volatility of ETH and instead would prefer to transact using other assets.  Unfortunately, since gasMUSTbe paid for with ETH, this prevents the user from transacting with their assets without first acquiring some ETH using some other means, and then using that ETH to pay fees.", "Batch Transactions": "Often times an EOA may want to execute a series of transactions with a strong guarantee that they happen in order with nothing occurring between them.  For example, one may want to send some tokens to a contract and then follow that up with another transaction that makes a contract call on the destination address that causes those tokens to be registered to them.  By supporting transaction batching at layer 1, we can ensure that the user can get strong guarantees at signing time of cross-transaction atomicity.", "Expiring Transactions": "TransactionType2.  SeeEIP-2718", "Specification": "TransactionType2.  SeeEIP-2718", "Definitions": "TransactionType2.  SeeEIP-2718", "New Transaction Type": "As ofFORK_BLOCK_NUMBERanEIP-2718transaction with aTransactionTypeof2will have itsPayloadinterpreted as an RLP encoded tuple of:", "New Transaction Receipt": "As ofFORK_BLOCK_NUMBERanEIP-2718transaction receipt with aTransactionTypeof2will have itsPayloadinterpreted as arlp([status, cumulativeGasUsed, logsBloom, logs][])where each item of the array corresponds to the child-transaction at matching offset in the transaction type 2Payload.", "Rationale": "This EIP could be split up into multiple EIPs, one for each of the subtypes and one for the meta-type.  Alternatively, each of the subtypes could be a unique TransactionType.  The reason we chose to go with a single EIP with subtypes is because these 4 transactions all have alotin common and each separate EIP would be almost identical to the previous.  We felt that in this case, splitting into multiple EIPs wasn\u2019t worth the duplication of EIP content.", "One Monolithic EIP": "This EIP could be split up into multiple EIPs, one for each of the subtypes and one for the meta-type.  Alternatively, each of the subtypes could be a unique TransactionType.  The reason we chose to go with a single EIP with subtypes is because these 4 transactions all have alotin common and each separate EIP would be almost identical to the previous.  We felt that in this case, splitting into multiple EIPs wasn\u2019t worth the duplication of EIP content.", "ChainID not encoded withv": "While we could save one byte in the common case by bundling the y-parity bit of the signature with the Chain ID like in EIP-155, this adds complexity to signing tools that the authors deem not worth it given the size of the transaction overall.", "Optionality of ChainID": "Sometimes it is useful to have a transaction thatcanbe replayed on multiple chains.  An example of this is when you construct a vanity signature for a transaction and have thefrombe whatever address that signature recovers to.  With the ability to have someone else be a gas payer (setting both the gas limit and the gas price), one can have transactions that deploy contracts which live at the same address on every chain.  While this can be accomplished with CREATE2 using legacy transactions, we have the opportunity here to simplify the process and enable potentially other future uses of deterministic transactions by making ChainID optional.", "Optionality of ValidUntil": "A user can setValidUntilto a very large number which effectively makes it non-expiring.  By makingValidUntiloptional, we can save some bytes on the wire by allowing such transactions to simply have a0(1 byte in RLP) value for this field.", "SENDERsetsgasLimitandgasPrice": "This type of transaction is useful when the transaction may execute differently depending on what these values are set to.  By having theSENDERset both, we ensure that theSENDERhas full control over the transaction details.", "SENDERsetsgasLimit,GAS_PAYERsetsgasPrice": "This type of transaction is useful when the transaction may execute differently depending on how much gas it is allowed (e.g., number of loops) but where theSENDERwould like to give theGAS_PAYERthe ability to price the transaction to maximize chances of inclusion.", "GAS_PAYERsetsgasLimitandgasPrice": "This type of transaction allows theSENDERto define what they want to do, and leaves all worry about gas to theGAS_PAYER.  This is useful for transactions where the sender doesn\u2019t care how much gas is used or the price that is paid and also either trusts theGAS_PAYERto be non-malicious or doesn\u2019t care if theSENDER\u2019s nonce is increased.  Such situations are useful when you have extra-protocol trust between theSENDERandGAS_PAYERand you want to separate concerns (what to do vs how to get included) for security or complexity reasons.", "Nonces": "The inner transaction needs a nonce to protect themselves from replay attacks.  Since the inner transaction has a nonce, we get replay protection on the outer transaction as well, so it is not critical for security to have multiple parties provide a nonce.", "ValidUntil": "For the dust-account clearing usecase,", "ValidUntil as timestamp instead of block number": "No known issues.", "Backwards Compatibility": "No known issues.", "Test Cases": "Copyright and related rights waived viaCC0.", "Implementation": "Copyright and related rights waived viaCC0.", "Security Considerations": "Copyright and related rights waived viaCC0.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2733, "url": "https://eips.ethereum.org/EIPS/eip-2733", "title": "Transaction Package", "authors": ["Matt Garnett\u00a0(", "@lightclient", ")"], "sections": {"EIP-2733: Transaction Package": "Creates a new transaction type which executes a package of one or more\ntransactions, while passing status information to subsequent transactions.", "": "Creates a new transaction type which executes a package of one or more\ntransactions, while passing status information to subsequent transactions.", "Simple Summary": "Creates a new transaction type which executes a package of one or more\ntransactions, while passing status information to subsequent transactions.", "Abstract": "Introduce a new transaction type which includes a list of transactions that\nmust be executed serially by clients. Execution information (e.g. success,\ngas_used, etc.) will be propagated forward to the next transaction.", "Motivation": "Onboarding new users to Ethereum has been notoriously difficult due to the need\nfor new users to acquire enough ether to pay for their transactions. This\nhurdle has seen a significant allocation of resources over the years to solve.\nToday, that solution is meta-transactions. This is, unfortunately, a brittle\nsolution that requires signatures to be recovered within a smart contract to\nauthenticate the message. This EIP aims to provide a flexible framework for\nrelayers to \u201csponsor\u201d many transactions at once, trustlessly.", "Specification": "Introduce a newEIP-2718transaction type whereid = 2.", "Validity": "ATransactionPackagecan be deemed valid or invalid as follows.", "Results": "SubsequentChildTransactions will be able to receive the result of the\npreviousChildTransactionviaRETURNDATACOPY (0x3E)in first frame of\nexecution, before making any subcalls. Each element, except the last, will be0-padded left to 32 bytes.", "Intrinsic Cost": "Let the intrinsic cost of the transaction package be defined as follows:", "Execution": "Transaction packages should be executed as follows:", "Rationale": "For simplicity, the author has chosen to require each child package to specify\nits own signature, even if the signer is the same as the package signer. This\nchoice is made to allow for maximum flexibility, with minimal client changes.\nThis transaction can still be used by a single user at the cost of only one\nadditional signature recovery.", "EachChildhas its own signature": "For simplicity, the author has chosen to require each child package to specify\nits own signature, even if the signer is the same as the package signer. This\nchoice is made to allow for maximum flexibility, with minimal client changes.\nThis transaction can still be used by a single user at the cost of only one\nadditional signature recovery.", "ChildPackagespecifiesmax_gas_priceinstead ofgas_price": "Allowing child packages to specify a range of acceptable gas prices is\nstrictly more versatile than a static price. It gives relayers more flexibility\nin terms of building transaction bundles, and it makes it possible for relayers\nto try and achieve the best price for the transaction sender. With a fixed\nprice, the relayer may require the user to sign multiple different\ntransactions, with varying prices. This can be avoided by specifying a max\nprice, and communicating out-of-band how the urgency of the transaction (e.g.\nthe relayer should package it with the max price immediately vs. slowly\nincreasing the gas price).\nA future transaction type can be specified with only a single\nsignature, if such an optimization is desired.", "ChildPackageis also typed": "The type element serves a modest role in the transaction type, denoting whether\nthe transaction signer wishes to delegate control of the gas price and gas\nlimit to the outer signer. This is a useful UX improvement when interacting\nwith a trusted relayer, as once the user decides to make a transaction the\nrelayer can ensure it is included on chain by choosing the best gas price and\nlimit.", "Theflagsandextrafields aren\u2019t used": "These fields are included to better support future changes to the transaction\ntype. This would likely be used in conjunction with theflagsandtypefields. A benefit of explicitly defining them is that specialized serialization\nof RLP can be avoided, simplifying clients and downstream infrastructure. The\nauthor believe the cost of 2 bytes per transaction is acceptable for smoother\nintegration of future features.", "Backwards Compatibility": "Contracts which rely onORIGIN (0x32) == CALLER (0x33) && RETURNDATASIZE\n(0x3D) == 0x00will now always fail in transaction packages, unless they are\nthe first executed transaction. It\u2019s unknown if any contracts conduct this\ncheck.", "Test Cases": "TBD", "Implementation": "TBD", "Security Considerations": "The introduction of a new transaction type brings along new concerns regarding\nthe mempool. Done naively, it could turn into a DDoS vector for clients. This\nEIP has been written to reduce as much validation complexity as possible.", "Managing packages efficiently in the mempool": "The introduction of a new transaction type brings along new concerns regarding\nthe mempool. Done naively, it could turn into a DDoS vector for clients. This\nEIP has been written to reduce as much validation complexity as possible.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2780, "url": "https://eips.ethereum.org/EIPS/eip-2780", "title": "Reduce intrinsic transaction gas", "authors": ["Matt Garnett\u00a0(", "@lightclient", ")", "Uri Klarman\u00a0(", "@uriklarman", ")"], "sections": {"EIP-2780: Reduce intrinsic transaction gas": "Reduce the intrinsic cost of a transaction from21,000to7,000gas.", "": "Reduce the intrinsic cost of a transaction from21,000to7,000gas.", "Abstract": "Reduce the intrinsic cost of a transaction from21,000to7,000gas.", "Motivation": "The current21,000gas intrinsic cost of a transaction makes sending ETH very costly, often times prohibitively costly for small amounts (tens of USD).\nWhile broad changes to the gas price and first price auction are being considerted in other EIPs (like EIP-1559),\nsubstantially reducing the cost of sending ETH and enabling higher volumes of such transactions would be a net positive if done in a safe manner,\nand without imposing negative externalities, as outlined below.", "Specification": "Afterblock.number >= FORK_BLOCK, enforce an intrinsic gas cost of7,000.", "Rationale": "The proliferation of calls to DeFi smart-contracts had substantially increased the cost of making transactions,\nsince such calls are usually both time sensitive and involve large sums of money.\nWhile the utilization of the chain\u2019s capacity by the most valuable transactions is by design,\nthe high cost of sending transactionsz is limiting Ethereum\u2019s the use-cases,\ncreate a terribel user experience,\ndecreases the actual value created (and captured) by ETH,\nand pushes users to seek alternatives in other, less-congested chains.", "Backwards Compatibility": "This EIP is backward compatible as well as compatible with other approaches pursued in other EIPs.", "Test Cases": "While the benefits of reducing transactions\u2019 intrinsic cost are appearant,\nsuch a change should be applied if it impose no negative externalities,\nor if such effects are negligible.", "Implementation": "TBD", "Security Considerations": "The growth of Ethereum\u2019s state size continues to raise concerns among members of the community.\nHowever, an analysis of Ethereum accounts shows that their effect on stat size is negligible.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 2972, "url": "https://eips.ethereum.org/EIPS/eip-2972", "title": "Wrapped Legacy Transactions", "authors": ["Micah Zoltu\u00a0(", "@MicahZoltu", ")"], "sections": {"EIP-2972: Wrapped Legacy Transactions": "Two new transaction types for wrapping legacy transactions with and without a chain ID.", "": "Two new transaction types for wrapping legacy transactions with and without a chain ID.", "Simple Summary": "Two new transaction types for wrapping legacy transactions with and without a chain ID.", "Abstract": "Introduces two newEIP-2718transactions that are signature compatible with legacy transactions and can be automatically upgraded by any client.", "Motivation": "We would like to eventually deprecate legacy transactions so we no longer have to retain code in the networking and signer layer that deals with them.\nHowever, we also want to ensure that signatures for transactions that were generated prior to that deprecation are still valid and funds don\u2019t end up stuck because of an inability to sign a new style transaction.\nThis EIP provides a mechanism for transmitting/including transactions in a way that isEIP-2718compatible while still being signature compatible with legacy transactions.", "Specification": "As ofFORK_BLOCK_NUMBER,0x00 || ssz.serialize(yParity, r, s, rlp([nonce, gasPrice, gasLimit, to, value, data]))will be a valid transaction where:", "Definitions": "As ofFORK_BLOCK_NUMBER,0x00 || ssz.serialize(yParity, r, s, rlp([nonce, gasPrice, gasLimit, to, value, data]))will be a valid transaction where:", "Transactions": "As ofFORK_BLOCK_NUMBER,0x00 || ssz.serialize(yParity, r, s, rlp([nonce, gasPrice, gasLimit, to, value, data]))will be a valid transaction where:", "Receipts": "As ofFORK_BLOCK_NUMBER,0 || ssz.serialize(status, cumulativeGasUsed, logsBloom, logs)will be a valid receipt where:", "Rationale": "These transaction types are explicitly designed to be signature compatible with legacy transactions, which means we cannot change the data being signed.\nSee Security Considerations section for more details.", "Signature doesn\u2019t include transaction type as first signature byte": "These transaction types are explicitly designed to be signature compatible with legacy transactions, which means we cannot change the data being signed.\nSee Security Considerations section for more details.", "Two transaction types instead of one": "With the introduction of typed transactions, we no longer need to do bit packing to avoid changing the shape of the signature.\nLegacy transactions introduced chain ID inEIP-155and wanted to avoid changing the transaction array length, so it bitpacked the chainID into the signature\u2019svvalue.\nSince we no longer need to guarantee consistent payload lengths between transaction types, we have opted to have two transaction types with clear fields.", "Signature separate from signed data": "When validating a signature, one must first separate out the signed data from the signature and then validate the signature against the signed data.\nIn the case of legacy transactions, this was a bit of a burden since you had to first RLP decode the transaction, then extract out the signature, then RLP encode a subset of the transaction.\nEIP-155 made this process even worse by requiring the validator to further decode thevsignature value to extract the chain ID (if present) and include that in the signed data payload.\nBy having the signed data encoded exactly as it is signed, we make it so one can verify the transaction\u2019s signature without having to do any decoding before hand.\nBy having the signature SSZ encoded up front, we can easily extract the signature without even having to use a decoder.", "SSZ for serialization": "There is a weak consensus that RLP is not a particularly good encoding scheme for hashed data partially due to its inability to be streamed.\nSSZ is almost certainly going to be included in Ethereum at some point in the future, so clients likely have access to an SSZ decoder.\nFor this particular case, manual decoding without a full SSZ decoder isn\u2019t too complicated, though it does require doing a bit of \u201cpointer math\u201d sincelogsis an array of variable length items.", "Deprecating legacy transactions": "By deprecating legacy transactions, we make it easier for clients as they can always deal with typed transactions in blocks.", "Max length of logs and logs data": "EIP-706limits devp2p messages to 24 bit length, which gives us a pragmatic cap at that for any single transaction at the moment.\nThis number seems to far exceed what is reasonable anytime in the near future, so feels like as reasonable of a cap as any.", "Backwards Compatibility": "The new transactions are signature compatible with legacy transactions.\nLegacy transactions can be decoded and then encoded as type 0 or type 1 transactions.\nThis EIP does not introduce any deprecation process for legacy encoded transactions, though the authors do encourage client developers to upgrade legacy encoded transactions to typed transactions as soon as it is reasonable.", "Test Cases": "TBD", "Implementation": "TBD", "Security Considerations": "WhileEIP-2718strongly recommends including the transaction type as the first byte of the signed data, we cannot accomplish that in this case because we need to remain signature compatible with legacy transactions.\nLuckily,EIP-2718also excludes transaction types0xc0to0xfefrom valid transaction types, and the first byte of the signature in this case is in that range so we can be sure this will not conflict with any future transaction types.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3332, "url": "https://eips.ethereum.org/EIPS/eip-3332", "title": "MEDGASPRICE Opcode", "authors": ["Justice Hudson\u00a0(", "@jchancehud", ")"], "sections": {"EIP-3332: MEDGASPRICE Opcode": "An opcode for getting the median gas price of the parent block.", "": "An opcode for getting the median gas price of the parent block.", "Simple Summary": "An opcode for getting the median gas price of the parent block.", "Abstract": "AddsMEDGASPRICE (0x46)opcode that returns the median gas price for the parent block.", "Motivation": "With the emergence of rollups as core mechanisms in scaling Ethereum there are a number of common transactions that can be front-run. Optimistic rollups rely on the submission of fraud proofs to maintain the integrity of their systems. As a result actors submitting fraud proofs typically receive a financial reward for doing so. This opens a trivial front-running strategy of watching the mempool for fraud proof submissions and copying such transactions with a much higher gas price to reap the reward. Such front-runners do not perform validation independently and de-incentivize others from performing validation. Adding a mechanism enforcing an upper bound on gas prices for a transaction could be an effective defense against such front-running attacks.", "Forwards Compatibility": "EIP-1559plans to change the fee market in a number of ways. Most notably is the creation of a base fee that is burned. In this context an \u201cinclusion fee\u201d still exists as a part of the total fee. Consider the following two cases:", "Specification": "Ifblock.number >= TBD, add a new opcodeMEDGASPRICE (0x46):", "Rationale": "Having access to the current gas price economy allows contracts to implement more robust and automated logic surrounding acceptable transaction gas prices.", "Naming note": "The nameMEDGASPRICEwas chosen because the median gas price of the network can only be calculated from the latest complete block. Thus transactions being executed should expect the median gas price to be calculated from the previous block.", "Backwards Compatibility": "There are no known backwards incompabitility issues.", "Security Considerations": "The strategy described for preventing front-running by setting an upper bound on the gas price of transactions has a few caveats:", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3338, "url": "https://eips.ethereum.org/EIPS/eip-3338", "title": "Limit account nonce to 2^52", "authors": ["Micah Zoltu\u00a0(", "@MicahZoltu", ")", "Alex Beregszaszi\u00a0(", "@axic", ")"], "sections": {"EIP-3338: Limit account nonce to 2^52": "Limit account nonce to be between0and2^52.", "": "Limit account nonce to be between0and2^52.", "Abstract": "Limit account nonce to be between0and2^52.", "Motivation": "Account nonces are currently specified to be arbitrarily long unsigned integers. Dealing with arbitrary length data in the state witnesses is not optimal, therefore this EIP will allow proofs to represent the nonce in a more optimized way.", "Specification": "Ifblock.number >= FORK_BLOCKintroduce two new restrictions:", "Rationale": "While this is a breaking change, no actual effect should be visible:", "Backwards Compatibility": "While this is a breaking change, no actual effect should be visible:", "Security Considerations": "None.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3374, "url": "https://eips.ethereum.org/EIPS/eip-3374", "title": "Predictable Proof-of-Work (POW) Sunsetting", "authors": ["Query0x\u00a0(", "@Query0x", ")"], "sections": {"EIP-3374: Predictable Proof-of-Work (POW) Sunsetting": "Sets block reward to 3 and reduces it to 1 linearly over the course of about 1 year.", "": "Sets block reward to 3 and reduces it to 1 linearly over the course of about 1 year.", "Simple Summary": "Sets block reward to 3 and reduces it to 1 linearly over the course of about 1 year.", "Abstract": "Sets the block reward to 3 ETH and then incrementally decreases it every block for 2,362,000 blocks (approximately 1 year) until it reaches 1 ETH.", "Motivation": "Unnecessarily abrupt changes to the Ethereum ecosystem cause disruption and disharmony resulting in the disenfranchisement of community members while undermining stability and confidence.  While moves from Proof-of-Work to Proof-of-Stake will undoubtedly cause friction between those community members vested in either, all benefit from a measured, predictable transition.", "Specification": "Picking starting and ending block reward values that are equidistant from the current block reward rate of 2 ensures the impact of this EIP will be issuance neutral over the one year time frame.  Temporarily raising the block reward to 3 blunts the initial impact of a sudden miner revenue decrease and the continual reductions thereafter codify Ethereum\u2019s move to POS by increasingly disincentivizing POW.  Importantly, this approach moderates the rate of change so impacts and threats can be measured and monitored.", "Constants": "Picking starting and ending block reward values that are equidistant from the current block reward rate of 2 ensures the impact of this EIP will be issuance neutral over the one year time frame.  Temporarily raising the block reward to 3 blunts the initial impact of a sudden miner revenue decrease and the continual reductions thereafter codify Ethereum\u2019s move to POS by increasingly disincentivizing POW.  Importantly, this approach moderates the rate of change so impacts and threats can be measured and monitored.", "Rationale": "Picking starting and ending block reward values that are equidistant from the current block reward rate of 2 ensures the impact of this EIP will be issuance neutral over the one year time frame.  Temporarily raising the block reward to 3 blunts the initial impact of a sudden miner revenue decrease and the continual reductions thereafter codify Ethereum\u2019s move to POS by increasingly disincentivizing POW.  Importantly, this approach moderates the rate of change so impacts and threats can be measured and monitored.", "Backwards Compatibility": "There are no known backward compatibility issues with the introduction of this EIP.", "Security Considerations": "There are no known security issues with the introduction of this EIP.", "Copyright": "Copyright and related rights waived via CC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3382, "url": "https://eips.ethereum.org/EIPS/eip-3382", "title": "Hardcoded Block Gas Limit", "authors": ["Philippe Castonguay\u00a0(", "@PhABC", ")"], "sections": {"EIP-3382: Hardcoded Block Gas Limit": "Hardcode the block gas limit to12,500,000gas per block.", "": "Hardcode the block gas limit to12,500,000gas per block.", "Simple Summary": "Hardcode the block gas limit to12,500,000gas per block.", "Abstract": "Updates the block validation rules such that a block is invalid if thegas_limitheader field is not equal to12,500,000.", "Motivation": "Both Ethereum\u2019s Proof of Work and Proof of Stake designs assume that block producers are financially rational, but does not assume block producers to be benevolent. There is one exception however, and it is when block producers choose the gas limit of a block where it is assumed that block producers care about the long term health and decentralisation of the chain. Indeed, the block gas limit is one of the only parameters in Ethereum that is not dictated by node consensus, but instead is chosen by block producers. This decision was initially made to allow urgent changes in the block gas limit if necessary. Both drastically increasing or decreasing this parameter could have serious consequences that may not be desired. It is therefore a critical parameter that should require node consensus to avoid any sudden harmful change imposed by a small number of actors on the rest of the network.", "Specification": "Refer togasLimitasgasTargetpost EIP-1559.", "Added Consensus Constraint": "As ofFORK_BLOCK_NUMBER, theheader.gasLimitMUSTbe equal toBLOCK_GAS_LIMIT, whereBLOCK_GAS_LIMITis a hardcoded constant set to12,500,000.", "Rationale": "While it would be possible to remove thegasLimitfield from block headers, it would change the data structure to be hashed, which could lead to unintended consequences. It is therefore easier to leave the gasLimit as part of block headers.", "Keeping gasLimit in Block Headers": "While it would be possible to remove thegasLimitfield from block headers, it would change the data structure to be hashed, which could lead to unintended consequences. It is therefore easier to leave the gasLimit as part of block headers.", "Chosen Gas Limit": "The12,500,000value is being proposed as it\u2019s the current block gas limit as of time of writing this EIP. The actual amount could be altered with a subsequent EIP to avoid deviating from the core intent of this EIP.", "Backwards Compatibility": "This EIP is backward compatible.", "Security Considerations": "Rapid changes to the gas limit will likely be more difficult to execute, which could be problematic if an urgent situation arise that required changing the gas limit.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 3779, "url": "https://eips.ethereum.org/EIPS/eip-3779", "title": "Safer Control Flow for the EVM", "authors": ["Greg Colvin\u00a0(", "@gcolvin", ")", "Greg Colvin\u00a0<", "greg@colvin.org", ">", "Brooklyn Zelenka\u00a0(", "@expede", ")"], "sections": {"EIP-3779: Safer Control Flow for the EVM": "We define a safe EVM contract as one that cannot encounter an exceptional halting state.  In general, we cannot prove safety for Turing-complete programs. But we can prove a useful subset.", "Ensure an essential level of safety for EVM code.": "We define a safe EVM contract as one that cannot encounter an exceptional halting state.  In general, we cannot prove safety for Turing-complete programs. But we can prove a useful subset.", "Abstract": "We define a safe EVM contract as one that cannot encounter an exceptional halting state.  In general, we cannot prove safety for Turing-complete programs. But we can prove a useful subset.", "Motivation": "For our purposes we define a safe EVM contract as one that cannot encounter an exceptional halting state.  From the standpoint of security it would be best if unsafe contracts were never placed on the blockchain.  Unsafe code can attempt to overflow stack, underflow stack, execute invalid instructions, and jump to invalid locations.", "Safety": "For our purposes we define a safe EVM contract as one that cannot encounter an exceptional halting state.  From the standpoint of security it would be best if unsafe contracts were never placed on the blockchain.  Unsafe code can attempt to overflow stack, underflow stack, execute invalid instructions, and jump to invalid locations.", "Performance": "Validating safe control flow at initialization time has potential performance advantages.", "Specification": "We define asafeEVM contract as one that cannot encounter an exceptional halting state.  We validatesafetyat initialization time to the extent practical.", "Validity": "We define asafeEVM contract as one that cannot encounter an exceptional halting state.  We validatesafetyat initialization time to the extent practical.", "Rationale": "Demandingstaticdestinations for all jumps means that all jump destinations can be validated at initialization time, not runtime.", "Backwards Compatibility": "These changes affect the semantics of EVM code \u2013 the use ofJUMP,JUMPI, and the stack are restricted, such that somecodethat would otherwise run correctly will nonetheless be invalid EVMcode.", "Reference Implementation": "The following is a pseudo-Go implementation of an algorithm for predicating code validity.  An equivalent algorithm must be run at initialization time.", "Validation Function": "Note:This function is a work in progress, and the version below is known to be incorrect.", "Security Considerations": "This EIP is intended to ensure an essential level of safety for EVM code deployed on the blockchain.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 6913, "url": "https://eips.ethereum.org/EIPS/eip-6913", "title": "SETCODE instruction", "authors": ["William Morriss\u00a0(", "@wjmelements", ")"], "sections": {"EIP-6913: SETCODE instruction": "Introduce theSETCODE(0xfc) instruction, which replaces the code of the executing account from memory.", "new instruction to replace code in-place": "Introduce theSETCODE(0xfc) instruction, which replaces the code of the executing account from memory.", "Abstract": "Introduce theSETCODE(0xfc) instruction, which replaces the code of the executing account from memory.", "Motivation": "Many contracts are upgradeable in order to facilitate improvement or defer decisions without migrating to a new address.\nContracts presently do this in several ways:", "Specification": "When within a read-only execution scope like the recursive kind created bySTATICCALL,SETCODEcauses an exceptional abort.", "Gas": "The gas cost of this operation is the sum ofGselfdestructand the product ofGcodedepositand the number of bytes in the new code.", "Rationale": "The behavior ofCODECOPY,CODESIZE,EXTCODESIZE, andEXTCODECOPYmatch the behavior ofDELEGATECALLandCREATE, where it is also possible for executing code to differ from the code of the executing account.", "Backwards Compatibility": "The only prior operation changing code isSELFDESTRUCT.\nAs code modification viaSELFDESTRUCTis deferred until the end of the transaction, its interactions withSETCODEare well-defined.", "Test Cases": "Risks related toSETCODEsimilarly apply to other upgrade patterns.", "Security Considerations": "Risks related toSETCODEsimilarly apply to other upgrade patterns.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
{"eip": 7664, "url": "https://eips.ethereum.org/EIPS/eip-7664", "title": "Access-Key opcode", "authors": ["Diederik Loerakker\u00a0(", "@protolambda", ")"], "sections": {"EIP-7664: Access-Key opcode": "This EIP introduces a new opcode to inspect the access-list keys of the executing address.", "The access-key opcode enables contracts to read inputs that are statically declared in access-lists.": "This EIP introduces a new opcode to inspect the access-list keys of the executing address.", "Abstract": "This EIP introduces a new opcode to inspect the access-list keys of the executing address.", "Motivation": "This EIP serves as a substitute of top-level-call detection to enable a smart-contract to \nenforce static declaration of attributes.", "Specification": "We add an instructionACCESS_KEY(with opcodeACCESS_KEY_OPCODE_BYTE) which popsindexfrom the top\nof the stack as big-endianuint256, and pushestx.access_list[address][index]back on the stack,\nifaddressis present in thetx.access_listandindex < len(tx.access_list[address]),\nand otherwise pushes a zeroedbytes32value.", "Parameters": "We add an instructionACCESS_KEY(with opcodeACCESS_KEY_OPCODE_BYTE) which popsindexfrom the top\nof the stack as big-endianuint256, and pushestx.access_list[address][index]back on the stack,\nifaddressis present in thetx.access_listandindex < len(tx.access_list[address]),\nand otherwise pushes a zeroedbytes32value.", "Opcode": "We add an instructionACCESS_KEY(with opcodeACCESS_KEY_OPCODE_BYTE) which popsindexfrom the top\nof the stack as big-endianuint256, and pushestx.access_list[address][index]back on the stack,\nifaddressis present in thetx.access_listandindex < len(tx.access_list[address]),\nand otherwise pushes a zeroedbytes32value.", "Gas costs": "The gas cost ofACCESS_KEY_OPCODE_GASgas matches that of similar operations,\nspecifically theBLOBHASHopcode ofEIP-4844:\nthis opcode also pop an index-like EVM word from the stack,\nand pushes a full 32 byte EVM word back on the stack, based on a list of hashes embedded in the transaction.", "Rationale": "Static declaration of contract-inputs enables advanced layer-two constructions and block-building techniques:\ndata is available without EVM introspection, and contracts can reliably tell if the executing transaction\ndeclared critical properties to the block builder and verifying nodes.", "Static analysis of transactions": "Static declaration of contract-inputs enables advanced layer-two constructions and block-building techniques:\ndata is available without EVM introspection, and contracts can reliably tell if the executing transaction\ndeclared critical properties to the block builder and verifying nodes.", "Global read-only values": "Akin toTLOAD, as described inEIP-1153,\ntheACCESS_KEYopcode provides contracts with a view that is global\nto the message-execution of the transaction in the EVM.", "Access-list utility": "Access-lists are under-utilized today:\nvery few users utilize this to warm-up storage interactions for reduced gas costs.\nGenerally the gas cost savings achieved with EIP-2930 are not applicable in as many use-cases.", "Witness data": "This EIP supports the transformation of applications to reduce statefulness,\nby supporting read-only application state to be provided to contracts without\nrequiring the contract caller to support forwarding of data.", "Naming ofACCESS_KEY": "Access-lists currently only support a list of access-keys.\nThe list is not enforced to be sorted, and thus supports indexed lookups.", "Backwards Compatibility": "This enhancement of access-lists utility does not affect the access-list encoding,\nor the existing transaction types that support access-lists.", "No transaction-type changes": "This enhancement of access-lists utility does not affect the access-list encoding,\nor the existing transaction types that support access-lists.", "Minimal impact on EVM transaction-context": "With EIP-2930, the access-list contents are already readily available in the transaction-context during EVM execution,\nand the RPC methods that trigger said execution.", "Test Cases": "The block fee-recipient, and any other warmed-up attributes not declared statically in the transaction access-list,\nmust not be considered to be part of the access-list.", "Security Considerations": "The access-list attributes are already gas-metered in EIP-2930,\nand readily accessible in the EVM to determine storage gas-costs. In terms of denial-of-service risks,\nthis EIP introduces no new significant data or data-processing costs.", "Copyright": "Copyright and related rights waived viaCC0.", "Citation": "Please cite this document as:"}, "content_type": "core-eip"}
